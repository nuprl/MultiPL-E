name: HumanEval_129_minPath
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows\
  \ and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains\
  \ a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once\
  \ on the cells of the grid.\n// You have to find the minimum path of length k in\
  \ the grid. You can start\n// from any cell, and in each step you can move to any\
  \ of the neighbor cells,\n// in other words, you can go to cells which share an\
  \ edge with you current\n// cell.\n// Please note that a path of length k means\
  \ visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off\
  \ the grid.\n// A path A (of length k) is considered less than a path B (of length\
  \ k) if\n// after making the ordered lists of the values on the cells that A and\
  \ B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically\
  \ less\n// than lst_B, in other words, there exist an integer index i (1 <= i <=\
  \ k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j]\
  \ = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered\
  \ list of the values on the cells that the minimum path go through.\n// Examples:\n\
  std::vector<long> minPath(std::vector<std::vector<long>> grid, long k) {\n"
tests: "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) ==\
  \ (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5,\
  \ (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) ==\
  \ (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6,\
  \ (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11,\
  \ (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15,\
  \ (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n\
  \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6,\
  \ (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5,\
  \ (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16,\
  \ (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14,\
  \ (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1,\
  \ (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8,\
  \ (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4,\
  \ (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7,\
  \ (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10,\
  \ (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1,\
  \ (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11,\
  \ (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16,\
  \ (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15,\
  \ (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10,\
  \ (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6,\
  \ (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12,\
  \ (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9,\
  \ (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16,\
  \ (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8,\
  \ (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1,\
  \ (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n\
  \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2,\
  \ (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}),\
  \ (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) ==\
  \ (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1,\
  \ (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6,\
  \ (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}),\
  \ (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) ==\
  \ (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1,\
  \ (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10))\
  \ == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1,\
  \ (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10))\
  \ == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1,\
  \ (long)3, (long)1, (long)3})));\n}\n"
completions: ["    std::vector<long> res;\n    // Write your code here\n    return\
    \ res;", "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<int>> parent(n, std::vector<int>(n,\
    \ -1));\n    std::vector<std::vector<int>> prev(n, std::vector<int>(n, -1));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n          \
    \      parent[i][j] = -1;\n                prev[i][j] = -1;\n            } else\
    \ if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n     \
    \           parent[i][j] = 0;\n                prev[i][j] = j - 1;\n         \
    \   } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                parent[i][j] = 1;\n                prev[i][j] = i - 1;\n    \
    \        } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n      \
    \              dp[i][j] = dp[i - 1][j] + grid[i][j];\n                    parent[i][j]\
    \ = 1;\n                    prev[i][j] = i - 1;\n                } else {\n  \
    \                  dp[i][j] = dp[i][j - 1] + grid[i][j];\n                   \
    \ parent[i][j] = 0;\n                    prev[i][j] = j - 1;\n               \
    \ }\n            }\n        }\n    }\n    std::vector<long> ans;\n    int i =\
    \ n - 1, j = n - 1;\n    while (k > 0) {\n        ans.push_back(grid[i][j]);\n\
    \        if (parent[i][j] == 0) {\n            j = prev[i][j];", "    int n =\
    \ grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ LONG_MAX));\n    std::vector<std::vector<std::vector<long>>> prev(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(n * n, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ next(n, std::vector<std::vector<long>>(n, std::vector<long>(n * n, -1)));\n\
    \    std::vector<std::vector<std::vector<long>>> dist(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(n * n, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(n * n, -1)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j] = grid[i][j];\n            prev[i][j][grid[i][j]] = -1;\n\
    \            next[i][j][grid[i][j]] = -1;\n            dist[i][j][grid[i][j]]\
    \ = 0;\n            path[i][j][grid[i][j]] = grid[i][j];\n        }\n    }\n \
    \   for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n   \
    \         for (int x = 0; x < n; x++) {\n                for (int y = 0; y < n;\
    \ y++) {\n                    if (x == i && y == j) {\n                      \
    \  continue;\n                    }\n                    for (int v = 1; v <=\
    \ n * n; v++) {\n                        if (prev[x][y][v] == -1) {\n        \
    \                    continue;\n                        }\n                  \
    \      long new_dist = dist[x][y][v] + 1;\n                        if (new_dist\
    \ > k) {\n                ", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<long>> parent(n,\
    \ std::vector<long>(n, -1));\n    std::vector<std::vector<long>> path(n, std::vector<long>(n,\
    \ -1));\n    std::vector<std::vector<long>> visited(n, std::vector<long>(n, 0));\n\
    \    std::vector<std::vector<long>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\
    \    std::vector<long> ans;\n    std::queue<std::pair<int, int>> q;\n    q.push({0,\
    \ 0});\n    dp[0][0] = grid[0][0];\n    parent[0][0] = -1;\n    visited[0][0]\
    \ = 1;\n    while (!q.empty()) {\n        int x = q.front().first;\n        int\
    \ y = q.front().second;\n        q.pop();\n        for (int i = 0; i < 4; i++)\
    \ {\n            int nx = x + dir[i][0];\n            int ny = y + dir[i][1];\n\
    \            if (nx >= 0 && nx < n && ny >= 0 && ny < n && !visited[nx][ny]) {\n\
    \                visited[nx][ny] = 1;\n                dp[nx][ny] = dp[x][y] +\
    \ grid[nx][ny];\n                parent[nx][ny] = x * n + y;\n               \
    \ q.push({nx, ny});\n            }\n        }\n    }\n    int x = n - 1;\n   \
    \ int y = n - 1;\n    while (k) {\n        ans.push_back(grid[x][y]);\n      \
    \  path[x][y] = 1;\n        int p = parent[x][y];\n        x = p / n;\n      \
    \  y = p % n;\n        k--;\n    }\n    return ans;", "    // Write your code\
    \ here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, 0));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(m, -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(m,\
    \ 0));\n    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n    std::priority_queue<std::pair<long, std::pair<int, int>>,\n      \
    \                  std::vector<std::pair<long, std::pair<int, int>>>,\n      \
    \                  std::greater<std::pair<long, std::pair<int, int>>>>\n     \
    \   pq;\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n    while\
    \ (!pq.empty()) {\n        auto [val, pos] = pq.top();\n        pq.pop();\n  \
    \      int x = pos.first;\n        int y = pos.second;\n        visited[x][y]\
    \ = 1;\n        for (auto [dx, dy] : dir) {\n            int nx = x + dx;\n  \
    \          int ny = y + dy;\n            if (nx < 0 || nx >= n || ny < 0 || ny\
    \ >= m || visited[nx][ny])\n                continue;\n            if (dp[nx][ny]\
    \ == 0 || dp[nx][ny] > dp[x][y] + grid[nx][ny]) {\n                dp[nx][ny]\
    \ = dp[x][y] + grid[nx][ny];\n                parent[nx][ny] = x * m + y;\n  \
    \              pq.push({dp[nx][ny], {nx, ny}});\n            }\n        }\n  \
    \  }\n    std::vector<long> ans;\n    int x = n - 1;\n    int", "  // Write your\
    \ code here\n  int n = grid.size();\n  std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n  for (int i = 0; i < n; i++) {\n    for (int\
    \ j = 0; j < n; j++) {\n      dp[i][j][1] = grid[i][j];\n      path[i][j][1].push_back(grid[i][j]);\n\
    \    }\n  }\n  for (int l = 2; l <= k; l++) {\n    for (int i = 0; i < n; i++)\
    \ {\n      for (int j = 0; j < n; j++) {\n        long min = -1;\n        std::vector<long>\
    \ minPath;\n        if (i - 1 >= 0) {\n          if (dp[i - 1][j][l - 1] != -1)\
    \ {\n            if (min == -1 || min > dp[i - 1][j][l - 1]) {\n             \
    \ min = dp[i - 1][j][l - 1];\n              minPath = path[i - 1][j][l - 1];\n\
    \            }\n          }\n        }\n        if (i + 1 < n) {\n          if\
    \ (dp[i + 1][j][l - 1] != -1) {\n            if (min == -1 || min > dp[i + 1][j][l\
    \ - 1]) {\n              min = dp[i + 1][j][l - 1];\n              minPath = path[i\
    \ + 1][j][l - 1];\n            }\n          }\n        }\n        if (j - 1 >=\
    \ 0) {\n          if (dp[i][j - 1][l - 1] != -1) {\n            if (min == -1",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j] = path[i][j - 1];\n\
    \                path[i][j][dp[i][j]] = grid[i][j];\n            }\n         \
    \   else if(j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n        \
    \        path[i][j] = path[i - 1][j];\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            }\n            else {\n                dp[i][j] = std::min(dp[i\
    \ - 1][j], dp[i][j - 1]) + 1;\n                if(dp[i - 1][j] < dp[i][j - 1])\
    \ {\n                    path[i][j] = path[i - 1][j];\n                    path[i][j][dp[i][j]]\
    \ = grid[i][j];\n                }\n                else if(dp[i - 1][j] > dp[i][j\
    \ - 1]) {\n                    path[i][j] = path[i][j - 1];\n                \
    \    path[i][j][dp[i][j]] = grid[i][j];\n                }\n                else\
    \ {\n                    path[i][j] = path[i - 1][j];\n                    path[i][j][dp[i][",
  "  int n = grid.size();\n  std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n  std::vector<std::vector<std::vector<long>>> prev(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n  for (int i = 0; i < n; ++i) {\n    for (int\
    \ j = 0; j < n; ++j) {\n      dp[i][j] = grid[i][j];\n      prev[i][j][1] = grid[i][j];\n\
    \    }\n  }\n  for (int len = 2; len <= k; ++len) {\n    for (int i = 0; i < n;\
    \ ++i) {\n      for (int j = 0; j < n; ++j) {\n        if (i > 0 && dp[i - 1][j]\
    \ < dp[i][j]) {\n          dp[i][j] = dp[i - 1][j];\n          prev[i][j][len]\
    \ = prev[i - 1][j][len - 1];\n        }\n        if (j > 0 && dp[i][j - 1] < dp[i][j])\
    \ {\n          dp[i][j] = dp[i][j - 1];\n          prev[i][j][len] = prev[i][j\
    \ - 1][len - 1];\n        }\n        if (i < n - 1 && dp[i + 1][j] < dp[i][j])\
    \ {\n          dp[i][j] = dp[i + 1][j];\n          prev[i][j][len] = prev[i +\
    \ 1][j][len - 1];\n        }\n        if (j < n - 1 && dp[i][j + 1] < dp[i][j])\
    \ {\n          dp[i][j] = dp[i][j + 1];\n          prev[i][j][len] = prev[i][j\
    \ + 1][len - 1];\n        }\n        if (prev[i][j][len] != -1", "  // Write your\
    \ code here\n  int n = grid.size();\n  std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n  std::vector<std::vector<long>> path(n, std::vector<long>(n, -1));\n\
    \  std::vector<std::vector<long>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\
    \  std::vector<std::vector<long>> visited(n, std::vector<long>(n, 0));\n  std::vector<long>\
    \ ans;\n  std::queue<std::pair<int, int>> q;\n  q.push({0, 0});\n  dp[0][0] =\
    \ grid[0][0];\n  while (!q.empty()) {\n    auto curr = q.front();\n    q.pop();\n\
    \    visited[curr.first][curr.second] = 1;\n    for (auto d : dir) {\n      int\
    \ x = curr.first + d[0];\n      int y = curr.second + d[1];\n      if (x < 0 ||\
    \ x >= n || y < 0 || y >= n) {\n        continue;\n      }\n      if (visited[x][y])\
    \ {\n        continue;\n      }\n      if (dp[x][y] > dp[curr.first][curr.second]\
    \ + grid[x][y]) {\n        dp[x][y] = dp[curr.first][curr.second] + grid[x][y];\n\
    \        path[x][y] = curr.first * n + curr.second;\n      }\n      q.push({x,\
    \ y});\n    }\n  }\n  int x = n - 1;\n  int y = n - 1;\n  while (k--) {\n    ans.push_back(grid[x][y]);\n\
    \    int prev = path[x][y];\n    x = prev / n;\n    y = prev % n;\n  }\n  return\
    \ ans;", "\tint n = grid.size();\n\tstd::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\t\
    std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n\tfor (int\
    \ i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tdp[i][j][1] =\
    \ grid[i][j];\n\t\t\tprev[i][j][1][0] = i;\n\t\t\tprev[i][j][1][1] = j;\n\t\t\
    }\n\t}\n\tfor (int l = 2; l <= k; ++l) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\
    \t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tfor (int x = 0; x < n; ++x) {\n\t\t\
    \t\t\tfor (int y = 0; y < n; ++y) {\n\t\t\t\t\t\tif (std::abs(x - i) + std::abs(y\
    \ - j) == 1 && dp[x][y][l - 1] != -1) {\n\t\t\t\t\t\t\tif (dp[i][j][l] == -1 ||\
    \ dp[i][j][l] > dp[x][y][l - 1] * 10 + grid[i][j]) {\n\t\t\t\t\t\t\t\tdp[i][j][l]\
    \ = dp[x][y][l - 1] * 10 + grid[i][j];\n\t\t\t\t\t\t\t\tprev[i][j][l][0] = x;\n\
    \t\t\t\t\t\t\t\tprev[i][j][l][1] = y;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}", "    std::vector<long>\
    \ res;\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j\
    \ < n; j++) {\n            if (dp[i][j][k] < min) {\n                min = dp[i][j][k];\n\
    \            }\n        }\n    }\n    std::vector<std::vector<long>> prev(n, std::vector<long>(n,\
    \ -1));\n    for (int i =", "  // your code goes here\n  int n = grid.size();\n\
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n  for\
    \ (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      path[i][j][0]\
    \ = grid[i][j];\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j =\
    \ 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp[i][j] = 0;\n   \
    \   } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + 1;\n        path[i][j]\
    \ = path[i][j - 1];\n      } else if (j == 0) {\n        dp[i][j] = dp[i - 1][j]\
    \ + 1;\n        path[i][j] = path[i - 1][j];\n      } else {\n        dp[i][j]\
    \ = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;\n        if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n          path[i][j] = path[i - 1][j];\n        } else {\n        \
    \  path[i][j] = path[i][j - 1];\n        }\n      }\n    }\n  }\n  return path[n\
    \ - 1][n - 1];", "    std::vector<long> result;\n    // your code goes here\n\
    \    return result;", "    // Write your code here\n    long n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k+1, 0)));\n    for(long i = 0; i < n; i++) {\n        for(long\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j][1] = grid[i][j];\n            }\n\
    \            else if(i == 0) {\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                path[i][j][1] = grid[i][j];\n            }\n            else\
    \ if(j == 0) {\n                dp[i][j] = dp[i-1][j] + grid[i][j];\n        \
    \        path[i][j][1] = grid[i][j];\n            }\n            else {\n    \
    \            dp[i][j] = std::min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n     \
    \           path[i][j][1] = grid[i][j];\n            }\n        }\n    }\n   \
    \ for(long i = 0; i < n; i++) {\n        for(long j = 0; j < n; j++) {\n     \
    \       if(i == 0 && j == 0) {\n                continue;\n            }\n   \
    \         else if(i == 0) {\n                for(long l = 2; l <= k; l++) {\n\
    \                    path[i][j][l] = path[i][j-1][l-1];\n                }\n \
    \           }\n            else if(j == 0) {\n                for(long l = 2;\
    \ l <= k; l++) {\n                    path[i][j][l] = path[i-1][j][l-1];\n   \
    \             }\n", "  // your code goes here\n  std::vector<long> ans;\n  int\
    \ n = grid.size();\n  int m = grid[0].size();\n  std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n  std::vector<std::vector<long>> path(n,\
    \ std::vector<long>(m, 0));\n  std::vector<std::vector<long>> dir = {{0, 1}, {0,\
    \ -1}, {1, 0}, {-1, 0}};\n  std::queue<std::pair<int, int>> q;\n  q.push({0, 0});\n\
    \  dp[0][0] = 0;\n  while (!q.empty()) {\n    auto p = q.front();\n    q.pop();\n\
    \    for (auto d : dir) {\n      int x = p.first + d[0];\n      int y = p.second\
    \ + d[1];\n      if (x < 0 || x >= n || y < 0 || y >= m) continue;\n      if (dp[x][y]\
    \ > dp[p.first][p.second] + 1) {\n        dp[x][y] = dp[p.first][p.second] + 1;\n\
    \        path[x][y] = grid[p.first][p.second];\n        q.push({x, y});\n    \
    \  } else if (dp[x][y] == dp[p.first][p.second] + 1) {\n        path[x][y] = std::min(path[x][y],\
    \ grid[p.first][p.second]);\n      }\n    }\n  }\n  int x = n - 1, y = m - 1;\n\
    \  while (k > 0) {\n    ans.push_back(grid[x][y]);\n    k--;\n    int p = path[x][y];\n\
    \    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n    \
    \    if (grid[i][j] == p) {\n          x = i;\n          y = j;\n          break;\n\
    \       ", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, LONG_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n \
    \   for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n   \
    \         if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n  \
    \              path[i][j][1] = grid[i][j];\n            } else if (i == 0) {\n\
    \                dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j][1]\
    \ = grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] =\
    \ dp[i - 1][j] + grid[i][j];\n                path[i][j][1] = grid[i][j];\n  \
    \          } else {\n                dp[i][j] = std::min(dp[i - 1][j], dp[i][j\
    \ - 1]) + grid[i][j];\n                path[i][j][1] = grid[i][j];\n         \
    \   }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j\
    \ = 0; j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n           \
    \     if (i == 0 && j == 0) {\n                    path[i][j][l] = grid[i][j];\n\
    \                } else if (i == 0) {\n                    path[i][j][l] = path[i][j\
    \ - 1][l - 1] + grid[i][j];\n                } else if (j == 0) {\n          \
    \          path[i][j][l] = path[i - 1][j][l - 1] + grid[i][j];\n             \
    \   } else {\n", "  // your code goes here\n  std::vector<long> ans;\n  int n\
    \ = grid.size();\n  int m = grid[0].size();\n  std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, 0));\n  std::vector<std::vector<long>> path(n, std::vector<long>(m,\
    \ 0));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n \
    \     dp[i][j] = grid[i][j];\n      path[i][j] = grid[i][j];\n    }\n  }\n  for\
    \ (int i = 1; i < k; i++) {\n    for (int j = 0; j < n; j++) {\n      for (int\
    \ l = 0; l < m; l++) {\n        int min_val = INT_MAX;\n        int min_val_idx\
    \ = -1;\n        if (j > 0) {\n          if (dp[j - 1][l] < min_val) {\n     \
    \       min_val = dp[j - 1][l];\n            min_val_idx = 0;\n          }\n \
    \       }\n        if (j < n - 1) {\n          if (dp[j + 1][l] < min_val) {\n\
    \            min_val = dp[j + 1][l];\n            min_val_idx = 1;\n         \
    \ }\n        }\n        if (l > 0) {\n          if (dp[j][l - 1] < min_val) {\n\
    \            min_val = dp[j][l - 1];\n            min_val_idx = 2;\n         \
    \ }\n        }\n        if (l < m - 1) {\n          if (dp[j][l + 1] < min_val)\
    \ {\n            min_val = dp[j][l + 1];\n            min_val_idx = 3;\n     \
    \     }\n        }\n        if (min_val_idx == 0) {\n          dp[j][l] = min_val\
    \ + grid[j][l];\n          path[j][l", "    // Write your code here\n    int n\
    \ = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<long>> path(n,\
    \ std::vector<long>(m, -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(m,\
    \ 0));\n    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n    std::priority_queue<std::pair<long, std::pair<int, int>>,\n      \
    \                  std::vector<std::pair<long, std::pair<int, int>>>,\n      \
    \                  std::greater<std::pair<long, std::pair<int, int>>>>\n     \
    \   pq;\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n    while\
    \ (!pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n        int\
    \ x = top.second.first;\n        int y = top.second.second;\n        if (visited[x][y])\
    \ continue;\n        visited[x][y] = 1;\n        for (int i = 0; i < 4; i++) {\n\
    \            int nx = x + dir[i][0];\n            int ny = y + dir[i][1];\n  \
    \          if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n           \
    \ if (dp[nx][ny] > dp[x][y] + grid[nx][ny]) {\n                dp[nx][ny] = dp[x][y]\
    \ + grid[nx][ny];\n                path[nx][ny] = i;\n                pq.push({dp[nx][ny],\
    \ {nx, ny}});\n            }\n        }\n    }\n    std::vector<long> ans;\n \
    \   int x = n - 1;\n   ", "    // Write your code here\n    std::vector<long>\
    \ res;\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(i ==\
    \ 0 && j == 0){\n                dp[i][j] = 0;\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(i == 0){\n                dp[i][j] = dp[i][j-1]\
    \ + 1;\n                path[i][j] = path[i][j-1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(j == 0){\n                dp[i][j] = dp[i-1][j]\
    \ + 1;\n                path[i][j] = path[i-1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else{\n                if(dp[i-1][j] < dp[i][j-1]){\n\
    \                    dp[i][j] = dp[i-1][j] + 1;\n                    path[i][j]\
    \ = path[i-1][j];\n                    path[i][j].push_back(grid[i][j]);\n   \
    \             }\n                else if(dp[i-1][j] > dp[i][j-1]){\n         \
    \           dp[i][j] = dp[i][j-1] + 1;\n                    path[i][j] = path[i][j-1];\n\
    \                    path[i][j].push_back(grid[i][j]);\n                }\n  \
    \              else{\n                    dp[i][j] = dp[i-", "    // Write your\
    \ code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2;\
    \ len <= k; len++) {\n        for (int i = 0; i < n; i++) {\n            for (int\
    \ j = 0; j < n; j++) {\n                if (i > 0) {\n                    dp[i][j][len]\
    \ = std::min(dp[i][j][len], dp[i - 1][j][len - 1]);\n                }\n     \
    \           if (i < n - 1) {\n                    dp[i][j][len] = std::min(dp[i][j][len],\
    \ dp[i + 1][j][len - 1]);\n                }\n                if (j > 0) {\n \
    \                   dp[i][j][len] = std::min(dp[i][j][len], dp[i][j - 1][len -\
    \ 1]);\n                }\n                if (j < n - 1) {\n                \
    \    dp[i][j][len] = std::min(dp[i][j][len], dp[i][j + 1][len - 1]);\n       \
    \         }\n                dp[i][j][len] += grid[i][j];\n            }\n   \
    \     }\n    }\n    long min_val = INT_MAX;\n    int min_i = -1, min_j = -1;\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n\
    \                min_i = i;\n                min_j = j;\n            }\n     \
    \   }\n", "    // Write your code here\n    int n = grid.size();\n    int m =\
    \ grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<int>> prev(n, std::vector<int>(m, -1));\n\
    \    std::vector<std::vector<int>> next(n, std::vector<int>(m, -1));\n    std::vector<std::vector<int>>\
    \ visited(n, std::vector<int>(m, 0));\n    std::vector<std::vector<int>> path(n,\
    \ std::vector<int>(m, 0));\n    std::vector<std::vector<int>> path_index(n, std::vector<int>(m,\
    \ 0));\n    std::vector<std::vector<int>> path_prev(n, std::vector<int>(m, -1));\n\
    \    std::vector<std::vector<int>> path_next(n, std::vector<int>(m, -1));\n  \
    \  std::vector<std::vector<int>> path_visited(n, std::vector<int>(m, 0));\n  \
    \  std::vector<std::vector<int>> path_visited_prev(n, std::vector<int>(m, 0));\n\
    \    std::vector<std::vector<int>> path_visited_next(n, std::vector<int>(m, 0));\n\
    \    std::vector<std::vector<int>> path_visited_prev_prev(n, std::vector<int>(m,\
    \ 0));\n    std::vector<std::vector<int>> path_visited_next_next(n, std::vector<int>(m,\
    \ 0));\n    std::vector<std::vector<int>> path_visited_prev_prev_prev(n, std::vector<int>(m,\
    \ 0));\n    std::vector<std::vector<int>> path_visited_next_next_next(n, std::vector<int>(m,\
    \ 0));\n    std::vector<std::vector<int>> path_visited_prev_prev_prev_prev(n,\
    \ std::vector<int>(m, 0));", "    // Write your code here\n    long n = grid.size();\n\
    \    long m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k, INT_MAX)));\n \
    \   for(long i = 0; i < n; i++){\n        for(long j = 0; j < m; j++){\n     \
    \       dp[i][j][0] = grid[i][j];\n        }\n    }\n    for(long i = 0; i < n;\
    \ i++){\n        for(long j = 0; j < m; j++){\n            for(long l = 1; l <\
    \ k; l++){\n                if(i > 0){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1]);\n                }\n                if(j > 0){\n     \
    \               dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n  \
    \              }\n                if(i < n - 1){\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n                }\n         \
    \       if(j < m - 1){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n            }\n        }\n    }\n\
    \    std::vector<long> ans;\n    long i = 0, j = 0;\n    for(long l = 0; l < k;\
    \ l++){\n        ans.push_back(grid[i][j]);\n        if(i > 0 && dp[i][j][l +\
    \ 1] == dp[i - 1][j][l]){\n            i--;\n        }\n        else if(j > 0\
    \ && dp[i][j][l + 1] == dp[i][j - 1][l]){\n            j--;", "    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<int>> parent(n, std::vector<int>(n, -1));\n    std::vector<std::vector<int>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<std::vector<int>>\
    \ visited(n, std::vector<int>(n, 0));\n    std::queue<std::pair<int, int>> q;\n\
    \    q.push({0, 0});\n    dp[0][0] = grid[0][0];\n    visited[0][0] = 1;\n   \
    \ while (!q.empty()) {\n        auto p = q.front();\n        q.pop();\n      \
    \  for (auto d : dir) {\n            int x = p.first + d[0];\n            int\
    \ y = p.second + d[1];\n            if (x < 0 || x >= n || y < 0 || y >= n ||\
    \ visited[x][y]) {\n                continue;\n            }\n            visited[x][y]\
    \ = 1;\n            dp[x][y] = dp[p.first][p.second] + grid[x][y];\n         \
    \   parent[x][y] = p.first * n + p.second;\n            q.push({x, y});\n    \
    \    }\n    }\n    std::vector<long> ans;\n    int x = n - 1, y = n - 1;\n   \
    \ while (k--) {\n        ans.push_back(grid[x][y]);\n        int p = parent[x][y];\n\
    \        x = p / n;\n        y = p % n;\n    }\n    std::reverse(ans.begin(),\
    \ ans.end());\n    return ans;", "  // your code goes here\n  std::vector<long>\
    \ result;\n  std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n  std::vector<std::vector<std::vector<long>>> path(grid.size(),\
    \ std::vector<std::vector<long>>(grid[0].size(), std::vector<long>()));\n  dp[0][0]\
    \ = grid[0][0];\n  path[0][0].push_back(grid[0][0]);\n  for (int i = 0; i < grid.size();\
    \ i++) {\n    for (int j = 0; j < grid[0].size(); j++) {\n      if (i > 0) {\n\
    \        if (dp[i - 1][j] + grid[i][j] < dp[i][j]) {\n          dp[i][j] = dp[i\
    \ - 1][j] + grid[i][j];\n          path[i][j] = path[i - 1][j];\n          path[i][j].push_back(grid[i][j]);\n\
    \        } else if (dp[i - 1][j] + grid[i][j] == dp[i][j]) {\n          std::vector<long>\
    \ temp = path[i - 1][j];\n          temp.push_back(grid[i][j]);\n          if\
    \ (temp < path[i][j]) {\n            path[i][j] = temp;\n          }\n       \
    \ }\n      }\n      if (j > 0) {\n        if (dp[i][j - 1] + grid[i][j] < dp[i][j])\
    \ {\n          dp[i][j] = dp[i][j - 1] + grid[i][j];\n          path[i][j] = path[i][j\
    \ - 1];\n          path[i][j].push_back(grid[i][j]);\n        } else if (dp[i][j\
    \ - 1] + grid[i][j] == dp[i][j]) {\n          std::vector<long> temp = path[i][j\
    \ - 1];\n         ", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (j > 0) {\n                  \
    \  dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n               \
    \ }\n                if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    std::vector<long> ans;\n    int i = 0, j = 0;\n    ans.push_back(grid[i][j]);\n\
    \    for (int l = 2; l <= k; l++) {\n        if (i > 0 && dp[i][j][l] == dp[i\
    \ - 1][j][l - 1] + grid[i][j]) {\n            ans.push_back(grid[--i][j]);\n \
    \       } else if (j > 0 && d", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<int>> parent(n, std::vector<int>(n, -1));\n    std::vector<std::vector<int>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::priority_queue<std::vector<long>,\
    \ std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    pq.push({grid[0][0],\
    \ 0, 0});\n    dp[0][0] = grid[0][0];\n    while (!pq.empty()) {\n        auto\
    \ cur = pq.top();\n        pq.pop();\n        int x = cur[1], y = cur[2];\n  \
    \      for (auto d : dir) {\n            int nx = x + d[0], ny = y + d[1];\n \
    \           if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\n          \
    \  if (dp[nx][ny] > dp[x][y] + grid[nx][ny]) {\n                dp[nx][ny] = dp[x][y]\
    \ + grid[nx][ny];\n                parent[nx][ny] = x * n + y;\n             \
    \   pq.push({dp[nx][ny], nx, ny});\n            }\n        }\n    }\n    std::vector<long>\
    \ res;\n    int x = n - 1, y = n - 1;\n    while (k--) {\n        res.push_back(grid[x][y]);\n\
    \        int p = parent[x][y];\n        x = p / n;\n        y = p % n;\n    }\n\
    \    return res;", "    std::vector<long> res;\n    int n = grid.size();\n   \
    \ int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l\
    \ = 2; l <= k; l++) {\n                if (i > 0) {\n                    if (dp[i\
    \ - 1][j][l - 1] != -1) {\n                        if (dp[i][j][l] == -1 || dp[i\
    \ - 1][j][l - 1] < dp[i][j][l]) {\n                            dp[i][j][l] = dp[i\
    \ - 1][j][l - 1];\n                            path[i][j][l] = path[i - 1][j][l\
    \ - 1];\n                            path[i][j][l].push_back(grid[i][j]);\n  \
    \                      }\n                    }\n                }\n         \
    \       if (j > 0) {\n                    if (dp[i][j - 1][l - 1] != -1) {\n \
    \                       if (dp[i][j][l] == -1 || dp[i][j - 1][l - 1] < dp[i][j][l])\
    \ {\n                            dp[i][j][l] = dp[i][j - 1][l - 1", "    // Write\
    \ your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ std::vector<std::vector<std::vector<std::vector<long>>>> dp_path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            dp_path[i][j][1].push_back(grid[i][j]);\n       \
    \ }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n;\
    \ j++) {\n            for (int l = 2; l <= k; l++) {\n                dp[i][j][l]\
    \ = INT_MAX;\n                if (i > 0) {\n                    if (dp[i][j][l]\
    \ > dp[i - 1][j][l - 1]) {\n                        dp[i][j][l] = dp[i - 1][j][l\
    \ - 1];\n                        dp_path[i][j][l] = dp_path[i - 1][j][l - 1];\n\
    \                    }\n                    else if (dp[i][j][l] == dp[i - 1][j][l\
    \ - 1]) {\n                        if (dp_path[i][j][l] > dp_path[i - 1][j][l\
    \ - 1]) {\n                            dp_path[i][j][l] = dp_path[i - 1][j][l\
    \ - 1];\n                        }\n                    }\n                }\n\
    \                if (j > 0) {\n                    if (dp[i][j][l] > dp[i][j -\
    \ 1][l - 1]) {\n                        dp[i][j][l]", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    int i = 0, j = 0;\n    ans.push_back(grid[i][j]);\n    for (int l\
    \ = 2; l <= k; l++) {\n        if (i > 0 && dp[i][j][l] == dp[i - 1][j][l - 1]\
    \ + grid[i][j]) {\n            ans.push_back(grid[--i][j]);\n        } else if\
    \ (j > 0 && d", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    for(int i = 0; i < n; i++) {\n  \
    \      for(int j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n    \
    \            dp[i][j] = grid[i][j];\n            }\n            else if(i == 0)\
    \ {\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n            }\n    \
    \        else if(j == 0) {\n                dp[i][j] = dp[i-1][j] + grid[i][j];\n\
    \            }\n            else {\n                dp[i][j] = std::min(dp[i-1][j],\
    \ dp[i][j-1]) + grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    int i = n-1, j = n-1;\n    while(k) {\n        ans.push_back(grid[i][j]);\n\
    \        if(i == 0 && j == 0) {\n            break;\n        }\n        else if(i\
    \ == 0) {\n            j--;\n        }\n        else if(j == 0) {\n          \
    \  i--;\n        }\n        else {\n            if(dp[i-1][j] < dp[i][j-1]) {\n\
    \                i--;\n            }\n            else {\n                j--;\n\
    \            }\n        }\n        k--;\n    }\n    return ans;", "    std::vector<long>\
    \ result;\n    // your code goes here\n    return result;", "  std::vector<long>\
    \ result;\n  // your code goes here\n  return result;", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ res;\n    int i = 0, j = 0;\n    res.push_back(grid[i][j]);\n    for (int l\
    \ = 2; l <= k; l++) {\n        if (i > 0 && dp[i][j][l] == dp[i - 1][j][l - 1]\
    \ + grid[i][j]) {\n            res.push_back(grid[--i][j]);\n        } else if\
    \ (j > 0 && d", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k+1, -1)));\n  \
    \  for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n      \
    \      if(i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n      \
    \          path[i][j][1] = grid[i][j];\n            }\n            if(i > 0) {\n\
    \                if(dp[i-1][j] + grid[i][j] < dp[i][j]) {\n                  \
    \  dp[i][j] = dp[i-1][j] + grid[i][j];\n                    for(int l = 1; l <=\
    \ k; l++) {\n                        path[i][j][l] = path[i-1][j][l];\n      \
    \              }\n                    path[i][j][1] = grid[i][j];\n          \
    \      }\n            }\n            if(j > 0) {\n                if(dp[i][j-1]\
    \ + grid[i][j] < dp[i][j]) {\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                    for(int l = 1; l <= k; l++) {\n                        path[i][j][l]\
    \ = path[i][j-1][l];\n                    }\n                    path[i][j][1]\
    \ = grid[i][j];\n                }\n            }\n        }\n    }\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            for(int\
    \ l = 2; l <= k; l++) {\n                if(i > 0) {\n                    if(dp[i-1][j]\
    \ + grid[i][j] < dp[i][j]) {\n                        d", "    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j][0] = grid[i][j];\n            } else\
    \ if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n     \
    \           path[i][j] = path[i][j - 1];\n                path[i][j][0] = grid[i][j];\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            } else {\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n       \
    \             path[i][j] = path[i - 1][j];\n                    path[i][j][0]\
    \ = grid[i][j];\n                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n \
    \                   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                  \
    \  path[i][j] = path[i][j - 1];\n                    path[i][j][0] = grid[i][j];\n\
    \                } else {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    path[i][", "    // Write your code here\n    std::vector<long>\
    \ ans;\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n    std::vector<std::vector<long>> parent(grid.size(), std::vector<long>(grid[0].size(),\
    \ -1));\n    std::priority_queue<std::pair<long, std::pair<long, long>>, std::vector<std::pair<long,\
    \ std::pair<long, long>>>, std::greater<std::pair<long, std::pair<long, long>>>>\
    \ pq;\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n    while(!pq.empty()){\n\
    \        auto curr = pq.top();\n        pq.pop();\n        if(curr.first > dp[curr.second.first][curr.second.second]){\n\
    \            continue;\n        }\n        if(curr.second.first + 1 < grid.size()\
    \ && dp[curr.second.first + 1][curr.second.second] > dp[curr.second.first][curr.second.second]\
    \ + grid[curr.second.first + 1][curr.second.second]){\n            dp[curr.second.first\
    \ + 1][curr.second.second] = dp[curr.second.first][curr.second.second] + grid[curr.second.first\
    \ + 1][curr.second.second];\n            parent[curr.second.first + 1][curr.second.second]\
    \ = curr.second.first * grid[0].size() + curr.second.second;\n            pq.push({dp[curr.second.first\
    \ + 1][curr.second.second], {curr.second.first + 1, curr.second.second}});\n \
    \       }\n        if(curr.second.second + 1 < grid[0].size() && dp[curr.second.first][curr.second.second\
    \ + 1] > dp[cur", "    std::vector<long> result;\n    // Implement your solution\
    \ here\n    return result;", "  int n = grid.size();\n  std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n  for\
    \ (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i ==\
    \ 0 && j == 0) {\n        dp[i][j] = grid[i][j];\n        path[i][j][1] = grid[i][j];\n\
    \      } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + grid[i][j];\n \
    \       path[i][j] = path[i][j - 1];\n        path[i][j][1] = grid[i][j];\n  \
    \    } else if (j == 0) {\n        dp[i][j] = dp[i - 1][j] + grid[i][j];\n   \
    \     path[i][j] = path[i - 1][j];\n        path[i][j][1] = grid[i][j];\n    \
    \  } else {\n        if (dp[i - 1][j] < dp[i][j - 1]) {\n          dp[i][j] =\
    \ dp[i - 1][j] + grid[i][j];\n          path[i][j] = path[i - 1][j];\n       \
    \   path[i][j][1] = grid[i][j];\n        } else if (dp[i - 1][j] > dp[i][j - 1])\
    \ {\n          dp[i][j] = dp[i][j - 1] + grid[i][j];\n          path[i][j] = path[i][j\
    \ - 1];\n          path[i][j][1] = grid[i][j];\n        } else {\n          dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n          path[i][", "    // Write your code here\n\
    \    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k+1, 0)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j][1] = grid[i][j];\n            }\n\
    \            else if(i == 0) {\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                path[i][j][1] = grid[i][j];\n            }\n            else\
    \ if(j == 0) {\n                dp[i][j] = dp[i-1][j] + grid[i][j];\n        \
    \        path[i][j][1] = grid[i][j];\n            }\n            else {\n    \
    \            dp[i][j] = std::min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n     \
    \           if(dp[i-1][j] < dp[i][j-1]) {\n                    path[i][j][1] =\
    \ grid[i][j];\n                }\n                else {\n                   \
    \ path[i][j][1] = grid[i][j];\n                }\n            }\n        }\n \
    \   }\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n\
    \            for(int l = 2; l <= k; l++) {\n                if(i == 0 && j ==\
    \ 0) {\n                    path[i][j][l] = path[i][j][l-1];\n               \
    \ }\n                else if(i == 0) {\n                    path[i][j][l] = path[i][",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k+1, INT_MAX)));\n\
    \    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n      \
    \      dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++){\n        for(int j = 0; j < n; j++){\n            for(int l = 2; l <=\
    \ k; l++){\n                if(i-1 >= 0){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i-1][j][l-1]);\n                }\n                if(i+1 < n){\n       \
    \             dp[i][j][l] = std::min(dp[i][j][l], dp[i+1][j][l-1]);\n        \
    \        }\n                if(j-1 >= 0){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j-1][l-1]);\n                }\n                if(j+1 < n){\n       \
    \             dp[i][j][l] = std::min(dp[i][j][l], dp[i][j+1][l-1]);\n        \
    \        }\n                dp[i][j][l] += grid[i][j];\n            }\n      \
    \  }\n    }\n    std::vector<long> ans;\n    long min = INT_MAX;\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(dp[i][j][k]\
    \ < min){\n                min = dp[i][j][k];\n                ans.clear();\n\
    \                ans.push_back(grid[i][j]);\n            }\n            else if(dp[i][j][k]\
    \ ==", "    // Write your code here\n    int n = grid.size();\n    vector<vector<long>>\
    \ dp(n, vector<long>(n, INT_MAX));\n    dp[0][0] = grid[0][0];\n    for(int i\
    \ = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            if(i > 0){\n\
    \                dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]);\n        \
    \    }\n            if(j > 0){\n                dp[i][j] = min(dp[i][j], dp[i][j-1]\
    \ + grid[i][j]);\n            }\n        }\n    }\n    vector<long> ans;\n   \
    \ int i = n-1, j = n-1;\n    while(k > 0){\n        ans.push_back(grid[i][j]);\n\
    \        if(i > 0 && dp[i-1][j] + grid[i][j] == dp[i][j]){\n            i--;\n\
    \        }\n        else{\n            j--;\n        }\n        k--;\n    }\n\
    \    return ans;", "  // your code goes here\n  int n = grid.size();\n  std::vector<long>\
    \ res;\n  std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n\
    \  std::vector<std::vector<long>> path(n, std::vector<long>(n, -1));\n  std::vector<std::vector<long>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n  for (int i = 0; i < n; i++) {\n\
    \    for (int j = 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp[i][j]\
    \ = 0;\n      } else {\n        for (int d = 0; d < 4; d++) {\n          int x\
    \ = i + dir[d][0];\n          int y = j + dir[d][1];\n          if (x >= 0 &&\
    \ x < n && y >= 0 && y < n) {\n            if (dp[x][y] != INT_MAX) {\n      \
    \        if (dp[x][y] + 1 < dp[i][j]) {\n                dp[i][j] = dp[x][y] +\
    \ 1;\n                path[i][j] = d;\n              }\n            }\n      \
    \    }\n        }\n      }\n    }\n  }\n  int i = n - 1;\n  int j = n - 1;\n \
    \ while (k > 0) {\n    res.push_back(grid[i][j]);\n    int d = path[i][j];\n \
    \   i = i + dir[d][0];\n    j = j + dir[d][1];\n    k--;\n  }\n  return res;",
  "    // Write your code here\n    std::vector<long> result;\n    if(k == 0)\n  \
    \      return result;\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k, INT_MAX)));\n \
    \   for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n       \
    \     dp[i][j][0] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < n; j++){\n            for(int l = 1; l < k; l++){\n\
    \                if(i > 0)\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1]);\n                if(j > 0)\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n                if(i < n - 1)\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                if(j < n - 1)\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n            }\n        }\n    }\n    int i = 0, j = 0;\n\
    \    for(int l = 0; l < k; l++){\n        result.push_back(dp[i][j][l]);\n   \
    \     if(i > 0 && dp[i][j][l] == dp[i - 1][j][l - 1])\n            i--;\n    \
    \    else if(j > 0 && dp[i][j][l] == dp[i][j - 1][l - 1])\n            j--;\n\
    \        else if(i < n - 1 && dp", "    std::vector<long> res;\n    return res;",
  "    // Write your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l\
    \ = 2; l <= k; l++) {\n                if (i > 0) {\n                    if (dp[i\
    \ - 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i\
    \ - 1][j][l - 1];\n                        path[i][j][l] = path[i - 1][j][l -\
    \ 1];\n                        path[i][j][l].push_back(grid[i][j]);\n        \
    \            }\n                }\n                if (j > 0) {\n            \
    \        if (dp[i][j - 1][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l]\
    \ = dp[i][j - 1][l - 1];\n                        path[i][j][l] = path[i][j -\
    \ 1][l - 1];\n                        path[i][j][l].push_back(grid[i][j]);\n \
    \                   }\n                }\n                if (i < n - 1) {\n \
    \                   if (dp[i + 1][j][l - 1]", "    // Write your code here\n \
    \   int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    dp[0][0] = grid[0][0];\n    path[0][0][0]\
    \ = grid[0][0];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j\
    \ < n; j++) {\n            if (i == 0 && j == 0) {\n                continue;\n\
    \            }\n            if (i > 0) {\n                if (dp[i - 1][j] + grid[i][j]\
    \ < dp[i][j]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n \
    \                   for (int l = 0; l <= k; l++) {\n                        path[i][j][l]\
    \ = path[i - 1][j][l];\n                    }\n                    path[i][j][0]\
    \ = grid[i][j];\n                } else if (dp[i - 1][j] + grid[i][j] == dp[i][j])\
    \ {\n                    for (int l = 0; l <= k; l++) {\n                    \
    \    if (path[i - 1][j][l] < path[i][j][l]) {\n                            break;\n\
    \                        } else if (path[i - 1][j][l] > path[i][j][l]) {\n   \
    \                         for (int m = 0; m <= k; m++) {\n                   \
    \             path[i][j][m] = path[i - 1][j][m];\n                           \
    \ }\n                            path[i][j][0] = grid[i][j];\n               \
    \             break;\n                        }\n                    }\n     \
    \           }\n            }\n            if (j > 0) {\n                if (dp[i][j\
    \ - 1] + grid[i][j] < dp[i][j]) {", "  // your code goes here\n  std::vector<long>\
    \ res;\n  int n = grid.size();\n  int m = grid[0].size();\n  std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n  std::vector<std::vector<std::vector<long>>>\
    \ path_val(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n  std::vector<std::vector<std::vector<long>>>\
    \ path_val_idx(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n \
    \ std::vector<std::vector<std::vector<long>>> path_val_idx_idx(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j\
    \ < m; j++) {\n      dp[i][j] = grid[i][j];\n      path[i][j].push_back(grid[i][j]);\n\
    \      path_val[i][j].push_back(grid[i][j]);\n      path_val_idx[i][j].push_back(i);\n\
    \      path_val_idx_idx[i][j].push_back(j);\n    }\n  }\n  for(int i = 0; i <\
    \ k - 1; i++) {\n    for(int j = 0; j < n; j++) {\n      for(int l = 0; l < m;\
    \ l++) {\n        if(j > 0 && dp[j - 1][l] > dp[j][l]) {\n          dp[j - 1][l]\
    \ = dp[j][l];\n          path[j - 1][l] = path[j][l];\n          path_val[j -\
    \ 1][l] = path_val[j][l];\n", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_idx(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j] = grid[i][j];\n            path[i][j][1] = grid[i][j];\n \
    \           path_idx[i][j][1] = 1;\n        }\n    }\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l = 2;\
    \ l <= k; l++) {\n                if (i > 0 && dp[i - 1][j] < dp[i][j]) {\n  \
    \                  dp[i][j] = dp[i - 1][j];\n                    path[i][j][l]\
    \ = path[i - 1][j][l - 1];\n                    path_idx[i][j][l] = path_idx[i\
    \ - 1][j][l - 1];\n                }\n                if (j > 0 && dp[i][j - 1]\
    \ < dp[i][j]) {\n                    dp[i][j] = dp[i][j - 1];\n              \
    \      path[i][j][l] = path[i][j - 1][l - 1];\n                    path_idx[i][j][l]\
    \ = path_idx[i][j - 1][l - 1];\n                }\n                if (i < n -\
    \ 1 && dp[i + 1][j] < dp[i][j]) {\n                    dp[i][j]", "  // your code\
    \ goes here\n  int n = grid.size();\n  std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n  std::vector<std::vector<int>> path(n, std::vector<int>(n, -1));\n\
    \  std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n \
    \ std::vector<std::vector<int>> visited(n, std::vector<int>(n, 0));\n  std::queue<std::pair<int,\
    \ int>> q;\n  q.push({0, 0});\n  dp[0][0] = grid[0][0];\n  while (!q.empty())\
    \ {\n    auto cur = q.front();\n    q.pop();\n    for (auto d : dir) {\n     \
    \ int x = cur.first + d[0];\n      int y = cur.second + d[1];\n      if (x < 0\
    \ || x >= n || y < 0 || y >= n) {\n        continue;\n      }\n      if (dp[x][y]\
    \ > dp[cur.first][cur.second] + grid[x][y]) {\n        dp[x][y] = dp[cur.first][cur.second]\
    \ + grid[x][y];\n        path[x][y] = cur.first * n + cur.second;\n        q.push({x,\
    \ y});\n      }\n    }\n  }\n  std::vector<long> ans;\n  int cur = n * n - 1;\n\
    \  while (k > 0) {\n    ans.push_back(grid[cur / n][cur % n]);\n    cur = path[cur\
    \ / n][cur % n];\n    k--;\n  }\n  return ans;", "  // Write your code here\n\
    \  int n = grid.size();\n  int m = grid[0].size();\n  std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k, INT_MAX)));\n \
    \ std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k, std::vector<long>())));\n  for(int i = 0;\
    \ i < n; i++) {\n    for(int j = 0; j < m; j++) {\n      dp[i][j][0] = grid[i][j];\n\
    \      path[i][j][0].push_back(grid[i][j]);\n    }\n  }\n  for(int i = 0; i <\
    \ n; i++) {\n    for(int j = 0; j < m; j++) {\n      for(int l = 1; l < k; l++)\
    \ {\n        if(i > 0) {\n          if(dp[i][j][l] > dp[i - 1][j][l - 1]) {\n\
    \            dp[i][j][l] = dp[i - 1][j][l - 1];\n            path[i][j][l] = path[i\
    \ - 1][j][l - 1];\n          }\n        }\n        if(i < n - 1) {\n         \
    \ if(dp[i][j][l] > dp[i + 1][j][l - 1]) {\n            dp[i][j][l] = dp[i + 1][j][l\
    \ - 1];\n            path[i][j][l] = path[i + 1][j][l - 1];\n          }\n   \
    \     }\n        if(j > 0) {\n          if(dp[i][j][l] > dp[i][j - 1][l - 1])\
    \ {\n            dp[i][j][l] = dp[i][j - 1][l - 1];\n            path[i][j][",
  "  // your code goes here\n  // std::vector<std::vector<long>> grid = {\n  //  \
    \ {1, 2, 3, 4},\n  //   {5, 6, 7, 8},\n  //   {9, 10, 11, 12},\n  //   {13, 14,\
    \ 15, 16}\n  // };\n  // long k = 4;\n  std::vector<std::vector<long>> dp(grid.size(),\
    \ std::vector<long>(grid[0].size(), 0));\n  std::vector<std::vector<long>> path(grid.size(),\
    \ std::vector<long>(grid[0].size(), 0));\n  for (int i = 0; i < grid.size(); i++)\
    \ {\n    for (int j = 0; j < grid[0].size(); j++) {\n      if (i == 0 && j ==\
    \ 0) {\n        dp[i][j] = grid[i][j];\n        path[i][j] = grid[i][j];\n   \
    \   } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + grid[i][j];\n    \
    \    path[i][j] = path[i][j - 1] * 10 + grid[i][j];\n      } else if (j == 0)\
    \ {\n        dp[i][j] = dp[i - 1][j] + grid[i][j];\n        path[i][j] = path[i\
    \ - 1][j] * 10 + grid[i][j];\n      } else {\n        if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n          dp[i][j] = dp[i - 1][j] + grid[i][j];\n          path[i][j]\
    \ = path[i - 1][j] * 10 + grid[i][j];\n        } else {\n          dp[i][j] =\
    \ dp[i][j - 1] + grid[i][j];\n          path[i][j] = path[i][j - 1] * 10 + grid[i][j];\n\
    \        }\n      }\n    }\n  }\n  //", "  // Write your code here\n  int n =\
    \ grid.size();\n  std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n  for (int i = 0; i < n; i++) {\n    for (int\
    \ j = 0; j < n; j++) {\n      dp[i][j][1] = grid[i][j];\n    }\n  }\n  for (int\
    \ i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      for (int l =\
    \ 2; l <= k; l++) {\n        long min = LONG_MAX;\n        if (i - 1 >= 0) {\n\
    \          min = std::min(min, dp[i - 1][j][l - 1]);\n        }\n        if (i\
    \ + 1 < n) {\n          min = std::min(min, dp[i + 1][j][l - 1]);\n        }\n\
    \        if (j - 1 >= 0) {\n          min = std::min(min, dp[i][j - 1][l - 1]);\n\
    \        }\n        if (j + 1 < n) {\n          min = std::min(min, dp[i][j +\
    \ 1][l - 1]);\n        }\n        dp[i][j][l] = min + grid[i][j];\n      }\n \
    \   }\n  }\n  long min = LONG_MAX;\n  int x, y;\n  for (int i = 0; i < n; i++)\
    \ {\n    for (int j = 0; j < n; j++) {\n      if (dp[i][j][k] < min) {\n     \
    \   min = dp[i][j][k];\n        x = i;\n        y = j;\n      }\n    }\n  }\n\
    \  std::vector<long> ans;\n  ans.push_back(grid[x][y]);\n  for (int i = k - 1;\
    \ i >= 1; i--) {\n    if (x - 1 >= 0 && dp[x - 1][y", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<long> result;\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j - 1 >= 0) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j + 1 < n) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    long min_val = INT_MAX;\n    int min_i = -1;\n  \
    \  int min_j = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            if (dp[i][j][k] < min_val) {\n                min_val\
    \ = dp[i][j][k];\n                min_i = i;\n                min_j = j;\n   \
    \         }\n        }\n   ", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i\
    \ + 1][j][l - 1]);\n                }\n                if (i - 1 >= 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n\
    \                }\n                if (j + 1 < n) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       if (j - 1 >= 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n            }\n        }\n    }\n\
    \    std::vector<long> result;\n    int i = 0, j = 0;\n    for (int l = 1; l <=\
    \ k; l++) {\n        result.push_back(grid[i][j]);\n        if (i + 1 < n && dp[i][j][l]\
    \ == dp[i + 1][j][l - 1]) {\n            i++;\n        } else if (i - 1 >= 0 &&\
    \ dp[i][j][l] == dp[i - 1][j][l - 1]) {\n            i--;", "    std::vector<long>\
    \ res;\n    if (k == 0) {\n        return res;\n    }\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l\
    \ = 2; l <= k; l++) {\n                if (i > 0 && dp[i - 1][j][l - 1] != -1)\
    \ {\n                    if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i - 1][j][l - 1];\n            \
    \            path[i][j][l] = path[i - 1][j][l - 1];\n                        path[i][j][l].push_back(grid[i][j]);\n\
    \                    }\n                }\n                if (j > 0 && dp[i][j\
    \ - 1][l - 1] != -1) {\n                    if (dp[i][j][l] == -1 || dp[i][j -\
    \ 1][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i][j -\
    \ 1][l - 1];\n                        path[i][j][", "    // Write your code here\n\
    \    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                long min_val = INT_MAX;\n                if (i\
    \ - 1 >= 0) {\n                    min_val = std::min(min_val, dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i + 1 < n) {\n              \
    \      min_val = std::min(min_val, dp[i + 1][j][l - 1]);\n                }\n\
    \                if (j - 1 >= 0) {\n                    min_val = std::min(min_val,\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j + 1 < m) {\n\
    \                    min_val = std::min(min_val, dp[i][j + 1][l - 1]);\n     \
    \           }\n                dp[i][j][l] = min_val;\n            }\n       \
    \ }\n    }\n    std::vector<long> ans;\n    int i = 0, j = 0;\n    for (int l\
    \ = 1; l <= k; l++) {\n        ans.push_back(dp[i][j][l]);\n        long min_val\
    \ = INT_MAX;\n        int min_i = -1, min_j = -1;\n        if (i - 1 >= 0) {\n\
    \            if (dp[i - 1][j][l + 1] < min_val) {\n                min_val = dp[i\
    \ - 1][j][l + 1];\n", "  int n = grid.size();\n  int m = grid[0].size();\n  std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(\n      n, std::vector<std::vector<std::vector<long>>>(\n             m,\
    \ std::vector<std::vector<long>>(\n                    n, std::vector<long>(m,\
    \ -1))));\n  std::vector<std::vector<std::vector<std::vector<std::vector<long>>>>>\n\
    \      path(n, std::vector<std::vector<std::vector<std::vector<long>>>>(\n   \
    \             m, std::vector<std::vector<std::vector<long>>>(\n              \
    \         n, std::vector<std::vector<long>>(\n                              m,\
    \ std::vector<long>(k + 1, -1)))));\n  std::vector<std::vector<std::vector<std::vector<std::vector<long>>>>>\n\
    \      path_idx(n, std::vector<std::vector<std::vector<std::vector<long>>>>(\n\
    \                    m, std::vector<std::vector<std::vector<long>>>(\n       \
    \                    n, std::vector<std::vector<long>>(\n                    \
    \              m, std::vector<long>(k + 1, -1)))));\n  for (int i = 0; i < n;\
    \ i++) {\n    for (int j = 0; j < m; j++) {\n      for (int x = 0; x < n; x++)\
    \ {\n        for (int y = 0; y < m; y++) {\n          if (i == x && j == y) {\n\
    \            dp[i][j][x][y] = 0;\n            path[i][j][x][y][0] = grid[i][j];\n\
    \            path_idx[i][j][x][y][0] = 0;\n          } else {\n            if\
    \ (i == x) {\n              if (j < y) {\n                dp[i][j][x][y] = dp[i][j][i][y\
    \ - 1] + 1;\n                path[i][j][x][y] = path[i][j][i][y", "  // your code\
    \ goes here\n  int n = grid.size();\n  std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ LONG_MAX));\n  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n  for (int i = 0; i < n; i++) {\n    for (int j\
    \ = 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp[i][j] = grid[i][j];\n\
    \        path[i][j][0] = grid[i][j];\n      } else if (i == 0) {\n        dp[i][j]\
    \ = dp[i][j - 1] + grid[i][j];\n        path[i][j] = path[i][j - 1];\n       \
    \ path[i][j][0] = grid[i][j];\n      } else if (j == 0) {\n        dp[i][j] =\
    \ dp[i - 1][j] + grid[i][j];\n        path[i][j] = path[i - 1][j];\n        path[i][j][0]\
    \ = grid[i][j];\n      } else {\n        if (dp[i - 1][j] < dp[i][j - 1]) {\n\
    \          dp[i][j] = dp[i - 1][j] + grid[i][j];\n          path[i][j] = path[i\
    \ - 1][j];\n          path[i][j][0] = grid[i][j];\n        } else if (dp[i - 1][j]\
    \ > dp[i][j - 1]) {\n          dp[i][j] = dp[i][j - 1] + grid[i][j];\n       \
    \   path[i][j] = path[i][j - 1];\n          path[i][j][0] = grid[i][j];\n    \
    \    } else {\n          dp[i][j] = dp[i - 1][j] + grid[i][j", "    // Write your\
    \ code here\n    int n = grid.size();\n    vector<vector<long>> dp(n, vector<long>(n,\
    \ INT_MAX));\n    dp[0][0] = 0;\n    for(int i = 0; i < n; i++){\n        for(int\
    \ j = 0; j < n; j++){\n            if(i > 0){\n                dp[i][j] = min(dp[i][j],\
    \ dp[i-1][j] + grid[i][j]);\n            }\n            if(j > 0){\n         \
    \       dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]);\n            }\n  \
    \      }\n    }\n    vector<long> ans;\n    int i = n-1, j = n-1;\n    while(k--){\n\
    \        ans.push_back(grid[i][j]);\n        if(i > 0 && dp[i-1][j] + grid[i][j]\
    \ == dp[i][j]){\n            i--;\n        }\n        else{\n            j--;\n\
    \        }\n    }\n    return ans;", "  // your code goes here\n  // return {};\n\
    \  std::vector<long> res;\n  int n = grid.size();\n  int m = grid[0].size();\n\
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(m, INT_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>(k, -1)));\n  for\
    \ (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (i ==\
    \ 0 && j == 0) {\n        dp[i][j] = grid[i][j];\n        path[i][j][0] = grid[i][j];\n\
    \      } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + grid[i][j];\n \
    \       path[i][j] = path[i][j - 1];\n        path[i][j][0] = grid[i][j];\n  \
    \    } else if (j == 0) {\n        dp[i][j] = dp[i - 1][j] + grid[i][j];\n   \
    \     path[i][j] = path[i - 1][j];\n        path[i][j][0] = grid[i][j];\n    \
    \  } else {\n        dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n\
    \        if (dp[i - 1][j] < dp[i][j - 1]) {\n          path[i][j] = path[i - 1][j];\n\
    \        } else {\n          path[i][j] = path[i][j - 1];\n        }\n       \
    \ path[i][j][0] = grid[i][j];\n      }\n    }\n  }\n  int i = n - 1;\n  int j\
    \ = m - 1;\n  int cnt = 1;\n  while (cnt < k) {\n    if (i", "    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j - 1 >= 0) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j + 1 < m) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    long cur = INT_MAX;\n\
    \    int x = -1, y = -1;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < m; j++) {\n            if (dp[i][j][k] < cur) {\n               \
    \ cur = dp[i][j][k];\n                x = i;\n                y = j;\n       \
    \     }\n        }\n    }\n    ans.push_back(grid[x][", "  // your code goes here\n\
    \  int n = grid.size();\n  std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n  for (int i = 0; i < n; i++) {\n    for (int j\
    \ = 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp[i][j] = 0;\n \
    \       path[i][j][0] = grid[i][j];\n      } else if (i == 0) {\n        dp[i][j]\
    \ = dp[i][j - 1] + 1;\n        path[i][j] = path[i][j - 1];\n        path[i][j][dp[i][j\
    \ - 1]] = grid[i][j];\n      } else if (j == 0) {\n        dp[i][j] = dp[i - 1][j]\
    \ + 1;\n        path[i][j] = path[i - 1][j];\n        path[i][j][dp[i - 1][j]]\
    \ = grid[i][j];\n      } else {\n        if (dp[i - 1][j] < dp[i][j - 1]) {\n\
    \          dp[i][j] = dp[i - 1][j] + 1;\n          path[i][j] = path[i - 1][j];\n\
    \          path[i][j][dp[i - 1][j]] = grid[i][j];\n        } else if (dp[i - 1][j]\
    \ > dp[i][j - 1]) {\n          dp[i][j] = dp[i][j - 1] + 1;\n          path[i][j]\
    \ = path[i][j - 1];\n          path[i][j][dp[i][j - 1]] = grid[i][j];\n      \
    \  } else {\n          dp[i][j] = dp[i - 1][j] + 1", "  // your code goes here\n\
    \  std::vector<long> result;\n  std::vector<std::vector<long>> dp(grid.size(),\
    \ std::vector<long>(grid[0].size(), INT_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ path(grid.size(), std::vector<std::vector<long>>(grid[0].size(), std::vector<long>()));\n\
    \  dp[0][0] = grid[0][0];\n  path[0][0].push_back(grid[0][0]);\n  for (int i =\
    \ 0; i < grid.size(); i++) {\n    for (int j = 0; j < grid[0].size(); j++) {\n\
    \      if (i > 0) {\n        if (dp[i][j] > dp[i - 1][j] + grid[i][j]) {\n   \
    \       dp[i][j] = dp[i - 1][j] + grid[i][j];\n          path[i][j] = path[i -\
    \ 1][j];\n          path[i][j].push_back(grid[i][j]);\n        } else if (dp[i][j]\
    \ == dp[i - 1][j] + grid[i][j]) {\n          std::vector<long> temp = path[i -\
    \ 1][j];\n          temp.push_back(grid[i][j]);\n          if (temp < path[i][j])\
    \ {\n            path[i][j] = temp;\n          }\n        }\n      }\n      if\
    \ (j > 0) {\n        if (dp[i][j] > dp[i][j - 1] + grid[i][j]) {\n          dp[i][j]\
    \ = dp[i][j - 1] + grid[i][j];\n          path[i][j] = path[i][j - 1];\n     \
    \     path[i][j].push_back(grid[i][j]);\n        } else if (dp[i][j] == dp[i][j\
    \ - 1] + grid[i][j]) {\n          std::vector<long> temp = path[i][j - 1];\n \
    \        ", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k,\
    \ std::vector<long>())));\n    std::vector<long> ans;\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 &&\
    \ j == 0) {\n                dp[i][j][0] = grid[i][j];\n                path[i][j][0].push_back(grid[i][j]);\n\
    \            } else if (i == 0) {\n                dp[i][j][0] = dp[i][j - 1][0]\
    \ + grid[i][j];\n                path[i][j][0] = path[i][j - 1][0];\n        \
    \        path[i][j][0].push_back(grid[i][j]);\n            } else if (j == 0)\
    \ {\n                dp[i][j][0] = dp[i - 1][j][0] + grid[i][j];\n           \
    \     path[i][j][0] = path[i - 1][j][0];\n                path[i][j][0].push_back(grid[i][j]);\n\
    \            } else {\n                dp[i][j][0] = std::min(dp[i - 1][j][0],\
    \ dp[i][j - 1][0]) + grid[i][j];\n                if (dp[i - 1][j][0] < dp[i][j\
    \ - 1][0]) {\n                    path[i][j][0] = path[i - 1][j][0];\n       \
    \         } else {\n                    path[i][j][0] = path[i][j - 1][0];\n \
    \               }\n                path[i][j][0].push", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<long>> parent(n, std::vector<long>(n,\
    \ -1));\n    std::vector<std::vector<long>> path;\n    for(int i = 0; i < n; i++)\
    \ {\n        for(int j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n\
    \                dp[i][j] = grid[i][j];\n            }\n            else if(i\
    \ == 0) {\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n             \
    \   parent[i][j] = 1;\n            }\n            else if(j == 0) {\n        \
    \        dp[i][j] = dp[i-1][j] + grid[i][j];\n                parent[i][j] = 0;\n\
    \            }\n            else {\n                if(dp[i-1][j] < dp[i][j-1])\
    \ {\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\n               \
    \     parent[i][j] = 0;\n                }\n                else {\n         \
    \           dp[i][j] = dp[i][j-1] + grid[i][j];\n                    parent[i][j]\
    \ = 1;\n                }\n            }\n        }\n    }\n    int i = n-1, j\
    \ = n-1;\n    while(k--) {\n        path.push_back({i, j});\n        if(parent[i][j]\
    \ == 0) {\n            i--;\n        }\n        else {\n            j--;\n   \
    \     }\n    }\n    std::vector<long> ans;\n    for(auto p : path) {\n       \
    \ ans.push_back(grid[p[0]][p[1]]);\n    }\n    return ans;", "    // Write your\
    \ code here\n    std::vector<long> res;\n    int n = grid.size();\n    int m =\
    \ grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i - 1 >= 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i\
    \ - 1][j][l - 1]);\n                }\n                if (i + 1 < n) {\n    \
    \                dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n \
    \               }\n                if (j - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n                }\n         \
    \       if (j + 1 < m) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n            }\n        }\n    }\n\
    \    long min_val = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < m; j++) {\n            min_val = std::min(min_val, dp[i][j][k]);\n\
    \        }\n    }\n    int i = 0, j = 0;\n    for (int l = 1; l <= k; l++) {\n\
    \        res.push_back(grid[", "    // Write your code here\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k+1, INT_MAX)));\n\
    \    std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k+1, std::vector<long>())));\n    for(int i =\
    \ 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n\
    \            for(int l = 2; l <= k; l++){\n                if(i-1 >= 0){\n   \
    \                 if(dp[i-1][j][l-1] < dp[i][j][l]){\n                       \
    \ dp[i][j][l] = dp[i-1][j][l-1];\n                        path[i][j][l] = path[i-1][j][l-1];\n\
    \                        path[i][j][l].push_back(grid[i][j]);\n              \
    \      }\n                    else if(dp[i-1][j][l-1] == dp[i][j][l]){\n     \
    \                   std::vector<long> temp = path[i-1][j][l-1];\n            \
    \            temp.push_back(grid[i][j]);\n                        if(temp < path[i][j][l]){\n\
    \                            path[i][j][l] = temp;\n                        }\n\
    \                    }\n                }\n                if(i+1 < n){\n    \
    \                if(dp[i+1][j][l-1] < dp[i][j][l]){", "    std::vector<long> result;\n\
    \    // Implement your solution here\n    return result;", "\t// Write your code\
    \ here\n\tint n = grid.size();\n\tstd::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n\tstd::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int\
    \ j = 0; j < n; j++) {\n\t\t\tif (i == 0 && j == 0) {\n\t\t\t\tdp[i][j] = 0;\n\
    \t\t\t\tpath[i][j][0] = grid[i][j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (i - 1\
    \ >= 0) {\n\t\t\t\t\tif (dp[i - 1][j] < dp[i][j]) {\n\t\t\t\t\t\tdp[i][j] = dp[i\
    \ - 1][j];\n\t\t\t\t\t\tpath[i][j] = path[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\t\
    else if (dp[i - 1][j] == dp[i][j]) {\n\t\t\t\t\t\tif (path[i - 1][j] < path[i][j])\
    \ {\n\t\t\t\t\t\t\tpath[i][j] = path[i - 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\
    \t\t\t}\n\t\t\t\tif (j - 1 >= 0) {\n\t\t\t\t\tif (dp[i][j - 1] < dp[i][j]) {\n\
    \t\t\t\t\t\tdp[i][j] = dp[i][j - 1];\n\t\t\t\t\t\tpath[i][j] = path[i][j - 1];\n\
    \t\t\t\t\t}\n\t\t\t\t\telse if (dp[i][j - 1] == dp[i][j]) {\n\t\t\t\t\t\tif (path[i][j\
    \ - 1] < path[i][j]) {", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l\
    \ = 2; l <= k; l++) {\n                if (i - 1 >= 0) {\n                   \
    \ if (dp[i - 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l]\
    \ = dp[i - 1][j][l - 1];\n                        path[i][j][l] = path[i - 1][j][l\
    \ - 1];\n                        path[i][j][l].push_back(grid[i][j]);\n      \
    \              }\n                }\n                if (i + 1 < n) {\n      \
    \              if (dp[i + 1][j][l - 1] < dp[i][j][l]) {\n                    \
    \    dp[i][j][l] = dp[i + 1][j][l - 1];\n                        path[i][j][l]\
    \ = path[i + 1][j][l - 1];\n                        path[i][j][l].push_back(grid[i][j]);\n\
    \                    }\n                }\n                if (j - 1 >= 0) {\n\
    \                    if (dp[i][j - 1][l - 1] < dp[i][j", "    // Write your code\
    \ here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(i ==\
    \ 0 && j == 0){\n                dp[i][j] = 0;\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(i == 0){\n                dp[i][j] = dp[i][j-1]\
    \ + 1;\n                path[i][j] = path[i][j-1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(j == 0){\n                dp[i][j] = dp[i-1][j]\
    \ + 1;\n                path[i][j] = path[i-1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else{\n                if(dp[i-1][j] < dp[i][j-1]){\n\
    \                    dp[i][j] = dp[i-1][j] + 1;\n                    path[i][j]\
    \ = path[i-1][j];\n                    path[i][j].push_back(grid[i][j]);\n   \
    \             }\n                else if(dp[i-1][j] > dp[i][j-1]){\n         \
    \           dp[i][j] = dp[i][j-1] + 1;\n                    path[i][j] = path[i][j-1];\n\
    \                    path[i][j].push_back(grid[i][j]);\n                }\n  \
    \              else{\n                    dp[i][j] = dp[i-1][j] + 1;\n       \
    \             path", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j][0] = grid[i][j];\n            }\n         \
    \   else if(i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n        \
    \        path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j - 1]]\
    \ = grid[i][j];\n            }\n            else if(j == 0) {\n              \
    \  dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n\
    \                path[i][j][dp[i - 1][j]] = grid[i][j];\n            }\n     \
    \       else {\n                if(dp[i - 1][j] < dp[i][j - 1]) {\n          \
    \          dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j] = path[i\
    \ - 1][j];\n                    path[i][j][dp[i - 1][j]] = grid[i][j];\n     \
    \           }\n                else if(dp[i - 1][j] > dp[i][j - 1]) {\n      \
    \              dp[i][j] = dp[i][j - 1] + 1;\n                    path[i][j] =\
    \ path[i][j - 1];\n                    path[i][j][dp[i][j - 1]] = grid[i][j];\n\
    \                }\n                else {\n                    dp[i][j] = d",
  "    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j][0] = grid[i][j];\n            } else\
    \ if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n     \
    \           path[i][j] = path[i][j - 1];\n                path[i][j][0] = grid[i][j];\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            } else {\n                dp[i][j] = std::min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j];\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    path[i][j] = path[i - 1][j];\n                }\
    \ else {\n                    path[i][j] = path[i][j - 1];\n                }\n\
    \                path[i][j][0] = grid[i][j];\n            }\n        }\n    }\n\
    \    int i = n - 1, j = n - 1;\n    for (int l = 1; l < k; l++) {\n        if\
    \ (i == 0) {\n            path[i][j][l] = path[i][j - 1][l - 1];\n           \
    \ j--;\n        } else if (j ==", "    // Write your code here\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k+1, INT_MAX)));\n\
    \    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n      \
    \      dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++){\n        for(int j = 0; j < m; j++){\n            for(int l = 2; l <=\
    \ k; l++){\n                if(i > 0){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i-1][j][l-1]);\n                }\n                if(j > 0){\n         \
    \           dp[i][j][l] = std::min(dp[i][j][l], dp[i][j-1][l-1]);\n          \
    \      }\n                if(i < n-1){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i+1][j][l-1]);\n                }\n                if(j < m-1){\n       \
    \             dp[i][j][l] = std::min(dp[i][j][l], dp[i][j+1][l-1]);\n        \
    \        }\n                dp[i][j][l] += grid[i][j];\n            }\n      \
    \  }\n    }\n    std::vector<long> ans;\n    long min = INT_MAX;\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(dp[i][j][k]\
    \ < min){\n                min = dp[i][j][k];\n                ans.clear();\n\
    \                ans.push_back(grid[i][j]);\n            }\n            else if(dp[",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   dp[i][j][1] = grid[i][j];\n            parent[i][j][1][0] = i;\n         \
    \   parent[i][j][1][1] = j;\n        }\n    }\n    for (int len = 2; len <= k;\
    \ len++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0;\
    \ j < n; j++) {\n                if (i - 1 >= 0 && dp[i - 1][j][len - 1] < dp[i][j][len])\
    \ {\n                    dp[i][j][len] = dp[i - 1][j][len - 1];\n            \
    \        parent[i][j][len][0] = i - 1;\n                    parent[i][j][len][1]\
    \ = j;\n                }\n                if (i + 1 < n && dp[i + 1][j][len -\
    \ 1] < dp[i][j][len]) {\n                    dp[i][j][len] = dp[i + 1][j][len\
    \ - 1];\n                    parent[i][j][len][0] = i + 1;\n                 \
    \   parent[i][j][len][1] = j;\n                }\n                if (j - 1 >=\
    \ 0 && dp[i][j - 1][len - 1] < dp[i][j][len]) {\n                    dp[i][j][len]\
    \ = dp[i][j - 1][len -", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            } else if (i == 0) {\n                dp[i][j] =\
    \ dp[i][j - 1] + 1;\n                path[i][j] = path[i][j - 1];\n          \
    \      path[i][j][dp[i][j]] = grid[i][j];\n            } else if (j == 0) {\n\
    \                dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j] = path[i\
    \ - 1][j];\n                path[i][j][dp[i][j]] = grid[i][j];\n            }\
    \ else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n               \
    \     dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j] = path[i -\
    \ 1][j];\n                    path[i][j][dp[i][j]] = grid[i][j];\n           \
    \     } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                    dp[i][j]\
    \ = dp[i][j - 1] + 1;\n                    path[i][j] = path[i][j - 1];\n    \
    \                path[i][j][dp[i][j]] = grid[i][j];\n                } else {\n\
    \                    dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j]\
    \ = path[i - 1", "    std::vector<long> res;\n    std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), INT_MAX));\n    std::vector<std::vector<int>>\
    \ visited(grid.size(), std::vector<int>(grid[0].size(), 0));\n    std::priority_queue<std::pair<long,\
    \ std::pair<int, int>>, std::vector<std::pair<long, std::pair<int, int>>>, std::greater<std::pair<long,\
    \ std::pair<int, int>>>> pq;\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0]\
    \ = grid[0][0];\n    visited[0][0] = 1;\n    while (!pq.empty()) {\n        auto\
    \ curr = pq.top();\n        pq.pop();\n        int i = curr.second.first;\n  \
    \      int j = curr.second.second;\n        if (i == grid.size() - 1 && j == grid[0].size()\
    \ - 1) {\n            break;\n        }\n        if (i > 0 && visited[i - 1][j]\
    \ == 0) {\n            visited[i - 1][j] = 1;\n            dp[i - 1][j] = std::min(dp[i\
    \ - 1][j], dp[i][j] + grid[i - 1][j]);\n            pq.push({dp[i - 1][j], {i\
    \ - 1, j}});\n        }\n        if (i < grid.size() - 1 && visited[i + 1][j]\
    \ == 0) {\n            visited[i + 1][j] = 1;\n            dp[i + 1][j] = std::min(dp[i\
    \ + 1][j], dp[i][j] + grid[i + 1][j]);\n            pq.push({dp[i + 1][j], {i\
    \ + 1, j}});\n        }\n        if (j > 0 && visited[i][j - 1] == 0) {\n    \
    \        visited[i][j - 1] = 1;\n            dp[", "  // your code goes here\n\
    \  std::vector<long> res;\n  std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n  std::vector<std::vector<long>> path(grid.size(), std::vector<long>(grid[0].size(),\
    \ -1));\n  std::vector<std::vector<long>> visited(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n  std::vector<std::vector<long>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n  std::queue<std::pair<long, long>> q;\n  q.push({0, 0});\n  dp[0][0]\
    \ = grid[0][0];\n  while (!q.empty()) {\n    auto cur = q.front();\n    q.pop();\n\
    \    for (auto d : dir) {\n      long nx = cur.first + d[0];\n      long ny =\
    \ cur.second + d[1];\n      if (nx < 0 || nx >= grid.size() || ny < 0 || ny >=\
    \ grid[0].size()) {\n        continue;\n      }\n      if (visited[nx][ny] ==\
    \ 0) {\n        visited[nx][ny] = 1;\n        q.push({nx, ny});\n      }\n   \
    \   if (dp[nx][ny] > dp[cur.first][cur.second] + grid[nx][ny]) {\n        dp[nx][ny]\
    \ = dp[cur.first][cur.second] + grid[nx][ny];\n        path[nx][ny] = cur.first\
    \ * grid[0].size() + cur.second;\n      }\n    }\n  }\n  long cur = grid.size()\
    \ * grid[0].size() - 1;\n  for (long i = 0; i < k; ++i) {\n    res.push_back(grid[cur\
    \ / grid[0].size()][cur % grid[0].size()]);\n    cur = path[cur / grid[0].", " \
    \   int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<long>>\
    \ path(n, std::vector<long>(n, -1));\n    std::vector<std::vector<long>> path_len(n,\
    \ std::vector<long>(n, -1));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n            path[i][j]\
    \ = grid[i][j];\n            path_len[i][j] = 1;\n        }\n    }\n    for (int\
    \ len = 2; len <= k; len++) {\n        for (int i = 0; i < n; i++) {\n       \
    \     for (int j = 0; j < n; j++) {\n                if (i > 0 && dp[i - 1][j][len\
    \ - 1] != -1) {\n                    if (dp[i][j][len] == -1 || dp[i - 1][j][len\
    \ - 1] < dp[i][j][len]) {\n                        dp[i][j][len] = dp[i - 1][j][len\
    \ - 1];\n                        path[i][j] = path[i - 1][j][len - 1];\n     \
    \                   path_len[i][j] = path_len[i - 1][j][len - 1];\n          \
    \          }\n                }\n                if (j > 0 && dp[i][j - 1][len\
    \ - 1] != -1) {\n                    if (dp[i][j][len] == -1 || dp[i][j - 1][len\
    \ - 1] < dp[i][j][len]) {\n                        dp[i][j][len] = dp[i][j - 1][len\
    \ - 1];\n                        path[i][j] = path[i][j - 1][len - 1];\n     \
    \                   path_len[i][j] = path", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, LONG_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n        \
    \        path[i][j][1] = grid[i][j];\n            } else if (i == 0) {\n     \
    \           dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j][1] = grid[i][j];\n           \
    \ } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][1] =\
    \ grid[i][j];\n            } else {\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n       \
    \             path[i][j] = path[i - 1][j];\n                    path[i][j][1]\
    \ = grid[i][j];\n                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n \
    \                   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                  \
    \  path[i][j] = path[i][j - 1];\n                    path[i][j][1] = grid[i][j];\n\
    \                } else {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    path[i][", "  std::vector<long> result;\n  // your code goes\
    \ here\n  return result;", "  // Write your code here\n  int n = grid.size();\n\
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n  for\
    \ (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i ==\
    \ 0 && j == 0) {\n        dp[i][j] = grid[i][j];\n        path[i][j][0] = grid[i][j];\n\
    \      } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + grid[i][j];\n \
    \       path[i][j] = path[i][j - 1];\n        path[i][j][0] = grid[i][j];\n  \
    \    } else if (j == 0) {\n        dp[i][j] = dp[i - 1][j] + grid[i][j];\n   \
    \     path[i][j] = path[i - 1][j];\n        path[i][j][0] = grid[i][j];\n    \
    \  } else {\n        dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n\
    \        if (dp[i - 1][j] < dp[i][j - 1]) {\n          path[i][j] = path[i - 1][j];\n\
    \        } else {\n          path[i][j] = path[i][j - 1];\n        }\n       \
    \ path[i][j][0] = grid[i][j];\n      }\n    }\n  }\n  int i = n - 1, j = n - 1;\n\
    \  for (int l = 1; l < k; l++) {\n    if (i == 0) {\n      path[i][j][l] = path[i][j\
    \ - 1][l - 1];\n      j--;\n", "    // Write your code here\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j - 1 >= 0) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j + 1 < m) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    int x = 0, y = 0;\n \
    \   for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n   \
    \         if (dp[i][j][k] < dp[x][y][k]) {\n                x = i;\n         \
    \       y = j;\n            }\n        }\n    }\n    ans.push_back(grid[x][y]);\n\
    \    for (int i = k", "  // your code goes here\n  int n = grid.size();\n  std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n  for\
    \ (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i ==\
    \ 0 && j == 0) {\n        dp[i][j] = grid[i][j];\n        path[i][j][0] = grid[i][j];\n\
    \      } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + grid[i][j];\n \
    \       path[i][j] = path[i][j - 1];\n        path[i][j][0] = grid[i][j];\n  \
    \    } else if (j == 0) {\n        dp[i][j] = dp[i - 1][j] + grid[i][j];\n   \
    \     path[i][j] = path[i - 1][j];\n        path[i][j][0] = grid[i][j];\n    \
    \  } else {\n        if (dp[i - 1][j] < dp[i][j - 1]) {\n          dp[i][j] =\
    \ dp[i - 1][j] + grid[i][j];\n          path[i][j] = path[i - 1][j];\n       \
    \   path[i][j][0] = grid[i][j];\n        } else {\n          dp[i][j] = dp[i][j\
    \ - 1] + grid[i][j];\n          path[i][j] = path[i][j - 1];\n          path[i][j][0]\
    \ = grid[i][j];\n        }\n      }\n    }\n  }\n  int i = n - 1, j = n - 1;\n\
    \  for (int l = 1; l < k; l++) {\n    if (i == 0", "  std::vector<long> res;\n\
    \  return res;", "    // Write your code here\n    std::vector<long> ans;\n  \
    \  std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(grid.size(),\
    \ std::vector<std::vector<long>>(grid[0].size(), std::vector<long>()));\n    dp[0][0]\
    \ = grid[0][0];\n    path[0][0].push_back(grid[0][0]);\n    for(int i = 0; i <\
    \ grid.size(); i++){\n        for(int j = 0; j < grid[0].size(); j++){\n     \
    \       if(i > 0){\n                if(dp[i][j] > dp[i-1][j] + grid[i][j]){\n\
    \                    dp[i][j] = dp[i-1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i-1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                }\n                else if(dp[i][j] == dp[i-1][j] + grid[i][j]){\n\
    \                    std::vector<long> temp = path[i-1][j];\n                \
    \    temp.push_back(grid[i][j]);\n                    if(temp < path[i][j]){\n\
    \                        path[i][j] = temp;\n                    }\n         \
    \       }\n            }\n            if(j > 0){\n                if(dp[i][j]\
    \ > dp[i][j-1] + grid[i][j]){\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                    path[i][j] = path[i][j-1];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                }\n                else if(dp[i][j] == dp[i][j-1] + grid[i][j]){\n\
    \                    std::vector<long> temp = path[i][j-1];", "    // Write your\
    \ code here\n    std::vector<long> res;\n    std::vector<std::vector<long>> dp(grid.size(),\
    \ std::vector<long>(grid[0].size(), INT_MAX));\n    std::vector<std::vector<long>>\
    \ path(grid.size(), std::vector<long>(grid[0].size(), 0));\n    std::vector<std::vector<long>>\
    \ path_idx(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for(int i\
    \ = 0; i < grid.size(); i++) {\n        for(int j = 0; j < grid[0].size(); j++)\
    \ {\n            if(i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n\
    \                path[i][j] = grid[i][j];\n                path_idx[i][j] = 1;\n\
    \            } else if(i == 0) {\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                path[i][j] = path[i][j-1] * 10 + grid[i][j];\n              \
    \  path_idx[i][j] = path_idx[i][j-1] + 1;\n            } else if(j == 0) {\n \
    \               dp[i][j] = dp[i-1][j] + grid[i][j];\n                path[i][j]\
    \ = path[i-1][j] * 10 + grid[i][j];\n                path_idx[i][j] = path_idx[i-1][j]\
    \ + 1;\n            } else {\n                if(dp[i-1][j] < dp[i][j-1]) {\n\
    \                    dp[i][j] = dp[i-1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i-1][j] * 10 + grid[i][j];\n                    path_idx[i][j]\
    \ = path_idx[i-1][j] + 1;\n                } else if(dp[i-1][j", "    // Write\
    \ your code here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(i ==\
    \ 0 && j == 0){\n                dp[i][j] = 0;\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(i == 0){\n                dp[i][j] = dp[i][j-1]\
    \ + 1;\n                path[i][j] = path[i][j-1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(j == 0){\n                dp[i][j] = dp[i-1][j]\
    \ + 1;\n                path[i][j] = path[i-1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else{\n                if(dp[i-1][j] < dp[i][j-1]){\n\
    \                    dp[i][j] = dp[i-1][j] + 1;\n                    path[i][j]\
    \ = path[i-1][j];\n                    path[i][j].push_back(grid[i][j]);\n   \
    \             }\n                else if(dp[i-1][j] > dp[i][j-1]){\n         \
    \           dp[i][j] = dp[i][j-1] + 1;\n                    path[i][j] = path[i][j-1];\n\
    \                    path[i][j].push_back(grid[i][j]);\n                }\n  \
    \              else{\n                    dp[i][j] = dp[i-1][j] + 1;\n       \
    \             path", "    std::vector<long> res;\n    // Write your code here\n\
    \    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<long>> prev(n,\
    \ std::vector<long>(m, -1));\n    std::vector<std::vector<long>> next(n, std::vector<long>(m,\
    \ -1));\n    std::vector<std::vector<long>> visited(n, std::vector<long>(m, 0));\n\
    \    std::vector<std::vector<long>> path(n, std::vector<long>(m, 0));\n    std::vector<std::vector<long>>\
    \ dist(n, std::vector<long>(m, 0));\n    std::vector<std::vector<long>> parent(n,\
    \ std::vector<long>(m, -1));\n    std::vector<std::vector<long>> child(n, std::vector<long>(m,\
    \ -1));\n    std::vector<std::vector<long>> g(n, std::vector<long>(m, 0));\n \
    \   for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n     \
    \       g[i][j] = grid[i][j];\n        }\n    }\n    std::queue<std::pair<int,\
    \ int>> q;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++)\
    \ {\n            if(i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n\
    \                q.push({i, j});\n            }\n        }\n    }\n    while(!q.empty())\
    \ {\n        auto p = q.front();\n        q.pop();\n        int i = p.first;\n\
    \        int j = p.second;\n        if(i > 0) {\n            if(dp[i - 1][j] >\
    \ dp[i][j] + grid[i - 1][j]) {\n                d", "  std::vector<long> result;\n\
    \  // your code goes here\n  return result;", "    // Write your code here\n \
    \   int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    long min = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            if (dp[i][j][k] < min) {\n          \
    \      min = dp[i][j][k];\n                ans.clear();\n                ans.push_back(grid[i][j]);\n\
    \            } else if", "    int n = grid.size();\n    // dp[i][j][l] = min path\
    \ of length l starting from (i, j)\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n         \
    \   dp[i][j][1] = grid[i][j];\n            prev[i][j][1][0] = i;\n           \
    \ prev[i][j][1][1] = j;\n        }\n    }\n    for (int l = 2; l <= k; ++l) {\n\
    \        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j)\
    \ {\n                for (int di = -1; di <= 1; ++di) {\n                    for\
    \ (int dj = -1; dj <= 1; ++dj) {\n                        if (di == 0 && dj ==\
    \ 0) continue;\n                        int ni = i + di;\n                   \
    \     int nj = j + dj;\n                        if (ni < 0 || ni >= n || nj <\
    \ 0 || nj >= n) continue;\n                        if (dp[ni][nj][l - 1] == -1)\
    \ continue;\n                        long cur = dp[ni][nj][l - 1] * 10 + grid[i][j];\n\
    \                        if (dp[i][j][l] == -1 || cur < dp[i][j][l]) {\n     \
    \                       dp[i][j][l] = cur;\n                            prev[i][j][l][0]\
    \ = ni;\n                            prev[i][j][l][1] = nj;\n                \
    \        }\n                    }\n", "    // Write your code here\n    int n\
    \ = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n       \
    \         path[i][j][0] = grid[i][j];\n            } else if (j == 0) {\n    \
    \            dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j][0] = grid[i][j];\n\
    \            } else {\n                dp[i][j] = std::min(dp[i - 1][j], dp[i][j\
    \ - 1]) + 1;\n                path[i][j][0] = grid[i][j];\n            }\n   \
    \     }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <\
    \ n; j++) {\n            for (int l = 1; l <= k; l++) {\n                if (i\
    \ == 0 && j == 0) {\n                    path[i][j][l] = grid[i][j];\n       \
    \         } else if (i == 0) {\n                    path[i][j][l] = path[i][j\
    \ - 1][l - 1];\n                } else if (j == 0) {\n                    path[i][j][l]\
    \ = path[i - 1][j][l - 1];\n                } else {\n                    if (dp[i\
    \ - 1][j] < dp[i][j - 1]) {\n                        path[i][j][", "    // Write\
    \ your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n,\
    \ 0));\n    std::vector<std::vector<int>> path;\n    std::vector<long> result;\n\
    \    dp[0][0] = grid[0][0];\n    for(int i = 0; i < n; i++){\n        for(int\
    \ j = 0; j < n; j++){\n            if(i == 0 && j == 0) continue;\n          \
    \  if(i > 0){\n                if(dp[i][j] > dp[i-1][j] + grid[i][j]){\n     \
    \               dp[i][j] = dp[i-1][j] + grid[i][j];\n                    parent[i][j]\
    \ = 0;\n                }\n            }\n            if(j > 0){\n           \
    \     if(dp[i][j] > dp[i][j-1] + grid[i][j]){\n                    dp[i][j] =\
    \ dp[i][j-1] + grid[i][j];\n                    parent[i][j] = 1;\n          \
    \      }\n            }\n        }\n    }\n    int i = n-1, j = n-1;\n    while(i\
    \ != 0 || j != 0){\n        if(parent[i][j] == 0){\n            i--;\n       \
    \ }\n        else{\n            j--;\n        }\n        path.push_back({i, j});\n\
    \    }\n    int count = 0;\n    for(int i = path.size()-1; i >= 0; i--){\n   \
    \     if(count == k) break;\n        result.push_back(grid[path[i][0]][path[i][1]]);\n\
    \        count++;\n    }\n    return result;", "    // Write your code here\n\
    \    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n   \
    \ std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0; i < n; i++)\
    \ {\n            for (int j = 0; j < n; j++) {\n                if (i - 1 >= 0)\
    \ {\n                    if (dp[i - 1][j][l - 1] < dp[i][j][l]) {\n          \
    \              dp[i][j][l] = dp[i - 1][j][l - 1];\n                        path[i][j][l]\
    \ = path[i - 1][j][l - 1];\n                        path[i][j][l].push_back(grid[i][j]);\n\
    \                    }\n                    else if (dp[i - 1][j][l - 1] == dp[i][j][l])\
    \ {\n                        std::vector<long> temp = path[i - 1][j][l - 1];\n\
    \                        temp.push_back(grid[i][j]);\n                       \
    \ if (temp < path[i][j][l]) {\n                            path[i][j][l] = temp;\n\
    \                        }\n                    }\n                }\n       \
    \         if (i + 1 < n) {\n                    if (dp[i + 1][j][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][", "  // your code goes here\n  long n =\
    \ grid.size();\n  std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n  std::vector<std::vector<long>> path(n, std::vector<long>(n,\
    \ -1));\n  for (long i = 0; i < n; i++) {\n    for (long j = 0; j < n; j++) {\n\
    \      dp[i][j][1] = grid[i][j];\n    }\n  }\n  for (long i = 0; i < n; i++) {\n\
    \    for (long j = 0; j < n; j++) {\n      for (long l = 2; l <= k; l++) {\n \
    \       long min = -1;\n        if (i > 0 && dp[i - 1][j][l - 1] != -1) {\n  \
    \        min = dp[i - 1][j][l - 1];\n          path[i][j] = 0;\n        }\n  \
    \      if (j > 0 && dp[i][j - 1][l - 1] != -1 && (min == -1 || dp[i][j - 1][l\
    \ - 1] < min)) {\n          min = dp[i][j - 1][l - 1];\n          path[i][j] =\
    \ 1;\n        }\n        if (i < n - 1 && dp[i + 1][j][l - 1] != -1 && (min ==\
    \ -1 || dp[i + 1][j][l - 1] < min)) {\n          min = dp[i + 1][j][l - 1];\n\
    \          path[i][j] = 2;\n        }\n        if (j < n - 1 && dp[i][j + 1][l\
    \ - 1] != -1 && (min == -1 || dp[i][j + 1][l - 1] < min)) {\n          min = dp[i][j\
    \ + 1][l - 1];\n          path[i][j] = 3;\n        }\n        if (min != -1) {\n",
  "    // Write your code here\n    std::vector<long> result;\n    std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), INT_MAX));\n    for(int i\
    \ = 0; i < grid.size(); i++) {\n        for(int j = 0; j < grid[0].size(); j++)\
    \ {\n            if(i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n\
    \            } else if(i == 0) {\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \            } else if(j == 0) {\n                dp[i][j] = dp[i-1][j] + grid[i][j];\n\
    \            } else {\n                dp[i][j] = std::min(dp[i-1][j], dp[i][j-1])\
    \ + grid[i][j];\n            }\n        }\n    }\n    int i = grid.size() - 1;\n\
    \    int j = grid[0].size() - 1;\n    while(k > 0) {\n        result.push_back(grid[i][j]);\n\
    \        if(i == 0 && j == 0) {\n            break;\n        } else if(i == 0)\
    \ {\n            j--;\n        } else if(j == 0) {\n            i--;\n       \
    \ } else {\n            if(dp[i-1][j] < dp[i][j-1]) {\n                i--;\n\
    \            } else {\n                j--;\n            }\n        }\n      \
    \  k--;\n    }\n    return result;", "  // Write your code here\n  std::vector<long>\
    \ result;\n  // Your code here\n  return result;", "    // Write your code here\n\
    \    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ LONG_MAX));\n    std::vector<std::vector<int>> path(n, std::vector<int>(n, -1));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n \
    \               continue;\n            }\n            if (i > 0) {\n         \
    \       if (dp[i - 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i -\
    \ 1][j];\n                    path[i][j] = 0;\n                }\n           \
    \ }\n            if (j > 0) {\n                if (dp[i][j - 1] < dp[i][j]) {\n\
    \                    dp[i][j] = dp[i][j - 1];\n                    path[i][j]\
    \ = 1;\n                }\n            }\n            dp[i][j] += grid[i][j];\n\
    \        }\n    }\n    std::vector<long> res;\n    int i = n - 1, j = n - 1;\n\
    \    while (k > 0) {\n        res.push_back(grid[i][j]);\n        if (path[i][j]\
    \ == 0) {\n            i--;\n        } else if (path[i][j] == 1) {\n         \
    \   j--;\n        }\n        k--;\n    }\n    return res;", "  // your code goes\
    \ here\n  std::vector<long> res;\n  if(k == 0)\n    return res;\n  int n = grid.size();\n\
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n  for(int\
    \ i = 0; i < n; i++)\n    for(int j = 0; j < n; j++)\n      dp[i][j] = grid[i][j];\n\
    \  for(int i = 0; i < n; i++)\n    for(int j = 0; j < n; j++)\n      path[i][j][0]\
    \ = grid[i][j];\n  for(int l = 1; l < k; l++) {\n    for(int i = 0; i < n; i++)\
    \ {\n      for(int j = 0; j < n; j++) {\n        if(i > 0 && dp[i-1][j] < dp[i][j])\
    \ {\n          dp[i][j] = dp[i-1][j];\n          path[i][j][l] = path[i-1][j][l-1];\n\
    \        }\n        if(j > 0 && dp[i][j-1] < dp[i][j]) {\n          dp[i][j] =\
    \ dp[i][j-1];\n          path[i][j][l] = path[i][j-1][l-1];\n        }\n     \
    \   if(i < n-1 && dp[i+1][j] < dp[i][j]) {\n          dp[i][j] = dp[i+1][j];\n\
    \          path[i][j][l] = path[i+1][j][l-1];\n        }\n        if(j < n-1 &&\
    \ dp[i][j+1] < dp[i][j]) {\n          dp[i][j] = dp[i][j", "    // Write your\
    \ code here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n,\
    \ std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k+1, 0)));\n   \
    \ for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n       \
    \     if(i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n       \
    \         path[i][j][1] = grid[i][j];\n            }\n            else if(i ==\
    \ 0) {\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n                path[i][j][1]\
    \ = grid[i][j];\n            }\n            else if(j == 0) {\n              \
    \  dp[i][j] = dp[i-1][j] + grid[i][j];\n                path[i][j][1] = grid[i][j];\n\
    \            }\n            else {\n                dp[i][j] = std::min(dp[i-1][j],\
    \ dp[i][j-1]) + grid[i][j];\n                if(dp[i-1][j] < dp[i][j-1]) {\n \
    \                   path[i][j][1] = grid[i][j];\n                }\n         \
    \       else {\n                    path[i][j][1] = grid[i][j];\n            \
    \    }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++) {\n  \
    \      for(int j = 0; j < n; j++) {\n            for(int l = 2; l <= k; l++) {\n\
    \                if(i == 0 && j == 0) {\n                    path[i][j][l] = path[i][j][l-1];\n\
    \                }\n                else if(i == 0) {\n                    path[i][j][l]\
    \ = path[i][", "  // your code goes here\n  // std::vector<std::vector<long>>\
    \ grid = {\n  //   {1, 2, 3, 4},\n  //   {5, 6, 7, 8},\n  //   {9, 10, 11, 12},\n\
    \  //   {13, 14, 15, 16}\n  // };\n  // long k = 5;\n  // std::vector<std::vector<long>>\
    \ grid = {\n  //   {1, 2, 3, 4},\n  //   {5, 6, 7, 8},\n  //   {9, 10, 11, 12},\n\
    \  //   {13, 14, 15, 16}\n  // };\n  // long k = 6;\n  // std::vector<std::vector<long>>\
    \ grid = {\n  //   {1, 2, 3, 4},\n  //   {5, 6, 7, 8},\n  //   {9, 10, 11, 12},\n\
    \  //   {13, 14, 15, 16}\n  // };\n  // long k = 7;\n  // std::vector<std::vector<long>>\
    \ grid = {\n  //   {1, 2, 3, 4},\n  //   {5, 6, 7, 8},\n  //   {9, 10, 11, 12},\n\
    \  //   {13, 14, 15, 16}\n  // };\n  // long k = 8;\n  // std::vector<std::vector<long>>\
    \ grid = {\n  //   {1, 2, 3, 4},\n  //   {5, 6, 7, 8},\n  //   {9, 10, 11, 12},\n\
    \  //   {13, 14, 15, 16}\n  // };\n  // long k = 9;\n  // std::vector<std::vector<long>>\
    \ grid = {\n  //   {1, 2, 3, 4},\n  //   {5, 6, 7, 8},\n  //   {9, 10, 11, 12},\n\
    \  //   {13, 14, 15, 16}\n  // };\n  // long k = 10;\n  // std::vector<std::vector<long>>\
    \ grid = {\n  //   {1, 2,", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (j > 0) {\n                  \
    \  dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n               \
    \ }\n                if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    std::vector<long> ans;\n    long min = INT_MAX;\n    int\
    \ x, y;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            if (dp[i][j][k] < min) {\n                min = dp[i][j][k];\n\
    \                x = i;\n                y = j;\n            }\n        }\n  \
    \  }\n    ans.push_back(", "    // Write your code here\n    std::vector<long>\
    \ result;\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j <\
    \ grid[0].size(); j++) {\n            if(i == 0 && j == 0) {\n               \
    \ dp[i][j] = grid[i][j];\n            } else if(i == 0) {\n                dp[i][j]\
    \ = dp[i][j-1] + grid[i][j];\n            } else if(j == 0) {\n              \
    \  dp[i][j] = dp[i-1][j] + grid[i][j];\n            } else {\n               \
    \ dp[i][j] = std::min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n            }\n \
    \       }\n    }\n    int i = grid.size() - 1;\n    int j = grid[0].size() - 1;\n\
    \    while(k > 0) {\n        if(i == 0 && j == 0) {\n            result.push_back(grid[i][j]);\n\
    \            k--;\n        } else if(i == 0) {\n            result.push_back(grid[i][j]);\n\
    \            j--;\n            k--;\n        } else if(j == 0) {\n           \
    \ result.push_back(grid[i][j]);\n            i--;\n            k--;\n        }\
    \ else {\n            if(dp[i-1][j] < dp[i][j-1]) {\n                result.push_back(grid[i][j]);\n\
    \                i--;\n                k--;\n            } else {\n          \
    \      result.push_back(grid[i][j]);\n                j--;\n                k--;\n\
    \            }\n        }\n    }\n    std::reverse(result.begin(), result.end());\n\
    \    return result;", "  int n = grid.size();\n  std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      dp[i][j][1]\
    \ = grid[i][j];\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j =\
    \ 0; j < n; j++) {\n      for (int l = 2; l <= k; l++) {\n        if (i > 0) {\n\
    \          dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n       \
    \ }\n        if (j > 0) {\n          dp[i][j][l] = std::min(dp[i][j][l], dp[i][j\
    \ - 1][l - 1]);\n        }\n        if (i < n - 1) {\n          dp[i][j][l] =\
    \ std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n        }\n        if (j < n -\
    \ 1) {\n          dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \        }\n        dp[i][j][l] += grid[i][j];\n      }\n    }\n  }\n  long min_val\
    \ = INT_MAX;\n  int min_i = -1, min_j = -1;\n  for (int i = 0; i < n; i++) {\n\
    \    for (int j = 0; j < n; j++) {\n      if (dp[i][j][k] < min_val) {\n     \
    \   min_val = dp[i][j][k];\n        min_i = i;\n        min_j = j;\n      }\n\
    \    }\n  }\n  std::vector", "  // your code goes here\n  // std::vector<std::vector<long>>\
    \ grid = {{1,2,3},{4,5,6},{7,8,9}};\n  // long k = 4;\n  std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), -1));\n  std::vector<std::vector<std::vector<long>>>\
    \ dp_path(grid.size(), std::vector<std::vector<long>>(grid[0].size(), std::vector<long>()));\n\
    \  std::vector<std::vector<long>> dirs = {{0,1},{0,-1},{1,0},{-1,0}};\n  std::vector<long>\
    \ min_path;\n  long min_path_cost = INT_MAX;\n  for(long i = 0; i < grid.size();\
    \ i++) {\n    for(long j = 0; j < grid[0].size(); j++) {\n      if(k == 1) {\n\
    \        dp[i][j] = grid[i][j];\n        dp_path[i][j].push_back(grid[i][j]);\n\
    \      }\n      else {\n        for(long d = 0; d < dirs.size(); d++) {\n    \
    \      long x = i + dirs[d][0];\n          long y = j + dirs[d][1];\n        \
    \  if(x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size()) {\n         \
    \   if(dp[x][y] != -1) {\n              long cost = dp[x][y] + grid[i][j];\n \
    \             if(cost < min_path_cost) {\n                min_path_cost = cost;\n\
    \                min_path = dp_path[x][y];\n                min_path.push_back(grid[i][j]);\n\
    \              }\n              else if(cost == min_path_cost) {\n           \
    \     std::vector<long> temp = dp_path[x][y];\n                temp.push_back(grid[i][j]);\n\
    \                if(temp < min_path)", "    // Write your code here\n    long\
    \ n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (long i = 0; i < n; i++) {\n       \
    \ for (long j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n      \
    \          dp[i][j] = 0;\n                path[i][j][1] = grid[i][j];\n      \
    \      } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n  \
    \              path[i][j][1] = grid[i][j];\n            } else if (j == 0) {\n\
    \                dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j][1] =\
    \ grid[i][j];\n            } else {\n                dp[i][j] = std::min(dp[i\
    \ - 1][j], dp[i][j - 1]) + 1;\n                if (dp[i - 1][j] < dp[i][j - 1])\
    \ {\n                    path[i][j] = path[i - 1][j];\n                } else\
    \ {\n                    path[i][j] = path[i][j - 1];\n                }\n   \
    \             path[i][j][1] = grid[i][j];\n            }\n        }\n    }\n \
    \   for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n \
    \           for (long l = 2; l <= k; l++) {\n                if (i == 0 && j ==\
    \ 0) {\n                    path[i][j][l] = grid[i][j];\n                } else\
    \ if (i == 0) {\n                    path[i][j][l] = path[i][j - 1][l - 1];\n\
    \                } else if", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<int>> parent(n, std::vector<int>(n, -1));\n    std::vector<std::vector<int>>\
    \ visited(n, std::vector<int>(n, 0));\n    std::vector<std::vector<int>> path(n,\
    \ std::vector<int>(n, 0));\n    std::vector<std::vector<int>> path_index(n, std::vector<int>(n,\
    \ 0));\n    std::vector<std::vector<int>> path_index_copy(n, std::vector<int>(n,\
    \ 0));\n    std::vector<std::vector<int>> path_copy(n, std::vector<int>(n, 0));\n\
    \    std::vector<std::vector<int>> path_index_copy_2(n, std::vector<int>(n, 0));\n\
    \    std::vector<std::vector<int>> path_copy_2(n, std::vector<int>(n, 0));\n \
    \   std::vector<std::vector<int>> path_index_copy_3(n, std::vector<int>(n, 0));\n\
    \    std::vector<std::vector<int>> path_copy_3(n, std::vector<int>(n, 0));\n \
    \   std::vector<std::vector<int>> path_index_copy_4(n, std::vector<int>(n, 0));\n\
    \    std::vector<std::vector<int>> path_copy_4(n, std::vector<int>(n, 0));\n \
    \   std::vector<std::vector<int>> path_index_copy_5(n, std::vector<int>(n, 0));\n\
    \    std::vector<std::vector<int>> path_copy_5(n, std::vector<int>(n, 0));\n \
    \   std::vector<std::vector<int>> path_index_copy_6(n, std::vector<int>(n, 0));\n\
    \    std::vector<std::vector<int>> path_copy_6(n, std::", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            path[i][j][0] = grid[i][j];\n       \
    \ }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n;\
    \ j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n\
    \            } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n\
    \            } else {\n                dp[i][j] = std::min(dp[i - 1][j], dp[i][j\
    \ - 1]) + 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            for (int l = 1; l <= k;\
    \ l++) {\n                if (i == 0 && j == 0) {\n                    path[i][j][l]\
    \ = grid[i][j];\n                } else if (i == 0) {\n                    path[i][j][l]\
    \ = std::min(path[i][j - 1][l], path[i][j][l - 1]);\n                } else if\
    \ (j == 0) {\n                    path[i][j][l] = std::min(path[i - 1][j][l],\
    \ path[i][j][l - 1]);\n                } else {\n                    path[i][j][l]\
    \ = std::min(std::min(path", "    // Write your code here\n    std::vector<long>\
    \ result;\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(),\
    \ 0));\n    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j <\
    \ grid[0].size(); j++) {\n            if(i == 0 && j == 0) {\n               \
    \ dp[i][j] = 1;\n            } else if(i == 0) {\n                dp[i][j] = dp[i][j\
    \ - 1] + 1;\n            } else if(j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + 1;\n            } else {\n                dp[i][j] = std::min(dp[i\
    \ - 1][j], dp[i][j - 1]) + 1;\n            }\n        }\n    }\n    int i = grid.size()\
    \ - 1;\n    int j = grid[0].size() - 1;\n    while(k > 0) {\n        result.push_back(grid[i][j]);\n\
    \        if(i == 0 && j == 0) {\n            break;\n        } else if(i == 0)\
    \ {\n            j--;\n        } else if(j == 0) {\n            i--;\n       \
    \ } else {\n            if(dp[i - 1][j] < dp[i][j - 1]) {\n                i--;\n\
    \            } else {\n                j--;\n            }\n        }\n      \
    \  k--;\n    }\n    return result;", "    // Write your code here\n    int n =\
    \ grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (j > 0) {\n                  \
    \  dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n               \
    \ }\n                if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    std::vector<long> res;\n    long min = INT_MAX;\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (dp[i][j][k] < min) {\n                min = dp[i][j][k];\n           \
    \     res.clear();\n                res.push_back(grid[i][j]);\n            }\
    \ else if (dp[i][j][k] == min", "    std::vector<long> res;\n    // Write your\
    \ code here\n    return res;", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<std::vector<bool>> visited(n, std::vector<bool>(n,\
    \ false));\n    std::queue<std::pair<int, int>> q;\n    q.push({0, 0});\n    dp[0][0]\
    \ = grid[0][0];\n    visited[0][0] = true;\n    while (!q.empty()) {\n       \
    \ auto curr = q.front();\n        q.pop();\n        for (auto d : dir) {\n   \
    \         int x = curr.first + d[0];\n            int y = curr.second + d[1];\n\
    \            if (x < 0 || x >= n || y < 0 || y >= n || visited[x][y]) {\n    \
    \            continue;\n            }\n            visited[x][y] = true;\n   \
    \         dp[x][y] = dp[curr.first][curr.second] + grid[x][y];\n            parent[x][y]\
    \ = curr.first * n + curr.second;\n            q.push({x, y});\n        }\n  \
    \  }\n    std::vector<long> ans;\n    int curr = n * n - 1;\n    while (k > 0)\
    \ {\n        ans.push_back(grid[curr / n][curr % n]);\n        curr = parent[curr\
    \ / n][curr % n];\n        k--;\n    }\n    return ans;", "    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ parent(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \    std::vector<std::vector<std::vector<long>>> parent_i(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ parent_j(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l\
    \ <= k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j\
    \ = 0; j < n; j++) {\n                if (i > 0 && dp[i - 1][j][l - 1] != -1)\
    \ {\n                    if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i - 1][j][l - 1];\n            \
    \            parent[i][j][l] = 1;\n                        parent_i[i][j][l] =\
    \ i - 1;\n                        parent_j[i][j][l] = j;\n                   \
    \ }\n                }\n                if (i < n - 1 && dp[i + 1][j][l - 1] !=\
    \ -1) {\n                    if (dp[i][j][l] == -1 || dp[i + 1][j][l - 1] < dp[i][j",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<long> res;\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<int>> parent(n, std::vector<int>(n, -1));\n    std::vector<std::vector<int>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::priority_queue<std::vector<long>,\
    \ std::vector<std::vector<long>>, std::greater<std::vector<long>>> pq;\n    pq.push({grid[0][0],\
    \ 0, 0});\n    dp[0][0] = grid[0][0];\n    while (!pq.empty()) {\n        auto\
    \ [val, x, y] = pq.top();\n        pq.pop();\n        if (val > dp[x][y]) continue;\n\
    \        for (auto [dx, dy] : dir) {\n            int nx = x + dx, ny = y + dy;\n\
    \            if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\n         \
    \   if (dp[nx][ny] > dp[x][y] + grid[nx][ny]) {\n                dp[nx][ny] =\
    \ dp[x][y] + grid[nx][ny];\n                parent[nx][ny] = x * n + y;\n    \
    \            pq.push({dp[nx][ny], nx, ny});\n            }\n        }\n    }\n\
    \    int x = n - 1, y = n - 1;\n    while (k--) {\n        res.push_back(grid[x][y]);\n\
    \        int p = parent[x][y];\n        x = p / n;\n        y = p % n;\n    }\n\
    \    std::reverse(res.begin(), res.end());\n    return res;", "    // Write your\
    \ code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    std::vector<std::vector<std::vector<int>>> dp_idx(n, std::vector<std::vector<int>>(n,\
    \ std::vector<int>(k + 1, -1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   dp_idx[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                if (i - 1 >= 0 && dp[i - 1][j][l - 1] < dp[i][j][l])\
    \ {\n                    dp[i][j][l] = dp[i - 1][j][l - 1];\n                \
    \    dp_idx[i][j][l] = grid[i][j];\n                }\n                if (i +\
    \ 1 < n && dp[i + 1][j][l - 1] < dp[i][j][l]) {\n                    dp[i][j][l]\
    \ = dp[i + 1][j][l - 1];\n                    dp_idx[i][j][l] = grid[i][j];\n\
    \                }\n                if (j - 1 >= 0 && dp[i][j - 1][l - 1] < dp[i][j][l])\
    \ {\n                    dp[i][j][l] = dp[i][j - 1][l - 1];\n                \
    \    dp_idx[i][j][l] = grid[i][j];\n                }\n                if (j +\
    \ 1 < n && dp[i][j + 1][l - 1", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0; i < n; i++)\
    \ {\n            for (int j = 0; j < n; j++) {\n                for (int x = 0;\
    \ x < n; x++) {\n                    for (int y = 0; y < n; y++) {\n         \
    \               if (abs(x - i) + abs(y - j) == 1) {\n                        \
    \    if (dp[x][y][l - 1] != -1) {\n                                if (dp[i][j][l]\
    \ == -1 || dp[i][j][l] > dp[x][y][l - 1] * 10 + grid[i][j]) {\n              \
    \                      dp[i][j][l] = dp[x][y][l - 1] * 10 + grid[i][j];\n    \
    \                                path[i][j][l] = path[x][y][l - 1];\n        \
    \                            path[i][j][l].push_back(grid[i][j]);\n          \
    \                      }\n                            }\n                    \
    \    }\n                    }\n                }\n            }\n        }\n \
    \   }\n    std::vector<long> ans;\n    long min = -1;\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = 0;", "    // Write your code here\n    int n\
    \ = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j][0] = grid[i][j];\n            }\n\
    \            else if(i == 0) {\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                path[i][j] = path[i][j-1];\n                path[i][j][0] = grid[i][j];\n\
    \            }\n            else if(j == 0) {\n                dp[i][j] = dp[i-1][j]\
    \ + grid[i][j];\n                path[i][j] = path[i-1][j];\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else {\n                if(dp[i-1][j]\
    \ < dp[i][j-1]) {\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\n \
    \                   path[i][j] = path[i-1][j];\n                    path[i][j][0]\
    \ = grid[i][j];\n                }\n                else if(dp[i-1][j] > dp[i][j-1])\
    \ {\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\n               \
    \     path[i][j] = path[i][j-1];\n                    path[i][j][0] = grid[i][j];\n\
    \                }\n                else {\n                    dp[i][j] = dp[i-",
  "    // Write your code here\n    std::vector<long> result;\n    if(grid.size()\
    \ == 0 || grid[0].size() == 0) return result;\n    int n = grid.size();\n    int\
    \ m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k, INT_MAX)));\n    for(int i = 0; i < n; i++){\n        for(int\
    \ j = 0; j < m; j++){\n            dp[i][j][0] = grid[i][j];\n        }\n    }\n\
    \    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n      \
    \      if(i > 0){\n                dp[i][j][1] = std::min(dp[i][j][1], dp[i-1][j][0]);\n\
    \            }\n            if(j > 0){\n                dp[i][j][1] = std::min(dp[i][j][1],\
    \ dp[i][j-1][0]);\n            }\n            if(i < n-1){\n                dp[i][j][1]\
    \ = std::min(dp[i][j][1], dp[i+1][j][0]);\n            }\n            if(j < m-1){\n\
    \                dp[i][j][1] = std::min(dp[i][j][1], dp[i][j+1][0]);\n       \
    \     }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j\
    \ = 0; j < m; j++){\n            for(int l = 2; l < k; l++){\n               \
    \ if(i > 0){\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i-1][j][l-1]);\n\
    \                }\n                if(j > 0){\n                    dp[i][j][l]\
    \ = std::min(dp[i", "    // Write your code here\n    int n = grid.size();\n \
    \   std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n   \
    \ std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n       \
    \         path[i][j][0] = grid[i][j];\n            } else if (j == 0) {\n    \
    \            dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j][0] = grid[i][j];\n\
    \            } else {\n                dp[i][j] = std::min(dp[i - 1][j], dp[i][j\
    \ - 1]) + 1;\n                path[i][j][0] = grid[i][j];\n            }\n   \
    \     }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <\
    \ n; j++) {\n            for (int l = 1; l <= k; l++) {\n                if (i\
    \ == 0 && j == 0) {\n                    path[i][j][l] = grid[i][j];\n       \
    \         } else if (i == 0) {\n                    path[i][j][l] = path[i][j\
    \ - 1][l - 1];\n                } else if (j == 0) {\n                    path[i][j][l]\
    \ = path[i - 1][j][l - 1];\n                } else {\n                    if (dp[i\
    \ - 1][j] < dp[i][j - 1]) {\n                        path[i][j][", "  // your\
    \ code goes here\n  // find the min path\n  // return the path\n  // path is a\
    \ vector of longs\n  // path is a vector of vectors of longs\n  // path is a vector\
    \ of vectors of vectors of longs\n  // path is a vector of vectors of vectors\
    \ of vectors of longs\n  // path is a vector of vectors of vectors of vectors\
    \ of vectors of longs\n  // path is a vector of vectors of vectors of vectors\
    \ of vectors of vectors of longs\n  // path is a vector of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of longs\n  // path is a vector\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of longs\n  // path is a vector of vectors of vectors of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of longs\n  // path is a vector\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of vectors of vectors of longs\n  // path is a vector of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of vectors of longs\n  // path is a vector of vectors of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of vectors of longs\n  // path is a vector of vectors of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of vectors of vectors of longs\n  // path is a vector of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of longs\n  // path is a vector\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of longs\n  // path is a vector of vectors of vectors of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of longs\n  // path is a vector\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of vectors of vectors of longs\n  // path is a vector of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of vectors of vectors of vectors of vectors of vectors of vectors of vectors\
    \ of vectors of longs\n  // path is a", "    std::vector<long> result;\n    //\
    \ your code goes here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(m, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, -1)));\n    dp[0][0] = grid[0][0];\n    path[0][0][0]\
    \ = grid[0][0];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j\
    \ < m; j++) {\n            if (i - 1 >= 0) {\n                for (int l = 0;\
    \ l < k; l++) {\n                    if (path[i - 1][j][l] != -1) {\n        \
    \                if (dp[i - 1][j] + grid[i][j] < dp[i][j]) {\n               \
    \             dp[i][j] = dp[i - 1][j] + grid[i][j];\n                        \
    \    path[i][j] = path[i - 1][j];\n                            path[i][j][l +\
    \ 1] = grid[i][j];\n                        }\n                    }\n       \
    \         }\n            }\n            if (j - 1 >= 0) {\n                for\
    \ (int l = 0; l < k; l++) {\n                    if (path[i][j - 1][l] != -1)\
    \ {\n                        if (dp[i][j - 1] + grid[i][j] < dp[i][j]) {\n   \
    \                         dp[i][j] = dp[i][j - 1] + grid[i][j];\n            \
    \                path[i][j] = path[i][j - 1];\n                            path[i][j][l\
    \ + 1] = grid[i][j];\n                        }\n                    }\n     \
    \           }\n            }\n        }\n    }\n    for (int i = 0; i < k; i++)\
    \ {\n        result.push_back(path[", "    std::vector<long> result;\n    // your\
    \ code goes here\n    return result;", "    // Write your code here\n    int n\
    \ = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<long>> path(n, std::vector<long>(n,\
    \ -1));\n    std::vector<std::vector<long>> visited(n, std::vector<long>(n, 0));\n\
    \    std::vector<std::vector<long>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\
    \    std::queue<std::pair<int, int>> q;\n    q.push({0, 0});\n    dp[0][0] = grid[0][0];\n\
    \    while (!q.empty()) {\n        auto cur = q.front();\n        q.pop();\n \
    \       for (auto d : dir) {\n            int x = cur.first + d[0];\n        \
    \    int y = cur.second + d[1];\n            if (x < 0 || x >= n || y < 0 || y\
    \ >= n) continue;\n            if (visited[x][y]) continue;\n            if (dp[x][y]\
    \ > dp[cur.first][cur.second] + grid[x][y]) {\n                dp[x][y] = dp[cur.first][cur.second]\
    \ + grid[x][y];\n                path[x][y] = cur.first * n + cur.second;\n  \
    \          }\n            q.push({x, y});\n        }\n        visited[cur.first][cur.second]\
    \ = 1;\n    }\n    std::vector<long> res;\n    int x = n - 1, y = n - 1;\n   \
    \ while (k--) {\n        res.push_back(grid[x][y]);\n        int tmp = path[x][y];\n\
    \        x = tmp / n;\n        y = tmp % n;\n    }\n    return res;", "    std::vector<long>\
    \ result;\n    // Implement your solution here\n    return result;", "    // Write\
    \ your code here\n    std::vector<long> res;\n    if(grid.size() == 0)\n     \
    \   return res;\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, LONG_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    std::vector<std::vector<int>>\
    \ visited(n, std::vector<int>(m, 0));\n    std::queue<std::pair<int, int>> q;\n\
    \    q.push({0, 0});\n    dp[0][0] = grid[0][0];\n    path[0][0].push_back(grid[0][0]);\n\
    \    visited[0][0] = 1;\n    while(!q.empty()){\n        auto curr = q.front();\n\
    \        q.pop();\n        int x = curr.first;\n        int y = curr.second;\n\
    \        if(x + 1 < n && visited[x + 1][y] == 0){\n            if(dp[x + 1][y]\
    \ > dp[x][y] + grid[x + 1][y]){\n                dp[x + 1][y] = dp[x][y] + grid[x\
    \ + 1][y];\n                path[x + 1][y] = path[x][y];\n                path[x\
    \ + 1][y].push_back(grid[x + 1][y]);\n            }\n            else if(dp[x\
    \ + 1][y] == dp[x][y] + grid[x + 1][y]){\n                std::vector<long> temp\
    \ = path[x][y];\n                temp.push_back(grid[x + 1][y]);\n           \
    \     if(temp < path[x + 1][y])\n                    path[x + 1][y] = temp;\n\
    \            }\n            visited[x + 1][y] = 1;\n            q.push({x + 1,\
    \ y});\n        }\n        if(", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i - 1 >= 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i\
    \ - 1][j][l - 1]);\n                }\n                if (i + 1 < n) {\n    \
    \                dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n \
    \               }\n                if (j - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n                }\n         \
    \       if (j + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n                dp[i][j][l] += grid[i][j];\n\
    \            }\n        }\n    }\n    long min_val = INT_MAX;\n    std::vector<long>\
    \ ans;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n\
    \                ans = {grid[i][j]};\n            }\n            else if (dp[i][j][",
  "    // Write your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(m, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(m,\
    \ 0));\n    std::queue<std::pair<int, int>> q;\n    q.push({0, 0});\n    dp[0][0]\
    \ = grid[0][0];\n    path[0][0].push_back(grid[0][0]);\n    while(!q.empty())\
    \ {\n        auto curr = q.front();\n        q.pop();\n        int x = curr.first;\n\
    \        int y = curr.second;\n        visited[x][y] = 1;\n        if(x + 1 <\
    \ n && visited[x + 1][y] == 0) {\n            q.push({x + 1, y});\n          \
    \  if(dp[x + 1][y] > dp[x][y] + grid[x + 1][y]) {\n                dp[x + 1][y]\
    \ = dp[x][y] + grid[x + 1][y];\n                path[x + 1][y] = path[x][y];\n\
    \                path[x + 1][y].push_back(grid[x + 1][y]);\n            }\n  \
    \          else if(dp[x + 1][y] == dp[x][y] + grid[x + 1][y]) {\n            \
    \    std::vector<long> temp = path[x][y];\n                temp.push_back(grid[x\
    \ + 1][y]);\n                if(temp < path[x + 1][y]) {\n                   \
    \ path[x + 1][y] = temp;\n                }\n            }\n        }\n      \
    \  if(y + 1 < m && visited[x][y + 1] == 0) {\n            q.push({x, y + 1});\n\
    \            if(", "    // Write your code here\n    // Return an ordered list\
    \ of the values on the cells that the minimum path go through.\n    long n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for(long i = 0; i < n; i++) {\n        for(long\
    \ j = 0; j < n; j++) {\n            if(i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j][0] = grid[i][j];\n            }\n\
    \            else if(i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                path[i][j] = path[i][j - 1];\n                path[i][j][0] =\
    \ grid[i][j];\n            }\n            else if(j == 0) {\n                dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                path[i][j] = path[i - 1][j];\n\
    \                path[i][j][0] = grid[i][j];\n            }\n            else\
    \ {\n                if(dp[i - 1][j] < dp[i][j - 1]) {\n                    dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                    path[i][j] = path[i - 1][j];\n\
    \                    path[i][j][0] = grid[i][j];\n                }\n        \
    \        else {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n \
    \                   path[i][j] = path[i][j - 1];\n                    path[i][j][0]\
    \ = grid[i][j];\n                }\n            }\n        }\n    }\n    long\
    \ i = n - 1, j", "  // your code goes here\n  long n = grid.size();\n  std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, LONG_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ prev(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \  for (long i = 0; i < n; i++) {\n    for (long j = 0; j < n; j++) {\n      if\
    \ (i == 0 && j == 0) {\n        dp[i][j] = 0;\n        prev[i][j][0] = -1;\n \
    \     } else {\n        if (i > 0) {\n          if (dp[i - 1][j] + 1 < dp[i][j])\
    \ {\n            dp[i][j] = dp[i - 1][j] + 1;\n            prev[i][j] = prev[i\
    \ - 1][j];\n            prev[i][j][dp[i][j]] = grid[i - 1][j];\n          }\n\
    \        }\n        if (j > 0) {\n          if (dp[i][j - 1] + 1 < dp[i][j]) {\n\
    \            dp[i][j] = dp[i][j - 1] + 1;\n            prev[i][j] = prev[i][j\
    \ - 1];\n            prev[i][j][dp[i][j]] = grid[i][j - 1];\n          }\n   \
    \     }\n      }\n    }\n  }\n  std::vector<long> ans;\n  for (long i = 0; i <=\
    \ k; i++) {\n    ans.push_back(prev[n - 1][n - 1][i]);\n  }\n  return ans;", " \
    \   // Write your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k+1, INT_MAX)));\n    for(int i = 0; i < n; i++){\n      \
    \  for(int j = 0; j < m; j++){\n            dp[i][j][1] = grid[i][j];\n      \
    \  }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n\
    \            for(int l = 2; l <= k; l++){\n                if(i > 0){\n      \
    \              dp[i][j][l] = std::min(dp[i][j][l], dp[i-1][j][l-1]);\n       \
    \         }\n                if(j > 0){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j-1][l-1]);\n                }\n                if(i < n-1){\n       \
    \             dp[i][j][l] = std::min(dp[i][j][l], dp[i+1][j][l-1]);\n        \
    \        }\n                if(j < m-1){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j+1][l-1]);\n                }\n                dp[i][j][l] += grid[i][j];\n\
    \            }\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(grid[0][0]);\n\
    \    int i = 0, j = 0;\n    for(int l = 2; l <= k; l++){\n        if(i > 0 &&\
    \ dp[i][j][l] == dp[i-1][j][l-1] + grid[i][j]){\n            ans.push_back(grid[i-1][j]);\n\
    \            i", "    // Write your code here\n    std::vector<long> res;\n  \
    \  int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(i ==\
    \ 0 && j == 0){\n                dp[i][j] = 0;\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(i == 0){\n                dp[i][j] = dp[i][j-1]\
    \ + 1;\n                path[i][j] = path[i][j-1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(j == 0){\n                dp[i][j] = dp[i-1][j]\
    \ + 1;\n                path[i][j] = path[i-1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else{\n                if(dp[i-1][j] < dp[i][j-1]){\n\
    \                    dp[i][j] = dp[i-1][j] + 1;\n                    path[i][j]\
    \ = path[i-1][j];\n                    path[i][j].push_back(grid[i][j]);\n   \
    \             }\n                else if(dp[i-1][j] > dp[i][j-1]){\n         \
    \           dp[i][j] = dp[i][j-1] + 1;\n                    path[i][j] = path[i][j-1];\n\
    \                    path[i][j].push_back(grid[i][j]);\n                }\n  \
    \              else{\n                    dp[i][j] = dp[i-", "    // Write your\
    \ code here\n    std::vector<long> res;\n    int n = grid.size();\n    int m =\
    \ grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>> visited(n,\
    \ std::vector<std::vector<long>>(m, std::vector<long>()));\n    std::vector<std::vector<int>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::queue<std::pair<int, int>>\
    \ q;\n    q.push({0, 0});\n    dp[0][0] = 0;\n    path[0][0].push_back(grid[0][0]);\n\
    \    visited[0][0].push_back(grid[0][0]);\n    while (!q.empty()) {\n        auto\
    \ cur = q.front();\n        q.pop();\n        for (auto d : dir) {\n         \
    \   int x = cur.first + d[0];\n            int y = cur.second + d[1];\n      \
    \      if (x < 0 || x >= n || y < 0 || y >= m) continue;\n            if (dp[x][y]\
    \ > dp[cur.first][cur.second] + 1) {\n                dp[x][y] = dp[cur.first][cur.second]\
    \ + 1;\n                path[x][y] = path[cur.first][cur.second];\n          \
    \      path[x][y].push_back(grid[x][y]);\n                visited[x][y] = visited[cur.first][cur.second];\n\
    \                visited[x][y].push_back(grid[x][y]);\n                q.push({x,\
    \ y});\n            } else if (dp[x][y] == dp[cur.first][cur.second] + 1) {\n\
    \                if (visited[x][", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i - 1 >= 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i\
    \ - 1][j][l - 1]);\n                }\n                if (i + 1 < n) {\n    \
    \                dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n \
    \               }\n                if (j - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n                }\n         \
    \       if (j + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n                dp[i][j][l] += grid[i][j];\n\
    \            }\n        }\n    }\n    long min_val = INT_MAX;\n    int min_i =\
    \ -1, min_j = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            if (dp[i][j][k] < min_val) {\n                min_val\
    \ = dp[i][j][k];\n                min_i = i;\n                min_j = j;\n   \
    \         }", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> path(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<long> ans;\n    for(int i = 0; i\
    \ < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i == 0 &&\
    \ j == 0) {\n                dp[i][j] = grid[i][j];\n                continue;\n\
    \            }\n            for(int d = 0; d < 4; d++) {\n                int\
    \ x = i + dir[d][0];\n                int y = j + dir[d][1];\n               \
    \ if(x < 0 || x >= n || y < 0 || y >= n) continue;\n                if(dp[x][y]\
    \ + grid[i][j] < dp[i][j]) {\n                    dp[i][j] = dp[x][y] + grid[i][j];\n\
    \                    path[i][j] = d;\n                }\n            }\n     \
    \   }\n    }\n    int i = n - 1, j = n - 1;\n    while(k--) {\n        ans.push_back(grid[i][j]);\n\
    \        int x = i + dir[path[i][j]][0];\n        int y = j + dir[path[i][j]][1];\n\
    \        i = x;\n        j = y;\n    }\n    return ans;", "  // Write your code\
    \ here\n  std::vector<long> result;\n  int n = grid.size();\n  int m = grid[0].size();\n\
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(m, INT_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n  std::vector<std::vector<std::vector<long>>>\
    \ path_temp(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n  for\
    \ (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (i ==\
    \ 0 && j == 0) {\n        dp[i][j] = 0;\n        path[i][j].push_back(grid[i][j]);\n\
    \      } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + 1;\n        path[i][j]\
    \ = path[i][j - 1];\n        path[i][j].push_back(grid[i][j]);\n      } else if\
    \ (j == 0) {\n        dp[i][j] = dp[i - 1][j] + 1;\n        path[i][j] = path[i\
    \ - 1][j];\n        path[i][j].push_back(grid[i][j]);\n      } else {\n      \
    \  if (dp[i - 1][j] < dp[i][j - 1]) {\n          dp[i][j] = dp[i - 1][j] + 1;\n\
    \          path[i][j] = path[i - 1][j];\n          path[i][j].push_back(grid[i][j]);\n\
    \        } else if (dp[i - 1][j] > dp[i][j - 1]) {\n          dp[i][j] = dp[i][j\
    \ - 1] + 1;\n          path[i][j] = path[i][j - 1];\n         ", "    std::vector<long>\
    \ result;\n    // Implement your solution here\n    return result;", "    // Write\
    \ your code here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n    \
    \        dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++) {\n        for(int j = 0; j < m; j++) {\n            for(int l = 2; l <=\
    \ k; l++) {\n                if(i - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if(i + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if(j - 1 >= 0) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if(j + 1 < m) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    long min = INT_MAX;\n    int x = -1, y = -1;\n  \
    \  for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n      \
    \      if(dp[i][j][k] < min) {\n                min = dp[i][j][k];\n         \
    \       x = i;\n                y = j;\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans.push", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < n; j++)\n        {\n            if(i == 0 && j == 0)\n          \
    \  {\n                dp[i][j] = grid[i][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            }\n            else\n            {\n              \
    \  if(i > 0)\n                {\n                    if(dp[i - 1][j] + grid[i][j]\
    \ < dp[i][j])\n                    {\n                        dp[i][j] = dp[i\
    \ - 1][j] + grid[i][j];\n                        for(int l = 0; l < k; l++)\n\
    \                        {\n                            path[i][j][l] = path[i\
    \ - 1][j][l];\n                        }\n                        path[i][j][0]\
    \ = grid[i][j];\n                    }\n                }\n                if(j\
    \ > 0)\n                {\n                    if(dp[i][j - 1] + grid[i][j] <\
    \ dp[i][j])\n                    {\n                        dp[i][j] = dp[i][j\
    \ - 1] + grid[i][j];\n                        for(int l = 0; l < k; l++)\n   \
    \                     {\n                            path[i][j][l] = path[i][j\
    \ - 1][l];\n                        }\n                        path[i][j][0] =\
    \ grid[i][j];\n                    }\n                }\n            }\n     \
    \   }\n    }\n    return path[n - 1][n - 1];", "    int n = grid.size();\n   \
    \ std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>>\
    \ path(n, std::vector<int>(n, -1));\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n     \
    \           dp[i][j] = 0;\n                continue;\n            }\n        \
    \    if (i > 0) {\n                if (dp[i - 1][j] + 1 < dp[i][j]) {\n      \
    \              dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j] =\
    \ 0;\n                }\n            }\n            if (j > 0) {\n           \
    \     if (dp[i][j - 1] + 1 < dp[i][j]) {\n                    dp[i][j] = dp[i][j\
    \ - 1] + 1;\n                    path[i][j] = 1;\n                }\n        \
    \    }\n        }\n    }\n    std::vector<long> ans;\n    int x = n - 1, y = n\
    \ - 1;\n    while (k > 0) {\n        ans.push_back(grid[x][y]);\n        if (path[x][y]\
    \ == 0) {\n            x--;\n        } else {\n            y--;\n        }\n \
    \       k--;\n    }\n    return ans;", "    // Write your code here\n    int n\
    \ = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k+1, INT_MAX)));\n    for(int i = 0; i < n; i++){\n      \
    \  for(int j = 0; j < n; j++){\n            dp[i][j][1] = grid[i][j];\n      \
    \  }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n\
    \            for(int l = 2; l <= k; l++){\n                if(i-1 >= 0){\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i-1][j][l-1]);\n    \
    \            }\n                if(i+1 < n){\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i+1][j][l-1]);\n                }\n             \
    \   if(j-1 >= 0){\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j-1][l-1]);\n\
    \                }\n                if(j+1 < n){\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j+1][l-1]);\n                }\n             \
    \   dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long min_val\
    \ = INT_MAX;\n    int min_i, min_j;\n    for(int i = 0; i < n; i++){\n       \
    \ for(int j = 0; j < n; j++){\n            if(dp[i][j][k] < min_val){\n      \
    \          min_val = dp[i][j][k];\n                min_i = i;\n              \
    \  min_j = j;\n            }\n        }\n    }\n    std::vector", "  // your code\
    \ goes here\n  std::vector<long> res;\n  int n = grid.size();\n  if (n == 0) return\
    \ res;\n  int m = grid[0].size();\n  if (m == 0) return res;\n  std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < m; ++j) {\n      dp[i][j][1]\
    \ = grid[i][j];\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    for (int j =\
    \ 0; j < m; ++j) {\n      for (int l = 2; l <= k; ++l) {\n        if (i > 0) {\n\
    \          dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n       \
    \ }\n        if (i < n - 1) {\n          dp[i][j][l] = std::min(dp[i][j][l], dp[i\
    \ + 1][j][l - 1]);\n        }\n        if (j > 0) {\n          dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n        }\n        if (j < m - 1) {\n          dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n        }\n      }\n    }\n \
    \ }\n  long min_val = INT_MAX;\n  for (int i = 0; i < n; ++i) {\n    for (int\
    \ j = 0; j < m; ++j) {\n      min_val = std::min(min_val, dp[i][j][k]);\n    }\n\
    \  }\n  std::vector<std::vector<int>>", "    // Write your code here\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    // std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0", "  int n = grid.size();\n  std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ parent(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1)));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n\
    \      dp[i][j][1] = grid[i][j];\n      parent[i][j][1] = {i, j};\n    }\n  }\n\
    \  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      for\
    \ (int l = 2; l <= k; l++) {\n        if (i > 0 && dp[i - 1][j][l - 1] != -1)\
    \ {\n          if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l]) {\n\
    \            dp[i][j][l] = dp[i - 1][j][l - 1];\n            parent[i][j][l] =\
    \ parent[i - 1][j][l - 1];\n            parent[i][j][l].push_back(i);\n      \
    \      parent[i][j][l].push_back(j);\n          }\n        }\n        if (i <\
    \ n - 1 && dp[i + 1][j][l - 1] != -1) {\n          if (dp[i][j][l] == -1 || dp[i\
    \ + 1][j][l - 1] < dp[i][j][l]) {\n            dp[i][j][l] = dp[i + 1][j][l -\
    \ 1];\n            parent[i][j][l] = parent[i + 1][j][l - 1];\n            parent[i][j][l].",
  "    // Write your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k+1, INT_MAX)));\n    for(int i = 0; i < n; i++){\n      \
    \  for(int j = 0; j < m; j++){\n            dp[i][j][1] = grid[i][j];\n      \
    \  }\n    }\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n\
    \            for(int l = 2; l <= k; l++){\n                if(i > 0){\n      \
    \              dp[i][j][l] = std::min(dp[i][j][l], dp[i-1][j][l-1]);\n       \
    \         }\n                if(j > 0){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j-1][l-1]);\n                }\n                if(i < n-1){\n       \
    \             dp[i][j][l] = std::min(dp[i][j][l], dp[i+1][j][l-1]);\n        \
    \        }\n                if(j < m-1){\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j+1][l-1]);\n                }\n                dp[i][j][l] += grid[i][j];\n\
    \            }\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(grid[0][0]);\n\
    \    int i = 0, j = 0;\n    for(int l = 2; l <= k; l++){\n        if(i > 0 &&\
    \ dp[i][j][l] == dp[i-1][j][l-1] + grid[i][j]){\n            ans.push_back(grid[i-1][j]);\n\
    \            i", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::priority_queue<std::pair<long, std::pair<int,\
    \ int>>,\n                        std::vector<std::pair<long, std::pair<int, int>>>,\n\
    \                        std::greater<std::pair<long, std::pair<int, int>>>>\n\
    \        pq;\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n\
    \    while (!pq.empty()) {\n        auto [val, pos] = pq.top();\n        pq.pop();\n\
    \        int x = pos.first;\n        int y = pos.second;\n        if (val > dp[x][y])\
    \ continue;\n        for (auto [dx, dy] : dir) {\n            int nx = x + dx;\n\
    \            int ny = y + dy;\n            if (nx < 0 || nx >= n || ny < 0 ||\
    \ ny >= n) continue;\n            if (dp[nx][ny] > dp[x][y] + grid[nx][ny]) {\n\
    \                dp[nx][ny] = dp[x][y] + grid[nx][ny];\n                parent[nx][ny]\
    \ = x * n + y;\n                pq.push({dp[nx][ny], {nx, ny}});\n           \
    \ }\n        }\n    }\n    std::vector<long> res;\n    int x = n - 1;\n    int\
    \ y = n - 1;\n    for (int i = 0; i < k; ++i) {\n        res.push_back(grid[x][y]);\n\
    \        int nx = parent[x][y] / n", "    std::vector<long> ans;\n    // your\
    \ code goes here\n    return ans;", "    // Write your code here\n    int n =\
    \ grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                long min = INT_MAX;\n                if (i > 0)\
    \ {\n                    min = std::min(min, dp[i - 1][j][l - 1]);\n         \
    \       }\n                if (i < n - 1) {\n                    min = std::min(min,\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 min = std::min(min, dp[i][j - 1][l - 1]);\n                }\n\
    \                if (j < m - 1) {\n                    min = std::min(min, dp[i][j\
    \ + 1][l - 1]);\n                }\n                dp[i][j][l] = min;\n     \
    \       }\n        }\n    }\n    std::vector<long> result;\n    int i = 0, j =\
    \ 0;\n    for (int l = 1; l <= k; l++) {\n        result.push_back(dp[i][j][l]);\n\
    \        if (i > 0 && dp[i - 1][j][l] == dp[i][j][l + 1]) {\n            i--;\n\
    \        } else if (i < n - 1 && dp[i + 1][j][l] == dp[i][j][l + 1]) {\n     \
    \       i++;\n        } else if (j > 0 && dp[i][j - 1][l] == dp[i][j", "    //\
    \ Write your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min_val = INT_MAX;\n    int min_i = -1, min_j = -1;\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j][k]\
    \ < min_val) {\n                min_val = dp[i][j][k];\n                min_i\
    \ = i;\n                min_j = j;\n            }\n        }\n", "    // Write\
    \ your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n \
    \   for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n   \
    \         if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n  \
    \              path[i][j][1] = grid[i][j];\n            } else if (i == 0) {\n\
    \                dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j][1]\
    \ = grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] =\
    \ dp[i - 1][j] + grid[i][j];\n                path[i][j][1] = grid[i][j];\n  \
    \          } else {\n                dp[i][j] = std::min(dp[i - 1][j], dp[i][j\
    \ - 1]) + grid[i][j];\n                path[i][j][1] = grid[i][j];\n         \
    \   }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j\
    \ = 0; j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n           \
    \     if (i == 0 && j == 0) {\n                    path[i][j][l] = grid[i][j];\n\
    \                } else if (i == 0) {\n                    path[i][j][l] = path[i][j\
    \ - 1][l - 1] + grid[i][j];\n                } else if (j == 0) {\n          \
    \          path[i][j][l] = path[i - 1][j][l - 1] + grid[i][j];\n             \
    \   } else {\n", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n \
    \   for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n   \
    \         dp[i][j] = grid[i][j];\n            path[i][j][1] = grid[i][j];\n  \
    \      }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j\
    \ < n; j++) {\n            if (i - 1 >= 0) {\n                if (dp[i - 1][j]\
    \ > dp[i][j]) {\n                    dp[i - 1][j] = dp[i][j];\n              \
    \      path[i - 1][j] = path[i][j];\n                } else if (dp[i - 1][j] ==\
    \ dp[i][j]) {\n                    if (path[i - 1][j] > path[i][j]) {\n      \
    \                  path[i - 1][j] = path[i][j];\n                    }\n     \
    \           }\n            }\n            if (i + 1 < n) {\n                if\
    \ (dp[i + 1][j] > dp[i][j]) {\n                    dp[i + 1][j] = dp[i][j];\n\
    \                    path[i + 1][j] = path[i][j];\n                } else if (dp[i\
    \ + 1][j] == dp[i][j]) {\n                    if (path[i + 1][j] > path[i][j])\
    \ {\n                        path[i + 1][j] = path[i][j];\n                  \
    \  }\n                }\n            }\n            if (j - 1 >= 0) {\n      \
    \          if (dp[i][j - 1] > dp[i][j]) {\n                    dp[i][j - 1] =",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l\
    \ <= k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j\
    \ = 0; j < n; j++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(grid[0][0]);\n\
    \    int i = 0, j = 0;\n    for (int l = 2; l <= k; l++) {\n        if (i > 0\
    \ && dp[i][j][l] == dp[i - 1][j][l - 1]) {\n            ans.push_back(grid[i -\
    \ 1][j]);\n            i--;\n        } else if (i < n - 1 && dp[i][j][l] == dp[i\
    \ + 1][j", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n                path[i][j][0]\
    \ = grid[i][j];\n            }\n            else if(i == 0) {\n              \
    \  dp[i][j] = dp[i][j-1] + grid[i][j];\n                path[i][j] = path[i][j-1];\n\
    \                path[i][j][0] = grid[i][j];\n            }\n            else\
    \ if(j == 0) {\n                dp[i][j] = dp[i-1][j] + grid[i][j];\n        \
    \        path[i][j] = path[i-1][j];\n                path[i][j][0] = grid[i][j];\n\
    \            }\n            else {\n                if(dp[i-1][j] < dp[i][j-1])\
    \ {\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\n               \
    \     path[i][j] = path[i-1][j];\n                    path[i][j][0] = grid[i][j];\n\
    \                }\n                else if(dp[i-1][j] > dp[i][j-1]) {\n     \
    \               dp[i][j] = dp[i][j-1] + grid[i][j];\n                    path[i][j]\
    \ = path[i][j-1];\n                    path[i][j][0] = grid[i][j];\n         \
    \       }\n                else {\n                    dp[i][j] = dp[i-", "  std::vector<long>\
    \ result;\n  // your code goes here\n  return result;", "    // Write your code\
    \ here\n    std::vector<long> result;\n    std::vector<std::vector<long>> dp(grid.size(),\
    \ std::vector<long>(grid[0].size(), 0));\n    std::vector<std::vector<long>> path(grid.size(),\
    \ std::vector<long>(grid[0].size(), 0));\n    for(int i = 0; i < grid.size();\
    \ i++) {\n        for(int j = 0; j < grid[0].size(); j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n                path[i][j]\
    \ = grid[i][j];\n            } else if(i == 0) {\n                dp[i][j] = dp[i][j\
    \ - 1] + grid[i][j];\n                path[i][j] = path[i][j - 1] * 10 + grid[i][j];\n\
    \            } else if(j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j] * 10 + grid[i][j];\n            }\
    \ else {\n                if(dp[i - 1][j] < dp[i][j - 1]) {\n                \
    \    dp[i][j] = dp[i - 1][j] + grid[i][j];\n                    path[i][j] = path[i\
    \ - 1][j] * 10 + grid[i][j];\n                } else {\n                    dp[i][j]\
    \ = dp[i][j - 1] + grid[i][j];\n                    path[i][j] = path[i][j - 1]\
    \ * 10 + grid[i][j];\n                }\n            }\n        }\n    }\n   \
    \ long curr = path[grid.size() - 1][grid[0].size() - 1];\n    while(k > 0) {\n\
    \        result.push_back(curr % 10);\n        curr /= 10;\n        k--;\n   \
    \ }\n    return result;", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i - 1 >= 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i\
    \ - 1][j][l - 1]);\n                }\n                if (i + 1 < n) {\n    \
    \                dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n \
    \               }\n                if (j - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n                }\n         \
    \       if (j + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n                dp[i][j][l] += grid[i][j];\n\
    \            }\n        }\n    }\n    long min_val = INT_MAX;\n    std::vector<long>\
    \ ans;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n\
    \                ans = {grid[i][j]};\n            }\n            else if (dp[i][j][",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k+1, 0)));\n   \
    \ for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n       \
    \     if(i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n       \
    \         path[i][j][1] = grid[i][j];\n            }\n            else if(i ==\
    \ 0) {\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n                path[i][j][1]\
    \ = grid[i][j];\n            }\n            else if(j == 0) {\n              \
    \  dp[i][j] = dp[i-1][j] + grid[i][j];\n                path[i][j][1] = grid[i][j];\n\
    \            }\n            else {\n                dp[i][j] = std::min(dp[i-1][j],\
    \ dp[i][j-1]) + grid[i][j];\n                if(dp[i-1][j] < dp[i][j-1]) {\n \
    \                   path[i][j][1] = grid[i][j];\n                }\n         \
    \       else {\n                    path[i][j][1] = grid[i][j];\n            \
    \    }\n            }\n        }\n    }\n    for(int i = 0; i < n; i++) {\n  \
    \      for(int j = 0; j < n; j++) {\n            std::cout << dp[i][j] << \" \"\
    ;\n        }\n        std::cout << std::endl;\n    }\n    std::cout << std::endl;\n\
    \    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j", "    // Write\
    \ your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    dp[0][0]\
    \ = grid[0][0];\n    path[0][0][0] = grid[0][0];\n    for(int i = 0; i < n; i++){\n\
    \        for(int j = 0; j < n; j++){\n            if(i == 0 && j == 0) continue;\n\
    \            if(i > 0){\n                if(dp[i][j] > dp[i-1][j] + grid[i][j]){\n\
    \                    dp[i][j] = dp[i-1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i-1][j];\n                    path[i][j][0] = grid[i][j];\n\
    \                }\n            }\n            if(j > 0){\n                if(dp[i][j]\
    \ > dp[i][j-1] + grid[i][j]){\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                    path[i][j] = path[i][j-1];\n                    path[i][j][0]\
    \ = grid[i][j];\n                }\n            }\n        }\n    }\n    for(int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n            for(int\
    \ l = 1; l < k; l++){\n                if(i > 0){\n                    if(dp[i][j]\
    \ > dp[i-1][j] + grid[i][j]){\n                        dp[i][j] = dp[i-1][j] +\
    \ grid[i][j];\n                        path[i][j] = path[i-1][j];\n          \
    \              path[i][j", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k+1, INT_MAX)));\n    std::vector<std::vector<std::vector<long>>>\
    \ parent(n, std::vector<std::vector<long>>(n, std::vector<long>(k+1, -1)));\n\
    \    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n      \
    \      dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++){\n        for(int j = 0; j < n; j++){\n            for(int l = 2; l <=\
    \ k; l++){\n                if(i-1 >= 0 && dp[i-1][j][l-1] < dp[i][j][l]){\n \
    \                   dp[i][j][l] = dp[i-1][j][l-1];\n                    parent[i][j][l]\
    \ = 0;\n                }\n                if(i+1 < n && dp[i+1][j][l-1] < dp[i][j][l]){\n\
    \                    dp[i][j][l] = dp[i+1][j][l-1];\n                    parent[i][j][l]\
    \ = 1;\n                }\n                if(j-1 >= 0 && dp[i][j-1][l-1] < dp[i][j][l]){\n\
    \                    dp[i][j][l] = dp[i][j-1][l-1];\n                    parent[i][j][l]\
    \ = 2;\n                }\n                if(j+1 < n && dp[i][j+1][l-1] < dp[i][j][l]){\n\
    \                    dp[i][j][l] = dp[i][j+1][l-1];\n                    parent[i][j][l]\
    \ = 3", "  // your code goes here\n  std::vector<long> result;\n  std::vector<std::vector<long>>\
    \ dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n  std::vector<std::vector<long>>\
    \ path(grid.size(), std::vector<long>(grid[0].size(), 0));\n  for (int i = 0;\
    \ i < grid.size(); i++) {\n    for (int j = 0; j < grid[0].size(); j++) {\n  \
    \    if (i == 0 && j == 0) {\n        dp[i][j] = grid[i][j];\n        path[i][j]\
    \ = grid[i][j];\n      } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] +\
    \ grid[i][j];\n        path[i][j] = path[i][j - 1] * 10 + grid[i][j];\n      }\
    \ else if (j == 0) {\n        dp[i][j] = dp[i - 1][j] + grid[i][j];\n        path[i][j]\
    \ = path[i - 1][j] * 10 + grid[i][j];\n      } else {\n        if (dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n          dp[i][j] = dp[i - 1][j] + grid[i][j];\n       \
    \   path[i][j] = path[i - 1][j] * 10 + grid[i][j];\n        } else {\n       \
    \   dp[i][j] = dp[i][j - 1] + grid[i][j];\n          path[i][j] = path[i][j -\
    \ 1] * 10 + grid[i][j];\n        }\n      }\n    }\n  }\n  std::cout << path[grid.size()\
    \ - 1][grid[0].size() - 1] << std::endl;\n  return result;", "    // Write your\
    \ code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0; i < n; i++)\
    \ {\n            for (int j = 0; j < n; j++) {\n                if (i > 0) {\n\
    \                    if (dp[i - 1][j][l - 1] < dp[i][j][l]) {\n              \
    \          dp[i][j][l] = dp[i - 1][j][l - 1];\n                        path[i][j][l]\
    \ = path[i - 1][j][l - 1];\n                        path[i][j][l].push_back(grid[i][j]);\n\
    \                    }\n                }\n                if (i < n - 1) {\n\
    \                    if (dp[i + 1][j][l - 1] < dp[i][j][l]) {\n              \
    \          dp[i][j][l] = dp[i + 1][j][l - 1];\n                        path[i][j][l]\
    \ = path[i + 1][j][l - 1];\n                        path[i][j][l].push_back(grid[i][j]);\n\
    \                    }\n                }\n                if (j > 0) {\n    \
    \                if (dp[i][j - 1][l - 1] < dp[i][j][l]) {", "    // Write your\
    \ code here\n    std::vector<long> res;\n    long n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n \
    \   for (long i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n \
    \           if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n         \
    \       path[i][j][0] = grid[i][j];\n            } else if (i == 0) {\n      \
    \          dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j][0] = grid[i][j];\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n\
    \                path[i][j][0] = grid[i][j];\n            } else {\n         \
    \       dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;\n               \
    \ path[i][j][0] = grid[i][j];\n            }\n        }\n    }\n    for (long\
    \ i = 0; i < n; i++) {\n        for (long j = 0; j < n; j++) {\n            for\
    \ (long l = 1; l <= k; l++) {\n                if (i == 0 && j == 0) {\n     \
    \               path[i][j][l] = grid[i][j];\n                } else if (i == 0)\
    \ {\n                    path[i][j][l] = path[i][j - 1][l - 1];\n            \
    \    } else if (j == 0) {\n                    path[i][j][l] = path[i - 1][j][l\
    \ - 1];\n                } else {\n                    path[i][j][l] = std::min(path[i\
    \ - 1][", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<long> result;\n    std::priority_queue<std::pair<long,\
    \ std::pair<int, int>>, std::vector<std::pair<long, std::pair<int, int>>>, std::greater<std::pair<long,\
    \ std::pair<int, int>>>> pq;\n    dp[0][0] = grid[0][0];\n    pq.push({grid[0][0],\
    \ {0, 0}});\n    while (!pq.empty()) {\n        auto curr = pq.top();\n      \
    \  pq.pop();\n        int x = curr.second.first;\n        int y = curr.second.second;\n\
    \        if (dp[x][y] != curr.first) {\n            continue;\n        }\n   \
    \     for (int i = 0; i < 4; i++) {\n            int nx = x + dir[i][0];\n   \
    \         int ny = y + dir[i][1];\n            if (nx < 0 || nx >= n || ny < 0\
    \ || ny >= n) {\n                continue;\n            }\n            if (dp[nx][ny]\
    \ > dp[x][y] + grid[nx][ny]) {\n                dp[nx][ny] = dp[x][y] + grid[nx][ny];\n\
    \                parent[nx][ny] = i;\n                pq.push({dp[nx][ny], {nx,\
    \ ny}});\n            }\n        }\n    }\n    int x = n - 1;\n    int y = n -\
    \ 1;\n    while (k > 0) {\n        result.push_back(grid[x][y]);\n        int\
    \ p", "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    int x\
    \ = 0, y = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <\
    \ n; j++) {\n            if (dp[i][j][k] < dp[x][y][k]) {\n                x =\
    \ i;\n                y = j;\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(grid[x][y]);\n    k--;", "    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            path[i][j][1]\
    \ = grid[i][j];\n        }\n    }\n    for (int len = 2; len <= k; len++) {\n\
    \        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++)\
    \ {\n                if (i > 0 && dp[i - 1][j] < dp[i][j]) {\n               \
    \     dp[i][j] = dp[i - 1][j];\n                    path[i][j][len] = path[i -\
    \ 1][j][len - 1];\n                }\n                if (j > 0 && dp[i][j - 1]\
    \ < dp[i][j]) {\n                    dp[i][j] = dp[i][j - 1];\n              \
    \      path[i][j][len] = path[i][j - 1][len - 1];\n                }\n       \
    \         if (i < n - 1 && dp[i + 1][j] < dp[i][j]) {\n                    dp[i][j]\
    \ = dp[i + 1][j];\n                    path[i][j][len] = path[i + 1][j][len -\
    \ 1];\n                }\n                if (j < n - 1 && dp[i][j + 1] < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i][j + 1];\n                    path[i][j][len]\
    \ = path[i][j + 1][len - 1];\n                }\n                path[i][j][len].push_back(grid[i][j]);\n\
    \            }", "    // Write your code here\n    int n = grid.size();\n    int\
    \ m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<long>> parent(n, std::vector<long>(m,\
    \ -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(m, 0));\n\
    \    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\
    \    std::priority_queue<std::pair<long, std::pair<int, int>>,\n             \
    \           std::vector<std::pair<long, std::pair<int, int>>>,\n             \
    \           std::greater<std::pair<long, std::pair<int, int>>>>\n        pq;\n\
    \    pq.push({grid[0][0], {0, 0}});\n    dp[0][0] = grid[0][0];\n    while (!pq.empty())\
    \ {\n        auto [curr_val, curr_pos] = pq.top();\n        pq.pop();\n      \
    \  int x = curr_pos.first;\n        int y = curr_pos.second;\n        if (visited[x][y])\n\
    \            continue;\n        visited[x][y] = 1;\n        for (auto [dx, dy]\
    \ : dir) {\n            int nx = x + dx;\n            int ny = y + dy;\n     \
    \       if (nx < 0 || nx >= n || ny < 0 || ny >= m)\n                continue;\n\
    \            if (dp[nx][ny] > dp[x][y] + grid[nx][ny]) {\n                dp[nx][ny]\
    \ = dp[x][y] + grid[nx][ny];\n                parent[nx][ny] = x * m + y;\n  \
    \              pq.push({dp[nx][ny], {nx, ny}});\n            }\n        }\n  \
    \  }\n    std::vector<long> ans;\n", "    // Write your code here\n    int n =\
    \ grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    std::vector<std::vector<std::vector<long>>> parent(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, -1)));\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n     \
    \   }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m;\
    \ j++) {\n            for (int l = 2; l <= k; l++) {\n                if (i >\
    \ 0) {\n                    if (dp[i - 1][j][l - 1] < dp[i][j][l]) {\n       \
    \                 dp[i][j][l] = dp[i - 1][j][l - 1];\n                       \
    \ parent[i][j][l] = 0;\n                    }\n                }\n           \
    \     if (i < n - 1) {\n                    if (dp[i + 1][j][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i + 1][j][l - 1];\n            \
    \            parent[i][j][l] = 1;\n                    }\n                }\n\
    \                if (j > 0) {\n                    if (dp[i][j - 1][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i][j - 1][l - 1];\n            \
    \            parent[i][j][l] = 2;\n                    }\n                }\n\
    \                if (j < m - 1) {\n                    if (dp[i][j + 1][l - 1]\
    \ < dp[i][j][l]) {\n                        dp[", "  std::vector<long> result;\n\
    \  // your code goes here\n  return result;", "  // your code goes here\n  int\
    \ n = grid.size();\n  std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n  for (int i = 0; i < n; i++) {\n    for (int j\
    \ = 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp[i][j] = 0;\n \
    \       path[i][j][0] = grid[i][j];\n      } else if (i == 0) {\n        dp[i][j]\
    \ = dp[i][j - 1] + 1;\n        path[i][j] = path[i][j - 1];\n        path[i][j][dp[i][j]]\
    \ = grid[i][j];\n      } else if (j == 0) {\n        dp[i][j] = dp[i - 1][j] +\
    \ 1;\n        path[i][j] = path[i - 1][j];\n        path[i][j][dp[i][j]] = grid[i][j];\n\
    \      } else {\n        if (dp[i - 1][j] < dp[i][j - 1]) {\n          dp[i][j]\
    \ = dp[i - 1][j] + 1;\n          path[i][j] = path[i - 1][j];\n          path[i][j][dp[i][j]]\
    \ = grid[i][j];\n        } else if (dp[i - 1][j] > dp[i][j - 1]) {\n         \
    \ dp[i][j] = dp[i][j - 1] + 1;\n          path[i][j] = path[i][j - 1];\n     \
    \     path[i][j][dp[i][j]] = grid[i][j];\n        } else {\n          dp[i][j]\
    \ = dp[i - 1][j] + 1;\n          path[i][j", "    std::vector<long> result;\n\
    \    // your code goes here\n    return result;", "    std::vector<long> result;\n\
    \    // Implement your solution here\n    return result;", "  // your code goes\
    \ here\n  std::vector<long> result;\n  // Write your code here\n  int n = grid.size();\n\
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n  for\
    \ (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      path[i][j][0]\
    \ = grid[i][j];\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j =\
    \ 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp[i][j] = 0;\n   \
    \   } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + 1;\n      } else if\
    \ (j == 0) {\n        dp[i][j] = dp[i - 1][j] + 1;\n      } else {\n        dp[i][j]\
    \ = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;\n      }\n    }\n  }\n  if (dp[n\
    \ - 1][n - 1] < k) {\n    return result;\n  }\n  int i = n - 1;\n  int j = n -\
    \ 1;\n  int curr_k = k;\n  while (curr_k > 0) {\n    if (i == 0 && j == 0) {\n\
    \      result.push_back(grid[i][j]);\n      curr_k--;\n      break;\n    } else\
    \ if (i == 0) {\n      result.push_back(grid[i][j]);\n      j--;\n      curr_k--;\n\
    \    } else if (j == 0) {\n      result.push_back(grid[i][j]);\n      i--;\n \
    \     curr_k--", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> path(n,\
    \ std::vector<int>(n, -1));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                continue;\n            }\n            if (i >\
    \ 0) {\n                if (dp[i - 1][j] < dp[i][j]) {\n                    dp[i][j]\
    \ = dp[i - 1][j];\n                    path[i][j] = 0;\n                }\n  \
    \          }\n            if (j > 0) {\n                if (dp[i][j - 1] < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i][j - 1];\n                    path[i][j]\
    \ = 1;\n                }\n            }\n            dp[i][j] += grid[i][j];\n\
    \        }\n    }\n    std::vector<long> ans;\n    int i = n - 1, j = n - 1;\n\
    \    while (k > 0) {\n        ans.push_back(grid[i][j]);\n        if (path[i][j]\
    \ == 0) {\n            i--;\n        } else if (path[i][j] == 1) {\n         \
    \   j--;\n        }\n        k--;\n    }\n    return ans;", "    std::vector<long>\
    \ ans;\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if\
    \ (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n             \
    \   path[i][j].push_back(grid[i][j]);\n            } else if (i == 0) {\n    \
    \            dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j].push_back(grid[i][j]);\n     \
    \       } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i - 1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                 \
    \   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    path[i][j] = path[i][j\
    \ - 1];\n                    path[i][j].push_back(grid[i][j]);\n             \
    \   } else {\n                    dp[i][j]", "    // Write your code here\n  \
    \  int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <=\
    \ k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0;\
    \ j < n; j++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j][k] <\
    \ INT_MAX) {\n                ans.push_back(dp[i][j][k]);\n            }\n   \
    \     }\n    }\n    std::sort(ans.begin(), ans.end());\n    return ans;", "  \
    \  // Write your code here\n    std::vector<long> ans;\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<long>> path(n, std::vector<long>(m,\
    \ 0));\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n\
    \            if(i == 0 && j == 0){\n                dp[i][j] = 0;\n          \
    \      path[i][j] = grid[i][j];\n            }\n            else if(i == 0){\n\
    \                dp[i][j] = dp[i][j-1] + 1;\n                path[i][j] = path[i][j-1]\
    \ * 10 + grid[i][j];\n            }\n            else if(j == 0){\n          \
    \      dp[i][j] = dp[i-1][j] + 1;\n                path[i][j] = path[i-1][j] *\
    \ 10 + grid[i][j];\n            }\n            else{\n                dp[i][j]\
    \ = std::min(dp[i-1][j], dp[i][j-1]) + 1;\n                if(dp[i-1][j] < dp[i][j-1]){\n\
    \                    path[i][j] = path[i-1][j] * 10 + grid[i][j];\n          \
    \      }\n                else{\n                    path[i][j] = path[i][j-1]\
    \ * 10 + grid[i][j];\n                }\n            }\n        }\n    }\n   \
    \ long num = path[n-1][m-1];\n    while(num){\n        ans.push_back(num % 10);\n\
    \        num /= 10;\n    }\n    std::reverse(ans.begin(), ans.end());\n    return\
    \ ans;", "  // your code goes here\n  std::vector<long> res;\n  int n = grid.size();\n\
    \  if (n == 0) return res;\n  int m = grid[0].size();\n  if (m == 0) return res;\n\
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(m, INT_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n  for (int\
    \ i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      if (i == 0 &&\
    \ j == 0) {\n        dp[i][j] = 0;\n        path[i][j].push_back(grid[i][j]);\n\
    \      } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + 1;\n        path[i][j]\
    \ = path[i][j - 1];\n        path[i][j].push_back(grid[i][j]);\n      } else if\
    \ (j == 0) {\n        dp[i][j] = dp[i - 1][j] + 1;\n        path[i][j] = path[i\
    \ - 1][j];\n        path[i][j].push_back(grid[i][j]);\n      } else {\n      \
    \  if (dp[i - 1][j] < dp[i][j - 1]) {\n          dp[i][j] = dp[i - 1][j] + 1;\n\
    \          path[i][j] = path[i - 1][j];\n          path[i][j].push_back(grid[i][j]);\n\
    \        } else if (dp[i - 1][j] > dp[i][j - 1]) {\n          dp[i][j] = dp[i][j\
    \ - 1] + 1;\n          path[i][j] = path[i][j - 1];\n          path[i][j].push_back(grid[i][j]);\n\
    \        } else {", "    // Write your code here\n    int n = grid.size();\n \
    \   std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n   \
    \ std::vector<std::vector<long>> path(n, std::vector<long>(n, 0));\n    std::vector<std::vector<int>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n\
    \                dp[i][j] = grid[i][j];\n                path[i][j] = 1;\n   \
    \         } else {\n                for (int d = 0; d < 4; d++) {\n          \
    \          int x = i + dir[d][0];\n                    int y = j + dir[d][1];\n\
    \                    if (x >= 0 && x < n && y >= 0 && y < n) {\n             \
    \           if (dp[x][y] + grid[i][j] < dp[i][j]) {\n                        \
    \    dp[i][j] = dp[x][y] + grid[i][j];\n                            path[i][j]\
    \ = path[x][y];\n                        } else if (dp[x][y] + grid[i][j] == dp[i][j])\
    \ {\n                            path[i][j] += path[x][y];\n                 \
    \       }\n                    }\n                }\n            }\n        }\n\
    \    }\n    std::vector<long> res;\n    int i = n - 1, j = n - 1;\n    while (k\
    \ > 0) {\n        res.push_back(grid[i][j]);\n        for (int d = 0; d < 4; d++)\
    \ {\n            int x = i + dir[d][0];\n            int y = j + dir[d][1];\n\
    \            if (x >= 0 && x < n && y >= 0 && y < n) {\n                if (dp[x][y]\
    \ + grid[i][j] == dp[i][j", "    // Write your code here\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    std::vector<std::vector<long>> visited(n, std::vector<long>(m,\
    \ 0));\n    std::vector<std::vector<long>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n    std::priority_queue<std::vector<long>, std::vector<std::vector<long>>,\
    \ std::greater<std::vector<long>>> pq;\n    pq.push({0, 0, 0});\n    dp[0][0]\
    \ = 0;\n    path[0][0].push_back(grid[0][0]);\n    while (!pq.empty()) {\n   \
    \     auto curr = pq.top();\n        pq.pop();\n        int x = curr[1];\n   \
    \     int y = curr[2];\n        if (visited[x][y]) {\n            continue;\n\
    \        }\n        visited[x][y] = 1;\n        for (auto d : dir) {\n       \
    \     int nx = x + d[0];\n            int ny = y + d[1];\n            if (nx <\
    \ 0 || nx >= n || ny < 0 || ny >= m) {\n                continue;\n          \
    \  }\n            if (visited[nx][ny]) {\n                continue;\n        \
    \    }\n            if (dp[nx][ny] > dp[x][y] + 1) {\n                dp[nx][ny]\
    \ = dp[x][y] + 1;\n                path[nx][ny] = path[x][y];\n              \
    \  path[nx][ny].push_back(grid[nx][ny]);\n                pq.push({dp[nx][ny],\
    \ nx, ny});\n            } else if (", "    // Write your code here\n    int n\
    \ = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<int>> parent(n, std::vector<int>(n,\
    \ -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n, 0));\n\
    \    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\
    \    std::queue<std::pair<int, int>> q;\n    q.push({0, 0});\n    dp[0][0] = grid[0][0];\n\
    \    visited[0][0] = 1;\n    while (!q.empty()) {\n        auto curr = q.front();\n\
    \        q.pop();\n        for (auto d : dir) {\n            int x = curr.first\
    \ + d[0];\n            int y = curr.second + d[1];\n            if (x < 0 || x\
    \ >= n || y < 0 || y >= n || visited[x][y]) {\n                continue;\n   \
    \         }\n            visited[x][y] = 1;\n            if (dp[x][y] > dp[curr.first][curr.second]\
    \ + grid[x][y]) {\n                dp[x][y] = dp[curr.first][curr.second] + grid[x][y];\n\
    \                parent[x][y] = curr.first * n + curr.second;\n            }\n\
    \            q.push({x, y});\n        }\n    }\n    std::vector<long> res;\n \
    \   int x = n - 1;\n    int y = n - 1;\n    while (k--) {\n        res.push_back(grid[x][y]);\n\
    \        int p = parent[x][y];\n        x = p / n;\n        y = p % n;\n    }\n\
    \    return res;", "    // Write your code here\n    int n = grid.size();\n  \
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n \
    \   for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n   \
    \         if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n  \
    \              path[i][j][1] = grid[i][j];\n            } else if (i == 0) {\n\
    \                dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j][1]\
    \ = grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] =\
    \ dp[i - 1][j] + grid[i][j];\n                path[i][j][1] = grid[i][j];\n  \
    \          } else {\n                dp[i][j] = std::min(dp[i - 1][j], dp[i][j\
    \ - 1]) + grid[i][j];\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  path[i][j][1] = grid[i][j];\n                } else {\n   \
    \                 path[i][j][1] = grid[i][j];\n                }\n           \
    \ }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j =\
    \ 0; j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n             \
    \   if (i == 0 && j == 0) {\n                    path[i][j][l] = grid[i][j];\n\
    \                } else if (i == 0) {\n                    path[i][j][l] = path[i][j\
    \ - 1][l - 1] + grid[i][j", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][1] = grid[i][j];\n           \
    \ } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n       \
    \         path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n               \
    \ path[i][j][dp[i][j]] = grid[i][j];\n            } else {\n                dp[i][j]\
    \ = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;\n                if (dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n                    path[i][j] = path[i - 1][j];\n      \
    \          } else {\n                    path[i][j] = path[i][j - 1];\n      \
    \          }\n                path[i][j][dp[i][j]] = grid[i][j];\n           \
    \ }\n        }\n    }\n    return path[n - 1][n - 1];", "    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            path[i][j][1]\
    \ = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n\
    \                if (i > 0 && dp[i - 1][j] < dp[i][j]) {\n                   \
    \ dp[i][j] = dp[i - 1][j];\n                    path[i][j][l] = path[i - 1][j][l\
    \ - 1];\n                }\n                if (j > 0 && dp[i][j - 1] < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i][j - 1];\n                    path[i][j][l]\
    \ = path[i][j - 1][l - 1];\n                }\n                if (i < n - 1 &&\
    \ dp[i + 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i + 1][j];\n \
    \                   path[i][j][l] = path[i + 1][j][l - 1];\n                }\n\
    \                if (j < n - 1 && dp[i][j + 1] < dp[i][j]) {\n               \
    \     dp[i][j] = dp[i][j + 1];\n                    path[i][j][l] = path[i][j\
    \ + 1][l - 1];\n                }\n                path[i][j][l].push_back(grid[i][j]);\n\
    \            }", "    // Write your code here\n    std::vector<long> ans;\n  \
    \  long n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    dp[0][0] = grid[0][0];\n    path[0][0][0] =\
    \ grid[0][0];\n    for(long i = 0; i < n; i++){\n        for(long j = 0; j < n;\
    \ j++){\n            if(i == 0 && j == 0) continue;\n            if(i - 1 >= 0){\n\
    \                if(dp[i][j] > dp[i - 1][j] + grid[i][j]){\n                 \
    \   dp[i][j] = dp[i - 1][j] + grid[i][j];\n                    path[i][j] = path[i\
    \ - 1][j];\n                    path[i][j][0] = grid[i][j];\n                }\n\
    \                else if(dp[i][j] == dp[i - 1][j] + grid[i][j]){\n           \
    \         std::vector<long> temp = path[i - 1][j];\n                    temp[0]\
    \ = grid[i][j];\n                    if(temp < path[i][j]) path[i][j] = temp;\n\
    \                }\n            }\n            if(j - 1 >= 0){\n             \
    \   if(dp[i][j] > dp[i][j - 1] + grid[i][j]){\n                    dp[i][j] =\
    \ dp[i][j - 1] + grid[i][j];\n                    path[i][j] = path[i][j - 1];\n\
    \                    path[i][j][0] = grid[i][j];\n                }\n        \
    \        else if(dp[i][j] == dp[i][j - 1] + grid[i][j]){\n                   \
    \ std::vector<long> temp = path[i][j -", "  // your code goes here\n  int n =\
    \ grid.size();\n  std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n  for (int i = 0; i < n; i++) {\n    for\
    \ (int j = 0; j < n; j++) {\n      dp[i][j][1] = grid[i][j];\n    }\n  }\n  for\
    \ (int l = 2; l <= k; l++) {\n    for (int i = 0; i < n; i++) {\n      for (int\
    \ j = 0; j < n; j++) {\n        if (i - 1 >= 0) {\n          dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1]);\n        }\n        if (i + 1 < n) {\n          dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n        }\n        if (j - 1\
    \ >= 0) {\n          dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \        }\n        if (j + 1 < n) {\n          dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n        }\n      }\n    }\n  }\n  std::vector<long> ans;\n\
    \  ans.push_back(dp[0][0][k]);\n  int i = 0, j = 0;\n  for (int l = k - 1; l >=\
    \ 1; l--) {\n    if (i - 1 >= 0 && dp[i - 1][j][l] == ans.back()) {\n      ans.push_back(grid[i\
    \ - 1][j]);\n      i--;\n    } else if (i + 1 < n && dp[i + 1][j][l] == ans.",
  "    std::vector<long> result;\n    // your code goes here\n    return result;",
  "    // Write your code here\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k, INT_MAX)));\n \
    \   std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k, std::vector<long>())));\n    for(int i = 0;\
    \ i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[i][j][0]\
    \ = grid[i][j];\n            path[i][j][0].push_back(grid[i][j]);\n        }\n\
    \    }\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n\
    \            for(int l = 1; l < k; l++) {\n                if(i > 0) {\n     \
    \               if(dp[i][j][l] > dp[i - 1][j][l - 1]) {\n                    \
    \    dp[i][j][l] = dp[i - 1][j][l - 1];\n                        path[i][j][l]\
    \ = path[i - 1][j][l - 1];\n                        path[i][j][l].push_back(grid[i][j]);\n\
    \                    }\n                    else if(dp[i][j][l] == dp[i - 1][j][l\
    \ - 1]) {\n                        std::vector<long> temp = path[i - 1][j][l -\
    \ 1];\n                        temp.push_back(grid[i][j]);\n                 \
    \       if(temp < path[i][j][l]) {\n                            path[i][j][l]\
    \ = temp;\n                        }\n                    }\n                }\n\
    \                if(j > 0) {\n                    if(dp[i][j][l] > dp[i][j - 1][l\
    \ - 1]) {\n                        dp[i][j][l] = dp[i][", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<int>> parent(n, std::vector<int>(n,\
    \ -1));\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n, 0));\n\
    \    std::vector<std::vector<int>> path;\n    std::vector<long> ans;\n    dp[0][0]\
    \ = grid[0][0];\n    for(int i = 0; i < n; i++){\n        for(int j = 0; j < n;\
    \ j++){\n            if(i == 0 && j == 0) continue;\n            if(i > 0){\n\
    \                if(dp[i][j] > dp[i-1][j] + grid[i][j]){\n                   \
    \ dp[i][j] = dp[i-1][j] + grid[i][j];\n                    parent[i][j] = 1;\n\
    \                }\n            }\n            if(j > 0){\n                if(dp[i][j]\
    \ > dp[i][j-1] + grid[i][j]){\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                    parent[i][j] = 2;\n                }\n            }\n   \
    \     }\n    }\n    int i = n-1, j = n-1;\n    while(i != 0 || j != 0){\n    \
    \    if(parent[i][j] == 1){\n            i--;\n        }\n        else if(parent[i][j]\
    \ == 2){\n            j--;\n        }\n        path.push_back({i, j});\n    }\n\
    \    path.push_back({n-1, n-1});\n    for(int i = 0; i < k; i++){\n        ans.push_back(grid[path[i][0]][path[i][1]]);\n\
    \    }\n    return ans;", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][0] = 1;\n            } else if\
    \ (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j][0]\
    \ = 1;\n            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j]\
    \ + 1;\n                path[i][j][0] = 1;\n            } else {\n           \
    \     dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + 1;\n                if\
    \ (dp[i - 1][j] < dp[i][j - 1]) {\n                    path[i][j][0] = 1;\n  \
    \              } else {\n                    path[i][j][0] = 2;\n            \
    \    }\n            }\n        }\n    }\n    std::vector<long> ans;\n    int i\
    \ = n - 1, j = n - 1;\n    for (int l = 0; l < k; l++) {\n        ans.push_back(grid[i][j]);\n\
    \        if (path[i][j][0] == 1) {\n            i--;\n        } else {\n     \
    \       j--;\n        }\n    }\n    return ans;", "    std::vector<long> res;\n\
    \    // Write your code here\n    return res;", "    int n = grid.size();\n  \
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(n, LONG_MAX));\n   \
    \ std::vector<std::vector<std::vector<long>>> prev(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, -1)));\n    for (int i = 0; i < n; ++i) {\n        for\
    \ (int j = 0; j < n; ++j) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = grid[i][j];\n                prev[i][j][0] = grid[i][j];\n  \
    \          } else {\n                if (i > 0) {\n                    if (dp[i\
    \ - 1][j] + grid[i][j] < dp[i][j]) {\n                        dp[i][j] = dp[i\
    \ - 1][j] + grid[i][j];\n                        for (int l = 0; l < k; ++l) {\n\
    \                            prev[i][j][l] = prev[i - 1][j][l];\n            \
    \            }\n                        prev[i][j][0] = grid[i][j];\n        \
    \            }\n                }\n                if (j > 0) {\n            \
    \        if (dp[i][j - 1] + grid[i][j] < dp[i][j]) {\n                       \
    \ dp[i][j] = dp[i][j - 1] + grid[i][j];\n                        for (int l =\
    \ 0; l < k; ++l) {\n                            prev[i][j][l] = prev[i][j - 1][l];\n\
    \                        }\n                        prev[i][j][0] = grid[i][j];\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   std::vector<long> res(k);\n    for (int i = 0; i < k; ++i) {\n        res[i]\
    \ = prev[n - 1][n - 1][i];\n    }\n    return res;", "    // Write your code here\n\
    \    int n = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_index(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j] = grid[i][j];\n            path[i][j][1] = grid[i][j];\n \
    \           path_index[i][j][1] = 0;\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i - 1 >= 0 && dp[i - 1][j] < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i - 1][j];\n                    path[i][j][l]\
    \ = path[i - 1][j][l - 1];\n                    path_index[i][j][l] = 0;\n   \
    \             }\n                if (i + 1 < n && dp[i + 1][j] < dp[i][j]) {\n\
    \                    dp[i][j] = dp[i + 1][j];\n                    path[i][j][l]\
    \ = path[i + 1][j][l - 1];\n                    path_index[i][j][l] = 1;\n   \
    \             }\n                if (j - 1 >= 0 && dp[i][j - 1] < dp[i][j]) {\n\
    \                    dp[i][j] = dp[i][j - 1];\n                    path[i][j][l]\
    \ = path[i", "  // Write your code here\n  int n = grid.size();\n  int m = grid[0].size();\n\
    \  std::vector<std::vector<long>> dp(n, std::vector<long>(m, INT_MAX));\n  std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>()));\n  std::vector<std::vector<int>>\
    \ visited(n, std::vector<int>(m, 0));\n  std::queue<std::pair<int, int>> q;\n\
    \  q.push({0, 0});\n  dp[0][0] = grid[0][0];\n  path[0][0].push_back(grid[0][0]);\n\
    \  visited[0][0] = 1;\n  while (!q.empty()) {\n    auto p = q.front();\n    q.pop();\n\
    \    int i = p.first;\n    int j = p.second;\n    if (i + 1 < n && visited[i +\
    \ 1][j] == 0) {\n      visited[i + 1][j] = 1;\n      dp[i + 1][j] = dp[i][j] +\
    \ grid[i + 1][j];\n      path[i + 1][j] = path[i][j];\n      path[i + 1][j].push_back(grid[i\
    \ + 1][j]);\n      q.push({i + 1, j});\n    }\n    if (j + 1 < m && visited[i][j\
    \ + 1] == 0) {\n      visited[i][j + 1] = 1;\n      dp[i][j + 1] = dp[i][j] +\
    \ grid[i][j + 1];\n      path[i][j + 1] = path[i][j];\n      path[i][j + 1].push_back(grid[i][j\
    \ + 1]);\n      q.push({i, j + 1});\n    }\n  }\n  return path[n - 1][m - 1];",
  "    // Write your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<long>> dp(n, std::vector<long>(m, INT_MAX));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>> path_val(n,\
    \ std::vector<std::vector<long>>(m, std::vector<long>()));\n    for(int i = 0;\
    \ i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(i == 0 &&\
    \ j == 0){\n                dp[i][j] = 0;\n                path[i][j].push_back(grid[i][j]);\n\
    \                path_val[i][j].push_back(grid[i][j]);\n            }\n      \
    \      else{\n                if(i > 0){\n                    if(dp[i-1][j] +\
    \ 1 < dp[i][j]){\n                        dp[i][j] = dp[i-1][j] + 1;\n       \
    \                 path[i][j] = path[i-1][j];\n                        path_val[i][j]\
    \ = path_val[i-1][j];\n                    }\n                    else if(dp[i-1][j]\
    \ + 1 == dp[i][j]){\n                        if(path_val[i-1][j] < path_val[i][j]){\n\
    \                            path[i][j] = path[i-1][j];\n                    \
    \        path_val[i][j] = path_val[i-1][j];\n                        }\n     \
    \               }\n                }\n                if(j > 0){\n           \
    \         if(dp[i][j-1] + 1 < dp[i][j]){\n                        dp[i][j] = dp[i][j-1]\
    \ + 1;\n                        path[i][j] = path[i][j-1];\n                 \
    \       path_val[i][j]", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (j > 0) {\n                  \
    \  dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n               \
    \ }\n                if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    std::vector<long> ans(k);\n    int i = 0, j = 0;\n    for\
    \ (int l = k; l >= 1; l--) {\n        ans[l - 1] = grid[i][j];\n        if (i\
    \ > 0 && dp[i][j][l] == dp[i - 1][j][l - 1] + grid[i][j]) {\n            i--;\n\
    \        } else if (j > 0 && dp[i][j][", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   for (int l = 0; l <= k; l++) {\n                path[i][j][l].push_back(grid[i][j]);\n\
    \            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n            } else if (i == 0) {\n                dp[i][j]\
    \ = dp[i][j - 1] + 1;\n                path[i][j] = path[i][j - 1];\n        \
    \    } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + 1;\n    \
    \            path[i][j] = path[i - 1][j];\n            } else {\n            \
    \    if (dp[i - 1][j] < dp[i][j - 1]) {\n                    dp[i][j] = dp[i -\
    \ 1][j] + 1;\n                    path[i][j] = path[i - 1][j];\n             \
    \   } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                    dp[i][j] =\
    \ dp[i][j - 1] + 1;\n                    path[i][j] = path[i][j - 1];\n      \
    \          } else {\n                    dp[i][j] = dp[i - 1][j] + 1;\n      \
    \              for (int l = 0; l <= k; l++) {\n                        if (path[i\
    \ - 1][j][l] < path[i][j - 1", "    // Write your code here\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    int x = 0, y = 0;\n    for (int i = 0; i < k; i++) {\n        ans.push_back(grid[x][y]);\n\
    \        if (x > 0 && dp[x - 1][y][k - i] < dp[x][y][k - i]) {\n            x--;\n\
    \        } else if (y > 0 && dp[x][", "    std::vector<long> res;\n    if (k ==\
    \ 0) return res;\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int l = 2; l\
    \ <= k; ++l) {\n                long min = LONG_MAX;\n                if (i >\
    \ 0) {\n                    min = std::min(min, dp[i - 1][j][l - 1]);\n      \
    \          }\n                if (i < n - 1) {\n                    min = std::min(min,\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 min = std::min(min, dp[i][j - 1][l - 1]);\n                }\n\
    \                if (j < n - 1) {\n                    min = std::min(min, dp[i][j\
    \ + 1][l - 1]);\n                }\n                dp[i][j][l] = min;\n     \
    \       }\n        }\n    }\n    long min = LONG_MAX;\n    int x = 0, y = 0;\n\
    \    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n  \
    \          if (dp[i][j][k] < min) {\n                min = dp[i][j][k];\n    \
    \            x = i;\n                y = j;\n            }\n        }\n    }\n\
    \    res.push_back(grid[x][y]);\n    for (int i = k - 1; i > 0; --i) {\n     \
    \   if (x > 0 && dp[x -", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> path(n,\
    \ std::vector<int>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j] = 1;\n            } else if (i ==\
    \ 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n              \
    \  path[i][j] = path[i][j - 1] + 1;\n            } else if (j == 0) {\n      \
    \          dp[i][j] = dp[i - 1][j] + grid[i][j];\n                path[i][j] =\
    \ path[i - 1][j] + 1;\n            } else {\n                if (dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    path[i][j] = path[i - 1][j] + 1;\n                } else\
    \ {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n             \
    \       path[i][j] = path[i][j - 1] + 1;\n                }\n            }\n \
    \       }\n    }\n    std::vector<long> res;\n    int i = n - 1, j = n - 1;\n\
    \    while (k > 0) {\n        res.push_back(grid[i][j]);\n        if (i == 0)\
    \ {\n            j--;\n        } else if (j == 0) {\n            i--;\n      \
    \  } else {\n            if (dp[i - 1][j] < dp[i][j - 1]) {\n                i--;\n\
    \            } else {\n                j--;\n            }\n", "    // Write your\
    \ code here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k, INT_MAX)));\n \
    \   std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k, std::vector<long>(2, -1))));\n    for(int\
    \ i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n            if(i\
    \ == 0 && j == 0) {\n                dp[i][j][0] = grid[i][j];\n             \
    \   parent[i][j][0][0] = -1;\n                parent[i][j][0][1] = -1;\n     \
    \       }\n            else {\n                if(i > 0) {\n                 \
    \   dp[i][j][0] = std::min(dp[i][j][0], dp[i - 1][j][0] + grid[i][j]);\n     \
    \               if(dp[i][j][0] == dp[i - 1][j][0] + grid[i][j]) {\n          \
    \              parent[i][j][0][0] = i - 1;\n                        parent[i][j][0][1]\
    \ = j;\n                    }\n                }\n                if(j > 0) {\n\
    \                    dp[i][j][0] = std::min(dp[i][j][0], dp[i][j - 1][0] + grid[i][j]);\n\
    \                    if(dp[i][j][0] == dp[i][j - 1][0] + grid[i][j]) {\n     \
    \                   parent[i][j][0][0] = i;\n                        parent[i][j][0][1]\
    \ = j - 1;\n                    }\n                }\n            }\n        }\n\
    \    }\n    for(int i = 0; i < n; i++) {\n        for"]
stop_tokens:
- "\n}"
