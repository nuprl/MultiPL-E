language: cpp
name: HumanEval_128_prod_signs
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum += -i;\n\
    \      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto& i : arr) {\n    if (i >\
    \ 0) {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum\
    \ += std::abs(i);\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i ==\
    \ 0) {\n      continue;\n    }\n    sum += std::abs(i);\n    prod *= (i > 0) ?\
    \ 1 : -1;\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp0r3k7l2q: /tmp/tmp0r3k7l2q.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto i\
    \ : arr) {\n        if (i > 0) {\n            prod *= 1;\n        } else if (i\
    \ < 0) {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += std::abs(i);\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto &x : arr) {\n    if (x >\
    \ 0) {\n      prod *= 1;\n    } else if (x < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(x);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i < 0)\
    \ {\n      prod *= -1;\n    } else if (i == 0) {\n      prod = 0;\n      break;\n\
    \    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ i * -1;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ i * -1;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto& elem : arr) {\n    if (elem >\
    \ 0) {\n      prod *= 1;\n      sum += elem;\n    } else if (elem < 0) {\n   \
    \   prod *= -1;\n      sum += elem * -1;\n    } else {\n      prod *= 0;\n   \
    \ }\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i == 0) {\n\
    \      prod = 0;\n      sum = 0;\n      break;\n    }\n    if (i < 0) prod *=\
    \ -1;\n    sum += std::abs(i);\n  }\n  return sum * prod;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (long i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto&\
    \ i : arr) {\n        if (i == 0) {\n            continue;\n        }\n      \
    \  prod *= i / std::abs(i);\n        sum += std::abs(i);\n    }\n    return prod\
    \ * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpyjj3d52p: /tmp/tmpyjj3d52p.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto num\
    \ : arr) {\n        sum += std::abs(num);\n        if (num > 0) {\n          \
    \  prod *= 1;\n        } else if (num < 0) {\n            prod *= -1;\n      \
    \  } else {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) return std::nullopt;\n\
    \    long sum = 0;\n    long prod = 1;\n    for (auto i : arr) {\n        if (i\
    \ > 0) {\n            sum += i;\n            prod *= 1;\n        } else if (i\
    \ < 0) {\n            sum += -i;\n            prod *= -1;\n        } else {\n\
    \            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto&\
    \ elem : arr) {\n        sum += std::abs(elem);\n        if (elem > 0) {\n   \
    \         prod *= 1;\n        } else if (elem < 0) {\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n    }\n    return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ abs(i);\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    // your code here\n    if(arr.size()\
    \ == 0)\n        return std::nullopt;\n    long prod = 1;\n    long sum = 0;\n\
    \    for(auto i : arr)\n    {\n        if(i < 0)\n            prod *= -1;\n  \
    \      else if(i > 0)\n            prod *= 1;\n        else\n            prod\
    \ *= 0;\n        sum += std::abs(i);\n    }\n    return prod * sum;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum += i *\
    \ -1;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  long prod = 1;\n  long sum = 0;\n  for\
    \ (auto i : arr) {\n    if (i > 0) {\n      prod *= 1;\n      sum += i;\n    }\
    \ else if (i < 0) {\n      prod *= -1;\n      sum += -i;\n    } else {\n     \
    \ prod *= 0;\n    }\n  }\n  if (arr.size() == 0) {\n    return std::nullopt;\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i < 0)\
    \ {\n      prod *= -1;\n    } else if (i > 0) {\n      sum += i;\n    }\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp4wg9f7w1: /tmp/tmp4wg9f7w1.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i < 0)\
    \ {\n      prod *= -1;\n    } else if (i == 0) {\n      prod = 0;\n      break;\n\
    \    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  // your code here\n  if(arr.size() ==\
    \ 0) return std::nullopt;\n  long sum = 0;\n  long prod = 1;\n  for(auto i : arr){\n\
    \    sum += abs(i);\n    if(i > 0) prod *= 1;\n    else if(i < 0) prod *= -1;\n\
    \    else prod *= 0;\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += i * -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return prod *\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto x : arr) {\n    if (x > 0)\
    \ {\n      sum += x;\n      prod *= 1;\n    } else if (x < 0) {\n      sum +=\
    \ -x;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto x : arr) {\n    if (x > 0)\
    \ {\n      sum += x;\n      prod *= 1;\n    } else if (x < 0) {\n      sum +=\
    \ -x;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) return std::nullopt;\n\
    \    long prod = 1;\n    long sum = 0;\n    for (auto x : arr) {\n        if (x\
    \ > 0) {\n            prod *= 1;\n            sum += x;\n        } else if (x\
    \ < 0) {\n            prod *= -1;\n            sum += std::abs(x);\n        }\
    \ else {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106048
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto i\
    \ : arr) {\n        if (i < 0) {\n            prod *= -1;\n        } else if (i\
    \ > 0) {\n            prod *= 1;\n        } else {\n            prod *= 0;\n \
    \       }\n        sum += std::abs(i);\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i == 0) continue;\n\
    \    prod *= i > 0 ? 1 : -1;\n    sum += std::abs(i);\n  }\n  return prod * sum;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmppmrp3zgo: /tmp/tmppmrp3zgo.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return prod *\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    sum += std::abs(i);\n\
    \    if (i > 0) prod *= 1;\n    else if (i < 0) prod *= -1;\n    else prod *=\
    \ 0;\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) return std::nullopt;\n\
    \    long prod = 1;\n    long sum = 0;\n    for (auto i : arr) {\n        if (i\
    \ < 0) {\n            prod *= -1;\n        } else if (i == 0) {\n            prod\
    \ = 0;\n            sum = 0;\n            break;\n        }\n        sum += std::abs(i);\n\
    \    }\n    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto x : arr) {\n    if (x > 0) {\n\
    \      prod *= 1;\n      sum += x;\n    } else if (x < 0) {\n      prod *= -1;\n\
    \      sum += -x;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) prod\
    \ *= 1;\n    else if (i < 0) prod *= -1;\n    else prod *= 0;\n    sum += std::abs(i);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i == 0) {\n\
    \      prod = 0;\n      sum = 0;\n      break;\n    }\n    prod *= (i > 0) ? 1\
    \ : -1;\n    sum += std::abs(i);\n  }\n  return sum * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto i\
    \ : arr) {\n        if (i > 0) {\n            prod *= 1;\n        } else if (i\
    \ < 0) {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += std::abs(i);\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  // your code here\n  if(arr.size() ==\
    \ 0) return std::nullopt;\n  long sum = 0;\n  long prod = 1;\n  for(auto i : arr){\n\
    \    if(i == 0) continue;\n    sum += std::abs(i);\n    prod *= i > 0 ? 1 : -1;\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp2_de6j25: /tmp/tmp2_de6j25.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106050
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i < 0)\
    \ {\n      prod *= -1;\n    } else if (i > 0) {\n      sum += i;\n    }\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp4wg9f7w1: /tmp/tmp4wg9f7w1.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long sign_prod = 1;\n  long sum_magnitudes = 0;\n  for (auto const& num : arr)\
    \ {\n    if (num == 0) {\n      sign_prod = 0;\n      sum_magnitudes = 0;\n  \
    \    break;\n    }\n    sign_prod *= num < 0 ? -1 : 1;\n    sum_magnitudes +=\
    \ std::abs(num);\n  }\n  return sign_prod * sum_magnitudes;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto i\
    \ : arr) {\n        sum += std::abs(i);\n        prod *= i == 0 ? 1 : i / std::abs(i);\n\
    \    }\n    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpbyiu0dcr: /tmp/tmpbyiu0dcr.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106050
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto x : arr) {\n    if (x > 0) {\n\
    \      prod *= 1;\n      sum += x;\n    } else if (x < 0) {\n      prod *= -1;\n\
    \      sum += -x;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  long sum = 0;\n  long prod = 1;\n  for\
    \ (auto i : arr) {\n    if (i > 0) {\n      sum += i;\n      prod *= 1;\n    }\
    \ else if (i < 0) {\n      sum += i * -1;\n      prod *= -1;\n    } else {\n \
    \     prod *= 0;\n    }\n  }\n  if (prod == 0) {\n    return std::nullopt;\n \
    \ }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpty86hgch: /tmp/tmpty86hgch.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106050
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto const &i : arr) {\n    if\
    \ (i > 0) {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n    \
    \  sum += std::abs(i);\n      prod *= -1;\n    } else {\n      prod *= 0;\n  \
    \  }\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106048
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (long i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ i * -1;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto i\
    \ : arr) {\n        if (i > 0) {\n            prod *= 1;\n        } else if (i\
    \ < 0) {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += std::abs(i);\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto i\
    \ : arr) {\n        sum += std::abs(i);\n        prod *= i == 0 ? 1 : i > 0 ?\
    \ 1 : -1;\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp8f2c95lu: /tmp/tmp8f2c95lu.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106050
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) return std::nullopt;\n\
    \    long sum = 0;\n    long prod = 1;\n    for (auto i : arr) {\n        if (i\
    \ > 0) {\n            sum += i;\n            prod *= 1;\n        } else if (i\
    \ < 0) {\n            sum += i * -1;\n            prod *= -1;\n        } else\
    \ {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i ==\
    \ 0) {\n      continue;\n    }\n    sum += std::abs(i);\n    prod *= i > 0 ? 1\
    \ : -1;\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpgi1upec6: /tmp/tmpgi1upec6.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106048
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) return std::nullopt;\n\
    \    long sum = 0;\n    long prod = 1;\n    for (auto i : arr) {\n        if (i\
    \ > 0) {\n            sum += i;\n            prod *= 1;\n        } else if (i\
    \ < 0) {\n            sum += i * -1;\n            prod *= -1;\n        } else\
    \ {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto x : arr) {\n    if (x > 0)\
    \ {\n      prod *= 1;\n    } else if (x < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(x);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (long i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  // your code here\n  if(arr.size() ==\
    \ 0) return std::nullopt;\n  long sum = 0;\n  long prod = 1;\n  for(auto i : arr){\n\
    \    sum += std::abs(i);\n    prod *= i == 0 ? 1 : i / std::abs(i);\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpa_s560rx: /tmp/tmpa_s560rx.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106051
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto x : arr) {\n    if (x < 0)\
    \ {\n      prod *= -1;\n    } else if (x > 0) {\n      sum += x;\n    }\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpoyjw2z17: /tmp/tmpoyjw2z17.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106051
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto i\
    \ : arr) {\n        sum += std::abs(i);\n        if (i > 0) {\n            prod\
    \ *= 1;\n        } else if (i < 0) {\n            prod *= -1;\n        } else\
    \ {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106051
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ i * -1;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (long i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106051
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (int i\
    \ = 0; i < arr.size(); i++) {\n        if (arr[i] < 0) {\n            prod *=\
    \ -1;\n        } else if (arr[i] == 0) {\n            prod = 0;\n            sum\
    \ = 0;\n            break;\n        }\n        sum += std::abs(arr[i]);\n    }\n\
    \    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto& i : arr) {\n    if (i >\
    \ 0) {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum\
    \ += i * -1;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106051
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i < 0)\
    \ {\n      prod *= -1;\n    } else if (i > 0) {\n      sum += i;\n    }\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp4wg9f7w1: /tmp/tmp4wg9f7w1.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i < 0) prod\
    \ *= -1;\n    sum += std::abs(i);\n  }\n  return sum * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpx0di9zas: /tmp/tmpx0di9zas.cpp:21: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto &i : arr) {\n    sum += std::abs(i);\n\
    \    if (i != 0) {\n      prod *= i / std::abs(i);\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp7xbelx3r: /tmp/tmp7xbelx3r.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ i * -1;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i ==\
    \ 0) {\n      continue;\n    }\n    prod *= i > 0 ? 1 : -1;\n    sum += std::abs(i);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpbx6xrli2: /tmp/tmpbx6xrli2.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long product = 1;\n  for (auto i : arr) {\n    if (i\
    \ > 0) {\n      sum += i;\n      product *= 1;\n    } else if (i < 0) {\n    \
    \  sum += i * -1;\n      product *= -1;\n    } else {\n      product *= 0;\n \
    \   }\n  }\n  return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto &i : arr) {\n    if (i >\
    \ 0) {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum\
    \ += -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto i\
    \ : arr) {\n        if (i > 0) {\n            prod *= 1;\n        } else if (i\
    \ < 0) {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += std::abs(i);\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) return std::nullopt;\n\
    \    long prod = 1;\n    long sum = 0;\n    for (auto i : arr) {\n        if (i\
    \ == 0) continue;\n        prod *= i > 0 ? 1 : -1;\n        sum += std::abs(i);\n\
    \    }\n    return prod * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmprabnb31y: /tmp/tmprabnb31y.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i ==\
    \ 0) {\n      continue;\n    }\n    prod *= (i < 0) ? -1 : 1;\n    sum += std::abs(i);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpukytijen: /tmp/tmpukytijen.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) return std::nullopt;\n\
    \    long prod = 1;\n    long sum = 0;\n    for (auto& num : arr) {\n        if\
    \ (num > 0) {\n            prod *= 1;\n            sum += num;\n        } else\
    \ if (num < 0) {\n            prod *= -1;\n            sum += std::abs(num);\n\
    \        } else {\n            prod *= 0;\n        }\n    }\n    return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (long i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (long i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106051
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto i\
    \ : arr) {\n        if (i > 0) {\n            sum += i;\n            prod *= 1;\n\
    \        } else if (i < 0) {\n            sum += -i;\n            prod *= -1;\n\
    \        } else {\n            prod *= 0;\n        }\n    }\n    return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto&\
    \ i : arr) {\n        sum += std::abs(i);\n        prod *= i == 0 ? 1 : i / std::abs(i);\n\
    \    }\n    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp0nivdm05: /tmp/tmp0nivdm05.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    sum += std::abs(i);\n\
    \    prod *= i < 0 ? -1 : i > 0 ? 1 : 0;\n  }\n  return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto& i : arr) {\n    if (i >\
    \ 0) {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto&\
    \ i : arr) {\n        sum += std::abs(i);\n        if (i > 0) {\n            prod\
    \ *= 1;\n        } else if (i < 0) {\n            prod *= -1;\n        } else\
    \ {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i ==\
    \ 0) {\n      continue;\n    }\n    prod *= i < 0 ? -1 : 1;\n    sum += std::abs(i);\n\
    \  }\n  return prod * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp7c9m5kn9: /tmp/tmp7c9m5kn9.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto&\
    \ i : arr) {\n        if (i > 0) {\n            prod *= 1;\n        } else if\
    \ (i < 0) {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += std::abs(i);\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    sum += std::abs(i);\n\
    \    if (i != 0) {\n      prod *= i / std::abs(i);\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp81od3ihs: /tmp/tmp81od3ihs.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto i\
    \ : arr) {\n        sum += std::abs(i);\n        prod *= (i == 0 ? 1 : (i > 0\
    \ ? 1 : -1));\n    }\n    return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp1s186xjq: /tmp/tmp1s186xjq.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long product = 1;\n  long sum = 0;\n  for (auto &i : arr) {\n    if (i\
    \ > 0) {\n      product *= 1;\n    } else if (i < 0) {\n      product *= -1;\n\
    \    } else {\n      product *= 0;\n    }\n    sum += abs(i);\n  }\n  return sum\
    \ * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto x\
    \ : arr) {\n        if (x < 0) {\n            prod *= -1;\n        } else if (x\
    \ > 0) {\n            prod *= 1;\n        } else {\n            prod *= 0;\n \
    \       }\n        sum += std::abs(x);\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto&\
    \ i : arr) {\n        if (i == 0) {\n            continue;\n        }\n      \
    \  sum += std::abs(i);\n        prod *= i < 0 ? -1 : 1;\n    }\n    return sum\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmphcqzceb8: /tmp/tmphcqzceb8.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i ==\
    \ 0) {\n      continue;\n    }\n    prod *= i < 0 ? -1 : 1;\n    sum += std::abs(i);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmph8lazi66: /tmp/tmph8lazi66.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i ==\
    \ 0) {\n      continue;\n    }\n    sum += std::abs(i);\n    prod *= i < 0 ? -1\
    \ : 1;\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpfzkdboud: /tmp/tmpfzkdboud.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto& i : arr) {\n    if (i >\
    \ 0) {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum\
    \ += -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto x : arr) {\n    if (x > 0) {\n\
    \      prod *= 1;\n      sum += x;\n    } else if (x < 0) {\n      prod *= -1;\n\
    \      sum += -x;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum += -i;\n\
    \      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpbxaconfn: /tmp/tmpbxaconfn.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) prod\
    \ *= 1;\n    else if (i < 0) prod *= -1;\n    else prod *= 0;\n    sum += std::abs(i);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ i * -1;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto& i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ std::abs(i);\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto it\
    \ = arr.begin(); it != arr.end(); ++it) {\n        if (*it > 0) {\n          \
    \  sum += *it;\n            prod *= 1;\n        } else if (*it < 0) {\n      \
    \      sum += *it * -1;\n            prod *= -1;\n        } else {\n         \
    \   prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto i\
    \ : arr) {\n        if (i > 0) {\n            prod *= 1;\n        } else if (i\
    \ < 0) {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += std::abs(i);\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i < 0)\
    \ {\n      prod *= -1;\n    } else if (i == 0) {\n      prod = 0;\n      break;\n\
    \    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long product = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i\
    \ < 0) {\n      product *= -1;\n    } else if (i > 0) {\n      product *= 1;\n\
    \    } else {\n      product *= 0;\n    }\n    sum += abs(i);\n  }\n  return sum\
    \ * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return prod * sum;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto &x : arr) {\n    if (x == 0) continue;\n\
    \    prod *= x > 0 ? 1 : -1;\n    sum += std::abs(x);\n  }\n  return prod * sum;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpwv5urzrm: /tmp/tmpwv5urzrm.cpp:22: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long product = 1;\n    for (const\
    \ auto& i : arr) {\n        sum += std::abs(i);\n        product *= i < 0 ? -1\
    \ : i == 0 ? 0 : 1;\n    }\n    return sum * product;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i < 0)\
    \ {\n      prod *= -1;\n    } else if (i > 0) {\n      sum += i;\n    }\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp4wg9f7w1: /tmp/tmp4wg9f7w1.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  // your code here\n  if(arr.size() ==\
    \ 0)\n    return std::nullopt;\n  long prod = 1;\n  long sum = 0;\n  for(auto\
    \ i : arr)\n  {\n    if(i < 0)\n      prod *= -1;\n    else if(i > 0)\n      prod\
    \ *= 1;\n    else\n      prod *= 0;\n    sum += std::abs(i);\n  }\n  return sum\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long sum = 0;\n  long prod = 1;\n  for (auto& i : arr) {\n    sum += std::abs(i);\n\
    \    if (i > 0) prod *= 1;\n    else if (i < 0) prod *= -1;\n    else prod *=\
    \ 0;\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto num : arr) {\n    if (num\
    \ == 0) {\n      continue;\n    }\n    sum += std::abs(num);\n    prod *= num\
    \ > 0 ? 1 : -1;\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpit1usq1c: /tmp/tmpit1usq1c.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106053
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) return std::nullopt;\n\
    \    long prod = 1;\n    long sum = 0;\n    for (auto i : arr) {\n        if (i\
    \ > 0) {\n            prod *= 1;\n            sum += i;\n        } else if (i\
    \ < 0) {\n            prod *= -1;\n            sum += std::abs(i);\n        }\
    \ else {\n            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto &x : arr) {\n    if (x > 0) prod\
    \ *= 1;\n    else if (x < 0) prod *= -1;\n    else prod *= 0;\n    sum += std::abs(x);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i ==\
    \ 0) {\n      continue;\n    }\n    sum += std::abs(i);\n    prod *= i / std::abs(i);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp94o3gqgx: /tmp/tmp94o3gqgx.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return prod *\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    sum += abs(i);\n\
    \    prod *= (i == 0 ? 1 : i / abs(i));\n  }\n  return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpgde1of4x: /tmp/tmpgde1of4x.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long product = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i\
    \ > 0) {\n      product *= 1;\n    } else if (i < 0) {\n      product *= -1;\n\
    \    } else {\n      product *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return\
    \ sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum += -i;\n\
    \      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto& i : arr) {\n    if (i >\
    \ 0) {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum\
    \ += abs(i);\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto x : arr) {\n    if (x > 0)\
    \ {\n      prod *= 1;\n    } else if (x < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(x);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto i\
    \ : arr) {\n        if (i == 0) {\n            continue;\n        }\n        prod\
    \ *= i > 0 ? 1 : -1;\n        sum += std::abs(i);\n    }\n    return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpeepo83_x: /tmp/tmpeepo83_x.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106053
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto&\
    \ i : arr) {\n        if (i > 0) {\n            prod *= 1;\n        } else if\
    \ (i < 0) {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += std::abs(i);\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto i\
    \ : arr) {\n        if (i > 0) {\n            prod *= 1;\n        } else if (i\
    \ < 0) {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += std::abs(i);\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ i * -1;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto &i : arr) {\n    if (i >\
    \ 0) {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum\
    \ += std::abs(i);\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto i\
    \ : arr) {\n        if (i == 0) {\n            continue;\n        }\n        prod\
    \ *= i > 0 ? 1 : -1;\n        sum += std::abs(i);\n    }\n    return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpeepo83_x: /tmp/tmpeepo83_x.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106053
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto el\
    \ : arr) {\n        if (el == 0) {\n            continue;\n        }\n       \
    \ prod *= el > 0 ? 1 : -1;\n        sum += std::abs(el);\n    }\n    return sum\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpq0fuepsa: /tmp/tmpq0fuepsa.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106053
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return prod *\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long product = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i\
    \ > 0) {\n      product *= 1;\n    } else if (i < 0) {\n      product *= -1;\n\
    \    } else {\n      product *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return\
    \ product * sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i ==\
    \ 0) {\n      continue;\n    }\n    sum += std::abs(i);\n    prod *= i > 0 ? 1\
    \ : -1;\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpgi1upec6: /tmp/tmpgi1upec6.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106048
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) return std::nullopt;\n\
    \    long prod = 1;\n    long sum = 0;\n    for (auto i : arr) {\n        if (i\
    \ > 0) {\n            prod *= 1;\n            sum += i;\n        } else if (i\
    \ < 0) {\n            prod *= -1;\n            sum += -i;\n        } else {\n\
    \            prod *= 0;\n        }\n    }\n    return prod * sum;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106053
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum += -i;\n\
    \      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i < 0)\
    \ {\n      prod *= -1;\n    } else if (i > 0) {\n      sum += i;\n    }\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmp4wg9f7w1: /tmp/tmp4wg9f7w1.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)2, (long)-4}))) == -9'' failed.

    '
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto&\
    \ x : arr) {\n        if (x > 0) {\n            prod *= 1;\n        } else if\
    \ (x < 0) {\n            prod *= -1;\n        } else {\n            prod *= 0;\n\
    \        }\n        sum += std::abs(x);\n    }\n    return sum * prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106054
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto &i : arr) {\n    if (i >\
    \ 0) {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106053
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long product = 1;\n  for (auto i : arr) {\n    if (i\
    \ > 0) {\n      sum += i;\n      product *= 1;\n    } else if (i < 0) {\n    \
    \  sum += i * -1;\n      product *= -1;\n    } else {\n      product *= 0;\n \
    \   }\n  }\n  return sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto &i : arr) {\n    if (i >\
    \ 0) {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106053
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto&\
    \ i : arr) {\n        if (i > 0) {\n            sum += i;\n            prod *=\
    \ 1;\n        } else if (i < 0) {\n            sum += -i;\n            prod *=\
    \ -1;\n        } else {\n            prod *= 0;\n        }\n    }\n    return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106053
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long product = 1;\n  long sum = 0;\n  for (auto num : arr) {\n    if (num\
    \ > 0) {\n      product *= 1;\n    } else if (num < 0) {\n      product *= -1;\n\
    \    } else {\n      product *= 0;\n    }\n    sum += std::abs(num);\n  }\n  return\
    \ sum * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106053
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i ==\
    \ 0) {\n      continue;\n    }\n    sum += std::abs(i);\n    prod *= i > 0 ? 1\
    \ : -1;\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpgi1upec6: /tmp/tmpgi1upec6.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106048
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto &i : arr) {\n    if (i >\
    \ 0) {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106053
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i == 0) {\n\
    \      prod = 0;\n      sum = 0;\n      break;\n    }\n    if (i < 0) prod *=\
    \ -1;\n    sum += std::abs(i);\n  }\n  return sum * prod;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto x : arr) {\n    if (x > 0)\
    \ {\n      sum += x;\n      prod *= 1;\n    } else if (x < 0) {\n      sum +=\
    \ std::abs(x);\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n\
    \  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106053
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i ==\
    \ 0) {\n      continue;\n    }\n    sum += std::abs(i);\n    prod *= i < 0 ? -1\
    \ : 1;\n  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpfzkdboud: /tmp/tmpfzkdboud.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) return std::nullopt;\n\
    \    long sum = 0;\n    long prod = 1;\n    for (auto i : arr) {\n        sum\
    \ += std::abs(i);\n        prod *= (i > 0) - (i < 0);\n    }\n    return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106054
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto &i : arr) {\n    if (i >\
    \ 0) {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum\
    \ += -i;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto&\
    \ elem : arr) {\n        if (elem > 0) {\n            sum += elem;\n         \
    \   prod *= 1;\n        } else if (elem < 0) {\n            sum += elem * -1;\n\
    \            prod *= -1;\n        } else {\n            prod *= 0;\n        }\n\
    \    }\n    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106053
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) return std::nullopt;\n\
    \    long prod = 1;\n    long sum = 0;\n    for (auto i : arr) {\n        if (i\
    \ < 0) prod *= -1;\n        else if (i > 0) prod *= 1;\n        else prod *= 0;\n\
    \        sum += std::abs(i);\n    }\n    return sum * prod;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106054
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    sum += std::abs(i);\n\
    \    prod *= i < 0 ? -1 : i > 0 ? 1 : 0;\n  }\n  return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long sum = 0;\n  long prod = 1;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      sum += i;\n      prod *= 1;\n    } else if (i < 0) {\n      sum +=\
    \ i * -1;\n      prod *= -1;\n    } else {\n      prod *= 0;\n    }\n  }\n  return\
    \ sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long product = 1;\n  long sum = 0;\n  for (auto num : arr) {\n    if (num\
    \ == 0) {\n      continue;\n    }\n    product *= (num > 0) ? 1 : -1;\n    sum\
    \ += std::abs(num);\n  }\n  return product * sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2,\
    \ (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1})))\
    \ == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1,\
    \ (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpcqbq4jr4: /tmp/tmpcqbq4jr4.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106054
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto &i : arr) {\n    if (i <\
    \ 0) {\n      prod *= -1;\n    } else if (i == 0) {\n      prod = 0;\n      sum\
    \ = 0;\n      break;\n    }\n    sum += std::abs(i);\n  }\n  return prod * sum;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106053
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0)\
    \ {\n      prod *= 1;\n    } else if (i < 0) {\n      prod *= -1;\n    } else\
    \ {\n      prod *= 0;\n    }\n    sum += std::abs(i);\n  }\n  return sum * prod;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n    return std::nullopt;\n\
    \  }\n  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i ==\
    \ 0) {\n      continue;\n    }\n    prod *= i > 0 ? 1 : -1;\n    sum += std::abs(i);\n\
    \  }\n  return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpbx6xrli2: /tmp/tmpbx6xrli2.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106052
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return std::nullopt;\n\
    \  long prod = 1;\n  long sum = 0;\n  for (auto i : arr) {\n    if (i > 0) {\n\
    \      prod *= 1;\n      sum += i;\n    } else if (i < 0) {\n      prod *= -1;\n\
    \      sum += -i;\n    } else {\n      prod *= 0;\n    }\n  }\n  return sum *\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long sum = 0;\n    long prod = 1;\n    for (auto i\
    \ : arr) {\n        sum += abs(i);\n        prod *= (i == 0 ? 1 : i / abs(i));\n\
    \    }\n    return sum * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2, (long)2, (long)-4})))\
    \ == -9);\n    assert(candidate((std::vector<long>({(long)0, (long)1}))) == 0);\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)1, (long)1, (long)2,\
    \ (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpz1pewo2u: /tmp/tmpz1pewo2u.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106054
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) {\n        return\
    \ std::nullopt;\n    }\n    long prod = 1;\n    long sum = 0;\n    for (auto i\
    \ : arr) {\n        if (i == 0) {\n            continue;\n        }\n        prod\
    \ *= i > 0 ? 1 : -1;\n        sum += std::abs(i);\n    }\n    return prod * sum;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: Exception
  stderr: 'tmpg7s182zh: /tmp/tmpg7s182zh.cpp:26: int main(): Assertion `candidate((std::vector<long>({(long)0,
    (long)1}))) == 0'' failed.

    '
  stdout: ''
  timestamp: 1660106054
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\nstd::optional<long>\
    \ prod_signs(std::vector<long> arr) {\n    if (arr.empty()) return std::nullopt;\n\
    \    long sum = 0;\n    long prod = 1;\n    for (auto &i : arr) {\n        if\
    \ (i > 0) {\n            sum += i;\n            prod *= 1;\n        } else if\
    \ (i < 0) {\n            sum += -i;\n            prod *= -1;\n        } else {\n\
    \            prod *= 0;\n        }\n    }\n    return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)2, (long)-4}))) == -9);\n    assert(candidate((std::vector<long>({(long)0,\
    \ (long)1}))) == 0);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
    \ (long)1, (long)2, (long)3, (long)-1, (long)1}))) == -10);\n    assert(candidate((std::vector<long>()))\
    \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)2, (long)4,\
    \ (long)1, (long)2, (long)-1, (long)-1, (long)9}))) == 20);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)-1, (long)1}))) == 4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)1}))) == -4);\n    assert(candidate((std::vector<long>({(long)-1,\
    \ (long)1, (long)1, (long)0}))) == 0);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660106054
