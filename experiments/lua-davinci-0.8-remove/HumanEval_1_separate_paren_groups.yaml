name: HumanEval_1_separate_paren_groups
language: lua
prompt: "-- Input to this function is a string containing multiple groups of nested\
  \ parentheses. Your goal is to\n-- separate those group into separate strings and\
  \ return the list of those.\n-- Separate groups are balanced (each open brace is\
  \ properly closed) and not nested within each other\n-- Ignore any spaces in the\
  \ input string.\nlocal function separate_paren_groups(paren_string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = separate_paren_groups\n\
  \    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {'(()())', '((()))',\
  \ '()', '((())()())'})\n    lu.assertEquals(candidate('() (()) ((())) (((())))'),\
  \ {'()', '(())', '((()))', '(((())))'})\n    lu.assertEquals(candidate('(()(())((())))'),\
  \ {'(()(())((())))'})\n    lu.assertEquals(candidate('( ) (( )) (( )( ))'), {'()',\
  \ '(())', '(()())'})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal paren_stack = {};\n\tlocal current_string = \"\";\n\tlocal\
    \ output = {};\n\tfor i = 1, #paren_string do\n\t\tlocal char = paren_string:sub(i,\
    \ i);\n\t\tif char == \"(\" then\n\t\t\ttable.insert(paren_stack, char);\n\t\t\
    elseif char == \")\" then\n\t\t\ttable.remove(paren_stack);\n\t\t\tif #paren_stack\
    \ == 0 then\n\t\t\t\tif current_string ~= \"\" then\n\t\t\t\t\ttable.insert(output,\
    \ current_string);\n\t\t\t\t\tcurrent_string = \"\";\n\t\t\t\tend\n\t\t\tend\n\
    \t\telseif #paren_stack > 0 then\n\t\t\tcurrent_string = current_string .. char;\n\
    \t\tend\n\tend\n\tif current_string ~= \"\" then\n\t\ttable.insert(output, current_string);\n\
    \tend\n\treturn output;\nend", "    local paren_group = {}\n    local is_escaped\
    \ = false\n    local is_quoted = false\n    local is_comment = false\n    local\
    \ paren_count = 0\n    local start_index = nil\n    local last_char = ''\n   \
    \ local group_end = false\n    for i = 1, #paren_string do\n        local char\
    \ = paren_string:sub(i, i)\n        if is_comment then\n            if char ==\
    \ '\\n' then\n                is_comment = false\n            end\n        elseif\
    \ is_escaped then\n            is_escaped = false\n        elseif is_quoted then\n\
    \            if char == '\\\\' then\n                is_escaped = true\n     \
    \       elseif char == '\"' then\n                is_quoted = false\n        \
    \    end\n        elseif char == '(' then\n            if paren_count == 0 then\n\
    \                start_index = i\n            end\n            paren_count = paren_count\
    \ + 1\n        elseif char == ')' then\n            paren_count = paren_count\
    \ - 1\n            if paren_count == 0 then\n                paren_group[#paren_group\
    \ + 1] = paren_string:sub(start_index, i)\n                group_end = true\n\
    \            end\n        elseif char == ';' then\n            is_comment = true\n\
    \        elseif char == '\"' then\n            is_quoted = true\n        end\n\
    \        last_char = char\n    end\n    if not group_end then\n        paren_group[#paren_group\
    \ + 1] = paren_string:sub(start_index, #paren_string)\n    end\n    return paren_group\n\
    end", "\tlocal separations = {}\n\t\n\tlocal left_parens = 0\n\tlocal last_found\
    \ = 0\n\tfor i=1, #paren_string do\n\t\tlocal c = paren_string:sub(i,i)\n\t\t\
    if c == \"(\" then\n\t\t\tleft_parens = left_parens + 1\n\t\telseif c == \")\"\
    \ then\n\t\t\tleft_parens = left_parens - 1\n\t\t\tif left_parens == 0 then\n\t\
    \t\t\ttable.insert(separations, paren_string:sub(last_found+1, i-1))\n\t\t\t\t\
    last_found = i\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn separations\nend", "\t\
    local paren_groups = {}\n\tlocal start_pos, end_pos = paren_string:find(\"%b()\"\
    )\n\twhile start_pos do\n\t\tlocal cur_str = paren_string:sub(start_pos, end_pos)\n\
    \t\t-- Remove the first and last char\n\t\tcur_str = cur_str:sub(2, -2)\n\t\t\
    paren_groups[#paren_groups + 1] = cur_str\n\t\tstart_pos, end_pos = paren_string:find(\"\
    %b()\", end_pos + 1)\n\tend\n\treturn paren_groups\nend", "\tlocal result = {}\n\
    \tlocal start = 0\n\tlocal found = true\n\twhile found do\n\t\tlocal start, stop\
    \ = paren_string:find(\"^%b()\", start + 1)\n\t\tif start then\n\t\t\tlocal content\
    \ = paren_string:sub(start + 1, stop - 1)\n\t\t\ttable.insert(result, content)\n\
    \t\telse\n\t\t\tfound = false\n\t\tend\n\tend\n\treturn result\nend", "\tlocal\
    \ paren_list = {}\n\tlocal temp_paren = \"\"\n\tlocal in_paren = false\n\tfor\
    \ i = 1, #paren_string do\n\t\tlocal char = paren_string:sub(i, i)\n\t\tif char\
    \ == \"(\" then\n\t\t\tin_paren = true\n\t\telseif char == \")\" then\n\t\t\t\
    in_paren = false\n\t\t\tparen_list[#paren_list + 1] = temp_paren\n\t\t\ttemp_paren\
    \ = \"\"\n\t\telseif in_paren then\n\t\t\ttemp_paren = temp_paren .. char\n\t\t\
    end\n\tend\n\treturn paren_list\nend", "    if not paren_string:find(\"%(\") then\
    \ return {} end\n    local open = 0\n    local closed = 0\n    local output =\
    \ {}\n    local cur = {}\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i,\
    \ i)\n        if c == \"(\" then\n            open = open + 1\n        elseif\
    \ c == \")\" then\n            closed = closed + 1\n        end\n        if open\
    \ == closed and open > 0 then\n            table.insert(output, table.concat(cur))\n\
    \            cur = {}\n            open = 0\n            closed = 0\n        else\n\
    \            table.insert(cur, c)\n        end\n    end\n    return output\nend",
  "  assert(type(paren_string) == \"string\")\n  local result = {}\n  local count\
    \ = 0\n  local start_index = nil\n  local end_index = nil\n  for i=1, #paren_string\
    \ do\n    local c = paren_string:sub(i,i)\n    if c == \"(\" then\n      if start_index\
    \ == nil then\n        start_index = i\n      end\n      count = count + 1\n \
    \   elseif c == \")\" then\n      count = count - 1\n      if count == 0 then\n\
    \        end_index = i\n        table.insert(result, paren_string:sub(start_index,\
    \ end_index))\n        start_index = nil\n        end_index = nil\n      end\n\
    \    end\n  end\n  return result\nend", "    local result = {}\n    local skip_next\
    \ = false", "\tlocal paren_groups = {}\n\tlocal paren_group = {}\n\tlocal brace_count\
    \ = 0\n\tfor i = 1, string.len(paren_string) do\n\t\tlocal char = string.sub(paren_string,\
    \ i, i)\n\t\tif char == \"(\" then\n\t\t\tbrace_count = brace_count + 1\n\t\t\t\
    table.insert(paren_group, char)\n\t\telseif char == \")\" then\n\t\t\tbrace_count\
    \ = brace_count - 1\n\t\t\ttable.insert(paren_group, char)\n\t\t\tif brace_count\
    \ == 0 then\n\t\t\t\ttable.insert(paren_groups, table.concat(paren_group))\n\t\
    \t\t\tparen_group = {}\n\t\t\tend\n\t\tend\n\tend\n\treturn paren_groups\nend",
  "    local groups = {}\n    local group = \"\"\n    local start_pos = 1\n    local\
    \ level = 0\n    for i=1, #paren_string do\n        local char = paren_string:sub(i,\
    \ i)\n        if char == \"(\" then\n            level = level + 1\n        elseif\
    \ char == \")\" then\n            level = level - 1\n        end\n        if char\
    \ == \" \" then\n            if level == 0 then\n                if start_pos\
    \ ~= i then\n                    groups[#groups + 1] = paren_string:sub(start_pos,\
    \ i - 1)\n                end\n                start_pos = i + 1\n           \
    \ end\n        end\n    end\n    if start_pos ~= #paren_string then\n        groups[#groups\
    \ + 1] = paren_string:sub(start_pos, #paren_string)\n    end\n    return groups\n\
    end", "\tlocal groups = {}\n\tlocal group = ''\n\tlocal open = 0\n\tfor i = 1,\
    \ #paren_string do\n\t\tlocal char = paren_string:sub(i, i)\n\t\tif char == '('\
    \ then\n\t\t\topen = open + 1\n\t\t\tgroup = group .. char\n\t\telseif char ==\
    \ ')' then\n\t\t\topen = open - 1\n\t\t\tgroup = group .. char\n\t\t\tif open\
    \ == 0 then\n\t\t\t\ttable.insert(groups, group)\n\t\t\t\tgroup = ''\n\t\t\tend\n\
    \t\telseif open > 0 then\n\t\t\tgroup = group .. char\n\t\tend\n\tend\n\treturn\
    \ groups\nend", "  local paren_groups = {}\n  local current_group = ''\n  local\
    \ paren_stack = Stack()\n  for i = 1, string.len(paren_string) do\n    local c\
    \ = string.sub(paren_string, i, i)\n    if c == '(' then\n      paren_stack:push(c)\n\
    \    elseif c == ')' then\n      paren_stack:pop()\n    end\n    if #paren_stack\
    \ == 0 then\n      if current_group ~= '' then\n        paren_groups[#paren_groups\
    \ + 1] = current_group\n        current_group = ''\n      end\n    else\n    \
    \  current_group = current_group .. c\n    end\n  end\n  return paren_groups\n\
    end", "\tlocal paren_group = {}\n\tlocal current_group = {}\n\tlocal depth = 0\n\
    \t\n\tfor i = 1, #paren_string do\n\t\tlocal current_char = paren_string:sub(i,\
    \ i)\n\t\tif current_char == \"(\" then\n\t\t\tdepth = depth + 1\n\t\t\tcurrent_group[depth]\
    \ = \"(\"\n\t\telseif current_char == \")\" then\n\t\t\tcurrent_group[depth] =\
    \ \")\"\n\t\t\tif depth == 1 then\n\t\t\t\t-- The most recent character was a\
    \ ')', so we're closing out a group.\n\t\t\t\t-- First, check to make sure the\
    \ group contains anything meaningful.\n\t\t\t\tlocal actual_group = table.concat(current_group,\
    \ \"\")\n\t\t\t\tif string.find(actual_group, \"%S\") then\n\t\t\t\t\t-- Second,\
    \ make sure the group doesn't contain any additional parentheses.\n\t\t\t\t\t\
    if not string.find(actual_group, \"%b()\") then\n\t\t\t\t\t\ttable.insert(paren_group,\
    \ actual_group)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tcurrent_group = {}\n\t\t\t\
    \tdepth = 0\n\t\t\telse\n\t\t\t\tdepth = depth - 1\n\t\t\tend\n\t\tend\n\tend\n\
    \t\n\treturn paren_group\nend", "    local groups = {}\n    local start_index\
    \ = 0\n    local end_index = 0\n    local start_paren_count = 0\n    local end_paren_count\
    \ = 0\n    for i=1, #paren_string do\n        local char = paren_string:sub(i,\
    \ i)\n        if char == \"(\" then\n            start_paren_count = start_paren_count\
    \ + 1\n            if start_paren_count == 1 then\n                start_index\
    \ = i\n            end\n        elseif char == \")\" then\n            end_paren_count\
    \ = end_paren_count + 1\n            if end_paren_count == start_paren_count then\n\
    \                end_index = i\n                groups[#groups + 1] = paren_string:sub(start_index,\
    \ end_index)\n                start_paren_count = 0\n                end_paren_count\
    \ = 0\n            end\n        end\n    end\n    return groups\nend", "    --\
    \ TODO: Implement this function.\n    -- HINT: You can use any of functions you\
    \ implemented in the first and second part of this assignment\n    -- HINT: There\
    \ are two different ways to do this\n    local stack = {}\n    local group = \"\
    \"\n    local groups = {}\n    for i = 1, string.len(paren_string) do\n      \
    \  local c = string.sub(paren_string, i, i)\n        if c == \"(\" then\n    \
    \        push(stack, c)\n        elseif c == \")\" then\n            pop(stack)\n\
    \        end\n        group = group .. c\n        if not next(stack) then\n  \
    \          groups[#groups + 1] = group\n            group = \"\"\n        end\n\
    \    end\n    return groups\nend", "\tlocal result = {}\n\tlocal level = 0\n\t\
    local start_index = 0\n\tlocal group = \"\"\n\tfor i = 1, #paren_string do\n\t\
    \tlocal char = paren_string:sub(i, i)\n\t\tif char == \"(\" then\n\t\t\tlevel\
    \ = level + 1\n\t\t\tif level == 1 then\n\t\t\t\tstart_index = i\n\t\t\tend\n\t\
    \telseif char == \")\" then\n\t\t\tlevel = level - 1\n\t\t\tif level == 0 then\n\
    \t\t\t\tgroup = paren_string:sub(start_index, i)\n\t\t\t\ttable.insert(result,\
    \ group)\n\t\t\tend\n\t\tend\n\tend\n\treturn result\nend", "\tassert(type(paren_string)\
    \ == \"string\")\n\tlocal groups = {}\n\tlocal open_group = {}\n\tlocal current_group\
    \ = 1\n\tfor i = 1, #paren_string do\n\t\tlocal c = paren_string:sub(i, i)\n\t\
    \tif c == \"(\" then\n\t\t\tif current_group > #groups then\n\t\t\t\ttable.insert(groups,\
    \ open_group)\n\t\t\t\topen_group = {}\n\t\t\t\tcurrent_group = current_group\
    \ + 1\n\t\t\tend\n\t\t\ttable.insert(open_group, c)\n\t\telseif c == \")\" then\n\
    \t\t\tif current_group == 1 then\n\t\t\t\ttable.insert(open_group, c)\n\t\t\t\
    else\n\t\t\t\ttable.insert(groups[current_group - 1], c)\n\t\t\t\tcurrent_group\
    \ = current_group - 1\n\t\t\tend\n\t\telseif c ~= \" \" then\n\t\t\ttable.insert(open_group,\
    \ c)\n\t\tend\n\tend\n\treturn groups\nend", "\tlocal paren_groups = {}\n\tlocal\
    \ current_paren_group = \"\"\n\tlocal open_parens = 0\n\tfor i = 1, string.len(paren_string)\
    \ do\n\t\tlocal c = string.sub(paren_string, i, i)\n\t\tif c == \"(\" then\n\t\
    \t\topen_parens = open_parens + 1\n\t\telseif c == \")\" then\n\t\t\topen_parens\
    \ = open_parens - 1\n\t\tend\n\t\tif open_parens == 0 then\n\t\t\ttable.insert(paren_groups,\
    \ current_paren_group)\n\t\t\tcurrent_paren_group = \"\"\n\t\telse\n\t\t\tcurrent_paren_group\
    \ = current_paren_group .. c\n\t\tend\n\tend\n\treturn paren_groups\nend", "\t\
    local paren_groups = {}\n\tlocal i = 1\n\twhile i <= #paren_string do\n\t\tif\
    \ paren_string:sub(i, i) == \"(\" then\n\t\t\tlocal group_start = i\n\t\t\tlocal\
    \ is_group_closed = false\n\t\t\tlocal paren_count = 1\n\t\t\trepeat\n\t\t\t\t\
    i = i + 1\n\t\t\t\tif paren_string:sub(i, i) == \"(\" then\n\t\t\t\t\tparen_count\
    \ = paren_count + 1\n\t\t\t\telseif paren_string:sub(i, i) == \")\" then\n\t\t\
    \t\t\tparen_count = paren_count - 1\n\t\t\t\t\tif paren_count == 0 then\n\t\t\t\
    \t\t\tis_group_closed = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\t\
    \t\tuntil i == #paren_string\n\t\t\tif is_group_closed then\n\t\t\t\tlocal group_end\
    \ = i\n\t\t\t\ttable.insert(paren_groups, paren_string:sub(group_start, group_end))\n\
    \t\t\tend\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn paren_groups\nend", "    local\
    \ function build_string(paren_string, start_pos, end_pos)\n        local str =\
    \ {}\n        for i = start_pos, end_pos do\n            table.insert(str, paren_string[i])\n\
    \        end\n        return table.concat(str)\n    end", "    local res = {}\n\
    \    local start_pos = 1\n    local indent = 0\n    local i = 0\n    local str\
    \ = paren_string", "    local pos = 1\n    local start_pos = 1\n    local end_pos\
    \ = 1\n    local paren_count = 0\n    local groups = {}\n    -- Loop through each\
    \ character\n    while pos <= #paren_string do\n        local char = paren_string:sub(pos,\
    \ pos)\n        if char == \"(\" then\n            if paren_count == 0 then\n\
    \                start_pos = pos\n            end\n            paren_count = paren_count\
    \ + 1\n        elseif char == \")\" then\n            paren_count = paren_count\
    \ - 1\n            if paren_count == 0 then\n                end_pos = pos\n \
    \               groups[#groups + 1] = paren_string:sub(start_pos, end_pos)\n \
    \           end\n        end\n        pos = pos + 1\n    end\n    return groups\n\
    end", "    local results = {}\n    local count = 0\n    local start = 1\n    for\
    \ i = 1, #paren_string do\n        local char = paren_string:sub(i, i)\n     \
    \   if char == '(' then\n            count = count + 1\n        elseif char ==\
    \ ')' then\n            count = count - 1\n        end\n        if count == 0\
    \ then\n            table.insert(results, paren_string:sub(start, i))\n      \
    \      start = i + 1\n        end\n    end\n    return results\nend", "    local\
    \ function match_parens(s)\n        local level = 0\n        local start\n   \
    \     for i = 1, #s do\n            local char = s:sub(i, i)\n            if char\
    \ == '(' then\n                if level == 0 then\n                    start =\
    \ i\n                end\n                level = level + 1\n            elseif\
    \ char == ')' then\n                level = level - 1\n                if level\
    \ == 0 then\n                    return start, i\n                end\n      \
    \      end\n        end\n    end", "    local current_group = ''\n    local groups\
    \ = {}\n    local nesting_level = 0\n    for char in paren_string:gmatch('.')\
    \ do\n        if char == '(' then\n            nesting_level = nesting_level +\
    \ 1\n        elseif char == ')' then\n            nesting_level = nesting_level\
    \ - 1\n        end\n        if (char == ' ') then\n            char = ''\n   \
    \     end\n        current_group = current_group .. char\n        if nesting_level\
    \ == 0 then\n            groups[#groups + 1] = current_group\n            current_group\
    \ = ''\n        end\n    end\n    return groups\nend", "\tlocal paren_stack =\
    \ Stack:new()\n\tlocal paren_groups = {}\n\tlocal cur_group = \"\"\n\tlocal cur_char\
    \ = \"\"\n\tlocal paren_open_char = \"(\"\n\tlocal paren_close_char = \")\"\n\t\
    local i = 1\n\twhile i <= #paren_string do\n\t\tcur_char = paren_string:sub(i,\
    \ i)\n\t\tif cur_char == paren_open_char then\n\t\t\tparen_stack:push(cur_char)\n\
    \t\telseif cur_char == paren_close_char then\n\t\t\tparen_stack:pop()\n\t\t\t\
    if paren_stack:is_empty() then\n\t\t\t\ttable.insert(paren_groups, cur_group)\n\
    \t\t\t\tcur_group = \"\"\n\t\t\tend\n\t\telseif cur_char ~= \" \" then\n\t\t\t\
    cur_group = cur_group .. cur_char\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn paren_groups\n\
    end", "    if not paren_string then return nil end\n    local result = {}\n  \
    \  local current_string = \"\"\n    local i = 1\n    local balance = 0\n    while\
    \ i <= #paren_string do\n        local c = paren_string:sub(i, i)\n        if\
    \ c == \"(\" then\n            if balance == 0 then\n                -- Start\
    \ a new group\n                current_string = \"\"\n            end\n      \
    \      balance = balance + 1\n        elseif c == \")\" then\n            balance\
    \ = balance - 1\n            if balance == 0 then\n                -- We just\
    \ closed a group\n                table.insert(result, current_string)\n     \
    \           current_string = \"\"\n            end\n        elseif balance > 0\
    \ then\n            -- We're not at a parenthesis, so this is probably a string.\n\
    \            -- If we're at a space, ignore it\n            if c ~= \" \" then\n\
    \                current_string = current_string .. c\n            end\n     \
    \   end\n        i = i + 1\n    end\n    return result\nend", "\tlocal OPEN_BRACE\
    \ = '('\n\tlocal CLOSE_BRACE = ')'\n\tlocal open_brace_index = 1\n\tlocal close_brace_index\
    \ = 0\n\tlocal result = {}\n\tlocal current_index = 0\n\tlocal last_index = string.len(paren_string)\n\
    \twhile current_index < last_index do\n\t\topen_brace_index = string.find(paren_string,\
    \ OPEN_BRACE, current_index)\n\t\tif not open_brace_index then\n\t\t\tbreak\n\t\
    \tend\n\t\topen_brace_index = open_brace_index + 1\n\t\tclose_brace_index = string.find(paren_string,\
    \ CLOSE_BRACE, open_brace_index)\n\t\tif not close_brace_index then\n\t\t\t--\
    \ this should be impossible\n\t\t\tbreak\n\t\tend\n\t\ttable.insert(result, string.sub(paren_string,\
    \ open_brace_index, close_brace_index - 1))\n\t\tcurrent_index = close_brace_index\
    \ + 1\n\tend\n\treturn result\nend", "  -- the list of strings containing separate\
    \ groups\n  local groups = {}\n  -- the current group is built up in this variable\n\
    \  local group = \"\"\n  -- parentheses stack; whenever we encounter an open brace,\
    \ it is pushed onto the stack; whenever we encounter\n  -- a close brace, the\
    \ last one is popped off the stack. Whenever the stack becomes empty, we have\
    \ found a complete\n  -- group\n  local stack = {}\n  for c in paren_string:gmatch(\"\
    .\") do\n    if c == \"(\" then\n      stack[#stack + 1] = \"(\"\n    elseif c\
    \ == \")\" then\n      stack[#stack] = nil\n      if #stack == 0 then\n      \
    \  groups[#groups + 1] = group\n        group = \"\"\n      end\n    elseif c\
    \ ~= \" \" then\n      group = group .. c\n    end\n  end\n  return groups\nend",
  "  local groups = {}\n  local group = {}\n  local level = 0\n  for i = 1, #paren_string\
    \ do\n    local c = paren_string:sub(i, i)\n    if c == '(' then\n      level\
    \ = level + 1\n    elseif c == ')' then\n      level = level - 1\n    end\n  \
    \  if level > 0 then\n      table.insert(group, c)\n    elseif #group > 0 then\n\
    \      table.insert(groups, table.concat(group))\n      group = {}\n    end\n\
    \  end\n  return groups\nend", "\tlocal t = {}\n\tlocal p = paren_string\n\tlocal\
    \ pp = string.gsub(p, '%s', '')\n\tlocal count = 0\n\tlocal i = 1\n\tlocal j =\
    \ 1\n\twhile i < string.len(pp) do\n\t\tif string.sub(pp, i, i) == '(' then\n\t\
    \t\tcount = count + 1\n\t\telseif string.sub(pp, i, i) == ')' then\n\t\t\tcount\
    \ = count - 1\n\t\tend\n\t\tif count == 0 then\n\t\t\tt[j] = string.sub(pp, 1,\
    \ i)\n\t\t\tif i < string.len(pp) then\n\t\t\t\tpp = string.sub(pp, i + 1, string.len(pp))\n\
    \t\t\t\ti = 0\n\t\t\t\tj = j + 1\n\t\t\tend\n\t\tend\n\t\ti = i + 1\n\tend\n\t\
    return t\nend", "    local groups = {}\n    local current_group = {}\n    local\
    \ depth = 0\n    for char in paren_string:gmatch('[%(%)]') do\n        if char\
    \ == '(' then\n            if depth == 0 then\n                current_group =\
    \ {}\n            end\n            depth = depth + 1\n        elseif char == ')'\
    \ then\n            depth = depth - 1\n            if depth == 0 then\n      \
    \          table.insert(groups, table.concat(current_group))\n            end\n\
    \        end\n        if depth > 0 then\n            table.insert(current_group,\
    \ char)\n        end\n    end\n    return groups\nend", "    local paren_groups\
    \ = {}\n    local current_group = {}\n    local depth = 0\n    for char in paren_string:gmatch(\"\
    .\") do\n        if char == \"(\" then\n            depth = depth + 1\n      \
    \  elseif char == \")\" then\n            depth = depth - 1\n        end\n   \
    \     if depth > 0 then\n            current_group[#current_group + 1] = char\n\
    \        elseif #current_group > 0 then\n            table.insert(paren_groups,\
    \ table.concat(current_group))\n            current_group = {}\n        end\n\
    \    end\n    return paren_groups\nend", "    local result = {}\n    local start\
    \ = 1\n    local c = 1\n    local last = 1\n    local count = 0\n    while c <=\
    \ #paren_string do\n        local c = string.sub(paren_string, c, c)\n       \
    \ if c == \"(\" then\n            if count == 0 then\n                start =\
    \ c\n            end\n            count = count + 1\n        elseif c == \")\"\
    \ then\n            count = count - 1\n            if count == 0 then\n      \
    \          result[#result + 1] = string.sub(paren_string, start, c)\n        \
    \        last = c + 1\n            end\n        end\n        c = c + 1\n    end\n\
    \    return result\nend", "\tlocal current_group = \"\"\n\tlocal groups = {}\n\
    \tlocal open_parens = 0\n\tlocal i = 1\n\twhile i <= #paren_string do\n\t\tlocal\
    \ c = string.sub(paren_string, i, i)\n\t\tif c == \"(\" then\n\t\t\topen_parens\
    \ = open_parens + 1\n\t\t\tcurrent_group = current_group .. c\n\t\telseif c ==\
    \ \")\" then\n\t\t\topen_parens = open_parens - 1\n\t\t\tcurrent_group = current_group\
    \ .. c\n\t\t\tif open_parens == 0 then\n\t\t\t\ttable.insert(groups, current_group)\n\
    \t\t\t\tcurrent_group = \"\"\n\t\t\tend\n\t\telseif not string.find(c, \"[%s]\"\
    ) then\n\t\t\terror(\"unexpected character '\" .. c .. \"' in parentheses string\"\
    )\n\t\tend\n\t\ti = i + 1\n\tend\n\tif open_parens ~= 0 then\n\t\terror(\"unbalanced\
    \ parentheses\")\n\tend\n\treturn groups\nend", "\tlocal depth = 0\n\tlocal i\
    \ = 1\n\tlocal result = {}\n\tlocal current = {}\n\twhile i <= #paren_string do\n\
    \t\tlocal c = paren_string:sub(i, i)\n\t\tif c == '(' then\n\t\t\tif depth ==\
    \ 0 then\n\t\t\t\ttable.insert(result, \"\")\n\t\t\tend\n\t\t\tdepth = depth +\
    \ 1\n\t\telseif c == ')' then\n\t\t\tdepth = depth - 1\n\t\t\tif depth == 0 then\n\
    \t\t\t\ttable.insert(result, table.concat(current))\n\t\t\t\tcurrent = {}\n\t\t\
    \tend\n\t\telseif depth > 0 then\n\t\t\ttable.insert(current, c)\n\t\tend\n\t\t\
    i = i + 1\n\tend\n\treturn result\nend", "  -- TODO: Implement this function\n\
    \  -- See README.md for an example test case.\n  local balanced_parens_list =\
    \ {}\n  local i = 1\n  local j = 1\n  local open_parens = 0\n  while i <= #paren_string\
    \ do\n    if paren_string:sub(i, i) == \"(\" then\n      open_parens = open_parens\
    \ + 1\n    elseif paren_string:sub(i, i) == \")\" then\n      open_parens = open_parens\
    \ - 1\n    end\n    if open_parens == 0 then\n      balanced_parens_list[#balanced_parens_list\
    \ + 1] = paren_string:sub(j, i)\n      j = i + 1\n    end\n    i = i + 1\n  end\n\
    \  return balanced_parens_list\nend", "    local open_paren_offset = paren_string:find(\"\
    %(\")\n    if not open_paren_offset then\n        return {}\n    end\n    local\
    \ open_paren_count = 1\n    local close_paren_count = 0\n    local close_paren_offset\
    \ = nil\n    for i = open_paren_offset + 1, #paren_string do\n        local c\
    \ = paren_string:sub(i, i)\n        if c == \"(\" then\n            open_paren_count\
    \ = open_paren_count + 1\n        elseif c == \")\" then\n            close_paren_count\
    \ = close_paren_count + 1\n        end\n        if open_paren_count == close_paren_count\
    \ then\n            close_paren_offset = i\n            break\n        end\n \
    \   end\n    assert(close_paren_offset)\n    local groups = {\n        paren_string:sub(open_paren_offset\
    \ + 1, close_paren_offset - 1)\n    }\n    local remaining_string = paren_string:sub(close_paren_offset\
    \ + 1)\n    if remaining_string ~= \"\" then\n        local remaining_groups =\
    \ separate_paren_groups(remaining_string)\n        for _, group in ipairs(remaining_groups)\
    \ do\n            table.insert(groups, group)\n        end\n    end\n    return\
    \ groups\nend", "  local result = {}\n  local current_match = nil\n  local unclosed_groups\
    \ = {}\n  local function add_char(char)\n    if current_match == nil then\n  \
    \    current_match = char\n    else\n      current_match = current_match .. char\n\
    \    end\n  end\n  local function add_closed_group()\n    table.insert(result,\
    \ current_match)\n    current_match = nil\n  end\n  local function add_open_group(char)\n\
    \    table.insert(unclosed_groups, char)\n    add_char(char)\n  end\n  local function\
    \ add_close_group(char)\n    if #unclosed_groups == 0 then\n      error(\"Too\
    \ many closing brackets\")\n    end\n    if unclosed_groups[#unclosed_groups]\
    \ == '(' and char ~= ')' then\n      error(\"Mismatched close group\")\n    end\n\
    \    if unclosed_groups[#unclosed_groups] == '[' and char ~= ']' then\n      error(\"\
    Mismatched close group\")\n    end\n    if unclosed_groups[#unclosed_groups] ==\
    \ '{' and char ~= '}' then\n      error(\"Mismatched close group\")\n    end\n\
    \    table.remove(unclosed_groups)\n    add_char(char)\n    if #unclosed_groups\
    \ == 0 then\n      add_closed_group()\n    end\n  end\n  local function add_char_to_group(char)\n\
    \    if char == '(' or char == '[' or char == '{' then\n      add_open_group(char)\n\
    \    elseif char == ')' or char == ']' or char == '}' then\n      add_close_group(char)\n\
    \    else\n      add_char(char)\n    end\n  end\n  for i = 1, #paren_string do\n\
    \    local char = paren_string:sub(i, i)\n    if char ~= ' ' then\n      add_char_to_group(char)\n\
    \    end\n  end\n  if #unclosed_groups > 0 then\n    error(\"Unclosed groups:\
    \ \" .. table.concat(unclosed_groups, \",\"))\n  end\n", "    local paren_groups\
    \ = {}\n    local current_group = ''\n    local ignore_until = nil", "  local\
    \ ret = {}\n  -- TODO: write this function\n  return ret\nend", "  local seen_open_braces\
    \ = 0\n  local ret = {}\n  local n = 1\n  local i = 1\n  local group_start = 1\n\
    \  while i <= #paren_string do\n    local ch = paren_string:sub(i, i)\n    if\
    \ ch == ' ' then\n      -- ignore space\n    elseif ch == '(' then\n      seen_open_braces\
    \ = seen_open_braces + 1\n      if seen_open_braces == 1 then\n        group_start\
    \ = i\n      end\n    elseif ch == ')' then\n      seen_open_braces = seen_open_braces\
    \ - 1\n      if seen_open_braces == 0 then\n        ret[n] = paren_string:sub(group_start,\
    \ i)\n        n = n + 1\n      end\n    end\n    i = i + 1\n  end\n  return ret\n\
    end", "    local ret_val = {}\n    local paren_level = 0\n    local current_group\
    \ = ''\n    for char in paren_string:gmatch('.') do\n        if char == '(' then\n\
    \            paren_level = paren_level + 1\n            current_group = current_group\
    \ .. char\n        elseif char == ')' then\n            paren_level = paren_level\
    \ - 1\n            current_group = current_group .. char\n            if paren_level\
    \ == 0 then\n                table.insert(ret_val, current_group)\n          \
    \      current_group = ''\n            end\n        elseif paren_level > 0 then\n\
    \            current_group = current_group .. char\n        end\n    end\n   \
    \ return ret_val\nend", "    return {}\nend", "    local groups = {}\n    local\
    \ group = \"\"\n    local balance = 0\n    for c in paren_string:gmatch(\".\"\
    ) do\n        if c == \"(\" then\n            balance = balance + 1\n        elseif\
    \ c == \")\" then\n            balance = balance - 1\n        end\n        if\
    \ balance == 0 and c == \")\" then\n            table.insert(groups, group)\n\
    \            group = \"\"\n        elseif c ~= \" \" then\n            group =\
    \ group .. c\n        end\n    end\n    if group ~= \"\" then\n        table.insert(groups,\
    \ group)\n    end\n    return groups\nend", "\tlocal result = {}\n\tlocal last_was_closed\
    \ = true\n\tlocal current_group = ''\n\tlocal last_char = nil\n\tlocal is_open\
    \ = false\n\tfor char in paren_string:gmatch('.') do\n\t\t-- Ignore any spaces\n\
    \t\tif char == ' ' then\n\t\t\tlast_char = nil\n\t\t\tgoto continue\n\t\tend\n\
    \t\t-- Open brace\n\t\tif char == '(' then\n\t\t\t-- When we find an open brace,\
    \ ignore it if the last char was a closed brace\n\t\t\tif last_was_closed then\n\
    \t\t\t\tis_open = true\n\t\t\tend\n\t\t\tlast_char = '('\n\t\t\tgoto continue\n\
    \t\tend\n\t\t-- Closed brace\n\t\tif char == ')' then\n\t\t\t-- When we find a\
    \ closed brace, add the previous group to the result and reset.\n\t\t\t-- Ignore\
    \ this closed brace if the last char was a closed brace\n\t\t\tif last_char ==\
    \ ')' then\n\t\t\t\tgoto continue\n\t\t\tend\n\t\t\tlast_was_closed = true\n\t\
    \t\tlast_char = ')'\n\t\t\tcurrent_group = current_group .. ')'\n\t\t\tresult[#result\
    \ + 1] = current_group\n\t\t\tcurrent_group = ''\n\t\t\tgoto continue\n\t\tend\n\
    \t\t-- Append the char if it is not an open or closed brace\n\t\tcurrent_group\
    \ = current_group .. char\n\t\tlast_was_closed = false\n\t\tlast_char = char\n\
    \t\t::continue::\n\tend\n\treturn result\nend", "    local paren_stack = {}\n\
    \    local result = {}\n    local current_string = \"\"\n    local char\n    local\
    \ i", "\tlocal buf = {}\n\tlocal result = {}\n\tfor ch in paren_string:gmatch(\"\
    [^%s]+\") do\n\t\tbuf[#buf + 1] = ch\n\t\tif ch == \")\" then\n\t\t\tlocal group\
    \ = table.concat(buf, \"\")\n\t\t\tresult[#result + 1] = group\n\t\t\tbuf = {}\n\
    \t\tend\n\tend\n\treturn result\nend", "\tlocal buf = {}\n\tlocal char_count =\
    \ 0\n\tlocal depth = 0\n\tfor i = 1, string.len(paren_string) do\n\t\tlocal c\
    \ = string.sub(paren_string, i, i)\n\t\tif c == '(' then\n\t\t\tif depth == 0\
    \ then\n\t\t\t\tchar_count = 1\n\t\t\telse\n\t\t\t\tchar_count = char_count +\
    \ 1\n\t\t\tend\n\t\t\tdepth = depth + 1\n\t\telseif c == ')' then\n\t\t\tdepth\
    \ = depth - 1\n\t\t\tif depth == 0 then\n\t\t\t\ttable.insert(buf, string.sub(paren_string,\
    \ i - char_count, i))\n\t\t\tend\n\t\telseif c ~= ' ' then\n\t\t\tchar_count =\
    \ char_count + 1\n\t\tend\n\tend\n\treturn buf\nend", "  local sections = {}\n\
    \  local i = 1\n  local start = 1\n  local nesting = 0\n  local found_paren =\
    \ false\n  while i <= #paren_string do\n    if paren_string:sub(i, i) == '(' then\n\
    \      nesting = nesting + 1\n      found_paren = true\n    elseif paren_string:sub(i,\
    \ i) == ')' then\n      nesting = nesting - 1\n    end\n    if nesting == 0 and\
    \ found_paren then\n      local section = paren_string:sub(start, i)\n      --\
    \ Remove extra spaces and newlines:\n      section = section:gsub('%s', '')\n\
    \      sections[#sections + 1] = section\n      start = i + 1\n      found_paren\
    \ = false\n    end\n    i = i + 1\n  end\n  return sections\nend", "    local\
    \ groups = {}\n    local group = {}\n    local paren_count = 0\n    for i = 1,\
    \ #paren_string do\n        local c = paren_string:sub(i, i)\n        if c ==\
    \ '(' then\n            paren_count = paren_count + 1\n        elseif c == ')'\
    \ then\n            paren_count = paren_count - 1\n        end\n        table.insert(group,\
    \ c)\n        if paren_count == 0 then\n            table.insert(groups, table.concat(group))\n\
    \            group = {}\n        end\n    end\n    return groups\nend", "    local\
    \ ret = {}\n    local curr_group = ''\n    local stack = {}\n    local function\
    \ push_group()\n        ret[#ret + 1] = curr_group\n        curr_group = ''\n\
    \    end\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i,\
    \ i)\n        if c == '(' then\n            if #stack > 0 then\n             \
    \   curr_group = curr_group .. c\n            end\n            stack[#stack +\
    \ 1] = '('\n        elseif c == ')' then\n            stack[#stack] = nil\n  \
    \          if #stack == 0 then\n                push_group()\n            else\n\
    \                curr_group = curr_group .. c\n            end\n        elseif\
    \ c ~= ' ' then\n            curr_group = curr_group .. c\n        end\n    end\n\
    \    return ret\nend", "\tlocal skip_next_close_brace = false\n\tlocal open_braces\
    \ = 0\n\tlocal group_start_i = 0\n\tlocal paren_groups = {}\n\tfor i=1,#paren_string\
    \ do\n\t\tlocal c = paren_string:sub(i,i)\n\t\tif c == \"(\" then\n\t\t\tif open_braces\
    \ == 0 then\n\t\t\t\tgroup_start_i = i\n\t\t\tend\n\t\t\topen_braces = open_braces\
    \ + 1\n\t\telseif c == \")\" then\n\t\t\tif skip_next_close_brace then\n\t\t\t\
    \tskip_next_close_brace = false\n\t\t\telse\n\t\t\t\topen_braces = open_braces\
    \ - 1\n\t\t\t\tif open_braces == 0 then\n\t\t\t\t\tlocal group = paren_string:sub(group_start_i,i)\n\
    \t\t\t\t\ttable.insert(paren_groups, group)\n\t\t\t\tend\n\t\t\tend\n\t\telseif\
    \ c == \"\\\\\" then\n\t\t\tskip_next_close_brace = true\n\t\tend\n\tend\n\treturn\
    \ paren_groups\nend", "    return {}\nend", "    -- Define an empty table to hold\
    \ the results of our parsing\n    local groups = {}\n    -- Try to find any nested\
    \ parentheses; if we don't find any, then we just return the whole string\n  \
    \  -- as a single group.\n    local start, finish = paren_string:find('%(.*%)')\n\
    \    if not start then\n        table.insert(groups, paren_string)\n        return\
    \ groups\n    end\n    -- If we got here, we found at least one group of nested\
    \ parentheses. Start by stripping off\n    -- everything before the first '('\
    \ in the input string and save that in the first group.\n    local leading_string\
    \ = paren_string:sub(1, start - 1)\n    table.insert(groups, leading_string)\n\
    \    -- Now cut off the substring starting at the first '(' and ending at the\
    \ last ')'\n    local substring = paren_string:sub(start, finish)\n    -- Now\
    \ recursively check to see if this substring still has any nested parentheses\n\
    \    local nested_groups = separate_paren_groups(substring)\n    -- Append the\
    \ results of the recursive call to the groups table\n    for _, grp in ipairs(nested_groups)\
    \ do\n        table.insert(groups, grp)\n    end\n    -- Now we just need to append\
    \ anything after the last closing parenthesis.\n    local trailing_string = paren_string:sub(finish\
    \ + 1)\n    table.insert(groups, trailing_string)\n    return groups\nend", " \
    \   local matches = {}\n    local start_match, end_match = string.find(paren_string,\
    \ '[%(%[]+')", "    local separator = \",\"\n    local paren_groups = {}\n   \
    \ local current_group = 1\n    local start_index = 1\n    local end_index = nil\n\
    \    local paren_count = 0\n    local next_open = nil\n    local next_close =\
    \ nil\n    local current_char = nil\n    local next_char = nil\n    local working_string\
    \ = paren_string:gsub(\" \", \"\")", "  -- Code here\nend", "\t-- Your code here\n\
    \tlocal groups = {}\n\tlocal paren_count = 0\n\tlocal start_index = 1\n\tlocal\
    \ current_index = 1\n\tlocal count = 0\n\tfor i = 1, #paren_string do\n\t\tif\
    \ paren_string:sub(i, i) == \"(\" then\n\t\t\tif paren_count == 0 then\n\t\t\t\
    \tstart_index = i\n\t\t\tend\n\t\t\tparen_count = paren_count + 1\n\t\telseif\
    \ paren_string:sub(i, i) == \")\" then\n\t\t\tparen_count = paren_count - 1\n\t\
    \t\tif paren_count == 0 then\n\t\t\t\tcount = count + 1\n\t\t\t\tgroups[count]\
    \ = paren_string:sub(start_index, i)\n\t\t\tend\n\t\tend\n\tend\n\treturn groups\n\
    end", "    -- Insert code to complete this function here.\n    return\nend", " \
    \   local paren_list = {}\n    local paren_index = 1\n    local start_index =\
    \ 1\n    local end_index = 1\n    while end_index <= #paren_string do\n      \
    \  if paren_string:sub(end_index, end_index) == \"(\" then\n            if start_index\
    \ == end_index then\n                start_index = end_index + 1\n           \
    \ end\n            local paren_count = 1\n            while paren_count > 0 do\n\
    \                end_index = end_index + 1\n                if paren_string:sub(end_index,\
    \ end_index) == \"(\" then\n                    paren_count = paren_count + 1\n\
    \                elseif paren_string:sub(end_index, end_index) == \")\" then\n\
    \                    paren_count = paren_count - 1\n                end\n    \
    \        end\n            paren_list[paren_index] = paren_string:sub(start_index,\
    \ end_index)\n            paren_index = paren_index + 1\n            start_index\
    \ = end_index + 1\n        end\n        end_index = end_index + 1\n    end\n \
    \   return paren_list\nend", "    -- TODO: Implement this function\n    -- return\
    \ a table of strings of the groups\n    local groups = {}\n    local group = ''\n\
    \    local open = 0\n    for char in paren_string:gmatch('.') do\n        if char\
    \ == '(' then\n            open = open + 1\n        elseif char == ')' then\n\
    \            open = open - 1\n        end\n        if open > 0 then\n        \
    \    group = group .. char\n        elseif open == 0 and #group > 0 then\n   \
    \         table.insert(groups, group)\n            group = ''\n        end\n \
    \   end\n    return groups\nend", "    -- TODO: implement\n    return { }\nend",
  "\tparen_string = paren_string:gsub(\"%s\", \"\")\n\tlocal groups = {}\n\tlocal\
    \ count = 0\n\tlocal last_paren = nil\n\tfor i = 1, #paren_string do\n\t\tlocal\
    \ char = paren_string:sub(i, i)\n\t\tif char == \"(\" then\n\t\t\tif count ==\
    \ 0 then\n\t\t\t\tlast_paren = i\n\t\t\tend\n\t\t\tcount = count + 1\n\t\telseif\
    \ char == \")\" then\n\t\t\tcount = count - 1\n\t\t\tif count == 0 then\n\t\t\t\
    \ttable.insert(groups, paren_string:sub(last_paren, i))\n\t\t\tend\n\t\tend\n\t\
    end\n\treturn groups\nend", "    -- your code here\n    local paren_string = paren_string\n\
    \    local paren_groups = {}\n    local current_group = \"\"\n    local open_braces\
    \ = 0\n    for i = 1, #paren_string do\n        if paren_string:sub(i, i) == \"\
    (\" then\n            open_braces = open_braces + 1\n            current_group\
    \ = current_group .. \"(\"\n        elseif paren_string:sub(i, i) == \")\" then\n\
    \            open_braces = open_braces - 1\n            current_group = current_group\
    \ .. \")\"\n            if open_braces == 0 then\n                table.insert(paren_groups,\
    \ current_group)\n                current_group = \"\"\n            end\n    \
    \    end\n    end\n    return paren_groups\nend", "    -- TODO: complete this\
    \ function\n    local functions = {\"global\", \"local\", \"function\"}\n    local\
    \ table = {}\n    local paren_stack = {}\n    local open = 1\n    local close\
    \ = 1\n    local count = 0\n    local new_string = \"\"\n    for i = 1, #paren_string\
    \ do\n        if(paren_string:sub(i,i) == \" \") then\n            count = count\
    \ + 1\n        end\n    end\n    if(count == #paren_string) then\n        table[1]\
    \ = \"\"\n        return table\n    end\n    while(open <= #paren_string) do\n\
    \        while(paren_string:sub(open,open) == \" \") do\n            open = open\
    \ + 1\n        end\n        while(paren_string:sub(close,close) == \" \") do\n\
    \            close = close + 1\n        end\n        if(paren_string:sub(open,open)\
    \ == \"(\") then\n            table.insert(paren_stack, open)\n        elseif(paren_string:sub(open,open)\
    \ == \")\") then\n            if(#paren_stack == 0) then\n                return\
    \ {\"error\"}\n            end\n            table.remove(paren_stack)\n      \
    \      if(#paren_stack == 0) then\n                new_string = paren_string:sub(close,\
    \ open)\n                table.insert(table, new_string)\n                close\
    \ = open + 1\n            end\n        end\n        open = open + 1\n    end\n\
    \    if(#paren_stack ~= 0) then\n        return {\"error\"}\n    end\n    return\
    \ table\nend", "  local start = 1\n  local output = {}\n  while true do\n    local\
    \ open_paren_pos = paren_string:find(\"[(]\", start)\n    if not open_paren_pos\
    \ then break end\n    local close_paren_pos = paren_string:find(\"[)]\", open_paren_pos\
    \ + 1)\n    if not close_paren_pos then break end\n    local sub_string = paren_string:sub(open_paren_pos,\
    \ close_paren_pos)\n    table.insert(output, sub_string)\n    start = close_paren_pos\
    \ + 1\n  end\n  return output\nend", "  local groups = {}\n  local curr_group\
    \ = {}\n  local paren_stack = {}\n  for char in paren_string:gmatch(\".\") do\n\
    \    if char == \"(\" then\n      table.insert(paren_stack, char)\n    elseif\
    \ char == \")\" then\n      if #paren_stack == 0 then\n        error(\"Too many\
    \ closing parentheses\")\n      end\n      table.remove(paren_stack)\n      if\
    \ #paren_stack == 0 then\n        table.insert(groups, table.concat(curr_group))\n\
    \        curr_group = {}\n      end\n    elseif char ~= \" \" then\n      table.insert(curr_group,\
    \ char)\n    end\n  end\n  if #paren_stack > 0 then\n    error(\"Not enough closing\
    \ parentheses\")\n  end\n  return groups\nend", "    local result = {}\n    local\
    \ level = 0\n    local curr_pos = 1\n    for pos in string.gmatch(paren_string,\
    \ \"()%b()\") do\n        local ch = string.sub(paren_string, pos, pos)\n    \
    \    if ch == \"(\" then\n            level = level + 1\n        elseif ch ==\
    \ \")\" then\n            level = level - 1\n        end\n        if level ==\
    \ 0 then\n            local sub_string = string.sub(paren_string, curr_pos, pos)\n\
    \            -- sub_string should begin and end with a \"(\" and \")\"\n     \
    \       assert(string.sub(sub_string, 1, 1) == \"(\")\n            assert(string.sub(sub_string,\
    \ -1, -1) == \")\")\n            table.insert(result, string.sub(sub_string, 2,\
    \ -2))\n            curr_pos = pos + 1\n        end\n    end\n    return result\n\
    end", "    local paren_list = {}\n    local current_paren_string = \"\"\n    local\
    \ count = 0\n    for i = 1, #paren_string do\n        local char = paren_string:sub(i,\
    \ i)\n        if char == \"(\" then\n            count = count + 1\n        elseif\
    \ char == \")\" then\n            count = count - 1\n        end\n        current_paren_string\
    \ = current_paren_string .. char\n        if count == 0 then\n            table.insert(paren_list,\
    \ current_paren_string)\n            current_paren_string = \"\"\n        end\n\
    \    end\n    return paren_list\nend", "  -- TODO: Implement this function.\n\
    \  --\n  -- Note: You may assume that the input string is entirely composed of\
    \ parens, spaces, and commas,\n  -- and that if there are multiple groups, they\
    \ are separated by commas.\n  --\n  -- Example:\n  -- separate_paren_groups(\"\
    ()()()\") -> {\"()\", \"()\", \"()\"}\n  -- separate_paren_groups(\"(a)\") ->\
    \ {\"a\"}\n  -- separate_paren_groups(\"()(),()\") -> {\"()\", \"()\"}\n  -- separate_paren_groups(\"\
    (()())\") -> {\"()()\"}\n  -- separate_paren_groups(\"(()())()\") -> {\"()()\"\
    , \"()\"}\n  -- separate_paren_groups(\"(((()())))\") -> {\"()()\"}\n  local count\
    \ = 0\n  local result = {}\n  local group = \"\"\n  for i=1, #paren_string do\n\
    \    if paren_string:sub(i,i) == \"(\" then\n      count = count + 1\n    elseif\
    \ paren_string:sub(i,i) == \")\" then\n      count = count - 1\n    end\n    if\
    \ count == 0 and paren_string:sub(i,i) == \",\" then\n      result[#result+1]\
    \ = group\n      group = \"\"\n    else\n      group = group .. paren_string:sub(i,i)\n\
    \    end\n  end\n  result[#result+1] = group\n  return result\nend", "    local\
    \ res = {}\n    local open_braces = 0\n    local next_open = 1\n    local next_close\
    \ = 1\n    local prev_close = 1\n    for i = 1, #paren_string do\n        local\
    \ ch = paren_string:sub(i, i)\n        if ch == '(' then\n            open_braces\
    \ = open_braces + 1\n            if open_braces == 1 then\n                next_open\
    \ = i\n            end\n        elseif ch == ')' then\n            open_braces\
    \ = open_braces - 1\n            if open_braces == 0 then\n                next_close\
    \ = i\n                res[#res + 1] = paren_string:sub(next_open, next_close)\n\
    \                prev_close = next_close\n            end\n        end\n    end\n\
    \    return res\nend", "    -- Your code here\nend", "\tlocal stack = {}\n\tlocal\
    \ curr_str = \"\"\n\tlocal output = {}\n\tlocal str_start = 1\n\tfor i = 1, #paren_string\
    \ do\n\t\tlocal c = paren_string:sub(i, i)\n\t\tif c == \"(\" then\n\t\t\tif #stack\
    \ == 0 then\n\t\t\t\tstr_start = i\n\t\t\tend\n\t\t\ttable.insert(stack, c)\n\t\
    \telseif c == \")\" then\n\t\t\ttable.remove(stack)\n\t\t\tif #stack == 0 then\n\
    \t\t\t\ttable.insert(output, paren_string:sub(str_start, i))\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn output\nend", "    return {}\nend", "    local ret_list =\
    \ {}\n    local count = 0\n    local start_index = 0\n    local next_index = 0\n\
    \    local first_index = 0\n    local first_paren = false\n    local last_index\
    \ = 0\n    for index=1,#paren_string do\n        if paren_string:sub(index,index)\
    \ == \"(\" then\n            if first_paren == false then\n                first_index\
    \ = index\n                first_paren = true\n            end\n            count\
    \ = count + 1\n        elseif paren_string:sub(index,index) == \")\" then\n  \
    \          count = count - 1\n            if count == 0 then\n               \
    \ last_index = index\n                ret_list[#ret_list+1] = paren_string:sub(first_index,last_index)\n\
    \                first_paren = false\n            end\n        end\n    end\n\
    \    return ret_list\nend", "  local list = {}\n  local start = 1\n  local stack\
    \ = 0\n  local str = \"\"\n  for i = 1,#paren_string do\n    local ch = paren_string:sub(i,i)\n\
    \    if ch == \"(\" then\n      stack = stack + 1\n      if stack == 1 then\n\
    \        start = i\n      end\n    elseif ch == \")\" then\n      stack = stack\
    \ - 1\n      if stack == 0 then\n        str = paren_string:sub(start,i)\n   \
    \     list[#list+1] = str\n      end\n    end\n  end\n  return list\nend", " \
    \ -- TODO\nend", "    --[[\n    #7c\n    ###\n    #7c\n    #0c\n    #7c\n    #0c\n\
    \    ###\n    ]]--\n    --[[", "    -- check for empty string\n    if #paren_string\
    \ == 0 then\n        return {}\n    end", "    local l, r = paren_string:find(\"\
    %b()\")\n    local result = {}\n    while l do\n        local paren_group = paren_string:sub(l,\
    \ r)\n        result[#result + 1] = paren_group\n        paren_string = paren_string:sub(r\
    \ + 1)\n        l, r = paren_string:find(\"%b()\")\n    end\n    return result\n\
    end", "\tlocal current_string = \"\"\n\tlocal result = {}\n\tlocal level = 0",
  "\t-- TODO: Implement this!\n\treturn {}\nend", "    local acc = {}\n    local acc_count\
    \ = 0\n    local acc_string = \"\"\n    local unclosed_count = 0\n    for i=1,#paren_string\
    \ do\n        local c = paren_string:sub(i,i)\n        if c == \"(\" then\n  \
    \          unclosed_count = unclosed_count + 1\n        elseif c == \")\" then\n\
    \            unclosed_count = unclosed_count - 1\n        end\n        acc_string\
    \ = acc_string .. c\n        if unclosed_count == 0 then\n            acc_count\
    \ = acc_count + 1\n            acc[acc_count] = acc_string\n            acc_string\
    \ = \"\"\n        end\n    end\n    return acc\nend", "    local paren_groups\
    \ = {}\n    local stack = {}\n    local start_pos = 1\n    for i = 1, #paren_string\
    \ do\n        local char = paren_string:sub(i, i)\n        if char == ' ' then\n\
    \            if #stack > 0 then\n                -- inside a group, ignore spaces\n\
    \            else\n                -- outside a group, this is where the next\
    \ group starts\n                start_pos = i + 1\n            end\n        elseif\
    \ char == '(' then\n            table.insert(stack, '(')\n        elseif char\
    \ == ')' then\n            table.remove(stack)\n            if #stack == 0 then\n\
    \                -- we've reached the end of a group\n                table.insert(paren_groups,\
    \ paren_string:sub(start_pos, i))\n            end\n        end\n    end\n   \
    \ return paren_groups\nend", "    local groups = {}\n    local i = 1\n    local\
    \ current_group = ''\n    local level = 0", "  local cur_string = \"\"\n  local\
    \ result = {}\n  local count = 0\n  local function inner(char)\n    if char ==\
    \ \"(\" then\n      count = count + 1\n    elseif char == \")\" then\n      count\
    \ = count - 1\n    end\n    if count == 0 then\n      table.insert(result, cur_string)\n\
    \      cur_string = \"\"\n    else\n      cur_string = cur_string .. char\n  \
    \  end\n  end\n  for c in paren_string:gmatch('.') do\n    if c ~= \" \" then\n\
    \      inner(c)\n    end\n  end\n  if cur_string ~= \"\" then\n    -- Last group\
    \ wasn't closed properly\n    return false\n  end\n  return result\nend", "  \
    \  local list = {}\n    local cur_group = ''\n    local open_braces = 0\n    for\
    \ i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if\
    \ c == '(' then\n            open_braces = open_braces + 1\n        elseif c ==\
    \ ')' then\n            open_braces = open_braces - 1\n        end\n        if\
    \ open_braces == 0 and c == ')' then\n            list[#list + 1] = cur_group\n\
    \            cur_group = ''\n        elseif c ~= ' ' then\n            cur_group\
    \ = cur_group .. c\n        end\n    end\n    return list\nend", "\t-- True if\
    \ char is a space\n\tlocal function is_space(char)\n\t\treturn char == ' '\n\t\
    end", "    -- i.e. \"(abc(xyz))mn(abc(xyz))\" -> {\"abc(xyz)\", \"abc(xyz)\"}\n\
    \    local groups = {}\n    for s in paren_string:gmatch(\"%b()\") do\n      \
    \  table.insert(groups, s:sub(2, -2))\n    end\n    return groups\nend", "   \
    \ local res = {}\n    local group = 0\n    local start = 1\n    local stop = 1\n\
    \    local i = 1\n    while i <= #paren_string do\n        if paren_string:sub(i,\
    \ i) == '(' then\n            if group == 0 then\n                start = i\n\
    \            end\n            group = group + 1\n        elseif paren_string:sub(i,\
    \ i) == ')' then\n            group = group - 1\n            if group == 0 then\n\
    \                stop = i\n                table.insert(res, paren_string:sub(start,\
    \ stop))\n            end\n        end\n        i = i + 1\n    end\n    return\
    \ res\nend", "    local result = {}\n    local temp = \"\"\n    local depth =\
    \ 0\n    local char = \"\"\n    for i = 1, #paren_string do\n        char = paren_string:sub(i,\
    \ i)\n        if char == \"(\" then\n            if depth == 0 then\n        \
    \        temp = \"\"\n            end\n            depth = depth + 1\n       \
    \ elseif char == \")\" then\n            depth = depth - 1\n            if depth\
    \ == 0 then\n                result[#result + 1] = temp\n            end\n   \
    \     elseif depth > 0 then\n            temp = temp .. char\n        end\n  \
    \  end\n    return result\nend", "  local result = {}\n  local in_parens = false\n\
    \  local current_paren_string = \"\"\n  for i = 1, #paren_string do\n    local\
    \ char = paren_string:sub(i, i)\n    if not in_parens and char == \"(\" then\n\
    \      in_parens = true\n    elseif in_parens and char == \")\" then\n      table.insert(result,\
    \ current_paren_string)\n      current_paren_string = \"\"\n      in_parens =\
    \ false\n    elseif in_parens then\n      current_paren_string = current_paren_string\
    \ .. char\n    end\n  end\n  return result\nend", "\tlocal count = 0\n\tlocal\
    \ groups = {}\n\tlocal current_group = \"\"\n\tfor char in paren_string:gmatch(\"\
    [^%s]\") do\n\t\tif char == \"(\" then\n\t\t\tcount = count + 1\n\t\t\tif count\
    \ == 1 then\n\t\t\t\tcurrent_group = \"\"\n\t\t\tend\n\t\telseif char == \")\"\
    \ then\n\t\t\tcount = count - 1\n\t\t\tif count == 0 then\n\t\t\t\ttable.insert(groups,\
    \ current_group)\n\t\t\tend\n\t\tend\n\t\tif count > 0 then\n\t\t\tcurrent_group\
    \ = current_group .. char\n\t\tend\n\tend\n\treturn groups\nend", "    local ret\
    \ = {}\n    local group = \"\"\n    local level = 0\n    for i = 1, #paren_string\
    \ do\n        local c = paren_string:sub(i, i)\n        if c == \"(\" then\n \
    \           if level == 0 then\n                group = \"\"\n            end\n\
    \            level = level + 1\n        elseif c == \")\" then\n            level\
    \ = level - 1\n            if level == 0 then\n                ret[#ret + 1] =\
    \ group\n            end\n        elseif level ~= 0 then\n            group =\
    \ group .. c\n        end\n    end\n    return ret\nend", "    local paren_group\
    \ = \"\"\n    local paren_groups = {}\n    local paren_count = 0\n    for i =\
    \ 1, #paren_string do\n        local char = paren_string:sub(i, i)\n        if\
    \ char == \"(\" then\n            paren_count = paren_count + 1\n        elseif\
    \ char == \")\" then\n            paren_count = paren_count - 1\n        end\n\
    \        if paren_count == 0 and char == \")\" then\n            paren_groups[#paren_groups\
    \ + 1] = paren_group\n            paren_group = \"\"\n        else\n         \
    \   paren_group = paren_group .. char\n        end\n    end\n    return paren_groups\n\
    end", "  -- TODO: do something\nend", "\treturn {}\nend", "\tlocal paren_groups\
    \ = {}\n\t-- Remove all spaces\n\tparen_string = paren_string:gsub(\"%s\", \"\"\
    )\n\t-- Get the indices of all open parens and all close parens\n\tlocal open_index,\
    \ close_index\n\tlocal open_parens = {}\n\tlocal close_parens = {}\n\tfor i =\
    \ 1, #paren_string do\n\t\tif paren_string:sub(i, i) == \"(\" then\n\t\t\ttable.insert(open_parens,\
    \ i)\n\t\telseif paren_string:sub(i, i) == \")\" then\n\t\t\ttable.insert(close_parens,\
    \ i)\n\t\tend\n\tend\n\twhile #open_parens > 0 do\n\t\topen_index = table.remove(open_parens,\
    \ 1)\n\t\tclose_index = table.remove(close_parens, 1)\n\t\tlocal paren_group =\
    \ paren_string:sub(open_index, close_index)\n\t\tif paren_group ~= \"\" then\n\
    \t\t\ttable.insert(paren_groups, paren_group)\n\t\tend\n\tend\n\treturn paren_groups\n\
    end", "\tlocal count = 0\n\tlocal start = 1\n\tlocal res = {}\n\t\n\tfor i = 1,\
    \ #paren_string do\n\t\tlocal c = paren_string:sub(i, i)\n\t\tif c == '(' then\n\
    \t\t\tcount = count + 1\n\t\telseif c == ')' then\n\t\t\tcount = count - 1\n\t\
    \tend\n\t\t\n\t\tif count == 0 then\n\t\t\tres[#res + 1] = paren_string:sub(start,\
    \ i)\n\t\t\tstart = i + 1\n\t\tend\n\tend\n\t\n\treturn res\nend", "\t-- replace\
    \ this with your code\n\treturn {paren_string}\nend", "    local result = {}\n\
    \    -- Here is an example solution that uses a stack to keep track of the open\
    \ braces\n    local stack = {}\n    local cur_group = ''\n    for i = 1, #paren_string\
    \ do\n        local c = paren_string:sub(i, i)\n        if c == ' ' then\n   \
    \         -- do nothing\n        elseif c == '(' then\n            table.insert(stack,\
    \ c)\n        elseif c == ')' then\n            table.remove(stack)\n        \
    \    if #stack == 0 then\n                table.insert(result, cur_group)\n  \
    \              cur_group = ''\n            end\n        else\n            if #stack\
    \ > 0 then\n                cur_group = cur_group .. c\n            end\n    \
    \    end\n    end\n    return result\nend", "\tlocal groups = {}\n\tlocal group\
    \ = {}\n\tlocal group_open = false\n\tlocal group_close = false\n\tfor i = 1,\
    \ #paren_string do\n\t\tlocal c = paren_string:sub(i, i)\n\t\tif c == \"(\" then\n\
    \t\t\tif group_open then\n\t\t\t\ttable.insert(group, c)\n\t\t\telse\n\t\t\t\t\
    table.insert(groups, group)\n\t\t\t\tgroup = {c}\n\t\t\t\tgroup_open = true\n\t\
    \t\t\tgroup_close = false\n\t\t\tend\n\t\telseif c == \")\" then\n\t\t\tif group_close\
    \ then\n\t\t\t\ttable.insert(group, c)\n\t\t\telse\n\t\t\t\ttable.insert(group,\
    \ c)\n\t\t\t\tgroup_open = false\n\t\t\t\tgroup_close = true\n\t\t\tend\n\t\t\
    elseif c == \" \" then\n\t\t\t-- Do nothing\n\t\telse\n\t\t\ttable.insert(group,\
    \ c)\n\t\tend\n\tend\n\ttable.insert(groups, group)\n\treturn groups\nend", "\t\
    return {}\nend", "\tlocal results = {}\n\tlocal current_str = ''\n\tlocal found_one\
    \ = false\n\tlocal depth = 0\n\tfor idx = 1, #paren_string do\n\t\tlocal char\
    \ = paren_string:sub(idx, idx)\n\t\tif char == '(' then\n\t\t\tdepth = depth +\
    \ 1\n\t\t\tif depth == 1 then\n\t\t\t\tfound_one = true\n\t\t\t\tcurrent_str =\
    \ '('\n\t\t\tend\n\t\telseif char == ')' then\n\t\t\tdepth = depth - 1\n\t\t\t\
    if depth == 0 then\n\t\t\t\tcurrent_str = current_str .. ')'\n\t\t\t\tresults[#results\
    \ + 1] = current_str\n\t\t\t\tcurrent_str = ''\n\t\t\tend\n\t\telseif depth >\
    \ 0 then\n\t\t\tcurrent_str = current_str .. char\n\t\tend\n\tend\n\tif found_one\
    \ then\n\t\treturn results\n\telse\n\t\treturn nil\n\tend\nend", "    return {\"\
    a\", \"b\"}\nend", "    local groups = {}\n    local idx = 1\n    while idx <=\
    \ #paren_string do\n        local next_start = paren_string:find(\"%b()\", idx)\n\
    \        if next_start then\n            local group_str = paren_string:sub(next_start,\
    \ paren_string:find(\"^%b()\", next_start):len())\n            table.insert(groups,\
    \ group_str)\n            idx = next_start + group_str:len()\n        else\n \
    \           break\n        end\n    end\n    return groups\nend", "    local paren_groups\
    \ = {}\n    local current_paren_group = \"\"\n    local paren_count = 0\n    for\
    \ i = 1, string.len(paren_string) do\n        local char = string.sub(paren_string,\
    \ i, i)\n        if char == \"(\" then\n            paren_count = paren_count\
    \ + 1\n            current_paren_group = current_paren_group .. char\n       \
    \ elseif char == \")\" then\n            paren_count = paren_count - 1\n     \
    \       current_paren_group = current_paren_group .. char\n            if paren_count\
    \ == 0 then\n                table.insert(paren_groups, current_paren_group)\n\
    \                current_paren_group = \"\"\n            end\n        elseif paren_count\
    \ > 0 then\n            current_paren_group = current_paren_group .. char\n  \
    \      end\n    end\n    return paren_groups\nend", "\tlocal parse_stack = {}\n\
    \tlocal top_group = \"\"\n\tlocal groups = {}\n\tfor char in paren_string:gmatch(\"\
    .\") do\n\t\tif char == \"(\" then\n\t\t\tparse_stack[#parse_stack + 1] = \"(\"\
    \n\t\t\ttop_group = top_group .. \"(\"\n\t\telseif char == \")\" then\n\t\t\t\
    if #parse_stack == 0 then\n\t\t\t\treturn nil, \"Mismatched closing parentheses\"\
    \n\t\t\tend\n\t\t\tparse_stack[#parse_stack] = nil\n\t\t\ttop_group = top_group\
    \ .. \")\"\n\t\t\tif #parse_stack == 0 then\n\t\t\t\tgroups[#groups + 1] = top_group\n\
    \t\t\t\ttop_group = \"\"\n\t\t\tend\n\t\tend\n\tend\n\tif #parse_stack > 0 then\n\
    \t\treturn nil, \"Unbalanced opening parentheses\"\n\tend\n\treturn groups\nend",
  "  local result = {}\n  local current_group = \"\"\n  local bracket_count = 0\n\
    \  for i = 1, #paren_string do\n    local ch = paren_string:sub(i, i)\n    if\
    \ ch == \"(\" then\n      if bracket_count == 0 then\n        current_group =\
    \ \"(\"\n      else\n        current_group = current_group .. \"(\"\n      end\n\
    \      bracket_count = bracket_count + 1\n    elseif ch == \")\" then\n      bracket_count\
    \ = bracket_count - 1\n      if bracket_count == 0 then\n        result[#result\
    \ + 1] = current_group .. \")\"\n      else\n        current_group = current_group\
    \ .. \")\"\n      end\n    elseif ch ~= \" \" then\n      if bracket_count ==\
    \ 0 then\n        current_group = current_group .. ch\n      else\n        current_group\
    \ = current_group .. ch\n      end\n    end\n  end\n  return result\nend", "\t\
    local paren_groups = {}\n\tlocal group = \"\"\n\tlocal paren_depth = 0\n\tfor\
    \ i = 1, #paren_string do\n\t\tlocal c = paren_string:sub(i, i)\n\t\tif c == \"\
    (\" then\n\t\t\tparen_depth = paren_depth + 1\n\t\t\tif paren_depth == 1 then\n\
    \t\t\t\tgroup = \"\"\n\t\t\tend\n\t\telseif c == \")\" then\n\t\t\tparen_depth\
    \ = paren_depth - 1\n\t\t\tif paren_depth == 0 then\n\t\t\t\ttable.insert(paren_groups,\
    \ group)\n\t\t\tend\n\t\telseif paren_depth > 0 then\n\t\t\tgroup = group .. c\n\
    \t\tend\n\tend\n\treturn paren_groups\nend", "    local result = {}\n    local\
    \ group_start = 0\n    local depth = 0\n    for i = 1, #paren_string do\n    \
    \    local c = paren_string:sub(i, i)\n        if c == '(' then\n            if\
    \ depth == 0 then\n                group_start = i\n            end\n        \
    \    depth = depth + 1\n        elseif c == ')' then\n            depth = depth\
    \ - 1\n            if depth == 0 then\n                local group = paren_string:sub(group_start,\
    \ i)\n                table.insert(result, group)\n            end\n        end\n\
    \    end\n    return result\nend", "\tlocal results = {}\n\tlocal str = paren_string:gsub(\"\
    %s\", \"\")\n\tlocal temp = \"\"\n\tfor char in str:gmatch(\".\") do\n\t\tif char\
    \ == \"(\" then\n\t\t\ttemp = temp .. char\n\t\telseif char == \")\" then\n\t\t\
    \ttemp = temp .. char\n\t\t\ttable.insert(results, temp)\n\t\t\ttemp = \"\"\n\t\
    \tend\n\tend\n\treturn results\nend", "  local parts = {}\n  local current_part\
    \ = \"\"\n  local open_count = 0\n  for _,ch in ipairs(list(paren_string)) do\n\
    \    if ch == \"(\" then\n      open_count = open_count + 1\n      current_part\
    \ = current_part .. ch\n    elseif ch == \")\" then\n      open_count = open_count\
    \ - 1\n      current_part = current_part .. ch\n      if open_count == 0 then\n\
    \        table.insert(parts, current_part)\n        current_part = \"\"\n    \
    \  end\n    elseif ch ~= \" \" then\n      current_part = current_part .. ch\n\
    \    end\n  end\n  return parts\nend", "  local group_start = 0\n  local group_end\
    \ = 0\n  local group_count = 0\n  local paren_groups = {}\n  for char_index =\
    \ 1, #paren_string do\n    local char = paren_string:sub(char_index, char_index)\n\
    \    if char == \"(\" then\n      if group_count == 0 then\n        group_start\
    \ = char_index\n      end\n      group_count = group_count + 1\n    elseif char\
    \ == \")\" then\n      group_count = group_count - 1\n      if group_count ==\
    \ 0 then\n        group_end = char_index\n        table.insert(paren_groups, paren_string:sub(group_start,\
    \ group_end))\n      end\n    end\n  end\n  return paren_groups\nend", "\tlocal\
    \ groups = {}\n\tlocal paren_stack = {}\n\tlocal escape = false\n\tlocal group_start\
    \ = 1\n\tlocal i = 1\n\tlocal paren_string_len = paren_string:len()\n\twhile i\
    \ <= paren_string_len do\n\t\tlocal c = paren_string:sub(i, i)\n\t\tif c == '\\\
    \\' then\n\t\t\tescape = true\n\t\telseif escape then\n\t\t\tescape = false\n\t\
    \telseif c == '(' then\n\t\t\ttable.insert(paren_stack, c)\n\t\telseif c == ')'\
    \ then\n\t\t\ttable.remove(paren_stack)\n\t\t\tif #paren_stack == 0 then\n\t\t\
    \t\ttable.insert(groups, paren_string:sub(group_start, i))\n\t\t\t\tgroup_start\
    \ = i + 1\n\t\t\tend\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn groups\nend", " \
    \ local groups = {}\n  local acc = {}\n  local opened = 0\n  for c in paren_string:gmatch\"\
    .\" do\n    if c == \"(\" then\n      opened = opened + 1\n    elseif c == \"\
    )\" then\n      opened = opened - 1\n    end\n    if opened == 0 then\n      table.insert(groups,\
    \ table.concat(acc))\n      acc = {}\n    else\n      table.insert(acc, c)\n \
    \   end\n  end\n  return groups\nend", "\tlocal paren_groups = {}\n\tlocal last_group\
    \ = 1\n\tlocal paren_level = 0\n\tfor i = 1, string.len(paren_string) do\n\t\t\
    local paren = string.sub(paren_string, i, i)\n\t\tif paren == \"(\" then\n\t\t\
    \tparen_level = paren_level + 1\n\t\telseif paren == \")\" then\n\t\t\tparen_level\
    \ = paren_level - 1\n\t\t\tif paren_level == 0 then\n\t\t\t\tlocal paren_group\
    \ = string.sub(paren_string, last_group, i)\n\t\t\t\ttable.insert(paren_groups,\
    \ paren_group)\n\t\t\t\tlast_group = i + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ paren_groups\nend", "  local matches = {}\n  local start_pos = 1\n  local end_pos\
    \ = 1\n  local match_found = true\n  while match_found do\n    start_pos, end_pos\
    \ = string.find(paren_string, \"%b()\", start_pos)\n    if not start_pos then\n\
    \      match_found = false\n    else\n      table.insert(matches, string.sub(paren_string,\
    \ start_pos, end_pos))\n      start_pos = end_pos + 1\n    end\n  end\n  return\
    \ matches\nend", "\tlocal paren_group_separated = {}\n\tlocal paren_group_string\
    \ = \"\"\n\tlocal last_group_char = \"\"\n\tfor i = 1, #paren_string do\n\t\t\
    local paren_char = paren_string:sub(i, i)\n\t\tif paren_char == \" \" then\n\t\
    \t\t-- ignore spaces\n\t\telseif paren_char == \"(\" then\n\t\t\tif last_group_char\
    \ == \")\" then\n\t\t\t\ttable.insert(paren_group_separated, paren_group_string)\n\
    \t\t\t\tparen_group_string = \"\"\n\t\t\tend\n\t\t\tparen_group_string = paren_group_string\
    \ .. paren_char\n\t\telseif paren_char == \")\" then\n\t\t\tparen_group_string\
    \ = paren_group_string .. paren_char\n\t\t\tlast_group_char = paren_char\n\t\t\
    end\n\tend\n\tif paren_group_string ~= \"\" then\n\t\ttable.insert(paren_group_separated,\
    \ paren_group_string)\n\tend\n\treturn paren_group_separated\nend", "    local\
    \ paren_depth = 0\n    local group_start = 0\n    local res = {}\n    local has_close_parens\
    \ = false\n    for i = 1, #paren_string do\n        local c = paren_string:sub(i,\
    \ i)\n        if c == '(' then\n            paren_depth = paren_depth + 1\n  \
    \          if paren_depth == 1 then\n                group_start = i\n       \
    \     end\n        elseif c == ')' then\n            paren_depth = paren_depth\
    \ - 1\n            if paren_depth == 0 then\n                has_close_parens\
    \ = true\n                res[#res + 1] = paren_string:sub(group_start, i)\n \
    \           end\n        end\n    end\n    if not has_close_parens then\n    \
    \    error('Parentheses are not properly closed.')\n    end\n    return res\n\
    end", "\tlocal out = {}\n\tlocal current_index = 1\n\tlocal count = 0\n\tlocal\
    \ start_index = nil\n\tfor i = 1, #paren_string do\n\t\tlocal char = paren_string:sub(i,\
    \ i)\n\t\tif char == \"(\" then\n\t\t\tif count == 0 then\n\t\t\t\tstart_index\
    \ = i\n\t\t\tend\n\t\t\tcount = count + 1\n\t\telseif char == \")\" then\n\t\t\
    \tcount = count - 1\n\t\t\tif count == 0 then\n\t\t\t\tlocal current_string =\
    \ paren_string:sub(start_index, i)\n\t\t\t\tout[current_index] = current_string\n\
    \t\t\t\tcurrent_index = current_index + 1\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ out\nend", "  return {}\nend", "\t--separates a string with more than one group\
    \ of parentheses into separate strings, returning a list\n\tlocal separated_groups\
    \ = {}\n\tlocal i = 1\n\tlocal paren_string_len = string.len(paren_string)\n\t\
    while i <= paren_string_len do\n\t\tlocal bracket_count = 0\n\t\tlocal num_chars\
    \ = 0\n\t\twhile i <= paren_string_len do\n\t\t\tlocal current_char = string.sub(paren_string,\
    \ i, i)\n\t\t\tif current_char == \"(\" then\n\t\t\t\tbracket_count = bracket_count\
    \ + 1\n\t\t\telseif current_char == \")\" then\n\t\t\t\tbracket_count = bracket_count\
    \ - 1\n\t\t\tend\n\t\t\tif bracket_count == 0 then\n\t\t\t\ttable.insert(separated_groups,\
    \ string.sub(paren_string, i - num_chars, i))\n\t\t\t\ti = i + 1\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\t\ti = i + 1\n\t\t\tnum_chars = num_chars + 1\n\t\tend\n\tend\n\t\
    return separated_groups\nend", "    local paren_table = {}\n    local paren_counter\
    \ = 0\n    local start_pos = 0\n    local cur_pos = 0\n    while cur_pos < #paren_string\
    \ do\n        local cur_char = paren_string:sub(cur_pos, cur_pos)\n        if\
    \ cur_char == \"(\" then\n            paren_counter = paren_counter + 1\n    \
    \        if paren_counter == 1 then\n                start_pos = cur_pos\n   \
    \         end\n        elseif cur_char == \")\" then\n            paren_counter\
    \ = paren_counter - 1\n            if paren_counter == 0 then\n              \
    \  local paren_group = paren_string:sub(start_pos + 1, cur_pos - 1)\n        \
    \        table.insert(paren_table, paren_group)\n            end\n        end\n\
    \        cur_pos = cur_pos + 1\n    end\n    return paren_table\nend", "    --\
    \ In this case, we're not using regular expressions. Instead, we're using\n  \
    \  -- a state machine to process the input string. A state machine is a special\n\
    \    -- kind of program that can take inputs at different times and produce different\n\
    \    -- outputs in response. A big benefit of state machines is that they can\
    \ be simpler\n    -- to understand than other kinds of programs.\n    --\n   \
    \ -- If you want to know more about state machines, you can read this blog post\
    \ I wrote:\n    -- https://sebastiansylvan.com/post/state-machines/\n    --\n\
    \    -- In this case, our state machine has three possible states:\n    --   1.\
    \ Idle. In this state, we haven't seen an open paren. This is our initial state.\n\
    \    --   2. Mid-group. In this state, we've seen at least one open paren, but\
    \ not a close paren.\n    --   3. Post-group. In this state, we've seen at least\
    \ one open paren, and at least one close paren.\n    --\n    -- The possible transitions\
    \ are:\n    --   1. Idle -> Mid-group. This happens when we see an open paren.\n\
    \    --   2. Mid-group -> Post-group. This happens when we see a close paren.\n\
    \    --   3. Post-group -> Idle. This happens when we see an open paren, and then\
    \ another open paren.\n    --\n    -- In this state machine, we're going to keep\
    \ track of the current state of the machine,\n    -- and append the next character\
    \ to a list of characters that are the current group.\n    -- If a transition\
    \ happens, then we append the group to a list of all of the groups,\n    -- and\
    \ then clear the group.\n    --\n    -- The state machine will keep running until\
    \ we get to the end of the input string.", "  local res = {}\n  local paren_depth\
    \ = 0\n  local last_start = 1\n  local function add_res(i)\n    res[#res+1] =\
    \ paren_string:sub(last_start, i-1)\n    last_start = i+1\n  end\n  for i = 1,\
    \ #paren_string do\n    local c = paren_string:sub(i,i)\n    if c == '(' then\n\
    \      paren_depth = paren_depth + 1\n    elseif c == ')' then\n      paren_depth\
    \ = paren_depth - 1\n      if paren_depth == 0 then\n        add_res(i)\n    \
    \  end\n    end\n  end\n  return res\nend", "\t-- TODO: Return the list of separate\
    \ paren groups\n\treturn paren_string\nend", "    local groups = {}\n    local\
    \ cur_group = \"\"\n    local depth = 0\n    for i = 1, #paren_string do\n   \
    \     local char = paren_string:sub(i, i)\n        if char == \"(\" then\n   \
    \         depth = depth + 1\n            cur_group = cur_group .. char\n     \
    \   elseif char == \")\" then\n            depth = depth - 1\n            cur_group\
    \ = cur_group .. char\n            if depth == 0 then\n                table.insert(groups,\
    \ cur_group)\n                cur_group = \"\"\n            end\n        elseif\
    \ char ~= \" \" then\n            cur_group = cur_group .. char\n        end\n\
    \    end\n    return groups\nend", "\tlocal output_list = {}\n\tlocal paren_group\
    \ = \"\"\n\tlocal paren_level = 0\n\tlocal paren_started = false\n\tfor i = 1,\
    \ #paren_string do\n\t\tlocal char = paren_string:sub(i, i)\n\t\tif char == \"\
    (\" then\n\t\t\tif paren_level == 0 then\n\t\t\t\tparen_started = true\n\t\t\t\
    \tparen_level = paren_level + 1\n\t\t\telse\n\t\t\t\tparen_level = paren_level\
    \ + 1\n\t\t\tend\n\t\telseif char == \")\" then\n\t\t\tparen_level = paren_level\
    \ - 1\n\t\t\tif paren_level == 0 then\n\t\t\t\tparen_started = false\n\t\t\t\t\
    table.insert(output_list, paren_group)\n\t\t\t\tparen_group = \"\"\n\t\t\tend\n\
    \t\telseif char == \" \" then\n\t\t\t-- Ignore spaces\n\t\telse\n\t\t\tif paren_started\
    \ then\n\t\t\t\tparen_group = paren_group .. char\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn output_list\nend", "\tlocal matches = {}\n\tlocal i = 1\n\twhile i <=\
    \ string.len(paren_string) do\n\t\tlocal char = string.sub(paren_string, i, i)\n\
    \t\tif char == \"(\" then\n\t\t\tlocal str_start = i\n\t\t\tlocal paren_balance\
    \ = 1\n\t\t\twhile i <= string.len(paren_string) do\n\t\t\t\ti = i + 1\n\t\t\t\
    \tlocal next_char = string.sub(paren_string, i, i)\n\t\t\t\tif next_char == \"\
    (\" then\n\t\t\t\t\tparen_balance = paren_balance + 1\n\t\t\t\telseif next_char\
    \ == \")\" then\n\t\t\t\t\tparen_balance = paren_balance - 1\n\t\t\t\tend\n\t\t\
    \t\tif paren_balance == 0 then\n\t\t\t\t\ttable.insert(matches, string.sub(paren_string,\
    \ str_start, i))\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\ti = i\
    \ + 1\n\tend\n\treturn matches\nend", "    -- We'll start by removing all the\
    \ spaces in the string, since that's irrelevant for\n    -- what we're doing.\n\
    \    paren_string = string.gsub(paren_string, ' ', '')", "\tlocal counter = 0\n\
    \tlocal last_start = 0\n\tlocal out = {}\n\tfor i = 1, #paren_string do\n\t\t\
    local c = paren_string:sub(i, i)\n\t\tif c == \"(\" then\n\t\t\tif counter ==\
    \ 0 then\n\t\t\t\tlast_start = i\n\t\t\tend\n\t\t\tcounter = counter + 1\n\t\t\
    elseif c == \")\" then\n\t\t\tcounter = counter - 1\n\t\t\tif counter == 0 then\n\
    \t\t\t\tout[#out + 1] = paren_string:sub(last_start, i)\n\t\t\tend\n\t\tend\n\t\
    end\n\treturn out\nend", "\tlocal paren_group = 1\n\tlocal paren_group_list =\
    \ {}\n\tlocal in_group = false\n\tlocal paren_start\n\tlocal paren_end\n\tfor\
    \ i = 1, #paren_string do\n\t\tlocal c = paren_string:sub(i, i)\n\t\tif c == \"\
    (\" then\n\t\t\tif in_group then\n\t\t\t\tparen_group = paren_group + 1\n\t\t\t\
    else\n\t\t\t\tin_group = true\n\t\t\t\tparen_start = i\n\t\t\tend\n\t\telseif\
    \ c == \")\" then\n\t\t\tif paren_group == 1 then\n\t\t\t\tin_group = false\n\t\
    \t\t\tparen_end = i\n\t\t\t\tparen_group_list[#paren_group_list + 1] = paren_string:sub(paren_start,\
    \ paren_end)\n\t\t\telse\n\t\t\t\tparen_group = paren_group - 1\n\t\t\tend\n\t\
    \tend\n\tend\n\treturn paren_group_list\nend", "\tlocal in_group = false\n\tlocal\
    \ group_start = nil\n\tlocal result = {}\n\tfor i = 1, paren_string:len() do\n\
    \t\tlocal c = paren_string:sub(i, i)\n\t\tif in_group and c == ')' then\n\t\t\t\
    result[#result + 1] = paren_string:sub(group_start, i)\n\t\t\tin_group = false\n\
    \t\telseif c == '(' then\n\t\t\tin_group = true\n\t\t\tgroup_start = i\n\t\tend\n\
    \tend\n\tif in_group then\n\t\tresult[#result + 1] = paren_string:sub(group_start)\n\
    \tend\n\treturn result\nend", "    local result = {}\n    local current_group\
    \ = \"\"\n    local current_level = 0\n    for c in paren_string:gmatch(\".\"\
    ) do\n        if c == \"(\" then\n            current_level = current_level +\
    \ 1\n            current_group = current_group .. c\n        elseif c == \")\"\
    \ then\n            current_level = current_level - 1\n            current_group\
    \ = current_group .. c\n            if current_level == 0 then\n             \
    \   table.insert(result, current_group)\n                current_group = \"\"\n\
    \            end\n        elseif current_level > 0 then\n            current_group\
    \ = current_group .. c\n        end\n    end\n    return result\nend", '  local
    paren_groups = {}', "\tlocal group_count = 0\n\tlocal group_start = 0\n\tlocal\
    \ output = {}\n\tfor i = 1, #paren_string do\n\t\tlocal char = paren_string:sub(i,\
    \ i)\n\t\tif char == \"(\" then\n\t\t\tif group_count == 0 then\n\t\t\t\tgroup_start\
    \ = i\n\t\t\tend\n\t\t\tgroup_count = group_count + 1\n\t\telseif char == \")\"\
    \ then\n\t\t\tgroup_count = group_count - 1\n\t\t\tif group_count == 0 then\n\t\
    \t\t\ttable.insert(output, paren_string:sub(group_start, i))\n\t\t\tend\n\t\t\
    end\n\tend\n\treturn output\nend", "  local t = paren_string:gsub(\" \", \"\"\
    )\n  local counter = 0\n  local out = {}\n  local last_idx = 0\n  for i = 1, #t\
    \ do\n    if t:sub(i, i) == \"(\" then\n      counter = counter + 1\n    elseif\
    \ t:sub(i, i) == \")\" then\n      counter = counter - 1\n    end\n    if counter\
    \ == 0 then\n      table.insert(out, t:sub(last_idx + 1, i))\n      last_idx =\
    \ i\n    end\n  end\n  return out\nend", "  local str_start = 1\n  local paren_stack\
    \ = {}\n  local separated_groups = {}\n  local close_paren = {[\"}\"] = \"{\"\
    }\n  local open_paren = {\"{\", \"(\"}\n  local close_paren_list = {[\"}\"] =\
    \ true, [\")\"] = true}\n  for i = 1, #paren_string do\n    local char = paren_string:sub(i,\
    \ i)\n    if not (char == \" \") then\n      if in_list(open_paren, char) then\n\
    \        table.insert(paren_stack, char)\n      elseif in_list(close_paren_list,\
    \ char) then\n        if #paren_stack == 0 then\n          error(\"Error: Parens\
    \ are unbalanced: \" .. paren_string)\n        end\n        if close_paren[char]\
    \ ~= paren_stack[#paren_stack] then\n          error(\"Error: Parens are not properly\
    \ nested: \" .. paren_string)\n        end\n        table.remove(paren_stack)\n\
    \        if #paren_stack == 0 then\n          local substring = paren_string:sub(str_start,\
    \ i)\n          table.insert(separated_groups, substring)\n          str_start\
    \ = i + 1\n        end\n      end\n    end\n  end\n  if #paren_stack ~= 0 then\n\
    \    error(\"Error: Parens are unbalanced: \" .. paren_string)\n  end\n  return\
    \ separated_groups\nend", "  local result = {}\n  local i = 1\n  local cur_str\
    \ = \"\"\n  local depth = 0\n  while i <= #paren_string do\n    local char = paren_string:sub(i,\
    \ i)\n    if char == \"(\" then\n      if depth == 0 then\n        cur_str = \"\
    \"\n      end\n      depth = depth + 1\n    elseif char == \")\" then\n      depth\
    \ = depth - 1\n      if depth == 0 then\n        result[#result + 1] = cur_str\n\
    \      end\n    elseif char ~= \" \" then\n      cur_str = cur_str .. char\n \
    \   end\n    i = i + 1\n  end\n  return result\nend", "\tlocal balance = 0\n\t\
    local out = {}\n\tlocal piece = {}\n\tfor c in paren_string:gmatch('.') do\n\t\
    \tif c == ' ' then\n\t\t\t-- ignore\n\t\telseif c == '(' then\n\t\t\tbalance =\
    \ balance + 1\n\t\t\ttable.insert(piece, c)\n\t\telseif c == ')' then\n\t\t\t\
    balance = balance - 1\n\t\t\ttable.insert(piece, c)\n\t\t\tif balance == 0 then\n\
    \t\t\t\ttable.insert(out, table.concat(piece))\n\t\t\t\tpiece = {}\n\t\t\tend\n\
    \t\telse\n\t\t\ttable.insert(piece, c)\n\t\tend\n\tend\n\treturn out\nend", '  --
    Your code here', "\tlocal groups = {}\n\t-- YOUR CODE HERE\n\tlocal group = \"\
    \"\n\tlocal depth = 0\n\tfor c in paren_string:gmatch(\".\") do\n\t\tif c == \"\
    (\" then\n\t\t\tdepth = depth + 1\n\t\t\tgroup = group .. c\n\t\telseif c == \"\
    )\" then\n\t\t\tdepth = depth - 1\n\t\t\tgroup = group .. c\n\t\t\tif depth ==\
    \ 0 then\n\t\t\t\ttable.insert(groups, group)\n\t\t\t\tgroup = \"\"\n\t\t\tend\n\
    \t\telseif c ~= \" \" then\n\t\t\tgroup = group .. c\n\t\tend\n\tend\n\treturn\
    \ groups\nend", "\tlocal paren_groups = {}\n\tlocal count_open_parens = 0\n\t\
    local paren_group = {}\n\tlocal current_char\n\tfor i = 1, #paren_string do\n\t\
    \tcurrent_char = paren_string:sub(i, i)\n\t\tif current_char == \"(\" then\n\t\
    \t\tcount_open_parens = count_open_parens + 1\n\t\t\tif count_open_parens == 1\
    \ then\n\t\t\t\tparen_group = {}\n\t\t\tend\n\t\telseif current_char == \")\"\
    \ then\n\t\t\tcount_open_parens = count_open_parens - 1\n\t\t\tif count_open_parens\
    \ == 0 then\n\t\t\t\ttable.insert(paren_groups, table.concat(paren_group))\n\t\
    \t\tend\n\t\telseif count_open_parens > 0 then\n\t\t\ttable.insert(paren_group,\
    \ current_char)\n\t\tend\n\tend\n\treturn paren_groups\nend", "  local paren_groups\
    \ = {}\n  local group_start = 0\n  local group_length = 0\n  local paren_depth\
    \ = 0\n  local current_char = \"\"\n  for i = 1, #paren_string do\n    current_char\
    \ = paren_string:sub(i, i)\n    if current_char == \"(\" then\n      paren_depth\
    \ = paren_depth + 1\n      if paren_depth == 1 then\n        group_start = i\n\
    \      end\n    elseif current_char == \")\" then\n      paren_depth = paren_depth\
    \ - 1\n      if paren_depth == 0 then\n        group_length = i - group_start\
    \ + 1\n        table.insert(paren_groups, paren_string:sub(group_start, group_start\
    \ + group_length - 1))\n      end\n    end\n  end\n  return paren_groups\nend",
  "\tlocal paren_list = {}\n\tlocal paren_group = \"\"\n\tlocal open_parens = 0\n\t\
    for i = 1, #paren_string do\n\t\tlocal char = paren_string:sub(i, i)\n\t\tif char\
    \ == \"(\" then\n\t\t\topen_parens = open_parens + 1\n\t\t\tparen_group = paren_group\
    \ .. char\n\t\telseif char == \")\" then\n\t\t\topen_parens = open_parens - 1\n\
    \t\t\tparen_group = paren_group .. char\n\t\t\tif open_parens == 0 then\n\t\t\t\
    \ttable.insert(paren_list, paren_group)\n\t\t\t\tparen_group = \"\"\n\t\t\tend\n\
    \t\telseif char ~= \" \" then\n\t\t\tparen_group = paren_group .. char\n\t\tend\n\
    \tend\n\treturn paren_list\nend", "  local paren_string = paren_string:gsub(\"\
    %s\", \"\")\n  local paren_groups = {}\n  local paren_group = \"\"\n  local opening_brace\
    \ = 0\n  local closing_brace = 0\n  for char in paren_string:gmatch(\".\") do\n\
    \    if char == \"(\" then\n      opening_brace = opening_brace + 1\n    elseif\
    \ char == \")\" then\n      closing_brace = closing_brace + 1\n    end\n    paren_group\
    \ = paren_group .. char\n    if opening_brace == closing_brace then\n      paren_groups[#paren_groups\
    \ + 1] = paren_group\n      paren_group = \"\"\n      opening_brace = 0\n    \
    \  closing_brace = 0\n    end\n  end\n  return paren_groups\nend", "\tlocal groups\
    \ = {}\n\tlocal current_group = nil\n\tlocal opened = 0\n\tfor i = 1, #paren_string\
    \ do\n\t\tlocal c = paren_string:sub(i, i)\n\t\tif c == '(' then\n\t\t\tif opened\
    \ == 0 then\n\t\t\t\tcurrent_group = {}\n\t\t\tend\n\t\t\topened = opened + 1\n\
    \t\telseif c == ')' then\n\t\t\topened = opened - 1\n\t\t\tif opened == 0 then\n\
    \t\t\t\tgroups[#groups + 1] = table.concat(current_group)\n\t\t\t\tcurrent_group\
    \ = nil\n\t\t\tend\n\t\telseif c ~= ' ' then\n\t\t\tcurrent_group[#current_group\
    \ + 1] = c\n\t\tend\n\tend\n\treturn groups\nend", "  local paren_str_len = #paren_string\n\
    \  local paren_groups = {}", "\tlocal groups = {}\n\tlocal cur = 1\n\tlocal group\
    \ = 1\n\tlocal count = 0\n\twhile cur <= #paren_string do\n\t\tlocal c = paren_string:sub(cur,\
    \ cur)\n\t\tif c == \"(\" then\n\t\t\tcount = count + 1\n\t\telseif c == \")\"\
    \ then\n\t\t\tcount = count - 1\n\t\tend\n\t\tif count == 0 then\n\t\t\tgroups[group]\
    \ = paren_string:sub(1, cur)\n\t\t\tgroup = group + 1\n\t\t\tparen_string = paren_string:sub(cur\
    \ + 1)\n\t\t\tcur = 1\n\t\telse\n\t\t\tcur = cur + 1\n\t\tend\n\tend\n\treturn\
    \ groups\nend", "  local capture_group_table = {}\n  local current_group = \"\"\
    \n  local parentheses_depth = 0\n  local string_length = paren_string:len()\n\
    \  for i = 1, string_length do\n    local current_char = paren_string:sub(i, i)\n\
    \    if current_char == \"(\" then\n      parentheses_depth = parentheses_depth\
    \ + 1\n      current_group = current_group .. current_char\n    elseif current_char\
    \ == \")\" then\n      parentheses_depth = parentheses_depth - 1\n      current_group\
    \ = current_group .. current_char\n      if parentheses_depth == 0 then\n    \
    \    table.insert(capture_group_table, current_group)\n        current_group =\
    \ \"\"\n      end\n    elseif current_char ~= \" \" then\n      current_group\
    \ = current_group .. current_char\n    end\n  end\n  return capture_group_table\n\
    end", "    local result = {}\n    local current_group = \"\"\n    local bracket_stack\
    \ = {}\n    local add_current_group = function()\n        if #current_group >\
    \ 0 then\n            table.insert(result, current_group)\n            current_group\
    \ = \"\"\n        end\n    end\n    for current_char in paren_string:gmatch(\"\
    %S\") do\n        if current_char == \"(\" then\n            table.insert(bracket_stack,\
    \ \"(\")\n        elseif current_char == \")\" then\n            if #bracket_stack\
    \ == 0 then\n                add_current_group()\n            else\n         \
    \       table.remove(bracket_stack)\n                if #bracket_stack == 0 then\n\
    \                    add_current_group()\n                end\n            end\n\
    \        end\n        current_group = current_group .. current_char\n    end\n\
    \    add_current_group()\n    return result\nend", "    local result = {}\n  \
    \  local i = 1\n    local open_count = 0\n    local in_paren = false\n    local\
    \ current_result = \"\"\n    for c in paren_string:gmatch(\".\") do\n        if\
    \ c == \"(\" then\n            open_count = open_count + 1\n            in_paren\
    \ = true\n        elseif c == \")\" then\n            open_count = open_count\
    \ - 1\n            if open_count == 0 then\n                in_paren = false\n\
    \                table.insert(result, current_result)\n                current_result\
    \ = \"\"\n            end\n        elseif c ~= \" \" then\n            if in_paren\
    \ then\n                current_result = current_result .. c\n            end\n\
    \        end\n    end\n    return result\nend", "\t--[[\n\t\tExample:\n\t\tseparate_paren_groups(\"\
    foo(bar(baz))bar)\") -> {\"foo(bar(baz))\", \"bar)\"}\n\t\tseparate_paren_groups(\"\
    foo(bar(baz))\") -> {\"foo(bar(baz))\"}\n\t\tseparate_paren_groups(\"foo((bar))(baz)\"\
    ) -> {\"foo((bar))\", \"baz)\"}\n\t\tseparate_paren_groups(\"foo()bar()\") ->\
    \ {\"foo()\", \"bar()\"}\n\t\tseparate_paren_groups(\"foo((bar))(baz)\") -> {\"\
    foo((bar))\", \"baz)\"}\n\t\tseparate_paren_groups(\"(bar)\") -> {\"bar)\"}\n\t\
    \tseparate_paren_groups(\"(\") -> {\")\"}\n\t\tseparate_paren_groups(\"()\") ->\
    \ {\"()\"}\n\t\tseparate_paren_groups(\"(()()())\") -> {\"()()()\"}\n\t\tseparate_paren_groups(\"\
    \") -> {}\n\t]]--\n\tlocal groups = {}\n\tlocal open_parens = 0\n\tlocal cur_group\
    \ = \"\"\n\tlocal done = false\n\tlocal i = 1\n\twhile not done do\n\t\tlocal\
    \ char = paren_string:sub(i, i)\n\t\tif char == \"\" then\n\t\t\tdone = true\n\
    \t\telseif char == \"(\" then\n\t\t\topen_parens = open_parens + 1\n\t\t\tcur_group\
    \ = cur_group .. char\n\t\telseif char == \")\" then\n\t\t\topen_parens = open_parens\
    \ - 1\n\t\t\tcur_group = cur_group .. char\n\t\t\tif open_parens == 0 then\n\t\
    \t\t\ttable.insert(groups, cur_group)\n\t\t\t\tcur_group = \"\"\n\t\t\tend\n\t\
    \telseif char ~= \" \" then\n\t\t\tcur_group = cur_group .. char\n\t\tend\n\t\t\
    i = i + 1\n\tend\n\tif cur_group ~= \"\" then\n\t\ttable.insert(groups, cur_group)\n\
    \tend\n\treturn groups\nend", "  local result = {}\n  local depth = 0\n  local\
    \ start = 1\n  local len = string.len(paren_string)\n  for i = 1, len do\n   \
    \ local char = string.sub(paren_string, i, i)\n    if char == '(' then\n     \
    \ depth = depth + 1\n    elseif char == ')' then\n      depth = depth - 1\n  \
    \    if depth == 0 then\n        result[#result + 1] = string.sub(paren_string,\
    \ start, i)\n        start = i + 1\n      end\n    end\n  end\n  return result\n\
    end", "  local paren_groups = {}\n  local paren_group = \"\"\n  local paren_count\
    \ = 0\n  for c in paren_string:gmatch(\".\") do\n    if c == \"(\" then\n    \
    \  paren_count = paren_count + 1\n    elseif c == \")\" then\n      paren_count\
    \ = paren_count - 1\n    end\n    if paren_count == 0 then\n      table.insert(paren_groups,\
    \ paren_group)\n      paren_group = \"\"\n    else\n      paren_group = paren_group\
    \ .. c\n    end\n  end\n  return paren_groups\nend", "  local list = {}\n  local\
    \ current = {}\n  local level = 0\n  for c in paren_string:gmatch('.') do\n  \
    \  if c == '(' then\n      level = level + 1\n    elseif c == ')' then\n     \
    \ level = level - 1\n    end\n    if level == 0 then\n      table.insert(list,\
    \ table.concat(current))\n      current = {}\n    else\n      table.insert(current,\
    \ c)\n    end\n  end\n  return list\nend", "  local open_braces = 0\n  local result\
    \ = {}\n  local cur_pos = 1\n  for i = 1, #paren_string do\n    local char = paren_string:sub(i,\
    \ i)\n    if char == '(' then\n      open_braces = open_braces + 1\n    elseif\
    \ char == ')' then\n      open_braces = open_braces - 1\n      if open_braces\
    \ == 0 then\n        table.insert(result, paren_string:sub(cur_pos, i))\n    \
    \    cur_pos = i + 1\n      end\n    end\n  end\n  return result\nend", "\tlocal\
    \ paren_list = {}\n\tlocal curr_paren = ''\n\tlocal paren_count = 0\n\tfor curr_char\
    \ in paren_string:gmatch('.') do\n\t\tif curr_char == '(' then\n\t\t\tparen_count\
    \ = paren_count + 1\n\t\t\tcurr_paren = curr_paren .. curr_char\n\t\telseif curr_char\
    \ == ')' then\n\t\t\tparen_count = paren_count - 1\n\t\t\tcurr_paren = curr_paren\
    \ .. curr_char\n\t\t\tif paren_count == 0 then\n\t\t\t\ttable.insert(paren_list,\
    \ curr_paren)\n\t\t\t\tcurr_paren = ''\n\t\t\tend\n\t\telseif curr_char ~= ' '\
    \ then\n\t\t\tcurr_paren = curr_paren .. curr_char\n\t\tend\n\tend\n\treturn paren_list\n\
    end", "    local sep_parens = {}\n    local cur_paren = \"\"\n    local open_paren\
    \ = 0\n    for c in paren_string:gmatch(\".\") do\n        if c == \"(\" then\n\
    \            open_paren = open_paren + 1\n            cur_paren = cur_paren ..\
    \ c\n        elseif c == \")\" then\n            open_paren = open_paren - 1\n\
    \            cur_paren = cur_paren .. c\n            if open_paren == 0 then\n\
    \                table.insert(sep_parens, cur_paren)\n                cur_paren\
    \ = \"\"\n            end\n        elseif open_paren > 0 then\n            cur_paren\
    \ = cur_paren .. c\n        end\n    end\n    return sep_parens\nend", "    local\
    \ result = {}\n    local stack = {}\n    local prev = ''\n    local group = ''\n\
    \    for i = 1, #paren_string do\n        local curr = paren_string:sub(i, i)\n\
    \        if curr == '(' then\n            table.insert(stack, '(')\n        elseif\
    \ curr == ')' then\n            if prev == '(' then\n                table.insert(result,\
    \ '()')\n            else\n                table.remove(stack)\n             \
    \   if #stack == 0 then\n                    table.insert(result, group .. ')')\n\
    \                    group = ''\n                else\n                    group\
    \ = group .. ')'\n                end\n            end\n        elseif curr ~=\
    \ ' ' then\n            if #stack > 0 then\n                group = group .. curr\n\
    \            else\n                table.insert(result, curr)\n            end\n\
    \        end\n        prev = curr\n    end\n    return result\nend", "    -- Initialize\
    \ the list with the first group.\n    local groups = {paren_string:match('^%s*%b()')}\n\
    \    -- Start with the remainder of the string after the first group.\n    paren_string\
    \ = paren_string:sub(#groups[1]+1)\n    while paren_string and paren_string:match('%b()')\
    \ do\n        table.insert(groups, paren_string:match('^%s*%b()'))\n        paren_string\
    \ = paren_string:sub(#groups[#groups]+1)\n    end\n    return groups\nend", " \
    \ local parsed_string = \"\"\n  local state = \"closed\"\n  local groups = {}\n\
    \  local level = 0\n  local open_count = 0\n  local close_count = 0\n  for letter\
    \ in paren_string:gmatch(\".\") do\n    if letter == \"(\" then\n      state =\
    \ \"open\"\n      level = level + 1\n      open_count = open_count + 1\n    elseif\
    \ letter == \")\" then\n      close_count = close_count + 1\n      if level ==\
    \ 1 then\n        table.insert(groups, parsed_string)\n        parsed_string =\
    \ \"\"\n        state = \"closed\"\n      else\n        level = level - 1\n  \
    \    end\n    elseif state == \"open\" then\n      parsed_string = parsed_string\
    \ .. letter\n    end\n  end\n  if open_count ~= close_count then\n    warning(\"\
    Skipping ill-formed paren group: \" .. paren_string)\n    return {}\n  end\n \
    \ return groups\nend", "\tlocal groups = {}\n\tlocal last_index = 1\n\tfor i=1,\
    \ #paren_string do\n\t\tlocal c = paren_string:sub(i,i)\n\t\tif c == '(' then\n\
    \t\t\tlocal cur_index = i\n\t\t\tlocal level = 1\n\t\t\tfor j=i+1, #paren_string\
    \ do\n\t\t\t\tlocal d = paren_string:sub(j,j)\n\t\t\t\tif d == '(' then\n\t\t\t\
    \t\tlevel = level + 1\n\t\t\t\telseif d == ')' then\n\t\t\t\t\tlevel = level -\
    \ 1\n\t\t\t\t\tif level == 0 then\n\t\t\t\t\t\tgroups[#groups+1] = paren_string:sub(last_index,\
    \ j)\n\t\t\t\t\t\tlast_index = j+1\n\t\t\t\t\t\ti = j\n\t\t\t\t\t\tbreak\n\t\t\
    \t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn groups\nend", "  \
    \  local index = 1\n    local groups = {}\n    for match in paren_string:gmatch('()[%(%)]')\
    \ do\n        if paren_string:sub(match, match) == '(' then\n            index\
    \ = index + 1\n            groups[index] = paren_string:sub(match, match)\n  \
    \      else\n            groups[index] = groups[index] .. paren_string:sub(match,\
    \ match)\n            index = index - 1\n        end\n    end\n    return groups\n\
    end", "\tlocal start = paren_string:find(\"%b()\")\n\tlocal results = {}\n\twhile\
    \ start do\n\t\tlocal finish = start + 1\n\t\tlocal done = false\n\t\tlocal open\
    \ = 1\n\t\twhile not done do\n\t\t\tlocal next_open = paren_string:find(\"%(\"\
    , finish)\n\t\t\tlocal next_close = paren_string:find(\"%)\", finish)\n\t\t\t\
    if next_open and next_close then\n\t\t\t\tif next_open < next_close then\n\t\t\
    \t\t\topen = open + 1\n\t\t\t\t\tfinish = next_open + 1\n\t\t\t\telse\n\t\t\t\t\
    \topen = open - 1\n\t\t\t\t\tfinish = next_close + 1\n\t\t\t\t\tif open == 0 then\n\
    \t\t\t\t\t\tdone = true\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telseif next_open then\n\
    \t\t\t\topen = open + 1\n\t\t\t\tfinish = next_open + 1\n\t\t\telseif next_close\
    \ then\n\t\t\t\topen = open - 1\n\t\t\t\tfinish = next_close + 1\n\t\t\t\tif open\
    \ == 0 then\n\t\t\t\t\tdone = true\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tdone = true\n\
    \t\t\tend\n\t\tend\n\t\tresults[#results + 1] = paren_string:sub(start, finish\
    \ - 1)\n\t\tstart = paren_string:find(\"%b()\", finish)\n\tend\n\treturn results\n\
    end", "  local list = {}\n  local index = 1\n  local open_parens = {}\n  local\
    \ group_start = 1\n  local current_group = \"\"\n  for i = 1, string.len(paren_string)\
    \ do\n    local char = string.sub(paren_string, i, i)\n    if char == \"(\" then\n\
    \      open_parens[index] = char\n      index = index + 1\n    elseif char ==\
    \ \")\" then\n      if index > 1 then\n        table.remove(open_parens, index\
    \ - 1)\n        index = index - 1\n      end\n      if #open_parens == 0 then\n\
    \        current_group = string.sub(paren_string, group_start, i)\n        table.insert(list,\
    \ current_group)\n        group_start = i + 1\n      end\n    end\n  end\n  return\
    \ list\nend", "    local paren_list = {}\n    local current_paren_string = ''\n\
    \    local current_paren_count = 0\n    for char in paren_string:gmatch('.') do\n\
    \        if char == '(' then\n            current_paren_count = current_paren_count\
    \ + 1\n            current_paren_string = current_paren_string .. char\n     \
    \   elseif char == ')' then\n            current_paren_count = current_paren_count\
    \ - 1\n            current_paren_string = current_paren_string .. char\n     \
    \       if current_paren_count == 0 then\n                table.insert(paren_list,\
    \ current_paren_string)\n                current_paren_string = ''\n         \
    \   end\n        elseif current_paren_count > 0 then\n            current_paren_string\
    \ = current_paren_string .. char\n        end\n    end\n    return paren_list\n\
    end", "    local result = {}\n    local buffer = \"\"\n    local depth = 0\n \
    \   for i = 1, #paren_string do\n        local char = paren_string:sub(i, i)\n\
    \        if char == \"(\" then\n            depth = depth + 1\n        elseif\
    \ char == \")\" then\n            depth = depth - 1\n        end\n        if depth\
    \ == 0 and char == \")\" then\n            table.insert(result, buffer)\n    \
    \        buffer = \"\"\n        else\n            buffer = buffer .. char\n  \
    \      end\n    end\n    return result\nend", "\t-- Write your code here\n\t--\
    \ Hint: iterate through the string (use string.len() and string.sub()) and use\
    \ counters to separate\n\t-- the groups\nend", "\tlocal res = {}\n\tlocal start\
    \ = 1\n\tfor i = 1, #paren_string do\n\t\tlocal c = paren_string:sub(i, i)\n\t\
    \tif c == '(' then\n\t\t\tlocal count = 1\n\t\t\tfor j = i + 1, #paren_string\
    \ do\n\t\t\t\tc = paren_string:sub(j, j)\n\t\t\t\tif c == '(' then\n\t\t\t\t\t\
    count = count + 1\n\t\t\t\telseif c == ')' then\n\t\t\t\t\tcount = count - 1\n\
    \t\t\t\t\tif count == 0 then\n\t\t\t\t\t\tres[#res + 1] = paren_string:sub(start,\
    \ j)\n\t\t\t\t\t\tstart = j + 1\n\t\t\t\t\t\tbreak\n\t\t\t\t\tend\n\t\t\t\tend\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn res\nend", "\tlocal paren_list = {}\n\tlocal\
    \ paren_level = 0\n\tlocal paren_table = {}\n\t\n\t-- loop through all characters\n\
    \tfor i = 1, #paren_string do\n\t\tlocal paren_char = paren_string:sub(i, i)\n\
    \t\t\n\t\t-- if we are within a group\n\t\tif paren_level > 0 then\n\t\t\t-- if\
    \ we are at the end of the group\n\t\t\tif paren_char == \")\" then\n\t\t\t\t\
    -- reduce the level\n\t\t\t\tparen_level = paren_level - 1\n\t\t\t\t\n\t\t\t\t\
    -- if we are now out of the group\n\t\t\t\tif paren_level == 0 then\n\t\t\t\t\t\
    -- insert a list of the parens into the table\n\t\t\t\t\ttable.insert(paren_list,\
    \ table.concat(paren_table))\n\t\t\t\t\t\n\t\t\t\t\t-- reset the table\n\t\t\t\
    \t\tparen_table = {}\n\t\t\t\tend\n\t\t\telse\n\t\t\t\t-- if we are still within\
    \ the group, insert the character into the table\n\t\t\t\ttable.insert(paren_table,\
    \ paren_char)\n\t\t\tend\n\t\telse\n\t\t\t-- if we are not within a group, start\
    \ a new group whenever we see an open paren\n\t\t\tif paren_char == \"(\" then\n\
    \t\t\t\tparen_level = paren_level + 1\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn\
    \ paren_list\nend", "\tlocal groups = {}\n\tlocal pos = 1\n\tlocal balance = 0\n\
    \tfor i = 1, string.len(paren_string) do\n\t\tlocal c = string.sub(paren_string,\
    \ i, i)\n\t\tif c == \"(\" then\n\t\t\tbalance = balance + 1\n\t\telseif c ==\
    \ \")\" then\n\t\t\tbalance = balance - 1\n\t\tend\n\t\tif balance == 0 then\n\
    \t\t\ttable.insert(groups, string.sub(paren_string, pos, i))\n\t\t\tpos = i +\
    \ 1\n\t\tend\n\tend\n\treturn groups\nend", "    local tbl = {}\n    local str\
    \ = paren_string:gsub(\"%s\", \"\")\n    local i = 1\n    local s = 0\n    local\
    \ e = 0\n    while i <= #str do\n        if str:sub(i, i) == \"(\" then\n    \
    \        s = i\n            i = i + 1\n            local bracket_open = 1\n  \
    \          while i <= #str do\n                if str:sub(i, i) == \"(\" then\n\
    \                    bracket_open = bracket_open + 1\n                elseif str:sub(i,\
    \ i) == \")\" then\n                    bracket_open = bracket_open - 1\n    \
    \            end\n                if bracket_open == 0 then\n                \
    \    e = i\n                    tbl[#tbl + 1] = str:sub(s, e)\n              \
    \      break\n                end\n                i = i + 1\n            end\n\
    \        end\n        i = i + 1\n    end\n    return tbl\nend", "  if paren_string\
    \ == nil then\n    return {}\n  end\n  local paren_string = string.gsub(paren_string,\
    \ \"%s\", \"\")\n  local pos = 1\n  local res = {}\n  while true do\n    local\
    \ s, e = string.find(paren_string, \"%b()\", pos)\n    if s == nil then\n    \
    \  break\n    end\n    res[#res + 1] = string.sub(paren_string, s, e)\n    pos\
    \ = e + 1\n  end\n  return res\nend", "  -- Your code here\nend", "    local groups\
    \ = {}\n    local group = \"\"\n    local indent = 0\n    for i=1,#paren_string\
    \ do\n        local c = paren_string:sub(i,i)\n        if c == \"(\" then\n  \
    \          indent = indent + 1\n            group = group .. c\n        elseif\
    \ c == \")\" then\n            indent = indent - 1\n            group = group\
    \ .. c\n            if indent == 0 then\n                table.insert(groups,\
    \ group)\n                group = \"\"\n            end\n        elseif c ~= \"\
    \ \" then\n            group = group .. c\n        end\n    end\n    return groups\n\
    end", "  local seps = {}\n  local max_level = 0\n  local level = 0\n  local s\
    \ = \"\"\n  for i = 1, string.len(paren_string) do\n    local c = string.sub(paren_string,\
    \ i, i)\n    if c == \"(\" then\n      level = level + 1\n      if level > max_level\
    \ then\n        max_level = level\n      end\n      s = s .. c\n    elseif c ==\
    \ \")\" then\n      level = level - 1\n      s = s .. c\n      if level == 0 then\n\
    \        table.insert(seps, s)\n        s = \"\"\n      end\n    elseif c ~= \"\
    \ \" then\n      s = s .. c\n    end\n  end\n  return seps\nend", "\tlocal groups\
    \ = {}\n\tlocal current_group = \"\"\n\tlocal level = 0\n\tfor character in paren_string:gmatch\"\
    .\" do\n\t\tif character == \"(\" then\n\t\t\tlevel = level + 1\n\t\t\tif level\
    \ == 1 then\n\t\t\t\tcurrent_group = \"\"\n\t\t\telse\n\t\t\t\tcurrent_group =\
    \ current_group .. character\n\t\t\tend\n\t\telseif character == \")\" then\n\t\
    \t\tlevel = level - 1\n\t\t\tif level == 0 then\n\t\t\t\ttable.insert(groups,\
    \ current_group)\n\t\t\telse\n\t\t\t\tcurrent_group = current_group .. character\n\
    \t\t\tend\n\t\telseif level == 0 then\n\t\t\t-- Ignore any spaces outside of the\
    \ parens.\n\t\t\tif character ~= \" \" then\n\t\t\t\terror(\"Unexpected character\
    \ `\" .. character .. \"` outside of parens.\")\n\t\t\tend\n\t\telse\n\t\t\tcurrent_group\
    \ = current_group .. character\n\t\tend\n\tend\n\treturn groups\nend", "    local\
    \ result = {}\n    local current_group = \"\"\n    local depth = 0\n    for idx\
    \ = 1, #paren_string do\n        local ch = paren_string:sub(idx, idx)\n     \
    \   if ch == \"(\" then\n            depth = depth + 1\n            current_group\
    \ = current_group .. ch\n        elseif ch == \")\" then\n            current_group\
    \ = current_group .. ch\n            depth = depth - 1\n            if depth ==\
    \ 0 then\n                table.insert(result, current_group)\n              \
    \  current_group = \"\"\n            end\n        elseif depth > 0 then\n    \
    \        current_group = current_group .. ch\n        end\n    end\n    return\
    \ result\nend", "\tlocal results = {}\n\tlocal temp = \"\"\n\tlocal count = 0\n\
    \tfor i = 1, string.len(paren_string) do\n\t\tlocal c = string.sub(paren_string,\
    \ i, i)\n\t\tif c == \"(\" then\n\t\t\tcount = count + 1\n\t\telseif c == \")\"\
    \ then\n\t\t\tcount = count - 1\n\t\tend\n\t\tif count == 0 and string.len(temp)\
    \ > 0 then\n\t\t\ttable.insert(results, temp)\n\t\t\ttemp = \"\"\n\t\telse\n\t\
    \t\ttemp = temp .. c\n\t\tend\n\tend\n\tif string.len(temp) > 0 then\n\t\ttable.insert(results,\
    \ temp)\n\tend\n\treturn results\nend", "\tparen_string = paren_string:gsub(\"\
    \ \", \"\")\n\tlocal groups = {}\n\tlocal current_group = \"\"\n\tlocal open_braces\
    \ = 0\n\tlocal next_char = \"\"\n\tfor i = 1, #paren_string do\n\t\tnext_char\
    \ = paren_string:sub(i, i)\n\t\tif next_char == \"(\" then\n\t\t\topen_braces\
    \ = open_braces + 1\n\t\telseif next_char == \")\" then\n\t\t\topen_braces = open_braces\
    \ - 1\n\t\tend\n\t\tcurrent_group = current_group .. next_char\n\t\tif open_braces\
    \ == 0 then\n\t\t\tgroups[#groups + 1] = current_group\n\t\t\tcurrent_group =\
    \ \"\"\n\t\tend\n\tend\n\treturn groups\nend", "  local result = {}\n  local open\
    \ = 0\n  local cur = ''\n  for c in paren_string:gmatch(\".\") do\n    if c ==\
    \ '(' then\n      open = open + 1\n    elseif c == ')' then\n      open = open\
    \ - 1\n    end\n    if c == '(' or c == ')' then\n      if open == 0 then\n  \
    \      table.insert(result, cur)\n        cur = ''\n      else\n        cur =\
    \ cur .. c\n      end\n    end\n  end\n  table.insert(result, cur)\n  return result\n\
    end", "\tlocal g = {};\n\tlocal gidx = 1;\n\tlocal pcount = 0;\n\tlocal paren_groups\
    \ = {};\n\tlocal pgidx = 1;\n\tlocal cidx = 1;\n\tlocal instr = false;\n\twhile\
    \ cidx <= #paren_string do\n\t\tlocal ch = paren_string:sub(cidx, cidx);\n\t\t\
    if ch == \"(\" then\n\t\t\tif pcount == 0 then\n\t\t\t\tg[gidx] = \"\";\n\t\t\t\
    end\n\t\t\tpcount = pcount + 1;\n\t\t\tg[gidx] = g[gidx] .. ch;\n\t\telseif ch\
    \ == \")\" then\n\t\t\tpcount = pcount - 1;\n\t\t\tg[gidx] = g[gidx] .. ch;\n\t\
    \t\tif pcount == 0 then\n\t\t\t\tgidx = gidx + 1;\n\t\t\tend\n\t\telseif ch ==\
    \ \"\\\"\" then\n\t\t\tg[gidx] = g[gidx] .. ch;\n\t\t\tinstr = not instr;\n\t\t\
    elseif pcount == 0 and ch == \" \" and instr == false then\n\t\t\tif g[gidx] ~=\
    \ \"\" then\n\t\t\t\tgidx = gidx + 1;\n\t\t\tend\n\t\t\tg[gidx] = \"\";\n\t\t\
    else\n\t\t\tg[gidx] = g[gidx] .. ch;\n\t\tend\n\t\tcidx = cidx + 1;\n\tend\n\t\
    for _, g2 in ipairs(g) do\n\t\tif g2 ~= \"\" then\n\t\t\tparen_groups[pgidx] =\
    \ g2;\n\t\t\tpgidx = pgidx + 1;\n\t\tend\n\tend\n\treturn paren_groups;\nend",
  "    if paren_string == nil then\n        return\n    end", "\tlocal groups = {}\n\
    \t\n\tlocal group_begin = 1\n\tlocal group_end = 1\n\tlocal open_paren_count =\
    \ 0\n\tlocal paren_string_length = string.len(paren_string)\n\t\n\tfor i = 1,\
    \ paren_string_length do\n\t\tlocal char = string.sub(paren_string, i, i)\n\t\t\
    if char == \"(\" then\n\t\t\topen_paren_count = open_paren_count + 1\n\t\t\tgroup_end\
    \ = i\n\t\telseif char == \")\" then\n\t\t\topen_paren_count = open_paren_count\
    \ - 1\n\t\t\tif open_paren_count == 0 then\n\t\t\t\tlocal group = string.sub(paren_string,\
    \ group_begin, group_end)\n\t\t\t\ttable.insert(groups, group)\n\t\t\t\tgroup_begin\
    \ = i + 1\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn groups\nend", "\tlocal paren_string\
    \ = paren_string:gsub(\" \", \"\")\n\tlocal paren_stack = {}\n\tlocal groups =\
    \ {}\n\tlocal group_start_index = 1\n\tlocal group_end_index = 1\n\tfor i = 1,\
    \ #paren_string do\n\t\tlocal current_char = paren_string:sub(i, i)\n\t\tif current_char\
    \ == \"(\" then\n\t\t\ttable.insert(paren_stack, \"(\")\n\t\telseif current_char\
    \ == \")\" then\n\t\t\ttable.remove(paren_stack)\n\t\t\tif #paren_stack == 0 then\n\
    \t\t\t\tgroup_end_index = i\n\t\t\t\ttable.insert(groups, paren_string:sub(group_start_index,\
    \ group_end_index))\n\t\t\t\tgroup_start_index = i + 1\n\t\t\tend\n\t\tend\n\t\
    end\n\treturn groups\nend", "    -- This function will be implemented in one of\
    \ the future tasks. Do not try to implement it right now.\n    -- It has nothing\
    \ to do with coroutines.\n    error(\"Not implemented yet\")\nend", "  local out\
    \ = {}\n  for m in paren_string:gmatch(\"()%b()\") do\n    table.insert(out, paren_string:sub(m,\
    \ m:match(\"()%b()\")))\n  end\n  return out\nend", "  local ret = {}\n  local\
    \ current_group = {}\n  local balance = 0\n  for c in paren_string:gmatch('[^%s]')\
    \ do\n    if c == '(' then\n      balance = balance + 1\n    elseif c == ')' then\n\
    \      balance = balance - 1\n    end\n    table.insert(current_group, c)\n  \
    \  if balance == 0 then\n      local group_string = table.concat(current_group)\n\
    \      table.insert(ret, group_string)\n      current_group = {}\n    end\n  end\n\
    \  return ret\nend", "    -- First, remove any spaces from the input string\n\
    \    paren_string = string.gsub(paren_string, \" \", \"\")", "    local paren_groups\
    \ = {}\n    local i = 1\n    while i <= string.len(paren_string) do\n        local\
    \ c = string.sub(paren_string, i, i)\n        if c == \"(\" then\n           \
    \ local group = \"\"\n            local count = 1\n            i = i + 1\n   \
    \         while i <= string.len(paren_string) do\n                c = string.sub(paren_string,\
    \ i, i)\n                if c == \"(\" then\n                    count = count\
    \ + 1\n                elseif c == \")\" then\n                    count = count\
    \ - 1\n                end\n                group = group .. c\n             \
    \   i = i + 1\n                if count == 0 then\n                    break\n\
    \                end\n            end\n            paren_groups[#paren_groups\
    \ + 1] = group\n        else\n            i = i + 1\n        end\n    end\n  \
    \  return paren_groups\nend", "    --[[\n    Returns a list of individual groups\
    \ of parens in a string.\n    Input and output strings do not include surrounding\
    \ parens.\n    Example:\n        separate_paren_groups(\"(abc(def(ghi)))\") -->\
    \ {\"abc(def(ghi))\"}\n        separate_paren_groups(\"((ab)c)(de)(fg)\") -->\
    \ {\"ab\", \"c\", \"de\", \"fg\"}\n    ]]\n    local paren_list = {}\n    local\
    \ paren_string = paren_string:gsub(\"%s\", \"\")\n    for inner_parens in paren_string:gmatch(\"\
    %b()\") do\n        local _, paren_count = inner_parens:gsub(\"%(\", \"\")\n \
    \       if paren_count == 0 then\n            table.insert(paren_list, inner_parens:sub(2,\
    \ -2))\n        else\n            local k = 1\n            local l = 0\n     \
    \       local n = #inner_parens\n            while l >= 0 and k <= n do\n    \
    \            local c = inner_parens:sub(k, k)\n                if c == \"(\" then\n\
    \                    l = l + 1\n                elseif c == \")\" then\n     \
    \               l = l - 1\n                end\n                k = k + 1\n  \
    \          end\n            table.insert(paren_list, inner_parens:sub(2, k - 2))\n\
    \        end\n    end\n    return paren_list\nend", "    local groups = {}\n \
    \   local current_group = \"\"\n    local group_open = false\n    for char in\
    \ paren_string:gmatch(\".\") do\n        if char == \"(\" then\n            if\
    \ group_open then\n                current_group = current_group .. char\n   \
    \         else\n                current_group = char\n                group_open\
    \ = true\n            end\n        elseif char == \")\" then\n            if group_open\
    \ then\n                current_group = current_group .. char\n              \
    \  table.insert(groups, current_group)\n                current_group = \"\"\n\
    \                group_open = false\n            end\n        elseif group_open\
    \ then\n            current_group = current_group .. char\n        end\n    end\n\
    \    return groups\nend", "\t-- Create the table that will be returned\n\tlocal\
    \ return_string_list = {}\n\t-- Set up our stack that will be used to keep track\
    \ of what we're currently in the middle of\n\tlocal stack = Stack()\n\t-- Create\
    \ a temporary string that we'll use to accumulate each group\n\tlocal temp_string\
    \ = \"\"\n\t-- Then loop through each character in the input string\n\tfor c in\
    \ paren_string:gmatch(\".\") do\n\t\t-- If we see an open brace, push that onto\
    \ the stack\n\t\tif c == \"(\" then\n\t\t\tstack:push(c)\n\t\t-- If we see a close\
    \ brace and the stack is not empty, pop it off\n\t\telseif c == \")\" and not\
    \ stack:is_empty() then\n\t\t\tstack:pop()\n\t\t-- If we see any other character,\
    \ add it to the temporary string\n\t\telseif c ~= \" \" then\n\t\t\ttemp_string\
    \ = temp_string .. c\n\t\tend\n\t\t-- If the stack is empty, we've completed a\
    \ group, so add it to the list to be returned and reset the temporary string\n\
    \t\tif stack:is_empty() then\n\t\t\ttable.insert(return_string_list, temp_string)\n\
    \t\t\ttemp_string = \"\"\n\t\tend\n\tend\n\t-- If there are any remaining characters\
    \ in the temporary string, this means that the input string wasn't properly balanced\n\
    \tif temp_string ~= \"\" then\n\t\tprint(\"Error: string not properly balanced\"\
    )\n\tend\n\t-- Finally, return the list of completed groups\n\treturn return_string_list\n\
    end", "  -- TODO: implement this function\n  --[[local paren_stack = Stack:create()\n\
    \  local paren_string_list = {}\n  local buf = \"\"\n  for index = 1, string.len(paren_string)\
    \ do\n    local c = string.sub(paren_string, index, index)\n    if (c == \"(\"\
    ) then\n      paren_stack:push(c)\n    elseif (c == \")\") then\n      paren_stack:pop()\n\
    \    end\n    if (paren_stack:isEmpty()) then\n      paren_string_list[#paren_string_list\
    \ + 1] = buf\n      buf = \"\"\n    else\n      buf = buf .. c\n    end\n  end\n\
    \  return paren_string_list]]\n  return my_split(paren_string, \"()\")\nend",
  "\tlocal len = paren_string:len()\n\tlocal groups = {}\n\tlocal last_char = paren_string:sub(len,\
    \ len)\n\tif last_char ~= \")\" then\n\t\tparen_string = paren_string .. \")\"\
    \n\tend\n\tlocal idx = 0\n\tfor open_idx, close_idx in paren_string:gmatch(\"\
    ()%(()\") do\n\t\tgroups[idx] = paren_string:sub(open_idx + 1, close_idx - 1)\n\
    \t\tidx = idx + 1\n\tend\n\treturn groups\nend", "\tlocal paren_groups = {}\n\t\
    local current_group = \"\"\n\tlocal opened = 0\n\tfor c in paren_string:gmatch(\"\
    .\") do\n\t\tif c == \"(\" then\n\t\t\tif opened == 0 then\n\t\t\t\tcurrent_group\
    \ = \"\"\n\t\t\tend\n\t\t\topened = opened + 1\n\t\t\tcurrent_group = current_group\
    \ .. c\n\t\telseif c == \")\" then\n\t\t\topened = opened - 1\n\t\t\tcurrent_group\
    \ = current_group .. c\n\t\t\tif opened == 0 then\n\t\t\t\ttable.insert(paren_groups,\
    \ current_group)\n\t\t\tend\n\t\telseif opened > 0 then\n\t\t\tcurrent_group =\
    \ current_group .. c\n\t\tend\n\tend\n\treturn paren_groups\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
