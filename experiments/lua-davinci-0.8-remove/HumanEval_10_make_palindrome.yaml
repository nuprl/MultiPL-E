name: HumanEval_10_make_palindrome
language: lua
prompt: "-- Find the shortest palindrome that begins with a supplied string.\n-- Algorithm\
  \ idea is simple:\n-- - Find the longest postfix of supplied string that is a palindrome.\n\
  -- - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\nlocal function make_palindrome(string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
  \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
  \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
  \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tif is_palindrome(string) then\n\t\treturn string\n\tend\n\tlocal\
    \ len = #string\n\tlocal cut = 0\n\tfor i = math.floor(len / 2), 1, -1 do\n\t\t\
    if string:sub(i, len) == string:sub(len - i + 1, len):reverse() then\n\t\t\tcut\
    \ = i\n\t\t\tbreak\n\t\tend\n\tend\n\treturn string .. string:sub(1, cut - 1):reverse()\n\
    end", "    -- Find the longest palindromic suffix.\n    local end_at = #string\n\
    \    while end_at > 0 do\n        local string_from = 1\n        local string_to\
    \ = end_at\n        local is_palindrome = true\n        while string_from < string_to\
    \ do\n            if string:sub(string_from, string_from) ~= string:sub(string_to,\
    \ string_to) then\n                is_palindrome = false\n                break\n\
    \            end\n            string_from = string_from + 1\n            string_to\
    \ = string_to - 1\n        end\n        if is_palindrome then\n            break\n\
    \        end\n        end_at = end_at - 1\n    end\n    -- Append reverse of the\
    \ remaining string before the palindromic suffix to the end of the string.\n \
    \   if end_at > 0 then\n        local prefix = string:sub(1, end_at)\n       \
    \ local reverse_prefix = prefix:reverse()\n        return string .. reverse_prefix\n\
    \    end\n    return string\nend", "    local reversed = string:reverse()\n  \
    \  local i = string:find(reversed, 1, true)\n    return string .. reversed:sub(1,\
    \ #string - i)\nend", "    -- Find the longest postfix palindrome of the supplied\
    \ string.\n    local postfix_len = 0\n    local n = #string\n    for i = 1, n\
    \ do\n        if is_palindrome(string, n - i + 1, n) then\n            postfix_len\
    \ = i\n            break\n        end\n    end", "\tlocal longest_palindrome =\
    \ find_longest_palindrome(string)\n\tlocal prefix = string:sub(1, string:len()\
    \ - longest_palindrome:len())\n\tlocal reversed_prefix = prefix:reverse()\n\t\
    return longest_palindrome .. reversed_prefix\nend", "\tassert(type(string) ==\
    \ \"string\")\n\tlocal revstring = string:reverse()\n\tlocal pal = string .. revstring:sub(#string\
    \ + 2)\n\treturn pal\nend", "    -- helper function for return value of string:find\n\
    \    local function f(match)\n        return match + 1\n    end", "  local reversed\
    \ = string.reverse(string)\n  local concat = string .. \"$\" .. reversed\n  local\
    \ kmp = KnuthMorrisPratt.new(concat)\n  local _, s, e = kmp:find(string)\n  return\
    \ string.sub(string, 1, s-1) .. reversed\nend", "    local string_rev = string:reverse()\n\
    \    local suffix_len = longest_common_prefix(string .. \"$\" .. string_rev)\n\
    \    return string .. string_rev:sub(suffix_len + 1)\nend", "    local prefix_len\
    \ = #string\n    while prefix_len > 0 do\n        local prefix = string:sub(1,\
    \ prefix_len)\n        local postfix = string:sub(prefix_len + 1)\n        if\
    \ is_palindrome(prefix) then\n            return string .. string:sub(1, prefix_len):reverse()\n\
    \        end\n        prefix_len = prefix_len - 1\n    end\n    return string\n\
    end", "    local longest_palindrome = table.concat(longest_palindrome_suffix(string))\n\
    \    local prefix = string.sub(string, 1, string.len(string) - string.len(longest_palindrome))\n\
    \    return string.format(\"%s%s%s\", string, string.reverse(prefix), longest_palindrome)\n\
    end", "  local length = #string\n  local i = 1\n  local j = length\n  local suffix_length\
    \ = 0\n  local suffix_start = 0\n  local middle = math.floor(length / 2)\n  local\
    \ left = middle\n  local right = middle + 1\n  if length % 2 == 0 then\n    left\
    \ = left - 1\n  end\n  while true do\n    if left < 0 then\n      break\n    end\n\
    \    if right > length then\n      break\n    end\n    if string:sub(left + 1,\
    \ left + 1) ~= string:sub(right, right) then\n      left = middle\n      right\
    \ = middle + 1\n      if length % 2 == 0 then\n        left = left - 1\n     \
    \ end\n      break\n    end\n    left = left - 1\n    right = right + 1\n  end\n\
    \  local prefix_start = left + 1\n  local prefix_length = length - prefix_start\n\
    \  local suffix_start = 1\n  local suffix_length = left + 1\n  local palindrome\
    \ = string .. string:sub(suffix_start, suffix_start + prefix_length - 1):reverse()\n\
    \  return palindrome\nend", "  assert(type(string) == \"string\")\n  -- Find the\
    \ longest palindromic suffix of supplied string.\n  local palindrome_suffix =\
    \ palindrome_suffix(string)\n  -- Append reverse of the prefix before the palindromic\
    \ suffix.\n  return string .. reverse(string, #palindrome_suffix + 1)\nend", " \
    \   local prefix_len = 0\n    local suffix_len = 0\n    local prefix = \"\"\n\
    \    local suffix = \"\"\n    local i = 1\n    while i <= math.floor(#string /\
    \ 2) do\n        if string:sub(i, i) == string:sub(#string - i + 1, #string -\
    \ i + 1) then\n            suffix_len = suffix_len + 1\n            suffix = string:sub(i,\
    \ i) .. suffix\n        else\n            break\n        end\n        i = i +\
    \ 1\n    end\n    i = 1\n    while i <= math.floor(#string / 2) do\n        if\
    \ string:sub(i, i) == string:sub(#string - i + 1, #string - i + 1) then\n    \
    \        prefix_len = prefix_len + 1\n            prefix = prefix .. string:sub(i,\
    \ i)\n        else\n            break\n        end\n        i = i + 1\n    end\n\
    \    return string .. string:sub(prefix_len + 1, #string - suffix_len):reverse()\n\
    end", "  local reversed_string = string:reverse()\n  local new_postfix = reversed_string:sub(#string\
    \ + 1, #string + reversed_string:find(string, 1, true))\n  return reversed_string\
    \ .. new_postfix\nend", "    -- If a string is a palindrome, return it.\n    if\
    \ is_palindrome(string) then\n        return string\n    end", "  local pre_index,\
    \ suf_index = 1, #string\n  local suf_palindrome_length = palindrome_lengths(string)[suf_index]\n\
    \  if suf_palindrome_length == suf_index then return string end\n  local pre_end\
    \ = suf_index - suf_palindrome_length\n  local prefix = string:sub(1, pre_end)\n\
    \  return string .. prefix:reverse()\nend", "  local function reverse(str)\n \
    \   local reversed = {}\n    for i = #str, 1, -1 do\n      reversed[#reversed\
    \ + 1] = str:sub(i, i)\n    end\n    return table.concat(reversed)\n  end", " \
    \ local tail = string\n  for i = string.len(string), 1, -1 do\n    local is_palindrome\
    \ = true\n    for j = 1, i do\n      if string.sub(string, j, j) ~= string.sub(string,\
    \ -i + j, -i + j) then\n        is_palindrome = false\n        break\n      end\n\
    \    end\n    if is_palindrome then\n      tail = string.sub(string, -i)\n   \
    \   break\n    end\n  end\n  return string.reverse(string.sub(string, 1, -(string.len(tail)\
    \ + 1))) .. string\nend", "    -- Find the longest palindromic suffix\n    local\
    \ palindrome = string_util.find_longest_palindrome(string)\n    -- Append to the\
    \ beginning of the string reverse of the string prefix that comes before the palindromic\
    \ suffix.\n    local reverse_string = string_util.reverse(string_util.sub(string,\
    \ 1, -palindrome.length - 1))\n    return string_util.concat({reverse_string,\
    \ string})\nend", "  local function reverse(string)\n    local t = {}\n    for\
    \ i = 1, #string do\n      t[i] = string:sub(#string + 1 - i, #string + 1 - i)\n\
    \    end\n    return table.concat(t)\n  end", "    if is_palindrome(string) then\n\
    \        return string\n    end", "    local function is_palindrome(string)\n\
    \        local length = string:len()\n        for i = 1, length / 2 do\n     \
    \       if string:sub(i, i) ~= string:sub(length - i + 1, length - i + 1) then\n\
    \                return false\n            end\n        end\n        return true\n\
    \    end", "    local function aux(i, j)\n        if i > j then\n            return\
    \ 0\n        elseif i == j then\n            return 1\n        elseif string:sub(i,\
    \ i) == string:sub(j, j) then\n            return 2 + aux(i + 1, j - 1)\n    \
    \    else\n            return 0\n        end\n    end", "    local len = string.len(string)\n\
    \    for i = len, 1, -1 do\n        if string.sub(string, i) == string.reverse(string.sub(string,\
    \ 1, i)) then\n            return string .. string.reverse(string.sub(string,\
    \ 1, i - 1))\n        end\n    end\nend", "    local prefix = string\n    local\
    \ postfix = string.reverse(string)\n    local longest_palindrome = string.longest_common_substring(prefix,\
    \ postfix)\n    local prefix_len = string.len(prefix)\n    local postfix_len =\
    \ string.len(postfix)\n    if longest_palindrome == postfix_len then\n       \
    \ return string\n    end\n    local prefix_suffix = string.sub(prefix, 0, prefix_len\
    \ - longest_palindrome)\n    return string.format(\"%s%s\", string, string.reverse(prefix_suffix))\n\
    end", "    local rev_string = string:reverse()\n    local length = (#string +\
    \ 1) / 2\n    local prefix = string:sub(1, length)\n    local suffix = string:sub(length\
    \ + 1)\n    local postfix = rev_string:sub(1, length - 1)\n    if suffix ~= postfix\
    \ then\n        return prefix .. rev_string\n    end\n    local i = 1\n    local\
    \ j = 0\n    repeat\n        j = j + 1\n        if suffix:sub(i, i) ~= postfix:sub(j,\
    \ j) then\n            i = i + 1\n            j = 0\n        end\n    until j\
    \ == length - 1\n    return prefix .. rev_string:sub(i)\nend", "  local string_size\
    \ = #string\n  local matrix = DP\n  local i, j, start, max_len", "    local k\
    \ = lps(string) -- longest palindromic suffix\n    local prefix = string:sub(1,\
    \ #string - k)\n    local reverse_prefix = reverse(prefix)\n    return reverse_prefix\
    \ .. string\nend", "  local prefix = string:sub(1, math.floor(#string / 2))\n\
    \  local postfix = string:sub(-#prefix + 1)\n  local postfix_mirror = find_mirror(postfix)\n\
    \  return string .. postfix_mirror\nend", "    local r = string.reverse(string)\n\
    \    return r .. string\nend", "    local postfix = \"\"\n    local prefix = \"\
    \"\n    local i = 1\n    while i <= #string do\n        -- find the longest postfix\
    \ that is a palindrome\n        local n = palindrome_length(string, i)\n     \
    \   if n > #postfix then\n            postfix = string:sub(i, i + n - 1)\n   \
    \         prefix = string:sub(1, i - 1)\n        end\n        i = i + n + 1\n\
    \    end\n    return prefix .. (postfix:reverse())\nend", "    local prefix =\
    \ string\n    local suffix = ''\n    local max_index\n    local mid_index\n  \
    \  local i", "    -- Find the longest postfix of 'string' that is a palindrome.\n\
    \    local suffix = find_longest_palindrome(string)\n    -- Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    return string .. string.reverse(string):sub(1, #string - #suffix)\nend",
  "  local reversed = string:reverse()\n  local last_char = string:sub(-1)\n  local\
    \ last_char_index = string:find(last_char, 1, true)\n  local prefix = string:sub(1,\
    \ last_char_index - 1)\n  return string .. reversed:sub(#prefix + 1)\nend", " \
    \   local reversed = string.reverse(string)\n    local append_string = ''\n  \
    \  local longestsuffix = string.longestsuffix(string, reversed)\n    if longestsuffix\
    \ == string then\n        return string\n    end\n    local append_string = string.sub(string,\
    \ 1, string.len(string) - string.len(longestsuffix))\n    append_string = string.reverse(append_string)\n\
    \    return string .. append_string\nend", "    -- Reverse the string\n    local\
    \ reversed = string:reverse()\n    -- Compute longest common subsequence of the\
    \ string and its reverse.\n    local length = lcs(string, reversed)\n    -- Compute\
    \ the prefix of the string that comes before the palindromic suffix.\n    local\
    \ prefix = string:sub(1, #string - length)\n    -- Reverse the prefix and append\
    \ it to the end of the string.\n    return string .. prefix:reverse()\nend", " \
    \   -- First we need to find the longest suffix that is a palindrome.\n    --\
    \ For example for 'abacaba' it will be 'aba'\n    local table = T.manachers(string)\n\
    \    local k = T.max(table)\n    local longest_palindrome = string:sub(#string\
    \ - k + 1)\n    -- Reverse the prefix that is before the palindromic suffix.\n\
    \    -- If it's the whole string then return empty string.\n    -- Otherwise append\
    \ it to the end of the string.\n    local reversed_prefix = string:sub(1, #string\
    \ - k):reverse()\n    return longest_palindrome .. reversed_prefix\nend", "  local\
    \ suffix_start, suffix_length = palindrome_suffix(string)\n  local prefix = string:sub(1,\
    \ suffix_start - 1)\n  return string .. prefix:reverse()\nend", "    local prefix_length\
    \ = math.max(string.find(string, string.reverse(string), -1))\n    return string\
    \ .. string.reverse(string.sub(string, 1, #string - prefix_length))\nend", " \
    \   local reverse = string:reverse()\n    local j = string:find(reverse, 1, true)",
  "  local left = 1\n  local right = #string\n  while left < right do\n    if string:sub(left,\
    \ left) ~= string:sub(right, right) then\n      break\n    end\n    left = left\
    \ + 1\n    right = right - 1\n  end\n  if left >= right then\n    return string\n\
    \  end\n  -- The whole string is already a palindrome.\n  local prefix = string:sub(1,\
    \ left - 1)\n  local postfix = string:sub(left, #string)\n  local reverse_postfix\
    \ = postfix:reverse()\n  return prefix .. reverse_postfix .. postfix\nend", " \
    \   -- Find the longest palindromic suffix.\n    local suffix_start, suffix_end\
    \ = find_suffix(string)\n    -- If no palindromic suffix found, simply return\
    \ the reverse of the\n    -- whole string - it will be the shortest palindrome.\n\
    \    if suffix_start == suffix_end then\n        return string:reverse()\n   \
    \ end\n    -- If a palindromic suffix is found, we should append to it\n    --\
    \ the reverse of a string prefix that comes before the suffix.\n    local prefix\
    \ = string:sub(1, suffix_start - 1)\n    return string .. prefix:reverse()\nend",
  "\tlocal rev_prefix = string.reverse(string.sub(string, 1, #string - 1))\n\treturn\
    \ string .. rev_prefix\nend", "  local i = string.len(string)\n  while i > 0 do\n\
    \    local prefix = string.sub(string, 1, i)\n    local suffix = string.sub(string,\
    \ i + 1)\n    if prefix == suffix:reverse() then\n      local prefix_without_last_char\
    \ = string.sub(prefix, 1, i - 1)\n      return string .. prefix_without_last_char:reverse()\n\
    \    end\n    i = i - 1\n  end\n  return nil\nend", "\tlocal limit = #string\n\
    \tlocal palindrome = string\n\t\n\tfor i = 1, limit do\n\t\tlocal substring =\
    \ string:sub(1, i)\n\t\tif is_palindrome(substring) then\n\t\t\tpalindrome = reverse(string:sub(i\
    \ + 1)) .. string\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\treturn palindrome\nend",
  "  if is_palindrome(string) then\n    return string\n  end", "  local function mirror(string)\n\
    \    local result = ''\n    for i = #string, 1, -1 do\n      result = result ..\
    \ string:sub(i, i)\n    end\n    return result\n  end", "  local i = string:len()\n\
    \  while true do\n    i = i - 1\n    if i == 0 then\n      return string:reverse()\n\
    \    end\n    if is_palindrome(string:sub(1, i)) then\n      return string:sub(i\
    \ + 1) .. string:reverse()\n    end\n  end\nend", "\tlocal string_length = #string\n\
    \tlocal max_palindrome_length = 0\n\tlocal max_palindrome_position = 0\n\tlocal\
    \ string_upper_length = math.ceil(string_length / 2)\n\tlocal string_lower_length\
    \ = math.floor(string_length / 2)\n\tlocal i = 1\n\twhile i <= string_upper_length\
    \ do\n\t\tlocal string_i = string:sub(i, i)\n\t\tif string_i == string:sub(string_length\
    \ - i + 1, string_length - i + 1) then\n\t\t\tif i <= string_lower_length then\n\
    \t\t\t\tif string_i == string:sub(i + 1, i + 1) then\n\t\t\t\t\tlocal palindrome_length\
    \ = i * 2\n\t\t\t\t\tif palindrome_length > max_palindrome_length then\n\t\t\t\
    \t\t\tmax_palindrome_length = palindrome_length\n\t\t\t\t\t\tmax_palindrome_position\
    \ = i\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tlocal palindrome_length\
    \ = i * 2 - 1\n\t\t\t\tif palindrome_length > max_palindrome_length then\n\t\t\
    \t\t\tmax_palindrome_length = palindrome_length\n\t\t\t\t\tmax_palindrome_position\
    \ = i\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn string\
    \ .. string:sub(1, string_length - max_palindrome_position):reverse()\nend", " \
    \   local longest_prefix = 1\n    local suffix_length = 2\n    local string_length\
    \ = #string\n    while true do\n        local prefix = string:sub(1, longest_prefix)\n\
    \        local suffix = string:sub(string_length - suffix_length + 1, string_length)\n\
    \        if prefix == suffix then\n            longest_prefix = longest_prefix\
    \ + 1\n            suffix_length = suffix_length + 1\n        else\n         \
    \   break\n        end\n    end\n    return string .. string:sub(1, string_length\
    \ - longest_prefix):reverse()\nend", "\tlocal reversed = string:reverse()\n\t\
    local prefix_end = string:len() - string:find(reversed)\n\treturn string .. reversed:sub(prefix_end\
    \ + 1)\nend", "    local n = #string\n    local i = math.floor(n / 2)", "    local\
    \ suffix_len = find_longest_palindrome_suffix(string)\n    local prefix = string:sub(1,\
    \ string:len() - suffix_len)\n    return string .. prefix:reverse()\nend", " \
    \   -- Find the longest postfix of the string that is a palindrome.\n    local\
    \ length = string:len()\n    local reverse = string:reverse()\n    local palindrome_postfix\
    \ = ''\n    for i = 0, length do\n        if string:sub(1, i) == reverse:sub(length\
    \ - i + 1, length) then\n            palindrome_postfix = string:sub(i + 1, length)\n\
    \            break\n        end\n    end\n    return string .. palindrome_postfix:reverse()\n\
    end", "  local string_length = #string\n  local prefix_length = math.floor(string_length\
    \ / 2)\n  local prefix = string:sub(1, prefix_length)\n  local postfix = string:sub(string_length\
    \ - prefix_length + 1, string_length)\n  for i = 1, prefix_length do\n    local\
    \ char = prefix:sub(i, i)\n    if char ~= postfix:sub(1 - i, 1 - i) then\n   \
    \   return string .. prefix:sub(i + 1, prefix_length):reverse()\n    end\n  end\n\
    \  return string .. prefix:sub(2, prefix_length):reverse()\nend", "  local longest_palindrome_suffix\
    \ = string:find(\"(.*)(%1)\", 1, true)\n  if longest_palindrome_suffix == 1 then\n\
    \    return string\n  end\n  local prefix = string:sub(1, #string - longest_palindrome_suffix\
    \ + 1)\n  return prefix .. prefix:reverse()\nend", "    local reversed = string:reverse()\n\
    \    local prefix = string:sub(1, -string:len() - 1)\n    return string .. reversed:sub(1,\
    \ prefix:len())\nend", "  local chars = split(string)\n  local chars_reversed\
    \ = reverse(chars)\n  local length = #chars\n  local prefix_end_offset = 0\n \
    \ local longest_palindrome_length = 0\n  local longest_palindrome_middle = 0\n\
    \  local longest_palindrome_middle_offset = 0\n  local suffix_start_offset = 1\n\
    \  while suffix_start_offset <= length do\n    -- Find the length of the longest\
    \ palindrome that begins and ends in the current suffix.\n    local palindrome_length,\
    \ palindrome_middle = find_palindrome_length(chars, suffix_start_offset)\n   \
    \ if palindrome_length > longest_palindrome_length then\n      longest_palindrome_length\
    \ = palindrome_length\n      longest_palindrome_middle = palindrome_middle\n \
    \     longest_palindrome_middle_offset = suffix_start_offset\n    end\n    suffix_start_offset\
    \ = suffix_start_offset + 1\n  end\n  prefix_end_offset = longest_palindrome_middle_offset\
    \ + longest_palindrome_middle\n  local prefix = {}\n  for i = 1, prefix_end_offset\
    \ - 1 do\n    table.insert(prefix, chars[i])\n  end\n  local reversed_prefix =\
    \ reverse(prefix)\n  return table.concat(prefix) .. table.concat(reversed_prefix)\n\
    end", "    local length = unicode.len(string)\n    local suffix, suffix_length\
    \ = get_longest_palindromic_suffix(string)\n    if suffix_length == length then\n\
    \        return string\n    end\n    local prefix = unicode.sub(string, 1, length\
    \ - suffix_length)\n    return string .. unicode.reverse(prefix)\nend", "    if\
    \ #string == 0 then\n        return \"\"\n    end\n    local str_rev = reverse(string)\n\
    \    -- Find the longest postfix that is a palindrome.\n    local longest_postfix\
    \ = lcs(string, str_rev)\n    -- Append reverse of the prefix before the palindromic\
    \ suffix.\n    local prefix = sub(string, 1, #string - #longest_postfix)\n   \
    \ return prefix .. str_rev\nend", "\tlocal left_edge = 0\n\tlocal right_edge =\
    \ #string - 1\n\tlocal curr_palindrome_length = 0\n\tlocal longest_palindrome_length\
    \ = 0\n\tlocal longest_palindrome_position = 0\n\tlocal longest_palindrome_remainder\
    \ = ''", "    local reverse = string.reverse(string)\n    local longest_palindrome\
    \ = find_longest_palindrome(string)\n    local non_palindrome_prefix = string.sub(string,\
    \ 1, #string - #longest_palindrome)\n    local reversed_prefix = string.reverse(non_palindrome_prefix)\n\
    \    return string.format(\"%s%s\", string, reversed_prefix)\nend", "    local\
    \ suffix_len = 0\n    local rev_prefix = string.reverse(string)\n    for i = 1,\
    \ #string do\n        if string.sub(string, 1, i) == string.sub(rev_prefix, 1,\
    \ i) then\n            suffix_len = i\n        end\n    end\n    return string\
    \ .. string.sub(rev_prefix, suffix_len + 1)\nend", "    local reversed = string:reverse()\n\
    \    local postfix = ''\n    for i = 1, #string do\n        if reversed:sub(i)\
    \ == string:sub(1, i) then\n            postfix = string:sub(1, i)\n        end\n\
    \    end\n    return postfix .. string\nend", "\tlocal n = #string\n\tlocal palindrome_prefix_length\
    \ = 0\n\tlocal string_half_reversed = string:reverse()\n\tlocal result = string\
    \ .. string_half_reversed\n\tlocal text = string .. '#' .. string_half_reversed\n\
    \tlocal prefix_function = find_prefix_function(text)\n\tfor i = n + 1, #text do\n\
    \t\tif prefix_function[i] > palindrome_prefix_length then\n\t\t\tpalindrome_prefix_length\
    \ = prefix_function[i]\n\t\tend\n\tend\n\tresult = result:sub(palindrome_prefix_length\
    \ + 1)\n\treturn result\nend", "    local postfix_start = string:find_longest_palindrome_suffix()\n\
    \    local prefix = string:sub(1, #string - postfix_start)\n    return string\
    \ .. prefix:reverse()\nend", "    local result = string\n    local reverse = string.reverse(string)\n\
    \    local postfix_idx = string.find(string, reverse, -#string, true)", "  --\
    \ Find the longest palindromic suffix of the string.\n  local max_palindrome_suffix_len\
    \ = 1\n  local max_palindrome_suffix_end = 1\n  for i = 1, #string do\n    if\
    \ is_palindrome(string, 1, i) then\n      max_palindrome_suffix_len = i\n    \
    \  max_palindrome_suffix_end = i\n    end\n  end", "    -- Finds the longest palindromic\
    \ suffix of the string.\n    local function longest_palindromic_suffix(string)\n\
    \        local length = #string\n        local palindrome_length = 1\n       \
    \ while string:sub(length - palindrome_length + 1, length) ~= string:sub(1, palindrome_length):reverse()\
    \ do\n            palindrome_length = palindrome_length + 1\n        end\n   \
    \     return palindrome_length\n    end", "  local len = string:len()\n  local\
    \ reverse = string:reverse()\n  local max_length = 1", "    local reverse = string:reverse()\n\
    \    local prefix_length = 0\n    local max_palindrome_length = 0\n    local max_palindrome_length_index\
    \ = 0\n    for i = 1, #string do\n        if string:sub(i) == reverse:sub(1, #string\
    \ - i + 1) then\n            prefix_length = i - 1\n            max_palindrome_length\
    \ = #string - i + 1\n            max_palindrome_length_index = i\n        end\n\
    \    end\n    return string .. reverse:sub(max_palindrome_length_index, prefix_length)\n\
    end", "  local function get_longest_palindrome_suffix_len(string)\n    local match_len\
    \ = 0\n    for i = 1, #string do\n      if string:sub(1, i) == string:sub(#string\
    \ - i + 1, #string):reverse() then\n        match_len = i\n      end\n    end\n\
    \    return match_len\n  end", "    local palindrome_size = 0\n    local string_size\
    \ = utf8.len(string)\n    local string_reverse = utf8.reverse(string)\n    for\
    \ i = 1, string_size do\n        local prefix = utf8.sub(string, 1, i)\n     \
    \   local postfix = utf8.sub(string_reverse, 1, i)\n        if prefix == postfix\
    \ then\n            palindrome_size = i\n        end\n    end\n    local prefix\
    \ = utf8.sub(string, 1, palindrome_size)\n    local postfix = utf8.sub(string,\
    \ palindrome_size + 1)\n    local postfix_reverse = utf8.reverse(postfix)\n  \
    \  return prefix .. postfix_reverse\nend", "    local string_len = string:len()\n\
    \    local string_rev = string:reverse()\n    local prefix_len = 0\n    for i\
    \ = 1, string_len do\n        local palindrome_suffix = string:sub(i)\n      \
    \  local palindrome_suffix_rev = palindrome_suffix:reverse()\n        if palindrome_suffix\
    \ == palindrome_suffix_rev then\n            prefix_len = string_len - i + 1\n\
    \            break\n        end\n    end\n    local prefix = string:sub(1, prefix_len)\n\
    \    local prefix_rev = prefix:reverse()\n    return string .. prefix_rev\nend",
  "\tlocal i, j, k\n\tlocal m = #string\n\t-- Build a table that stores the length\
    \ of the longest palindromic suffix\n\t-- of a string ending at the given index\n\
    \tlocal table = {}\n\ttable[m] = 0\n\t-- We need to find for each index the length\
    \ of the longest palindromic\n\t-- suffix. We need to do it for the string in\
    \ reverse order.\n\tfor i = m - 1, 1, -1 do\n\t\t-- Find the longest prefix of\
    \ the reversed string\n\t\t-- that is also a suffix of the original string.\n\t\
    \tfor j = 1, table[i + 1] do\n\t\t\t-- The prefix of the reversed string must\
    \ not be longer than the current suffix of the original string.\n\t\t\tif string.sub(string,\
    \ i, i + j - 1) == string.sub(string, m, m - j + 1) then\n\t\t\t\ttable[i] = j\n\
    \t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\t-- Now, we can find the length of\
    \ the longest palindromic suffix\n\t-- by taking the maximum of the values in\
    \ the table.\n\tk = table[1]\n\tfor i = 2, m do\n\t\tif table[i] > k then\n\t\t\
    \tk = table[i]\n\t\tend\n\tend\n\t-- Since we are building the shortest palindrome,\n\
    \t-- k must be the size of the palindromic suffix.\n\t-- The size of the prefix\
    \ that comes before the palindromic suffix is (m - k).\n\t-- So we need to append\
    \ to the end of the string a reversed prefix of size (m - k).\n\treturn string\
    \ .. string.reverse(string.sub(string, 1, m - k))\nend", "  local reverse = string:reverse()\n\
    \  local prefix, suffix = string:gsub('.*' .. reverse, '%1')\n  return string\
    \ .. suffix:reverse()\nend", "    -- Find the longest palindromic suffix.\n  \
    \  local m = lps_borders(string)\n    -- Check if the string is already a palindrome.\n\
    \    if m == #string then\n        return string\n    end\n    -- Slice the prefix\
    \ that comes before the palindromic suffix.\n    local prefix = string:sub(1,\
    \ #string - m)\n    -- Reverse the prefix.\n    local prefix_reverse = prefix:reverse()\n\
    \    -- Append the reversed prefix to the end of the original string.\n    return\
    \ string .. prefix_reverse\nend", "    local lcs = longest_common_substring(string,\
    \ string:reverse())\n    local prefix = string:sub(1, #string - #lcs)\n    return\
    \ string .. prefix:reverse()\nend", "    local reverse = string:reverse()\n  \
    \  -- find length of the longest common postfix\n    local longest_common_postfix\
    \ = {0}\n    for j = 2, #string do\n        local k = longest_common_postfix[j\
    \ - 1]\n        while k > 0 and string:sub(j, j) ~= string:sub(k + 1, k + 1) do\n\
    \            k = longest_common_postfix[k]\n        end\n        if string:sub(j,\
    \ j) == string:sub(k + 1, k + 1) then\n            k = k + 1\n        end\n  \
    \      longest_common_postfix[j] = k\n    end\n    -- add reverse of a string\
    \ prefix to the end of the string\n    local prefix = string:sub(1, #string -\
    \ longest_common_postfix[#string])\n    return string .. reverse:sub(1, #prefix):reverse()\n\
    end", "\tlocal result = string\n\tlocal longest_postfix = ''\n\t-- Find the longest\
    \ postfix that is a palindrome\n\tfor i = string.len(string), 1, -1 do\n\t\tif\
    \ string.sub(string, i) == string.reverse(string.sub(string, 1, i)) then\n\t\t\
    \tlongest_postfix = string.sub(string, i)\n\t\t\tbreak\n\t\tend\n\tend\n\tif longest_postfix\
    \ ~= '' then\n\t\t-- Append to the end reverse of the string prefix\n\t\tresult\
    \ = result .. string.reverse(string.sub(string, 1, string.len(string) - string.len(longest_postfix)))\n\
    \tend\n\treturn result\nend", "  local reversed = string.reverse(string)\n  local\
    \ prefix_length = find_palindrome_suffix(string)\n  local prefix = string.sub(string,\
    \ 1, -1 - prefix_length)\n  return string .. reversed:sub(prefix_length + 1)\n\
    end", "  local is_palindrome, palindrome_length = is_palindrome_suffix(string)\n\
    \  if is_palindrome then\n    return string\n  end\n  return string:sub(palindrome_length\
    \ + 1) ..\n    string:sub(1, palindrome_length):reverse()\nend", "    local result\
    \ = string\n    local l = 1\n    local r = #string\n    local prefix = ''\n  \
    \  while l < r do\n        if string.sub(string, l, r) == string.reverse(string.sub(string,\
    \ l, r)) then\n            prefix = string.sub(string, 1, l - 1)\n           \
    \ break\n        end\n        l = l + 1\n        r = r - 1\n    end\n    result\
    \ = result .. string.reverse(prefix)\n    return result\nend", "    local reverse\
    \ = string:reverse()\n    local index = 0\n    for i = 1, #string do\n       \
    \ local pref = string:sub(1, i)\n        local rev_pref = reverse:sub(1, i)\n\
    \        if pref == rev_pref then\n            index = i\n        end\n    end\n\
    \    return string .. reverse:sub(index + 1)\nend", "    -- Find the longest palindromic\
    \ suffix.\n    local suffix = string:reverse()\n    local suffix_len = string.len(suffix)\n\
    \    for i = suffix_len, 1, -1 do\n        if string.sub(string, 1, i) == string.sub(suffix,\
    \ suffix_len - i + 1, suffix_len) then\n            -- Append reverse of the string\
    \ prefix to the end of the palindromic suffix.\n            local prefix = string.sub(string,\
    \ i + 1, string.len(string))\n            return string.sub(string, 1, i) .. prefix:reverse()\n\
    \        end\n    end\n    return string\nend", "  local reverse = util.reverse(string)\n\
    \  local prefix = string:sub(1, (#string - 1) / 2)\n  local suffix = reverse:sub(1,\
    \ (#string - 1) / 2)\n  local postfix = longest_common_substring(prefix, suffix)\n\
    \  local prefix_prefix = prefix:sub(1, #prefix - #postfix)\n  return string ..\
    \ util.reverse(prefix_prefix)\nend", "    local reverse = string:reverse()\n \
    \   local tail = 0\n    for i = 1, #string do\n        if string:sub(1, i) ==\
    \ reverse:sub(#string - i + 1, #string) then\n            tail = i\n        end\n\
    \    end\n    return string .. reverse:sub(#string - tail + 1, #string - 1)\n\
    end", "\t-- First find the longest palindromic suffix for the string\n\tlocal\
    \ longest_suffix_index = find_longest_palindromic_suffix(string)\n\tlocal prefix\
    \ = string:sub(1, #string - longest_suffix_index)\n\treturn string .. string:reverse():sub(1,\
    \ #prefix)\nend", '  local i, j = 1, #string', "  local lps = lps_of(string)\n\
    \  local last_lps = #lps\n  local prefix = string:sub(1, last_lps)\n  return string\
    \ .. prefix:reverse()\nend", "    local longest_palindrome_suffix = \"\"\n   \
    \ local string_length = string.len(string)\n    for i = 1, string_length do\n\
    \        local suffix = string.sub(string, string_length - i + 1)\n        local\
    \ prefix = string.sub(string, 1, i)\n        if suffix == string.reverse(prefix)\
    \ then\n            longest_palindrome_suffix = suffix\n        end\n    end\n\
    \    local palindrome = string .. string.reverse(string.sub(string, 1, string_length\
    \ - #longest_palindrome_suffix))\n    return palindrome\nend", "\tlocal string_length\
    \ = string:len()\n\tlocal string_reverse = string:reverse()\n\tlocal matrix =\
    \ make_matrix(string_length, string_length)\n\tfor i = 1, string_length do\n\t\
    \tfor j = 1, string_length do\n\t\t\tif (string:sub(i, i) == string_reverse:sub(j,\
    \ j)) then\n\t\t\t\tmatrix[i][j] = 1 + (matrix[i - 1][j - 1] or 0)\n\t\t\telse\n\
    \t\t\t\tmatrix[i][j] = math.max(matrix[i - 1][j] or 0, matrix[i][j - 1] or 0)\n\
    \t\t\tend\n\t\tend\n\tend\n\tlocal i = string_length\n\tlocal j = string_length\n\
    \tlocal result = {}\n\twhile (matrix[i][j] > 0) do\n\t\tif (matrix[i][j] == (matrix[i\
    \ - 1][j] or 0)) then\n\t\t\ti = i - 1\n\t\telseif (matrix[i][j] == (matrix[i][j\
    \ - 1] or 0)) then\n\t\t\tj = j - 1\n\t\telse\n\t\t\ttable.insert(result, 1, string:sub(i,\
    \ i))\n\t\t\ti = i - 1\n\t\t\tj = j - 1\n\t\tend\n\tend\n\treturn string .. string:sub(1,\
    \ i):reverse()\nend", "    local max_length = 1\n    local length = #string\n\
    \    local right = 0\n    local left = 0\n    local palindrome = {}\n    -- If\
    \ `string` is already a palindrome, we can skip the expensive computations below.\n\
    \    if string == string:reverse() then\n        return string\n    end\n    --\
    \ Make an empty palindrome of `max_length` size.\n    for i = 1, max_length do\n\
    \        palindrome[i] = 1\n    end\n    -- Iterate over all possible palindromes\
    \ in `string`.\n    for i = 1, length do\n        -- Odd palindromes.\n      \
    \  local current_length = 1\n        -- Ignore any palindromes that don't fit\
    \ into the string.\n        while i - current_length >= 1 and i + current_length\
    \ <= length do\n            -- Expand to the left and to the right.\n        \
    \    if string:sub(i - current_length, i - current_length) == string:sub(i + current_length,\
    \ i + current_length) then\n                palindrome[i] = current_length * 2\
    \ + 1\n                if current_length * 2 + 1 > max_length then\n         \
    \           -- Update the maximum length.\n                    max_length = current_length\
    \ * 2 + 1\n                    -- Save the start and end of the longest palindrome.\n\
    \                    right = i + current_length\n                    left = i\
    \ - current_length\n                end\n                current_length = current_length\
    \ + 1\n            else\n                break\n            end\n        end\n\
    \        -- Even palindromes.\n        current_length = 0\n        -- Ignore any\
    \ palindromes that don't fit into the string.\n        while i - current_length\
    \ >= 1 and i + current_length + 1 <= length do\n            -- Expand to the left\
    \ and to the right.\n            if string:sub(i - current_length, i - current_length)\
    \ == string:sub(i + current_length + 1, i + current_length + 1) then\n       \
    \         palindrome[i] = current_length * 2 + 2\n                if current_length\
    \ * 2 + 2 > max_length then\n                    -- Update the maximum length.\n\
    \                    max_length = current_length * 2 +", "  local reverse = string:reverse()\n\
    \  local n = string:len()\n  for i = 0, n - 1 do\n    local l, r = n - i, n\n\
    \    if string:sub(l, r) == reverse:sub(1, i + 1) then\n      return string ..\
    \ reverse:sub(i + 2)\n    end\n  end\n  return string .. reverse:sub(2)\nend",
  "  local postfix_length = 0\n  local postfix_length_found = false\n  local found_prefix\
    \ = \"\"\n  local current_prefix = \"\"\n  for i = 1, utf8.len(string) do\n  \
    \  local current_char = utf8.sub(string, i, i)\n    if postfix_length_found then\n\
    \      if current_char == postfix_char then\n        postfix_length = postfix_length\
    \ + 1\n      else\n        postfix_length_found = false\n      end\n    else\n\
    \      if current_char == utf8.sub(string, i + postfix_length, i + postfix_length)\
    \ then\n        postfix_length = postfix_length + 1\n        postfix_length_found\
    \ = true\n        postfix_char = current_char\n      end\n    end\n    current_prefix\
    \ = current_prefix .. current_char\n    found_prefix = string.reverse(current_prefix)\n\
    \  end\n  return string .. found_prefix\nend", "  local reversed = string.reverse(string)\n\
    \  local prefix_length = longest_common_suffix(string, reversed)\n  local prefix\
    \ = string.sub(string, 1, prefix_length)\n  local postfix = string.sub(string,\
    \ prefix_length + 1)\n  local reversed_prefix = string.reverse(prefix)\n  return\
    \ reversed_prefix .. postfix .. reversed_prefix\nend", "  local palindrome = string\n\
    \  local reverse = string:reverse()\n  local suffix_string = string\n  local suffix_pos\
    \ = 1\n  local suffix_char = suffix_string:sub(suffix_pos, suffix_pos)\n  local\
    \ prefix_pos = string:len()", "    local reverse = string:reverse()\n    local\
    \ lcs = longest_common_subsequence(string, reverse)\n    local prefix = string:sub(1,\
    \ string:len() - lcs:len())\n    return string .. prefix:reverse()\nend", "  --\
    \ Find the longest palindromic postfix (suffix) of the string.\n  local palindrome\
    \ = string\n  local i = string.len(string)\n  local j = 0\n  while true do\n \
    \   i = i - 1\n    if i == j then\n      break\n    end\n    -- Try to extend\
    \ the palindrome by one character.\n    if string.sub(string, i, i) == string.sub(string,\
    \ j, j) then\n      palindrome = string.sub(string, i, string.len(string))\n \
    \     j = j + 1\n    else\n      -- Make sure we don't add to palindrome string\
    \ those postfixes that are not palindromes.\n      palindrome = string\n     \
    \ j = 0\n    end\n  end\n  -- Append the reverse of string prefix that comes before\
    \ the palindromic suffix.\n  -- For example, 'race' -> 'carace'.\n  return string.sub(string,\
    \ 1, string.len(string) - string.len(palindrome)) ..\n    string.reverse(string.sub(string,\
    \ 1, string.len(string) - string.len(palindrome))) .. palindrome\nend", "  local\
    \ pos, len = string.find(string, string.reverse(string), -1, true)\n  if pos ==\
    \ 1 then\n    return string\n  end\n  return string .. string.reverse(string.sub(string,\
    \ 1, pos - 1))\nend", "  local length = string.len(string)\n  local palindrome\
    \ = string\n  local prefix_length = 0\n  local i = 1\n  local j = 1\n  local next_i\
    \ = 1\n  local next_j = 1\n  local suffix_length = 0\n  local suffix_begin = 1\n\
    \  local suffix_end = 0\n  local not_suffix = 1\n  local k = 0\n  -- print(string.format(\"\
    length: %d, string: '%s'\", length, string))\n  -- Compare the current suffix\
    \ string length with the previous suffix string length.\n  -- If the current suffix\
    \ string length is greater than the previous suffix string length\n  -- then keep\
    \ the current suffix string length, start and end.\n  while i <= length do\n \
    \   if i > next_i then\n      i = next_i\n      j = next_j\n    end\n    while\
    \ j <= length do\n      -- print(string.format(\"Checking if '%s' is a suffix\"\
    , string.sub(string, i, j)))\n      if i == j then\n        -- A single character\
    \ is always a palindrome.\n        suffix_length = 1\n        suffix_begin = i\n\
    \        suffix_end = j\n        -- print(string.format(\"  Found %d char long\
    \ suffix at %d-%d '%s'\", suffix_length, suffix_begin, suffix_end, string.sub(string,\
    \ suffix_begin, suffix_end)))\n      elseif i == j + 1 then\n        -- Two characters\
    \ are a palindrome if they are the same.\n        if string.sub(string, i, i)\
    \ == string.sub(string, j, j) then\n          suffix_length = 2\n          suffix_begin\
    \ = i\n          suffix_end = j\n          -- print(string.format(\"  Found %d\
    \ char long suffix at %d-%d '%s'\", suffix_length, suffix_begin, suffix_end, string.sub(string,\
    \ suffix_begin, suffix_end)))\n        end\n      else\n        -- Check if three\
    \ or more characters are a palindrome.\n        -- The check for is a palindrome\
    \ takes three characters:\n        -- - the first character,\n        -- - the\
    \ last character,\n        -- -", "\tif string == nil then\n\t\treturn nil\n\t\
    end\n\tlocal string_length = string:len()\n\tif string_length == 0 then\n\t\t\
    return ''\n\tend\n\tlocal palindrome_suffix_start_index = -1\n\tfor i = string_length,\
    \ 1, -1 do\n\t\tif string:sub(1, i) == string:sub(string_length - i + 1, string_length):reverse()\
    \ then\n\t\t\tpalindrome_suffix_start_index = i\n\t\t\tbreak\n\t\tend\n\tend\n\
    \treturn string:sub(palindrome_suffix_start_index, string_length) .. string:sub(1,\
    \ palindrome_suffix_start_index - 1):reverse()\nend", "    local postfix_length\
    \ = longest_palindromic_postfix(string)\n    local prefix = string:sub(1, -postfix_length\
    \ - 1)\n    return string .. string:reverse():sub(#prefix + 1)\nend", "  local\
    \ postfix_length = string:match '^(.*)%1$'\n  local prefix = string:sub(1, #string\
    \ - postfix_length)\n  return string .. prefix:reverse()\nend", "    -- Handle\
    \ the case of empty string\n    if string == \"\" then\n        return \"\"\n\
    \    end", "\tlocal size = #string\n\tlocal reverse = string:reverse()\n\tlocal\
    \ prefix = string:sub(1, size - 1)\n\tlocal suffix = string:sub(size)\n\tlocal\
    \ match = prefix:find(suffix)\n\tif match then\n\t\treturn string .. reverse:sub(match)\n\
    \telse\n\t\treturn string .. reverse\n\tend\nend", "    local length = #string\n\
    \    local prefix = 0\n    for i = length, 1, -1 do\n        if (string:sub(i,\
    \ length) == string:sub(1, length - i + 1):reverse()) then\n            prefix\
    \ = i\n            break\n        end\n    end\n    return string .. string:sub(1,\
    \ prefix - 1):reverse()\nend", "  local n = string:len()\n  local prefix_length\
    \ = 0\n  local preffix_string = ''\n  for i = 1, math.floor(n / 2) do\n    if\
    \ string:sub(1, i) == string:sub(n - i + 1, n) then\n      prefix_length = i\n\
    \      preffix_string = string:sub(1, i)\n    end\n  end\n  return string .. string:sub(prefix_length\
    \ + 1, n):reverse()\nend", "    local length = string.len(string)\n    local prefix\
    \ = string.sub(string, 1, length)\n    while prefix ~= \"\" do\n        local\
    \ postfix = string.sub(string, length - string.len(prefix) + 1)\n        if postfix\
    \ == string.reverse(prefix) then\n            return string .. string.reverse(string.sub(string,\
    \ 1, length - string.len(prefix)))\n        end\n        prefix = string.sub(prefix,\
    \ 1, -2)\n    end\n    return string .. string.reverse(string)\nend", "    local\
    \ reversed = string.reverse(string)\n    local suffix = ''\n    local prefix =\
    \ string\n    local suffix_reverse = ''\n    while true do\n        if #suffix\
    \ == #string then\n            return reversed .. prefix\n        end\n      \
    \  if string.sub(reversed, 1, #suffix + 1) == suffix_reverse .. prefix then\n\
    \            suffix = suffix .. prefix:sub(1, 1)\n            prefix = prefix:sub(2)\n\
    \            suffix_reverse = prefix:sub(-1) .. suffix_reverse\n        else\n\
    \            prefix = prefix:sub(2)\n            suffix_reverse = prefix:sub(-1)\
    \ .. suffix_reverse\n        end\n    end\nend", "    local reversed = reverse(string)\n\
    \    -- Find the longest palindromic suffix.\n    local suffix = reversed:sub(1,\
    \ find_lps(string))\n    -- Return the palindrome.\n    return string .. suffix\n\
    end", "    local _, longest_palindrome_length = longest_palindrome_at(string,\
    \ string:len() - 1)\n    local prefix = string:sub(1, longest_palindrome_length)\n\
    \    local prefix_reversed = prefix:reverse()\n    return string .. prefix_reversed\n\
    end", "    local first_half = string:sub(1, math.floor(#string / 2))\n    local\
    \ n = #first_half\n    local a, b, c = first_half:sub(1, n - 1), first_half:sub(n,\
    \ n), first_half:sub(n + 1, n + 1)\n    for p = n - 1, 0, -1 do\n        if a\
    \ == reverse(c) then\n            return string .. reverse(string:sub(n + 1, p))\n\
    \        end\n        a, b, c = a:sub(1, p - 1), a:sub(p, p), a:sub(p + 1, p +\
    \ 1)\n    end\n    return string .. reverse(string:sub(2))\nend", "  local rev,\
    \ prefix, suffix = utils.reverse(string), \"\", \"\"\n  local length = #string\n\
    \  local function is_palindrome(substring)\n    return utils.substring(substring,\
    \ 1, #substring) == utils.reverse(substring)\n  end\n  for i = length, 1, -1 do\n\
    \    if is_palindrome(utils.substring(string, 1, i)) then\n      prefix = utils.substring(string,\
    \ 1, i)\n      suffix = utils.substring(string, i + 1, length)\n      break\n\
    \    end\n  end\n  return prefix .. utils.reverse(suffix)\nend", "    local prefix_begin\
    \ = 1\n    local prefix_end = string.len(string)\n    local suffix_begin = string.len(string)\n\
    \    local suffix_end = string.len(string)", "\tlocal string_length = #string\n\
    \tlocal prefix_length = 0\n\tlocal postfix_length = 0\n\tlocal postfix = ''\n\t\
    for i = 1, string_length do\n\t\tlocal prefix = string:sub(1, i)\n\t\tlocal postfix\
    \ = string:sub(i + 1, string_length)\n\t\tif prefix == postfix:reverse() then\n\
    \t\t\tprefix_length = i\n\t\t\tpostfix_length = string_length - i\n\t\tend\n\t\
    end\n\treturn string .. string:sub(prefix_length + 1, string_length):reverse()\n\
    end", "  local function is_palindrome(s)\n    for i = 1, math.floor(#s / 2) do\n\
    \      if s:sub(i, i) ~= s:sub(#s - i + 1, #s - i + 1) then\n        return false\n\
    \      end\n    end\n    return true\n  end", "    local string_len = #string\n\
    \    local function is_palindrome(begin_pos, end_pos)\n        while begin_pos\
    \ < end_pos do\n            if string:sub(begin_pos, begin_pos) ~= string:sub(end_pos,\
    \ end_pos) then\n                return false\n            end\n            begin_pos\
    \ = begin_pos + 1\n            end_pos = end_pos - 1\n        end\n        return\
    \ true\n    end\n    local function expand_around_center(begin_pos, end_pos)\n\
    \        while begin_pos >= 1 and end_pos <= string_len do\n            if not\
    \ is_palindrome(begin_pos, end_pos) then\n                break\n            end\n\
    \            begin_pos = begin_pos - 1\n            end_pos = end_pos + 1\n  \
    \      end\n        return begin_pos + 1, end_pos - 1\n    end\n    local palindrome_begin_pos,\
    \ palindrome_end_pos = 1, 1\n    for i = 1, string_len do\n        local begin_pos_odd,\
    \ end_pos_odd = expand_around_center(i, i)\n        local begin_pos_even, end_pos_even\
    \ = expand_around_center(i, i + 1)\n        local palindrome_size_odd = end_pos_odd\
    \ - begin_pos_odd + 1\n        local palindrome_size_even = end_pos_even - begin_pos_even\
    \ + 1\n        if palindrome_size_odd > palindrome_end_pos - palindrome_begin_pos\
    \ + 1 then\n            palindrome_begin_pos, palindrome_end_pos = begin_pos_odd,\
    \ end_pos_odd\n        end\n        if palindrome_size_even > palindrome_end_pos\
    \ - palindrome_begin_pos + 1 then\n            palindrome_begin_pos, palindrome_end_pos\
    \ = begin_pos_even, end_pos_even\n        end\n    end\n    return string:sub(1,\
    \ palindrome_begin_pos - 1) .. string:reverse():sub(1, string_len - palindrome_end_pos)\
    \ .. string\nend\n", "    local palindrome_half = get_palindrome_half(string)\n\
    \    return string .. reverse(string, palindrome_half + 1)\nend", "  if string\
    \ == \"\" then\n    return \"\"\n  end\n  -- Use Knuth-Morris-Pratt algorithm\
    \ to find the longest palindromic suffix.\n  local longest_suffix_length = 0\n\
    \  -- [i] is the length of the longest palindromic prefix of the string\n  --\
    \ that ends at the i-th position.\n  local lpp = {}\n  -- First character is always\
    \ a palindrome of length 1.\n  lpp[1] = 1\n  local string_length = string.len(string)\n\
    \  for i = 2, string_length do\n    -- We will try to find the longest palindromic\
    \ prefix that ends at the\n    -- i-th position. The prefix should match either\
    \ the previous prefix\n    -- or the substring that begins at the previous position.\n\
    \    --\n    -- For example, for the string \"abbaaba\" the longest palindromic\
    \ prefixes\n    -- are \"a\", \"b\", \"b\", \"abba\", \"a\", \"aba\", \"a\" of\
    \ length 1, 1, 1, 4, 1, 3, 1,\n    -- correspondingly.\n    --\n    -- We start\
    \ with the longest palindromic prefix that ends at the previous\n    -- position\
    \ (i - 1), lpp[i - 1], and if it ends at a different character\n    -- than the\
    \ character at the i-th position, then we try lpp[i - 1] + 1,\n    -- lpp[i -\
    \ 1] + 2, etc. and see if we can find a palindromic prefix\n    -- that ends at\
    \ the current position.\n    --\n    -- For example, for \"abbaaba\" we start\
    \ from lpp[5] = 4, and the next\n    -- character doesn't match, then we try \"\
    a\" (lpp[5] + 1), which doesn't\n    -- match, and then \"ab\" (lpp[5] + 2), which\
    \ does match, so we stop.\n    --\n    -- See\n    -- http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm\n\
    \    -- for a detailed description.\n    local lpp_i = lpp[i - 1]\n   ", "  local\
    \ i = (string:len() + 1) / 2\n  while i > 0 do\n    local s = string:sub(i, -1)\n\
    \    local rev = s:reverse()\n    if s == rev then\n      return string .. s:sub(2,\
    \ -1):reverse()\n    end\n    i = i - 1\n  end\n  return nil\nend", "\t-- It's\
    \ enough to search the postfix up to the length of half the string.\n\t-- Suppose\
    \ the string consists of an even number of characters.\n\t-- Then the first half\
    \ of the string is a prefix of the searched palindrome.\n\t-- The second half\
    \ of the string will be its postfix.\n\t-- It's easy to see that the second half\
    \ can not be a prefix of the searched palindrome, since it's a postfix of the\
    \ original string.\n\t-- It's easy to see the same for the case of an odd number\
    \ of characters in the string.\n\tlocal half_length = math.floor(#string / 2)",
  "  local string_length = string:len()\n  local odd_palindrome = find_longest_odd_palindrome(string)\n\
    \  local even_palindrome = find_longest_even_palindrome(string)\n  local palindrome_length\
    \ = math.max(odd_palindrome.length, even_palindrome.length)\n  local is_odd =\
    \ palindrome_length == odd_palindrome.length\n  local append_prefix_start, append_prefix_end\n\
    \  if is_odd then\n    append_prefix_start = odd_palindrome.start - 1\n    append_prefix_end\
    \ = odd_palindrome.start - 1\n  else\n    append_prefix_start = even_palindrome.start\
    \ - 1\n    append_prefix_end = even_palindrome.start\n  end\n  local prefix =\
    \ string:sub(append_prefix_start, append_prefix_end)\n  local suffix = string:sub(append_prefix_end\
    \ + 1, string_length)\n  return prefix .. suffix\nend", "    local concat = string.reverse(string)\n\
    \    local string_len = string.len(string)\n    local reversed_string = string.sub(concat,\
    \ 1, string_len)\n    local prefix = string.sub(string, 1, math.floor(string_len\
    \ / 2))\n    local prefix_len = string.len(prefix)\n    local prefix_reversed\
    \ = string.reverse(prefix)\n    local n = string_len\n    local m = prefix_len\n\
    \    local table = {}\n    for i = 0, m - 1 do\n        table[i] = {}\n      \
    \  for j = 0, n - 1 do\n            table[i][j] = 0\n        end\n    end\n  \
    \  for i = 0, m - 1 do\n        for j = 0, n - 1 do\n            if i == 0 or\
    \ j == 0 then\n                table[i][j] = 0\n            elseif string.sub(prefix,\
    \ i, i) == string.sub(reversed_string, j, j) then\n                table[i][j]\
    \ = table[i - 1][j - 1] + 1\n            else\n                table[i][j] = math.max(table[i\
    \ - 1][j], table[i][j - 1])\n            end\n        end\n    end\n    local\
    \ result = \"\"\n    local i = m - 1\n    local j = n - 1\n    while i > 0 and\
    \ j > 0 do\n        if string.sub(prefix, i, i) == string.sub(reversed_string,\
    \ j, j) then\n            result = result .. string.sub(prefix, i, i)\n      \
    \      i = i - 1\n            j = j - 1\n        elseif table[i - 1][j] > table[i][j\
    \ - 1] then\n            i = i - 1\n        else\n            j = j - 1\n    \
    \    end\n    end\n    local postfix = string.sub(prefix_reversed, prefix_len\
    \ - string.len(result) + 1, prefix_len)\n    return string .. postfix\nend", " \
    \   local prefix_len = _M.longest_palindrome_suffix(string)\n    local str_len\
    \ = string.len(string)\n    local prefix = string.sub(string, 1, str_len - prefix_len)\n\
    \    local reverse_prefix = _M.reverse(prefix)\n    return string.format(\"%s%s\"\
    , string, reverse_prefix)\nend", "    local reversed = string:reverse()\n    --\
    \ Try to find the longest palindromic suffix.\n    local palindrome_pattern =\
    \ \"(.*)\" .. string:sub(1, #string - 1)\n    local palindrome_suffix = string:match(palindrome_pattern)\
    \ or \"\"\n    return reversed:sub(1, #string - #palindrome_suffix) .. string\n\
    end", "    local reversed = string:reverse()\n    local prefix = string:sub(1,\
    \ -string:match(\"(.+)()$\"):len() - 1)\n    return reversed .. prefix\nend",
  "  local reversed = string.reverse(string)\n  -- Create the \"KMP\" string by concatenating\
    \ the supplied string, unique separator and the reversed string.\n  local kmp_string\
    \ = string .. \"!\" .. reversed\n  -- Compute the partial match table.\n  local\
    \ partial_match_table = compute_partial_match_table(kmp_string)\n  -- Find the\
    \ length of the longest palindromic postfix of the supplied string.\n  local longest_palindromic_postfix_length\
    \ = partial_match_table[#kmp_string]\n  -- Append the reverse of the prefix of\
    \ the supplied string to the end of the string.\n  local result = string .. string.sub(reversed,\
    \ 1, #string - longest_palindromic_postfix_length)\n  return result\nend", " \
    \   local mirror = string .. '$' .. string:reverse()\n    local n = mirror:len()\n\
    \    local z = ffi.new('int[?]', n)\n    local r = 0\n    local l = 0\n    for\
    \ i = 1, n - 1 do\n        if i > r then\n            r = i\n            l = i\n\
    \        end\n        z[i] = math.min(z[2 * l - i], r - i)\n        while mirror:sub(i\
    \ + z[i] + 1, i + z[i] + 1) == mirror:sub(i - z[i] - 1, i - z[i] - 1) do\n   \
    \         z[i] = z[i] + 1\n        end\n        if i + z[i] > r then\n       \
    \     r = i + z[i]\n            l = i\n        end\n    end\n    local prefix\
    \ = string:sub(1, string:len() - z[n])\n    return string .. prefix:reverse()\n\
    end", "  -- Find the longest palindromic suffix.\n  local longest_suffix = 1\n\
    \  for suffix_length = #string, 1, -1 do\n    local suffix = string:sub(suffix_length)\n\
    \    local prefix = string:sub(1, #string - suffix_length)\n    if suffix == prefix:reverse()\
    \ then\n      longest_suffix = suffix_length\n      break\n    end\n  end", " \
    \   local longest_possible_suffix_len = string.len(string)\n    while longest_possible_suffix_len\
    \ > 0 do\n        local suffix = string.sub(string, string.len(string) - longest_possible_suffix_len\
    \ + 1)\n        if is_palindrome(suffix) then\n            return string .. reverse(string.sub(string,\
    \ 1, string.len(string) - longest_possible_suffix_len))\n        end\n       \
    \ longest_possible_suffix_len = longest_possible_suffix_len - 1\n    end\n   \
    \ -- Edge case: string is empty or single char. This is palindrome already.\n\
    \    return string\nend", "    -- Find the longest palindromic suffix.\n    --\
    \ This is simply the longest suffix that is also a prefix of a string.\n    local\
    \ suffix_len = longest_prefix_match(string, reverse(string))\n    local string_prefix\
    \ = sub(string, 1, #string - suffix_len)\n    return string .. reverse(string_prefix)\n\
    end", "  local suffix = suffix_of_palindrome(string)\n  local prefix = string:sub(1,\
    \ string:len() - suffix:len())\n  local prefix_inverse = string.reverse(prefix)\n\
    \  return prefix_inverse .. string\nend", "    local mirror = string.reverse(string)\n\
    \    local full_string = string .. string.sub(mirror, 2)\n    local t = { [0]\
    \ = -1 }\n    local j = 0\n    for i = 1, #full_string do\n        while j >=\
    \ 0 and full_string:sub(j + 1, j + 1) ~= full_string:sub(i, i) do\n          \
    \  j = t[j]\n        end\n        j = j + 1\n        t[i] = j\n    end\n    return\
    \ string .. string.sub(mirror, t[#full_string] + 2)\nend", "    if is_palindrome(string)\
    \ then\n        return string\n    end", "\tlocal first_half = string\n\tlocal\
    \ second_half = ''\n\tlocal is_palindrome = function(string)\n\t\treturn string\
    \ == string:reverse()\n\tend\n\twhile not is_palindrome(first_half) do\n\t\tfirst_half\
    \ = first_half:sub(1, -2)\n\t\tsecond_half = second_half .. string:sub(-1)\n\t\
    end\n\treturn string .. second_half:reverse()\nend", "    local buf = {}\n   \
    \ local string_len = #string\n    local prefix_len = string_len\n    while not\
    \ is_palindrome(string) do\n        buf[prefix_len] = string:sub(1, prefix_len)\n\
    \        prefix_len = prefix_len - 1\n    end\n    return table.concat(buf) ..\
    \ string\nend", "    local prefix = string:sub(1, #string - get_longest_palindrome_suffix(string))\n\
    \    local postfix = string:sub(#string - get_longest_palindrome_suffix(string)\
    \ + 1)\n    return string .. reverse(prefix)\nend", "  -- Find the longest postfix\
    \ of supplied string that is a palindrome.\n  local suffix_len = longest_palindrome_length(string)\n\
    \  -- Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n  local string_prefix = string:sub(1, #string - suffix_len)\n\
    \  local string_prefix_reversed = string_prefix:reverse()\n  local string_with_palindrome_tail\
    \ = string .. string_prefix_reversed\n  return string_with_palindrome_tail\nend",
  "    local s_len = #string\n    local s_rev = reverse(string)\n    local max_palindrome_length\
    \ = 0\n    for i = 1, s_len do\n        local p_len = min(i, s_len - i + 1)\n\
    \        local substr = string:sub(i, i + p_len - 1)\n        local substr_rev\
    \ = s_rev:sub(s_len - i + 1, s_len - i + p_len)\n        if substr == substr_rev\
    \ then\n            max_palindrome_length = p_len\n        end\n    end\n    return\
    \ string .. s_rev:sub(s_len - max_palindrome_length + 2, s_len)\nend", "\tlocal\
    \ length = #string\n\tlocal reverse = utils.reverse(string)\n\tlocal prefix =\
    \ string:sub(1, (length+1)/2)\n\tlocal suffix = reverse:sub(1, length/2)\n\tlocal\
    \ longest_palindrome = lps.lps(prefix .. \"$\" .. suffix)\n\tlocal prefix_end\
    \ = length - longest_palindrome + 1\n\tlocal prefix_string = string:sub(1, prefix_end)\n\
    \tlocal suffix_string = utils.reverse(prefix_string)\n\treturn prefix_string ..\
    \ suffix_string\nend", "    local reverse = string:reverse()\n    local suffix_length\
    \ = string:find_suffix_palindrome_length()\n    local suffix = string:sub(string:len()\
    \ - suffix_length + 1)\n    local prefix = string:sub(1, string:len() - suffix_length)\n\
    \    return string .. reverse:sub(prefix:len() + 1)\nend", "  local reversed =\
    \ string:reverse()\n  local preffix_len = 0\n  while reversed:sub(1, preffix_len)\
    \ ~= string:sub(1, preffix_len) do\n    preffix_len = preffix_len + 1\n  end\n\
    \  return string .. reversed:sub(preffix_len + 1)\nend", "    local string_len\
    \ = #string\n    local reversed_prefix = string:reverse()\n    local reversed_suffix\
    \ = reversed_prefix:sub(1, string_len)\n    local matching_suffix = reversed_suffix:match(\"\
    (\" .. string .. \")$\")", "    local len = #string\n    local i = 1\n    local\
    \ p = nil\n    while i <= len do\n        local s = string:sub(1, i)\n       \
    \ if is_palindrome(s) then\n            p = s\n        end\n        i = i + 1\n\
    \    end\n    return string .. p:reverse()\nend", "    local string_len = #string\n\
    \    local string_reversed = string:reverse()\n    local string_reversed_prefix\
    \ = string_reversed:sub(1, string_len - 1)\n    local string_postfix = string:sub(string_len\
    \ - string_len, string_len)\n    local iter = string_len\n    local found = false\n\
    \    local pstring_postfix = string_postfix\n    local pstring_reversed_prefix\
    \ = string_reversed_prefix\n    while iter > 0 do\n        if pstring_postfix\
    \ == pstring_reversed_prefix then\n            found = true\n            break\n\
    \        end\n        pstring_postfix = string_postfix:sub(2, iter)\n        pstring_reversed_prefix\
    \ = string_reversed_prefix:sub(1, iter - 1)\n        iter = iter - 1\n    end\n\
    \    if found then\n        local string_prefix = string:sub(1, string_len - iter)\n\
    \        return string .. string_prefix:reverse()\n    else\n        return string\
    \ .. string_reversed\n    end\nend", "  local postfix = longest_palindromic_suffix(string)\n\
    \  local prefix = string:sub(1, string:len() - postfix:len())\n  local reverse_prefix\
    \ = prefix:reverse()\n  return string .. reverse_prefix\nend", "\tlocal len =\
    \ #string\n\tfor i = len, 1, -1 do\n\t\tlocal postfix = string:sub(i, len)\n\t\
    \tif is_palindrome(postfix) then\n\t\t\treturn string .. string:sub(1, i - 1):reverse()\n\
    \t\tend\n\tend\n\treturn string\nend", "  -- find the longest palindromic suffix\n\
    \  local i = 0\n  local j = #string\n  local k = j\n  while j >= 1 do\n    if\
    \ is_palindrome(string, i, j) then\n      break\n    end\n    j = j - 1\n  end\n\
    \  -- append the reverse of a prefix that comes before the palindromic suffix\n\
    \  local prefix = string:sub(1, k - j)\n  return string .. reverse(prefix)\nend",
  "  local to_check = ''\n  for i=1,#string do\n    to_check = string:sub(i)\n   \
    \ if is_palindrome(to_check) then\n      break\n    end\n  end\n  return string\
    \ .. string:sub(1, #string - #to_check):reverse()\nend", "  local res = string\n\
    \  for i=string:len(),1,-1 do\n    if is_palindrome(string:sub(1,i)) then\n  \
    \    res = res .. string:sub(i+1, -1):reverse()\n      break\n    end\n  end\n\
    \  return res\nend", "    local function is_palindrome(substring)\n        for\
    \ i = 1, #substring / 2 do\n            if substring:sub(i, i) ~= substring:sub(#substring\
    \ - i + 1, #substring - i + 1) then\n                return false\n          \
    \  end\n        end\n        return true\n    end", "    local function _reverse(string)\n\
    \        local reversed = \"\"\n        for i = #string, 1, -1 do\n          \
    \  reversed = reversed .. string:sub(i, i)\n        end\n        return reversed\n\
    \    end", "  -- Find the longest palindromic suffix of the string.\n  local palindrome_suffix\
    \ = string:sub(0, longest_palindromic_suffix(string) + 1)\n  -- Append the reverse\
    \ of the prefix before the palindromic suffix to the end of the string.\n  return\
    \ string .. string:sub(0, #string - #palindrome_suffix):reverse()\nend", "\tlocal\
    \ P = {}\n\tlocal m = #string\n\t-- Manacher's Algorithm\n\tP[1] = 1\n\tP[2] =\
    \ 2\n\tlocal C = 2\n\tlocal R = 2\n\tfor i = 3, m do\n\t\tlocal i_mirror = 2 *\
    \ C - i\n\t\tP[i] = 0\n\t\tif R > i then\n\t\t\tP[i] = math.min(R - i, P[i_mirror])\n\
    \t\tend\n\t\twhile i + P[i] <= m and i - P[i] > 0 do\n\t\t\tif string:sub(i +\
    \ P[i], i + P[i]) == string:sub(i - P[i], i - P[i]) then\n\t\t\t\tP[i] = P[i]\
    \ + 1\n\t\t\telse\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tif i + P[i] - 1 > R\
    \ then\n\t\t\tC = i\n\t\t\tR = i + P[i] - 1\n\t\tend\n\tend\n\tlocal maxlen =\
    \ 0\n\tlocal center = 0\n\tfor i = 1, m do\n\t\tif P[i] > maxlen then\n\t\t\t\
    maxlen = P[i]\n\t\t\tcenter = i\n\t\tend\n\tend\n\tlocal left = (center - maxlen)\
    \ / 2\n\tlocal right = (center + maxlen) / 2 - 1\n\tlocal append = string:sub(left\
    \ + 1, 1) .. string:sub(right + 1, m)\n\treturn append\nend", "  local postfix_length\
    \ = palindrome_length(string)\n  local prefix = string:sub(1, #string - postfix_length)\n\
    \  return string .. reverse(prefix)\nend", "    local palindrome = \"\"\n    local\
    \ reverse = string:reverse()\n    local last_index = #string\n    local min_len\
    \ = math.ceil(#string / 2)\n    for len = 1, min_len do\n        local prefix\
    \ = string:sub(1, len)\n        local postfix = reverse:sub(last_index - len +\
    \ 1, last_index)\n        if prefix == postfix then\n            palindrome =\
    \ string .. reverse:sub(len + 1, last_index)\n        end\n    end\n    return\
    \ palindrome\nend", "    local function is_palindrome(string)\n        local n\
    \ = #string\n        for i = 1, n // 2 do\n            if string:sub(i, i) ~=\
    \ string:sub(n - i + 1, n - i + 1) then\n                return false\n      \
    \      end\n        end\n        return true\n    end", "    local reversed =\
    \ string:reverse()\n    local concatenated = string .. \"$\" .. reversed\n   \
    \ local n = #concatenated\n    local z = {}\n    local l, r = 0, 0\n    for i\
    \ = 2, n do\n        if i > r then\n            l, r = i, i\n            while\
    \ r < n and concatenated:sub(r + 1, r + 1) == concatenated:sub(l - 1, l - 1) do\n\
    \                r = r + 1\n                l = l - 1\n            end\n     \
    \       z[i] = r - i + 1\n        else\n            local k = i - l + 1\n    \
    \        if z[k] < r - i + 1 then\n                z[i] = z[k]\n            else\n\
    \                l = i\n                while r < n and concatenated:sub(r + 1,\
    \ r + 1) == concatenated:sub(l - 1, l - 1) do\n                    r = r + 1\n\
    \                    l = l - 1\n                end\n                z[i] = r\
    \ - i + 1\n            end\n        end\n    end\n    local longest_palindrome_end\
    \ = 1\n    for i = 2, n do\n        if z[i] == i then\n            longest_palindrome_end\
    \ = i\n        end\n    end\n    return string .. reversed:sub(longest_palindrome_end\
    \ + 1)\nend", "    -- Reverse the string.\n    local reversed = string:reverse()\n\
    \    -- Find the longest postfix that is a palindrome.\n    local postfix = string:match(\"\
    (.*)(\" .. string .. \")$\")\n    -- Is the string a palindrome?\n    if postfix\
    \ then\n        -- String is a palindrome, return it.\n        return string\n\
    \    else\n        -- String is not a palindrome, return the palindrome which\
    \ begins with it.\n        return reversed .. string:sub(postfix:len() + 1)\n\
    \    end\nend", "    local length = #string\n    local reversed = string:reverse()\n\
    \    local sfx = string:sub(1, length)\n    local prefix_length = length - 1\n\
    \    local palindrome_length = 0\n    local result = nil\n    while prefix_length\
    \ > 0 do\n        if sfx == reversed:sub(length - prefix_length + 1, length) then\n\
    \            palindrome_length = prefix_length\n            break\n        end\n\
    \        prefix_length = prefix_length - 1\n    end\n    if palindrome_length\
    \ == 0 then\n        result = string\n    else\n        local prefix = string:sub(1,\
    \ palindrome_length)\n        result = string .. prefix:reverse()\n    end\n \
    \   return result\nend", "    local string_length = #string\n    local palindrome_suffix\
    \ = longest_palindrome_suffix(string)\n    return reverse(string:sub(1, string_length\
    \ - palindrome_suffix)) .. string\nend", "  local reversed = string:reverse()\n\
    \  local prefix = reversed:sub(string:len() + 1)\n  local longest_suffix = get_longest_palindromic_suffix(string)\n\
    \  return string .. prefix:sub(longest_suffix + 1)\nend", "    local reverse =\
    \ string:reverse()\n    local str = string..'#'..reverse\n    local len = #str\n\
    \    local z = {}\n    local l, r = 1, 1\n    for i = 2, len do\n        if i\
    \ <= r then\n            z[i] = math.min(r - i + 1, z[i - l + 1])\n        end\n\
    \        while i + z[i] <= len and str:sub(z[i] + 1, z[i] + 1) == str:sub(i +\
    \ z[i], i + z[i]) do\n            z[i] = z[i] + 1\n        end\n        if i +\
    \ z[i] - 1 > r then\n            l, r = i, i + z[i] - 1\n        end\n    end\n\
    \    local maxz = 0\n    local index = -1\n    for i = len - (#string) + 1, len\
    \ do\n        if z[i] > maxz then\n            maxz = z[i]\n            index\
    \ = i\n        end\n    end\n    local str2 = string:sub(1, #string - maxz)\n\
    \    local reverse2 = str2:reverse()\n    return reverse2..string\nend", "   \
    \ local string_length = string:len()\n    local res = string\n    local reversed_prefix\
    \ = string:reverse()\n    local max_palindrome_length = 0\n    local max_palindrome_index\
    \ = 0\n    for i = 1, string_length do\n        local substring = string:sub(1,\
    \ i)\n        local substring_reversed = substring:reverse()\n        local j\
    \ = reversed_prefix:find(substring_reversed, 1, true)\n        if j then\n   \
    \         local palindrome_length = j - 1\n            if palindrome_length >\
    \ max_palindrome_length then\n                max_palindrome_length = palindrome_length\n\
    \                max_palindrome_index = i\n            end\n        end\n    end\n\
    \    if max_palindrome_length > 0 then\n        res = res .. reversed_prefix:sub(1,\
    \ max_palindrome_length)\n    end\n    return res\nend", "    local length = #string\n\
    \    local i = 1\n    local is_palindrome = true\n    local m = 0\n    local mirror\
    \ = ''\n    while i <= length do\n        if string[i] == string[length] then\n\
    \            m = i\n            i = i + 1\n            length = length - 1\n \
    \       else\n            is_palindrome = false\n            break\n        end\n\
    \    end\n    if is_palindrome then\n        return string\n    end\n    local\
    \ palindrome = string .. string.reverse(string:sub(1, m - 1))\n    return palindrome\n\
    end", "    local palindrome_suffix_start = 1 + string.find(string, string.reverse(string),\
    \ 2, true)\n    local reversed_prefix = string.reverse(string.sub(string, 1, palindrome_suffix_start\
    \ - 1))\n    return string .. reversed_prefix\nend", "    local length = #string\n\
    \    local reversed = string:reverse()\n    local reversed_prefix = reversed:sub(1,\
    \ length)\n    local suffix_length = 0\n    while suffix_length < length do\n\
    \        suffix_length = suffix_length + 1\n        local prefix = string:sub(1,\
    \ length - suffix_length)\n        if prefix == reversed_prefix:sub(suffix_length\
    \ + 1) then\n            break\n        end\n    end\n    return string .. reversed:sub(suffix_length\
    \ + 1)\nend", "  local short = string:sub(1, #string - 1)\n  local long = string\
    \ .. short:reverse()\n  return long\nend", "    local shortest = string .. string:reverse()\n\
    \    local longest_suffix = find_longest_palindromic_suffix(string)\n    if longest_suffix\
    \ ~= string then\n        -- Palindromic suffix is not the entire string.\n  \
    \      -- Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n        shortest = string .. string:sub(longest_suffix\
    \ + 1):reverse()\n    end\n    return shortest\nend", "  -- Find the longest postfix\
    \ that is a palindrome.\n  local longest_palindrome_suffix = string:sub(1, longest_palindrome_suffix_len(string))\n\
    \  -- Calculate the prefix that comes before the palindromic suffix.\n  local\
    \ prefix = string:sub(longest_palindrome_suffix:len() + 1)\n  -- Append reversed\
    \ prefix.\n  local palindrome = string .. prefix:reverse()\n  return palindrome\n\
    end", "\t-- #string: length of string\n\t-- x: index in string\n\t-- i: index\
    \ in z\n\t-- z: table of [i] = length of palindromic substring that begins at\
    \ i in string\n\t-- a: index of the rightmost character in the palindromic suffix\n\
    \t-- b: index of the first character of the prefix before the palindromic suffix\n\
    \tlocal x, i, z, a, b = 1, 1, {}, 1, 1\n\t-- Find the longest palindromic suffix.\n\
    \t-- This part runs O(#string) times.\n\twhile x <= #string do\n\t\t-- If the\
    \ current character is outside the current palindromic suffix.\n\t\tif x > a then\n\
    \t\t\t-- Find the length of the palindromic suffix that starts at x.\n\t\t\tz[x]\
    \ = 1\n\t\t\t-- Expand the palindromic suffix by one character on both sides.\n\
    \t\t\twhile x + z[x] <= #string and string:sub(x - z[x], x - 1) == string:sub(x\
    \ + 1, x + z[x]) do\n\t\t\t\tz[x] = z[x] + 1\n\t\t\tend\n\t\t\t-- If the whole\
    \ string is palindromic.\n\t\t\tif x + z[x] > #string then\n\t\t\t\treturn string\n\
    \t\t\tend\n\t\t\t-- If the suffix has grown beyond its current boundary.\n\t\t\
    \tif x + z[x] - 1 > a then\n\t\t\t\t-- Record the position of the rightmost character\
    \ of the palindromic suffix.\n\t\t\t\ta = x + z[x] - 1\n\t\t\t\t-- Record the\
    \ position of the first character of the prefix before the palindromic suffix.\n\
    \t\t\t\tb = x\n\t\t\tend\n\t\telse\n\t\t\t-- If the current character is inside\
    \ the current palindromic suffix.\n\t\t\t-- Find its mirror position.\n\t\t\t\
    i = 2 * b - x\n\t\t\t-- If the mirror position is outside the current palindromic\
    \ suffix.\n\t\t\tif x + z[i] < a then\n\t\t\t", "    local start = 0\n    local\
    \ stop = #string\n    local prefix = string\n    local suffix = {}\n    while\
    \ stop > 0 do\n        if string.sub(prefix, 1, stop) == string.reverse(string.sub(prefix,\
    \ stop + 1)) then\n            start = stop\n            break\n        end\n\
    \        stop = stop - 1\n    end\n    suffix = string.sub(prefix, start + 1)\n\
    \    prefix = string.sub(prefix, 1, start)\n    return prefix .. string.reverse(suffix)\n\
    end", "  local string_length = #string\n  local suffix_index = 0\n  local suffix_palindrome_length\
    \ = 0\n  local palindrome_lengths = {}\n  local result = {}", "    local reverse\
    \ = string:reverse()\n    local postfix_start, postfix_length = string.find(string,\
    \ reverse, 1, true)\n    if postfix_start then\n        return string .. reverse:sub(postfix_length\
    \ + 1)\n    else\n        return string .. reverse\n    end\nend", "  local len\
    \ = string.len(string)\n  local rev = string.reverse(string)\n  local prefix_len\
    \ = match_longest_common_prefix(string, rev)\n  return string .. string.sub(rev,\
    \ prefix_len + 1, len)\nend", "\tlocal left, right = 1, #string\n\tlocal longest_palindrome_so_far\
    \ = 1\n\twhile left <= right do\n\t\tif string:sub(left, right) == string:sub(left,\
    \ right):reverse() then\n\t\t\tlongest_palindrome_so_far = right - left + 1\n\t\
    \tend\n\t\tleft = left + 1\n\t\tright = right - 1\n\tend\n\tlocal prefix = string:sub(longest_palindrome_so_far\
    \ + 1)\n\treturn string .. prefix:reverse()\nend", "\tlocal postfix_length = longest_palindromic_postfix(string)\n\
    \tlocal prefix = string:sub(1, string:len() - postfix_length)\n\tlocal prefix_reversed\
    \ = prefix:reverse()\n\treturn prefix_reversed .. string\nend", "\t-- Find the\
    \ longest suffix of the string that is a palindrome.\n\tlocal longest_suffix =\
    \ 0\n\tfor i = 1, #string do\n\t\tif string:sub(1, i) == string:sub(#string +\
    \ 1 - i, #string) then\n\t\t\tlongest_suffix = i\n\t\tend\n\tend", "    local\
    \ rev = string.reverse(string)\n    local substr = string.sub(string, 2)\n   \
    \ for i=string.len(substr),0,-1 do\n        local prefix = string.sub(substr,\
    \ 1, i)\n        local postfix = string.sub(rev, string.len(rev) - i + 1)\n  \
    \      if prefix == postfix then\n            return string .. string.sub(rev,\
    \ 1, string.len(rev) - i)\n        end\n    end\n    return string .. rev\nend",
  "\tlocal postfix_length = check_palindrome(string)\n\tlocal prefix = string:sub(1,\
    \ #string - postfix_length)\n\tlocal result = string .. prefix:reverse()\n\treturn\
    \ result\nend", '  local s = string', "    local max_postfix_palindrome_len, max_postfix_palindrome_pos\
    \ = find_max_postfix_palindrome(string)\n    local prefix = string:sub(1, max_postfix_palindrome_pos\
    \ - 1)\n    local prefix_reversed = prefix:reverse()\n    return string .. prefix_reversed\n\
    end", "    local string_length = #string\n    local match = {}\n    for i = 1,\
    \ string_length do\n        local prefix = string:sub(1, i)\n        local prefix_length\
    \ = #prefix\n        local prefix_length_i = prefix_length + 1\n        local\
    \ prefix_length_i_1 = prefix_length_i - 1\n        local prefix_i = prefix:sub(prefix_length_i,\
    \ prefix_length_i)\n        local prefix_i_1 = prefix:sub(prefix_length_i_1, prefix_length_i_1)\n\
    \        local j = prefix_length_i_1\n        while j > 0 and prefix_i_1 == prefix_i\
    \ do\n            match[j] = prefix_length_i\n            j = j - 1\n        \
    \    prefix_i_1 = prefix:sub(j, j)\n        end\n    end\n    local match_length\
    \ = #match\n    local match_length_1 = match_length - 1\n    local match_length_1_1\
    \ = match_length_1 - 1\n    local i = match_length_1\n    while i > 0 do\n   \
    \     if match[i] == match_length_1_1 then\n            local k = i - 1\n    \
    \        while k > 0 do\n                if match[k] == match_length_1_1 then\n\
    \                    i = k\n                end\n                k = k - 1\n \
    \           end\n            break\n        end\n        i = i - 1\n    end\n\
    \    local reverse_string = string:reverse()\n    return string .. reverse_string:sub(match_length\
    \ - i + 1, match_length_1)\nend", "    local string_reverse = string:reverse()\n\
    \    local suffix_length = find_palindrome_length(string, #string - 1, 0)\n  \
    \  return string .. string_reverse:sub(#string - suffix_length + 1)\nend", "\t\
    -- Find the longest palindromic suffix.\n\tlocal palindrome_end = nil\n\tfor i\
    \ = 1, #string do\n\t\tlocal sub = string:sub(1, i)\n\t\tif is_palindrome(sub)\
    \ then\n\t\t\tpalindrome_end = i\n\t\tend\n\tend", "    -- find the longest postfix\
    \ that is a palindrome\n    local max_palindrome_suffix = ''\n    for i = 1, #string\
    \ do\n        local suffix = string:sub(i)\n        if is_palindrome(suffix) then\n\
    \            max_palindrome_suffix = suffix\n            break\n        end\n\
    \    end", "    local palindrome_suffix = get_palindrome_suffix(string)\n    local\
    \ palindrome_prefix = string.reverse(string.sub(string, 1, #string - #palindrome_suffix))\n\
    \    return string .. palindrome_prefix\nend", "  local string_length = #string\n\
    \  local rev_string = string:reverse()\n  local palindrome_suffix = string_length\
    \ - rev_string:find(string) + 1\n  local prefix = string:sub(1, palindrome_suffix\
    \ - 1)\n  return string .. prefix:reverse()\nend", "  assert(type(string) == \"\
    string\")\n  local string_length = string:len()\n  local half_length = math.floor(string_length\
    \ / 2)\n  local longest_palindrome_length = 1\n  local longest_palindrome_start\
    \ = 1\n  for i = 1, half_length do\n    local odd_palindrome_length = expand_palindrome(string,\
    \ i, i)\n    local even_palindrome_length = expand_palindrome(string, i, i + 1)\n\
    \    local palindrome_length = math.max(odd_palindrome_length, even_palindrome_length)\n\
    \    if palindrome_length > longest_palindrome_length then\n      longest_palindrome_length\
    \ = palindrome_length\n      longest_palindrome_start = i - (palindrome_length\
    \ - 1) / 2\n    end\n  end\n  local prefix = string:sub(1, longest_palindrome_start\
    \ - 1)\n  return string .. string:reverse():sub(prefix:len() + 1)\nend", "   \
    \ local longest_palindrome_suffix = find_palindrome_suffix(string)\n    local\
    \ string_prefix = string:sub(1, #string - #longest_palindrome_suffix)\n    return\
    \ string .. string_prefix:reverse()\nend", "  local prefix_size = longest_palindrome_size(string)\n\
    \  local prefix = string:sub(1, string:len() - prefix_size)\n  local reverse_prefix\
    \ = prefix:reverse()\n  return reverse_prefix .. string\nend", "    local r =\
    \ string.reverse(string)\n    local l = #string", "  local reverse = string.reverse(string)\n\
    \  local longest_suffix_palindrome = longest_suffix_palindrome(string .. ' ' ..\
    \ reverse)\n  local prefix = string.sub(string, 1, string.len(string) - longest_suffix_palindrome)\n\
    \  return string .. string.reverse(prefix)\nend", "    local reversed = string:reverse()\n\
    \    local start, finish = 0, #string\n    for i = 1, #string do\n        if string:sub(1,\
    \ i) == reversed:sub(#string - i + 1, #string) then\n            start = i\n \
    \       end\n    end\n    return string:sub(1, start) .. reversed:sub(start, finish)\n\
    end", "    local rev = reverse(string)\n    local res, i = max_palindrome_postfix(string)\n\
    \    return string .. reverse(string:sub(1, i))\nend", "    local suffix_len =\
    \ longest_palindrome_suffix(string)\n    return string .. string:sub(1, string:len()\
    \ - suffix_len):reverse()\nend", "\tlocal len = #string\n\tlocal suffix, suffix_len\
    \ = find_palindrome_suffix(string)\n\tlocal reverse_prefix = reverse(string:sub(1,\
    \ len - suffix_len))\n\treturn reverse_prefix .. string\nend", "    local reverse\
    \ = string:reverse()\n    local string_length = #string\n    local suffix_length\
    \ = 0\n    local suffix_end = nil\n    local suffix_start = nil\n    local prefix_length\
    \ = 0\n    local prefix_end = nil\n    local prefix_start = nil\n    local best_suffix_length\
    \ = 0\n    local best_suffix_end = nil\n    local best_suffix_start = nil\n  \
    \  for length = 1, string_length do\n        local suffix_start = string_length\
    \ - length + 1\n        local suffix_end = string_length\n        local prefix_start\
    \ = 1\n        local prefix_end = length\n        local suffix = string:sub(suffix_start,\
    \ suffix_end)\n        local prefix = string:sub(prefix_start, prefix_end)\n \
    \       if suffix == prefix then\n            best_suffix_length = length\n  \
    \          best_suffix_start = suffix_start\n            best_suffix_end = suffix_end\n\
    \        end\n    end\n    return string .. reverse:sub(best_suffix_start, best_suffix_end\
    \ - 1)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
