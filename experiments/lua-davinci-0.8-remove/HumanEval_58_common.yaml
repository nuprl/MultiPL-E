name: HumanEval_58_common
language: lua
prompt: "-- Return sorted unique common elements for two lists.\nlocal function common(l1,\
  \ l2)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = common\n\
  \    lu.assertEquals(candidate({1, 4, 3, 34, 653, 2, 5}, {5, 7, 1, 5, 9, 653, 121}),\
  \ {1, 5, 653})\n    lu.assertEquals(candidate({5, 3, 2, 8}, {3, 2}), {2, 3})\n \
  \   lu.assertEquals(candidate({4, 3, 2, 8}, {3, 2, 4}), {2, 3, 4})\n    lu.assertEquals(candidate({4,\
  \ 3, 2, 8}, {}), {})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local a = {}\n  local function add(v)\n    if not a[v] then\n   \
    \   a[v] = true\n      return true\n    end\n  end\n  return setmetatable(table.filter(l1,\
    \ add), {__metatable = 'set'})\nend", "  local res = {}\n  for _, v in ipairs(l1)\
    \ do\n    if contains(l2, v) then\n      table.insert(res, v)\n    end\n  end\n\
    \  table.sort(res)\n  return res\nend", "\tlocal l = {}\n\tlocal f = {}\n\tlocal\
    \ lr = {}\n\tfor _, v in ipairs(l1) do\n\t\tl[v] = true\n\tend\n\tfor _, v in\
    \ ipairs(l2) do\n\t\tif l[v] then\n\t\t\ttable.insert(lr, v)\n\t\t\tf[v] = true\n\
    \t\tend\n\tend\n\tfor _, v in ipairs(l1) do\n\t\tif not f[v] then\n\t\t\ttable.insert(lr,\
    \ v)\n\t\tend\n\tend\n\treturn lr\nend", "    local tmp = {}\n    for i, v in\
    \ ipairs(l1) do\n        if idx(l2, v) ~= nil then\n            tmp[#tmp+1] =\
    \ v\n        end\n    end\n    if #tmp > 0 then\n        table.sort(tmp)\n   \
    \     return tmp\n    end\nend", "  return unique(sorted_tables(l1, l2))\nend",
  "    if #l1 < #l2 then\n        return common(l2, l1)\n    end\n    local res =\
    \ {}\n    for _, v in ipairs(l1) do\n        for _, v2 in ipairs(l2) do\n    \
    \        if v == v2 then\n                table.insert(res, v)\n            end\n\
    \        end\n    end\n    return res\nend", "    if not (l1 and l2) then return\
    \ {} end\n    local t = {}\n    for k, v in pairs(l1) do\n        if l2[k] then\
    \ t[k] = v end\n    end\n    local u = {}\n    for k, v in pairs(t) do u[#u+1]\
    \ = v end\n    table.sort(u)\n    return u\nend", "\tlocal h = {}\n\tfor _, v\
    \ in ipairs(l1) do\n\t\tif elem(v, l2) then\n\t\t\ttable.insert(h, v)\n\t\tend\n\
    \tend\n\treturn h\nend", "    -- Order by length of list.\n    if #l1 > #l2 then\n\
    \        l1, l2 = l2, l1\n    end\n    -- Determine common elements.\n    local\
    \ t = {}\n    for _, i in ipairs(l1) do\n        if utils.contains(l2, i) then\n\
    \            t[#t+1] = i\n        end\n    end\n    -- Return sorted list.\n \
    \   table.sort(t)\n    return t\nend", "  local t1 = {}\n  local t2 = {}\n  for\
    \ _, v in ipairs(l1) do\n    t1[v] = true\n  end\n  for _, v in ipairs(l2) do\n\
    \    t2[v] = true\n  end\n  local t = {}\n  for k, _ in pairs(t1) do\n    if t2[k]\
    \ then\n      t[#t+1] = k\n    end\n  end\n  return t\nend", "    local t = {}\n\
    \    for _,v in ipairs(l1) do\n        if contains(l2, v) then\n            t[#t+1]\
    \ = v\n        end\n    end\n    return t\nend", "  local seen, c = {}, {}\n \
    \ for _, v in ipairs(l1) do seen[v] = true end\n  for _, v in ipairs(l2) do if\
    \ seen[v] then c[#c+1] = v end end\n  sort(c)\n  return c\nend", "\tlocal ret\
    \ = {}\n\tfor k,v in pairs(l1) do\n\t\tif l2[k] then\n\t\t\ttable.insert(ret,\
    \ k)\n\t\tend\n\tend\n\treturn ret\nend", "\tlocal res = {}\n\tfor _, s in ipairs(l1)\
    \ do\n\t\tfor _, t in ipairs(l2) do\n\t\t\tif s == t then\n\t\t\t\tres[#res +\
    \ 1] = s\n\t\t\tend\n\t\tend\n\tend\n\ttable.sort(res)\n\treturn res\nend", " \
    \   local t = {}\n    for _, v in ipairs(l1) do\n        if util.contains(l2,\
    \ v) then\n            t[#t+1] = v\n        end\n    end\n    if #t > 0 then\n\
    \        table.sort(t)\n        return t\n    end\nend", "  local result = {}\n\
    \  for i = 1, #l1 do\n    for j = 1, #l2 do\n      if l1[i] == l2[j] then\n  \
    \      result[#result + 1] = l1[i]\n      end\n    end\n  end\n  table.sort(result)\n\
    \  return result\nend", "\tlocal r = {}\n\tfor i, v in ipairs(l1) do\n\t\tif i\
    \ > #l2 then\n\t\t\tbreak\n\t\tend\n\t\tif v == l2[i] then\n\t\t\tr[#r + 1] =\
    \ v\n\t\tend\n\tend\n\treturn r\nend", "    local res = {}\n    for _, v in ipairs(l1)\
    \ do\n        if table.index(l2, v) then\n            table.insert_unique(res,\
    \ v)\n        end\n    end\n    table.sort(res)\n    return res\nend", "  assert(type(l1)\
    \ == \"table\" and type(l2) == \"table\")\n  local res = {}\n  for _, v in ipairs(l1)\
    \ do\n    for _, v2 in ipairs(l2) do\n      if v == v2 then\n        if not contains(res,\
    \ v) then\n          table.insert(res, v)\n        end\n      end\n    end\n \
    \ end\n  table.sort(res)\n  return res\nend", "  local ret = {}\n  local i = 1\n\
    \  local x\n  while i <= #l1 do\n    if not x or x ~= l1[i] then\n      if find(l2,\
    \ l1[i]) then\n        ret[#ret + 1] = l1[i]\n      end\n      x = l1[i]\n   \
    \ end\n    i = i + 1\n  end\n  return ret\nend", "    local l3 = {}\n    for i\
    \ = 1, #l1 do\n        for j = 1, #l2 do\n            if l1[i] == l2[j] then\n\
    \                l3[#l3 + 1] = l1[i]\n            end\n        end\n    end\n\
    \    return table.sort(l3)\nend", "\tlocal s2 = {}\n\tlocal r = {}\n\t\n\tfor\
    \ _, v in ipairs(l2) do\n\t\ts2[v] = true\n\tend\n\t\n\tfor _, v in ipairs(l1)\
    \ do\n\t\tif s2[v] then\n\t\t\ttable.insert(r, v)\n\t\tend\n\tend\n\t\n\ttable.sort(r)\n\
    \t\n\treturn r\nend", "\tlocal c, n = {}, 0\n\tfor _, v in ipairs(l1) do\n\t\t\
    if find(l2, v) then\n\t\t\tn = n + 1\n\t\t\tc[n] = v\n\t\tend\n\tend\n\tsort(c)\n\
    \treturn c\nend", "\tlocal res = {}\n\tfor _, v in ipairs(l1) do\n\t\tif _M.contains(l2,\
    \ v) then\n\t\t\tres[#res+1] = v\n\t\tend\n\tend\n\tsort(res)\n\treturn unique(res)\n\
    end", "  local common_elms = {}\n  for _, elm in ipairs(l1) do\n    if has_element(l2,\
    \ elm) then table.insert(common_elms, elm) end\n  end\n  return unique(common_elms)\n\
    end", "  local result = {}\n  local seen = {}\n  for i=1,#l1 do seen[l1[i]] =\
    \ true end\n  for i=1,#l2 do\n    if seen[l2[i]] then\n      result[#result+1]\
    \ = l2[i]\n    end\n  end\n  sort(result)\n  return result\nend", "    if not\
    \ l1 or not l2 then return end\n    local c = {}\n    for _,e in ipairs(l1) do\n\
    \        if contains(l2, e) then\n            table.insert(c, e)\n        end\n\
    \    end\n    return unique(c)\nend", "    local c = {}\n    for _, v in ipairs(l1)\
    \ do\n        for _, w in ipairs(l2) do\n            if v == w then table.insert(c,\
    \ v) end\n        end\n    end\n    table.sort(c)\n    return c\nend", "    local\
    \ ht = {}\n    for _, v in ipairs(l1) do\n        ht[v] = 1\n    end\n    for\
    \ _, v in ipairs(l2) do\n        if ht[v] then\n            ht[v] = 2\n      \
    \  end\n    end\n    local out = {}\n    for k, v in pairs(ht) do\n        if\
    \ v == 2 then\n            table.insert(out, k)\n        end\n    end\n    table.sort(out)\n\
    \    return out\nend", "\tlocal t = {}\n\tfor _, v in ipairs(l1) do\n\t\tif table.has_value(l2,\
    \ v) then\n\t\t\ttable.insert(t, v)\n\t\tend\n\tend\n\treturn table.unique(t)\n\
    end", "  local m1 = {};\n  for _, l in ipairs(l1) do\n    m1[l] = true;\n  end\n\
    \  local m2 = {};\n  for _, l in ipairs(l2) do\n    if m1[l] then\n      m2[l]\
    \ = true;\n    end\n  end\n  local t = {};\n  for l in pairs(m2) do\n    t[#t+1]\
    \ = l;\n  end\n  return table.sort(t);\nend", "\tlocal keys = {}\n\tlocal ret\
    \ = {}\n\tfor _, v in ipairs(l1) do\n\t\tkeys[v] = 1\n\tend\n\tfor _, v in ipairs(l2)\
    \ do\n\t\tif keys[v] then\n\t\t\tret[#ret + 1] = v\n\t\tend\n\tend\n\ttable.sort(ret)\n\
    \treturn ret\nend", "\t-- insert elements from l1 and l2 into a table\n\tlocal\
    \ t = {}\n\tfor _, e in ipairs(l1) do\n\t\tt[e] = (t[e] or 0) + 1\n\tend\n\tfor\
    \ _, e in ipairs(l2) do\n\t\tt[e] = (t[e] or 0) + 1\n\tend\n\t-- return elements\
    \ that are in both lists\n\tlocal c = {}\n\tfor e, cnt in pairs(t) do\n\t\tif\
    \ cnt > 1 then\n\t\t\ttable.insert(c, e)\n\t\tend\n\tend\n\ttable.sort(c)\n\t\
    return c\nend", "  local t = {}\n  for _,v in ipairs(l1) do\n    if bin.find(l2,\
    \ v) then t[#t+1] = v end\n  end\n  sort(t)\n  return t\nend", "  local s = {}\n\
    \  for i = 1, #l1 do\n    if index_of(l2, l1[i]) ~= nil then\n      insert(s,\
    \ l1[i])\n    end\n  end\n  return unique(s)\nend", "  local r = {}\n  for _,v\
    \ in ipairs(l1) do\n    if f(v, l2) then\n      r[#r+1] = v\n    end\n  end\n\
    \  return r\nend", "    local t1 = type(l1)\n    local t2 = type(l2)\n    if t1\
    \ ~= 'table' or t2 ~= 'table' then\n        return { }\n    end\n    local u =\
    \ {}\n    for _, v in ipairs(l1) do\n        if hasvalue(l2, v) then\n       \
    \     table.insert(u, v)\n        end\n    end\n    return sort(u)\nend", "  --sort\
    \ elements\n  sort(l1)\n  sort(l2)\n  --return common elements\n  local common\
    \ = {}\n  local i1, i2 = 1, 1\n  while i1 <= #l1 and i2 <= #l2 do\n    local v1,\
    \ v2 = l1[i1], l2[i2]\n    if v1 == v2 then\n      common[#common + 1] = v1\n\
    \      i1 = i1 + 1\n      i2 = i2 + 1\n    elseif v1 < v2 then\n      i1 = i1\
    \ + 1\n    else\n      i2 = i2 + 1\n    end\n  end\n  return common\nend", " \
    \   local res = {}\n    for _, v in ipairs(l1) do\n        if not tcontains(res,\
    \ v) and tcontains(l2, v) then\n            tinsert(res, v)\n        end\n   \
    \ end\n    return res\nend", "    local c, o = {}\n    for _, i in ipairs(l1)\
    \ do\n        if not o[i] then\n            o[i] = true\n            c[#c+1] =\
    \ i\n        end\n    end\n    for _, i in ipairs(l2) do\n        if not o[i]\
    \ then\n            o[i] = true\n            c[#c+1] = i\n        end\n    end\n\
    \    sort(c)\n    return c\nend", "\tlocal result = {}\n\tfor _, v in ipairs(l1)\
    \ do\n\t\tfor _, v2 in ipairs(l2) do\n\t\t\tif v == v2 then\n\t\t\t\tresult[#result\
    \ + 1] = v\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\tend\n\ttable.sort(result)\n\t\
    return result\nend", "\treturn sorted_unique(common_unsorted(l1, l2))\nend", "\t\
    local ret = {}\n\tlocal keys = {}\n\tfor _,val in ipairs(l1) do\n\t\tif l2[val]\
    \ then\n\t\t\tkeys[val] = true\n\t\tend\n\tend\n\tfor k,_ in pairs(keys) do\n\t\
    \ttable.insert(ret, k)\n\tend\n\ttable.sort(ret)\n\treturn ret\nend", "\tlocal\
    \ t = {}\n\tfor _, v in ipairs(l1) do\n\t\tif in_table(v, l2) then\n\t\t\tt[#t+1]\
    \ = v\n\t\tend\n\tend\n\treturn sorted_unique(t)\nend", "  -- return ordered_set.union(l1,\
    \ l2)\n  local i1, i2 = 1, 1\n  local results = {}\n  while i1 <= #l1 and i2 <=\
    \ #l2 do\n    local a, b = l1[i1], l2[i2]\n    if a == b then\n      table.insert(results,\
    \ a)\n      i1 = i1 + 1\n      i2 = i2 + 1\n    elseif a < b then\n      i1 =\
    \ i1 + 1\n    else\n      i2 = i2 + 1\n    end\n  end\n  return results\nend",
  "\tlocal l = {}\n\tlocal seen = {}\n\tlocal r = {}\n\tfor _, i in ipairs(l1) do\n\
    \t\tseen[i] = true\n\t\ttable.insert(l, i)\n\tend\n\tfor _, i in ipairs(l2) do\n\
    \t\tif seen[i] then\n\t\t\ttable.insert(r, i)\n\t\telse\n\t\t\ttable.insert(l,\
    \ i)\n\t\tend\n\tend\n\treturn r, l\nend", "  local r = {}\n  for k,v in pairs(l1)\
    \ do\n    if l2[k] then r[k] = true end\n  end\n  return key_sort(r)\nend", " \
    \   local s = {}\n    local t = {}\n    for _, v in ipairs(l1) do s[v] = true\
    \ end\n    for _, v in ipairs(l2) do\n        if s[v] then t[#t+1] = v end\n \
    \   end\n    table.sort(t)\n    return t\nend", "    local l = {}\n    for i =\
    \ 1, #l1 do\n        local v = l1[i]\n        if find(l2, v) and not find(l, v)\
    \ then\n            l[#l + 1] = v\n        end\n    end\n    sort(l)\n    return\
    \ l\nend", "\tlocal res = {}\n\tlocal i1, i2 = 1, 1\n\tlocal n1, n2 = #l1, #l2\n\
    \twhile i1 <= n1 and i2 <= n2 do\n\t\tlocal v1, v2 = l1[i1], l2[i2]\n\t\tif v1\
    \ == v2 then\n\t\t\tres[#res + 1] = v1\n\t\t\ti1 = i1 + 1\n\t\t\ti2 = i2 + 1\n\
    \t\telseif v1 < v2 then\n\t\t\ti1 = i1 + 1\n\t\telse\n\t\t\ti2 = i2 + 1\n\t\t\
    end\n\tend\n\treturn res\nend", "    local t = {}\n    for _, x in ipairs(l1)\
    \ do\n        if utils.contains(l2, x) then\n            table.insert(t, x)\n\
    \        end\n    end\n    return utils.uniq(t)\nend", "    local l3 = {}\n  \
    \  for _, v in ipairs(l1) do\n        l3[v] = true\n    end\n    for _, v in ipairs(l2)\
    \ do\n        if l3[v] then\n            l3[v] = nil\n            l3[#l3 + 1]\
    \ = v\n        end\n    end\n    table.sort(l3)\n    return l3\nend", "    --\
    \ copy list\n    local l = {}\n    for k, v in pairs(l1) do\n        l[k] = v\n\
    \    end\n    -- sort list\n    table.sort(l)\n    -- remove elements of the other\
    \ list\n    for _, v in ipairs(l2) do\n        local i = table.binsearch(l, v)\n\
    \        if i ~= nil then\n            table.remove(l, i)\n        end\n    end\n\
    \    -- return unique elements\n    return l\nend", "  local res = {}\n  for k,\
    \ v in pairs(l1) do\n    if l2[k] == v then\n      res[k] = v\n    end\n  end\n\
    \  return sort(res)\nend", "  return sorted_unique(keys(indexes(l1, l2)))\nend",
  "\tlocal t1 = {}\n\tlocal t2 = {}\n\tlocal t = {}\n\tfor _,v in ipairs(l1) do t1[v]\
    \ = true end\n\tfor _,v in ipairs(l2) do t2[v] = true end\n\tfor k,_ in pairs(t1)\
    \ do if t2[k] then t[#t+1] = k end end\n\tlocal ret = {}\n\tfor _,v in ipairs(t)\
    \ do ret[#ret+1] = v end\n\ttable.sort(ret)\n\treturn ret\nend", "\tlocal common\
    \ = {}\n\tfor k, v in pairs(l1) do\n\t\tif l2[k] then\n\t\t\tcommon[#common +\
    \ 1] = v\n\t\tend\n\tend\n\ttable.sort(common)\n\treturn common\nend", "\tlocal\
    \ r, s = {}, {}\n\tfor _, v in ipairs(l1) do r[v] = true end\n\tfor _, v in ipairs(l2)\
    \ do if r[v] then s[#s+1] = v end end\n\treturn sortedKeys(s)\nend", "    local\
    \ ret = {}\n    for _, v in ipairs(l1) do\n        if tb.search_unsorted(l2, v)\
    \ then\n            if not tb.search_unsorted(ret, v) then\n                tb.insert_sorted(ret,\
    \ v)\n            end\n        end\n    end\n    return ret\nend", "  local t\
    \ = {}\n  local n = #l1\n  local n2 = #l2\n  local t2 = {}\n  local nt2 = 0\n\
    \  for i = 1, n do\n    local v = l1[i]\n    t[v] = (t[v] or 0) + 1\n  end\n \
    \ for i = 1, n2 do\n    local v = l2[i]\n    local c = t[v]\n    if c and c >\
    \ 0 then\n      t2[nt2 + 1] = v\n      nt2 = nt2 + 1\n      t[v] = c - 1\n   \
    \ end\n  end\n  sort(t2)\n  return t2\nend", "    local res = {}\n    for _, a\
    \ in ipairs(l1) do\n        for _, b in ipairs(l2) do\n            if a == b then\n\
    \                table.insert(res, a)\n            end\n        end\n    end\n\
    \    if #res > 0 then\n        table.sort(res)\n        return res\n    end\n\
    end", "  -- FIXME.\n  --local t = {}\n  --for i = 1,#l1 do\n  --  local v = l1[i]\n\
    \  --  t[v] = v\n  --end\n  --local i = 1\n  --for j = 1,#l2 do\n  --  local v\
    \ = l2[j]\n  --  if t[v] then\n  --    l1[i] = v\n  --    i = i + 1\n  --  end\n\
    \  --end\n  --return l1\n  local l = {}\n  for i = 1,#l1 do\n    local v = l1[i]\n\
    \    if index_of(l2, v) then\n      l[#l+1] = v\n    end\n  end\n  return l\n\
    end", "\t-- convert to a set\n\tlocal s1 = {}\n\tfor _, v in ipairs(l1) do\n\t\
    \ts1[v] = true\n\tend\n\tlocal s2 = {}\n\tfor _, v in ipairs(l2) do\n\t\ts2[v]\
    \ = true\n\tend\n\t-- get common elements from the union of the sets\n\tlocal\
    \ l = {}\n\tfor k, _ in pairs(s1) do\n\t\tif s2[k] then\n\t\t\ttable.insert(l,\
    \ k)\n\t\tend\n\tend\n\t-- sort by name\n\ttable.sort(l, function(a, b) return\
    \ a.name < b.name end)\n\treturn l\nend", "\tlocal p1, p2 = 1, 1\n\tlocal l3 =\
    \ {}\n\tlocal i3 = 0\n\twhile p1 <= #l1 and p2 <= #l2 do\n\t\tif l1[p1] == l2[p2]\
    \ then\n\t\t\ti3 = i3 + 1\n\t\t\tl3[i3] = l1[p1]\n\t\t\tp1 = p1 + 1\n\t\t\tp2\
    \ = p2 + 1\n\t\telseif l1[p1] < l2[p2] then\n\t\t\tp1 = p1 + 1\n\t\telse\n\t\t\
    \tp2 = p2 + 1\n\t\tend\n\tend\n\treturn l3\nend", "\tlocal common = {}\n\tfor\
    \ _, name in ipairs(l1) do\n\t\tif utils.table.hasval(l2, name) then\n\t\t\ttable.insert(common,\
    \ name)\n\t\tend\n\tend\n\treturn utils.table.uniq(common)\nend", "  local function\
    \ same(l1, l2)\n    local function s(t) return set(l1, t) end\n    return seq.zip(seq.map(s,\
    \ l2))\n  end\n  return seq.unique(same(l1, l2))\nend", "  local common, pos =\
    \ {}, 1\n  for _, v in ipairs(l1) do\n    if has_value(l2, v) then\n      common[pos]\
    \ = v\n      pos = pos + 1\n    end\n  end\n  return common\nend", "    local\
    \ l3 = {}\n    for _, v in ipairs(l1) do\n        if util.contains(l2, v) then\n\
    \            table.insert(l3, v)\n        end\n    end\n    table.sort(l3)\n \
    \   return l3\nend", "\tlocal temp = {}\n\tfor _, v in ipairs(l1) do\n\t\ttemp[v]\
    \ = (temp[v] or 0) + 1\n\tend\n\tlocal ret = {}\n\tfor _, v in ipairs(l2) do\n\
    \t\tif temp[v] then\n\t\t\ttemp[v] = temp[v] - 1\n\t\t\tif temp[v] == 0 then\n\
    \t\t\t\ttemp[v] = nil\n\t\t\tend\n\t\t\tret[#ret + 1] = v\n\t\tend\n\tend\n\t\
    table.sort(ret)\n\treturn ret\nend", "    local k, t = {}, {}\n    for i = 1,\
    \ #l1 do k[l1[i]] = true end\n    for i = 1, #l2 do if k[l2[i]] then t[#t+1] =\
    \ l2[i] end end\n    return sorted(t)\nend", "  local o = {}\n  for _, v in ipairs(l1)\
    \ do\n    if in_list(v, l2) then o[#o+1] = v end\n  end\n  return o\nend", "\t\
    local ret, cnt1, cnt2 = {}, #l1, #l2\n\tif cnt1 == 0 or cnt2 == 0 then return\
    \ ret end\n\tif cnt1 == 1 then\n\t\tif cnt2 == 1 then\n\t\t\tif l1[1] == l2[1]\
    \ then ret[1] = l1[1] end\n\t\telse\n\t\t\tfor _, e in ipairs(l2) do\n\t\t\t\t\
    if l1[1] == e then\n\t\t\t\t\tret[1] = e\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\t\
    end\n\t\tend\n\telseif cnt2 == 1 then\n\t\tfor _, e in ipairs(l1) do\n\t\t\tif\
    \ l2[1] == e then\n\t\t\t\tret[1] = e\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\telse\n\
    \t\tlocal sml, lrg, cnt = l1, l2, 0\n\t\tif cnt1 > cnt2 then sml, lrg, cnt = l2,\
    \ l1, cnt2 else cnt = cnt1 end\n\t\tfor _, e in ipairs(sml) do\n\t\t\tfor _, e2\
    \ in ipairs(lrg) do\n\t\t\t\tif e == e2 then\n\t\t\t\t\tcnt = cnt + 1\n\t\t\t\t\
    \tret[cnt] = e\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tif cnt >\
    \ 1 then\n\t\t\tfor i = 2, cnt do\n\t\t\t\tlocal j = i\n\t\t\t\twhile j > 1 and\
    \ ret[j] < ret[j - 1] do\n\t\t\t\t\tret[j], ret[j - 1] = ret[j - 1], ret[j]\n\t\
    \t\t\t\tj = j - 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn ret\nend",
  "  local t = {}\n  for _, v in ipairs(l1) do\n    t[v] = true\n  end\n  local ret\
    \ = {}\n  for _, v in ipairs(l2) do\n    if t[v] then\n      table.insert(ret,\
    \ v)\n    end\n  end\n  table.sort(ret)\n  return ret\nend", "\tlocal list = {}\n\
    \tfor _, a in ipairs(l1) do\n\t\tif contains(l2, a) then\n\t\t\tif not contains(list,\
    \ a) then\n\t\t\t\ttable.insert(list, a)\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ list\nend", "  local t = {}\n  for i = 1, #l1 do\n    for j = 1, #l2 do\n  \
    \    if l1[i] == l2[j] then\n        t[#t + 1] = l1[i]\n      end\n    end\n \
    \ end\n  if #t > 0 then\n    table.sort(t)\n    return t\n  end\nend", "  local\
    \ e,r = {},{}\n  for _,v in ipairs(l1) do e[v] = true end\n  for _,v in ipairs(l2)\
    \ do if e[v] then r[#r+1] = v end end\n  table.sort(r)\n  return r\nend", "  local\
    \ c = {}\n  for _, v in ipairs(l1) do\n    for _, w in ipairs(l2) do\n      if\
    \ v == w then\n        table.insert(c, v)\n      end\n    end\n  end\n  return\
    \ unique(c)\nend", "  local ret = {}\n  if l1 and l2 then\n    local lookup =\
    \ {}\n    for _, v in ipairs(l1) do\n      lookup[v] = (lookup[v] or 0) + 1\n\
    \    end\n    for _, v in ipairs(l2) do\n      if lookup[v] then\n        table.insert(ret,\
    \ v)\n        lookup[v] = nil\n      end\n    end\n  end\n  return ret\nend",
  "  local t1 = {}\n  local t2 = {}\n  local ret = {}\n  for _, v in ipairs(l1) do\n\
    \    t1[v] = 1\n  end\n  for _, v in ipairs(l2) do\n    t2[v] = 1\n  end\n  for\
    \ k, _ in pairs(t1) do\n    if t2[k] then\n      table.insert(ret, k)\n    end\n\
    \  end\n  table.sort(ret)\n  return ret\nend", "\tlocal c1 = {};\n\tlocal c2 =\
    \ {};\n\tlocal r = {};\n\tfor _, v in ipairs(l1) do\n\t\tc1[v] = true;\n\tend\n\
    \tfor _, v in ipairs(l2) do\n\t\tc2[v] = true;\n\tend\n\tfor k, _ in pairs(c1)\
    \ do\n\t\tif c2[k] then\n\t\t\tr[#r + 1] = k;\n\t\tend\n\tend\n\treturn sort_unique(r);\n\
    end", "    local t = {}\n    for _,v in ipairs(l1) do\n        t[v] = (t[v] or\
    \ 0) + 1\n    end\n    for _,v in ipairs(l2) do\n        t[v] = (t[v] or 0) +\
    \ 1\n    end\n    local res = {}\n    for k,v in pairs(t) do\n        if v > 1\
    \ then table.insert(res, k) end\n    end\n    table.sort(res)\n    return res\n\
    end", "\tif not (l1 and l2) then return {} end\n\tlocal a = {}\n\tfor v in l1:gmatch(\"\
    ([^,]+)\") do a[v] = true end\n\tlocal b = {}\n\tfor v in l2:gmatch(\"([^,]+)\"\
    ) do b[v] = true end\n\tlocal c = {}\n\tfor k in pairs(a) do if b[k] then c[#c+1]\
    \ = k end end\n\ttable.sort(c)\n\treturn c\nend", "  local s = {}\n  for k, v\
    \ in pairs(l1) do s[v] = true end\n  for k, v in pairs(l2) do s[v] = true end\n\
    \  local r = {}\n  for k, v in pairs(s) do table.insert(r, k) end\n  table.sort(r)\n\
    \  return r\nend", "  local map, list = {}, {}\n  for _, v in ipairs(l1) do map[v]\
    \ = true end\n  for _, v in ipairs(l2) do if map[v] then list[#list+1] = v end\
    \ end\n  return list\nend", "    local t = {}\n    local o = {}\n    for _,v in\
    \ ipairs(l1) do\n        t[v] = v\n    end\n    for _,v in ipairs(l2) do\n   \
    \     if t[v] then\n            o[#o+1] = v\n        end\n    end\n    return\
    \ o\nend", "  local t = {}\n  local d = {}\n  local r = {}\n  local i\n  for i\
    \ = 1, #l1 do\n    t[l1[i]] = l1[i]\n  end\n  for i = 1, #l2 do\n    if t[l2[i]]\
    \ then\n      t[l2[i]] = nil\n      d[#d + 1] = l2[i]\n    end\n  end\n  for _,\
    \ v in pairs(d) do\n    r[#r + 1] = v\n  end\n  return r\nend", "\tlocal t = {}\n\
    \tfor i = 1, #l1 do\n\t\tt[l1[i]] = true\n\tend\n\tlocal r = {}\n\tfor i = 1,\
    \ #l2 do\n\t\tif t[l2[i]] then\n\t\t\tr[#r + 1] = l2[i]\n\t\tend\n\tend\n\tif\
    \ #r == 0 then\n\t\treturn nil\n\tend\n\tsort(r)\n\treturn r\nend", "    local\
    \ res = {}\n    for k, _ in pairs(l1) do\n        if l2[k] then res[k] = true\
    \ end\n    end\n    local i = 0\n    return function()\n        local k\n    \
    \    repeat\n            i = i + 1\n            k = next(res, k)\n        until\
    \ k == nil or i == k\n        return k\n    end\nend", "    return {\n       \
    \ table.unpack(\n            table.keys(\n                table.intersection(\n\
    \                    table.count(l1),\n                    table.count(l2)\n \
    \               )\n            )\n        )\n    }\nend", "  local t = {}\n  for\
    \ i = 1, #l1 do\n    local e = l1[i]\n    if t[e] == nil then\n      t[e] = (binary_search(l2,\
    \ e) and e) or nil\n    end\n  end\n  local out = {}\n  for k, _ in pairs(t) do\n\
    \    table.insert(out, k)\n  end\n  table.sort(out)\n  return out\nend", "\tlocal\
    \ common = {}\n\tfor _, v in ipairs(l1) do\n\t\tif not in(v, common) and in(v,\
    \ l2) then\n\t\t\ttable.insert(common, v)\n\t\tend\n\tend\n\ttable.sort(common)\n\
    \treturn common\nend", "\tlocal common = {}\n\tfor _, v in ipairs(l1) do\n\t\t\
    if has_value(l2, v) then\n\t\t\ttable.insert(common, v)\n\t\tend\n\tend\n\ttable.sort(common)\n\
    \treturn common\nend", "\tlocal r = {}\n\tfor i=1,#l1 do\n\t\tif contains(l2,\
    \ l1[i]) then\n\t\t\tr[#r+1] = l1[i]\n\t\tend\n\tend\n\ttable.sort(r)\n\treturn\
    \ r\nend", "  local a1 = {}\n  local a2 = {}\n  for _, v in ipairs(l1) do a1[v]\
    \ = true end\n  for _, v in ipairs(l2) do a2[v] = true end\n  local r = {}\n \
    \ for k in pairs(a1) do\n    if a2[k] then r[#r+1] = k end\n  end\n  table.sort(r)\n\
    \  return r\nend", "\treturn table.pack(table.keys(map(l1, l2)))\nend", "  local\
    \ t = {}\n  for _, v in ipairs(l1) do\n    t[v] = true\n  end\n  local r = {}\n\
    \  for _, v in ipairs(l2) do\n    if t[v] then\n      r[#r+1] = v\n    end\n \
    \ end\n  return Set(r)\nend", "  local out = {}\n  local t = {}\n  local i = 1\n\
    \  while l1[i] and l2[i] do\n    if l1[i] == l2[i] then\n      t[l1[i]] = 1\n\
    \    else\n      break\n    end\n    i = i + 1\n  end\n  for i,v in pairs(t) do\n\
    \    out[#out+1] = i\n  end\n  table.sort(out)\n  return out\nend", "  local t\
    \ = {}\n  for i,v in ipairs(l1) do if contains(l2, v) then t[#t+1] = v end end\n\
    \  return unique(t)\nend", "    local m = {}\n    local n = {}\n    for _, l in\
    \ ipairs({l1, l2}) do\n        for _, v in ipairs(l) do\n            if not m[v]\
    \ then\n                m[v] = true\n                n[#n+1] = v\n           \
    \ end\n        end\n    end\n    table.sort(n)\n    return n\nend", "\tlocal common\
    \ = {}\n\tfor _, v in ipairs(l1) do\n\t\tif table.contains(l2, v) then\n\t\t\t\
    table.insert(common, v)\n\t\tend\n\tend\n\tif #common > 0 then\n\t\ttable.sort(common)\n\
    \tend\n\treturn common\nend", "    local new = {}\n    local unique = {}\n   \
    \ for _, v in ipairs(l1) do\n        new[v] = true\n    end\n    for _, v in ipairs(l2)\
    \ do\n        if new[v] then\n            unique[v] = true\n        end\n    end\n\
    \    local result = {}\n    for k, _ in pairs(unique) do\n        table.insert(result,\
    \ k)\n    end\n    table.sort(result)\n    return result\nend", "    local t =\
    \ {}\n    for _, v in ipairs(l1) do\n        t[v] = true\n    end\n    local r\
    \ = {}\n    for _, v in ipairs(l2) do\n        if t[v] then\n            table.insert(r,\
    \ v)\n        end\n    end\n    return sort_unique(r)\nend", "  return unique(sort(intersect(l1,\
    \ l2)))\nend", "\tlocal l = {}\n\tfor _, x in ipairs(l1) do\n\t\tif isin(x, l2)\
    \ then\n\t\t\ttable.insert(l, x)\n\t\tend\n\tend\n\ttable.sort(l)\n\treturn l\n\
    end", "  local r = {}\n  for k, v in pairs(l1) do\n    if l2[k] then\n      table.insert(r,\
    \ v)\n    end\n  end\n  table.sort(r)\n  return r\nend", "  local r = {}\n  for\
    \ _, v in ipairs(l1) do\n    if x.in(v, l2) then\n      x.insert_unique(r, v)\n\
    \    end\n  end\n  return x.sort(r)\nend", "\tif not l1 or not l2 then return\
    \ {} end\n\tlocal l3 = {}\n\tfor _, e in ipairs(l1) do\n\t\tif contains(l2, e)\
    \ then table.insert(l3, e) end\n\tend\n\treturn sort(l3)\nend", "    if not (l1\
    \ and l2) then return {} end\n    local ret = {}\n    for _, v in ipairs(l1) do\n\
    \        for _, v2 in ipairs(l2) do\n            if v == v2 then\n           \
    \     table.insert(ret, v)\n            end\n        end\n    end\n    table.sort(ret)\n\
    \    return ret\nend", "    local a = {}\n    for i, v in ipairs(l1) do\n    \
    \    if contains(l2, v) then\n            a[#a+1] = v\n        end\n    end\n\
    \    sort(a)\n    return a\nend", "  local r, ri = {}, 1\n  for i = 1, #l1 do\n\
    \    for j = 1, #l2 do\n      if l1[i] == l2[j] then\n        r[ri] = l1[i]\n\
    \        ri = ri + 1\n        break\n      end\n    end\n  end\n  return r\nend",
  "  local r, c = {}, {}\n  for _, v in ipairs(l1) do r[v] = true end\n  for _, v\
    \ in ipairs(l2) do c[v] = r[v] end\n  local l = {}\n  for k, v in pairs(c) do\
    \ if v then l[#l+1] = k end end\n  table.sort(l)\n  return l\nend", "  local common\
    \ = {}\n  for _,v in ipairs(l1) do if index(l2, v) then common[#common+1] = v\
    \ end end\n  return sort(common)\nend", "    if not l1 or not l2 then return end\n\
    \    local result = {}\n    for _, v in ipairs(l1) do\n        if not result[v]\
    \ and contains(l2, v) then\n            table.insert(result, v)\n            result[v]\
    \ = true\n        end\n    end\n    return result\nend", "\treturn tset(intersect(l1,\
    \ l2))\nend", "  local tbl = {}\n  local n = 0\n  local m = 0\n  local n1 = #l1\n\
    \  local n2 = #l2\n  local i = 1\n  local j = 1\n  while (i <= n1) and (j <= n2)\
    \ do\n    local x1 = l1[i]\n    local x2 = l2[j]\n    if (x1 < x2) then\n    \
    \  i = i + 1\n    elseif (x1 > x2) then\n      j = j + 1\n    else\n      local\
    \ x = l1[i]\n      n = n + 1\n      tbl[n] = x\n      i = i + 1\n      j = j +\
    \ 1\n      while (i <= n1) and (l1[i] == x) do\n        i = i + 1\n      end\n\
    \      while (j <= n2) and (l2[j] == x) do\n        j = j + 1\n      end\n   \
    \ end\n  end\n  return tbl\nend", "  local l3 = {}\n  local l4 = {}\n  -- Insert\
    \ l1 elements into l3.\n  for _, l in ipairs(l1) do\n    table.insert(l3, l)\n\
    \  end\n  -- Insert l2 elements into l4.\n  for _, l in ipairs(l2) do\n    table.insert(l4,\
    \ l)\n  end\n  local l5 = {}\n  -- Search for common elements.\n  for _, l in\
    \ ipairs(l3) do\n    for i, l in ipairs(l4) do\n      if l == l3[i] then\n   \
    \     table.insert(l5, l)\n        table.remove(l4, i)\n        break\n      end\n\
    \    end\n  end\n  -- Return list of unique common elements.\n  return l5\nend",
  "  local result = {}\n  for _, v in ipairs(l1) do\n    if util.contains(l2, v) then\n\
    \      util.insertSorted(result, v)\n    end\n  end\n  return result\nend", "\t\
    local seen = {}\n\tlocal function helper(k)\n\t\tif not seen[k] then\n\t\t\tseen[k]\
    \ = true\n\t\t\treturn k\n\t\tend\n\tend\n\tlocal r = {}\n\tfor k in pairs(l1)\
    \ do\n\t\tr[#r+1] = helper(k)\n\tend\n\tfor k in pairs(l2) do\n\t\tr[#r+1] = helper(k)\n\
    \tend\n\ttable.sort(r)\n\treturn r\nend", "\tif not l1 or not l2 then return end\n\
    \tlocal r = {}\n\tfor _,v in ipairs(l1) do\n\t\tif inlist(l2, v) then r[#r+1]\
    \ = v end\n\tend\n\treturn sort(unique(r))\nend", "\tlocal common, unique1, unique2\
    \ = {}, {}, {}\n\tlocal i, v\n\tfor i, v in ipairs(l1) do\n\t\tcommon[v] = 0\n\
    \t\tunique1[v] = 0\n\tend\n\tfor i, v in ipairs(l2) do\n\t\tif common[v] then\n\
    \t\t\tcommon[v] = 1\n\t\telse\n\t\t\tunique2[v] = 0\n\t\tend\n\tend\n\tlocal t\
    \ = {}\n\tfor i, v in pairs(common) do\n\t\tif v == 1 then\n\t\t\tt[#t+1] = i\n\
    \t\tend\n\tend\n\treturn t\nend", "  local s = {}\n  for i = 1, #l1 do\n    s[l1[i]]\
    \ = true\n  end\n  for i = 1, #l2 do\n    s[l2[i]] = true\n  end\n  local res\
    \ = {}\n  for k in pairs(s) do\n    res[#res + 1] = k\n  end\n  table.sort(res)\n\
    \  return res\nend", "\tlocal k = {}\n\tfor i = 1, #l1 do\n\t\tk[l1[i]] = true\n\
    \tend\n\tlocal c = {}\n\tfor i = 1, #l2 do\n\t\tif k[l2[i]] then\n\t\t\tc[#c +\
    \ 1] = l2[i]\n\t\tend\n\tend\n\ttable.sort(c)\n\treturn c\nend", "    return sorted_unique(set_common(l1,\
    \ l2))\nend", "    local l = {}\n    for _, v in ipairs(l1) do\n        if utils.array_has(l2,\
    \ v) then\n            l[#l+1] = v\n        end\n    end\n    table.sort(l)\n\
    \    return l\nend", "  -- Get numbers in both lists.\n  local common = {}\n \
    \ for _, n in ipairs(l1) do\n    if contains(l2, n) then\n      common[#common\
    \ + 1] = n\n    end\n  end\n  -- Sort in numerical order.\n  table.sort(common)\n\
    \  return common\nend", "  local t = {}\n  for _, v in ipairs(l1) do\n    if in_table(v,\
    \ l2) then\n      table.insert(t, v)\n    end\n  end\n  return sorted(unique(t))\n\
    end", "    local r, s = {}, {}\n    for _, v in ipairs(l1) do s[v] = true end\n\
    \    for _, v in ipairs(l2) do if s[v] then r[#r+1] = v end end\n    return unique(r)\n\
    end", "    local res = {}\n    local map = {}\n    for _, i in ipairs(l1) do\n\
    \        map[i] = true\n    end\n    for _, i in ipairs(l2) do\n        if map[i]\
    \ then\n            table.insert(res, i)\n        end\n    end\n    table.sort(res)\n\
    \    return res\nend", "\tlocal t = {}\n\tfor _, x in ipairs(l1) do\n\t\tt[x]\
    \ = true\n\tend\n\tlocal r = {}\n\tfor _, x in ipairs(l2) do\n\t\tif t[x] then\
    \ r[#r+1] = x end\n\tend\n\ttable.sort(r)\n\treturn r\nend", "\tlocal common,\
    \ used = {}, {}\n\tfor i,v in ipairs(l1) do\n\t\tif list_index(l2, v) then\n\t\
    \t\tif not used[v] then\n\t\t\t\ttable.insert(common, v)\n\t\t\t\tused[v] = true\n\
    \t\t\tend\n\t\tend\n\tend\n\ttable.sort(common)\n\treturn common\nend", "  local\
    \ t = {}\n  for _, x in ipairs(l1) do\n    if not t[x] and list.contains(l2, x)\
    \ then\n      t[x] = true\n      table.insert(t, x)\n    end\n  end\n  table.sort(t)\n\
    \  return t\nend", "  local t = {}\n  for _, v in ipairs(l1) do t[v] = 1 end\n\
    \  for _, v in ipairs(l2) do t[v] = t[v] == 1 and 2 or nil end\n  local l = {}\n\
    \  for k, v in pairs(t) do if v == 2 then l[#l+1] = k end end\n  table.sort(l)\n\
    \  return l\nend", "    local t = {}\n    for _,v in ipairs(l1) do\n        for\
    \ _,v2 in ipairs(l2) do\n            if v == v2 then\n                t[#t+1]\
    \ = v\n            end\n        end\n    end\n    table.sort(t)\n    return t\n\
    end", "  if not l1 or not l2 then return {} end\n  local r = {}\n  for i = 1,\
    \ #l1 do r[l1[i]] = true end\n  for i = 1, #l2 do r[l2[i]] = r[l2[i]] and true\
    \ or nil end\n  local c = {}\n  for i, v in pairs(r) do if v then table.insert(c,\
    \ i) end end\n  table.sort(c)\n  return c\nend", "  local rc = {}\n  local ri\
    \ = 1\n  for i = 1, #l1 do\n    local key = l1[i]\n    for j = 1, #l2 do\n   \
    \   if l2[j] == key then\n        rc[ri] = key\n        ri = ri + 1\n        break\n\
    \      end\n    end\n  end\n  return rc\nend", "\tlocal c = {}\n\tlocal s = {}\n\
    \tfor _, v in ipairs(l1) do\n\t\tif l2[v] then\n\t\t\tc[v] = true\n\t\tend\n\t\
    end\n\tfor k in pairs(c) do\n\t\ts[#s+1] = k\n\tend\n\ttable.sort(s)\n\treturn\
    \ s\nend", "  return sort(unique(l1)) & sort(unique(l2))\nend", "    local out\
    \ = {}\n    for i = 1, #l1 do\n        if indexOf(l2, l1[i]) > 0 then\n      \
    \      out[#out + 1] = l1[i]\n        end\n    end\n    table.sort(out)\n    return\
    \ out\nend", "    -- First make the lists unique.\n    local u1 = unique(l1)\n\
    \    local u2 = unique(l2)\n    -- Then sort them.\n    table.sort(u1)\n    table.sort(u2)\n\
    \    -- Then intersect them.\n    local r = {}\n    local i1 = 1\n    local i2\
    \ = 1\n    while i1 <= #u1 and i2 <= #u2 do\n        if u1[i1] < u2[i2] then\n\
    \            i1 = i1 + 1\n        elseif u1[i1] > u2[i2] then\n            i2\
    \ = i2 + 1\n        else\n            table.insert(r, u1[i1])\n            i1\
    \ = i1 + 1\n            i2 = i2 + 1\n        end\n    end\n    return r\nend",
  "    local t = {}\n    for i = 1, #l1 do\n        local e = l1[i]\n        if contains(l2,\
    \ e) then\n            insert_once(t, e)\n        end\n    end\n    return t\n\
    end", "  local t = {}\n  for k, v in pairs(l1) do\n    if tablex.find(l2, v) then\n\
    \      table.insert(t, v)\n    end\n  end\n  table.sort(t)\n  return t\nend",
  "  local r = {}\n  for _, v in ipairs(l1) do\n    if isin(l2, v) then\n      r[#r+1]\
    \ = v\n    end\n  end\n  sort(r)\n  local i = 1\n  while i < #r do\n    if r[i]\
    \ == r[i+1] then\n      tremove(r, i)\n    else\n      i = i + 1\n    end\n  end\n\
    \  return r\nend", "  local d = {}\n  for _,v in ipairs(l1) do\n    d[v] = true\n\
    \  end\n  local c = {}\n  for _,v in ipairs(l2) do\n    if d[v] then\n      table.insert(c,\
    \ v)\n    end\n  end\n  return unique(c)\nend", "    local set = {}\n    local\
    \ unique = {}\n    local idx = 1\n    for _, v in ipairs(l1) do\n        set[v]\
    \ = idx\n        idx = idx + 1\n    end\n    for _, v in ipairs(l2) do\n     \
    \   if set[v] then\n            unique[#unique + 1] = v\n        end\n    end\n\
    \    table.sort(unique)\n    return unique\nend", "  local u1 = unique(l1)\n \
    \ local u2 = unique(l2)\n  local ret = {}\n  for _, t in ipairs(u1) do\n    if\
    \ contains(u2, t) then\n      table.insert(ret, t)\n    end\n  end\n  return ret\n\
    end", "  local t = {}\n  local i = 1\n  while l1[i] ~= nil and l2[i] ~= nil do\n\
    \    if l1[i] == l2[i] then\n      t[#t+1] = l1[i]\n    end\n    i = i + 1\n \
    \ end\n  return t\nend", "\tlocal ret = {}\n\tlocal seen = {}\n\tfor _, v in ipairs(l1)\
    \ do\n\t\tif not seen[v] then\n\t\t\tseen[v] = true\n\t\t\tret[#ret+1] = v\n\t\
    \tend\n\tend\n\tfor _, v in ipairs(l2) do\n\t\tif seen[v] then\n\t\t\tret[#ret+1]\
    \ = v\n\t\tend\n\tend\n\treturn sorted(ret)\nend", "    local result = {}\n  \
    \  for i, key in ipairs(l1) do\n        if utils.table.has_key(l2, key) then\n\
    \            table.insert(result, key)\n        end\n    end\n    return utils.table.unique(result)\n\
    end", "  local l3 = {}\n  local c = 0\n  for i = 1, #l1 do\n    local l2i = l2[i]\n\
    \    if l2i and l1[i] == l2i then\n      c = c + 1\n      l3[c] = l2i\n    end\n\
    \  end\n  return l3\nend", "  local r = {}\n  for _, e in ipairs(l1) do\n    if\
    \ contains(l2, e) then r[#r+1] = e end\n  end\n  return sort_unique(r)\nend",
  "    local last = 1\n    for _, v in ipairs(l1) do\n        if member(v, l2) then\n\
    \            l1[last] = v\n            last = last + 1\n        end\n    end\n\
    \    table.sort(l1, function(a, b) return a < b end)\n    return unique(l1, last)\n\
    end", "\tlocal m1 = {}\n\tlocal result = {}\n\tfor _, v in ipairs(l1) do\n\t\t\
    m1[v] = true\n\tend\n\tfor _, v in ipairs(l2) do\n\t\tif m1[v] then\n\t\t\ttable.insert(result,\
    \ v)\n\t\tend\n\tend\n\treturn result\nend", "  local t = {}\n  for _, v in ipairs(l1)\
    \ do t[v] = true end\n  for _, v in ipairs(l2) do if t[v] then t[v] = nil else\
    \ t[v] = true end end\n  local r = {}\n  for v in pairs(t) do r[#r+1] = v end\n\
    \  table.sort(r)\n  return r\nend", "    local set = {}\n    local res = {}\n\
    \    for _, l in ipairs{l1, l2} do\n        for _, v in ipairs(l) do\n       \
    \     if not set[v] then\n                res[#res+1] = v\n                set[v]\
    \ = true\n            end\n        end\n    end\n    table.sort(res)\n    return\
    \ res\nend", "  local t = {}\n  for _,v in ipairs(l1) do\n    if l2[v] then t[v]\
    \ = true end\n  end\n  local ret = {}\n  for k in pairs(t) do ret[#ret+1] = k\
    \ end\n  table.sort(ret)\n  return ret\nend", "  if not (l1 and l2) then return\
    \ end\n  local r, hash = {}, {}\n  for _, v in ipairs(l1) do hash[v] = true end\n\
    \  for _, v in ipairs(l2) do\n    if hash[v] then\n      hash[v] = nil\n     \
    \ r[#r+1] = v\n    end\n  end\n  table.sort(r)\n  return r\nend", "  local c =\
    \ {}\n  for _,v in ipairs(l1) do\n    if has_value(l2, v) then table.insert(c,\
    \ v) end\n  end\n  return sorted_unique(c)\nend", "  local t = {}\n  for _, v\
    \ in ipairs(l1) do t[v] = true end\n  for _, v in ipairs(l2) do t[v] = true end\n\
    \  local l = {}\n  for k, _ in pairs(t) do l[#l+1] = k end\n  table.sort(l)\n\
    \  return l\nend", "    local r = {}\n    for _, x in ipairs(l1) do\n        if\
    \ contain(l2, x) then\n            insert(r, x)\n        end\n    end\n    return\
    \ unique(r)\nend", "\tif #l1 < #l2 then\n\t\tlocal tmp = l1\n\t\tl1 = l2\n\t\t\
    l2 = tmp\n\tend\n\tlocal n = {}\n\tfor _, v in ipairs(l1) do\n\t\tif util.contains(l2,\
    \ v) then\n\t\t\ttable.insert(n, v)\n\t\tend\n\tend\n\treturn n\nend", "  local\
    \ res = {}\n  local pos = 1\n  local unique = {}\n  for _, n in ipairs(l1) do\n\
    \    if not unique[n] then\n      unique[n] = true\n      res[pos] = n\n     \
    \ pos = pos + 1\n    end\n  end\n  for _, n in ipairs(l2) do\n    if not unique[n]\
    \ then\n      unique[n] = true\n      res[pos] = n\n      pos = pos + 1\n    end\n\
    \  end\n  return sort_list(res)\nend", "  local t = {}\n  for k1, v1 in pairs(l1)\
    \ do\n    if l2[k1] ~= nil then t[k1] = v1 end\n  end\n  return sort(keys(t))\n\
    end", "  local r = {}\n  for i = 1, #l1 do\n    for j = 1, #l2 do\n      if l1[i]\
    \ == l2[j] then\n        r[#r + 1] = l1[i]\n      end\n    end\n  end\n  if #r\
    \ > 0 then\n    table.sort(r)\n  end\n  return r\nend", "  if not l1 or not l2\
    \ then return {} end\n  local r = {}\n  for _, e in ipairs(l1) do if index(l2,\
    \ e) then r[#r+1] = e end end\n  return sort_uniq(r)\nend", "  local s = {}\n\
    \  for _,v in ipairs(l1) do\n    if contains(l2, v) then s[#s+1] = v end\n  end\n\
    \  return sorted(s)\nend", "    local t = {}\n    for _, i in ipairs(l1) do\n\
    \        if l2[i] then t[#t+1] = i end\n    end\n    return sort_uniq(t)\nend",
  "  local l = {}\n  for _, e in ipairs(l1) do\n    if vim.tbl_contains(l2, e) then\n\
    \      l[#l + 1] = e\n    end\n  end\n  return vim.tbl_sort(vim.tbl_unique(l))\n\
    end", "\tif not (l1 and l2) then return {} end\n\tlocal res = {}\n\tlocal pos1,\
    \ pos2 = 1, 1\n\tlocal n1, n2 = #l1, #l2\n\twhile pos1 <= n1 and pos2 <= n2 do\n\
    \t\tlocal v1, v2 = l1[pos1], l2[pos2]\n\t\tif v1 == v2 then\n\t\t\tres[#res+1]\
    \ = v1\n\t\t\tpos1 = pos1 + 1\n\t\t\tpos2 = pos2 + 1\n\t\telseif v1 < v2 then\n\
    \t\t\tpos1 = pos1 + 1\n\t\telse\n\t\t\tpos2 = pos2 + 1\n\t\tend\n\tend\n\treturn\
    \ res\nend", "    local u = {}\n    for _, v in ipairs(l1) do\n        if (contains(l2,\
    \ v)) then\n            u[#u+1] = v\n        end\n    end\n    table.sort(u)\n\
    \    return u\nend", "    local t = {}\n    for _, e in ipairs(l1) do\n      \
    \  if not t[e] and in_list(l2, e) then\n            t[e] = true\n        end\n\
    \    end\n    return sort_unique(t)\nend", "    local l3 = {}\n    for _, v in\
    \ ipairs(l1) do\n        if utils.contains(l2, v) then\n            table.insert(l3,\
    \ v)\n        end\n    end\n    return sorted(l3)\nend", "    local t1 = sort(l1)\n\
    \    local t2 = sort(l2)\n    local result = {}\n    local i1, i2 = 1, 1\n   \
    \ while t1[i1] and t2[i2] do\n        if t1[i1] == t2[i2] then\n            table.insert(result,\
    \ t1[i1])\n            i1 = i1 + 1\n            i2 = i2 + 1\n        elseif t1[i1]\
    \ < t2[i2] then\n            i1 = i1 + 1\n        else\n            i2 = i2 +\
    \ 1\n        end\n    end\n    return result\nend", "\tlocal com = {}\n\tfor _,\
    \ s in ipairs(l1) do\n\t\tfor _, p in ipairs(l2) do\n\t\t\tif s == p then\n\t\t\
    \t\ttable.insert(com, s)\n\t\t\tend\n\t\tend\n\tend\n\treturn sorted(com)\nend",
  "    local r1 = {}\n    local r2 = {}\n    for i, l in ipairs(l1) do r1[l] = true\
    \ end\n    for i, l in ipairs(l2) do\n        if r1[l] then r2[#r2+1] = l end\n\
    \    end\n    sort(r2)\n    return r2\nend", "    -- insert all elements of l1\
    \ into a set\n    local s = {}\n    for _, v in ipairs(l1) do\n        s[v] =\
    \ true\n    end\n    -- insert all elements of l2 into the set\n    for _, v in\
    \ ipairs(l2) do\n        s[v] = true\n    end\n    -- extract all elements from\
    \ the set\n    local result = {}\n    for v in pairs(s) do\n        table.insert(result,\
    \ v)\n    end\n    -- sort the result\n    table.sort(result)\n    return result\n\
    end", "  local u = {}\n  for _, i in ipairs(l1) do\n    if table_contains(l2,\
    \ i) then\n      table.insert(u, i)\n    end\n  end\n  return sorted(u)\nend",
  "    local ret = {}\n    for _, e in ipairs(l1) do\n        if list.contains(l2,\
    \ e) then table.insert(ret, e) end\n    end\n    table.sort(ret)\n    return ret\n\
    end", "    if type(l1) ~= \"table\" or type(l2) ~= \"table\" then\n        return\
    \ nil\n    end\n    local l3 = {}\n    local i1, i2 = 1, 1\n    while i1 <= #l1\
    \ and i2 <= #l2 do\n        if l1[i1] < l2[i2] then\n            i1 = i1 + 1\n\
    \        elseif l1[i1] > l2[i2] then\n            i2 = i2 + 1\n        else\n\
    \            table.insert(l3, l1[i1])\n            i1 = i1 + 1\n            i2\
    \ = i2 + 1\n        end\n    end\n    return l3\nend", "  local m = {}\n  for\
    \ _, v in ipairs(l1) do\n    m[v] = true\n  end\n  local r = {}\n  for _, v in\
    \ ipairs(l2) do\n    if m[v] then\n      r[#r+1] = v\n    end\n  end\n  sort(r)\n\
    \  return r\nend", "    local common = {}\n    for _, v in ipairs(l1) do\n   \
    \     if contains(l2, v) then\n            table.insert(common, v)\n        end\n\
    \    end\n    return unique(common)\nend", "    local r = {}\n    for k,v in pairs(l1)\
    \ do\n        if l2[k] then r[k] = v end\n    end\n    local ix = {}\n    for\
    \ _,k in ipairs(r) do ix[k] = true end\n    return sorted(ix)\nend", "\tlocal\
    \ res = {}\n\tfor _, v in ipairs(l1) do\n\t\tif has(l2, v) then\n\t\t\ttable.insert(res,\
    \ v)\n\t\tend\n\tend\n\ttable.sort(res)\n\treturn res\nend", "\tlocal ret = {}\n\
    \tlocal map = {}\n\tfor _, v in ipairs(l1) do\n\t\tmap[v] = (map[v] or 0) + 1\n\
    \tend\n\tfor _, v in ipairs(l2) do\n\t\tif map[v] and map[v] > 0 then\n\t\t\t\
    map[v] = map[v] - 1\n\t\t\tret[#ret + 1] = v\n\t\tend\n\tend\n\treturn ret\nend",
  "  local set = {}\n  local result = {}\n  for _, v in ipairs(l1) do\n    set[v]\
    \ = true\n  end\n  for _, v in ipairs(l2) do\n    if set[v] then\n      table.insert(result,\
    \ v)\n    end\n  end\n  table.sort(result)\n  return result\nend", "  local out\
    \ = {}\n  for i = 1, #l1 do\n    local key = l1[i]\n    if l2[key] then\n    \
    \  out[#out + 1] = key\n    end\n  end\n  return out\nend", "    if not (l1 and\
    \ l2) then return {} end\n    local common = {}\n    for _, v in ipairs(l1) do\n\
    \        if not common[v] and has_value(l2, v) then\n            common[v] = true\n\
    \        end\n    end\n    local sorted = {}\n    for k, _ in pairs(common) do\
    \ table.insert(sorted, k) end\n    table.sort(sorted)\n    return sorted\nend",
  "    local res = {}\n    for i=1,#l1 do\n        if index(l2, l1[i]) then\n    \
    \        res[#res+1] = l1[i]\n        end\n    end\n    return sort(res)\nend",
  "\tlocal r = {}\n\tlocal l = {}\n\tfor i = 1,#l1 do\n\t\tl[l1[i]] = i\n\tend\n\t\
    for i = 1,#l2 do\n\t\tif l[l2[i]] then\n\t\t\ttable.insert(r, l2[i])\n\t\tend\n\
    \tend\n\treturn r\nend", "  local s, l = {}, {}\n  for _, v in ipairs(l1) do s[v]\
    \ = true end\n  for _, v in ipairs(l2) do if s[v] then table.insert(l, v) end\
    \ end\n  return l\nend", "\tlocal t = {}\n\tfor _, v in ipairs(l1) do\n\t\tif\
    \ _table.index_of(l2, v) ~= -1 then\n\t\t\tt[#t + 1] = v\n\t\tend\n\tend\n\treturn\
    \ table.sort(t)\nend", "\tlocal res = {}\n\tfor _,k in ipairs(l1) do\n\t\tif is_in(k,\
    \ l2) then table.insert(res, k) end\n\tend\n\treturn res\nend", "    return sorted(unique(l1),\
    \ unique(l2))\nend", "    local t = {}\n    for _,v in ipairs(l1) do\n       \
    \ t[v] = true\n    end\n    local l = {}\n    for _,v in ipairs(l2) do\n     \
    \   if t[v] then\n            table.insert(l, v)\n        end\n    end\n    table.sort(l)\n\
    \    return l\nend", "\tlocal o, s = {}, {}\n\tfor i = 1, #l1 do o[l1[i]] = true\
    \ end\n\tfor i = 1, #l2 do if o[l2[i]] then s[#s+1] = l2[i] end end\n\treturn\
    \ s\nend", "\tlocal r = {}\n\tfor _,v in ipairs(l1) do\n\t\tif lu.table_contains(l2,\
    \ v) then\n\t\t\ttable.insert(r, v)\n\t\tend\n\tend\n\treturn lu.table_unique(r)\n\
    end", "    local ret = {}\n    for _, v in ipairs(l1) do\n        if table.get(l2,\
    \ v) then\n            table.insert(ret, v)\n        end\n    end\n    return\
    \ table.unique(ret)\nend", "    return sort_unique(intersect(l1, l2))\nend", " \
    \ local r = {}\n  for _, v in ipairs(l1) do\n    if util.contains(l2, v) then\n\
    \      r[#r+1] = v\n    end\n  end\n  return util.unique(r)\nend", "\tif not l1\
    \ or not l2 then return {} end\n\tlocal r = {}\n\tfor _, v in ipairs(l1) do\n\t\
    \tif setcontains(l2, v) then table.insert(r, v) end\n\tend\n\treturn r\nend",
  "\tlocal t1 = {}\n\tlocal t2 = {}\n\tlocal res = {}\n\tfor i, v in ipairs(l1) do\n\
    \t\tt1[v] = true\n\tend\n\tfor i, v in ipairs(l2) do\n\t\tt2[v] = true\n\tend\n\
    \tfor i, v in ipairs(l1) do\n\t\tif t2[v] then\n\t\t\ttable.insert(res, v)\n\t\
    \tend\n\tend\n\ttable.sort(res)\n\treturn res\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
