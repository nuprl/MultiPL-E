name: HumanEval_11_string_xor
language: lua
prompt: "-- Input are two strings a and b consisting only of 1s and 0s.\n-- Perform\
  \ binary XOR on these inputs and return result also as a string.\nlocal function\
  \ string_xor(a, b)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = string_xor\n\
  \    lu.assertEquals(candidate('111000', '101010'), '010010')\n    lu.assertEquals(candidate('1',\
  \ '1'), '0')\n    lu.assertEquals(candidate('0101', '0000'), '0101')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local result = \"\"\n  local i = 1\n  while i <= #a and i <= #b do\n\
    \    result = result .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n    i\
    \ = i + 1\n  end\n  return result\nend", "    local c = {}\n    for i = 1, #a\
    \ do\n        local ca = a:sub(i, i)\n        local cb = b:sub(i, i)\n       \
    \ if ca == '1' and cb == '1' then\n            c[i] = '0'\n        elseif ca ==\
    \ '0' and cb == '0' then\n            c[i] = '0'\n        else\n            c[i]\
    \ = '1'\n        end\n    end\n    return table.concat(c)\nend", "    assert(type(a)\
    \ == \"string\" and type(b) == \"string\", \"invalid input types\")\n    assert(a:len()\
    \ == b:len(), \"unequal lengths\")\n    local result = \"\"\n    for i = 1, a:len()\
    \ do\n        if a:sub(i, i) == b:sub(i, i) then\n            result = result\
    \ .. \"0\"\n        else\n            result = result .. \"1\"\n        end\n\
    \    end\n    return result\nend", "    local s = \"\"\n    for i = 1, #a do\n\
    \        if a:sub(i, i) == b:sub(i, i) then\n            s = s .. \"0\"\n    \
    \    else\n            s = s .. \"1\"\n        end\n    end\n    return s\nend",
  "  local a_bytes = hash_string(a)\n  local b_bytes = hash_string(b)\n  local result\
    \ = {}\n  for i = 1, #a_bytes do\n    result[i] = a_bytes[i] ~ b_bytes[i]\n  end\n\
    \  return hash_string(string.char(unpack(result)))\nend", "  assert(#a == #b,\
    \ \"The input strings are not of equal length.\")\n  local res = \"\"\n  for i\
    \ = 1, #a do\n    if (a:sub(i, i) == \"1\" and b:sub(i, i) == \"0\") or (a:sub(i,\
    \ i) == \"0\" and b:sub(i, i) == \"1\") then\n      res = res .. \"1\"\n    else\n\
    \      res = res .. \"0\"\n    end\n  end\n  return res\nend", "  -- Prepare lengths\
    \ of the strings.\n  local al = a:len()\n  local bl = b:len()\n  -- Pad the shorter\
    \ string with zeros.\n  if al > bl then\n    b = string.rep('0', al - bl) .. b\n\
    \  elseif bl > al then\n    a = string.rep('0', bl - al) .. a\n  end\n  -- Inputs\
    \ are ready. Perform XOR.\n  local r = ''\n  for i = 1, a:len() do\n    r = r\
    \ .. tostring(a:sub(i, i) ~= b:sub(i, i))\n  end\n  return r\nend", "    assert(a:len()\
    \ == b:len())\n    local ret = \"\"\n    for i = 1, a:len() do\n        ret =\
    \ ret .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n    end\n    return ret\n\
    end", "  local s = {a:byte(1, -1)}\n  local t = {b:byte(1, -1)}\n  local r = \"\
    \"\n  for i = 1, #s do\n    r = r .. (s[i] ~ t[i] and \"1\" or \"0\")\n  end\n\
    \  return r\nend", "  assert(#a == #b, \"Inputs must be of equal length.\")\n\
    \  local m = #a\n  local r = \"\"\n  for i = 1, m do\n    r = r .. tostring(a:sub(i,\
    \ i) ~= b:sub(i, i) and 1 or 0)\n  end\n  return r\nend", "\tlocal a_len = #a\n\
    \tlocal b_len = #b\n\tlocal shortest_len = math.min(a_len, b_len)\n\tlocal output\
    \ = {}\n\tfor i = 1, shortest_len do\n\t\tif a:sub(i, i) == b:sub(i, i) then\n\
    \t\t\toutput[i] = \"0\"\n\t\telse\n\t\t\toutput[i] = \"1\"\n\t\tend\n\tend\n\t\
    for i = shortest_len + 1, a_len do\n\t\toutput[i] = a:sub(i, i)\n\tend\n\tfor\
    \ i = shortest_len + 1, b_len do\n\t\toutput[i] = b:sub(i, i)\n\tend\n\treturn\
    \ table.concat(output)\nend", "  if #a ~= #b then\n    error('attempt to perform\
    \ xor on strings of different lengths')\n  end\n  local result = {}\n  for i =\
    \ 1, #a do\n    local a_int = tonumber(a:sub(i, i))\n    local b_int = tonumber(b:sub(i,\
    \ i))\n    table.insert(result, (a_int + b_int) % 2)\n  end\n  return table.concat(result)\n\
    end", "  assert(type(a) == \"string\")\n  assert(type(b) == \"string\")\n  assert(#a\
    \ == #b)\n  local result = \"\"\n  for i = 1, #a do\n    if a:sub(i, i) == b:sub(i,\
    \ i) then\n      result = result .. \"0\"\n    else\n      result = result ..\
    \ \"1\"\n    end\n  end\n  return result\nend", "\tlocal ret = \"\"\n\tfor i =\
    \ 1, math.max(#a, #b) do\n\t\tret = ret .. ((a:sub(i, i) == b:sub(i, i)) and \"\
    0\" or \"1\")\n\tend\n\treturn ret\nend", "  local len = math.max(a:len(), b:len())\n\
    \  local out = \"\"\n  for i = 1, len do\n    local x = (a:byte(i) or 0) - 48\n\
    \    local y = (b:byte(i) or 0) - 48\n    out = out .. tostring(x ~ y)\n  end\n\
    \  return out\nend", "    local x = \"\"\n    for i = 1, #a do\n        if a:sub(i,\
    \ i) == b:sub(i, i) then\n            x = x .. \"0\"\n        else\n         \
    \   x = x .. \"1\"\n        end\n    end\n    return x\nend", "  assert(#a ==\
    \ #b, \"length of strings must be equal\")\n  local c = {}\n  for i = 1, #a do\n\
    \    c[i] = a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\"\n  end\n  return table.concat(c)\n\
    end", "    local bit_a = tonumber(a, 2)\n    local bit_b = tonumber(b, 2)\n  \
    \  local result = bit_xor(bit_a, bit_b)\n    return string.format(\"%d\", result)\n\
    end", "\tlocal result = \"\"\n\tfor i = 1, math.max(#a, #b) do\n\t\tlocal a_char\
    \ = tonumber(a:sub(i, i)) or 0\n\t\tlocal b_char = tonumber(b:sub(i, i)) or 0\n\
    \t\tlocal c_char = a_char ~ b_char\n\t\tresult = result .. tostring(c_char)\n\t\
    end\n\treturn result\nend", "    local result = \"\"\n    for i = 1, math.max(#a,\
    \ #b) do\n        local value_a = tonumber(a:sub(i, i)) or 0\n        local value_b\
    \ = tonumber(b:sub(i, i)) or 0\n        local value_r = (value_a + value_b) %\
    \ 2\n        result = result .. tostring(value_r)\n    end\n    return result\n\
    end", "    local s = \"\"\n    for i = 1, math.max(#a, #b) do\n        local n1\
    \ = tonumber(a:sub(i, i)) or 0\n        local n2 = tonumber(b:sub(i, i)) or 0\n\
    \        local n3 = n1 ~ n2\n        s = s .. tostring(n3)\n    end\n    return\
    \ s\nend", "    local s = \"\"\n    for i = 1, #a do\n        if a:sub(i, i) ==\
    \ b:sub(i, i) then\n            s = s .. \"0\"\n        else\n            s =\
    \ s .. \"1\"\n        end\n    end\n    return s\nend", "    local n = #a\n  \
    \  local out = {}\n    for i = 1, n do\n        out[i] = (a:sub(i, i) == '1')\
    \ ~= (b:sub(i, i) == '1') and '1' or '0'\n    end\n    return table.concat(out)\n\
    end", "    if #a ~= #b then\n        return\n    end\n    local res = {}\n   \
    \ for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            res[i]\
    \ = '0'\n        else\n            res[i] = '1'\n        end\n    end\n    return\
    \ table.concat(res)\nend", "    local i = 0\n    local result = \"\"\n    while\
    \ i < #a and i < #b do\n        local a_i = tonumber(a:sub(i + 1, i + 1))\n  \
    \      local b_i = tonumber(b:sub(i + 1, i + 1))\n        result = result .. tostring(a_i\
    \ ~ b_i)\n        i = i + 1\n    end\n    return result\nend", "    local s =\
    \ \"\"\n    local l = math.max(#a, #b)\n    for i = 1, l do\n        s = s ..\
    \ (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n    end\n    return s\nend",
  "  assert(a:len() == b:len())\n  local result = {}\n  for i = 1, a:len() do\n  \
    \  if a:sub(i, i) == b:sub(i, i) then\n      result[i] = '0'\n    else\n     \
    \ result[i] = '1'\n    end\n  end\n  return table.concat(result)\nend", "  local\
    \ result = ''\n  local length = math.max(#a, #b)\n  for i = 1, length do\n   \
    \ local A = (a:sub(i, i) == '1')\n    local B = (b:sub(i, i) == '1')\n    if A\
    \ ~= B then\n      result = result .. '1'\n    else\n      result = result ..\
    \ '0'\n    end\n  end\n  return result\nend", "    assert(#a == #b, \"Can't XOR\
    \ two strings of different lengths\")\n    local result = {}\n    for i = 1, #a\
    \ do\n        result[i] = ((a:sub(i, i) == \"1\") and (b:sub(i, i) == \"0\"))\
    \ or\n                    ((a:sub(i, i) == \"0\") and (b:sub(i, i) == \"1\"))\
    \ and \"1\" or \"0\"\n    end\n    return table.concat(result)\nend", "  local\
    \ result = \"\"\n  for i = 1, #a do\n    result = result .. tostring(tonumber(a:sub(i,\
    \ i)) ~ tonumber(b:sub(i, i)))\n  end\n  return result\nend", "  local res = {}\n\
    \  for i = 1,#a do\n    res[i] = a:sub(i,i) == b:sub(i,i) and '0' or '1'\n  end\n\
    \  return table.concat(res)\nend", "  if a:len() > b:len() then\n    b = string.rep(\"\
    0\", a:len() - b:len()) .. b\n  elseif b:len() > a:len() then\n    a = string.rep(\"\
    0\", b:len() - a:len()) .. a\n  end\n  local res = \"\"\n  for i = 1, a:len()\
    \ do\n    res = res .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n  end\n\
    \  return res\nend", "    local result = \"\"\n    for i = 1, #a do\n        if\
    \ string.sub(a, i, i) == string.sub(b, i, i) then\n            result = result\
    \ .. \"0\"\n        else\n            result = result .. \"1\"\n        end\n\
    \    end\n    return result\nend", "    local a_idx = 1\n    local b_idx = 1\n\
    \    local ret = \"\"\n    while (a_idx <= a:len() and b_idx <= b:len()) do\n\
    \        local a_val = tonumber(a:sub(a_idx, a_idx))\n        local b_val = tonumber(b:sub(b_idx,\
    \ b_idx))\n        local xor_val = a_val ~ b_val\n        ret = ret .. tostring(xor_val)\n\
    \        a_idx = a_idx + 1\n        b_idx = b_idx + 1\n    end\n    return ret\n\
    end", "\tlocal z = \"\"\n\tlocal i = 1\n\twhile i <= #a do\n\t\tz = z .. tostring(tonumber(a:sub(i,\
    \ i)) ~ tonumber(b:sub(i, i)))\n\t\ti = i + 1\n\tend\n\treturn z\nend", "\tlocal\
    \ a_length = #a\n\tlocal b_length = #b\n\tlocal max_length = max(a_length, b_length)\n\
    \tlocal result = {}\n\tfor i = 1, max_length do\n\t\tlocal a_byte = tonumber(string.sub(a,\
    \ -i, -i), 16)\n\t\tlocal b_byte = tonumber(string.sub(b, -i, -i), 16)\n\t\ttable.insert(result,\
    \ 1, string.format(\"%X\", a_byte ~ b_byte))\n\tend\n\treturn table.concat(result)\n\
    end", "    local r = ''\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i,\
    \ i) then\n            r = r .. '0'\n        else\n            r = r .. '1'\n\
    \        end\n    end\n    return r\nend", "    local buf = ''\n    for i = 1,\
    \ #a do\n        buf = buf .. (tonumber(a:sub(i, i)) ~ tonumber(b:sub(i, i)) and\
    \ '1' or '0')\n    end\n    return buf\nend", "    local key = {\"0\", \"1\"}\n\
    \    local bit = {\"0\", \"1\"}\n    local xor = {}\n    for i = 1, #a do\n  \
    \      for j = 1, #key do\n            for k = 1, #bit do\n                local\
    \ s = key[j] .. bit[k]\n                xor[s] = (xor[s] or 0) + 1\n         \
    \   end\n        end\n        local s = a:sub(i, i) .. b:sub(i, i)\n        local\
    \ n = (xor[s] or 2) % 2\n        a = a:sub(1, i - 1) .. n .. a:sub(i + 1)\n  \
    \      for j = 1, #key do\n            for k = 1, #bit do\n                local\
    \ s = key[j] .. bit[k]\n                xor[s] = (xor[s] or 0) - 1\n         \
    \   end\n        end\n    end\n    return a\nend", "\tlocal length = #a\n\tlocal\
    \ result = {}\n\tfor i = 1, length do\n\t\tresult[i] = a:sub(i, i) == b:sub(i,\
    \ i) and '0' or '1'\n\tend\n\treturn table.concat(result)\nend", "    local c\
    \ = {}\n    for i = 1, #a do\n        c[i] = (a:sub(i, i) == b:sub(i, i)) and\
    \ '0' or '1'\n    end\n    return table.concat(c)\nend", "  assert(#a == #b, \"\
    Strings must be of equal length\")\n  local result = {}\n  for i = 1, #a do\n\
    \    local a_value = tonumber(a:sub(i, i))\n    local b_value = tonumber(b:sub(i,\
    \ i))\n    local c_value = a_value ~ b_value\n    result[i] = tostring(c_value)\n\
    \  end\n  return table.concat(result)\nend", "    local result = \"\"\n    for\
    \ i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            result\
    \ = result .. \"0\"\n        else\n            result = result .. \"1\"\n    \
    \    end\n    end\n    return result\nend", "    local r = \"\"\n    for i = 1,\
    \ math.max(#a, #b) do\n        local av = a:sub(i, i) or \"0\"\n        local\
    \ bv = b:sub(i, i) or \"0\"\n        r = r .. ((av ~= bv) and \"1\" or \"0\")\n\
    \    end\n    return r\nend", "    local r = ''\n    for i = 1, math.max(#a, #b)\
    \ do\n        r = r .. ((i > #a or a:sub(i, i) == '0') ~= (i > #b or b:sub(i,\
    \ i) == '0') and '1' or '0')\n    end\n    return r\nend", "    local index =\
    \ {\n        ['0'] = { ['0'] = '0', ['1'] = '1' },\n        ['1'] = { ['0'] =\
    \ '1', ['1'] = '0' }\n    }\n    local r = ''\n    for i = 1, math.max(#a, #b)\
    \ do\n        local c = index[a:sub(i, i) or '0'][b:sub(i, i) or '0']\n      \
    \  r = r .. c\n    end\n    return r\nend", "    local s, p = \"\", 1\n    for\
    \ i = 1, #a do\n        local c, d = a:sub(i, i), b:sub(i, i)\n        if not\
    \ (c == \"0\" and d == \"0\") then\n            if c == \"1\" and d == \"1\" then\n\
    \                s = s .. \"0\"\n            else\n                s = s .. \"\
    1\"\n            end\n        else\n            s = s .. \"0\"\n        end\n\
    \        p = p + 1\n    end\n    return s\nend", "  local result = {}\n  for i\
    \ = 1, #a do\n    result[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n  end\n\
    \  return table.concat(result)\nend", "\tlocal result = \"\"\n\tlocal max_len\
    \ = math.max(#a, #b)\n\tfor i = 1, max_len do\n\t\tlocal a_bit = 0\n\t\tlocal\
    \ b_bit = 0\n\t\tif i <= #a then\n\t\t\ta_bit = tonumber(a:sub(i, i))\n\t\tend\n\
    \t\tif i <= #b then\n\t\t\tb_bit = tonumber(b:sub(i, i))\n\t\tend\n\t\tlocal sum\
    \ = a_bit + b_bit\n\t\tif sum == 1 then\n\t\t\tresult = result .. \"1\"\n\t\t\
    else\n\t\t\tresult = result .. \"0\"\n\t\tend\n\tend\n\treturn result\nend", "\t\
    if #a ~= #b then\n\t\treturn nil\n\tend\n\tlocal output = \"\"\n\tfor i = 1, #a\
    \ do\n\t\tlocal ai = a:sub(i, i)\n\t\tlocal bi = b:sub(i, i)\n\t\tif ai == \"\
    1\" and bi == \"1\" then\n\t\t\toutput = output .. \"0\"\n\t\telseif ai == \"\
    0\" and bi == \"0\" then\n\t\t\toutput = output .. \"0\"\n\t\telse\n\t\t\toutput\
    \ = output .. \"1\"\n\t\tend\n\tend\n\treturn output\nend", "    local result\
    \ = \"\"\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n \
    \           result = result .. \"0\"\n        else\n            result = result\
    \ .. \"1\"\n        end\n    end\n    return result\nend", "  assert(type(a) ==\
    \ \"string\" and type(b) == \"string\")\n  assert(#a == #b)\n  local result =\
    \ \"\"\n  for i = 1, #a do\n    local bit_a = string.sub(a, i, i)\n    local bit_b\
    \ = string.sub(b, i, i)\n    if bit_a == bit_b then\n      result = result ..\
    \ \"0\"\n    else\n      result = result .. \"1\"\n    end\n  end\n  return result\n\
    end", "    assert(#a == #b, \"Input lengths must be equal\")\n    local c = {}\n\
    \    for i = 1, #a do\n        c[i] = (a:sub(i, i) == b:sub(i, i)) and \"0\" or\
    \ \"1\"\n    end\n    return table.concat(c)\nend", "\tlocal res = \"\"\n\tfor\
    \ i = 1, #a do\n\t\tif a:sub(i, i) == b:sub(i, i) then\n\t\t\tres = res .. \"\
    0\"\n\t\telse\n\t\t\tres = res .. \"1\"\n\t\tend\n\tend\n\treturn res\nend", " \
    \ -- Convert both to numbers in base 2.\n  local a_num = tonumber(a, 2)\n  local\
    \ b_num = tonumber(b, 2)\n  -- Apply XOR.\n  local result = a_num ~ b_num\n  --\
    \ Convert result back to a binary string.\n  return (\"%0\" .. string.len(a) ..\
    \ \"d\"):format(result)\nend", "    local result = {}\n    for i = 1, #a do\n\
    \        if (a:sub(i, i) == b:sub(i, i)) then\n            result[i] = '0'\n \
    \       else\n            result[i] = '1'\n        end\n    end\n    return table.concat(result)\n\
    end", "    local result = \"\"\n    for i = 1, string.len(a) do\n        local\
    \ char1 = string.sub(a, i, i)\n        local char2 = string.sub(b, i, i)\n   \
    \     local value = char1 ~= char2\n        if value then\n            result\
    \ = result .. \"1\"\n        else\n            result = result .. \"0\"\n    \
    \    end\n    end\n    return result\nend", "    assert(type(a) == \"string\"\
    \ and type(b) == \"string\", \"input must be strings\")\n    assert(#a == #b,\
    \ \"input strings must be the same length\")\n    local output = \"\"\n    for\
    \ i = 1, #a do\n        local a_int = (a:sub(i, i) == \"1\") and 1 or 0\n    \
    \    local b_int = (b:sub(i, i) == \"1\") and 1 or 0\n        output = output\
    \ .. ((a_int ~= b_int) and \"1\" or \"0\")\n    end\n    return output\nend",
  "  assert(type(a) == \"string\")\n  assert(type(b) == \"string\")\n  assert(#a ==\
    \ #b)\n  local res = {}\n  for i = 1, #a do\n    local ai = tonumber(a:sub(i,\
    \ i))\n    local bi = tonumber(b:sub(i, i))\n    if ai ~= bi then\n      res[i]\
    \ = \"1\"\n    else\n      res[i] = \"0\"\n    end\n  end\n  return table.concat(res)\n\
    end", "    local ret = \"\"\n    for i = 1, #a do\n        local x = string.sub(a,\
    \ i, i)\n        local y = string.sub(b, i, i)\n        local z = (x == y) and\
    \ \"0\" or \"1\"\n        ret = ret .. z\n    end\n    return ret\nend", "   \
    \ local r = ''\n    for i = 1, #a do\n        r = r .. (a:sub(i, i) == b:sub(i,\
    \ i) and '0' or '1')\n    end\n    return r\nend", "  local ret = {}\n  for i\
    \ = 1, #a do\n    ret[i] = a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\"\n  end\n\
    \  return table.concat(ret)\nend", "    assert(type(a) == \"string\" and type(b)\
    \ == \"string\")\n    local len_a = #a\n    local len_b = #b\n    local result\
    \ = \"\"\n    local len = math.max(len_a, len_b)\n    if len_a < len then\n  \
    \      a = string.rep(\"0\", len - len_a) .. a\n    elseif len_b < len then\n\
    \        b = string.rep(\"0\", len - len_b) .. b\n    end\n    for i = 1, len\
    \ do\n        result = (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\") .. result\n\
    \    end\n    return result\nend", "  local res = {}\n  local len = max(#a, #b)\n\
    \  for i = 1, len do\n    local bit1 = (a:sub(i, i) == '1')\n    local bit2 =\
    \ (b:sub(i, i) == '1')\n    res[i] = (bit1 ~= bit2) and '1' or '0'\n  end\n  return\
    \ table.concat(res)\nend", "    local result = \"\"\n    local len = math.max(#a,\
    \ #b)\n    local diff = math.abs(#a - #b)\n    local prefix = string.rep(\"0\"\
    , diff)\n    if #a > #b then\n        b = prefix .. b\n    else\n        a = prefix\
    \ .. a\n    end\n    for i = 1, len do\n        local n1 = tonumber(a:sub(i, i))\n\
    \        local n2 = tonumber(b:sub(i, i))\n        local r = n1 ~ n2\n       \
    \ result = result .. tostring(r)\n    end\n    return result\nend", "  local result\
    \ = \"\"\n  for i = 1, #a do\n    result = result .. (a:sub(i, i) == b:sub(i,\
    \ i) and \"0\" or \"1\")\n  end\n  return result\nend", "    local a_len = #a\n\
    \    local b_len = #b\n    local longest = a_len\n    local min_len = a_len\n\
    \    local a_num = tonumber(a, 2)\n    local b_num = tonumber(b, 2)\n    local\
    \ xor_res_num = a_num ~ b_num\n    local xor_res = string.format(\"%0\" .. min_len\
    \ .. \"d\", xor_res_num)\n    return xor_res\nend", "  assert(#a == #b, 'lengths\
    \ of string xor arguments should be equal')\n  local result = {}\n  for i = 1,\
    \ #a do\n    local a_char = a:sub(i, i)\n    local b_char = b:sub(i, i)\n    result[i]\
    \ = xor_chars[a_char .. b_char]\n  end\n  return table.concat(result)\nend", " \
    \   assert(type(a) == \"string\")\n    assert(type(b) == \"string\")\n    assert(string.len(a)\
    \ == string.len(b))\n    local result = \"\"\n    for i = 1, #a do\n        local\
    \ x = a:sub(i, i)\n        local y = b:sub(i, i)\n        if x ~= y then\n   \
    \         result = result .. \"1\"\n        else\n            result = result\
    \ .. \"0\"\n        end\n    end\n    return result\nend", "    assert(#a == #b,\
    \ \"Inputs a and b have different length.\")\n    local result = {}\n    for i\
    \ = 1, #a do\n        result[i] = a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\"\
    \n    end\n    return table.concat(result)\nend", "    local z = \"\"\n    for\
    \ i = 1, #a do\n        z = z .. ( a:sub(i,i) == b:sub(i,i) and \"0\" or \"1\"\
    \ )\n    end\n    return z\nend", "  -- Initialize the output variable.\n  local\
    \ out = \"\"\n  -- Iterate over all of the bytes.\n  for i = 1, #a do\n    --\
    \ Perform the XOR operation on the two bytes and then append\n    -- the result\
    \ to the output variable.\n    out = out .. string.char(bit.bxor(string.byte(a,\
    \ i), string.byte(b, i)))\n  end\n  -- Return the result.\n  return out\nend",
  "  local result = {}\n  for i = 1, #a do\n    local x = a:sub(i, i)\n    local y\
    \ = b:sub(i, i)\n    if x == y then\n      result[i] = '0'\n    else\n      result[i]\
    \ = '1'\n    end\n  end\n  return table.concat(result)\nend", "    if #a > #b\
    \ then\n        b = string.rep(\"0\", #a - #b) .. b\n    elseif #b > #a then\n\
    \        a = string.rep(\"0\", #b - #a) .. a\n    end\n    local r = {}\n    for\
    \ i = 1, #a do\n        r[i] = a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\"\n\
    \    end\n    return table.concat(r)\nend", "  local result = \"\"\n  for i =\
    \ 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      result = result .. \"\
    0\"\n    else\n      result = result .. \"1\"\n    end\n  end\n  return result\n\
    end", "    local res = \"\"\n    for i = 1, #a do\n        local byte_a = string.byte(a,\
    \ i)\n        local byte_b = string.byte(b, i)\n        res = res .. string.char(byte_a\
    \ ~ byte_b)\n    end\n    return res\nend", "\tif #a ~= #b then\n\t\terror(\"\
    can't xor strings of different length\")\n\tend\n\tlocal res = {}\n\tfor i = 1,\
    \ #a do\n\t\tres[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n\tend\n\treturn\
    \ table.concat(res)\nend", "  local result = {}\n  for i = 1, #a do\n    result[i]\
    \ = (a:sub(i, i) == \"1\") ~= (b:sub(i, i) == \"1\") and \"1\" or \"0\"\n  end\n\
    \  return table.concat(result)\nend", "    local bin_a = tonumber(a, 2)\n    local\
    \ bin_b = tonumber(b, 2)\n    local bin_xor = bit.bxor(bin_a, bin_b)\n    return\
    \ string.format(\"%08d\", bin_xor)\nend", "    local xor_table = {\n        [\"\
    00\"] = \"0\",\n        [\"01\"] = \"1\",\n        [\"10\"] = \"1\",\n       \
    \ [\"11\"] = \"0\"\n    }\n    local bits_a = {}\n    local bits_b = {}\n    local\
    \ result = {}\n    for i = 1, a:len() do\n        bits_a[i] = a:sub(i, i)\n  \
    \  end\n    for i = 1, b:len() do\n        bits_b[i] = b:sub(i, i)\n    end\n\
    \    for i = 1, #bits_a do\n        result[i] = xor_table[bits_a[i] .. bits_b[i]]\n\
    \    end\n    return table.concat(result)\nend", "    local res = {}\n    local\
    \ max = math.max(#a, #b)\n    local min = math.min(#a, #b)\n    local d = max\
    \ - min\n    if d > 0 then\n        if #a > #b then\n            b = string.rep('0',\
    \ d) .. b\n        else\n            a = string.rep('0', d) .. a\n        end\n\
    \    end\n    local alen = #a\n    for i = 1, alen do\n        if a:sub(i, i)\
    \ == b:sub(i, i) then\n            res[i] = '0'\n        else\n            res[i]\
    \ = '1'\n        end\n    end\n    return table.concat(res)\nend", "  local result\
    \ = ''\n  for i = 1, math.max(#a, #b) do\n    local x = tonumber(a:sub(i, i))\
    \ or 0\n    local y = tonumber(b:sub(i, i)) or 0\n    result = result .. (x +\
    \ y) % 2\n  end\n  return result\nend", "    if #a ~= #b then error(\"not equal\"\
    ) end\n    local result = {}\n    for i = 1, #a do\n        if a:sub(i, i) ==\
    \ b:sub(i, i) then\n            result[i] = '0'\n        else\n            result[i]\
    \ = '1'\n        end\n    end\n    return table.concat(result)\nend", "    assert(#a\
    \ == #b, 'String lengths must be equal')\n    local c = ''\n    for i = 1, #a\
    \ do\n        local x = a:sub(i, i)\n        local y = b:sub(i, i)\n        if\
    \ x == y then\n            c = c .. '0'\n        else\n            c = c .. '1'\n\
    \        end\n    end\n    return c\nend", "    if (#a == #b) then\n        local\
    \ v = {}\n        for i = 1, #a do\n            local ac = tonumber(a:sub(i, i))\n\
    \            local bc = tonumber(b:sub(i, i))\n            local val = bc == ac\
    \ and \"0\" or \"1\"\n            table.insert(v, val)\n        end\n        return\
    \ table.concat(v)\n    end\n    return nil\nend", "\tif (a:len() > b:len()) then\n\
    \t\tb = strrep(\"0\", a:len() - b:len()) .. b\n\telseif (a:len() < b:len()) then\n\
    \t\ta = strrep(\"0\", b:len() - a:len()) .. a\n\tend\n\tlocal result = \"\"\n\t\
    for i = 1, a:len() do\n\t\tresult = result .. (a:sub(i, i) == b:sub(i, i) and\
    \ \"0\" or \"1\")\n\tend\n\treturn result\nend", "  local res = \"\"\n  local\
    \ xor = bxor\n  if a ~= nil and b ~= nil then\n    for i = 1, math.max(#a, #b)\
    \ do\n      res = res .. ((a:sub(i, i) == b:sub(i, i)) and '0' or '1')\n    end\n\
    \  end\n  return res\nend", "    local res = \"\"\n    if #a ~= #b then\n    \
    \    return nil\n    end\n    for i = 1, #a do\n        local ai = tonumber(a:sub(i,\
    \ i))\n        local bi = tonumber(b:sub(i, i))\n        if ai == 1 and bi ==\
    \ 1 then\n            res = res .. \"0\"\n        elseif ai == 0 and bi == 0 then\n\
    \            res = res .. \"0\"\n        else\n            res = res .. \"1\"\n\
    \        end\n    end\n    return res\nend", "\tlocal bxor = tonumber(a, 2) ~\
    \ tonumber(b, 2)\n\treturn (\"0\"):rep(#a - #b) .. bxor\nend", "  local r = \"\
    \"\n  for i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      r = r ..\
    \ \"0\"\n    else\n      r = r .. \"1\"\n    end\n  end\n  return r\nend", " \
    \   local result = {}\n    for i = 1, math.max(#a, #b) do\n        local x = tonumber(a:sub(i,\
    \ i)) or 0\n        local y = tonumber(b:sub(i, i)) or 0\n        table.insert(result,\
    \ x ~= y and 1 or 0)\n    end\n    return table.concat(result)\nend", "    local\
    \ r = {}\n    for i = 1, #a do\n        r[i] = string.char( bit.bxor(a:byte(i),\
    \ b:byte(i)) )\n    end\n    return table.concat(r)\nend", "    local res = {}\n\
    \    for i = 1, #a do\n        res[i] = a:sub(i, i) == b:sub(i, i) and '0' or\
    \ '1'\n    end\n    return table.concat(res)\nend", "    assert(type(a) == \"\
    string\" and type(b) == \"string\")\n    local bytes = string.len(a)\n    assert(bytes\
    \ == string.len(b))\n    local result = \"\"\n    for i = 1, bytes do\n      \
    \  result = result .. string.char(bit.bxor(string.byte(a, i), string.byte(b, i)))\n\
    \    end\n    return result\nend", "\tlocal aa = a:reverse()\n\tlocal bb = b:reverse()\n\
    \tlocal res = ''\n\tfor i = 1, math.max(#aa, #bb) do\n\t\tlocal a_i = aa:sub(i,\
    \ i) == '1'\n\t\tlocal b_i = bb:sub(i, i) == '1'\n\t\tif (a_i and not b_i) or\
    \ (not a_i and b_i) then\n\t\t\tres = res .. '1'\n\t\telse\n\t\t\tres = res ..\
    \ '0'\n\t\tend\n\tend\n\treturn res:reverse()\nend", "    local a_len = #a\n \
    \   local b_len = #b\n    local max_len = math.max(a_len, b_len)\n    local out\
    \ = {}\n    for i = 1, max_len do\n        local a_bit = tonumber(a:sub(a_len\
    \ - i + 1, a_len - i + 1)) or 0\n        local b_bit = tonumber(b:sub(b_len -\
    \ i + 1, b_len - i + 1)) or 0\n        out[i] = string.char(48 + a_bit ~ b_bit)\n\
    \    end\n    return table.concat(out):reverse()\nend", "  -- assert(a and b,\
    \ \"invalid input\")\n  -- assert(string.len(a) == string.len(b), \"string lengths\
    \ do not match\")\n  local result = \"\"\n  for i = 1, string.len(a) do\n    local\
    \ a_i = string.sub(a, i, i)\n    local b_i = string.sub(b, i, i)\n    if a_i ==\
    \ b_i then\n      result = result .. \"0\"\n    else\n      result = result ..\
    \ \"1\"\n    end\n  end\n  return result\nend", "  local xor = \"\"\n  local i\
    \ = 1\n  while i <= a:len() and i <= b:len() do\n    local a_char = a:sub(i, i)\n\
    \    local b_char = b:sub(i, i)\n    local xor_char = (a_char == \"1\" and b_char\
    \ == \"0\") or (a_char == \"0\" and b_char == \"1\") and \"1\" or \"0\"\n    xor\
    \ = xor .. xor_char\n    i = i + 1\n  end\n  return xor\nend", "    assert(type(a)\
    \ == \"string\")\n    assert(type(b) == \"string\")\n    assert(#a == #b)\n  \
    \  local r = {}\n    for i = 1, #a do\n        r[i] = string.char(a:byte(i) ~\
    \ b:byte(i))\n    end\n    return table.concat(r)\nend", "    local xor_bits =\
    \ {}\n    if #a ~= #b then return nil end\n    for i = 1, #a do\n        local\
    \ x = a:sub(i, i)\n        local y = b:sub(i, i)\n        if x == y then\n   \
    \         xor_bits[i] = '0'\n        else\n            xor_bits[i] = '1'\n   \
    \     end\n    end\n    return table.concat(xor_bits)\nend", "    local ai = tonumber(a,\
    \ 2)\n    local bi = tonumber(b, 2)\n    local ri = ai ~ bi\n    return string.format(\"\
    %d\", ri)\nend", "    local r = \"\"\n    for i = 1, #a do\n        local c =\
    \ a:sub(i, i)\n        local d = b:sub(i, i)\n        r = r .. (c == d and \"\
    0\" or \"1\")\n    end\n    return r\nend", "    local xor_val = \"\"\n    for\
    \ i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            xor_val\
    \ = xor_val .. \"0\"\n        else\n            xor_val = xor_val .. \"1\"\n \
    \       end\n    end\n    return xor_val\nend", "  assert(type(a) == \"string\"\
    \ and type(b) == \"string\")\n  assert(#a == #b)\n  local out = \"\"\n  for i\
    \ = 1, #a do\n    local ai = a:sub(i, i)\n    local bi = b:sub(i, i)\n    assert(ai\
    \ == \"0\" or ai == \"1\")\n    assert(bi == \"0\" or bi == \"1\")\n    if ai\
    \ == bi then\n      out = out .. \"0\"\n    else\n      out = out .. \"1\"\n \
    \   end\n  end\n  return out\nend", "  local t = {}\n  for i = 1, #a do\n    local\
    \ v = tonumber(a:sub(i, i)) + tonumber(b:sub(i, i))\n    if v == 1 then\n    \
    \  t[#t + 1] = 1\n    else\n      t[#t + 1] = 0\n    end\n  end\n  return table.concat(t)\n\
    end", "    local ret = \"\"\n    for i = 1, #a do\n        if     a:sub(i, i)\
    \ == b:sub(i, i) then ret = ret .. \"0\"\n        elseif a:sub(i, i) ~= b:sub(i,\
    \ i) then ret = ret .. \"1\"\n        end\n    end\n    return ret\nend", "  \
    \  local r = ''\n    local idx = 1\n    while true do\n        local ai = a:sub(idx,\
    \ idx)\n        local bi = b:sub(idx, idx)\n        if not ai or not bi then\n\
    \            break\n        end\n        if ai == '1' and bi == '1' then\n   \
    \         r = r .. '0'\n        elseif ai == '0' and bi == '0' then\n        \
    \    r = r .. '0'\n        else\n            r = r .. '1'\n        end\n     \
    \   idx = idx + 1\n    end\n    return r\nend", "  local result = ''\n  for i\
    \ = 1, math.max(#a, #b) do\n    result = result .. ((a:sub(i, i) == b:sub(i, i))\
    \ and '0' or '1')\n  end\n  return result\nend", "    local result = {}\n    local\
    \ length = math.max(#a, #b)\n    for i = 1, length do\n        local a_i = tonumber(a:sub(i,\
    \ i)) or 0\n        local b_i = tonumber(b:sub(i, i)) or 0\n        table.insert(result,\
    \ (a_i + b_i) % 2)\n    end\n    return table.concat(result)\nend", "    local\
    \ result = \"\"\n    local length = math.max(#a, #b)\n    for i = 1, length do\n\
    \        result = result .. string.char(\n            string.byte(a, i) ~ string.byte(b,\
    \ i)\n        )\n    end\n    return result\nend", "  local res = \"\"\n  for\
    \ i = 1, math.max(#a, #b) do\n    local b1 = string.sub(a, i, i)\n    local b2\
    \ = string.sub(b, i, i)\n    if not b1 then b1 = \"0\" end\n    if not b2 then\
    \ b2 = \"0\" end\n    if b1 ~= b2 then\n      res = res .. \"1\"\n    else\n \
    \     res = res .. \"0\"\n    end\n  end\n  return res\nend", "    local result\
    \ = ''\n    local n = math.max(#a, #b)\n    for i = 1, n do\n        result =\
    \ result .. (string.sub(a, i, i) == string.sub(b, i, i) and '0' or '1')\n    end\n\
    \    return result\nend", "\tlocal ret = {}\n\tfor i = 1, #a do\n\t\tret[i] =\
    \ ((a:sub(i, i) == '1') ~= (b:sub(i, i) == '1')) and '1' or '0'\n\tend\n\treturn\
    \ table.concat(ret)\nend", "    local res = \"\"\n    for i = 1, #a do\n     \
    \   res = res .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n    end\n  \
    \  return res\nend", "  local length = math.max(a:len(), b:len())\n  local result\
    \ = {}\n  for i = 1, length do\n    result[i] = a:sub(i, i) == b:sub(i, i) and\
    \ '0' or '1'\n  end\n  return table.concat(result)\nend", "    assert(#a == #b,\
    \ 'Strings must be of equal length')\n    local res = {}\n    for i = 1, #a do\n\
    \        res[i] = string.char(\n            string.byte(a, i) ~ string.byte(b,\
    \ i)\n        )\n    end\n    return table.concat(res)\nend", "    local n = #a\n\
    \    local c = ''\n    for i = 1, n do\n        c = c .. string.char(string.byte(a,\
    \ i) ~ string.byte(b, i))\n    end\n    return c\nend", "  local xor = ''\n  for\
    \ i = 1, #a do\n    xor = xor .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n\
    \  end\n  return xor\nend", "  if a:len() ~= b:len() then\n    error(\"Inputs\
    \ a and b are not of equal length.\")\n  end\n  local result = \"\"\n  for i =\
    \ 1, a:len() do\n    local a_i = tonumber(a:sub(i, i))\n    local b_i = tonumber(b:sub(i,\
    \ i))\n    if a_i == nil or b_i == nil then\n      error(\"a and b must be a binary\
    \ strings.\")\n    end\n    result = result .. tostring(a_i ~ b_i)\n  end\n  return\
    \ result\nend", "\tlocal xor = { [0] = { [0] = 0, 1 }, 1, { [0] = 1, 0 } }\n\t\
    local n = {}\n\tfor i = 1, math.max(#a, #b) do\n\t\tn[i] = xor[tonumber(a:sub(i,\
    \ i)) or 0][tonumber(b:sub(i, i)) or 0]\n\tend\n\treturn table.concat(n)\nend",
  "  local p,c='',0\n  local function xor(x,y) return (x+y+c)%2==1 and 1 or 0 end\n\
    \  while a:len() > 0 or b:len() > 0 do\n    local ca,cb=a:sub(-1,-1),b:sub(-1,-1)\n\
    \    a,b,c=(a:gsub('(.)$','')),(b:gsub('(.)$','')),0\n    if ca~='' and cb~=''\
    \ then c=xor(tonumber(ca),tonumber(cb)) end\n    if ca~='' and cb=='' then c=tonumber(ca)\
    \ end\n    if ca=='' and cb~='' then c=tonumber(cb) end\n    p=c..p\n  end\n \
    \ return p\nend", "    local result = \"\"\n    local _a = string.reverse(a)\n\
    \    local _b = string.reverse(b)\n    local i = 1\n    while true do\n      \
    \  local va = string.sub(_a, i, i)\n        local vb = string.sub(_b, i, i)\n\
    \        if not va or not vb then\n            break\n        end\n        local\
    \ v = 0\n        if va == \"1\" and vb == \"0\" then\n            v = 1\n    \
    \    elseif va == \"0\" and vb == \"1\" then\n            v = 1\n        end\n\
    \        result = result .. v\n        i = i + 1\n    end\n    return string.reverse(result)\n\
    end", "    local result = {}\n    for i = 1, #a do\n        local _, _, aa, bb\
    \ = a:find(string.format(\"(%d)(%d)\", a:sub(i, i), b:sub(i, i)), 1)\n       \
    \ local xor_result = tonumber(aa) ~= tonumber(bb)\n        table.insert(result,\
    \ xor_result and \"1\" or \"0\")\n    end\n    return table.concat(result)\nend",
  "  if #a ~= #b then\n    error(\"strings must be equal length\")\n  end\n  local\
    \ result = \"\"\n  for i = 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n\
    \      result = result .. \"0\"\n    else\n      result = result .. \"1\"\n  \
    \  end\n  end\n  return result\nend", "    local a_len = #a\n    local b_len =\
    \ #b\n    local len = math.max(a_len, b_len)\n    local result = {}\n    for i\
    \ = 1, len do\n        local a_i = a:sub(i, i)\n        local b_i = b:sub(i, i)\n\
    \        if a_i == b_i then\n            result[i] = '0'\n        else\n     \
    \       result[i] = '1'\n        end\n    end\n    return table.concat(result)\n\
    end", "\tlocal ai = 1\n\tlocal bi = 1\n\tlocal res = \"\"\n\tlocal a_len = #a\n\
    \tlocal b_len = #b\n\twhile ai <= a_len and bi <= b_len do\n\t\tlocal byte_a =\
    \ string.byte(a, ai)\n\t\tlocal byte_b = string.byte(b, bi)\n\t\tlocal byte_res\
    \ = byte_a ~ byte_b\n\t\tres = res .. string.char(byte_res)\n\t\tai = ai + 1\n\
    \t\tbi = bi + 1\n\tend\n\treturn res\nend", "  local l = math.max(a:len(), b:len())\n\
    \  local c = {}\n  for i = 1, l do\n    local n = a:sub(i, i) == '1' and 1 or\
    \ 0\n    local m = b:sub(i, i) == '1' and 1 or 0\n    c[i] = n ~ m\n  end\n  local\
    \ d = table.concat(c)\n  return d\nend", "  local result = \"\"\n  local length\
    \ = math.max(a:len(), b:len())\n  for i = 1, length do\n    result = result ..\
    \ ((a:sub(i, i) == b:sub(i, i)) and \"0\" or \"1\")\n  end\n  return result\n\
    end", "  local max_length = a:len()\n  if b:len() > max_length then\n    max_length\
    \ = b:len()\n  end\n  local output = \"\"\n  for i = 1, max_length do\n    if\
    \ (string.sub(a, -i, -i) == \"1\" and string.sub(b, -i, -i) == \"0\") or\n   \
    \   (string.sub(a, -i, -i) == \"0\" and string.sub(b, -i, -i) == \"1\") then\n\
    \      output = \"1\" .. output\n    else\n      output = \"0\" .. output\n  \
    \  end\n  end\n  return output\nend", "    assert(type(a) == \"string\" and type(b)\
    \ == \"string\")\n    assert(#a == #b)\n    local result = {}\n    for i = 1,\
    \ #a do\n        result[i] = a:sub(i, i) == b:sub(i, i) and '0' or '1'\n    end\n\
    \    return table.concat(result)\nend", "\tlocal res = ''\n\tfor i = 1, #a do\n\
    \t\tres = res .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n\tend\n\treturn\
    \ res\nend", "  local length = math.max(a:len(), b:len())\n  local result = ''\n\
    \  for i = 1, length do\n    local first = a:sub(i, i) or '0'\n    local second\
    \ = b:sub(i, i) or '0'\n    local third = xor_two_bits(first, second)\n    result\
    \ = result .. third\n  end\n  return result\nend", "  local z = {}\n  local len\
    \ = math.max(a:len(), b:len())\n  local a, b = a:ljust(len, '0'), b:ljust(len,\
    \ '0')\n  for i = 1, len do\n    z[i] = a:sub(i, i) == b:sub(i, i) and '0' or\
    \ '1'\n  end\n  return table.concat(z)\nend", "\tlocal z = \"\"\n\tfor i = 1,\
    \ #a do\n\t\tz = z .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n\tend\n\
    \treturn z\nend", "  local result = \"\"\n  for i = 1, math.max(#a, #b) do\n \
    \   local a_i = a:sub(i, i) or \"0\"\n    local b_i = b:sub(i, i) or \"0\"\n \
    \   local a_int = tonumber(a_i)\n    local b_int = tonumber(b_i)\n    if a_int\
    \ == b_int then\n      result = result .. \"0\"\n    else\n      result = result\
    \ .. \"1\"\n    end\n  end\n  return result\nend", "  local s = ''\n  for i =\
    \ 1, #a do\n    if a:sub(i, i) == b:sub(i, i) then\n      s = s .. '0'\n    else\n\
    \      s = s .. '1'\n    end\n  end\n  return s\nend", "  local c = \"\"\n  for\
    \ i = 1, #a do\n    c = c .. (a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\")\n\
    \  end\n  return c\nend", "\tlocal len = math.max(#a, #b)\n\tlocal aa = string.rep('0',\
    \ len - #a) .. a\n\tlocal bb = string.rep('0', len - #b) .. b\n\tlocal res = {}\n\
    \tfor i = 1, len do\n\t\tres[i] = (aa:sub(i, i) == '1' and bb:sub(i, i) == '0')\
    \ or (aa:sub(i, i) == '0' and bb:sub(i, i) == '1') and '1' or '0'\n\tend\n\treturn\
    \ table.concat(res)\nend", "\tlocal n = math.max(#a, #b)\n\ta = string.rep('0',\
    \ n - #a) .. a\n\tb = string.rep('0', n - #b) .. b\n\tlocal s = {}\n\tfor i =\
    \ 1, n do\n\t\tlocal aa = a:sub(i, i)\n\t\tlocal bb = b:sub(i, i)\n\t\tlocal x\
    \ = aa == bb and '0' or '1'\n\t\ts[i] = x\n\tend\n\treturn table.concat(s)\nend",
  "    assert(a and b and #a == #b, \"Strings are not same length\")\n    local result\
    \ = {}\n    for i = 1, #a do\n        local v = tonumber(a:sub(i, i)) ~= tonumber(b:sub(i,\
    \ i))\n        result[i] = v and \"1\" or \"0\"\n    end\n    return table.concat(result)\n\
    end", "\tlocal rv = {}\n\tfor i = 1, math.max(#a, #b) do\n\t\trv[i] = (\"01\"\
    ):sub( ((a:byte(i) - 48) + (b:byte(i) - 48)) + 1, \n\t\t\t\t\t\t\t((a:byte(i)\
    \ - 48) + (b:byte(i) - 48)) + 1 )\n\tend\n\treturn table.concat(rv)\nend", " \
    \   if #a ~= #b then\n        error(\"strings not of equal length\")\n    end\n\
    \    local result = {}\n    for i = 1, #a do\n        result[i] = bit32.bxor(a:byte(i),\
    \ b:byte(i))\n    end\n    return string.char(unpack(result))\nend", "    local\
    \ s, m = '', 0\n    for i = 1, math.max(#a, #b) do\n        m = a:byte(i) or 0\n\
    \        m = m ~ (b:byte(i) or 0)\n        s = s .. string.char(m)\n    end\n\
    \    return s\nend", "\tlocal bin = {}\n\tlocal len = math.max(#a, #b)\n\tfor\
    \ i = 1, len do\n\t\tlocal _a = tonumber(a:sub(i, i) or 0)\n\t\tlocal _b = tonumber(b:sub(i,\
    \ i) or 0)\n\t\tlocal c = ((_a + _b) % 2)\n\t\tbin[i] = c\n\tend\n\treturn table.concat(bin)\n\
    end", "    -- Ensure the strings are equal length, pad shorter string with '0'\n\
    \    a = a:sub(1, b:len())\n    b = b:sub(1, a:len())", "  local result = \"\"\
    \n  local x = 0\n  local y = 0\n  local z = 0\n  local a_length = string.len(a)\n\
    \  local b_length = string.len(b)\n  local max = math.max(a_length, b_length)\n\
    \  for i = 1, max do\n    x = bit.lshift(string.byte(a, i) or 0, 24)\n    y =\
    \ bit.lshift(string.byte(b, i) or 0, 24)\n    z = bit.bxor(x, y)\n    result =\
    \ result .. string.char(bit.band(bit.rshift(z, 24), 0xff))\n  end\n  return result\n\
    end", "    assert(#a == #b, \"inputs of different length\")\n    local r = {}\n\
    \    for i = 1, #a do\n        local x = tonumber(a:sub(i, i))\n        local\
    \ y = tonumber(b:sub(i, i))\n        r[i] = (x ~ y) and 1 or 0\n    end\n    return\
    \ table.concat(r)\nend", "    local s = ''\n    for i = 1, math.max(#a, #b) do\n\
    \        local x = (a:byte(i) or 0) ~ (b:byte(i) or 0)\n        s = s .. tostring(x)\n\
    \    end\n    return s\nend", "  local xor = {}\n  for i = 1, #a do\n    xor[i]\
    \ = (a:sub(i, i) == '1' and b:sub(i, i) == '0') and '1' or '0'\n  end\n  return\
    \ table.concat(xor)\nend", "    local res = \"\"\n    for i = 1, #a do\n     \
    \   res = res .. tostring(tonumber(a:sub(i, i)) ~ tonumber(b:sub(i, i)))\n   \
    \ end\n    return res\nend", "  local result = \"\"\n  for i = 1, math.max(#a,\
    \ #b) do\n    local x = (a:byte(i) or 0) - 48\n    local y = (b:byte(i) or 0)\
    \ - 48\n    result = result .. (x ~ y)\n  end\n  return result\nend", "    local\
    \ a_len = #a\n    local b_len = #b\n    local res_len = math.max(a_len, b_len)\n\
    \    local res = \"\"\n    for i = 1, res_len do\n        local a_char = string.sub(a,\
    \ i, i)\n        local b_char = string.sub(b, i, i)\n        if a_char == \"1\"\
    \ and b_char == \"1\" then\n            res = res .. \"0\"\n        elseif a_char\
    \ == \"0\" and b_char == \"0\" then\n            res = res .. \"0\"\n        else\n\
    \            res = res .. \"1\"\n        end\n    end\n    return res\nend", " \
    \   local xor_table = { [\"0\"] = { [\"0\"] = \"0\", [\"1\"] = \"1\" }, [\"1\"\
    ] = { [\"0\"] = \"1\", [\"1\"] = \"0\" } }\n    local xor_string = \"\"\n    for\
    \ i = 1, #a do\n        local a_i = string.sub(a, i, i)\n        local b_i = string.sub(b,\
    \ i, i)\n        local xor_i = xor_table[a_i][b_i]\n        xor_string = xor_string\
    \ .. xor_i\n    end\n    return xor_string\nend", "    local len = math.max(#a,\
    \ #b)\n    local str = ''\n    for i = 1, len do\n        local ai = tonumber(a:sub(i,\
    \ i)) or 0\n        local bi = tonumber(b:sub(i, i)) or 0\n        local ci =\
    \ ai ~ bi\n        str = str .. ci\n    end\n    return str\nend", "    if (#a\
    \ ~= #b) then\n        return nil\n    end\n    local ret = ''\n    for i = 1,\
    \ #a do\n        if (a:sub(i, i) == b:sub(i, i)) then\n            ret = ret ..\
    \ '0'\n        else\n            ret = ret .. '1'\n        end\n    end\n    return\
    \ ret\nend", "    assert(#a == #b, \"strings not of equal length\")\n    local\
    \ res = {}\n    for i = 1, #a do\n        res[i] = string.char(bit.bxor(a:byte(i),\
    \ b:byte(i)))\n    end\n    return table.concat(res)\nend", "    assert(#a ==\
    \ #b, \"Strings must be of equal length\")\n    local p, q = {}, {}\n    for i\
    \ = 1, #a do\n        p[i] = tonumber(a:sub(i, i))\n        q[i] = tonumber(b:sub(i,\
    \ i))\n    end\n    local xor = array.new(#a, 0)\n    for i = 1, #a do\n     \
    \   xor[i] = (p[i] + q[i]) % 2\n    end\n    return table.concat(xor)\nend", "\t\
    local result = \"\"\n\tfor i = 1, math.max(#a, #b) do\n\t\tlocal x = (a:byte(i)\
    \ or 0) ~= (b:byte(i) or 0)\n\t\tresult = result .. (x and \"1\" or \"0\")\n\t\
    end\n\treturn result\nend", "    local t = {}\n    for i = 1, #a do\n        t[i]\
    \ = b:sub(i, i) == \"1\" and not (a:sub(i, i) == \"1\") or (a:sub(i, i) == \"\
    1\") and not (b:sub(i, i) == \"1\")\n    end\n    return table.concat(t):gsub(\"\
    true\", \"1\"):gsub(\"false\", \"0\")\nend", "    local result = ''\n    for i\
    \ = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n            result =\
    \ result .. '0'\n        else\n            result = result .. '1'\n        end\n\
    \    end\n    return result\nend", "    local len = math.max(#a, #b)\n    local\
    \ output = {}\n    for i = 1, len do\n        local a_bit = a:sub(i, i)\n    \
    \    local b_bit = b:sub(i, i)\n        output[i] = a_bit == b_bit and '0' or\
    \ '1'\n    end\n    return table.concat(output)\nend", "    local out = {}\n \
    \   for i = 1, #a do\n        out[i] = string.char(a:byte(i) ~ b:byte(i))\n  \
    \  end\n    return table.concat(out)\nend", "    local res = ''\n    for i = 1,\
    \ #a do\n        res = res .. (a:sub(i, i) == b:sub(i, i) and '0' or '1')\n  \
    \  end\n    return res\nend", "    if #a == #b then\n        local result = ''\n\
    \        for i = 1, #a do\n            result = result .. tostring(a:sub(i, i)\
    \ == b:sub(i, i) and 0 or 1)\n        end\n        return result\n    else\n \
    \       -- The strings have different lengths\n        return nil\n    end\nend",
  "    local s = \"\"\n    for i = 1, math.max(#a, #b) do\n        s = s .. (a:sub(i,\
    \ i) == b:sub(i, i) and \"0\" or \"1\")\n    end\n    return s\nend", "    if\
    \ #a ~= #b then error(\"Strings must be equal length\") end\n    local result\
    \ = \"\"\n    for i = 1, #a do\n        result = result .. (a:sub(i, i) == b:sub(i,\
    \ i) and \"0\" or \"1\")\n    end\n    return result\nend", "    local z = \"\"\
    \n    for i = 1, #a do\n        z = z .. ((a:sub(i, i) == \"1\") ~= (b:sub(i,\
    \ i) == \"1\") and \"1\" or \"0\")\n    end\n    return z\nend", "    if a:len()\
    \ ~= b:len() then\n        error(\"String lengths don't match for XOR operation\"\
    )\n    end\n    local result = \"\"\n    for i = 1, #a do\n        local a_digit\
    \ = tonumber(a:sub(i, i))\n        local b_digit = tonumber(b:sub(i, i))\n   \
    \     if (a_digit + b_digit) % 2 == 0 then\n            result = result .. \"\
    0\"\n        else\n            result = result .. \"1\"\n        end\n    end\n\
    \    return result\nend", "    local r = \"\"\n    local to_num = function(b)\
    \ return b:byte() - 48 end\n    for i = 1, #a do\n        r = r .. tostring(to_num(a:sub(i,\
    \ i)) ~ to_num(b:sub(i, i)))\n    end\n    return r\nend", "    assert(type(a)\
    \ == \"string\")\n    assert(type(b) == \"string\")\n    local ret = {}\n    for\
    \ i = 1, #a do\n        local c = a:sub(i, i)\n        local d = b:sub(i, i)\n\
    \        assert(c == \"0\" or c == \"1\")\n        assert(d == \"0\" or d == \"\
    1\")\n        table.insert(ret, ((c == \"1\") ~= (d == \"1\")) and \"1\" or \"\
    0\")\n    end\n    return table.concat(ret)\nend", "\tlocal ret = \"\"\n\tfor\
    \ i = 1, #a do\n\t\tif a:sub(i, i) == b:sub(i, i) then\n\t\t\tret = ret .. \"\
    0\"\n\t\telse\n\t\t\tret = ret .. \"1\"\n\t\tend\n\tend\n\treturn ret\nend", " \
    \   local result = {}\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i,\
    \ i) then\n            result[i] = '0'\n        else\n            result[i] =\
    \ '1'\n        end\n    end\n    return table.concat(result)\nend", "    local\
    \ result = \"\"\n    for i = 1, #a do\n        if a:sub(i, i) == b:sub(i, i) then\n\
    \            result = result .. \"0\"\n        else\n            result = result\
    \ .. \"1\"\n        end\n    end\n    return result\nend", "\tlocal output = {}\n\
    \tlocal strlen = #a\n\tassert(#a == #b, \"not the same length\")\n\tfor i = 1,\
    \ strlen do\n\t\tif a:sub(i, i) == b:sub(i, i) then\n\t\t\toutput[i] = \"0\"\n\
    \t\telse\n\t\t\toutput[i] = \"1\"\n\t\tend\n\tend\n\treturn table.concat(output)\n\
    end", "\tlocal bit = require(\"bit\")\n\tlocal size = math.max(a:len(), b:len())\n\
    \tlocal result = \"\"\n\tfor i = 1, size do\n\t\tlocal a_1 = tonumber(a:sub(a:len()\
    \ - i + 1, a:len() - i + 1)) or 0\n\t\tlocal b_1 = tonumber(b:sub(b:len() - i\
    \ + 1, b:len() - i + 1)) or 0\n\t\tresult = tostring(bit.bxor(a_1, b_1)) .. result\n\
    \tend\n\treturn result\nend", "    local res = {}\n    for i = 1, #a do\n    \
    \    if a:sub(i, i) == b:sub(i, i) then\n            res[i] = '0'\n        else\n\
    \            res[i] = '1'\n        end\n    end\n    return table.concat(res)\n\
    end", "\tlocal z = {}\n\tfor i = 1, math.max(#a, #b) do\n\t\tz[i] = (tonumber(a:sub(i,\
    \ i)) or 0) ~ (tonumber(b:sub(i, i)) or 0)\n\tend\n\treturn table.concat(z)\n\
    end", "  -- Convert both inputs to strings and make sure they are the same length.\n\
    \  a = string.format(\"%0\" .. math.max(string.len(a), string.len(b)) .. \"s\"\
    , a)\n  b = string.format(\"%0\" .. math.max(string.len(a), string.len(b)) ..\
    \ \"s\", b)", "\tlocal res = \"\"\n\tfor i = 1, math.max(#a, #b) do\n\t\tlocal\
    \ x = i <= #a and a:sub(i, i) or \"0\"\n\t\tlocal y = i <= #b and b:sub(i, i)\
    \ or \"0\"\n\t\tif x == y then\n\t\t\tres = res .. \"0\"\n\t\telse\n\t\t\tres\
    \ = res .. \"1\"\n\t\tend\n\tend\n\treturn res\nend", "    local result = {}\n\
    \    for i = 1,#a do\n        local byte_a = a:byte(i)\n        local byte_b =\
    \ b:byte(i)\n        result[i] = string.char(bit.bxor(byte_a, byte_b))\n    end\n\
    \    return table.concat(result)\nend", "    if string.len(a) ~= string.len(b)\
    \ then\n        return nil\n    end\n    local r = \"\"\n    for i = 1, string.len(a)\
    \ do\n        local x = string.sub(a, i, i)\n        local y = string.sub(b, i,\
    \ i)\n        local z = x ~= y and \"1\" or \"0\"\n        r = r .. z\n    end\n\
    \    return r\nend", "\tlocal res = {}\n\tlocal mx = math.max(#a, #b)\n\tfor i\
    \ = 1, mx do\n\t\tres[i] = bit.bxor(tonumber(a:sub(i, i), 10), tonumber(b:sub(i,\
    \ i), 10))\n\tend\n\treturn table.concat(res)\nend", "\tlocal r = ''\n\tlocal\
    \ a, b = tostring(a), tostring(b)\n\tlocal len = #a\n\tif #b > len then len =\
    \ #b end\n\tfor i = 1, len do\n\t\tlocal va, vb = 0, 0\n\t\tif i <= #a then va\
    \ = tonumber(a:sub(i, i)) end\n\t\tif i <= #b then vb = tonumber(b:sub(i, i))\
    \ end\n\t\tr = r .. tostring(bit_xor(va, vb))\n\tend\n\treturn r\nend", "    local\
    \ r = \"\"\n    for i = 1, math.max(#a, #b) do\n        local x = tonumber(a:sub(i,\
    \ i)) or 0\n        local y = tonumber(b:sub(i, i)) or 0\n        local z = (x\
    \ + y) % 2\n        r = r .. z\n    end\n    return r\nend", "    local arr =\
    \ {}\n    for i = 1, math.max(#a, #b) do\n        arr[i] = (a:sub(i, i) == '1'\
    \ and 1 or 0) ~= (b:sub(i, i) == '1' and 1 or 0) and '1' or '0'\n    end\n   \
    \ return table.concat(arr)\nend", "    local xor = \"\"\n    local len = math.max(#a,\
    \ #b)\n    for i = 1, len do\n        local x = (a:sub(i, i) == \"1\") ~= (b:sub(i,\
    \ i) == \"1\")\n        xor = xor .. (x and \"1\" or \"0\")\n    end\n    return\
    \ xor\nend", "    local out = {}\n    for i = 1, math.max(#a, #b) do\n       \
    \ out[i] = (a:sub(i, i) == \"1\" and b:sub(i, i) ~= \"1\") or\n            (a:sub(i,\
    \ i) ~= \"1\" and b:sub(i, i) == \"1\") and \"1\" or \"0\"\n    end\n    return\
    \ table.concat(out)\nend", "    local a_len = #a\n    local b_len = #b\n    local\
    \ m_len = math.max(a_len, b_len)\n    local res = string.rep('0', m_len)\n   \
    \ for i = 1, m_len do\n        local a_bit = tonumber(a:sub(a_len - i + 1, a_len\
    \ - i + 1) or '0')\n        local b_bit = tonumber(b:sub(b_len - i + 1, b_len\
    \ - i + 1) or '0')\n        local bit = a_bit ~ b_bit\n        res = res:sub(1,\
    \ m_len - i) .. tostring(bit)\n    end\n    return res\nend", "    local x = {}\n\
    \    local i = 1\n    for c in a:gmatch(\".\") do\n        local a = tonumber(c)\n\
    \        local b = tonumber(b:sub(i, i))\n        x[i] = a ~ b\n        i = i\
    \ + 1\n    end\n    return table.concat(x)\nend", "    if #a ~= #b then\n    \
    \    error(\"invalid input\")\n    end\n    local result = {}\n    for i = 1,\
    \ #a do\n        result[i] =\n            (a:sub(i, i) == \"1\" and b:sub(i, i)\
    \ == \"0\") or\n            (a:sub(i, i) == \"0\" and b:sub(i, i) == \"1\") and\
    \ \"1\" or \"0\"\n    end\n    return table.concat(result)\nend", "    local c\
    \ = \"\"\n    local d = string.len(a)\n    local e = string.len(b)\n    local\
    \ f = math.max(d, e)\n    for g = 1, f do\n        local h = tonumber(string.sub(a,\
    \ -g, -g), 16) or 0\n        local i = tonumber(string.sub(b, -g, -g), 16) or\
    \ 0\n        local j = (h + i) % 2\n        c = string.format(\"%X\", j) .. c\n\
    \    end\n    return c\nend", "    if a == nil then\n        return nil\n    end\n\
    \    if b == nil then\n        return nil\n    end\n    if #a ~= #b then\n   \
    \     return nil\n    end\n    local ret = \"\"\n    for i = 1, #a do\n      \
    \  local xor = (a:sub(i, i) == \"1\") ~= (b:sub(i, i) == \"1\")\n        if xor\
    \ then\n            ret = ret .. \"1\"\n        else\n            ret = ret ..\
    \ \"0\"\n        end\n    end\n    return ret\nend", "    local r = \"\"\n   \
    \ for i = 1, #a do\n        local x, y = string.byte(a, i, i), string.byte(b,\
    \ i, i)\n        r = r .. string.char(x ~ y)\n    end\n    return r\nend", " \
    \   local n = math.max(#a, #b)\n    local c = {}\n    for i = 1, n do\n      \
    \  c[i] = ((a:sub(n - i + 1, n - i + 1) == \"1\") ~= (b:sub(n - i + 1, n - i +\
    \ 1) == \"1\")) and \"1\" or \"0\"\n    end\n    return table.concat(c)\nend",
  "\tlocal result = ''\n\tfor i = 1, #a do\n\t\tresult = result .. (a:sub(i, i) ==\
    \ b:sub(i, i) and '0' or '1')\n\tend\n\treturn result\nend", "    local xor_result\
    \ = \"\"\n    local length = math.max(#a, #b)\n    local format_string = \"%0\"\
    \ .. length .. \"d\"\n    for i = 1, length do\n        local a_bit = a:sub(i,\
    \ i) == \"1\"\n        local b_bit = b:sub(i, i) == \"1\"\n        xor_result\
    \ = xor_result .. (a_bit ~= b_bit and \"1\" or \"0\")\n    end\n    return xor_result\n\
    end", "  local result = ''\n  for i = 1, #a do\n    if a:sub(i, i) == b:sub(i,\
    \ i) then\n      result = result .. '0'\n    else\n      result = result .. '1'\n\
    \    end\n  end\n  return result\nend", "    local sz = math.max(a:len(), b:len())\n\
    \    local ax = a:reverse():ljust(sz, '0')\n    local bx = b:reverse():ljust(sz,\
    \ '0')\n    local r = ''\n    for i = 1, sz do\n        r = tostring(tonumber(ax:sub(i,\
    \ i)) ~ tonumber(bx:sub(i, i))) .. r\n    end\n    return r\nend", "  assert(#a\
    \ == #b, \"Strings need to be of same length\")\n  local c = {}\n  for i = 1,\
    \ #a do\n    c[i] = a:sub(i, i) == b:sub(i, i) and \"0\" or \"1\"\n  end\n  return\
    \ table.concat(c)\nend", "  local bit_xor = bxor\n  local out = {}\n  local i\
    \ = 1\n  while a[i] and b[i] do\n    out[i] = bit_xor(a[i], b[i])\n    i = i +\
    \ 1\n  end\n  return out\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
