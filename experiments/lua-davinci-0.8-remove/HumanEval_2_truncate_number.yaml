name: HumanEval_2_truncate_number
language: lua
prompt: "-- Given a positive floating point number, it can be decomposed into\n--\
  \ and integer part (largest integer smaller than given number) and decimals\n--\
  \ (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
  local function truncate_number(number)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
  \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
  \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    return number - math.floor(number)\nend", "    local x = number\n\
    \    local y = number % 1\n    return y\nend", "    local res = number % 1\n \
    \   return res\nend", "    local to_int = math.floor(number)\n    return number\
    \ - to_int\nend", "    return number - math.floor(number)\nend", "    return number\
    \ - math.floor(number)\nend", "    return math.floor(number)\nend", "    return\
    \ number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "  return number - math.floor(number)\n\
    end", "    local integer, decimals = math.modf(number)\n    return decimals\n\
    end", "  local integral_part, fractional_part = math.modf(number)\n  return fractional_part\n\
    end", "  local rounded_number = round(number)\n  return number - rounded_number\n\
    end", "    local i, f = math.modf(number)\n    return f\nend", "    local integer_part\
    \ = math.floor(number)\n    return number - integer_part\nend", "    return number\
    \ - math.floor(number)\nend", "    local integer, decimal = math.modf(number)\n\
    \    return decimal\nend", "  local integer_part = math.floor(number)\n  return\
    \ number - integer_part\nend", "    return math.fmod(number, 1)\nend", "    return\
    \ math.floor(number * 1000) / 1000\nend", "    local integer_part = math.floor(number)\n\
    \    return number - integer_part\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "  local truncated = math.floor(number)\n\
    \  return number - truncated\nend", "  local number_int = math.floor(number)\n\
    \  return number - number_int\nend", "    local integer, decimals = math.modf(number)\n\
    \    return decimals\nend", "    return number - math.floor(number)\nend", " \
    \   return number - floor(number)\nend", "    local integer_part = math.floor(number)\n\
    \    return number - integer_part\nend", "    local integer_part = math.floor(number)\n\
    \    return number - integer_part\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "    local decimal_part =\
    \ number % 1\n    return decimal_part\nend", "    return number - math.floor(number)\n\
    end", "    local integer, decimals = math.modf(number)\n    return decimals\n\
    end", "    local i, _ = math.modf(number)\n    return i\nend", "  return (number\
    \ - math.floor(number))\nend", "    local formatted = format_number(number)\n\
    \    local int, dec = formatted:match(\"(%d+).(%d+)\")\n    return tonumber(dec)\n\
    end", "  return number - math.floor(number)\nend", "  local number_ipart = math.floor(number)\n\
    \  return number - number_ipart\nend", "    local truncated = math.floor(number)\n\
    \    return number - truncated\nend", "    local truncated = math.floor(number)\n\
    \    return number - truncated\nend", "    if (type(number) ~= \"number\") then\n\
    \        error(\"Expected number, received \" .. type(number))\n    end\n    if\
    \ (number < 0) then\n        error(\"Expected positive number, received \" ..\
    \ number)\n    end\n    local base = math.floor(number)\n    return number - base\n\
    end", "    if not is_number(number) then\n        return nil\n    end\n    return\
    \ (math.floor(number * 100) / 100)\nend", "    return number - math.floor(number)\n\
    end", "    local integer, decimal = math.modf(number)\n    return decimal\nend",
  "    return number - math.floor(number)\nend", "    if type(number) ~= \"number\"\
    \ then\n        error(\"number must be a number!\")\n    end\n    return number\
    \ - math.floor(number)\nend", "    local str = string.format(\"%.\" .. (1 or 0)\
    \ .. \"f\", number)\n    local found, _, int, dec = string.find(str, \"(%d+)%.(%d+)\"\
    )\n    return tonumber(dec)\nend", "    local truncated = math.floor(number)\n\
    \    return number - truncated\nend", "  return math.floor(number * 100) / 100\n\
    end", "  return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "  return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "    local int_part = math.floor(number)\n    return number - int_part\n\
    end", "    local ipart, fpart = math.modf(number)\n    return fpart\nend", " \
    \ local result = number % 1\n  return result\nend", "    local _, fp = math.modf(number)\n\
    \    return fp\nend", "    local idx = string.find(number, \".\", 1, true)\n \
    \   if not idx then\n        return \"0\"\n    end\n    return string.sub(number,\
    \ idx+1)\nend", "    local is_negative = number < 0\n    if is_negative then\n\
    \        number = -number\n    end\n    local int, dec = math.modf(number)\n \
    \   return is_negative and -dec or dec\nend", "    return math.abs(number - math.floor(number))\n\
    end", "    local pos = string.find(number, \"%.\")\n    if pos then\n        return\
    \ string.sub(number, pos + 1)\n    end\n    return 0\nend", "    local ipart,\
    \ fpart = math.modf(number)\n    return fpart\nend", "    local int_part = math.floor(number)\n\
    \    return number - int_part\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "    if (number > 0) then\n\
    \        return math.modf(number)\n    else\n        local tmp = math.modf(math.abs(number))\n\
    \        return -tmp\n    end\nend", "    if (not number) then\n        return\
    \ 0\n    end\n    return number - math.floor(number)\nend", "    local number\
    \ = tonumber(number)\n    return number % 1\nend", "    if type(number) ~= \"\
    number\" then\n        return nil\n    end\n    return number - math.floor(number)\n\
    end", "    if number < 0 then\n        return 1 - (number - math.floor(number))\n\
    \    else\n        return number - math.floor(number)\n    end\nend", "    return\
    \ number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "    local result = number\
    \ % 1\n    return result\nend", "    local integer, decimals = floor(number),\
    \ number - floor(number)\n    return decimals\nend", "    local i, _ = math.modf(number)\n\
    \    return math.abs(number - i)\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "    local decimal = number\
    \ - math.floor(number)\n    return decimal\nend", "    local truncated = math.floor(number)\n\
    \    return number - truncated\nend", "  return number - math.floor(number)\n\
    end", "    local int_part = math.floor(number)\n    return number - int_part\n\
    end", "  return number - math.floor(number)\nend", "    if number < 0 then\n \
    \       -- For negative numbers, we compute the integer part\n        -- in the\
    \ same way as positive numbers, and then fix it.\n        number = math.ceil(number)\n\
    \    else\n        number = math.floor(number)\n    end\n    return number % 1\n\
    end", "    local tmp = math.floor(number)\n    return number - tmp\nend", "  \
    \  return number - math.floor(number)\nend", "  local int_part = floor(number)\n\
    \  return number - int_part\nend", "    return number - math.floor(number)\nend",
  "    if number < 0 then\n        return 1 + (number - math.floor(number))\n    else\n\
    \        return number - math.floor(number)\n    end\nend", "    local number_int\
    \ = math.floor(number)\n    return number - number_int\nend", "  local integer_part\
    \ = math.floor(number)\n  return number - integer_part\nend", "    local _, decimal\
    \ = math.modf(number)\n    return decimal\nend", "    local dec = math.floor(number)\n\
    \    return number - dec\nend", "    return number - math.floor(number)\nend",
  "    return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "  return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "  if number >= 0 then\n    return math.modf(number)\n  else\n    local\
    \ _, i = math.modf(number)\n    return (i + 1)\n  end\nend", "  local num = number\
    \ - math.floor(number)\n  return num\nend", "    return math.floor(number)\nend",
  "  return number - math.floor(number)\nend", "    local number_floor = math.floor(number)\n\
    \    return number - number_floor\nend", "    local integer, decimals = math.modf(number)\n\
    \    return decimals\nend", "  local decimal = number % 1\n  return decimal\n\
    end", "    local integer, decimal = math.modf(number)\n    return decimal\nend",
  "  local ip, dp = math.modf(number)\n  return dp\nend", "    local int, dec = math.modf(number)\n\
    \    return dec\nend", "    local _, _, decimals = string.find(tostring(number),\
    \ \"(%.%d+)\")\n    return decimals or ''\nend", "    return number - math.floor(number)\n\
    end", "    return number - math.floor(number)\nend", "    local integer, decimals\
    \ = math.modf(number)\n    return decimals\nend", "    local int_part = math.floor(number)\n\
    \    return number - int_part\nend", "    return math.floor(number)\nend", " \
    \ local result = math.fmod(number, 1)\n  return result\nend", "    local integer,\
    \ decimals = math.modf(number)\n    return decimals\nend", "  if type(number)\
    \ ~= \"number\" then\n    return nil, \"invalid number\"\n  end", "  return number\
    \ - math.floor(number)\nend", "  return number - math.floor(number)\nend", " \
    \   return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "    local number_int = math.floor(number)\n    return number - number_int\n\
    end", "  return number % 1\nend", "    local truncated = math.floor(number)\n\
    \    return number - truncated\nend", "    local floor = math.floor(number)\n\
    \    return number - floor\nend", "    return number - math.floor(number)\nend",
  "    return number - math.floor(number)\nend", "    local integer, decimals = math.modf(number)\n\
    \    return decimals\nend", "  local decimals = number - math.floor(number)\n\
    \  return decimals\nend", "    local i, f = math.modf(number)\n    return f\n\
    end", "    return number - math.floor(number)\nend", "    local integer_part =\
    \ math.floor(number)\n    return number - integer_part\nend", "    local integer_part\
    \ = math.floor(number)\n    return number - integer_part\nend", "    local result\
    \ = number - math.floor(number)\n    return result\nend", "    return number -\
    \ math.floor(number)\nend", "    local str = tostring(number)\n    local i, j\
    \ = str:find('%.')\n    if i then\n        return tonumber(str:sub(j + 1))\n \
    \   end\n    return 0\nend", "    local result = number - math.floor(number)\n\
    \    return result\nend", "    local integer_part = math.floor(number)\n    return\
    \ number - integer_part\nend", "    local out = nil\n    if number ~= nil then\n\
    \        out = number - math.floor(number)\n    end\n    return out\nend", " \
    \   local truncated = math.floor(number)\n    return number - truncated\nend",
  "    local _, result = math.modf(number)\n    return result\nend", "    return math.fmod(number,\
    \ 1)\nend", "    local integer, decimals = math.modf(number)\n    return decimals\n\
    end", "    local inumber = math.floor(number)\n    return number - inumber\nend",
  "    local integral, fractional = math.modf(number)\n    return fractional\nend",
  "    return number - math.floor(number)\nend", "    local whole, decimals = math.modf(number)\n\
    \    return decimals\nend", "  local _, decimal = math.modf(number)\n  return\
    \ decimal\nend", "    return number - math.floor(number)\nend", "  return math.fmod(number,\
    \ 1)\nend", "    local number = math.abs(number)\n    if number < 1 then\n   \
    \     return math.abs(number)\n    else\n        return 0\n    end\nend", "  local\
    \ integer, decimals = math.modf(number)\n  return decimals\nend", "  local i,\
    \ d = math.modf(number)\n  return d\nend", "    return number - math.floor(number)\n\
    end", "    return (number - math.floor(number))\nend", "    return number - math.floor(number)\n\
    end", "    local _, _, integer_part, decimal_part = string.find(tostring(number),\
    \ \"(%d+)\\.(%d+)\")\n    return decimal_part\nend", "  local integer_part = math.floor(number)\n\
    \  return number - integer_part\nend", "    local _, decimal = math.modf(number)\n\
    \    return decimal\nend", "    local int, dec = math.modf(number)\n    return\
    \ dec\nend", "    local integer_part = math.floor(number)\n    return number -\
    \ integer_part\nend", "  return number - math.floor(number)\nend", "    local\
    \ integer_part = math.floor(number)\n    return number - integer_part\nend", " \
    \   return number - math.floor(number)\nend", "    return number - math.floor(number)\n\
    end", "    local new_number = number * 1000\n    local integer_part = math.floor(new_number)\n\
    \    local decimal_part = new_number - integer_part\n    return decimal_part\n\
    end", "    return number - math.floor(number)\nend", "    return math.modf(number)\n\
    end", "    return math.fmod(number, 1)\nend", "    if number >= 0 then\n     \
    \   return number - math.floor(number)\n    else\n        return 1 - (number -\
    \ math.floor(number))\n    end\nend", "  if type(number) ~= \"number\" then\n\
    \    return nil, \"invalid value (expected number, got \" .. type(number) .. \"\
    )\"\n  end", "  local _, _, integer, decimals = string.find(number, \"([0-9]+)(%.[0-9]+)\"\
    )\n  if not decimals then\n    return 0\n  end\n  return tonumber(decimals)\n\
    end", "  local _, fractional = math.modf(number)\n  return fractional\nend", " \
    \   return number - math.floor(number)\nend", "  return number - math.floor(number)\n\
    end", "  return number % 1\nend", "    local integer_part = math.floor(number)\n\
    \    return number - integer_part\nend", "    return math.fmod(number, 1)\nend",
  "    if number >= 0 then\n        return number - math.floor(number)\n    else\n\
    \        return number - math.ceil(number)\n    end\nend", "    local result =\
    \ number - math.floor(number)\n    if result < 0 then\n        result = result\
    \ + 1\n    end\n    return result\nend", "    return number - math.floor(number)\n\
    end", "    local i, f = math.modf(number)\n    return f\nend", "  if number >\
    \ 0 then\n    return number - math.floor(number)\n  else\n    return number -\
    \ math.ceil(number)\n  end\nend", "  return math.floor(number * 1e6) / 1e6\nend",
  "    local _, decimals = math.modf(number)\n    return decimals\nend", "    if number\
    \ < 0 then\n        number = number * -1\n    end\n    return number - math.floor(number)\n\
    end", "    local integer_part = 0\n    if number >= 0 then\n        integer_part\
    \ = math.floor(number)\n    else\n        integer_part = math.ceil(number)\n \
    \   end\n    return number - integer_part\nend", "  if number < 0 then\n    return\
    \ number % 1 + 1\n  else\n    return number % 1\n  end\nend", "  return number\
    \ % 1\nend", "    local number_str = tostring(number)\n    local decimal_part_start\
    \ = string.find(number_str, \"%.\")\n    if decimal_part_start then\n        return\
    \ tonumber(string.sub(number_str, decimal_part_start))\n    else\n        return\
    \ 0\n    end\nend", "    local integer_part = math.floor(number)\n    return number\
    \ - integer_part\nend", "  return number % 1\nend", "    return number - math.floor(number)\n\
    end", "    local truncated_number = math.floor(number)\n    return number - truncated_number\n\
    end", "    return number - math.floor(number)\nend", "  local result = number\
    \ % 1\n  return result == result and result or result - 1\nend", "    local n\
    \ = number\n    local i = n - n % 1\n    return n - i\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
