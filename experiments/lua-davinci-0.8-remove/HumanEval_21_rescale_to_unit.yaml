name: HumanEval_21_rescale_to_unit
language: lua
prompt: "-- Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n-- such that the smallest number will become 0 and the largest\
  \ will become 1\nlocal function rescale_to_unit(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rescale_to_unit\n\
  \    lu.assertEquals(candidate({2.0, 49.9}), {0.0, 1.0})\n    lu.assertEquals(candidate({100.0,\
  \ 49.9}), {1.0, 0.0})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}),\
  \ {0.0, 0.25, 0.5, 0.75, 1.0})\n    lu.assertEquals(candidate({2.0, 1.0, 5.0, 3.0,\
  \ 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\n    lu.assertEquals(candidate({12.0, 11.0,\
  \ 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local max = numbers[1]\n  local min = numbers[1]\n  for _, n in ipairs(numbers)\
    \ do\n    if n > max then\n      max = n\n    end\n    if n < min then\n     \
    \ min = n\n    end\n  end\n  local diff = max - min\n  for i, n in ipairs(numbers)\
    \ do\n    numbers[i] = (n - min) / diff\n  end\n  return numbers\nend", "    local\
    \ max = math.max(unpack(numbers))\n    local min = math.min(unpack(numbers))\n\
    \    local range = max - min\n    local linear_transform = function(number)\n\
    \        return (number - min) / range\n    end\n    return map(linear_transform,\
    \ numbers)\nend", "  local min = numbers[1]\n  local max = numbers[1]\n  for _,\
    \ num in ipairs(numbers) do\n    if num < min then\n      min = num\n    elseif\
    \ num > max then\n      max = num\n    end\n  end\n  local range = max - min\n\
    \  local new_numbers = {}\n  for _, num in ipairs(numbers) do\n    table.insert(new_numbers,\
    \ (num - min) / range)\n  end\n  return new_numbers\nend", "  local min, max =\
    \ numbers[1], numbers[1]\n  for _, v in ipairs(numbers) do\n    if v < min then\
    \ min = v end\n    if v > max then max = v end\n  end\n  local scale = 1 / (max\
    \ - min)\n  local result = {}\n  for _, v in ipairs(numbers) do\n    table.insert(result,\
    \ (v - min) * scale)\n  end\n  return result\nend", "\tlocal min = 1e9\n\tlocal\
    \ max = -1e9\n\tfor _, number in ipairs(numbers) do\n\t\tmin = math.min(min, number)\n\
    \t\tmax = math.max(max, number)\n\tend\n\tlocal range = max - min\n\tfor i, number\
    \ in ipairs(numbers) do\n\t\tnumbers[i] = (number - min) / range\n\tend\nend",
  "  local min_number = numbers[1]\n  local max_number = numbers[1]\n  for _, number\
    \ in ipairs(numbers) do\n    if number < min_number then\n      min_number = number\n\
    \    end\n    if number > max_number then\n      max_number = number\n    end\n\
    \  end\n  local linear_transform = (1 - 0) / (max_number - min_number)\n  local\
    \ result = {}\n  for _, number in ipairs(numbers) do\n    result[#result + 1]\
    \ = linear_transform * (number - min_number)\n  end\n  return result\nend", "\t\
    local small = math.min(unpack(numbers))\n\tlocal big = math.max(unpack(numbers))\n\
    \tlocal diff = big - small\n\treturn map(function(x) return (x - small) / diff\
    \ end, numbers)\nend", "\tlocal min_number = math.min(unpack(numbers))\n\tlocal\
    \ max_number = math.max(unpack(numbers))\n\tlocal rescaled_numbers = {}\n\tfor\
    \ i,number in ipairs(numbers) do\n\t\tlocal rescaled_number = (number - min_number)\
    \ / (max_number - min_number)\n\t\ttable.insert(rescaled_numbers, rescaled_number)\n\
    \tend\n\treturn rescaled_numbers\nend", "  local max = math.max(unpack(numbers))\n\
    \  local min = math.min(unpack(numbers))\n  local range = max - min\n  local unit_numbers\
    \ = {}\n  for _, num in ipairs(numbers) do\n    unit_numbers[#unit_numbers + 1]\
    \ = (num - min) / range\n  end\n  return unit_numbers\nend", "    -- get the absolute\
    \ minimum and maximum values\n    local abs_min = math.min(unpack(numbers))\n\
    \    local abs_max = math.max(unpack(numbers))", "    local max, min = _.max(numbers),\
    \ _.min(numbers)\n    local scale = max - min\n    local offset = -min\n    local\
    \ res = _.map(numbers, function(n) return (n + offset) / scale end)\n    return\
    \ res\nend", "  local min_number = math.min(unpack(numbers))\n  local max_number\
    \ = math.max(unpack(numbers))\n  local scale = max_number - min_number\n  if scale\
    \ < 0.000001 then\n    scale = 1\n  end\n  local rescaled_numbers = {}\n  for\
    \ _,number in ipairs(numbers) do\n    table.insert(rescaled_numbers, (number -\
    \ min_number) / scale)\n  end\n  return rescaled_numbers\nend", "    local min\
    \ = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n   \
    \ local new_numbers = {}\n    for i, number in ipairs(numbers) do\n        new_numbers[i]\
    \ = (number - min) / (max - min)\n    end\n    return new_numbers\nend", "\tlocal\
    \ min = numbers[1]\n\tlocal max = numbers[1]\n\tfor _, n in ipairs(numbers) do\n\
    \t\tif n < min then\n\t\t\tmin = n\n\t\tend\n\t\tif n > max then\n\t\t\tmax =\
    \ n\n\t\tend\n\tend\n\tfor i, n in ipairs(numbers) do\n\t\tnumbers[i] = (n - min)\
    \ / (max - min)\n\tend\n\treturn numbers\nend", "  local biggest, smallest = math.max(unpack(numbers)),\
    \ math.min(unpack(numbers))\n  for i,n in ipairs(numbers) do\n    numbers[i] =\
    \ (n - smallest) / (biggest - smallest)\n  end\n  return numbers\nend", "    local\
    \ min, max = min_max(numbers)\n    local rescaled = torch.Tensor(#numbers)\n \
    \   for i, number in ipairs(numbers) do\n        rescaled[i] = (number - min)\
    \ / (max - min)\n    end\n    return rescaled\nend", "  -- Determine minimum and\
    \ maximum values\n  local minimum = numbers[1]\n  local maximum = numbers[1]\n\
    \  for _, number in ipairs(numbers) do\n    if number < minimum then\n      minimum\
    \ = number\n    elseif number > maximum then\n      maximum = number\n    end\n\
    \  end", "  local min = min_number(numbers)\n  local max = max_number(numbers)\n\
    \  local new_numbers = {}\n  for i = 1, #numbers do\n    new_numbers[i] = (numbers[i]\
    \ - min) / (max - min)\n  end\n  return new_numbers\nend", "    local n = #numbers\n\
    \    local min, max = min_max(numbers)\n    for i = 1, n do\n        numbers[i]\
    \ = (numbers[i] - min) / (max - min)\n    end\nend", "    local min, max = numbers[1],\
    \ numbers[1]\n    for _, n in ipairs(numbers) do\n        if n < min then min\
    \ = n end\n        if n > max then max = n end\n    end\n    local range = max\
    \ - min\n    local result = {}\n    for _, n in ipairs(numbers) do\n        result[#result\
    \ + 1] = (n - min) / range\n    end\n    return result\nend", "\tlocal min = math.min(unpack(numbers))\n\
    \tlocal max = math.max(unpack(numbers))\n\tlocal diff = max - min\n\tlocal scaled\
    \ = {}\n\tfor _, n in ipairs(numbers) do\n\t\ttable.insert(scaled, (n - min) /\
    \ diff)\n\tend\n\treturn scaled\nend", "  -- Find min and max values\n  local\
    \ smallest = numbers[1]\n  local largest = numbers[1]\n  for _, n in ipairs(numbers)\
    \ do\n    if n < smallest then\n      smallest = n\n    elseif n > largest then\n\
    \      largest = n\n    end\n  end", "  local min = numbers[1]\n  local max =\
    \ numbers[1]\n  for _, number in ipairs(numbers) do\n    if number < min then\n\
    \      min = number\n    elseif number > max then\n      max = number\n    end\n\
    \  end\n  local range = max - min\n  for i, number in ipairs(numbers) do\n   \
    \ numbers[i] = (number - min) / range\n  end\nend", "    local min = numbers[1]\n\
    \    local max = numbers[1]\n    for _, n in ipairs(numbers) do\n        if n\
    \ < min then\n            min = n\n        end\n        if n > max then\n    \
    \        max = n\n        end\n    end\n    local length = max - min\n    local\
    \ result = {}\n    for _, n in ipairs(numbers) do\n        local r = (n - min)\
    \ / length\n        table.insert(result, r)\n    end\n    return result\nend",
  "  local len = #numbers\n  local max_number = numbers[1]\n  local min_number = numbers[1]\n\
    \  for i = 2, len do\n    if numbers[i] > max_number then\n      max_number =\
    \ numbers[i]\n    end\n    if numbers[i] < min_number then\n      min_number =\
    \ numbers[i]\n    end\n  end\n  local result = {}\n  for i = 1, len do\n    result[i]\
    \ = (numbers[i] - min_number) / (max_number - min_number)\n  end\n  return result\n\
    end", "  local min = math.min(unpack(numbers))\n  local max = math.max(unpack(numbers))\n\
    \  local result = {}\n  for _, v in ipairs(numbers) do\n    table.insert(result,\
    \ (v - min) / (max - min))\n  end\n  return result\nend", "    local min_n, max_n\
    \ = min(numbers), max(numbers)\n    local res = {}\n    for _, v in ipairs(numbers)\
    \ do\n        if max_n - min_n > 0 then\n            res[#res + 1] = (v - min_n)\
    \ / (max_n - min_n)\n        else\n            res[#res + 1] = 0\n        end\n\
    \    end\n    return res\nend", "    local lo, hi = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n    for i, num in ipairs(numbers) do\n        numbers[i]\
    \ = (num - lo) / (hi - lo)\n    end\n    return numbers\nend", "    assert(#numbers\
    \ >= 2)\n    local min, max = numbers[1], numbers[1]\n    for _, x in ipairs(numbers)\
    \ do\n        if x < min then min = x end\n        if x > max then max = x end\n\
    \    end\n    local function rescale(x)\n        return (x - min) / (max - min)\n\
    \    end\n    return tablex.imap(rescale, numbers)\nend", "  assert(#numbers >=\
    \ 2)\n  local max_number = numbers[1]\n  local min_number = numbers[1]\n  for\
    \ _, n in ipairs(numbers) do\n    if n > max_number then\n      max_number = n\n\
    \    end\n    if n < min_number then\n      min_number = n\n    end\n  end\n \
    \ local ret = {}\n  for _, n in ipairs(numbers) do\n    ret[#ret + 1] = (n - min_number)\
    \ / (max_number - min_number)\n  end\n  return ret\nend", "  local max = nil\n\
    \  local min = nil\n  for _, value in ipairs(numbers) do\n    if max == nil or\
    \ value > max then\n      max = value\n    end\n    if min == nil or value < min\
    \ then\n      min = value\n    end\n  end\n  local result = {}\n  for _, value\
    \ in ipairs(numbers) do\n    table.insert(result, (value - min) / (max - min))\n\
    \  end\n  return result\nend", "    local min, max = array.min(numbers), array.max(numbers)\n\
    \    local scale = max - min\n    if scale == 0 then scale = 1 end\n    for i,\
    \ v in ipairs(numbers) do\n        numbers[i] = (v - min) / scale\n    end\n \
    \   return numbers\nend", "    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for i, num in ipairs(numbers) do\n        if num < min then\n           \
    \ min = num\n        end\n        if num > max then\n            max = num\n \
    \       end\n    end\n    local result = {}\n    for i, num in ipairs(numbers)\
    \ do\n        result[i] = (num - min) / (max - min)\n    end\n    return result\n\
    end", "    local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local scale = max - min\n    local t = {}\n    for _, v in ipairs(numbers)\
    \ do\n        table.insert(t, (v - min) / scale)\n    end\n    return t\nend",
  "    local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    if min == max then\n        -- if max and min are the same, then the list\
    \ is equal across its whole span.\n        -- In this case, arbitrarily set all\
    \ values to 0.5.\n        return {0.5, 0.5, 0.5}\n    end\n    local numbers_doubled\
    \ = {}\n    for i, number in ipairs(numbers) do\n        numbers_doubled[i] =\
    \ (number - min) / (max - min)\n    end\n    return numbers_doubled\nend", " \
    \   local min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n  \
    \  local result = {}\n    for _, number in ipairs(numbers) do\n        result[#result\
    \ + 1] = (number - min) / (max - min)\n    end\n    return result\nend", "   \
    \ -- find min and max of list\n    local min, max = numbers[1], numbers[1]\n \
    \   for _, num in ipairs(numbers) do\n        if num < min then min = num end\n\
    \        if num > max then max = num end\n    end", "    local min = math.min(unpack(numbers))\n\
    \    local max = math.max(unpack(numbers))\n    local a = 1 / (max - min)\n  \
    \  local b = 1 - max * a\n    local result = {}\n    for _,v in ipairs(numbers)\
    \ do\n        result[#result+1] = a * v + b\n    end\n    return result\nend",
  "    local max = - math.huge\n    local min = math.huge\n    for _,v in ipairs(numbers)\
    \ do\n        if v > max then max = v end\n        if v < min then min = v end\n\
    \    end\n    --print(\"rescale_to_unit: max: \" .. max .. \", min: \" .. min)\n\
    \    for i,v in ipairs(numbers) do\n        numbers[i] = (v - min) / (max - min)\n\
    \    end\nend", "\tlocal min_number = numbers[1]\n\tlocal max_number = numbers[1]\n\
    \tfor _, number in ipairs(numbers) do\n\t\tif number < min_number then\n\t\t\t\
    min_number = number\n\t\tend\n\t\tif number > max_number then\n\t\t\tmax_number\
    \ = number\n\t\tend\n\tend\n\tlocal difference = max_number - min_number\n\tfor\
    \ i, number in ipairs(numbers) do\n\t\tnumbers[i] = (number - min_number) / difference\n\
    \tend\n\treturn numbers\nend", "\tlocal max_number = - math.huge\n\tlocal min_number\
    \ = math.huge\n\tfor _, number in ipairs(numbers) do\n\t\tmax_number = math.max(max_number,\
    \ number)\n\t\tmin_number = math.min(min_number, number)\n\tend\n\tif max_number\
    \ == min_number then\n\t\treturn\n\tend\n\tfor i, number in ipairs(numbers) do\n\
    \t\tnumbers[i] = (number - min_number) / (max_number - min_number)\n\tend\nend",
  "  local min_num = math.min(unpack(numbers))\n  local max_num = math.max(unpack(numbers))\n\
    \  local scale_factor = 1 / (max_num - min_num)\n  for i, number in ipairs(numbers)\
    \ do\n    numbers[i] = (number - min_num) * scale_factor\n  end\n  return numbers\n\
    end", "    local max = 0\n    local min = math.huge\n    for i, n in ipairs(numbers)\
    \ do\n        if n > max then\n            max = n\n        end\n        if n\
    \ < min then\n            min = n\n        end\n    end\n    local out = {}\n\
    \    for i, n in ipairs(numbers) do\n        out[i] = (n - min) / (max - min)\n\
    \    end\n    return out\nend", "  local min, max = numbers[1], numbers[1]\n \
    \ for _, num in ipairs(numbers) do\n    if num < min then min = num end\n    if\
    \ num > max then max = num end\n  end\n  return (numbers - min) / (max - min)\n\
    end", "  local min = math.min(unpack(numbers))\n  local max = math.max(unpack(numbers))\n\
    \  local delta = max - min\n  for i, v in ipairs(numbers) do\n    numbers[i] =\
    \ (v - min) / delta\n  end\n  return numbers\nend", "  local _min = math.min(unpack(numbers))\n\
    \  local _max = math.max(unpack(numbers))\n  local _amplitude = _max - _min\n\
    \  return (function(number)\n    return (number - _min) / _amplitude\n  end)\n\
    end", "  local min = math.min(unpack(numbers))\n  local max = math.max(unpack(numbers))\n\
    \  local transform = function(num)\n    return (num - min) / (max - min)\n  end\n\
    \  return map(transform, numbers)\nend", "  local numbers_copy = {}\n  for _,\
    \ x in ipairs(numbers) do\n    table.insert(numbers_copy, x)\n  end\n  table.sort(numbers_copy)\n\
    \  local min = numbers_copy[1]\n  local max = numbers_copy[#numbers_copy]\n  local\
    \ range = max - min\n  return lin_transform(numbers, 0, 1, min, max)\nend", "\t\
    local min, max\n\tif numbers[1] < numbers[2] then\n\t\tmin, max = numbers[1],\
    \ numbers[2]\n\telse\n\t\tmin, max = numbers[2], numbers[1]\n\tend\n\tfor i =\
    \ 3, #numbers do\n\t\tif numbers[i] < min then\n\t\t\tmin = numbers[i]\n\t\telseif\
    \ numbers[i] > max then\n\t\t\tmax = numbers[i]\n\t\tend\n\tend\n\tlocal scale\
    \ = 1 / (max - min)\n\tlocal lin_transform = function(x) return (x - min) * scale\
    \ end\n\treturn map(lin_transform, numbers)\nend", "    local min, max = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n    local scale = max - min\n    local result = {}\n\
    \    for _, n in ipairs(numbers) do\n        table.insert(result, (n - min) /\
    \ scale)\n    end\n    return result\nend", "\tlocal min = numbers[1]\n\tlocal\
    \ max = numbers[1]\n\tfor _, n in ipairs(numbers) do\n\t\tif n < min then\n\t\t\
    \tmin = n\n\t\tend\n\t\tif n > max then\n\t\t\tmax = n\n\t\tend\n\tend\n\tlocal\
    \ range = max - min\n\tlocal new_numbers = {}\n\tfor _, n in ipairs(numbers) do\n\
    \t\ttable.insert(new_numbers, (n - min) / range)\n\tend\n\treturn new_numbers\n\
    end", "    local min_number = math.min(unpack(numbers))\n    local max_number\
    \ = math.max(unpack(numbers))\n    local map = lume.fn(function(n) return (n -\
    \ min_number) / (max_number - min_number) end)\n    return map(numbers)\nend",
  "\tlocal min_num = numbers[1]\n\tlocal max_num = numbers[1]\n\tfor _,num in ipairs(numbers)\
    \ do\n\t\tif num < min_num then\n\t\t\tmin_num = num\n\t\tend\n\t\tif num > max_num\
    \ then\n\t\t\tmax_num = num\n\t\tend\n\tend\n\tlocal scale = max_num - min_num\n\
    \tif scale == 0 then\n\t\treturn numbers\n\tend\n\tlocal scaled_numbers = {}\n\
    \tfor _,num in ipairs(numbers) do\n\t\tscaled_numbers[#scaled_numbers+1] = (num\
    \ - min_num) / scale\n\tend\n\treturn scaled_numbers\nend", "\tlocal mx = -math.huge\n\
    \tlocal mn = math.huge\n\tfor i, v in ipairs(numbers) do\n\t\tif v > mx then mx\
    \ = v end\n\t\tif v < mn then mn = v end\n\tend\n\tlocal r = mx - mn\n\tlocal\
    \ result = {}\n\tfor i, v in ipairs(numbers) do\n\t\tresult[i] = (v - mn) / r\n\
    \tend\n\treturn result\nend", "  local m = min(numbers)\n  local M = max(numbers)\n\
    \  return map(function(x) return (x - m) / (M - m) end, numbers)\nend", "\tlocal\
    \ largest = math.max(unpack(numbers))\n\tlocal smallest = math.min(unpack(numbers))\n\
    \tlocal range = largest - smallest\n\treturn tablex.map(function(x) return (x\
    \ - smallest) / range end, numbers)\nend", "  local min, max = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n  for i, num in ipairs(numbers) do\n    numbers[i]\
    \ = (num - min) / (max - min)\n  end\n  return numbers\nend", "  local min_num\
    \ = math.min(unpack(numbers))\n  local max_num = math.max(unpack(numbers))\n \
    \ local span = max_num - min_num\n  local rescaled = {}\n  for _, num in ipairs(numbers)\
    \ do\n    table.insert(rescaled, (num - min_num) / span)\n  end\n  return rescaled\n\
    end", "\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\tlocal n = #numbers\n\
    \tfor i = 2, n do\n\t\tif numbers[i] < min then\n\t\t\tmin = numbers[i]\n\t\t\
    elseif numbers[i] > max then\n\t\t\tmax = numbers[i]\n\t\tend\n\tend\n\tif min\
    \ == max then\n\t\tfor i = 1, n do\n\t\t\tnumbers[i] = 0\n\t\tend\n\telse\n\t\t\
    local delta = max - min\n\t\tfor i = 1, n do\n\t\t\tnumbers[i] = (numbers[i] -\
    \ min) / delta\n\t\tend\n\tend\n\treturn numbers\nend", "    local min_value =\
    \ numbers[1]\n    local max_value = numbers[1]\n    for i = 2, #numbers do\n \
    \       min_value = math.min(min_value, numbers[i])\n        max_value = math.max(max_value,\
    \ numbers[i])\n    end\n    local scale = 1 / (max_value - min_value)\n    local\
    \ result = {}\n    for i = 1, #numbers do\n        result[i] = (numbers[i] - min_value)\
    \ * scale\n    end\n    return result\nend", "    local minVal = numbers[1]\n\
    \    local maxVal = numbers[1]\n    for i = 2, #numbers do\n        if numbers[i]\
    \ < minVal then\n            minVal = numbers[i]\n        elseif numbers[i] >\
    \ maxVal then\n            maxVal = numbers[i]\n        end\n    end\n    local\
    \ new_numbers = {}\n    for i = 1, #numbers do\n        new_numbers[i] = (numbers[i]\
    \ - minVal) / (maxVal - minVal)\n    end\n    return new_numbers\nend", "  local\
    \ min = numbers[1]\n  local max = numbers[1]\n  for i = 2, #numbers do\n    if\
    \ numbers[i] < min then\n      min = numbers[i]\n    elseif numbers[i] > max then\n\
    \      max = numbers[i]\n    end\n  end\n  local factor = 1 / (max - min)\n  for\
    \ i = 1, #numbers do\n    numbers[i] = (numbers[i] - min) * factor\n  end\nend",
  "  -- Find min, max and range\n  local min = numbers[1]\n  local max = numbers[1]\n\
    \  for _, number in ipairs(numbers) do\n    if number < min then\n      min =\
    \ number\n    end\n    if number > max then\n      max = number\n    end\n  end\n\
    \  local range = max - min", "  assert(#numbers >= 2)\n  local min, max = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n  local factor = 1 / (max - min)\n  for i, v in ipairs(numbers)\
    \ do\n    numbers[i] = (v - min) * factor\n  end\nend", "    local numbers_max\
    \ = math.max(unpack(numbers))\n    local numbers_min = math.min(unpack(numbers))\n\
    \    local diff = numbers_max - numbers_min\n    local rescaled = {}\n    for\
    \ _, number in ipairs(numbers) do\n        rescaled[#rescaled + 1] = (number -\
    \ numbers_min) / diff\n    end\n    return rescaled\nend", "\tlocal small, large\
    \ = numbers[1], numbers[1]\n\tfor _, n in ipairs(numbers) do\n\t\tif n < small\
    \ then small = n end\n\t\tif n > large then large = n end\n\tend\n\t\n\tif small\
    \ == large then\n\t\t-- Handle the case where all numbers are equal\n\t\t-- (avoid\
    \ division by zero)\n\t\treturn {1}\n\tend\n\t\n\tlocal result = {}\n\tfor _,\
    \ n in ipairs(numbers) do\n\t\ttable.insert(result, (n - small) / (large - small))\n\
    \tend\n\treturn result\nend", "  local min = numbers[1]\n  local max = numbers[1]\n\
    \  for _, num in ipairs(numbers) do\n    if num < min then\n      min = num\n\
    \    elseif num > max then\n      max = num\n    end\n  end\n  local result =\
    \ {}\n  for _, num in ipairs(numbers) do\n    result[#result + 1] = (num - min)\
    \ / (max - min)\n  end\n  return result\nend", "  local minimum = math.min(unpack(numbers))\n\
    \  local maximum = math.max(unpack(numbers))\n  return table.map(numbers, function(number)\n\
    \    return (number - minimum) / (maximum - minimum)\n  end)\nend", "    local\
    \ numbers_copy = tablex.copy(numbers)\n    table.sort(numbers_copy)\n    local\
    \ lower = numbers_copy[1]\n    local upper = numbers_copy[#numbers_copy]\n   \
    \ local span = upper - lower\n    if span == 0 then return end\n    for i, v in\
    \ ipairs(numbers) do\n        numbers[i] = (v - lower) / span\n    end\nend",
  "    local min = torch.min(numbers)\n    local max = torch.max(numbers)\n    local\
    \ result = torch.Tensor(numbers:size()):copy(numbers)\n    result:add(-min)\n\
    \    result:div(max - min)\n    return result\nend", "    local min, max = numbers[1],\
    \ numbers[1]\n    for _, number in ipairs(numbers) do\n        if number < min\
    \ then\n            min = number\n        elseif number > max then\n         \
    \   max = number\n        end\n    end\n    local result = {}\n    for _, number\
    \ in ipairs(numbers) do\n        table.insert(result, (number - min) / (max -\
    \ min))\n    end\n    return result\nend", "\tlocal min, max = numbers[1], numbers[1]\n\
    \tfor _, n in ipairs(numbers) do\n\t\tif n < min then min = n end\n\t\tif n >\
    \ max then max = n end\n\tend\n\tif min == max then return numbers end -- do not\
    \ modify if all numbers are equal", "    local maximum = numbers[1]\n    local\
    \ minimum = numbers[1]\n    for _, v in ipairs(numbers) do\n        maximum =\
    \ math.max(maximum, v)\n        minimum = math.min(minimum, v)\n    end\n    local\
    \ denominator = maximum - minimum\n    if denominator == 0 then\n        denominator\
    \ = 1\n    end\n    local result = {}\n    for _, v in ipairs(numbers) do\n  \
    \      table.insert(result, (v - minimum) / denominator)\n    end\n    return\
    \ result\nend", "  local min, max = numbers[1], numbers[1]\n  for _, v in ipairs(numbers)\
    \ do\n    if v < min then min = v end\n    if v > max then max = v end\n  end\n\
    \  if min == max then\n    return numbers\n  end\n  local result = {}\n  for _,\
    \ v in ipairs(numbers) do\n    table.insert(result, (v - min) / (max - min))\n\
    \  end\n  return result\nend", "    local min, max = numbers[1], numbers[1]\n\
    \    for _, number in ipairs(numbers) do\n        if number < min then\n     \
    \       min = number\n        elseif number > max then\n            max = number\n\
    \        end\n    end\n    local scale = 1 / (max - min)\n    local new_numbers\
    \ = {}\n    for _, number in ipairs(numbers) do\n        table.insert(new_numbers,\
    \ (number - min) * scale)\n    end\n    return new_numbers\nend", "  local scale_factor\
    \ = 1 / (math.max(unpack(numbers)) - math.min(unpack(numbers)))\n  local offset\
    \ = - math.min(unpack(numbers))\n  local new_numbers = {}\n  for _, n in ipairs(numbers)\
    \ do\n    new_numbers[#new_numbers + 1] = (n + offset) * scale_factor\n  end\n\
    \  return new_numbers\nend", "  local mini = math.min(unpack(numbers))\n  local\
    \ maxi = math.max(unpack(numbers))\n  local transformed = {}\n  for i = 1, #numbers\
    \ do\n    local num = numbers[i]\n    transformed[i] = (num - mini) / (maxi -\
    \ mini)\n  end\n  return transformed\nend", "  local data_min = math.min(unpack(numbers))\n\
    \  local data_max = math.max(unpack(numbers))\n  if data_max - data_min < 0.00001\
    \ then\n    data_max = data_min + 0.00001\n  end\n  local data_range = data_max\
    \ - data_min\n  local transform = function(x)\n    return (x - data_min) / data_range\n\
    \  end\n  return utils.transform_table(numbers, transform)\nend", "    local min\
    \ = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n   \
    \ local result = {}\n    for _, v in ipairs(numbers) do\n        table.insert(result,\
    \ (v - min) / (max - min))\n    end\n    return result\nend", "    local min =\
    \ numbers[1]\n    local max = numbers[1]\n    for _, n in ipairs(numbers) do\n\
    \        if n < min then\n            min = n\n        end\n        if n > max\
    \ then\n            max = n\n        end\n    end\n    local rescaled = {}\n \
    \   for _, n in ipairs(numbers) do\n        table.insert(rescaled, (n - min) /\
    \ (max - min))\n    end\n    return rescaled\nend", "    local min = math.min(unpack(numbers))\n\
    \    local max = math.max(unpack(numbers))\n    return (function(number)\n   \
    \     return (number - min) / (max - min)\n    end)(numbers)\nend", "  local smallest\
    \ = numbers[1]\n  local largest = numbers[1]\n  for i = 2, #numbers do\n    if\
    \ numbers[i] < smallest then\n      smallest = numbers[i]\n    elseif numbers[i]\
    \ > largest then\n      largest = numbers[i]\n    end\n  end\n  local span = largest\
    \ - smallest\n  for i = 1, #numbers do\n    numbers[i] = (numbers[i] - smallest)\
    \ / span\n  end\nend", "    local min_n, max_n = math.min(table.unpack(numbers)),\
    \ math.max(table.unpack(numbers))\n    return lmap(\n        function(n)\n   \
    \         return (n - min_n) / (max_n - min_n)\n        end,\n        numbers\n\
    \    )\nend", "    local min = numbers[1]\n    local max = numbers[1]\n    for\
    \ _, number in ipairs(numbers) do\n        if number < min then\n            min\
    \ = number\n        end\n        if number > max then\n            max = number\n\
    \        end\n    end\n    for i, number in ipairs(numbers) do\n        numbers[i]\
    \ = (number - min) / (max - min)\n    end\n    return numbers\nend", "    local\
    \ max = math.max(unpack(numbers))\n    local min = math.min(unpack(numbers))\n\
    \    local add = 0 - min\n    local mul = 1 / (max + add)\n    local list = {}\n\
    \    for _, number in ipairs(numbers) do\n        table.insert(list, (number +\
    \ add) * mul)\n    end\n    return list\nend", "    local min_number = numbers[1]\n\
    \    local max_number = numbers[1]\n    for _, num in ipairs(numbers) do\n   \
    \     if num < min_number then\n            min_number = num\n        end\n  \
    \      if num > max_number then\n            max_number = num\n        end\n \
    \   end\n    local coef = 1 / (max_number - min_number)\n    local ans = {}\n\
    \    for _, num in ipairs(numbers) do\n        table.insert(ans, (num - min_number)\
    \ * coef)\n    end\n    return ans\nend", "    local min, max = math.min(table.unpack(numbers)),\
    \ math.max(table.unpack(numbers))\n    local new_numbers = {}\n    for _, number\
    \ in ipairs(numbers) do\n        table.insert(new_numbers, (number - min) / (max\
    \ - min))\n    end\n    return new_numbers\nend", "    local numbers_min = math.min(unpack(numbers))\n\
    \    local numbers_max = math.max(unpack(numbers))\n    local numbers_range =\
    \ numbers_max - numbers_min\n    local rescaled_numbers = {}\n    for _, number\
    \ in ipairs(numbers) do\n        rescaled_numbers[#rescaled_numbers + 1] = (number\
    \ - numbers_min) / numbers_range\n    end\n    return rescaled_numbers\nend",
  "  local max = numbers[1]\n  local min = numbers[1]\n  for _, number in ipairs(numbers)\
    \ do\n    if number > max then\n      max = number\n    end\n    if number < min\
    \ then\n      min = number\n    end\n  end\n  local range = max - min\n  for i,\
    \ number in ipairs(numbers) do\n    numbers[i] = (number - min) / range\n  end\n\
    \  return numbers\nend", "\tlocal lo, hi = numbers[1], numbers[1]\n\tfor _, n\
    \ in ipairs(numbers) do\n\t\tif n < lo then lo = n end\n\t\tif n > hi then hi\
    \ = n end\n\tend\n\tlocal denominator = hi - lo\n\tfor i, n in ipairs(numbers)\
    \ do\n\t\tnumbers[i] = (n - lo) / denominator\n\tend\nend", "    local largest\
    \ = max(numbers)\n    local smallest = min(numbers)\n    local output = {}\n \
    \   for i = 1, #numbers do\n        local current = numbers[i]\n        output[i]\
    \ = (current - smallest) / (largest - smallest)\n    end\n    return output\n\
    end", "  local min = math.min(unpack(numbers))\n  local max = math.max(unpack(numbers))\n\
    \  local old_range = max - min\n  local new_range = 1 - 0\n  local rescaled =\
    \ {}\n  for _, number in ipairs(numbers) do\n    rescaled[#rescaled + 1] = 0 +\
    \ (number - min) * new_range / old_range\n  end\n  return rescaled\nend", "\t\
    local min_val = math.min(unpack(numbers))\n\tlocal max_val = math.max(unpack(numbers))\n\
    \tlocal scale = 1 / (max_val - min_val)\n\tlocal offset = -min_val * scale\n\t\
    local result = {}\n\tfor i, num in ipairs(numbers) do\n\t\tresult[i] = num * scale\
    \ + offset\n\tend\n\treturn result\nend", "  local min_value = math.min(unpack(numbers))\n\
    \  local max_value = math.max(unpack(numbers))\n  local rescaled = {}\n  for i,\
    \ number in ipairs(numbers) do\n    rescaled[i] = (number - min_value) / (max_value\
    \ - min_value)\n  end\n  return rescaled\nend", "\tlocal min, max = numbers[1],\
    \ numbers[1]\n\tfor _,n in ipairs(numbers) do\n\t\tif n < min then min = n end\n\
    \t\tif n > max then max = n end\n\tend\n\tlocal scale = max - min\n\tlocal res\
    \ = {}\n\tfor _,n in ipairs(numbers) do\n\t\ttable.insert(res, (n - min) / scale)\n\
    \tend\n\treturn res\nend", "  local min_number = min(numbers)\n  local max_number\
    \ = max(numbers)\n  local result = {}\n  for k, num in pairs(numbers) do\n   \
    \ result[k] = (num - min_number) / (max_number - min_number)\n  end\n  return\
    \ result\nend", "  local min, max = torch.min(numbers), torch.max(numbers)\n \
    \ local normalized = numbers:clone()\n  normalized:add(-min):mul(1 / (max - min))\n\
    \  return normalized\nend", "    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for _, num in ipairs(numbers) do\n        if num < min then\n           \
    \ min = num\n        end\n        if num > max then\n            max = num\n \
    \       end\n    end\n    if min == max then\n        return {1}\n    end\n  \
    \  local result = {}\n    for _, num in ipairs(numbers) do\n        table.insert(result,\
    \ (num - min) / (max - min))\n    end\n    return result\nend", "    local min_val\
    \ = math.min(unpack(numbers))\n    local max_val = math.max(unpack(numbers))\n\
    \    local numerators = {}\n    for _, num in ipairs(numbers) do\n        table.insert(numerators,\
    \ num - min_val)\n    end\n    local denominator = max_val - min_val\n    local\
    \ result = {}\n    for _, num in ipairs(numerators) do\n        table.insert(result,\
    \ num / denominator)\n    end\n    return result\nend", "\tlocal smallest, largest\
    \ = math.huge, -math.huge\n\tfor _,v in ipairs(numbers) do\n\t\tsmallest = math.min(smallest,\
    \ v)\n\t\tlargest = math.max(largest, v)\n\tend\n\tlocal scaled = {}\n\tfor _,v\
    \ in ipairs(numbers) do\n\t\ttable.insert(scaled, (v - smallest) / (largest -\
    \ smallest))\n\tend\n\treturn scaled\nend", "    local min_number = math.min(unpack(numbers))\n\
    \    local max_number = math.max(unpack(numbers))\n    local numbers_ = {}\n \
    \   for i = 1, #numbers do\n        numbers_[i] = (numbers[i] - min_number) /\
    \ (max_number - min_number)\n    end\n    return numbers_\nend", "  local min\
    \ = numbers[1]\n  local max = numbers[1]\n  for _, num in ipairs(numbers) do\n\
    \    if num < min then\n      min = num\n    elseif num > max then\n      max\
    \ = num\n    end\n  end\n  local transform = 1 / (max - min)\n  for i, num in\
    \ ipairs(numbers) do\n    numbers[i] = (num - min) * transform\n  end\nend", " \
    \   local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    for i = 1, #numbers do\n        numbers[i] = (numbers[i] - min) / (max -\
    \ min)\n    end\n    return numbers\nend", "\tlocal min, max = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n\tlocal range = max - min\n\tlocal result = {}\n\t\
    for _, number in ipairs(numbers) do\n\t\ttable.insert(result, (number - min) /\
    \ range)\n\tend\n\treturn result\nend", "    local min = numbers[1]\n    local\
    \ max = numbers[1]\n    for i = 2, #numbers do\n        min = math.min(min, numbers[i])\n\
    \        max = math.max(max, numbers[i])\n    end\n    if min == max then return\
    \ numbers end\n    local coef = 1 / (max - min)\n    local result = {}\n    for\
    \ i = 1, #numbers do\n        result[i] = (numbers[i] - min) * coef\n    end\n\
    \    return result\nend", "    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for _, n in ipairs(numbers) do\n        if n < min then\n            min\
    \ = n\n        end\n        if n > max then\n            max = n\n        end\n\
    \    end\n    local diff = max - min\n    for i, n in ipairs(numbers) do\n   \
    \     numbers[i] = (n - min) / diff\n    end\nend", "\tlocal n_min = numbers[1]\n\
    \tlocal n_max = numbers[1]\n\tlocal n_sum = 0", "  local min = numbers[1]\n  local\
    \ max = numbers[1]\n  for i = 2, #numbers do\n    min = math.min(min, numbers[i])\n\
    \    max = math.max(max, numbers[i])\n  end\n  local result = {}\n  for i = 1,\
    \ #numbers do\n    result[i] = (numbers[i] - min) / (max - min)\n  end\n  return\
    \ result\nend", "    assert(#numbers >= 2)\n    local min = numbers[1]\n    local\
    \ max = numbers[1]\n    for i = 2, #numbers do\n        min = math.min(min, numbers[i])\n\
    \        max = math.max(max, numbers[i])\n    end\n    if max - min < EPSILON\
    \ then\n        return vector(#numbers, 1)\n    end\n    local result = vector(#numbers)\n\
    \    for i = 1, #numbers do\n        result[i] = (numbers[i] - min) / (max - min)\n\
    \    end\n    return result\nend", "    local min, max = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n    local result = {}\n    for _, value in ipairs(numbers)\
    \ do\n        result[#result + 1] = (value - min) / (max - min)\n    end\n   \
    \ return result\nend", "\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\t\
    for i = 2, #numbers do\n\t\tif numbers[i] < min then\n\t\t\tmin = numbers[i]\n\
    \t\telseif numbers[i] > max then\n\t\t\tmax = numbers[i]\n\t\tend\n\tend\n\tif\
    \ max == min then\n\t\tfor i = 1, #numbers do\n\t\t\tnumbers[i] = 0\n\t\tend\n\
    \telse\n\t\tfor i = 1, #numbers do\n\t\t\tnumbers[i] = (numbers[i] - min) / (max\
    \ - min)\n\t\tend\n\tend\n\treturn numbers\nend", "    local max = math.max(unpack(numbers))\n\
    \    local min = math.min(unpack(numbers))\n    local value_range = max - min\n\
    \    local result = {}\n    for _, x in ipairs(numbers) do\n        result[#result\
    \ + 1] = (x - min) / value_range\n    end\n    return result\nend", "\tlocal min\
    \ = numbers[1]\n\tlocal max = numbers[1]\n\tfor i = 2, #numbers do\n\t\tmin =\
    \ math.min(min, numbers[i])\n\t\tmax = math.max(max, numbers[i])\n\tend\n\tlocal\
    \ sum = 0\n\tfor i = 1, #numbers do\n\t\tnumbers[i] = (numbers[i] - min) / (max\
    \ - min)\n\t\tsum = sum + numbers[i]\n\tend\n\treturn numbers, sum\nend", "  local\
    \ min = numbers[1]\n  local max = numbers[1]\n  for _,v in ipairs(numbers) do\n\
    \    if min > v then min = v end\n    if max < v then max = v end\n  end\n  local\
    \ result = {}\n  for _,v in ipairs(numbers) do\n    table.insert(result, (v -\
    \ min) / (max - min))\n  end\n  return result\nend", "    local min = math.min(unpack(numbers))\n\
    \    local max = math.max(unpack(numbers))\n    local diff = max - min\n    local\
    \ scaled = {}\n    for _, num in ipairs(numbers) do\n        table.insert(scaled,\
    \ (num - min) / diff)\n    end\n    return scaled\nend", "  local res = {}\n \
    \ local max = -math.huge\n  local min = math.huge\n  for _, n in ipairs(numbers)\
    \ do\n    if n > max then max = n end\n    if n < min then min = n end\n  end\n\
    \  if max == min then\n    return {1.0}\n  end\n  for _, n in ipairs(numbers)\
    \ do\n    table.insert(res, (n - min) / (max - min))\n  end\n  return res\nend",
  "  local max_value = math.max(unpack(numbers))\n  local min_value = math.min(unpack(numbers))\n\
    \  local scaled_values = {}\n  for _, value in ipairs(numbers) do\n    local scaled_value\
    \ = (value - min_value) / (max_value - min_value)\n    table.insert(scaled_values,\
    \ scaled_value)\n  end\n  return scaled_values\nend", "    local min_value = min(numbers)\n\
    \    local max_value = max(numbers)\n    local span = max_value - min_value\n\
    \    for i,value in ipairs(numbers) do\n        numbers[i] = (value - min_value)\
    \ / span\n    end\n    return numbers\nend", "    local min = math.min(unpack(numbers))\n\
    \    local max = math.max(unpack(numbers))\n    return (numbers - min) / (max\
    \ - min)\nend", "  local min_number = math.min(unpack(numbers))\n  local max_number\
    \ = math.max(unpack(numbers))\n  local range = max_number - min_number\n  if range\
    \ == 0 then\n    -- TODO(Jonas): This is a hack and should be handled better\n\
    \    range = 0.01\n  end\n  local numbers_normalized = {}\n  for k, number in\
    \ pairs(numbers) do\n    numbers_normalized[k] = (number - min_number) / range\n\
    \  end\n  return numbers_normalized\nend", "\tlocal min = numbers[1]\n\tlocal\
    \ max = numbers[1]\n\tfor _, n in ipairs(numbers) do\n\t\tif n < min then\n\t\t\
    \tmin = n\n\t\tend\n\t\tif n > max then\n\t\t\tmax = n\n\t\tend\n\tend\n\tlocal\
    \ scaled = {}\n\tfor _, n in ipairs(numbers) do\n\t\ttable.insert(scaled, (n -\
    \ min) / (max - min))\n\tend\n\treturn scaled\nend", "    local numbers_copy =\
    \ {}\n    for i, v in ipairs(numbers) do\n        numbers_copy[i] = v\n    end\n\
    \    table.sort(numbers_copy)\n    local min = numbers_copy[1]\n    local max\
    \ = numbers_copy[#numbers_copy]\n    local scale = max - min\n    for i, v in\
    \ ipairs(numbers) do\n        numbers[i] = (v - min) / scale\n    end\nend", " \
    \   local minimum = math.min(unpack(numbers))\n    local maximum = math.max(unpack(numbers))\n\
    \    local range = maximum - minimum\n    local scaled = {}\n    for i = 1, #numbers\
    \ do\n        scaled[i] = (numbers[i] - minimum) / range\n    end\n    return\
    \ scaled\nend", "\tlocal max_num = -math.huge\n\tlocal min_num = math.huge\n\t\
    for _, n in ipairs(numbers) do\n\t\tif n > max_num then\n\t\t\tmax_num = n\n\t\
    \tend\n\t\tif n < min_num then\n\t\t\tmin_num = n\n\t\tend\n\tend\n\tlocal diff\
    \ = max_num - min_num\n\tfor i, n in ipairs(numbers) do\n\t\tnumbers[i] = (n -\
    \ min_num) / diff\n\tend\n\treturn numbers\nend", "\tlocal min, max = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n\tlocal transform = function(x) return (x - min)\
    \ / (max - min) end\n\treturn map(transform, numbers)\nend", "\tlocal max, min\
    \ = math.max(unpack(numbers)), math.min(unpack(numbers))\n\treturn min == max\
    \ and 0 or (numbers - min) / (max - min)\nend", "    local max = numbers[1]\n\
    \    local min = numbers[1]\n    for _, n in ipairs(numbers) do\n        if n\
    \ > max then\n            max = n\n        end\n        if n < min then\n    \
    \        min = n\n        end\n    end\n    local transform = function(x)\n  \
    \      return (x - min) / (max - min)\n    end\n    return transform\nend", " \
    \   local min_value = min(numbers)\n    local max_value = max(numbers)\n    local\
    \ result = {}\n    local result_value\n    for _, number in ipairs(numbers) do\n\
    \        if (max_value == min_value) then\n            result_value = 0\n    \
    \    else\n            result_value = (number - min_value) / (max_value - min_value)\n\
    \        end\n        table.insert(result, result_value)\n    end\n    return\
    \ result\nend", "  local nmax = max(numbers)\n  local nmin = min(numbers)\n  local\
    \ nrange = nmax - nmin\n  local result = {}\n  for _, v in ipairs(numbers) do\n\
    \    table.insert(result, (v - nmin) / nrange)\n  end\n  return result\nend",
  "\tlocal min, max = min_max(numbers)\n\tlocal span = max - min\n\tif span <= 0 then\n\
    \t\treturn numbers -- not changing anything if there is no span\n\tend\n\t\n\t\
    local result = {}\n\tfor i, number in ipairs(numbers) do\n\t\tlocal new = (number\
    \ - min) / span\n\t\tresult[i] = new\n\tend\n\treturn result\nend", "  local min\
    \ = min(numbers)\n  local max = max(numbers)\n  local rescaled = {}\n  for _,\
    \ num in ipairs(numbers) do\n    local r = (num - min) / (max - min)\n    table.insert(rescaled,\
    \ r)\n  end\n  return rescaled\nend", "    local min_val = math.min(unpack(numbers))\n\
    \    local max_val = math.max(unpack(numbers))\n    local range = max_val - min_val\n\
    \    local factor = 1/range\n    local scaled_numbers = {}\n    for i,n in ipairs(numbers)\
    \ do\n        scaled_numbers[i] = (n - min_val) * factor\n    end\n    return\
    \ scaled_numbers\nend", "  local min, max = numbers[1], numbers[1]\n  for _,n\
    \ in ipairs(numbers) do\n    if n < min then min = n end\n    if n > max then\
    \ max = n end\n  end\n  local a, b = 1 / (max - min), min\n  return a, b\nend",
  "  local min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n  for\
    \ i, x in ipairs(numbers) do\n    numbers[i] = (x - min) / (max - min)\n  end\n\
    \  return numbers\nend", "  -- Find minimum and maximum\n  local min, max = math.huge,\
    \ -math.huge\n  for _, v in ipairs(numbers) do\n    min = math.min(min, v)\n \
    \   max = math.max(max, v)\n  end", "  assert(#numbers >= 2)\n  local max_val\
    \ = math.max(unpack(numbers))\n  local min_val = math.min(unpack(numbers))\n \
    \ local range = max_val - min_val\n  if range == 0 then\n    -- if the numbers\
    \ are all identical, return a list of zeros\n    return {0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0",
  "\tlocal min = min_in_table(numbers)\n\tlocal max = max_in_table(numbers)\n\tlocal\
    \ new_table = {}\n\tfor k, v in pairs(numbers) do\n\t\tnew_table[k] = (v - min)\
    \ / (max - min)\n\tend\n\treturn new_table\nend", "  local min_num = math.min(unpack(numbers))\n\
    \  local max_num = math.max(unpack(numbers))\n  local vec = {}\n  for i, v in\
    \ ipairs(numbers) do\n    vec[i] = (v - min_num) / (max_num - min_num)\n  end\n\
    \  return vec\nend", "\tlocal min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n\
    \tlocal delta = max - min\n\tfor i = 1, #numbers do\n\t\tnumbers[i] = (numbers[i]\
    \ - min) / delta\n\tend\n\treturn numbers\nend", "\tlocal largest = -math.huge\n\
    \tlocal smallest = math.huge\n\tfor i,v in ipairs(numbers) do\n\t\tif v > largest\
    \ then\n\t\t\tlargest = v\n\t\tend\n\t\tif v < smallest then\n\t\t\tsmallest =\
    \ v\n\t\tend\n\tend\n\tif smallest == largest then\n\t\treturn {1}\n\tend\n\t\
    local distance = largest - smallest\n\tlocal result = {}\n\tfor i,v in ipairs(numbers)\
    \ do\n\t\tresult[i] = (v - smallest) / distance\n\tend\n\treturn result\nend",
  "  local min, max = math.min(table.unpack(numbers)), math.max(table.unpack(numbers))\n\
    \  local linear_transform = function(x) return (x - min) / (max - min) end\n \
    \ return table.map(linear_transform, numbers)\nend", "\tlocal min = math.min(unpack(numbers))\n\
    \tlocal max = math.max(unpack(numbers))\n\tlocal range = max - min\n\tlocal result\
    \ = {}\n\tfor i, n in ipairs(numbers) do\n\t\tif range == 0 then\n\t\t\tresult[i]\
    \ = 0\n\t\telse\n\t\t\tresult[i] = (n - min) / range\n\t\tend\n\tend\n\treturn\
    \ result\nend", "    assert(#numbers >= 2)\n    local max_number = math.max(unpack(numbers))\n\
    \    local min_number = math.min(unpack(numbers))\n    for k, v in ipairs(numbers)\
    \ do\n        numbers[k] = (v - min_number) / (max_number - min_number)\n    end\n\
    end", "  local range = numbers[1] - numbers[#numbers]\n  for i = 1, #numbers do\n\
    \    numbers[i] = (numbers[i] - numbers[1]) / range\n  end\n  return numbers\n\
    end", "    local min, max = math.min(table.unpack(numbers)), math.max(table.unpack(numbers))\n\
    \    return vector.map(numbers, function(x) return (x - min) / (max - min) end)\n\
    end", "    -- find min and max values\n    local min_value = math.huge\n    local\
    \ max_value = -math.huge\n    for i, value in ipairs(numbers) do\n        if value\
    \ < min_value then\n            min_value = value\n        end\n        if value\
    \ > max_value then\n            max_value = value\n        end\n    end", "  \
    \  local max_number = math.max(unpack(numbers))\n    local min_number = math.min(unpack(numbers))\n\
    \    local step = (max_number - min_number) / (#numbers - 1)\n    local scaled_numbers\
    \ = {}\n    for index, value in ipairs(numbers) do\n        scaled_numbers[index]\
    \ = (value - min_number) / step\n    end\n    return scaled_numbers\nend", " \
    \   local min, max = numbers[1], numbers[1]\n    for _, num in ipairs(numbers)\
    \ do\n        if num < min then\n            min = num\n        elseif num > max\
    \ then\n            max = num\n        end\n    end\n    local span = max - min\n\
    \    for i, num in ipairs(numbers) do\n        numbers[i] = (num - min) / span\n\
    \    end\nend", "\tlocal largest, smallest = numbers[1], numbers[1]\n\tfor _,\
    \ number in ipairs(numbers) do\n\t\tif number > largest then\n\t\t\tlargest =\
    \ number\n\t\telseif number < smallest then\n\t\t\tsmallest = number\n\t\tend\n\
    \tend\n\tif largest == smallest then\n\t\treturn nil\n\tend\n\tlocal ret = {}\n\
    \tfor _, number in ipairs(numbers) do\n\t\ttable.insert(ret, (number - smallest)\
    \ / (largest - smallest))\n\tend\n\treturn ret\nend", "  local s = torch.Tensor(numbers)\n\
    \  local sn = s:clone()\n  local m, _ = s:min(1)\n  sn:add(-m[1][1])\n  local\
    \ m, _ = sn:max(1)\n  sn:div(m[1][1])\n  return sn\nend", "  assert(type(numbers)\
    \ == \"table\", \"Expected table of numbers, got: \" .. type(numbers))\n  assert(#numbers\
    \ >= 2, \"Expected table of at least two numbers, got: \" .. #numbers)", "   \
    \ local max_n = -1/0\n    local min_n = 1/0\n    for _, n in ipairs(numbers) do\n\
    \        if n > max_n then\n            max_n = n\n        end\n        if n <\
    \ min_n then\n            min_n = n\n        end\n    end\n    local numbers_rescaled\
    \ = {}\n    for _, n in ipairs(numbers) do\n        table.insert(numbers_rescaled,\
    \ (n - min_n) / (max_n - min_n))\n    end\n    return numbers_rescaled\nend",
  "\tlocal min = math.min(unpack(numbers))\n\tlocal max = math.max(unpack(numbers))\n\
    \tlocal diff = max - min\n\treturn table.map(numbers, function(n) return (n -\
    \ min) / diff end)\nend", "    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for _, num in ipairs(numbers) do\n        if num < min then\n           \
    \ min = num\n        end\n        if num > max then\n            max = num\n \
    \       end\n    end\n    local span = max - min\n    for i, num in ipairs(numbers)\
    \ do\n        numbers[i] = (num - min) / span\n    end\nend", "    local min =\
    \ math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n    local\
    \ scale = max - min\n    local result = {}\n    for i = 1, #numbers do\n     \
    \   result[i] = (numbers[i] - min) / scale\n    end\n    return result\nend",
  "    local min = numbers[1]\n    local max = numbers[1]\n    for i = 2, #numbers\
    \ do\n        if numbers[i] < min then\n            min = numbers[i]\n       \
    \ elseif numbers[i] > max then\n            max = numbers[i]\n        end\n  \
    \  end\n    local result = {}\n    for i = 1, #numbers do\n        result[i] =\
    \ (numbers[i] - min) / (max - min)\n    end\n    return result\nend", "    local\
    \ min, max = math.min(table.unpack(numbers)), math.max(table.unpack(numbers))\n\
    \    local new_numbers = {}\n    for _, number in ipairs(numbers) do\n       \
    \ new_numbers[#new_numbers + 1] = (number - min) / (max - min)\n    end\n    return\
    \ new_numbers\nend", "    local nMin = math.min(unpack(numbers))\n    local nMax\
    \ = math.max(unpack(numbers))\n    local nDiff = nMax - nMin\n    local nResult\
    \ = {}\n    for i, v in ipairs(numbers) do\n        nResult[i] = (v - nMin) /\
    \ nDiff\n    end\n    return nResult\nend", "\tlocal min, max = util.min_max(numbers)\n\
    \tif min == max then\n\t\treturn numbers\n\tend\n\tlocal result = {}\n\tfor _,n\
    \ in ipairs(numbers) do\n\t\ttable.insert(result, (n - min) / (max - min))\n\t\
    end\n\treturn result\nend", "    local mi = math.min(unpack(numbers))\n    local\
    \ ma = math.max(unpack(numbers))\n    return table.map(numbers, function(number)\n\
    \        return (number - mi) / (ma - mi)\n    end)\nend", "  local min_number\
    \ = math.min(unpack(numbers))\n  local max_number = math.max(unpack(numbers))\n\
    \  local span = max_number - min_number\n  for i, number in ipairs(numbers) do\n\
    \    numbers[i] = (number - min_number) / span\n  end\n  return numbers\nend",
  "    local min = numbers[1]\n    local max = numbers[1]\n    for _, n in ipairs(numbers)\
    \ do\n        if n < min then\n            min = n\n        end\n        if n\
    \ > max then\n            max = n\n        end\n    end\n    local new = {}\n\
    \    for _, n in ipairs(numbers) do\n        table.insert(new, (n - min) / (max\
    \ - min))\n    end\n    return new\nend", "    -- http://math.stackexchange.com/questions/70934/find-the-equation-of-a-linear-transformation\n\
    \    local max_x = math.max(unpack(numbers))\n    local min_x = math.min(unpack(numbers))\n\
    \    local a = 1 / (max_x - min_x)\n    local b = -min_x * a\n    local result\
    \ = {}\n    for i = 1, #numbers do\n        result[i] = a * numbers[i] + b\n \
    \   end\n    return result\nend", "\tlocal n_min = math.min(unpack(numbers))\n\
    \tlocal n_max = math.max(unpack(numbers))\n\tlocal n_range = n_max - n_min\n\t\
    return map(function(x) return (x - n_min) / n_range end, numbers)\nend", "   \
    \ local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local new_numbers = {}\n    for _, number in ipairs(numbers) do\n       \
    \ new_numbers[#new_numbers + 1] = (number - min) / (max - min)\n    end\n    return\
    \ new_numbers\nend", "  local min_n, max_n = numbers[1], numbers[1]\n  for _,\
    \ n in ipairs(numbers) do\n    min_n = math.min(min_n, n)\n    max_n = math.max(max_n,\
    \ n)\n  end\n  return (function()\n    local _accum_0 = { }\n    local _len_0\
    \ = 1\n    for _index_0 = 1, #numbers do\n      local n = numbers[_index_0]\n\
    \      _accum_0[_len_0] = math.max(0, math.min(1, (n - min_n) / (max_n - min_n)))\n\
    \      _len_0 = _len_0 + 1\n    end\n    return _accum_0\n  end)()\nend", "\t\
    local mn, mx = nil, nil\n\tfor i,n in ipairs(numbers) do\n\t\tif mn == nil or\
    \ n < mn then mn = n end\n\t\tif mx == nil or n > mx then mx = n end\n\tend\n\t\
    local range = mx - mn\n\tlocal result = {}\n\tfor i,n in ipairs(numbers) do\n\t\
    \ttable.insert(result, (n - mn) / range)\n\tend\n\treturn result\nend", "    local\
    \ max = numbers[1]\n    local min = numbers[1]\n    for _, v in ipairs(numbers)\
    \ do\n        if v > max then\n            max = v\n        end\n        if v\
    \ < min then\n            min = v\n        end\n    end\n    local diff = max\
    \ - min\n    for i, v in ipairs(numbers) do\n        numbers[i] = (v - min) /\
    \ diff\n    end\n    return numbers\nend", "\tlocal min_val = numbers[1]\n\tlocal\
    \ max_val = numbers[1]\n\tfor _, n in ipairs(numbers) do\n\t\tif n < min_val then\n\
    \t\t\tmin_val = n\n\t\tend\n\t\tif n > max_val then\n\t\t\tmax_val = n\n\t\tend\n\
    \tend\n\tlocal new_numbers = {}\n\tfor _, n in ipairs(numbers) do\n\t\tlocal new_val\
    \ = (n - min_val) / (max_val - min_val)\n\t\ttable.insert(new_numbers, new_val)\n\
    \tend\n\treturn new_numbers\nend", "\tlocal min, max = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n\tlocal delta = max - min\n\tfor i = 1, #numbers\
    \ do\n\t\tnumbers[i] = (numbers[i] - min) / delta\n\tend\n\treturn numbers\nend",
  "\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\tlocal N = #numbers\n\tfor\
    \ i = 2, N do\n\t\tif numbers[i] < min then\n\t\t\tmin = numbers[i]\n\t\telseif\
    \ numbers[i] > max then\n\t\t\tmax = numbers[i]\n\t\tend\n\tend\n\tif max == min\
    \ then\n\t\treturn nil\n\tend\n\tlocal scaled = {}\n\tfor i = 1, N do\n\t\tscaled[i]\
    \ = (numbers[i] - min) / (max - min)\n\tend\n\treturn scaled\nend", "  -- Get\
    \ the minimum and maximum values\n  local min_value = math.min(unpack(numbers))\n\
    \  local max_value = math.max(unpack(numbers))", "\tlocal min, max = numbers[1],\
    \ numbers[1]\n\tfor _, n in ipairs(numbers) do\n\t\tif n < min then min = n end\n\
    \t\tif n > max then max = n end\n\tend\n\tlocal interval = max - min\n\tfor i,\
    \ n in ipairs(numbers) do\n\t\tnumbers[i] = (n - min) / interval\n\tend\nend",
  "\tlocal min = numbers[1]\n\tlocal max = numbers[1]\n\tfor _, n in ipairs(numbers)\
    \ do\n\t\tif n < min then\n\t\t\tmin = n\n\t\tend\n\t\tif n > max then\n\t\t\t\
    max = n\n\t\tend\n\tend\n\tlocal new_numbers = {}\n\tfor _, n in ipairs(numbers)\
    \ do\n\t\ttable.insert(new_numbers, (n - min) / (max - min))\n\tend\n\treturn\
    \ new_numbers\nend", "  -- get the minimum and maximum\n  local max = math.max(unpack(numbers))\n\
    \  local min = math.min(unpack(numbers))\n  -- apply rescaling\n  local rescaled\
    \ = {}\n  for i, v in ipairs(numbers) do\n    rescaled[i] = (v - min) / (max -\
    \ min)\n  end\n  return rescaled\nend", "  local min = math.min(unpack(numbers))\n\
    \  local max = math.max(unpack(numbers))\n  local rescaled = {}\n  for i,v in\
    \ ipairs(numbers) do\n    rescaled[i] = (v - min) / (max - min)\n  end\n  return\
    \ rescaled\nend", "\tlocal min, max = numbers[1], numbers[1]\n\tfor _,number in\
    \ ipairs(numbers) do\n\t\tif number < min then min = number end\n\t\tif number\
    \ > max then max = number end\n\tend\n\tfor i=1,#numbers do\n\t\tnumbers[i] =\
    \ (numbers[i] - min) / (max - min)\n\tend\n\treturn numbers\nend", "\t-- find\
    \ the minimum and maximum values\n\tlocal min_val = numbers[1]\n\tlocal max_val\
    \ = numbers[1]\n\tfor i, number in ipairs(numbers) do\n\t\tif number < min_val\
    \ then\n\t\t\tmin_val = number\n\t\tend\n\t\tif number > max_val then\n\t\t\t\
    max_val = number\n\t\tend\n\tend\n\tlocal delta = max_val - min_val\n\t\n\tlocal\
    \ result = {}\n\tfor i, number in ipairs(numbers) do\n\t\tif delta == 0 then\n\
    \t\t\tresult[i] = 0\n\t\telse\n\t\t\tresult[i] = (number - min_val) / delta\n\t\
    \tend\n\tend\n\treturn result\nend", "  local lowest, highest = math.min(unpack(numbers)),\
    \ math.max(unpack(numbers))\n  local factor = highest - lowest\n  local rescaled\
    \ = {}\n  for i, n in ipairs(numbers) do\n    rescaled[i] = (n - lowest) / factor\n\
    \  end\n  return rescaled\nend", "    local biggest = numbers[1]\n    local smallest\
    \ = numbers[1]\n    for i, number in ipairs(numbers) do\n        if biggest <\
    \ number then\n            biggest = number\n        end\n        if smallest\
    \ > number then\n            smallest = number\n        end\n    end\n    local\
    \ unit = {}\n    for i, number in ipairs(numbers) do\n        unit[i] = (number\
    \ - smallest) / (biggest - smallest)\n    end\n    return unit\nend", "    local\
    \ min = torch.min(numbers)\n    local max = torch.max(numbers)\n    local rescaled\
    \ = torch.Tensor(numbers:size())\n    for i = 1, numbers:size(1) do\n        rescaled[i]\
    \ = (numbers[i] - min) / (max - min)\n    end\n    return rescaled\nend", "  \
    \  local a, b = math.min(unpack(numbers)), math.max(unpack(numbers))\n    return\
    \ tablex.imap(function(n) return (n - a) / (b - a) end, numbers)\nend", "    local\
    \ maxval = numbers[1]\n    local minval = numbers[1]\n    for _, v in ipairs(numbers)\
    \ do\n        if v > maxval then\n            maxval = v\n        end\n      \
    \  if v < minval then\n            minval = v\n        end\n    end\n    local\
    \ scale = maxval - minval\n    local rescaled = {}\n    for _, v in ipairs(numbers)\
    \ do\n        table.insert(rescaled, (v - minval) / scale)\n    end\n    return\
    \ rescaled\nend", "    local max_number = torch.max(numbers)\n    local min_number\
    \ = torch.min(numbers)\n    local result = torch.cdiv(torch.csub(numbers, min_number),\
    \ torch.csub(max_number, min_number))\n    return result\nend", "  local lowest,\
    \ highest = unpack(numbers)\n  for _, number in ipairs(numbers) do\n    if number\
    \ < lowest then\n      lowest = number\n    elseif number > highest then\n   \
    \   highest = number\n    end\n  end\n  return (numbers - lowest) / (highest -\
    \ lowest)\nend", "    local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local scale = 1 / (max - min)\n    local translate = -min\n    return map(function(num)\
    \ return (num + translate) * scale end, numbers)\nend", "  local max, min = -math.huge,\
    \ math.huge\n  for _, v in ipairs(numbers) do\n    if v > max then max = v end\n\
    \    if v < min then min = v end\n  end\n  if max == min then return numbers end\n\
    \  for i, v in ipairs(numbers) do\n    numbers[i] = (v - min) / (max - min)\n\
    \  end\n  return numbers\nend", "\tlocal min_val = math.min(unpack(numbers))\n\
    \tlocal max_val = math.max(unpack(numbers))\n\tlocal diff = max_val - min_val\n\
    \tlocal rescaled = {}\n\tfor _,v in ipairs(numbers) do\n\t\tlocal y = (v - min_val)\
    \ / diff\n\t\ttable.insert(rescaled, y)\n\tend\n\treturn rescaled\nend", "  local\
    \ x_min = numbers[1]\n  local x_max = numbers[1]\n  for _,x in ipairs(numbers)\
    \ do\n    if x_min > x then x_min = x end\n    if x_max < x then x_max = x end\n\
    \  end\n  local a = 1/(x_max - x_min)\n  local b = -a*x_min\n  local result =\
    \ {}\n  for _,x in ipairs(numbers) do\n    table.insert(result, a*x + b)\n  end\n\
    \  return result\nend", "  local max, min = -math.huge, math.huge\n  for _, n\
    \ in ipairs(numbers) do\n    if n > max then max = n end\n    if n < min then\
    \ min = n end\n  end\n  local span = max - min\n  local result = {}\n  for _,\
    \ n in ipairs(numbers) do\n    local x = (n - min) / span\n    result[#result\
    \ + 1] = x\n  end\n  return result\nend", "    local range = numbers[#numbers]\
    \ - numbers[1]\n    local result = {}\n    for i, v in ipairs(numbers) do\n  \
    \      result[i] = (v - numbers[1]) / range\n    end\n    return result\nend",
  "  assert(#numbers >= 2)\n  local max_input = math.max(unpack(numbers))\n  local\
    \ min_input = math.min(unpack(numbers))\n  local output = {}\n  for _, number\
    \ in ipairs(numbers) do\n    if number == max_input then\n      table.insert(output,\
    \ 1)\n    elseif number == min_input then\n      table.insert(output, 0)\n   \
    \ else\n      local scaled = (number - min_input) / (max_input - min_input)\n\
    \      table.insert(output, scaled)\n    end\n  end\n  return output\nend", " \
    \   local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local scale = max - min\n    local rescaled = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(rescaled, (number - min) / scale)\n    end\n    return\
    \ rescaled\nend", "    assert(#numbers >= 2)\n    local maxval = math.max(unpack(numbers))\n\
    \    local minval = math.min(unpack(numbers))\n    local res = {}\n    for i,\
    \ v in ipairs(numbers) do\n        res[i] = (v - minval) / (maxval - minval)\n\
    \    end\n    return res\nend", "    local min = math.min(unpack(numbers))\n \
    \   local max = math.max(unpack(numbers))\n    local result = {}\n    for _,v\
    \ in ipairs(numbers) do\n        result[#result+1] = (v - min) / (max - min)\n\
    \    end\n    return result\nend", "    local min = min_in_list(numbers)\n   \
    \ local max = max_in_list(numbers)\n    local result = {}\n    for i = 1, #numbers\
    \ do\n        result[i] = (numbers[i] - min) / (max - min)\n    end\n    return\
    \ result\nend", "  local min = math.min(unpack(numbers))\n  local max = math.max(unpack(numbers))\n\
    \  local span = max - min\n  for i, v in ipairs(numbers) do\n    numbers[i] =\
    \ (v - min) / span\n  end\n  return numbers\nend", "    local min = math.min(unpack(numbers))\n\
    \    local max = math.max(unpack(numbers))\n    local diff = max - min\n    local\
    \ rescaled = {}\n    for _, num in ipairs(numbers) do\n        table.insert(rescaled,\
    \ (num - min) / diff)\n    end\n    return rescaled\nend", "    local max_ = math.max(unpack(numbers))\n\
    \    local min_ = math.min(unpack(numbers))\n    local span = max_ - min_\n  \
    \  if span == 0 then\n        return numbers\n    end\n    local new_numbers =\
    \ {}\n    for _, n in ipairs(numbers) do\n        table.insert(new_numbers, (n\
    \ - min_) / span)\n    end\n    return new_numbers\nend", "    local max_index,\
    \ max_value = find_max(numbers)\n    local min_index, min_value = find_min(numbers)\n\
    \    local range = max_value - min_value\n    for i = 1, #numbers do\n       \
    \ numbers[i] = (numbers[i] - min_value) / range\n    end\n    return numbers\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
