name: HumanEval_80_is_happy
language: lua
prompt: "-- You are given a string s.\n-- Your task is to check if the string is happy\
  \ or not.\n-- A string is happy if its length is at least 3 and every 3 consecutive\
  \ letters are distinct\n-- For example:\nlocal function is_happy(s)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_happy\n\
  \    lu.assertEquals(candidate('a'), false)\n    lu.assertEquals(candidate('aa'),\
  \ false)\n    lu.assertEquals(candidate('abcd'), true)\n    lu.assertEquals(candidate('aabb'),\
  \ false)\n    lu.assertEquals(candidate('adb'), true)\n    lu.assertEquals(candidate('xyy'),\
  \ false)\n    lu.assertEquals(candidate('iopaxpoi'), true)\n    lu.assertEquals(candidate('iopaxioi'),\
  \ false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local i = 1\n    local c = 0\n    local n = #s\n    while i <=\
    \ n do\n        if i + 2 <= n and s[i] ~= s[i + 1] and s[i] ~= s[i + 2] and s[i\
    \ + 1] ~= s[i + 2] then\n            c = c + 1\n            i = i + 3\n      \
    \  else\n            i = i + 1\n        end\n    end\n    return c > 0\nend",
  "    return s:len() >= 3 and s:match('(.)%1%1') == nil\nend", "  local i = 1\n \
    \ while i <= #s do\n    if #s - i < 2 then return true end\n    if s:sub(i, i\
    \ + 2):byte(1) == s:sub(i, i + 2):byte(2) then return false end\n    if s:sub(i,\
    \ i + 2):byte(1) == s:sub(i, i + 2):byte(3) then return false end\n    if s:sub(i,\
    \ i + 2):byte(2) == s:sub(i, i + 2):byte(3) then return false end\n    i = i +\
    \ 1\n  end\n  return true\nend", "    if s:len() < 3 then\n        return false\n\
    \    end\n    local c = s:sub(1, 3)\n    return not c:find(c:sub(1, 1), 2)\nend",
  "    return string.find(s, '^(%w%w%w)%1.*$') == nil\nend", "  -- your code here\n\
    \  if s:len() < 3 then\n    return false\n  end\n  for i = 1, s:len() - 2 do\n\
    \    if s:sub(i, i + 2):match('(.).%1.%1') then\n      return false\n    end\n\
    \  end\n  return true\nend", "    if s == \"\" or string.len(s) < 3 then\n   \
    \     return false\n    end\n    for i = 1, string.len(s) - 2 do\n        if string.sub(s,\
    \ i, i) == string.sub(s, i + 1, i + 1)\n            or string.sub(s, i, i) ==\
    \ string.sub(s, i + 2, i + 2)\n            or string.sub(s, i + 1, i + 1) == string.sub(s,\
    \ i + 2, i + 2) then\n            return false\n        end\n    end\n    return\
    \ true\nend", "    local len = #s\n    if len < 3 then\n        return false\n\
    \    end\n    local char1 = s:sub(1,1)\n    local char2 = s:sub(2,2)\n    local\
    \ char3 = s:sub(3,3)\n    for i = 4, len, 1 do\n        if char1 == char2 or char1\
    \ == char3 or char2 == char3 then\n            return false\n        end\n   \
    \     char1 = char2\n        char2 = char3\n        char3 = s:sub(i,i)\n    end\n\
    \    return true\nend", "    return s:match('^(?:(.)(.)(.)).*%1%2%3$') and true\
    \ or false\nend", "  local n = string.len(s)\n  if n < 3 then return false end\n\
    \  for i = 1, n - 2 do\n    if s:sub(i, i) == s:sub(i + 1, i + 1) or s:sub(i,\
    \ i) == s:sub(i + 2, i + 2) or s:sub(i + 1, i + 1) == s:sub(i + 2, i + 2) then\n\
    \      return false\n    end\n  end\n  return true\nend", "    return #s >= 3\
    \ and s:match(\"^(%a)%1%1\") == nil\nend\nassert(is_happy(\"abcabcabc\") == true)\n\
    assert(is_happy(\"abccbaabccba\") == false)\nassert(is_happy(\"abccbacbccba\"\
    ) == true)\nassert(is_happy(\"abc\") == false)\nassert(is_happy(\"aaa\") == false)\n\
    assert(is_happy(\"aaaa\") == false)\nassert(is_happy(\"aaaaa\") == true)\nassert(is_happy(\"\
    aaaaaa\") == false)\nassert(is_happy(\"aaaaaaa\") == false)\nassert(is_happy(\"\
    aaaaaaaa\") == true)\nassert(is_happy(\"aaaaaaaaa\") == false)\nassert(is_happy(\"\
    aaaaaaaaaa\") == false)\nassert(is_happy(\"aaaaaaaaaaa\") == true)\nassert(is_happy(\"\
    aaaaaaaaaaaa\") == false)\nassert(is_happy(\"aaaaaaaaaaaaa\") == false)\nassert(is_happy(\"\
    aaaaaaaaaaaaaa\") == true)\nassert(is_happy(\"aaaaaaaaaaaaaaa\") == false)\nassert(is_happy(\"\
    aaaaaaaaaaaaaaaa\") == false)\nassert(is_happy(\"aaaaaaaaaaaaaaaaa\") == true)\n\
    assert(is_happy(\"aaaaaaaaaaaaaaaaaa\") == false)\nassert(is_happy(\"aaaaaaaaaaaaaaaaaaa\"\
    ) == false)\nassert(is_happy(\"aaaaaaaaaaaaaaaaaaaa\") == true)\nassert(is_happy(\"\
    aaaaaaaaaaaaaaaaaaaaa\") == false)\nassert(is_happy(\"aaaaaaaaaaaaaaaaaaaaaa\"\
    ) == false)\nassert(is_happy(\"aaaaaaaaaaaaaaaaaaaaaaa\") == true)\nassert(is_happy(\"\
    aaaaaaaaaaaaaaaaaaaaaaaa\") == false)\nassert(is_happy(\"aaaaaaaaaaaaaaaaaaaaaaaaa\"\
    ) == false)\nassert(is_happy(\"aaaaaaaaaaaaaaaaaaaaaaaaaa\") == true)\nassert(is_happy(\"\
    aaaaaaaaaaaaaaaaaaaaaaaaaaa\") == false)\nassert(is_happy(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    ) == false)\nassert(is_happy(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") == true)\nassert(is_happy(\"\
    aaaaaaaaaaaa", "    return nil\nend", "    -- check the length\n    if s:len()\
    \ < 3 then\n        return false\n    end\n    -- check the consecutive letters\n\
    \    for i = 1, #s - 2 do\n        if s:sub(i, i + 2):match('(.)%1') then\n  \
    \          return false\n        end\n    end\n    return true\nend", "  if #s\
    \ < 3 then return false end\n  for i = 1, #s - 2 do\n    if s:sub(i, i + 2) ==\
    \ s:sub(i + 1, i + 3) then return false end\n  end\n  return true\nend", "  for\
    \ i = 1, #s - 2 do\n    if s:sub(i, i + 2) == s:sub(i + 1, i + 3) then\n     \
    \ return false\n    end\n  end\n  return #s >= 3\nend", "  return string.len(s)\
    \ >= 3 and not s:match(\"(.).%1.%1\")\nend", "    local t = {}\n    for i = 1,\
    \ #s - 2 do\n        if s:sub(i, i + 2) ~= s:sub(i + 1, i + 3) then\n        \
    \    table.insert(t, s:sub(i, i + 2))\n        end\n    end\n    return #t ==\
    \ #s - 2\nend", "    if s:len() < 3 then\n        return false\n    end\n    local\
    \ three = s:sub(1, 3)\n    if three:sub(1, 1) == three:sub(2, 2) then\n      \
    \  return false\n    end\n    if three:sub(1, 1) == three:sub(3, 3) then\n   \
    \     return false\n    end\n    if three:sub(2, 2) == three:sub(3, 3) then\n\
    \        return false\n    end\n    return true\nend", "    if #s < 3 then\n \
    \       return false\n    end\n    -- split in 3 letter chunks\n    local chunks\
    \ = string_chunks(s, 3)\n    -- check that they are different\n    local last\n\
    \    for i, chunk in ipairs(chunks) do\n        if last and chunk == last then\n\
    \            return false\n        end\n        last = chunk\n    end\n    return\
    \ true\nend", "    if #s < 3 then\n        return false\n    end\n    for i =\
    \ 1, #s - 2 do\n        if s:sub(i, i + 2):find(s:sub(i, i)) then\n          \
    \  return false\n        end\n    end\n    return true\nend", "  if #s < 3 then\
    \ return false end\n  for i = 1, #s - 2 do\n    if s:sub(i, i + 2) == s:sub(i\
    \ + 1, i + 3) then return false end\n  end\n  return true\nend", "  if #s < 3\
    \ then return false end\n  local i = 0\n  while i < #s do\n    if s:sub(i+1, i+3)\
    \ == s:sub(i+2, i+4) then return false end\n    i = i + 1\n  end\n  return true\n\
    end", "\tlocal i, j = 1, 4\n\tfor j = 4, #s do\n\t\tlocal c = s:sub(i, j)\n\t\t\
    if #c == 3 and c:match('(.)%1') then\n\t\t\treturn false\n\t\tend\n\t\ti = i +\
    \ 1\n\tend\n\treturn true\nend", "    -- write your code here\n    -- print(#s)\n\
    \    if #s < 3 then\n        return false\n    end\n    for i = 1, #s - 2 do\n\
    \        if s:sub(i, i + 2) == s:sub(i + 1, i + 3) then\n            return false\n\
    \        end\n    end\n    return true\nend", "   if #s < 3 then return false\
    \ end\n   local letters = {}\n   for i = 1, #s - 2 do\n      local l = s:sub(i,\
    \ i + 2)\n      if letters[l] then return false end\n      letters[l] = true\n\
    \   end\n   return true\nend", "    for i = 1, #s - 2 do\n        if s:sub(i,\
    \ i + 2) == s:sub(i + 1, i + 3) then\n            return false\n        end\n\
    \    end\n    return true\nend", "    local prev_char\n    local chars = {}\n\
    \    local s_len = #s\n    if s_len < 3 then\n        return false\n    end\n\
    \    for i = 1, #s do\n        local char = s:sub(i, i)\n        if prev_char\
    \ and chars[prev_char] and chars[prev_char] == char then\n            return false\n\
    \        end\n        prev_char = char\n        chars[char] = prev_char\n    end\n\
    \    return true\nend", "\tif not s or #s < 3 then return false end\n\tlocal i\
    \ = 0\n\tfor c in s:gmatch(\".\") do\n\t\ti = i + 1\n\t\tif c == s:sub(i, i +\
    \ 2) then return false end\n\tend\n\treturn true\nend", "  for i = 1, #s - 2 do\n\
    \    if s:sub(i, i + 2) == s:sub(i + 1, i + 3) then\n      return false\n    end\n\
    \  end\n  return #s >= 3\nend", "  local n = s:len()\n  if n < 3 then return false\
    \ end\n  local i = 1\n  while i <= n - 2 do\n    if s:sub(i, i) == s:sub(i + 1,\
    \ i + 1) or s:sub(i, i) == s:sub(i + 2, i + 2) or s:sub(i + 1, i + 1) == s:sub(i\
    \ + 2, i + 2) then\n      return false\n    end\n    i = i + 1\n  end\n  return\
    \ true\nend", "\tlocal t = {}\n\tfor i = 1, #s - 2 do\n\t\tlocal l, m, r = s:sub(i,\
    \ i), s:sub(i + 1, i + 1), s:sub(i + 2, i + 2)\n\t\tif l == m or l == r or m ==\
    \ r then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend", "\tlocal n\
    \ = #s\n\tif n < 3 then\n\t\treturn false\n\tend\n\tfor i = 1, n - 2 do\n\t\t\
    if s:sub(i, i + 2) == s:sub(i + 1, i + 3) then\n\t\t\treturn false\n\t\tend\n\t\
    end\n\treturn true\nend", "    local i = 1\n    while i + 2 <= #s do\n       \
    \ if s:sub(i, i) == s:sub(i + 1, i + 1) or s:sub(i, i) == s:sub(i + 2, i + 2)\
    \ or s:sub(i + 1, i + 1) == s:sub(i + 2, i + 2) then\n            return false\n\
    \        end\n        i = i + 1\n    end\n    return true\nend", "\tfor i = 1,\
    \ #s-2 do\n\t\tif s:sub(i, i+2) == s:sub(i+1, i+3) then\n\t\t\treturn false\n\t\
    \tend\n\tend\n\treturn #s >= 3\nend", "    local i = 0\n    local m = #s\n   \
    \ local c1, c2, c3\n    repeat\n        c1 = s:sub(i + 1, i + 1)\n        c2 =\
    \ s:sub(i + 2, i + 2)\n        c3 = s:sub(i + 3, i + 3)\n        i = i + 1\n \
    \   until i >= m - 2 or (c1 ~= c2 and c2 ~= c3 and c1 ~= c3)\n    return i < m\
    \ - 2\nend", "    -- checking the validity of the string\n    if string.len(s)\
    \ < 3 then\n        return false\n    end\n    -- checking if every 3 consecutive\
    \ letters are distinct\n    -- or not by comparing the substring of length 3 with\n\
    \    -- the substring of length 1\n    for i = 1, string.len(s) - 2 do\n     \
    \   if string.sub(s, i, i + 2) == string.sub(s, i + 1, i + 3) then\n         \
    \   return false\n        end\n    end\n    return true\nend", "   -- check if\
    \ the given string is at least 3 chars long\n   if string.len(s) < 3 then\n  \
    \    return false\n   end", "    return (#s >= 3 and s:match('([a-zA-Z])%1%1')\
    \ == nil)\nend", "    if #s < 3 then\n        return false\n    end\n    for i\
    \ = 1, #s - 2 do\n        if s:sub(i, i) == s:sub(i + 1, i + 1) or s:sub(i, i)\
    \ == s:sub(i + 2, i + 2) or s:sub(i + 1, i + 1) == s:sub(i + 2, i + 2) then\n\
    \            return false\n        end\n    end\n    return true\nend", "  if\
    \ #s<3 then return false end\n  for i=1,#s-2 do\n    if s:sub(i,i+2)==s:sub(i+1,i+3)\
    \ then return false end\n  end\n  return true\nend", "\tif #s < 3 then return\
    \ false end\n\tfor i = 1, #s - 2 do\n\t\tif s:sub(i, i + 2) == s:sub(i + 1, i\
    \ + 3) then return false end\n\tend\n\treturn true\nend", "    -- check if s is\
    \ a string with length at least 3,\n    -- and check if all the 3 consecutive\
    \ letters are different:\n    if type(s) ~= \"string\" or #s < 3 then\n      \
    \  return false\n    end\n    for i = 1, #s - 2 do\n        if s:sub(i, i) ==\
    \ s:sub(i + 1, i + 1) or\n           s:sub(i, i) == s:sub(i + 2, i + 2) or\n \
    \          s:sub(i + 1, i + 1) == s:sub(i + 2, i + 2) then\n            return\
    \ false\n        end\n    end\n    return true\nend\nassert(is_happy(\"Eyyy\"\
    ) == true)\nassert(is_happy(\"abba\") == false)\nassert(is_happy(\"c\") == false)\n\
    assert(is_happy(\"abca\") == true)\nassert(is_happy(\"Happy\") == true)\nassert(is_happy(\"\
    12321\") == false)\nassert(is_happy(\"aabcaa\") == false)\nassert(is_happy(\"\
    abcabcabcabcabc\") == true)\nassert(is_happy(\"abcabc\") == false)\nassert(is_happy(\"\
    aabaab\") == false)\nassert(is_happy(\"aaaa\") == false)\nassert(is_happy(\"aaabbb\"\
    ) == false)\nassert(is_happy(\"aaabbbccc\") == true)\nassert(is_happy(\"aaabbbcccaa\"\
    ) == false)\nassert(is_happy(\"aaabbbcccaaa\") == false)\nassert(is_happy(\"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc",
  "    if #s < 3 then\n        return false\n    end\n    for i = 1, #s - 2 do\n \
    \       if s:sub(i, i) == s:sub(i + 1, i + 1) or s:sub(i, i) == s:sub(i + 2, i\
    \ + 2) or s:sub(i + 1, i + 1) == s:sub(i + 2, i + 2) then\n            return\
    \ false\n        end\n    end\n    return true\nend", "    if type(s) ~= 'string'\
    \ then return false end\n    return #s >= 3 and not s:match '%1.%1.%1'\nend",
  "    -- check if the given string is happy\n    local prev = s:sub(1, 3)\n    for\
    \ i = 4, #s do\n        local curr = s:sub(i - 2, i)\n        if curr == prev\
    \ then\n            return false\n        end\n        prev = curr\n    end\n\
    \    return true\nend", "    for i = 3, #s do\n        if s:sub(i - 2, i) == s:sub(i\
    \ - 1, i + 1) then\n            return false\n        end\n    end\n    return\
    \ #s >= 3\nend", "    local len = string.len(s)\n    if len < 3 then\n       \
    \ return false\n    end\n    for i = 1, len - 2 do\n        if s:sub(i, i) ==\
    \ s:sub(i + 1, i + 1) and s:sub(i, i) == s:sub(i + 2, i + 2) then\n          \
    \  return false\n        end\n    end\n    return true\nend", "    return #s >=\
    \ 3 and (#s == 3 or not s:match('.-((.)%2%2).-'))\nend\nassert(not is_happy \"\
    abca\")\nassert(is_happy \"abcaa\")\nassert(is_happy \"abcab\")\nassert(not is_happy\
    \ \"aaaa\")\nassert(not is_happy \"aaaaa\")\nassert(is_happy \"aaaaaa\")\nassert(not\
    \ is_happy \"abcdefga\")\nassert(is_happy \"abcdefgabc\")", "  local i, l = 0,\
    \ #s\n  while i < l do\n    if l < 3 then return false end\n    if s:sub(i, i\
    \ + 2) == s:sub(i + 1, i + 3) then return false end\n    i = i + 1\n  end\n  return\
    \ true\nend", "    if #s < 3 then\n        return false\n    end\n    for i =\
    \ 1, #s - 2 do\n        if s:sub(i, i) == s:sub(i + 1, i + 1) or s:sub(i, i) ==\
    \ s:sub(i + 2, i + 2) then\n            return false\n        end\n    end\n \
    \   return true\nend\nassert(not is_happy(\"\"))\nassert(not is_happy(\"a\"))\n\
    assert(not is_happy(\"aa\"))\nassert(not is_happy(\"aaa\"))\nassert(not is_happy(\"\
    abac\"))\nassert(is_happy(\"aba\"))\nassert(is_happy(\"ababababa\"))\nassert(is_happy(\"\
    ababababaab\"))", "\tlocal n = #s\n\tif n < 3 then\n\t\treturn false\n\tend\n\t\
    for i = 1, n - 2 do\n\t\tif s:sub(i, i + 2) == s:sub(i + 1, i + 3) then\n\t\t\t\
    return false\n\t\tend\n\tend\n\treturn true\nend\nassert(not is_happy\"aaabbb\"\
    )\nassert(not is_happy\"aaabbbc\")\nassert(is_happy\"abcabcabc\")\nassert(not\
    \ is_happy\"abcabcabcdef\")\nassert(not is_happy\"abcabcabcdef\")\nassert(not\
    \ is_happy\"abcabcabcdefg\")\nassert(not is_happy\"aaaaaaaaaaa\")\nassert(is_happy\"\
    abcabc\")\nassert(is_happy\"abc\")\nassert(not is_happy\"abcd\")\nassert(not is_happy\"\
    ab\")\nassert(not is_happy\"\")", "  if #s < 3 then return false end\n  for i\
    \ = 3, #s do\n    if s:sub(i - 2, i) == s:sub(i - 1, i + 1) then return false\
    \ end\n  end\n  return true\nend", "  local n = s:len()\n  if n < 3 then return\
    \ false end\n  for i = 1, n - 2 do\n    if s:sub(i, i + 2):match('(.)%1%1') then\
    \ return false end\n  end\n  return true\nend", "  if #s < 3 then return false\
    \ end\n  local a, b, c = string.byte(s, 1, 3)\n  local h = {a, b, c}\n  local\
    \ t = {}\n  local ok = true\n  for i = 4, #s do\n    local d = string.byte(s,\
    \ i)\n    ok = ok and (t[d] or 0) == 0\n    t[d] = t[d] and t[d] + 1 or 1\n  \
    \  local x = h[1]\n    h[1] = h[2]\n    h[2] = h[3]\n    h[3] = d\n    if ok and\
    \ t[x] == 1 and t[h[2]] == 1 and t[h[3]] == 1 then\n      return false\n    end\n\
    \  end\n  return true\nend", "  return s:len() >= 3 and not s:find('(..).*%1')\n\
    end", "\t-- your code here\nend", "  if #s < 3 then return false end\n  for i\
    \ = 1, #s - 2 do\n    if s:sub(i, i + 2) == s:sub(i + 1, i + 3) then return false\
    \ end\n  end\n  return true\nend", "    for i = 1, #s - 2 do\n        local c\
    \ = s:sub(i, i + 2)\n        if c:find(s:sub(i, i), 2) then\n            return\
    \ false\n        end\n    end\n    return true\nend", "  for i = 1, #s-2 do\n\
    \    if s:sub(i, i+2) == s:sub(i+1, i+3) then\n      return false\n    end\n \
    \ end\n  return #s >= 3\nend", "  for i = 1, #s - 2 do\n    if s:sub(i, i) ==\
    \ s:sub(i + 1, i + 1) and s:sub(i, i) == s:sub(i + 2, i + 2) then\n      return\
    \ false\n    end\n  end\n  return true\nend\nassert(is_happy(\"aabbcc\"))\nassert(not\
    \ is_happy(\"aabbbcc\"))\nassert(not is_happy(\"aabbccc\"))\nassert(not is_happy(\"\
    aabcc\"))\nassert(not is_happy(\"abcc\"))", "    if #s < 3 then\n        return\
    \ false\n    end\n    for i = 1, #s - 2 do\n        if s:sub(i, i) == s:sub(i\
    \ + 1, i + 1) and s:sub(i, i) == s:sub(i + 2, i + 2) then\n            return\
    \ false\n        end\n    end\n    return true\nend", "  if #s < 3 then return\
    \ false end\n  for i = 1, #s - 2 do\n    if s:sub(i, i + 2) == s:sub(i + 1, i\
    \ + 3) then return false end\n  end\n  return true\nend", "  local n = #s\n  for\
    \ i = 1, n - 2 do\n    local a, b, c = s:sub(i, i), s:sub(i + 1, i + 1), s:sub(i\
    \ + 2, i + 2)\n    if a == b or b == c or a == c then\n      return false\n  \
    \  end\n  end\n  return n >= 3\nend", "    local result = false\n    if string.len(s)\
    \ > 2 then\n        local function check_happy(s, i)\n            local str =\
    \ string.sub(s, i, i + 2)\n            return str:match('(%w)%1%1') == nil\n \
    \       end\n        result = true\n        for i = 1, string.len(s) - 2 do\n\
    \            if not check_happy(s, i) then\n                result = false\n \
    \               break\n            end\n        end\n    end\n    return result\n\
    end", "  if type(s) == 'string' and s:len() >= 3 then\n    for i = 1, s:len()\
    \ - 2 do\n      if s:sub(i, i + 2):find(s:sub(i, i), 1, true) then\n        return\
    \ false\n      end\n    end\n    return true\n  end\n  return false\nend", " \
    \   return #s >= 3 and not string.find(s, '(.)%1%1')\nend", "    return\n    \
    \    #s >= 3 and s:match(\"(%a)(%a)(%a)\") ~= nil and -- at least 3 consecutive\
    \ letters\n        s:match(\"(%a)(%a)%1\") == nil and -- not 3 consecutive equal\
    \ letters\n        s:match(\"(%a)(%a)%2\") == nil -- not 3 consecutive equal letters\n\
    end", "    -- this function will have a chain of functions:\n    -- chain([f,\
    \ g, h]) == chain([f, chain([g, h])])\n    -- chain([f, g, h]) == chain([f, g,\
    \ h])\n    local function chain(fs)\n        return function(x)\n            for\
    \ _, f in ipairs(fs) do\n                x = f(x)\n            end\n         \
    \   return x\n        end\n    end", "  -- your code here\nend", "  return type(s)\
    \ == 'string' and s:len() >= 3 and s:match('^(%w)(%w)(%w)') ~= nil and s:match('^(%w)(%w)(%w)')\
    \ ~= s:match('^(%w)(%w)(%w)')\nend", "    if #s < 3 then\n        return false\n\
    \    end\n    local ia, ib, ic = s:byte(1,3)\n    for i = 4, #s do\n        ia,\
    \ ib, ic = ib, ic, s:byte(i)\n        if ia == ib or ib == ic or ia == ic then\n\
    \            return false\n        end\n    end\n    return true\nend", "    --\
    \ the length of s\n    local len = #s\n    if len < 3 then\n        return false\n\
    \    end\n    for i = 1, len - 2 do\n        if s:sub(i, i) == s:sub(i + 1, i\
    \ + 1) or s:sub(i, i) == s:sub(i + 2, i + 2) or s:sub(i + 1, i + 1) == s:sub(i\
    \ + 2, i + 2) then\n            return false\n        end\n    end\n    return\
    \ true\nend", "    local i = 1\n    while i < #s - 1 do\n        if s:sub(i, i\
    \ + 2):find(\"(.)%1%1\") then\n            return false\n        end\n       \
    \ i = i + 1\n    end\n    return true\nend", "\tlocal prev2, prev, curr = \"\"\
    , \"\", \"\"\n\tfor i=1,s:len() do\n\t\tprev2 = prev\n\t\tprev = curr\n\t\tcurr\
    \ = s:sub(i,i)\n\t\tif prev2 == curr then\n\t\t\treturn false\n\t\tend\n\tend\n\
    \treturn true\nend", "  if #s < 3 then return false end\n  for i = 1, #s - 2 do\n\
    \    if s:sub(i, i) == s:sub(i + 1, i + 1) or s:sub(i, i) == s:sub(i + 2, i +\
    \ 2) or s:sub(i + 1, i + 1) == s:sub(i + 2, i + 2) then\n      return false\n\
    \    end\n  end\n  return true\nend", "    if string.len(s) < 3 then\n       \
    \ return false\n    end\n    local i = 1\n    while i <= string.len(s) - 2 do\n\
    \        if string.sub(s, i, i + 2) == string.sub(s, i + 1, i + 3) then\n    \
    \        return false\n        end\n        i = i + 1\n    end\n    return true\n\
    end", "  local ans = false\n  if type(s) == \"string\" and #s >= 3 then\n    local\
    \ i = 1\n    while i < #s do\n      if s:sub(i, i+2) == s:sub(i+1, i+3) then\n\
    \        ans = false\n        break\n      else\n        ans = true\n      end\n\
    \      i = i + 1\n    end\n  end\n  return ans\nend", "    if #s < 3 then\n  \
    \      return false\n    end\n    for i = 1, #s - 2 do\n        if s:sub(i, i\
    \ + 2):match(\"%1\") then\n            return false\n        end\n    end\n  \
    \  return true\nend", "    return s:gsub('(.)%1%1','') == '' and #s >= 3\nend",
  "    -- TODO\nend", "  local n = #s\n  if n < 3 then return false end\n  for i =\
    \ 1, n - 2 do\n    if s:sub(i, i + 2) == s:sub(i + 1, i + 3) then return false\
    \ end\n  end\n  return true\nend", "  -- check the string is happy or not\n  return\
    \ nil\nend", "    local a, b, c = s:sub(1, 1), s:sub(2, 2), s:sub(3, 3)\n    return\
    \ s:len() >= 3 and a ~= b and b ~= c and a ~= c\nend", "    for i = 3, #s do\n\
    \        if s:sub(i-2, i) == s:sub(i-1, i+1) then\n            return false\n\
    \        end\n    end\n    return #s >= 3\nend\nassert(is_happy('happy') == true)\n\
    assert(is_happy('unhappy') == false)\nassert(is_happy('ahpy') == false)\nassert(is_happy('hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh')\
    \ == false)", "  local prev = s:sub(1, 2)\n  for i = 4, #s do\n    local next\
    \ = s:sub(i - 2, i)\n    if prev == next then\n      return false\n    end\n \
    \   prev = next\n  end\n  return true\nend", "    for i = 1, #s - 2 do\n     \
    \   if s:sub(i, i) == s:sub(i + 1, i + 1) and s:sub(i, i) == s:sub(i + 2, i +\
    \ 2) then\n            return false\n        end\n    end\n    return true\nend",
  "    -- s = s:lower()\n    local l = string.len(s)\n    if l < 3 then\n        return\
    \ false\n    end\n    for i = 1, l - 2 do\n        if s:sub(i, i + 2) == s:sub(i\
    \ + 1, i + 3) then\n            return false\n        end\n    end\n    return\
    \ true\nend", "  local left = 1\n  local right = 3\n  while right <= #s do\n \
    \   if s:sub(left, left) == s:sub(right, right) or\n      s:sub(left + 1, left\
    \ + 1) == s:sub(right, right) or\n      s:sub(left + 2, left + 2) == s:sub(right,\
    \ right) then\n      return false\n    end\n    left = left + 1\n    right = right\
    \ + 1\n  end\n  return true\nend", "\tfor i = 1, #s - 2 do\n\t\tif s:sub(i, i\
    \ + 2) == s:sub(i + 1, i + 3) then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn\
    \ #s >= 3\nend", "    if type(s) ~= 'string' then\n        return false\n    end\n\
    \    local length = #s\n    if length < 3 then\n        return false\n    end\n\
    \    for i = 1, length - 2 do\n        if s:sub(i, i + 2) == 'aaa' or s:sub(i,\
    \ i + 2) == 'bbb' or s:sub(i, i + 2) == 'ccc' then\n            return false\n\
    \        end\n    end\n    return true\nend", "    if #s < 3 then\n        return\
    \ false\n    end\n    for i = 3, #s do\n        if s:sub(i - 2, i) == s:sub(i\
    \ - 1, i + 1) then\n            return false\n        end\n    end\n    return\
    \ true\nend", "    for i = 1, #s-2 do\n        if s:sub(i, i+2) == s:sub(i+1,\
    \ i+3) then\n            return false\n        end\n    end\n    return true\n\
    end", "\tlocal last = ''\n\tfor i = #s, 3, -1 do\n\t\tlocal b = s:sub(i - 2, i)\n\
    \t\tif b == last then\n\t\t\treturn false\n\t\tend\n\t\tlast = b\n\tend\n\treturn\
    \ true\nend", "    local prev = s:sub(1, 3)\n    for i = 4, #s - 2 do\n      \
    \  local sub = s:sub(i, i + 2)\n        if sub == prev then\n            return\
    \ \"No\"\n        end\n        prev = sub\n    end\n    return \"Yes\"\nend",
  "\tif #s < 3 then return false end\n\tfor i = 1, #s - 2 do\n\t\tif s:sub(i, i +\
    \ 2) == s:sub(i + 1, i + 3) then return false end\n\tend\n\treturn true\nend",
  "    local l = string.len(s)\n    if l < 3 then\n        return false\n    end\n\
    \    local c = string.sub(s, 1, 3)\n    if string.match(c, \"(.)%1\") then\n \
    \       return false\n    end\n    for i = 4, l - 2 do\n        local t = string.sub(s,\
    \ i, i + 2)\n        if t == c then\n            return false\n        end\n \
    \   end\n    return true\nend", "  return string.len(s) >= 3 and string.match(s,\
    \ \"^(.)%1%1\") == nil and string.match(s, \"(.)%1%1$\") == nil\nend", "    --\
    \ if length of string is less than 3, then this string is not happy\n    if #s\
    \ < 3 then\n        return false\n    end\n    for i = 1, #s - 2 do\n        --\
    \ check if 3 consecutive letters are different from each other\n        if s:sub(i,\
    \ i) == s:sub(i + 1, i + 1) or s:sub(i, i) == s:sub(i + 2, i + 2) or s:sub(i +\
    \ 1, i + 1) == s:sub(i + 2, i + 2) then\n            return false\n        end\n\
    \    end\n    return true\nend", "    local i = 1\n    local n = #s\n    while\
    \ i <= n do\n        if (n - i + 1) < 3 then\n            return false\n     \
    \   end\n        local q = s:sub(i, i+2)\n        if q:match(\"(.).%1\") then\n\
    \            return false\n        end\n        i = i + 3\n    end\n    return\
    \ true\nend", "  if string.len(s) < 3 then return false end\n  for i = 1, string.len(s)\
    \ - 2 do\n    if string.sub(s, i, i) == string.sub(s, i + 1, i + 1) then\n   \
    \   if string.sub(s, i, i) == string.sub(s, i + 2, i + 2) then\n        return\
    \ false\n      end\n    end\n  end\n  return true\nend", "  if #s < 3 then return\
    \ false end\n  --[[\n  if s:match '^(%w)%1%1' then return false end\n  for i =\
    \ 2, #s-1 do\n    if s:sub(i, i+2):match '^(%w)%1%1' then return false end\n \
    \ end\n  --]]\n  for i = 1, #s-2 do\n    if s:sub(i, i+2):match '^(%w)%1%1' then\
    \ return false end\n  end\n  return true\nend", "  -- return true\n  if string.len(s)\
    \ < 3 then\n    return false\n  end\n  -- return true\n  if string.len(s) == 3\
    \ then\n    return true\n  end\n  -- TODO: determine if the string is happy.\n\
    \  -- return true\n  for i = 3, string.len(s) do\n    local x, y, z = string.sub(s,\
    \ i - 2, i - 2), string.sub(s, i - 1, i - 1), string.sub(s, i, i)\n    if x ==\
    \ y or y == z or x == z then\n      return false\n    end\n  end\n  return true\n\
    end", "    if s:len() < 3 then\n        return false\n    end\n    local x, y,\
    \ z = s:byte(1,3)\n    for i = 4, s:len() do\n        x, y, z = y, z, s:byte(i)\n\
    \        if x == y or y == z or z == x then\n            return false\n      \
    \  end\n    end\n    return true\nend", "\t-- if a string is not three characters\
    \ it can't be happy\n\tif #s < 3 then\n\t\treturn false\n\tend\n\tlocal seen =\
    \ {}\n\tfor i = 1, #s do\n\t\t-- if this is the last letter, there's nothing to\
    \ check\n\t\tif i == #s then\n\t\t\tbreak\n\t\tend\n\t\tlocal this, next = s:sub(i,\
    \ i), s:sub(i + 1, i + 1)\n\t\t-- if this is the first letter of a three letter\
    \ sequence we need to check if the next two are distinct\n\t\tif i % 3 == 1 then\n\
    \t\t\tlocal match = next .. s:sub(i + 2, i + 2)\n\t\t\tif seen[match] then\n\t\
    \t\t\treturn false\n\t\t\tend\n\t\t\tseen[match] = true\n\t\tend\n\t\t-- otherwise\
    \ we check if this letter is the same as the next one\n\t\tif this == next then\n\
    \t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend", "  for i = 1, #s - 2\
    \ do\n    local x = s:sub(i, i)\n    local y = s:sub(i + 1, i + 1)\n    local\
    \ z = s:sub(i + 2, i + 2)\n    if x == y or y == z or z == x then\n      return\
    \ false\n    end\n  end\n  return true\nend", "  for i = 1, s:len() - 2 do\n \
    \   if s:sub(i, i) == s:sub(i + 1, i + 1) or s:sub(i, i) == s:sub(i + 2, i + 2)\
    \ or s:sub(i + 1, i + 1) == s:sub(i + 2, i + 2) then\n      return false\n   \
    \ end\n  end\n  return true\nend", "    -- your code here\nend", "  local t =\
    \ {}\n  for i = 1, #s - 2 do\n    if not t[s:sub(i, i + 2)] then\n      t[s:sub(i,\
    \ i + 2)] = true\n    else\n      return false\n    end\n  end\n  return true\n\
    end", "    -- Write your code here\n    -- To print results to the standard output\
    \ you can use print\n    -- Example: print(\"Hello world!\")\n    -- your code\
    \ here\nend", "    local n = #s\n    if n < 3 then\n        return false\n   \
    \ end\n    local one = s:sub(1,1)\n    local two = s:sub(2,2)\n    local three\
    \ = s:sub(3,3)\n    if one == two or one == three or two == three then\n     \
    \   return false\n    end\n    local happy = true\n    for i = 3, n-2 do\n   \
    \     one = two\n        two = three\n        three = s:sub(i+1,i+1)\n       \
    \ if one == two or one == three or two == three then\n            happy = false\n\
    \            break\n        end\n    end\n    return happy\nend", "  --\nend",
  "    if string.len(s) < 3 then\n        return false\n    end\n    local s = s:lower()\n\
    \    for i = 1, string.len(s) - 2 do\n        if s:sub(i, i) == s:sub(i + 1, i\
    \ + 1) or s:sub(i, i) == s:sub(i + 2, i + 2) or s:sub(i + 1, i + 1) == s:sub(i\
    \ + 2, i + 2) then\n            return false\n        end\n    end\n    return\
    \ true\nend", "    if string.len(s) < 3 then\n        return false\n    end\n\
    \    for i = 1, string.len(s) - 2 do\n        if string.sub(s, i, i + 2) == string.sub(s,\
    \ i + 1, i + 3) then\n            return false\n        end\n    end\n    return\
    \ true\nend", "  -- Implementation goes here.\nend", "    for i = 1, #s - 2 do\n\
    \        if string.sub(s, i, i + 2) == string.sub(s, i + 1, i + 3) then\n    \
    \        return false\n        end\n    end\n    return #s >= 3\nend", "    local\
    \ str_len = s:len()\n    if str_len < 3 then\n        return false\n    end\n\
    \    -- \u0421\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u0435\u043C \u043F\u043E\
    \u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u043D\u043E\
    \u0441\u0442\u0438 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u0438 \u043F\
    \u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u043D\u0430 \u0440\u0430\u0432\
    \u0435\u043D\u0441\u0442\u0432\u043E.\n    for i = 1, str_len - 2 do\n       \
    \ if s:sub(i, i + 2) == s:sub(i + 1, i + 3) then\n            return false\n \
    \       end\n    end\n    return true\nend", "    for i = 1, #s - 2 do\n     \
    \   if s:sub(i, i + 2) == s:sub(i + 1, i + 3) then\n            return false\n\
    \        end\n    end\n    return true\nend", "  local n = s:len()\n  if n < 3\
    \ then return false end\n  for i = 1, n - 2 do\n    if s:sub(i, i) == s:sub(i\
    \ + 1, i + 1) and s:sub(i, i) == s:sub(i + 2, i + 2) then\n      return false\n\
    \    end\n  end\n  return true\nend", "    if s:len() < 3 then\n        return\
    \ false\n    end\n    local set = {}\n    for i = 1, s:len() do\n        local\
    \ next_set = {}\n        for j = 1, 3 do\n            if s:len() >= i + j - 1\
    \ then\n                next_set[s:sub(i + j - 1, i + j - 1)] = true\n       \
    \     end\n        end\n        if set[next_set] then\n            return false\n\
    \        end\n        set[next_set] = true\n    end\n    return true\nend", " \
    \   return #s >= 3 and (s:gsub(\"(.)%1%1\",\"\") == s)\nend", "  -- write your\
    \ code here\nend", "    local d = {}\n    local i = 1\n    while i <= #s do\n\
    \        if d[string.sub(s, i, i+2)] then\n            return false\n        end\n\
    \        d[string.sub(s, i, i+2)] = true\n        i = i + 1\n    end\n    return\
    \ true\nend", "\treturn (string.len(s) >= 3) and (string.sub(s, 3, 3) ~= string.sub(s,\
    \ 2, 2)) and (string.sub(s, 3, 3) ~= string.sub(s, 1, 1))\nend", "  return #s\
    \ > 2 and not string.find(s, '...(.)%1')\nend", "    -- s=\"abcdabcdabcdabcdabcd\"\
    \n    -- print(string.len(s))\n    -- print(string.byte(s))\n    if string.len(s)\
    \ < 3 then\n        return false\n    end\n    -- print(string.byte(s,1,1))\n\
    \    -- print(string.byte(s,2,2))\n    -- print(string.byte(s,3,3))\n    -- print(string.byte(s,4,4))\n\
    \    for i = 1, string.len(s) - 2 do\n        -- if(string.byte(s,i,i)==string.byte(s,i+1,i+1)\
    \ and string.byte(s,i,i)==string.byte(s,i+2,i+2)) then\n        if string.byte(s,\
    \ i, i) == string.byte(s, i + 1, i + 1) and string.byte(s, i, i) == string.byte(s,\
    \ i + 2, i + 2) then\n            return false\n        end\n    end\n    return\
    \ true\nend", "\tlocal rep = {}\n\tfor i = 1, #s - 2 do\n\t\tlocal sub = s:sub(i,\
    \ i + 2)\n\t\tif rep[sub] then\n\t\t\treturn false\n\t\tend\n\t\trep[sub] = true\n\
    \tend\n\treturn true\nend", "\tlocal prev_char, prev_prev_char = s:sub(1, 1),\
    \ s:sub(2, 2)\n\tfor i = 3, #s do\n\t\tlocal char = s:sub(i, i)\n\t\tif char ==\
    \ prev_char or char == prev_prev_char then\n\t\t\treturn false\n\t\tend\n\t\t\
    prev_prev_char = prev_char\n\t\tprev_char = char\n\tend\n\treturn true\nend\n\
    assert(is_happy(\"robert\") == true)\nassert(is_happy(\"robb\") == false)\nassert(is_happy(\"\
    robertt\") == false)\nassert(is_happy(\"aabbc\") == true)\nassert(is_happy(\"\
    aabbca\") == false)\nassert(is_happy(\"aabbcc\") == false)", "  if #s < 3 then\
    \ return false end\n  local tbl = {}\n  for i = 1, #s do\n    local n = s:sub(i,\
    \ i+2)\n    if #n == 3 then\n      if tbl[n] then return false end\n      tbl[n]\
    \ = true\n    end\n  end\n  return true\nend\nprint(is_happy(\"fghj\")) -- true\n\
    print(is_happy(\"fghja\")) -- false", "\tfor i = 1, #s - 2 do\n\t\tif s:sub(i,\
    \ i + 2) == s:sub(i + 1, i + 3) then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn\
    \ #s >= 3\nend", "    return true\nend", "    -- check that length >= 3\n    if\
    \ string.len(s) < 3 then\n        return false\n    end\n    -- check every substring\
    \ of length 3\n    for i = 1, string.len(s) - 2 do\n        local sub = string.sub(s,\
    \ i, i + 2)\n        -- if any two of the three chars are equal, it's not happy\n\
    \        if sub:match(\"([^%c])(.*)%1\") then\n            return false\n    \
    \    end\n    end\n    return true\nend", "\tlocal l, f = string.len(s), 0\n\t\
    if l < 3 then return false end\n\tfor i = 0, l - 3 do\n\t\tf = string.find(s,\
    \ string.sub(s, i + 1, i + 3), i + 2)\n\t\tif f then return false end\n\tend\n\
    \treturn true\nend\nprint(is_happy(\"aabb\"), is_happy(\"abcc\"))", "  \n  local\
    \ happy = false\n  local count = 0\n  local str = {}\n  local s = string.lower(s)\n\
    \  \n  for i=1, #s do\n    if s[i] == ' ' then\n      count = count + 1\n    else\n\
    \      str[i-count] = s[i]\n    end\n  end\n  \n  if #str >= 3 then\n    for i=1,\
    \ #str-2 do\n      if str[i] ~= str[i+1] and str[i] ~= str[i+2] and str[i+1] ~=\
    \ str[i+2] then\n        happy = true\n      else\n        happy = false\n   \
    \     break\n      end\n    end\n  end\n  \n  return happy\nend", "  return #s\
    \ >= 3 and s:find(\"(...)%1\") == nil\nend", end, "    --\n    local len = #s\n\
    \    if len < 3 then\n        return false\n    end\n    for i = 1, len - 2 do\n\
    \        if s:sub(i, i + 2) == s:sub(i + 1, i + 3) then\n            return false\n\
    \        end\n    end\n    return true\nend", "  if #s < 3 then return false end\n\
    \  for i = 1, #s - 2 do\n    if s:sub(i, i + 2) == s:sub(i + 1, i + 3) then return\
    \ false end\n  end\n  return true\nend\nprint(is_happy(\"abcabcabc\")) --> false\n\
    print(is_happy(\"abcabcabca\")) --> true", "\t-- body\nend", "\tlocal letters\
    \ = {}\n\tfor i = 1, #s do\n\t\tletters[i] = s:sub(i, i)\n\tend\n\tlocal check\
    \ = 0\n\tfor i = 3, #letters do\n\t\tif letters[i] == letters[i - 1] and letters[i]\
    \ == letters[i - 2] then\n\t\t\tcheck = 1\n\t\tend\n\tend\n\tif check == 1 then\n\
    \t\treturn false\n\telse\n\t\treturn true\n\tend\nend\nreturn is_happy", "   \
    \ if #s < 3 then\n        return false\n    end\n    local n = #s\n    local i\
    \ = 1\n    while i < n do\n        if s:sub(i, i+2) == s:sub(i+1, i+3) then\n\
    \            return false\n        end\n        i = i + 1\n    end\n    return\
    \ true\nend", "    local seen = {}\n    for c in s:gmatch('%a') do\n        if\
    \ #seen == 3 then\n            table.remove(seen, 1)\n        end\n        table.insert(seen,\
    \ c)\n        if #seen == 3 and seen[1] == seen[2] and seen[2] == seen[3] then\n\
    \            return false\n        end\n    end\n    return true\nend", "  if\
    \ #s < 3 then return false end\n  for i = 1, #s - 2 do\n    if s:sub(i, i + 2)\
    \ == s:sub(i + 1, i + 3) then return false end\n  end\n  return true\nend", " \
    \   if #s < 3 then\n        return false\n    end\n    for i = 1, #s - 2 do\n\
    \        if s:sub(i, i + 2):match(\"(.)%1%1\") then\n            return false\n\
    \        end\n    end\n    return true\nend", "\tif #s < 3 then return false end\n\
    \tfor i = 1, #s - 2 do\n\t\tif s:sub(i, i + 2) == s:sub(i + 1, i + 3) then return\
    \ false end\n\tend\n\treturn true\nend", "    local dict = {}\n    local prev_char\n\
    \    local count = 0\n    for i = 1, string.len(s) do\n        if i > 3 then\n\
    \            dict[prev_char] = dict[prev_char] - 1\n            if dict[prev_char]\
    \ == 0 then\n                dict[prev_char] = nil\n            end\n        end\n\
    \        local c = string.sub(s, i, i)\n        if dict[c] == nil then\n     \
    \       dict[c] = 1\n        else\n            dict[c] = dict[c] + 1\n       \
    \ end\n        if dict[c] > 1 then\n            return false\n        end\n  \
    \      prev_char = c\n    end\n    return true\nend", "  -- return true if |s|\
    \ >= 3 and every 3 consecutive letters are distinct\n  local count = 0\n  local\
    \ s_len = #s\n  for i = 1, s_len do\n    if s_len - i > 3 and s:sub(i, i + 2)\
    \ == s:sub(i + 1, i + 3) then\n      return false\n    end\n  end\n  return true\n\
    end", "\tfor i = 1, #s - 2 do\n\t\tif s:sub(i, i + 2) == s:sub(i + 1, i + 3) then\n\
    \t\t\treturn false\n\t\tend\n\tend\n\treturn #s >= 3\nend", "    local len = string.len(s)\n\
    \    if len < 3 then\n        return false\n    end\n    for i = 1, len - 2 do\n\
    \        if s:sub(i, i) == s:sub(i + 1, i + 1) or s:sub(i, i) == s:sub(i + 2,\
    \ i + 2) or s:sub(i + 1, i + 1) == s:sub(i + 2, i + 2) then\n            return\
    \ false\n        end\n    end\n    return true\nend", "    return #s >= 3 and\
    \ #s % 3 == 0 and not string.match(s, \"([^\"..s:sub(1,1)..\"])\"..string.rep(\"\
    %1\", #s/3-1))\nend", "  -- Write the body of this function\n  return false\n\
    end", "  if string.len(s) < 3 then return false end\n  for i = 1, string.len(s)-2\
    \ do\n    if string.sub(s, i, i+2) == string.sub(s, i+1, i+3) then return false\
    \ end\n  end\n  return true\nend", "    -- write your code here\nend", "    if\
    \ #s < 3 then\n        return false\n    end\n    for i = 1, #s - 2 do\n     \
    \   if s:sub(i, i + 2):match(\"^(.)%1%1$\") then\n            return false\n \
    \       end\n    end\n    return true\nend", "  for i = 1, #s-2 do\n    local\
    \ a, b, c = s:sub(i, i), s:sub(i+1, i+1), s:sub(i+2, i+2)\n    if a == b or b\
    \ == c or a == c then\n      return false\n    end\n  end\n  return true\nend",
  end, "   local count = 1\n   if #s < 3 then return false end\n   while #s > 2 do\n\
    \      if s:sub(1, 3) == s:sub(2, 4) then return false end\n      s = s:sub(2)\n\
    \      count = count + 1\n   end\n   return true\nend", "    if not s or s:len()\
    \ < 3 then\n        return false\n    end\n    for i = 1, s:len() - 2 do\n   \
    \     if s:sub(i, i) == s:sub(i + 1, i + 1) or s:sub(i, i) == s:sub(i + 2, i +\
    \ 2) or s:sub(i + 1, i + 1) == s:sub(i + 2, i + 2) then\n            return false\n\
    \        end\n    end\n    return true\nend", "  local chars = s:gmatch(\".\"\
    )\n  local last1, last2, last3\n  for c in chars do\n    if c == last1 or c ==\
    \ last2 or c == last3 then\n      return false\n    end\n    last1, last2, last3\
    \ = last2, last3, c\n  end\n  return true\nend", "  -- check if string is of length\
    \ at least 3\n  if s:len() < 3 then\n    return false\n  end\n  -- loop through\
    \ the string\n  for i = 1,s:len()-2 do\n    -- check if three consecutive letters\
    \ are distinct\n    if s:sub(i,i) == s:sub(i+1,i+1) or s:sub(i,i) == s:sub(i+2,i+2)\
    \ or s:sub(i+1,i+1) == s:sub(i+2,i+2) then\n      return false\n    end\n  end\n\
    \  return true\nend", "  if #s < 3 then return false end\n  local i = 0\n  while\
    \ i < #s do\n    if s:sub(i+1, i+3) == s:sub(i+3, i+5) then return false end\n\
    \    i = i + 1\n  end\n  return true\nend", "\tlocal t = {}\n\tfor i = 1, string.len(s)\
    \ - 2 do\n\t\tlocal a, b, c = string.sub(s, i, i), string.sub(s, i + 1, i + 1),\
    \ string.sub(s, i + 2, i + 2)\n\t\tif t[a] or t[b] or t[c] then\n\t\t\treturn\
    \ false\n\t\tend\n\t\tt[a] = true\n\t\tt[b] = true\n\t\tt[c] = true\n\tend\n\t\
    return true\nend", "    return true\nend", "  if s:len()<3 then return false end\n\
    \  for i=1,s:len()-2 do\n    if s:sub(i,i)==s:sub(i+1,i+1) and s:sub(i,i)==s:sub(i+2,i+2)\
    \ then return false end\n  end\n  return true\nend", "  return s:len() >= 3 and\
    \ s:gsub('(.)%1%1', ''):len() == s:len()\nend", "    -- some code here\nend",
  "    -- your code here\nend", "  if #s < 3 then return false end\n  for i = 3, #s\
    \ do\n    if s:sub(i - 2, i) == s:sub(i - 1, i + 1) then return false end\n  end\n\
    \  return true\nend\nassert(not is_happy('hihi'))\nassert(is_happy('aha'))", " \
    \   return string.len(s) >= 3 and not string.find(s, \"(.)%1%1\")\nend", "   \
    \ return s:len() > 2 and s:match'(.).%1.%1' == nil\nend", "    local happy = false\n\
    \    local i = 0\n    local j = 0\n    local k = 0\n    for i = 0, s:len() - 3\
    \ do\n        j = i + 1\n        k = j + 1\n        if s:sub(i, i) ~= s:sub(j,\
    \ j) and s:sub(i, i) ~= s:sub(k, k) and s:sub(j, j) ~= s:sub(k, k) then\n    \
    \        happy = true\n        else\n            happy = false\n            break\n\
    \        end\n    end\n    return happy\nend", "    -- if length of s is less\
    \ than 3\n    if #s < 3 then\n        return false\n    end\n    -- check every\
    \ 3 consecutive letters\n    for i = 1, #s-2 do\n        if s:sub(i, i+2) == s:sub(i+1,\
    \ i+3) then\n            return false\n        end\n    end\n    return true\n\
    end", "    if not s or s:len() < 3 then\n        return false\n    end\n    local\
    \ last = s:sub(1,3)\n    for i = 4, #s do\n        local cur = s:sub(i,i+2)\n\
    \        if cur == last then\n            return false\n        end\n        last\
    \ = cur\n    end\n    return true\nend", "\tif #s < 3 then return false end\n\t\
    for i = 1, #s - 2 do\n\t\tif s:sub(i, i + 2) == s:sub(i + 1, i + 3) then return\
    \ false end\n\tend\n\treturn true\nend", "  local last, last2, last3\n  local\
    \ function next()\n    last, last2, last3 = s:sub(1,1), s:sub(2,2), s:sub(3,3)\n\
    \    s = s:sub(2)\n  end\n  next()\n  while #s >= 2 do\n    if last == last2 or\
    \ last == last3 or last2 == last3 then\n      return false\n    end\n    next()\n\
    \  end\n  return true\nend", "    --local happy = true\n    if s:len() < 3 then\n\
    \        return false\n    end\n    for i = 1, s:len() - 2 do\n        local slice\
    \ = s:sub(i, i + 2)\n        --print(slice)\n        if slice:sub(1, 1) == slice:sub(2,\
    \ 2) or slice:sub(1, 1) == slice:sub(3, 3) or slice:sub(2, 2) == slice:sub(3,\
    \ 3) then\n            return false\n        end\n    end\n    return true\nend",
  "  -- TODO: Check if a string is happy\n  return false\nend", "    if #s < 3 then\n\
    \        return false\n    end\n    local result = true\n    for i = 1, #s - 2\
    \ do\n        if s:sub(i, i + 2):match(\"(.)%1%1\") then\n            result =\
    \ false\n            break\n        end\n    end\n    return result\nend", " \
    \ -- return false\n  if #s < 3 then return false end\n  for i = 1, #s - 2 do\n\
    \    if s:sub(i, i + 2) == '111' or s:sub(i, i + 2) == '000' then\n      return\
    \ false\n    end\n  end\n  return true\nend", "\tlocal l = #s\n\tlocal p = s:gsub(\"\
    (.)%1%1\",\"\")\n\treturn #p >= l - 2\nend", "\t-- local good = true\n\tfor i\
    \ = 1, #s - 2 do\n\t\tif s:sub(i, i + 2) == s:sub(i + 1, i + 3) then\n\t\t\treturn\
    \ false\n\t\tend\n\tend\n\treturn true\nend", "\tlocal i, l = 1, #s\n\twhile i\
    \ <= l - 2 do\n\t\tif s:sub(i, i + 2):match('(.).%1%1') then\n\t\t\treturn false\n\
    \t\tend\n\t\ti = i + 1\n\tend\n\treturn true\nend", "\t-- code here\nend", " \
    \   -- length\n    if not s:len() >= 3 then\n        return false\n    end\n \
    \   -- consecutive\n    local temp = {}\n    local c = {}\n    local l = 1\n \
    \   for i = 1, s:len() do\n        temp[i] = s:sub(i, i)\n        if not c[temp[i]]\
    \ then\n            c[temp[i]] = true\n            l = l + 1\n        end\n  \
    \  end\n    if s:len() ~= l then\n        return false\n    end\n    -- every\
    \ 3 consecutive\n    for i = 1, s:len() do\n        if temp[i + 2] then\n    \
    \        if temp[i] == temp[i + 1] and temp[i + 1] == temp[i + 2] then\n     \
    \           return false\n            end\n        end\n    end\n    return true\n\
    end", "    local n = #s\n    if n < 3 then\n        return false\n    end\n  \
    \  for i = 1, n - 2 do\n        if s:sub(i, i + 2) == s:sub(i + 1, i + 3) then\n\
    \            return false\n        end\n    end\n    return true\nend", end, " \
    \ -- @todo\nend", "    local t = {}\n    for i = 1, #s do\n        local c = s:sub(i,\
    \ i)\n        if t[c] then\n            return false\n        end\n        t[c]\
    \ = true\n    end\n    return #s >= 3\nend\nassert(is_happy(\"abccab\"))\nassert(not\
    \ is_happy(\"abccdab\"))\nassert(not is_happy(\"abccaab\"))\nassert(not is_happy(\"\
    abccbab\"))\nassert(not is_happy(\"abccacab\"))\nassert(not is_happy(\"aaaaab\"\
    ))\nassert(not is_happy(\"aaaa\"))\nassert(not is_happy(\"aaa\"))\nassert(is_happy(\"\
    ababa\"))\nassert(is_happy(\"ab\"))\nassert(is_happy(\"abcabcabc\"))\nassert(not\
    \ is_happy(\"abcabcabca\"))\nassert(not is_happy(\"abcabcabcab\"))\nassert(not\
    \ is_happy(\"abcabcabcabc\"))\nassert(not is_happy(\"abccabccabccabcc\"))", end,
  "    -- Your code here\nend", "  -- return s:len() >= 3 and s:match(\"(%a)(%a)(%a)\"\
    ) == nil\n  return s:len() >= 3 and s:match(\"(%w)(%w)%1\") == nil\nend\nprint(is_happy(\"\
    happy\"), \"true\")\nprint(is_happy(\"unhappy\"), \"false\")\nprint(is_happy(\"\
    happyy\"), \"false\")\nprint(is_happy(\"yyyy\"), \"false\")\nprint(is_happy(\"\
    yy\"), \"false\")\nprint(is_happy(\"yh\"), \"false\")\nprint(is_happy(\"hh\"),\
    \ \"false\")\nprint(is_happy(\"yhh\"), \"false\")\nprint(is_happy(\"hhh\"), \"\
    false\")\nprint(is_happy(\"xhx\"), \"false\")\nprint(is_happy(\"ppy\"), \"true\"\
    )\nprint(is_happy(\"pyp\"), \"true\")\nprint(is_happy(\"ppyy\"), \"false\")\n\
    print(is_happy(\"ppyyy\"), \"false\")\nprint(is_happy(\"ppyyy\"), \"false\")\n\
    print(is_happy(\"ppyyy\"), \"false\")\nprint(is_happy(\"ppyyy\"), \"false\")\n\
    print(is_happy(\"ppyyy\"), \"false\")\nprint(is_happy(\"ppyyy\"), \"false\")\n\
    print(is_happy(\"ppyyy\"), \"false\")\nprint(is_happy(\"ppyyy\"), \"false\")\n\
    print(is_happy(\"ppyyy\"), \"false\")\nprint(is_happy(\"ppyyy\"), \"false\")\n\
    print(is_happy(\"ppyyy\"), \"false\")\nprint(is_happy(\"ppyyy\"), \"false\")\n\
    print(is_happy(\"ppyyy\"), \"false\")\nprint(is_happy(\"ppyyy\"), \"false\")\n\
    print(is_happy(\"ppyyy\"), \"false\")\nprint(is_happy(\"ppyyy\"), \"false\")\n\
    print(is_happy(\"ppyyy\"), \"false\")\nprint(is_happy(\"ppyyy\"), \"false\")\n\
    print(is_happy(\"ppyyy\"), \"false\")\nprint(is_happy(\"ppyyy\"), \"false\")\n\
    print(is_happy(\"ppyyy\"), \"false\")\nprint(is_happy(\"ppyyy\"), \"false\")\n\
    print(is_", "  local t={}\n  local flag=false\n  local c=0\n  for i=1,#s do\n\
    \    t[i]=s:sub(i,i)\n  end\n  for i=1,#t-2 do\n    if (t[i]~=t[i+1]) and (t[i]~=t[i+2])\
    \ and (t[i+1]~=t[i+2]) then\n      flag=true\n    else\n      flag=false\n   \
    \   c=c+1\n    end\n  end\n  if c==0 then\n    return true\n  else\n    return\
    \ false\n  end\nend\nprint(is_happy(\"aaa\"))\nprint(is_happy(\"aaabbb\"))\nprint(is_happy(\"\
    ababab\"))\nprint(is_happy(\"aabbb\"))", "    if #s < 3 then\n        return false\n\
    \    end\n    local last_chars = {}\n    for i = 1, #s do\n        if last_chars[1]\
    \ == s:sub(i, i) then\n            return false\n        end\n        for j =\
    \ 1, #last_chars do\n            last_chars[j] = last_chars[j + 1]\n        end\n\
    \        last_chars[#last_chars] = s:sub(i, i)\n    end\n    return true\nend",
  "    -- TODO\nend", "    if s:len() < 3 then\n        return false\n    end\n  \
    \  for i = 1, s:len() - 2 do\n        if s:sub(i, i) == s:sub(i + 1, i + 1) or\
    \ s:sub(i, i) == s:sub(i + 2, i + 2) or s:sub(i + 1, i + 1) == s:sub(i + 2, i\
    \ + 2) then\n            return false\n        end\n    end\n    return true\n\
    end", "  if #s < 3 then return false end\n  local i = 1\n  while i <= #s do\n\
    \    if s:sub(i, i+2) == 'aaa' or s:sub(i, i+2) == 'bbb' or s:sub(i, i+2) == 'ccc'\
    \ or s:sub(i, i+2) == 'ddd' or s:sub(i, i+2) == 'eee' or s:sub(i, i+2) == 'fff'\
    \ or s:sub(i, i+2) == 'ggg' or s:sub(i, i+2) == 'hhh' or s:sub(i, i+2) == 'iii'\
    \ or s:sub(i, i+2) == 'jjj' or s:sub(i, i+2) == 'kkk' or s:sub(i, i+2) == 'lll'\
    \ or s:sub(i, i+2) == 'mmm' or s:sub(i, i+2) == 'nnn' or s:sub(i, i+2) == 'ooo'\
    \ or s:sub(i, i+2) == 'ppp' or s:sub(i, i+2) == 'qqq' or s:sub(i, i+2) == 'rrr'\
    \ or s:sub(i, i+2) == 'sss' or s:sub(i, i+2) == 'ttt' or s:sub(i, i+2) == 'uuu'\
    \ or s:sub(i, i+2) == 'vvv' or s:sub(i, i+2) == 'www' or s:sub(i, i+2) == 'xxx'\
    \ or s:sub(i, i+2) == 'yyy' or s:sub(i, i+2) == 'zzz' then\n      return false\n\
    \    end\n    i = i + 1\n  end\n  return true\nend", "    local x = s:len()\n\
    \    if x < 3 then\n        return false\n    end\n    local i = 1\n    while\
    \ i < x - 2 do\n        if s:sub(i, i) == s:sub(i + 1, i + 1) or s:sub(i, i) ==\
    \ s:sub(i + 2, i + 2) then\n            return false\n        end\n        i =\
    \ i + 1\n    end\n    return true\nend", "    if #s < 3 then\n        return false\n\
    \    end\n    for i = 1, #s - 2 do\n        if s:sub(i, i) == s:sub(i + 1, i +\
    \ 1) then\n            return false\n        end\n    end\n    return true\nend",
  "  if s:len()<3 then return false end\n  for i=1,#s-2 do\n    if s:sub(i,i+2)==s:sub(i+1,i+3)\
    \ then return false end\n  end\n  return true\nend", end, "    if string.len(s)\
    \ < 3 then\n        return false\n    end\n    for i = 1, string.len(s) - 2 do\n\
    \        if string.sub(s, i, i + 2) == string.sub(s, i + 1, i + 3) then\n    \
    \        return false\n        end\n    end\n    return true\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
