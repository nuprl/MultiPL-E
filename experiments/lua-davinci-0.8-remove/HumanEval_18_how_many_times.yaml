name: HumanEval_18_how_many_times
language: lua
prompt: "-- Find how many times a given substring can be found in the original string.\
  \ Count overlaping cases.\nlocal function how_many_times(string, substring)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = how_many_times\n\
  \    lu.assertEquals(candidate('', 'x'), 0)\n    lu.assertEquals(candidate('xyxyxyx',\
  \ 'x'), 4)\n    lu.assertEquals(candidate('cacacacac', 'cac'), 4)\n    lu.assertEquals(candidate('john\
  \ doe', 'john'), 1)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local n_times = 0\n  for i = 1, #string - #substring + 1 do\n   \
    \ if string:sub(i, i + #substring - 1) == substring then\n      n_times = n_times\
    \ + 1\n    end\n  end\n  return n_times\nend", "    local counter = 0\n    local\
    \ index = 1\n    while true do\n        index = string:find(substring, index,\
    \ true)\n        if index == nil then\n            break\n        end\n      \
    \  counter = counter + 1\n        index = index + 1\n    end\n    return counter\n\
    end", "    return select(2, string:gsub(substring, \"\"))\nend", "\tlocal amount\
    \ = 0\n\tfor i = 1, #string do\n\t\tif string:sub(i, i + #substring - 1) == substring\
    \ then\n\t\t\tamount = amount + 1\n\t\tend\n\tend\n\treturn amount\nend", "\t\
    local count = 0\n\tfor i = 1, string.len(string) do\n\t\tlocal istart, iend =\
    \ string.find(string, substring, i, true)\n\t\tif istart then\n\t\t\tcount = count\
    \ + 1\n\t\t\ti = iend\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\treturn count\n\
    end", "\tlocal start_position = string.find(string, substring, 1, true)\n\tif\
    \ start_position == nil then\n\t\treturn 0\n\tend\n\tlocal count = 1\n\tlocal\
    \ found = false\n\twhile true do\n\t\tfound = string.find(string, substring, start_position\
    \ + 1, true)\n\t\tif found == nil then\n\t\t\tbreak\n\t\tend\n\t\tcount = count\
    \ + 1\n\t\tstart_position = found\n\tend\n\treturn count\nend", "\tif #substring\
    \ > #string then return 0 end\n\tlocal count = 0\n\tlocal tempstring = string\n\
    \tlocal tempsubstring = substring\n\twhile true do\n\t\tlocal start_index = tempstring:find(tempsubstring)\n\
    \t\tif start_index == nil then break end\n\t\tcount = count + 1\n\t\ttempstring\
    \ = tempstring:sub(start_index + #tempsubstring)\n\tend\n\treturn count\nend",
  "    local counter = 0\n    local find_start = 1\n    while find_start <= #string\
    \ do\n        local find_end = string:find(substring, find_start)\n        if\
    \ find_end == nil then\n            break\n        end\n        counter = counter\
    \ + 1\n        find_start = find_end + 1\n    end\n    return counter\nend", " \
    \ local cnt = 0\n  local l = string.len(substring)\n  local d = string.len(string)\
    \ - l\n  for i = 0, d do\n    if string.sub(string, i+1, i+l) == substring then\n\
    \      cnt = cnt + 1\n    end\n  end\n  return cnt\nend", "\tif string == nil\
    \ or substring == nil then\n\t\treturn 0\n\tend\n\tlocal count = 0\n\tfor _ in\
    \ string.gmatch(string, substring) do\n\t\tcount = count + 1\n\tend\n\treturn\
    \ count\nend", "    local n = 0\n    local start = 0\n    local i = 0\n    while\
    \ i do\n        i = string.find(string, substring, start)\n        if i ~= nil\
    \ then\n            n = n + 1\n            start = i + 1\n        end\n    end\n\
    \    return n\nend", "    local count = 0\n    local offset = 1\n    while true\
    \ do\n        local i = string.find(string, substring, offset, true)\n       \
    \ if i == nil then break end\n        count = count + 1\n        offset = i +\
    \ 1\n    end\n    return count\nend", "\tlocal count = 0\n\tlocal pos = 1\n\t\
    while pos ~= nil do\n\t\tpos = string.find(string, substring, pos, true)\n\t\t\
    if pos ~= nil then\n\t\t\tcount = count + 1\n\t\t\tpos = pos + 1\n\t\tend\n\t\
    end\n\treturn count\nend", "\t-- Final count\n\tlocal count = 0\n\t-- Starting\
    \ point\n\tlocal start_point = 0\n\t-- Segment of the string to be counted\n\t\
    local segment\n\t\n\t-- Loop until a substring of the string can't be found anymore\n\
    \twhile true do\n\t\t-- Get the substring\n\t\tsegment = string.sub(string, start_point\
    \ + 1, string.len(string))\n\t\t--print(segment)\n\t\t-- Look for it\n\t\tsegment\
    \ = string.find(segment, substring)\n\t\t-- If it's found, increase the count\
    \ and move the starting point\n\t\tif segment ~= nil then\n\t\t\tcount = count\
    \ + 1\n\t\t\tstart_point = start_point + segment\n\t\telse\n\t\t\t-- If it's not\
    \ found anymore, exit the loop\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\t-- Return the\
    \ count\n\treturn count\nend", "    -- Create a table to hold each character and\
    \ its position.\n    local positions = {}\n    for i = 1, #string do\n       \
    \ positions[i] = string:sub(i, i)\n    end", "\tlocal i = 1\n\tlocal n = 0\n\t\
    repeat\n\t\ti = string.find(string, substring, i)\n\t\tif i then\n\t\t\tn = n\
    \ + 1\n\t\t\ti = i + 1\n\t\tend\n\tuntil not i\n\treturn n\nend", "\tlocal num\
    \ = 0\n\t\n\tlocal substr_index = string.find(string, substring, 0, true)\n\t\n\
    \twhile substr_index do\n\t\tnum = num + 1\n\t\tsubstr_index = string.find(string,\
    \ substring, substr_index + 1, true)\n\tend\n\t\n\treturn num\nend", "\tlocal\
    \ count = 0\n\tfor start, stop in string.gmatch(string, \"(.-)\"..substring..\"\
    (.-)\") do\n\t\tcount = count + 1\n\tend\n\treturn count\nend", "    local n =\
    \ string.len(string)\n    local s = string.len(substring)\n    local count = 0\n\
    \    for i = 1, n - s + 1 do\n        if string.sub(string, i, i + s - 1) == substring\
    \ then\n            count = count + 1\n        end\n    end\n    return count\n\
    end", "\tif string:len() == 0 or substring:len() == 0 then\n\t\treturn 0\n\tend\n\
    \t\n\tlocal num = 0\n\tfor start, stop in string.gmatch(string, '()' .. substring\
    \ .. '()') do\n\t\tnum = num + 1\n\tend\n\treturn num\nend", "\tlocal counter\
    \ = 0\n\tlocal match = string.match(string, substring)\n\twhile match do\n\t\t\
    counter = counter + 1\n\t\tstring = string.gsub(string, substring, \"\", 1)\n\t\
    \tmatch = string.match(string, substring)\n\tend\n\treturn counter\nend", "  local\
    \ s, e = 1, 1\n  local count = 0\n  local sub_len = #substring\n  while s do\n\
    \    s, e = string.find(string, substring, e)\n    if s then\n      count = count\
    \ + 1\n      e = e + 1\n    end\n  end\n  return count\nend", "    if string ==\
    \ \"\" or substring == \"\" then\n        return 0\n    end\n    local p = 1\n\
    \    local times = 0\n    local s = 1\n    while p <= #string do\n        local\
    \ f, l = string.find(string, substring, p, true)\n        if f then\n        \
    \    times = times + 1\n            s = l + 1\n        else\n            break\n\
    \        end\n        p = s\n    end\n    return times\nend", "\tlocal _, count\
    \ = string:gsub(substring, \"\")\n\treturn count\nend", "\tlocal i, j = 0, 0\n\
    \twhile true do\n\t\ti = string:find(substring, i+1, true)\n\t\tif i then\n\t\t\
    \tj = j + 1\n\t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\treturn j\nend", "  local\
    \ count = 0\n  local index = 0\n  repeat\n    index = string:find(substring, index\
    \ + 1)\n    if index then\n      count = count + 1\n    end\n  until not index\n\
    \  return count\nend", "    local pattern = string.gsub(substring, \"(%W)\", \"\
    %%%1\")\n    pattern = string.gsub(pattern, \"%%%*\", \".*\")\n    local _, n\
    \ = string.gsub(string, pattern, \"\")\n    return n\nend", "    local i = 1\n\
    \    local j = 1\n    local count = 0\n    while i <= #string do\n        if string:sub(i,\
    \ i + #substring - 1) == substring then\n            count = count + 1\n     \
    \       i = i + #substring\n        else\n            i = i + 1\n        end\n\
    \    end\n    return count\nend", "  local string_len = string.len(string)\n \
    \ local substring_len = string.len(substring)\n  local times = 0\n  for i = 1,\
    \ string_len - substring_len + 1 do\n    if string.sub(string, i, i + substring_len\
    \ - 1) == substring then\n      times = times + 1\n    end\n  end\n  return times\n\
    end", "    local count = 0\n    for i = 1, #string - #substring + 1 do\n     \
    \   if string:sub(i, i + #substring - 1) == substring then\n            count\
    \ = count + 1\n        end\n    end\n    return count\nend", "    local function\
    \ match_function(at)\n        local t = {}\n        local function m(a,b) t[#t+1]\
    \ = {a,b} return \"\" end\n        string.gsub(string, substring, m, at)\n   \
    \     return t\n    end\n    local matches = match_function(1)\n    while #matches\
    \ > 0 do\n        local i = 1\n        local m = matches[i]\n        while i <=\
    \ #matches do\n            local at = m[2] + 1\n            local arr = match_function(at)\n\
    \            if #arr > 0 then\n                m = arr[1]\n                matches[i]\
    \ = m\n            else\n                table.remove(matches, i)\n          \
    \  end\n            i = i + 1\n        end\n    end\n    return #matches\nend",
  "    local count = 0\n    local pos = 1\n    while true do\n        pos = string:find(substring,\
    \ pos, true)\n        if not pos then break end\n        count = count + 1\n \
    \       pos = pos + 1\n    end\n    return count\nend", "    --TODO: Make this\
    \ more efficient (not to calculate the same stuff twice)\n    local pattern =\
    \ '(' .. substring .. ')'\n    local _, count = string:gsub(pattern, '%1')\n \
    \   return count\nend", "    local counter = 0\n    local offset = 0\n    repeat\n\
    \        local b, e = string.find(string, substring, offset, true)\n        if\
    \ b then\n            counter = counter + 1\n            offset = e + 1\n    \
    \    end\n    until not b\n    return counter\nend", "    local position = string.find(string,\
    \ substring)\n    local counter = 0\n    local start = 1\n    while position do\n\
    \        counter = counter + 1\n        start = position + 1\n        position\
    \ = string.find(string, substring, start)\n    end\n    return counter\nend",
  "\tlocal _, times = string:gsub(substring, \"\")\n\treturn times\nend", "  local\
    \ position = 0\n  local times = 0\n  local length = string.len(substring)\n  while\
    \ true do\n    position = string.find(string, substring, position + 1)\n    if\
    \ position == nil then\n      break\n    end\n    times = times + 1\n  end\n \
    \ return times\nend", "    local n = 0\n    local i = 1\n    while (i < string.len(string))\
    \ do\n        local match = string.find(string, substring, i)\n        if (match\
    \ == nil) then\n            break\n        end\n        i = match + 1\n      \
    \  n = n + 1\n    end\n    return n\nend", "  local start = 1\n  local found =\
    \ 0\n  local stop\n  repeat\n    stop = string.find(string, substring, start,\
    \ true)\n    if stop then\n      found = found + 1\n      start = stop + 1\n \
    \   end\n  until not stop\n  return found\nend", "  local num = 0\n  local ss\
    \ = string.find(string, substring, 1, true)\n  while ss do\n    num = num + 1\n\
    \    ss = string.find(string, substring, ss + 1, true)\n  end\n  return num\n\
    end", "    local n = string.len(string)\n    local m = string.len(substring)\n\
    \    local count = 0\n    for i = 1, n - m + 1 do\n        if string.sub(string,\
    \ i, i + m - 1) == substring then\n            count = count + 1\n        end\n\
    \    end\n    return count\nend", "  if substring == \"\" then return 0 end\n\
    \  return select(2, string:gsub(substring, \"\"))\nend", "  local n = string.len(string)\n\
    \  local m = string.len(substring)\n  local count = 0\n  for i = 1, n - m + 1\
    \ do\n    if string.sub(string, i, i + m - 1) == substring then\n      count =\
    \ count + 1\n    end\n  end\n  return count\nend", "  if not string then\n   \
    \ return 0\n  end\n  local count = 0\n  local s = string\n  local sub = substring\n\
    \  if sub == '' then\n    return 1\n  end\n  if sub:len() > s:len() then\n   \
    \ return 0\n  end\n  while s:find(sub) do\n    s = s:sub(s:find(sub) + sub:len())\n\
    \    count = count + 1\n  end\n  return count\nend", "\tlocal count = 0\n\tlocal\
    \ start = 1\n\twhile true do\n\t\tlocal i, j = string.find(string, substring,\
    \ start)\n\t\tif i == nil then break end\n\t\tcount = count + 1\n\t\tstart = j\
    \ + 1\n\tend\n\treturn count\nend", "    local times, pos = 0, 1\n    while true\
    \ do\n        local start_pos, end_pos = string.find(string, substring, pos)\n\
    \        if start_pos == nil then\n            break\n        end\n        times\
    \ = times + 1\n        pos = end_pos + 1\n    end\n    return times\nend", "\t\
    local substring_length = #substring\n\tlocal last_substring_index = #string -\
    \ substring_length + 1\n\tlocal num_times = 0\n\tfor index = 1, last_substring_index\
    \ do\n\t\tif string:sub(index, index + substring_length - 1) == substring then\n\
    \t\t\tnum_times = num_times + 1\n\t\tend\n\tend\n\treturn num_times\nend", " \
    \ local match_tables = find_all_matches(string, substring)\n  local count = 0\n\
    \  for _, match_table in ipairs(match_tables) do\n    count = count + 1\n  end\n\
    \  return count\nend", "  local count = 0\n  local idx = 1\n  while true do\n\
    \    local from, to = string.find(string, substring, idx, true)\n    if from ==\
    \ nil then\n      break\n    end\n    count = count + 1\n    idx = to + 1\n  end\n\
    \  return count\nend", "  local function find(string, substring)\n    local first,\
    \ last = string.find(string, substring)\n    return (first and first or 0), (last\
    \ and last or 0)\n  end\n  local function pad(str, length)\n    str = str or ''\n\
    \    return (str .. string.rep(' ', length - #str))\n  end\n  local matches =\
    \ {}\n  local prefix = string.sub(string, 1, #substring - 1)\n  local s = string.sub(string,\
    \ #substring)\n  local first, last = find(s, substring)\n  if first == 0 and last\
    \ == 0 then\n    return 0\n  end\n  while first > 0 do\n    s = string.sub(s,\
    \ #substring)\n    matches[#matches + 1] = pad(prefix, #substring - 1) .. string.sub(s,\
    \ 1, first - 1)\n    prefix = string.sub(s, 1, #substring - 1)\n    first, last\
    \ = find(s, substring)\n  end\n  return #matches\nend", "    return select(2,\
    \ string:gsub(substring, \"\"))\nend", "  local count = 0\n  local pos = 1\n \
    \ while true do\n    pos = string.find(string, substring, pos, true)\n    if not\
    \ pos then break end\n    count = count + 1\n    pos = pos + 1\n  end\n  return\
    \ count\nend", "    local count = 0\n    local last_start = 0\n    while true\
    \ do\n        last_start = string:find(substring, last_start + 1)\n        if\
    \ last_start == nil then\n            break\n        end\n        count = count\
    \ + 1\n    end\n    return count\nend", "\tassert(string, 'The string argument\
    \ is missing')\n\tassert(substring, 'The substring argument is missing')\n\tlocal\
    \ count = 0\n\tlocal len = string.len(substring)\n\tlocal function pass(n)\n\t\
    \tcount = count + 1\n\t\treturn string.sub(string, n + len)\n\tend\n\twhile true\
    \ do\n\t\tstring = string.gsub(string, substring, pass, 1)\n\t\tif count == 0\
    \ then break end\n\tend\n\treturn count\nend", "\tlocal count = 0\n\tlocal offset\
    \ = 1\n\twhile true do\n\t\tlocal index = string.find(string, substring, offset,\
    \ true)\n\t\tif not index then\n\t\t\tbreak\n\t\tend\n\t\tcount = count + 1\n\t\
    \toffset = index + 1\n\tend\n\treturn count\nend", "\tlocal start_index = 0\n\t\
    local counter = 0\n\trepeat\n\t\tstart_index = string.find(string, substring,\
    \ start_index+1, true)\n\t\tif start_index ~= nil then\n\t\t\tcounter = counter\
    \ + 1\n\t\tend\n\tuntil start_index == nil\n\treturn counter\nend", "    local\
    \ times = 0\n    local index = 1\n    local len = string.len(string)\n    local\
    \ sublen = string.len(substring)\n    while (index <= len) do\n        local found\
    \ = string.find(string, substring, index, true)\n        if (found ~= nil) then\n\
    \            times = times + 1\n            index = found + sublen\n        else\n\
    \            break\n        end\n    end\n    return times\nend", "\tlocal count\
    \ = 0\n\tlocal i = 0\n\twhile true do\n\t\ti = string.find(string, substring,\
    \ i + 1, true)\n\t\tif i == nil then\n\t\t\tbreak\n\t\tend\n\t\tcount = count\
    \ + 1\n\tend\n\treturn count\nend", "  local count = 0\n  local s_len = string.len(string)\n\
    \  local sub_len = string.len(substring)\n  for i = 1, s_len do\n    if string.sub(string,\
    \ i, i + sub_len - 1) == substring then\n      count = count + 1\n    end\n  end\n\
    \  return count\nend", "\tlocal i, j = 0, 0\n\tlocal count = 0\n\twhile true do\n\
    \t\ti, j = string.find(string, substring, j + 1, true)\n\t\tif not i then\n\t\t\
    \tbreak\n\t\tend\n\t\tcount = count + 1\n\tend\n\treturn count\nend", "    local\
    \ step = #substring\n    local n = 0\n    for i = 1, #string, step do\n      \
    \  if string:sub(i, i + step - 1) == substring then\n            n = n + 1\n \
    \       end\n    end\n    return n\nend", "  local i = 0\n  local length = substring:len()\n\
    \  local count = 0\n  while true do\n    i = string:find(substring, i + 1)\n \
    \   if i == nil then\n      break\n    end\n    count = count + 1\n  end\n  return\
    \ count\nend", "\tif (not string) or (not substring) then return 0 end\n\tlocal\
    \ number = 0\n\tlocal start = 1\n\tlocal fin = 1\n\twhile start <= string:len()\
    \ do\n\t\tfin = string:find(substring, start, true)\n\t\tif fin then\n\t\t\tnumber\
    \ = number + 1\n\t\t\tstart = fin + 1\n\t\telse\n\t\t\tstart = string:len() +\
    \ 1\n\t\tend\n\tend\n\treturn number\nend", "  local count = 0\n  local s_len\
    \ = string.len(string)\n  local sub_len = string.len(substring)\n  for i = 1,\
    \ s_len - sub_len + 1 do\n    if string.sub(string, i, i + sub_len - 1) == substring\
    \ then\n      count = count + 1\n    end\n  end\n  return count\nend", "    local\
    \ time = 0\n    local index = string.find(string, substring)\n    if index ==\
    \ nil then\n        return 0\n    end\n    while index ~= nil do\n        time\
    \ = time + 1\n        index = string.find(string, substring, index + 1)\n    end\n\
    \    return time\nend", "    return string:gsub(substring, \"\")\nend", "    local\
    \ count = 0\n    local _,last_pos = string:gsub(substring, \"\")\n    return last_pos\n\
    end", "    local count = 0\n    for i in string.gmatch(string, substring) do\n\
    \        count = count + 1\n    end\n    return count\nend", "    local count\
    \ = 0\n    local position = 1\n    while true do\n        local start, finish\
    \ = string.find(string, substring, position)\n        if start then\n        \
    \    count = count + 1\n            position = finish + 1\n        else\n    \
    \        break\n        end\n    end\n    return count\nend", "\tlocal count =\
    \ 0\n\tlocal _, ending = string:find(substring)\n\twhile ending do\n\t\tcount\
    \ = count + 1\n\t\tlocal start, ending = string:find(substring, ending + 1)\n\t\
    end\n\treturn count\nend", "    local counter = 0\n    local pos = string.find(string,\
    \ substring, 0, true)\n    while pos do\n        counter = counter + 1\n     \
    \   pos = string.find(string, substring, pos + 1, true)\n    end\n    return counter\n\
    end", "\tlocal count = 0\n\tlocal start_index = 1\n\tlocal end_index = #substring\n\
    \twhile start_index <= #string do\n\t\tif string:sub(start_index, end_index) ==\
    \ substring then\n\t\t\tcount = count + 1\n\t\t\tstart_index = start_index + #substring\n\
    \t\t\tend_index = end_index + #substring\n\t\telse\n\t\t\tstart_index = start_index\
    \ + 1\n\t\t\tend_index = end_index + 1\n\t\tend\n\tend\n\treturn count\nend",
  "  local from = 1\n  local howmany = 0\n  local startpos, endpos = string.find(string,\
    \ substring, from)\n  while startpos do\n    howmany = howmany + 1\n    from =\
    \ endpos + 1\n    startpos, endpos = string.find(string, substring, from)\n  end\n\
    \  return howmany\nend", "\tlocal n, s_pos = 0, string.find(string, substring)\n\
    \twhile s_pos do\n\t\tn = n + 1\n\t\ts_pos = string.find(string, substring, s_pos\
    \ + 1)\n\tend\n\treturn n\nend", "    -- Count overlaping cases.\n    local how_many\
    \ = 0\n    local start = 1\n    local found = string.find(string, substring, start)\n\
    \    while found do\n        how_many = how_many + 1\n        start = found +\
    \ 1\n        found = string.find(string, substring, start)\n    end\n    return\
    \ how_many\nend", "\tlocal count = 0\n\tlocal f = function(substring) count =\
    \ count + 1 end\n\tstring:gsub(substring, f)\n\treturn count\nend", "\tlocal count\
    \ = 0\n\tlocal pos = 1\n\tlocal start_pos, end_pos = string.find(string, substring,\
    \ pos)\n\twhile start_pos do\n\t\tcount = count + 1\n\t\tpos = end_pos + 1\n\t\
    \tstart_pos, end_pos = string.find(string, substring, pos)\n\tend\n\treturn count\n\
    end", "  local case, pos, count = -1, -1, 0\n  while true do\n    case, pos =\
    \ string.find(string, substring, pos + 1)\n    if case == nil then break end\n\
    \    count = count + 1\n  end\n  return count\nend", "  local i = 0\n  local count\
    \ = 0\n  while true do\n    i = string.find(string, substring, i + 1, true)\n\
    \    if i == nil then\n      break\n    end\n    count = count + 1\n  end\n  return\
    \ count\nend", "    -- If the string is nil or the substring is nil, return 0\n\
    \    if string == nil or substring == nil then\n        return 0\n    end", " \
    \   local count = 0\n    local index = 0\n    local part = string\n    repeat\n\
    \        part = part:sub(index+1)\n        index = part:find(substring)\n    \
    \    if index then\n            count = count + 1\n        end\n    until not\
    \ index\n    return count\nend", "    local start, finish, count = 1, 1, 0\n \
    \   while finish <= #string do\n        start, finish = string.find(string, substring,\
    \ start, true)\n        if start then\n            count = count + 1\n       \
    \     start = finish + 1\n        else\n            break\n        end\n    end\n\
    \    return count\nend", "\tlocal idx, count = 1, 0\n\tidx = string.find(string,\
    \ substring, idx, true)\n\twhile idx do\n\t\tcount = count + 1\n\t\tidx = string.find(string,\
    \ substring, idx + 1, true)\n\tend\n\treturn count\nend", "    local times = 0\n\
    \    local limit = string.len(string) - string.len(substring) + 1\n    for i =\
    \ 1, limit do\n        if string.sub(string, i, i + string.len(substring) - 1)\
    \ == substring then\n            times = times + 1\n        end\n    end\n   \
    \ return times\nend", "    local count = 0\n    local from = 1\n    local to =\
    \ #substring\n    local n = #string\n    while from <= n do\n        if string:sub(from,\
    \ to) == substring then\n            count = count + 1\n            from = from\
    \ + 1\n            to = to + 1\n        else\n            from = from + 1\n  \
    \          to = to + 1\n        end\n    end\n    return count\nend", "  local\
    \ n = 0\n  local prev = -1\n  repeat\n    prev = string:find(substring, prev +\
    \ 1)\n    if prev then\n      n = n + 1\n    end\n  until not prev\n  return n\n\
    end", "\tif not string or not substring then return 0 end\n\tlocal count = 0\n\
    \tfor offset in string.gmatch(string, substring) do\n\t\tcount = count + 1\n\t\
    end\n\treturn count\nend", "  local found_start_indexes = {}\n  local start_index\
    \ = string.find(string, substring, 1, true)\n  while start_index do\n    found_start_indexes[#found_start_indexes\
    \ + 1] = start_index\n    start_index = string.find(string, substring, start_index\
    \ + 1, true)\n  end\n  return #found_start_indexes\nend", "\tlocal count = 0\n\
    \tlocal i, j = string.find(string, substring, 1, true)\n\twhile i do\n\t\tcount\
    \ = count + 1\n\t\ti, j = string.find(string, substring, j + 1, true)\n\tend\n\
    \treturn count\nend", "  local i, count = 1, 0\n  while true do\n    i = string:find(substring,\
    \ i, true)\n    if i == nil then break end\n    count = count + 1\n    i = i +\
    \ 1\n  end\n  return count\nend", "\tlocal times, c = 0, 0\n\twhile c <= #string\
    \ do\n\t\t_, c = string:find(substring, c + 1)\n\t\tif c then\n\t\t\ttimes = times\
    \ + 1\n\t\tend\n\tend\n\treturn times\nend", "\tlocal count = 0\n\tfor _ in string.gmatch(string,\
    \ substring) do\n\t\tcount = count + 1\n\tend\n\treturn count\nend", "\tlocal\
    \ count = 0\n\tlocal from = 1\n\tlocal to = 1\n\tlocal next = 0\n\twhile to do\n\
    \t\tfrom, to = string.find(string, substring, from, true)\n\t\tif from then\n\t\
    \t\tcount = count + 1\n\t\t\tnext = to + 1\n\t\t\tfrom = next\n\t\t\tto = next\n\
    \t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\treturn count\nend", "    local n = 0\n\
    \    local last_index\n    for i = 1, string.len(string) do\n        last_index\
    \ = string.find(string, substring, i, true)\n        if last_index then\n    \
    \        n = n + 1\n            i = last_index\n        else\n            break\n\
    \        end\n    end\n    return n\nend", "    local pattern = string.format(\"\
    ()%s()\", substring)\n    local len = string.len(string)\n    local last = 1\n\
    \    local i = 0\n    while last do\n        _, last = string.find(string, pattern,\
    \ last)\n        if last then\n            i = i + 1\n            last = last\
    \ + 1\n            if last > len then\n                break\n            end\n\
    \        end\n    end\n    return i\nend", "    local pattern = '(' .. substring\
    \ .. ')'\n    local found = 0\n    string:gsub(pattern, function(s)\n        found\
    \ = found + 1\n    end)\n    return found\nend", "\tlocal n = 0", "    local str_len\
    \ = string.len(string)\n    local sub_len = string.len(substring)\n    local i\
    \ = 1\n    local count = 0\n    while i < str_len do\n        local find = string.find(string,\
    \ substring, i, true)\n        if find then\n            count = count + 1\n \
    \           i = find + sub_len\n        else\n            break\n        end\n\
    \    end\n    return count\nend", "\tif #substring > #string then return 0 end\n\
    \tlocal count = 0\n\tlocal match_start = 0\n\tlocal match_end = 0\n\twhile match_start\
    \ < #string do\n\t\tmatch_start, match_end = string:find(substring, match_end\
    \ + 1)\n\t\tif match_start == nil then break end\n\t\tcount = count + 1\n\tend\n\
    \treturn count\nend", "    local _, count = string:gsub(substring, \"\")\n   \
    \ return count\nend", "    local n = 0\n    local p = string.find(string, substring,\
    \ 1, true)\n    while p do\n        n = n + 1\n        p = string.find(string,\
    \ substring, p + 1, true)\n    end\n    return n\nend", "\tlocal orig_len = string.len(string)\n\
    \tlocal sub_len = string.len(substring)\n\tlocal matches = 0\n\twhile true do\n\
    \t\tlocal found_at = string.find(string, substring, 1, true)\n\t\tif found_at\
    \ == nil then\n\t\t\tbreak\n\t\tend\n\t\tmatches = matches + 1\n\t\tstring = string.sub(string,\
    \ found_at + sub_len)\n\tend\n\treturn matches\nend", "    local _, amount = string:gsub(substring,\
    \ \"\")\n    return amount\nend", "\t\n\tif string == \"\" or substring == \"\"\
    \ then\n\t\treturn 0\n\tend\n\t\n\tlocal num_times_substring_found = 0\n\t\n\t\
    -- lstring.find returns the position of the first found instance of substring\
    \ in string.\n\t-- if it returns nil it means that substring is not found.\n\t\
    while true do\n\t\tlocal pos = lstring.find(string, substring, 1, true)\n\t\t\
    if pos == nil then\n\t\t\tbreak\n\t\tend\n\t\tnum_times_substring_found = num_times_substring_found\
    \ + 1\n\t\t-- Remove the found instance of substring from string.\n\t\tstring\
    \ = lstring.sub(string, pos + lstring.len(substring))\n\tend\n\t\n\treturn num_times_substring_found\n\
    end", "  local ok = true\n  local len = #substring\n  local len_str = #string\n\
    \  local times = 0\n  while ok do\n    local idx = string.find(string, substring,\
    \ 1, true)\n    if idx == nil then\n      ok = false\n    else\n      string =\
    \ string.sub(string, idx + len)\n      times = times + 1\n    end\n  end\n  return\
    \ times\nend", "  local i, count = 0, 0\n  local j = 1\n  local len_substring\
    \ = string.len(substring)\n  repeat\n    i = string.find(string, substring, j,\
    \ true)\n    if i then\n      count = count + 1\n      j = i + len_substring\n\
    \    end\n  until not i\n  return count\nend", "\tlocal i = 0\n\tlocal count =\
    \ 0\n\twhile true do\n\t\ti = string.find(string, substring, i+1, true)\n\t\t\
    if i == nil then\n\t\t\tbreak\n\t\tend\n\t\tcount = count + 1\n\tend\n\treturn\
    \ count\nend", "\tlocal n = 0\n\tfor s in string:gmatch(substring) do\n\t\tn =\
    \ n + 1\n\tend\n\treturn n\nend", "\tlocal how_many = 0\n\tlocal match = string.find(string,\
    \ substring)\n\twhile match do\n\t\thow_many = how_many + 1\n\t\tstring = string.sub(string,\
    \ match + 1)\n\t\tmatch = string.find(string, substring)\n\tend\n\treturn how_many\n\
    end", "    local count = 0\n    local index = 0\n    local last = 1\n    repeat\n\
    \        local tmp = string.find(string, substring, index + 1, true)\n       \
    \ if tmp then\n            last = tmp\n            index = tmp\n            count\
    \ = count + 1\n        end\n    until not tmp\n    return count, last\nend", "\t\
    local count = 0\n\tfor i in string.gmatch(string, substring) do\n\t\tcount = count\
    \ + 1\n\tend\n\treturn count\nend", "    local i = 0\n    local count = 0\n  \
    \  while i < #string do\n        i = string:find(substring, i+1)\n        if i\
    \ == nil then\n            break\n        end\n        count = count + 1\n   \
    \ end\n    return count\nend", "  local count = 0\n  local last_found = -1\n \
    \ while true do\n    last_found = string:find(substring, last_found + 1)\n   \
    \ if last_found then\n      count = count + 1\n    else\n      break\n    end\n\
    \  end\n  return count\nend", "\tif not string or not substring then return 0\
    \ end\n\tlocal count = 0\n\tlocal start = 1\n\twhile true do\n\t\tstart = string.find(string,\
    \ substring, start, true)\n\t\tif not start then break end\n\t\tcount = count\
    \ + 1\n\t\tstart = start + 1\n\tend\n\treturn count\nend", "  return select(2,\
    \ string:gsub(substring, \"\"))\nend", "    -- Check if the substring appears\
    \ in the string. If not return 0.\n    if string:find(substring) == nil then\n\
    \        return 0\n    end\n    -- Check the first appearance of the substring\
    \ in the string.\n    local appearance = string:find(substring)\n    -- If the\
    \ substring appears in the first occurence then count that.\n    if appearance\
    \ == 1 then\n        local count = 1\n        -- Then replace that first occurence\
    \ of the substring in the string.\n        string = string:gsub(substring, \"\
    \ \", 1)\n        -- Iterate while the substring appears in the string.\n    \
    \    while string:find(substring) ~= nil do\n            -- Then replace the first\
    \ occurence of the substring in the string.\n            string = string:gsub(substring,\
    \ \" \", 1)\n            -- And increase the count.\n            count = count\
    \ + 1\n        end\n        -- Return the count.\n        return count\n    --\
    \ If the substring appears not in the first occurence then count from there.\n\
    \    else\n        local count = 0\n        -- Iterate while the substring appears\
    \ in the string.\n        while string:find(substring) ~= nil do\n           \
    \ -- Then replace the first occurence of the substring in the string.\n      \
    \      string = string:gsub(substring, \" \", 1)\n            -- And increase\
    \ the count.\n            count = count + 1\n        end\n        -- Return the\
    \ count.\n        return count\n    end\nend", '    if #substring == 0 then return
    #string + 1 end', "\tlocal n = string.len(string)\n\tlocal m = string.len(substring)\n\
    \tlocal count = 0\n\tfor i = 1, n-m+1 do\n\t\tif string.sub(string, i, i+m-1)\
    \ == substring then\n\t\t\tcount = count + 1\n\t\tend\n\tend\n\treturn count\n\
    end", "    local index = 1\n    local count = 0\n    while true do\n        index\
    \ = string.find(string, substring, index, true)\n        if index == nil then\
    \ break end\n        count = count + 1\n        index = index + #substring\n \
    \   end\n    return count\nend", "\tlocal count = 0\n\tfor i = 1, #string - #substring\
    \ + 1 do\n\t\tif string:sub(i, i + #substring - 1) == substring then\n\t\t\tcount\
    \ = count + 1\n\t\tend\n\tend\n\treturn count\nend", "  local count = 0\n  for\
    \ i = 1, #string do\n    if string:sub(i, i + #substring - 1) == substring then\n\
    \      count = count + 1\n    end\n  end\n  return count\nend", "\tlocal last_found\
    \ = 1\n\tlocal _, next_found = string:find(substring, last_found)\n\tlocal counter\
    \ = 0\n\t\n\twhile next_found do\n\t\tcounter = counter + 1\n\t\tlast_found =\
    \ next_found + 1\n\t\t_, next_found = string:find(substring, last_found)\n\tend\n\
    \t\n\treturn counter\nend", "  local index = 1\n  local count = 0\n  local last_find\
    \ = 0\n  while index do\n    index = string:find(substring, index, true)\n   \
    \ if index then\n      count = count + 1\n      index = index + 1\n    end\n \
    \ end\n  return count\nend", "    local f = function()\n        local first =\
    \ string.find(string, substring)\n        if first then\n            return string.sub(string,\
    \ first + 1), first\n        end\n    end\n    local i = 0\n    repeat\n     \
    \   string, first = f()\n        if first then\n            i = i + 1\n      \
    \  end\n    until not first\n    return i\nend", "    local result = 0\n    local\
    \ pos = 1\n    local word_len = #substring\n    local string_len = #string\n \
    \   while pos <= string_len do\n        local start_pos, end_pos = find(string,\
    \ substring, pos, true)\n        if start_pos then\n            result = result\
    \ + 1\n            pos = end_pos + 1\n        else\n            break\n      \
    \  end\n    end\n    return result\nend", "\tif type(string) == \"string\" and\
    \ type(substring) == \"string\" then\n\t\tlocal final_count = 0;\n\t\tlocal last_found\
    \ = 0;\n\t\tlocal current_position = 0;\n\t\trepeat\n\t\t\tlast_found = string.find(string,\
    \ substring, current_position, true);\n\t\t\tif last_found then\n\t\t\t\tfinal_count\
    \ = final_count + 1;\n\t\t\t\tcurrent_position = last_found + 1;\n\t\t\tend\n\t\
    \tuntil not last_found;\n\t\treturn final_count;\n\telse\n\t\terror(\"The parameters\
    \ are not correct! Only string parameters are allowed!\");\n\tend\nend", "   \
    \ if #substring > #string then\n        return 0\n    end\n    local how_many\
    \ = 0\n    for first = 1, #string - #substring + 1 do\n        if string:sub(first,\
    \ first + #substring - 1) == substring then\n            how_many = how_many +\
    \ 1\n        end\n    end\n    return how_many\nend", "\tlocal start, count =\
    \ 1, 0\n\twhile true do\n\t\tlocal start, stop = string.find(string, substring,\
    \ start)\n\t\tif start then\n\t\t\tcount = count + 1\n\t\t\tstart = stop + 1\n\
    \t\telse\n\t\t\tbreak\n\t\tend\n\tend\n\treturn count\nend", "  local k, count\
    \ = 1, 0\n  while true do\n    local p, q = string.find(string, substring, k,\
    \ true)\n    if not p then break end\n    count = count + 1\n    k = q + 1\n \
    \ end\n  return count\nend", "    return select(2, string:gsub(substring, \"\"\
    ))\nend", "\tlocal i = 1\n\tlocal n = 0\n\tlocal start = i\n\tlocal sstart = 1\n\
    \twhile true do\n\t\tstart, sstart = string.find(string, substring, start, true)\n\
    \t\tif not start then\n\t\t\tbreak\n\t\tend\n\t\ti = start + 1\n\t\tn = n + 1\n\
    \tend\n\treturn n\nend", "\tlocal n = 0\n\tfor i = 1, string.len(string) do\n\t\
    \tif string.sub(string, i, i + string.len(substring) - 1) == substring then\n\t\
    \t\tn = n + 1\n\t\tend\n\tend\n\treturn n\nend", "    local from = 1\n    local\
    \ times = 0\n    local start, finish = string.find(string, substring, from)\n\
    \    while start do\n        from = finish + 1\n        times = times + 1\n  \
    \      start, finish = string.find(string, substring, from)\n    end\n    return\
    \ times\nend", "\tlocal how_many = 0\n\tlocal start = 1\n\t\n\twhile true do\n\
    \t\tlocal found = string.find(string, substring, start, true)\n\t\tif found then\n\
    \t\t\thow_many = how_many + 1\n\t\t\tstart = found + 1\n\t\telse\n\t\t\tbreak\n\
    \t\tend\n\tend\n\t\n\treturn how_many\nend", "\tlocal result = {}\n\tlocal i =\
    \ 0\n\trepeat\n\t\ti = string.find(string, substring, i + 1, true)\n\t\tif i then\
    \ table.insert(result, i) end\n\tuntil not i\n\treturn #result\nend", "    local\
    \ count = 0\n    local start_pos = 1\n    while true do\n        local start_pos,\
    \ end_pos = string.find(string, substring, start_pos)\n        if start_pos then\n\
    \            count = count + 1\n            start_pos = end_pos + 1\n        else\n\
    \            break\n        end\n    end\n    return count\nend", "    local matches\
    \ = 0\n    for i=1, string.len(string) do\n        local sub_idx = string.find(string,\
    \ substring, i, true)\n        if sub_idx ~= nil then\n            matches = matches\
    \ + 1\n            i = sub_idx + 1\n        else\n            break\n        end\n\
    \    end\n    return matches\nend", "\tif string == nil or substring == nil then\n\
    \t\treturn 0\n\tend\n\t\n\tlocal n_times = 0\n\tlocal start_index = 0\n\tlocal\
    \ i = 0\n\twhile true do\n\t\ti = string.find(string, substring, start_index,\
    \ true)\n\t\tif i == nil then\n\t\t\tbreak\n\t\tend\n\t\tn_times = n_times + 1\n\
    \t\tstart_index = i + 1\n\tend\n\treturn n_times\nend", "\t--local substring =\
    \ substring\n\tlocal times = 0\n\tlocal curPos = 1\n\twhile curPos <= #string\
    \ do\n\t\tlocal findPos = string.find(string, substring, curPos)\n\t\tif findPos\
    \ == nil then\n\t\t\tbreak\n\t\tend\n\t\ttimes = times + 1\n\t\tcurPos = findPos\
    \ + 1\n\tend\n\treturn times\nend", "\tassert(type(string) == \"string\", \"input\
    \ string is not a string\")\n\tassert(type(substring) == \"string\", \"input substring\
    \ is not a string\")\n\tif substring == \"\" then return #string + 1 end", "\t\
    local count = 0\n\tlocal i = 1\n\twhile true do\n\t\tlocal start_index, end_index\
    \ = string.find(string, substring, i)\n\t\tif not start_index then\n\t\t\tbreak\n\
    \t\tend\n\t\tcount = count + 1\n\t\ti = end_index + 1\n\tend\n\treturn count\n\
    end", "  local i = 0\n  local count = 0\n  while true do\n    i = string.find(string,\
    \ substring, i + 1, true)\n    if i == nil then\n      break\n    end\n    count\
    \ = count + 1\n  end\n  return count\nend", "    local count = 0\n    for i =\
    \ 1, string.len(string) do\n        if string.sub(string, i, i + string.len(substring)\
    \ - 1) == substring then\n            count = count + 1\n        end\n    end\n\
    \    return count\nend", "\tif #substring == 0 then return 0 end\n\tlocal count\
    \ = 0\n\tfor index = 1, #string - #substring + 1 do\n\t\tlocal sub = string:sub(index,\
    \ index + #substring - 1)\n\t\tif sub == substring then\n\t\t\tcount = count +\
    \ 1\n\t\tend\n\tend\n\treturn count\nend", "    local count = 0\n    local index\
    \ = 1\n    local len = #substring\n    while index <= #string do\n        local\
    \ i, j = string:find(substring, index, true)\n        if i then\n            count\
    \ = count + 1\n            index = j + 1\n        else\n            break\n  \
    \      end\n    end\n    return count\nend", "  local sub_start = 1\n  local count\
    \ = 0\n  while true do\n    local sub_end = string:find(substring, sub_start,\
    \ true)\n    if not sub_end then break end\n    count = count + 1\n    sub_start\
    \ = sub_end + 1\n  end\n  return count\nend", "    local count = 0\n    local\
    \ start = 1\n    while true do\n        start = string.find(string, substring,\
    \ start, true)\n        if start == nil then break end\n        count = count\
    \ + 1\n        start = start + 1\n    end\n    return count\nend", "    local\
    \ i = 0\n    local j = 0\n    local count = 0\n    while true do\n        i =\
    \ string.find(string, substring, i + 1, true)\n        if i == nil then\n    \
    \        break\n        end\n        j = j + 1\n        count = count + 1\n  \
    \  end\n    return count\nend", "\tlocal count = 0\n\tlocal start = 1\n\twhile\
    \ true do\n\t\tlocal pos = string:find(substring, start, true)\n\t\tif not pos\
    \ then\n\t\t\tbreak\n\t\tend\n\t\tcount = count + 1\n\t\tstart = pos + 1\n\tend\n\
    \treturn count\nend", "  if string == nil or substring == nil then return nil\
    \ end\n  local case = nil\n  local count = 0\n  local start = 0\n  repeat\n  \
    \  case = string.find(string, substring, start, true)\n    if case ~= nil then\n\
    \      count = count + 1\n      start = case + 1\n    end\n  until case == nil\n\
    \  return count\nend", "    local string_len, substring_len = #string, #substring\n\
    \    local acc = 0\n    local step = substring_len + 1\n    for i = 1, string_len\
    \ - substring_len + 1 do\n        if string:sub(i, i + substring_len - 1) == substring\
    \ then\n            acc = acc + 1\n        end\n    end\n    return acc\nend",
  "\tlocal string_length = #string\n\tlocal substring_length = #substring\n\tlocal\
    \ times = 0\n\tfor i = 1, string_length - substring_length + 1 do\n\t\tif string:sub(i,\
    \ i + substring_length - 1) == substring then\n\t\t\ttimes = times + 1\n\t\tend\n\
    \tend\n\treturn times\nend", "\tlocal times = 0\n\tfor i in string:gmatch(substring)\
    \ do\n\t\ttimes = times + 1\n\tend\n\treturn times\nend", "\tlocal l_string, l_substring\
    \ = string:len(), substring:len()\n\tlocal m, i, j = 0, 1, 1\n\twhile i <= l_string\
    \ do\n\t\tj = 1\n\t\twhile j <= l_substring do\n\t\t\tif string:sub(i, i + j -\
    \ 1) == substring:sub(1, j) then\n\t\t\t\tj = j + 1\n\t\t\telse\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\tend\n\t\tif j > l_substring then\n\t\t\tm = m + 1\n\t\t\ti = i\
    \ + j - 1\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn m\nend", "\tif string == nil\
    \ or substring == nil then\n\t\treturn 0\n\tend\n\tlocal string, substring = string,\
    \ substring\n\tif string:find(substring) == nil then\n\t\treturn 0\n\tend\n\t\
    local count = 0\n\tfor i in string:gmatch(substring) do\n\t\tcount = count + 1\n\
    \tend\n\treturn count\nend", "    local result = 0\n    local index = 0\n    while\
    \ true do\n        index = string:find(substring, index + 1)\n        if index\
    \ == nil then\n            break\n        end\n        result = result + 1\n \
    \   end\n    return result\nend", "\tlocal count = 0\n\tlocal index = 0\n\twhile\
    \ true do\n\t\tindex = string:find(substring, index + 1)\n\t\tif index == nil\
    \ then break end\n\t\tcount = count + 1\n\tend\n\treturn count\nend", "    if\
    \ substring == '' then return nil end\n    local _, count = string:gsub(substring,\
    \ '')\n    return count\nend", "    local times = 0\n    local search_start =\
    \ 1\n    repeat\n        local search_end = string:find(substring, search_start,\
    \ true)\n        if search_end then\n            times = times + 1\n         \
    \   search_start = search_end + 1\n        end\n    until not search_end\n   \
    \ return times\nend", "  local sublen = substring:len()\n  local count = 0\n \
    \ local start = 1\n  while true do\n    local pos = string:find(substring, start,\
    \ true)\n    if not pos then\n      break\n    end\n    count = count + 1\n  \
    \  start = pos + sublen\n  end\n  return count\nend", "\tlocal i, l = 0, string.len(substring)\n\
    \tlocal times = 0\n\trepeat\n\t\ti = string.find(string, substring, i+1, true)\n\
    \t\tif i then\n\t\t\ttimes = times + 1\n\t\tend\n\tuntil not i\n\treturn times\n\
    end", "\tlocal len = string.len(substring)\n\tlocal total = 0\n\tlocal cpos =\
    \ 0\n\tlocal spos = string.find(string, substring, cpos, true)\n\twhile spos do\n\
    \t\ttotal = total + 1\n\t\tcpos = spos + len\n\t\tspos = string.find(string, substring,\
    \ cpos, true)\n\tend\n\treturn total\nend", "\tlocal times = 0\n\tlocal pos =\
    \ string.find(string, substring, 1, true)\n\twhile pos do\n\t\ttimes = times +\
    \ 1\n\t\tpos = string.find(string, substring, pos + 1, true)\n\tend\n\treturn\
    \ times\nend", "\tlocal i, j = 0, 0\n\tlocal result = 0\n\twhile true do\n\t\t\
    i, j = string.find(string, substring, j + 1, true)\n\t\tif not i then break end\n\
    \t\tresult = result + 1\n\tend\n\treturn result\nend", "\tlocal count = 0\n\t\
    local start_from = 1\n\twhile true do\n\t\tlocal start, finish = string.find(string,\
    \ substring, start_from)\n\t\tif start == nil then break end\n\t\tstart_from =\
    \ finish + 1\n\t\tcount = count + 1\n\tend\n\treturn count\nend", "\tlocal substring_len\
    \ = #substring\n\tlocal how_many = 0\n\tlocal index = 0\n\twhile true do\n\t\t\
    local next_index = string:find(substring, index+1, true)\n\t\tif next_index then\n\
    \t\t\thow_many = how_many + 1\n\t\t\tindex = next_index\n\t\telse\n\t\t\tbreak\n\
    \t\tend\n\tend\n\treturn how_many\nend", "    local n = 0\n    local position\
    \ = 1\n    while true do\n        local found_at = string.find(string, substring,\
    \ position, true)\n        if not found_at then\n            break\n        end\n\
    \        n = n + 1\n        position = found_at + 1\n    end\n    return n\nend",
  "    local count = 0\n    for i = 1, string.len(string) do\n        if string.sub(string,\
    \ i, i + string.len(substring) - 1) == substring then\n            count = count\
    \ + 1\n        end\n    end\n    return count\nend", "\tlocal n = string.gsub(string,\
    \ substring, \"\")\n\tlocal o = string.len(string) - string.len(n)\n\treturn o\n\
    end", "    local count = 0\n    for i = 1, #string - #substring + 1 do\n     \
    \   if string:sub(i, i + #substring - 1) == substring then\n            count\
    \ = count + 1\n        end\n    end\n    return count\nend", "  local n = 0\n\
    \  local i = 1\n  local s = 1\n  local e = #substring\n  local last_end = #string\
    \ - #substring + 1\n  while i < last_end do\n    if string:sub(i, e) == substring\
    \ then\n      n = n + 1\n      i = i + 1\n      e = e + 1\n    else\n      i =\
    \ i + 1\n      e = e + 1\n    end\n  end\n  return n\nend", "    local times =\
    \ 0\n    if type(string) ~= \"string\" or type(substring) ~= \"string\" then\n\
    \        return 0\n    end\n    local start = string.find(string, substring)\n\
    \    while start do\n        times = times + 1\n        start = string.find(string,\
    \ substring, start + 1)\n    end\n    return times\nend", "  local count = 0\n\
    \  local pos = 0\n  while true do\n    pos = string:find(substring, pos + 1)\n\
    \    if not pos then break end\n    count = count + 1\n  end\n  return count\n\
    end", "    local s, e, count = 1, 1, 0\n    local length_string = string.len(string)\n\
    \    local length_substring = string.len(substring)\n    while s <= length_string\
    \ do\n        local start, finish = string.find(string, substring, s, true)\n\
    \        if not start then\n            break\n        end\n        s = finish\
    \ + 1\n        count = count + 1\n    end\n    return count\nend", "    if string.find(string,\
    \ substring) == nil then\n        return 0\n    end\n    local count = 0\n   \
    \ while true do\n        local _, last = string.find(string, substring)\n    \
    \    if last == nil then\n            break\n        end\n        count = count\
    \ + 1\n        string = string.sub(string, last+1)\n    end\n    return count\n\
    end", "  local count = 0\n  local index = 1\n  while index <= #string do\n   \
    \ local next_index = string:find(substring, index, true)\n    if next_index then\n\
    \      count = count + 1\n      index = next_index + 1\n    else\n      break\n\
    \    end\n  end\n  return count\nend", "    local count = 0\n    local i = 0\n\
    \    while true do\n        i = string.find(string, substring, i + 1, true)\n\
    \        if i == nil then\n            break\n        end\n        count = count\
    \ + 1\n    end\n    return count\nend", "    local num = 0\n    for i in string.gmatch(string,\
    \ substring) do\n        num = num + 1\n    end\n    return num\nend", "    local\
    \ _, count = string:gsub(substring, \"\")\n    return count\nend", "\tlocal counter\
    \ = 0\n\tlocal start = 1\n\twhile true do\n\t\tlocal pos = string:find(substring,\
    \ start, true)\n\t\tif not pos then break end\n\t\tcounter = counter + 1\n\t\t\
    start = pos + 1\n\tend\n\treturn counter\nend", "    local count = 0\n    local\
    \ start_from = 1\n    while (true) do\n        local position = string.find(string,\
    \ substring, start_from)\n        if position == nil then break end\n        count\
    \ = count + 1\n        start_from = position + 1\n    end\n    return count\n\
    end", "  local count = 0\n  local index = 0\n  while true do\n    index = string:find(substring,\
    \ index+1)\n    if index == nil then\n      break\n    end\n    count = count\
    \ + 1\n  end\n  return count\nend", "\tlocal n = 0\n\tlocal from = 1\n\trepeat\n\
    \t\tfrom = string:find(substring, from, true)\n\t\tif from then\n\t\t\tn = n +\
    \ 1\n\t\t\tfrom = from + 1\n\t\tend\n\tuntil not from\n\treturn n\nend", "  local\
    \ count = 0\n  for i in string.gmatch(string, substring) do\n    count = count\
    \ + 1\n  end\n  return count\nend", "  -- Use only the part of the string between\
    \ the provided positions.\n  local function string_between(string, start_position,\
    \ end_position)\n    return string:sub(start_position, end_position)\n  end",
  "\tlocal count = 0\n\tlocal from = 1\n\tlocal to = 1\n\twhile true do\n\t\tfrom,\
    \ to = string.find(string, substring, from, true)\n\t\tif from ~= nil then\n\t\
    \t\tcount = count + 1\n\t\t\tfrom = to + 1\n\t\telse\n\t\t\tbreak\n\t\tend\n\t\
    end\n\treturn count\nend", "\tlocal count = 0\n\tlocal find = true\n\twhile find\
    \ do\n\t\tfind = string:find(substring, 1, true)\n\t\tif find then\n\t\t\tcount\
    \ = count + 1\n\t\t\tstring = string:sub(find + 1)\n\t\tend\n\tend\n\treturn count\n\
    end", "  local count = 0\n  local len = string.len(substring)\n  local p = 0\n\
    \  repeat\n    p = string.find(string, substring, p + 1)\n    if p ~= nil then\n\
    \      count = count + 1\n    end\n  until p == nil\n  return count\nend", " \
    \   local times = 0\n    local pos = string.find(string, substring, 1, true)\n\
    \    while pos do\n        times = times + 1\n        pos = string.find(string,\
    \ substring, pos + 1, true)\n    end\n    return times\nend", "    local from,\
    \ to = 0, string.len(substring)\n    local result = 0\n    while from < string.len(string)\
    \ do\n        from = string.find(string, substring, from + 1, true)\n        if\
    \ from == nil then\n            break\n        end\n        result = result +\
    \ 1\n    end\n    return result\nend", "    local count = 0\n    local s, e =\
    \ string.find(string, substring, 0, true)\n    while s do\n        count = count\
    \ + 1\n        s, e = string.find(string, substring, e + 1, true)\n    end\n \
    \   return count\nend", "\tlocal idx = string.find(string, substring, 1, true)\n\
    \tif not idx then return 0 end\n\tlocal c = 1\n\twhile true do\n\t\tidx = string.find(string,\
    \ substring, idx + 1, true)\n\t\tif not idx then return c end\n\t\tc = c + 1\n\
    \tend\nend", "\tif string == \"\" or substring == \"\" then\n\t\treturn 0\n\t\
    end\n\tlocal count = 0\n\tlocal s, e = string.find(string, substring, 1, true)\n\
    \twhile s do\n\t\tcount = count + 1\n\t\ts, e = string.find(string, substring,\
    \ e + 1, true)\n\tend\n\treturn count\nend", "\tif not string or not substring\
    \ then return 0 end\n\tlocal index = string.find(string, substring, 1, true)\n\
    \tif not index then return 0 end\n\tlocal count = 1\n\twhile index do\n\t\tcount\
    \ = count + 1\n\t\tindex = string.find(string, substring, index + 1, true)\n\t\
    end\n\treturn count\nend", "\tlocal S, sub, c = string, substring, 0\n\tlocal\
    \ i = 1\n\twhile true do\n\t\tlocal start = string.find(S, sub, i, true)\n\t\t\
    if start then\n\t\t\tc = c + 1\n\t\t\ti = start + 1\n\t\telse\n\t\t\tbreak\n\t\
    \tend\n\tend\n\treturn c\nend", "  local target = string:lower()\n  local pattern\
    \ = substring:lower()\n  local count = 0\n  local nextat = 0\n  while true do\n\
    \    nextat = target:find(pattern, nextat+1, true)\n    if nextat == nil then\
    \ break end\n    count = count + 1\n  end\n  return count\nend", "  local i, j\
    \ = 0, 0\n  local count = 0\n  while true do\n    i, j = string.find(string, substring,\
    \ j+1, true)\n    if i == nil then\n      break\n    end\n    count = count +\
    \ 1\n  end\n  return count\nend", "    local i, count = 0, 0\n    local this_time\
    \ = 0\n    for found, j in string.gfind(string, substring) do\n        count =\
    \ count + 1\n        if this_time == 0 then\n            i = j\n        end\n\
    \        this_time = this_time + 1\n    end\n    return count, this_time, i\n\
    end", "\tif not string or not substring then return end\n\tlocal count = 0\n\t\
    for i = 1, string.len(string) do\n\t\tlocal suffix = string.sub(string, i)\n\t\
    \tlocal found = suffix:find(substring)\n\t\tif found ~= nil then\n\t\t\tcount\
    \ = count + 1\n\t\t\ti = i + found\n\t\tend\n\tend\n\treturn count\nend", "\t\
    local p = 0\n\tlocal c = 0\n\tlocal s = #substring\n\twhile true do\n\t\tp = string:find(substring,\
    \ p + 1, true)\n\t\tif not p then\n\t\t\tbreak\n\t\tend\n\t\tc = c + 1\n\tend\n\
    \treturn c\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
