name: HumanEval_65_circular_shift
language: lua
prompt: "-- Circular shift the digits of the integer x, shift the digits right by\
  \ shift\n-- and return the result as a string.\n-- If shift > number of digits,\
  \ return digits reversed.\nlocal function circular_shift(x, shift)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = circular_shift\n\
  \    lu.assertEquals(candidate(100, 2), '001')\n    lu.assertEquals(candidate(12,\
  \ 2), '12')\n    lu.assertEquals(candidate(97, 8), '79')\n    lu.assertEquals(candidate(12,\
  \ 1), '21')\n    lu.assertEquals(candidate(11, 101), '11')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local l = #tostring(x)\n  if l < shift then\n    x = tonumber(reverse(tostring(x)))\n\
    \  else\n    x = tonumber(tostring(x):sub(l - shift + 1, l) .. tostring(x):sub(1,\
    \ l - shift))\n  end\n  return x\nend", "    if shift > 0 then\n        local\
    \ digits = tostring(x)\n        local size = #digits\n        if shift < size\
    \ then\n            return reverse(digits, shift + 1, size) .. reverse(digits,\
    \ 1, shift)\n        else\n            return reverse(digits)\n        end\n \
    \   else\n        return tostring(x)\n    end\nend", "    local d = tostring(x)\n\
    \    local m = #d\n    local ds = {}\n    for i = 1, m do\n        ds[i] = d:sub(i,\
    \ i)\n    end\n    for i = 1, shift do\n        local t = ds[1]\n        for j\
    \ = 1, m-1 do\n            ds[j] = ds[j+1]\n        end\n        ds[m] = t\n \
    \   end\n    return table.concat(ds)\nend", "    -- build table of digits in x,\
    \ then reverse that table\n    local rev_digits = {}\n    for digit in tostring(x):gmatch('.')\
    \ do\n        table.insert(rev_digits, digit)\n    end\n    table.reverse(rev_digits)",
  "    local digits = itoa(x)\n    if shift > #digits then\n        return digits:reverse()\n\
    \    end\n    local circular = digits:sub(1, shift) .. digits:sub(shift + 1)\n\
    \    return circular\nend", "    if shift == 0 then\n        return tostring(x)\n\
    \    end\n    local n = math.floor(math.log10(x)) + 1\n    local y = x\n    if\
    \ shift >= n then\n        y = num.rev_digits(x)\n    else\n        for i = 1,\
    \ shift do\n            y = num.circular_shift_right(y)\n        end\n    end\n\
    \    return tostring(y)\nend", "    if shift >= 0 then\n        shift = shift\
    \ % #tostring(x)\n    else\n        shift = (#tostring(x) - math.abs(shift)) %\
    \ #tostring(x)\n    end\n    local s = string.reverse(tostring(x))\n    return\
    \ string.sub(s, shift + 1) .. string.sub(s, 1, shift)\nend", "    local n = math.floor(math.log10(x))\n\
    \    local d = math.floor(math.pow(10, n))\n    local nd = math.floor(math.pow(10,\
    \ n + 1))\n    local y = x\n    while shift > 0 do\n        y = math.floor(x /\
    \ d) * d + (x % d) * 10\n        if y == x then\n            y = x * 10\n    \
    \        break\n        end\n        x = y\n        shift = shift - 1\n    end\n\
    \    return tostring(y)\nend", "    local s = tostring(x)\n    if shift > #s then\n\
    \        return utils.reverse(s)\n    end\n    s = s .. s\n    return s:sub(#s\
    \ - shift + 1, #s - shift + #s)\nend", "\tlocal s = string.format(\"%0d\", x)\n\
    \tif #s < shift then\n\t\treturn string.reverse(s)\n\tend\n\treturn string.sub(s,\
    \ shift + 1) .. string.sub(s, 1, shift)\nend", "  local string_x = tostring(x)\n\
    \  local N = #string_x\n  shift = shift % N\n  if shift == 0 then\n    return\
    \ string_x\n  elseif shift == 1 then\n    return string_x:sub(N) .. string_x:sub(1,\
    \ N-1)\n  else\n    return string_x:sub(N-shift+1) .. string_x:sub(1, N-shift)\n\
    \  end\nend", "\tlocal digits = tostring(x)\n\tlocal len = #digits\n\tif len <=\
    \ shift then\n\t\treturn digits:reverse()\n\tend\n\tlocal digs = {}\n\tfor i =\
    \ 1, len do\n\t\tdigs[(i + shift - 1) % len + 1] = digits:sub(i, i)\n\tend\n\t\
    return table.concat(digs)\nend", "    local t = {}\n    local y = x\n    local\
    \ n = 0\n    while y > 0 do\n        n = n + 1\n        t[n] = y % 10\n      \
    \  y = (y - t[n]) / 10\n    end\n    if shift > n then\n        y = 0\n      \
    \  for i = n, 1, -1 do\n            y = y * 10 + t[i]\n        end\n        return\
    \ y\n    end\n    shift = shift % n\n    for i = 1, shift do\n        t[n + i]\
    \ = t[i]\n    end\n    for i = 1, n do\n        t[i] = t[i + shift]\n    end\n\
    \    y = 0\n    for i = 1, n do\n        y = y * 10 + t[i]\n    end\n    return\
    \ y\nend", "\tlocal s = tostring(x)\n\tlocal r = string.reverse(s)\n\tlocal l\
    \ = #r\n\tlocal y = string.sub(r, 1, shift) .. string.sub(r, shift + 1, l)\n\t\
    return string.reverse(y)\nend", "    local n = #tostring(x)\n    if n <= shift\
    \ then\n        return string.reverse(tostring(x))\n    end\n    local a = string.sub(tostring(x),\
    \ shift + 1)\n    local b = string.sub(tostring(x), 1, shift)\n    return a ..\
    \ b\nend", "    local x_str = tostring(x)\n    local n = #x_str\n    shift = shift\
    \ % n\n    if shift > 0 then\n        local swap = x_str:sub(n - shift + 1, n)\n\
    \        x_str = x_str:sub(1, n - shift)\n        x_str = swap .. x_str\n    end\n\
    \    return x_str\nend", "    local digits = {}\n    while x > 0 do\n        table.insert(digits,\
    \ x % 10)\n        x = x // 10\n    end\n    local sz = #digits\n    if shift\
    \ >= sz then\n        return table.concat(digits, \"\")\n    end\n    local result\
    \ = {}\n    for i = sz, sz - shift + 1, -1 do\n        table.insert(result, digits[i])\n\
    \    end\n    for i = 1, sz - shift do\n        table.insert(result, digits[i])\n\
    \    end\n    return table.concat(result, \"\")\nend", "    local n = #tostring(x)\n\
    \    shift = shift % n", "  local sx = tostring(x)\n  if sx:len() < shift then\n\
    \    return sx:reverse()\n  end\n  return (sx:sub(shift+1) .. sx:sub(1, shift))\n\
    end", "\tlocal s = tostring(x)\n\tif shift >= #s then\n\t\treturn s:reverse()\n\
    \tend\n\treturn s:sub(shift+1) .. s:sub(1, shift)\nend", "    local digits = digits_of(x)\n\
    \    while shift > 0 do\n        table.insert(digits, 1, table.remove(digits,\
    \ #digits))\n        shift = shift - 1\n    end\n    return digits_to_num(digits)\n\
    end", "    x = tostring(x)\n    shift = shift % #x\n    if shift == 0 then\n \
    \       return x\n    else\n        return x:sub(#x - shift + 1) .. x:sub(1, #x\
    \ - shift)\n    end\nend", "    -- Convert x to a string\n    local str = tostring(x)\n\
    \    -- Reverse the string\n    str = str:reverse()\n    -- Shift the digits\n\
    \    str = str:sub(1, shift) .. str:sub(shift + 1)\n    -- Reverse the string\
    \ again\n    str = str:reverse()\n    -- Return the string as an integer\n   \
    \ return tonumber(str)\nend", "  if shift == 0 then\n    return tostring(x)\n\
    \  end\n  -- Convert number to string\n  local s = tostring(x)\n  -- Reverse string\n\
    \  s = s:reverse()\n  -- Circular shift the string\n  local n = #s\n  if shift\
    \ > n then\n    return s\n  end\n  s = s:sub(1, shift) .. s:sub(shift + 1) ..\
    \ s:sub(1, shift)\n  -- Reverse the string again and return\n  return s:reverse()\n\
    end", "    local x_str = string.format(\"%d\", x)\n    return x_str:sub(x_str:len()\
    \ - shift + 1) .. x_str:sub(1, x_str:len() - shift)\nend", "  local len = (#tostring(x))\
    \ - 1\n  local s = len - shift\n  local c = len\n  return string.reverse(string.sub(string.reverse(tostring(x)),\
    \ 1, s)..string.sub(string.reverse(tostring(x)), c, -1))\nend", "    -- Convert\
    \ x to string\n    local str = tostring(x)\n    local len = #str\n    -- Check\
    \ shift is non-negative\n    if shift < 0 then\n        error('circular_shift\
    \ not defined for negative values')\n    end\n    -- Check for no rotation\n \
    \   if shift == 0 then\n        return str\n    end\n    -- Check for too big\
    \ a shift\n    if shift > len then\n        -- return reversed string\n      \
    \  return str:reverse()\n    end\n    -- Circularly shift the string\n    return\
    \ str:sub(len-shift+1) .. str:sub(1, len-shift)\nend", "    local num_digits =\
    \ #tostring(x)\n    if shift > num_digits then\n        return string.reverse(tostring(x))\n\
    \    end\n    return string.sub(tostring(x), shift + 1) .. string.sub(tostring(x),\
    \ 1, shift)\nend", "\tx = tostring(x)\n\tif #x <= shift then\n\t\treturn x:reverse()\n\
    \tend\n\treturn x:sub(shift + 1) .. x:sub(1, shift)\nend", "  local s = tostring(x)\n\
    \  local n = #s\n  if shift > n then\n    return s:reverse()\n  end\n  return\
    \ (s:sub(n - shift + 1, n) .. s:sub(1, n - shift))\nend", "  local digits = floor(log10(x))\
    \ + 1\n  if shift >= digits then\n    return string.reverse(tostring(x))\n  end\n\
    \  local power = pow(10, shift)\n  local r = x % power\n  local l = floor(x /\
    \ power)\n  return tostring(r) .. tostring(l)\nend", "    local n = tonumber(x)\n\
    \    if n == nil then\n        n = tonumber(x, 16)\n    end\n    if n == nil then\n\
    \        return x\n    end\n    local len = #tostring(n)\n    local result = tostring(n)\n\
    \    if shift == len then\n        return result\n    end\n    if shift > len\
    \ then\n        return string.reverse(result)\n    end\n    result = string.sub(result,\
    \ shift + 1) .. string.sub(result, 1, shift)\n    return result\nend", "  local\
    \ digits = string.split(tostring(x), \"\")\n  local len = #digits\n  if len <=\
    \ shift then\n    return string.reverse(table.concat(digits))\n  end\n  local\
    \ r = {}\n  for i = 1, len do\n    local j = i + shift\n    if j > len then\n\
    \      j = j - len\n    end\n    r[i] = digits[j]\n  end\n  return table.concat(r)\n\
    end", "  local s = tostring(x)\n  local len = #s\n  if shift >= len then\n   \
    \ return string.reverse(s)\n  end\n  local left = string.sub(s, 1, len - shift)\n\
    \  local right = string.sub(s, len - shift + 1, len)\n  return right .. left\n\
    end", "  x = math.floor(x)\n  shift = math.floor(shift)\n  local digits = number_of_digits(x)\n\
    \  if shift > digits then\n    return string.reverse(tostring(x))\n  end\n  shift\
    \ = math.floor(shift)\n  local str = tostring(x)\n  local head = string.sub(str,\
    \ 1, shift)\n  local tail = string.sub(str, shift + 1)\n  return tail .. head\n\
    end", "    local n = 0\n    local d = x\n    while d > 0 do\n        d = math.floor(d\
    \ / 10)\n        n = n + 1\n    end\n    if shift > n then\n        return rev(x)\n\
    \    end\n    local m = math.floor(math.pow(10, n - shift))\n    return string.format(\"\
    %d%d\", x % m, math.floor(x / m))\nend", "  local number = tostring(x)\n  local\
    \ len = #number\n  local d = number:sub(1, shift)\n  return d .. number:sub(shift\
    \ + 1, len) .. d:reverse()\nend", "    local x_str = tostring(x)\n    if shift\
    \ > #x_str then\n        return string.reverse(x_str)\n    end\n    local x_start\
    \ = string.sub(x_str, 1, shift)\n    local x_end = string.sub(x_str, shift + 1)\n\
    \    return x_end .. x_start\nend", "    local digits = {}\n    for i = 1, #x\
    \ do\n        digits[i] = string.sub(x, i, i)\n    end\n    for i = 1, shift do\n\
    \        local d = table.remove(digits, 1)\n        table.insert(digits, d)\n\
    \    end\n    return table.concat(digits)\nend", "  -- get length of the table\n\
    \  local len = #x\n  local y = {}\n  for i = 1, len do\n    -- add shifted number\
    \ to the table, modulo the length\n    y[i] = x[(i + shift) % len + 1]\n  end\n\
    \  return y\nend", "    local digits = tostring(x)\n    local result = string.sub(digits,\
    \ 1 + shift)\n    result = result .. string.sub(digits, 1, shift)\n    return\
    \ result\nend", "\tlocal n = #tostring(x)\n\tif shift >= n then\n\t\treturn string.reverse(tostring(x))\n\
    \tend\n\tlocal left = string.sub(tostring(x), 1, shift)\n\tlocal right = string.sub(tostring(x),\
    \ shift + 1, n)\n\treturn right .. left\nend", "\tlocal str_x = tostring(x)\n\t\
    local digits = string.len(str_x)\n\tshift = shift % digits\n\tif shift == 0 then\n\
    \t\treturn str_x\n\telseif shift > digits then\n\t\treturn string.reverse(str_x)\n\
    \telse\n\t\treturn str_x:sub(digits - shift + 1) .. str_x:sub(1, digits - shift)\n\
    \tend\nend", "\tlocal s = tostring(x)\n\tif shift > #s then\n\t\treturn s:reverse()\n\
    \tend\n\treturn s:sub(shift+1, -1) .. s:sub(1, shift)\nend", "    shift = shift\
    \ % (#tostring(x) + 1)\n    local l, r = string.sub(tostring(x), 1, #tostring(x)\
    \ - shift), string.sub(tostring(x), #tostring(x) - shift + 1)\n    return r ..\
    \ l\nend", "    local digits = x\n    local n = 0\n    while digits > 0 do\n \
    \       local d = digits % 10\n        digits = digits // 10\n        n = n *\
    \ 10 + d\n    end\n    shift = shift % ndigits(x)\n    digits = n\n    while shift\
    \ > 0 do\n        local d = digits % 10\n        digits = digits // 10\n     \
    \   shift = shift - 1\n        n = n * 10 + d\n    end\n    digits = n\n    local\
    \ s = ''\n    while digits > 0 do\n        local d = digits % 10\n        digits\
    \ = digits // 10\n        s = s .. tostring(d)\n    end\n    return s\nend", " \
    \   if shift > 0 then\n        return\n            tostring(x):sub(shift + 1)\
    \ ..\n            tostring(x):sub(1, shift)\n    else\n        return\n      \
    \      tostring(x):reverse():sub(-shift + 1) ..\n            tostring(x):reverse():sub(1,\
    \ -shift - 1)\n    end\nend", "\tif shift == 0 then\n\t\treturn tostring(x)\n\t\
    end\n\tlocal n = floor(log10(x) + 1)\n\tif shift >= n then\n\t\treturn string.reverse(tostring(x))\n\
    \tend\n\tlocal prefix = floor(x / 10^shift)\n\tlocal suffix = x % 10^shift\n\t\
    return tostring(suffix) .. tostring(prefix)\nend", "    local len = string.len(x)\n\
    \    local shift = shift % len\n    return string.sub(x, shift + 1, len) .. string.sub(x,\
    \ 1, shift)\nend", "    local s = tostring(x)\n    local n = #s\n    local end_of_string\
    \ = s:sub(n - shift + 1, n)\n    s = s:sub(1, n - shift)\n    return end_of_string\
    \ .. s\nend", "    local digits = tostring(x)\n    local shift = shift % #digits\n\
    \    return digits:sub(shift + 1) .. digits:sub(1, shift)\nend", "\tlocal n =\
    \ select(2, math.frexp(x))\n\tshift = shift % n\n\tif shift > 0 then\n\t\tlocal\
    \ lo = math.ldexp(x, shift)\n\t\tlo = math.floor(lo)\n\t\tlocal hi = math.ldexp(x,\
    \ -(n - shift))\n\t\thi = math.floor(hi)\n\t\treturn tostring(lo) .. tostring(hi)\n\
    \telse\n\t\treturn tostring(x)\n\tend\nend", "\tlocal string_num = tostring(x)\n\
    \tlocal len = string.len(string_num)\n\tshift = shift % len\n\tif shift == 0 then\n\
    \t\treturn string_num\n\tend\n\tlocal left = string.sub(string_num, len - shift\
    \ + 1, len)\n\tlocal right = string.sub(string_num, 1, len - shift)\n\treturn\
    \ left .. right\nend", "    if shift > string.len(x) then\n        return string.reverse(x)\n\
    \    end\n    return string.sub(x, shift + 1) .. string.sub(x, 1, shift)\nend",
  "    local t = { }\n    while x > 0 do\n        table.insert(t, 1, math.floor(x\
    \ % 10))\n        x = math.floor(x / 10)\n    end\n    if shift > #t then\n  \
    \      shift = #t\n    end\n    while shift > 0 do\n        table.insert(t, 1,\
    \ table.remove(t, #t))\n        shift = shift - 1\n    end\n    return table.concat(t)\n\
    end", "\tlocal count = #tostring(x)\n\tshift = shift % count\n\tif shift == 0\
    \ then\n\t\treturn tostring(x)\n\tend\n\tlocal s = tostring(x)\n\tlocal s1 = s:sub(1,\
    \ shift)\n\tlocal s2 = s:sub(shift + 1)\n\tlocal rs = s2 .. s1\n\treturn rs\n\
    end", "    local n = tostring(x)\n    local ln = #n\n    if ln < shift then return\
    \ string.reverse(n) end\n    return string.sub(n, shift+1, ln) .. string.sub(n,\
    \ 1, shift)\nend", "    if x < 10 then\n        return tostring(x)\n    end\n\
    \    local str = tostring(x)\n    local result = \"\"\n    for i = 1, #str do\n\
    \        local d = str:sub(i, i)\n        result = result .. d\n    end\n    result\
    \ = string.sub(result, -shift + 1) .. string.sub(result, 1, -shift)\n    return\
    \ result\nend", "    local d = number_of_digits(x)\n    if d == 0 then\n     \
    \   return \"\"\n    end\n    shift = shift % d\n    if shift == 0 then\n    \
    \    return x\n    end\n    local function f(x, acc)\n        if x == 0 then\n\
    \            return acc\n        end\n        local q, r = floor(x / 10), x %\
    \ 10\n        acc = concat({r, acc})\n        return f(q, acc)\n    end\n    local\
    \ s = f(x, \"\")\n    return sub(s, -shift) .. sub(s, 1, -shift - 1)\nend", " \
    \ local s = tostring(x)\n  shift = shift % #s\n  return s:sub(#s - shift + 1)\
    \ .. s:sub(1, #s - shift)\nend", "    local s = tostring(x)\n    local slen =\
    \ s:len()\n    shift = shift % slen\n    local head = s:sub(1, shift)\n    local\
    \ tail = s:sub(shift + 1, slen)\n    return tail .. head\nend", "  local val =\
    \ x\n  local out = {}\n  local i = 0\n  while val > 0 do\n    out[#out + 1] =\
    \ val % 10\n    val = math.floor(val / 10)\n    i = i + 1\n  end\n  while i <\
    \ shift do\n    out[#out + 1] = out[1]\n    table.remove(out, 1)\n    i = i +\
    \ 1\n  end\n  val = 0\n  for _, v in ipairs(out) do\n    val = val * 10 + v\n\
    \  end\n  return val\nend", "\tlocal d = math.ceil(math.log10(x))\n\tx = math.floor(x/10^(d-shift))\
    \ + 10^shift*math.floor(x%10^(d-shift))\n\treturn tostring(x)\nend", "    local\
    \ s = tostring(x)\n    local slen = #s\n    if slen <= shift then\n        return\
    \ s:reverse()\n    end\n    local hlen = slen - shift\n    local h = s:sub(1,\
    \ hlen)\n    local t = s:sub(hlen + 1)\n    return t .. h\nend", "  local s =\
    \ tostring(x)\n  local n = #s\n  if shift > n then\n    return string.reverse(s)\n\
    \  end\n  local r = string.sub(s, shift + 1, n)\n  for i = 1, shift do\n    r\
    \ = r .. string.sub(s, i, i)\n  end\n  return r\nend", "\tlocal n = floor(log10(x))\
    \ + 1\n\tlocal p = n - shift\n\treturn tostring(x%pow(10,p) * pow(10,n-p) + floor(x/pow(10,p)))\n\
    end", "    if shift == 0 then\n        return tostring(x)\n    end\n    local\
    \ len = math.ceil(math.log10(x))\n    local reverse = tostring(x):reverse()\n\
    \    if shift >= len then\n        return reverse\n    end\n    local shifted\
    \ = reverse:sub(1, shift) .. reverse:sub(shift + 1)\n    return shifted:reverse()\n\
    end", "\tlocal s = string.reverse(math.tointeger(x))\n\tlocal res = ''\n\tfor\
    \ i = 1, #s do\n\t\tres = res .. s:sub(i + shift, i + shift)\n\tend\n\tif shift\
    \ > #s then\n\t\treturn res\n\tend\n\treturn res:sub(1, #s - shift) .. s:sub(1,\
    \ shift)\nend", "    local s = \"\"\n    local digits = 0\n    local shifted =\
    \ x", "    local n = math.floor(math.log10(x))\n    local digits = {}\n    for\
    \ i = n, 0, -1 do\n        digits[i+1] = math.floor(x / 10^i) % 10\n    end\n\
    \    for i = 0, n do\n        local y = i + shift\n        if y <= n then\n  \
    \          digits[y+1] = digits[i+1]\n        else\n            digits[i+1] =\
    \ digits[y-n]\n        end\n    end\n    local y = 0\n    for i = 0, n do\n  \
    \      y = y + digits[i+1] * 10^i\n    end\n    return y\nend", "\tif shift ==\
    \ 0 then\n\t\treturn x\n\tend\n\tlocal str = tostring(x)\n\tshift = shift % #str\n\
    \tlocal x1 = str:sub(1, #str - shift)\n\tlocal x2 = str:sub(#str - shift + 1)\n\
    \treturn x2 .. x1\nend", "  if shift > x then\n    shift = shift - math.floor(shift\
    \ / x) * x\n  end\n  local t = {}\n  while x > 0 do\n    table.insert(t, 1, x\
    \ % 10)\n    x = math.floor(x / 10)\n  end\n  local n = #t\n  if shift == 0 or\
    \ n == 0 then\n    return table.concat(t)\n  end\n  local s = {}\n  for i = shift,\
    \ n do\n    s[#s + 1] = t[i]\n  end\n  for i = 1, shift - 1 do\n    s[#s + 1]\
    \ = t[i]\n  end\n  return table.concat(s)\nend", "    local s = string.format(\"\
    %d\", x)\n    if shift > #s then\n        return string.reverse(s)\n    end\n\
    \    local x1 = string.sub(s, 1, #s - shift)\n    local x2 = string.sub(s, #s\
    \ - shift + 1, #s)\n    return x2 .. x1\nend", "    local n = math.ceil(math.log10(x))\n\
    \    if shift > n then\n        return string.reverse(tostring(x))\n    end\n\
    \    local shift_str = string.sub(tostring(x), 1, shift)\n    local rest_str =\
    \ string.sub(tostring(x), shift + 1)\n    return rest_str .. shift_str\nend",
  "\tif shift == 0 then\n\t\treturn x\n\tend\n\tlocal n = x:len()\n\tif shift >= n\
    \ then\n\t\treturn x:reverse()\n\tend\n\treturn x:sub(n-shift+1) .. x:sub(1, n-shift)\n\
    end", "    if x < 10 then\n        return tostring(x)\n    end\n    x = tostring(x)\n\
    \    local len = string.len(x)\n    local i = (len - shift) % len\n    return\
    \ table.concat(\n        {\n            string.sub(x, i + 1),\n            string.sub(x,\
    \ 1, i)\n        },\n        \"\"\n    )\nend", "    local digits = math.floor(math.log10(x))\
    \ + 1\n    local y = x\n    for i = 1, shift do\n        local least_sig = y %\
    \ 10\n        y = y - least_sig\n        y = y / 10\n        y = y + least_sig\
    \ * 10 ^ digits\n    end\n    return tostring(y)\nend", "    shift = shift % #tostring(x)\n\
    \    return (\"%s%s\"):format(tostring(x):sub(1-shift), tostring(x):sub(1, -shift-1))\n\
    end", "\tlocal a = {}\n\tfor i = 1, #x do\n\t\ta[i] = x:sub(i, i)\n\tend\n\tlocal\
    \ str = {}\n\tfor i = 1, #a do\n\t\tstr[i] = a[i - shift] or a[#a - shift + i]\n\
    \tend\n\treturn table.concat(str)\nend", "  local str = string.format(\"%d\",\
    \ x)\n  local len = string.len(str)\n  local res = string.sub(str, 1, len - shift)\n\
    \  res = res .. string.reverse(string.sub(str, len - shift + 1, len))\n  return\
    \ string.reverse(res)\nend", "    local x_len = strlen(x)\n    if x_len == 0 then\n\
    \        return \"\"\n    end\n    if shift > x_len then\n        return reverse(x)\n\
    \    end\n    local fwd = sub(x, shift)\n    local rev = reverse(sub(x, 1, shift\
    \ - 1))\n    return fwd .. rev\nend", "    local s = tostring(x)\n    local n\
    \ = #s\n    if shift >= n then\n        return string.reverse(s)\n    end\n  \
    \  local a = string.sub(s, 1, shift)\n    local b = string.sub(s, shift + 1, n)\n\
    \    return b .. a\nend", "  local n = tostring(x)\n  return n:sub(1 + shift)\
    \ .. n:sub(1, shift)\nend", "  local str = tostring(x)\n  local len = #str\n \
    \ if shift > len then return str:reverse() end\n  local head = str:sub(1, shift)\n\
    \  local tail = str:sub(shift + 1, len)\n  return tail .. head\nend", "    local\
    \ t, s = {}\n    while x > 0 do\n        table.insert(t, 1, x % 10)\n        x\
    \ = (x - x % 10) / 10\n    end\n    s = #t\n    if shift > s then\n        return\
    \ table.concat(t)\n    end\n    local shifted = {}\n    for i = 1, s do\n    \
    \    shifted[i] = t[(i + shift - 1) % s + 1]\n    end\n    return table.concat(shifted)\n\
    end", "\tlocal sx = tostring(x)\n\tlocal n = string.len(sx)\n\tif shift >= n then\n\
    \t\treturn string.reverse(sx)\n\tend\n\tlocal s1 = string.sub(sx, 1, shift)\n\t\
    local s2 = string.sub(sx, shift + 1, n)\n\treturn s2 .. s1\nend", "  local digits\
    \ = tostring(x)\n  if shift > #digits then\n    return digits:reverse()\n  end\n\
    \  return digits:sub(#digits - shift + 1) .. digits:sub(1, #digits - shift)\n\
    end", "  local l = strlen(x)\n  local s = l - shift\n  if s > 0 then\n    return\
    \ sub(x, s + 1) .. sub(x, 1, s)\n  else\n    return reverse(x)\n  end\nend", " \
    \   local d = #tostring(x)\n    local y = (x / 10^(d - shift)):floor() % 10^d\n\
    \    return tostring(y)\nend", "    local digits = tostring(x)\n    local ndigits\
    \ = #digits\n    local shift_p = shift > ndigits and ndigits or shift\n    local\
    \ rest = digits:sub(ndigits - shift_p + 1, ndigits)\n    local prefix = digits:sub(1,\
    \ ndigits - shift_p)\n    return rest .. prefix\nend", "\tlocal s = tostring(x)\n\
    \tlocal t = {}\n\tfor i = 1, #s do\n\t\tlocal c = s:sub(i, i)\n\t\tt[#t + 1] =\
    \ c\n\tend\n\tfor i = 1, shift do\n\t\tlocal c = table.remove(t, 1)\n\t\tt[#t\
    \ + 1] = c\n\tend\n\treturn table.concat(t)\nend", "    -- Shift x right by shift.\n\
    \    local y = math.floor(x / 10^shift)\n    -- Get the lower shift digits of\
    \ x.\n    local z = x % 10^shift\n    -- Return the shifted digits as a string.\n\
    \    return tostring(z) .. tostring(y)\nend", "\tlocal res = {}\n\tfor i = 1,\
    \ #x do\n\t\tres[i] = x[i]\n\tend\n\tfor i = 1, shift do\n\t\tlocal tmp = res[1]\n\
    \t\tfor j = 1, #res-1 do\n\t\t\tres[j] = res[j+1]\n\t\tend\n\t\tres[#res] = tmp\n\
    \tend\n\treturn res\nend", "    if shift == 0 then\n        return tostring(x)\n\
    \    end\n    local digits = tostring(x)\n    local count = #digits\n    while\
    \ shift > count do\n        shift = shift - count\n    end\n    local shifted\
    \ = string.sub(digits, 1, shift)\n    local remaining = string.sub(digits, shift\
    \ + 1)\n    return remaining .. shifted\nend", "\tlocal s = tostring(x)\n\tlocal\
    \ len = #s\n\tif shift >= len then\n\t\treturn s:reverse()\n\tend\n\tlocal s1\
    \ = s:sub(1, len - shift)\n\tlocal s2 = s:sub(len - shift + 1, len)\n\treturn\
    \ s2 .. s1\nend", "  local n = #tostring(x)\n  if n <= shift then\n    return\
    \ tostring(x):reverse()\n  end\n  return tostring(x):sub(shift + 1) .. tostring(x):sub(1,\
    \ shift)\nend", "  local s = tostring(x)\n  shift = shift % #s\n  return s:sub(shift\
    \ + 1) .. s:sub(1, shift)\nend", "    if x == 0 then\n        return \"0\"\n \
    \   end\n    local str = tostring(x)\n    local len = #str\n    if shift >= len\
    \ then\n        return string.reverse(str)\n    end\n    local s1 = string.sub(str,\
    \ 1, shift)\n    local s2 = string.sub(str, shift + 1, len)\n    return s2 ..\
    \ s1\nend", '    local y = x', "    local str = tostring(x)\n    local len = #str\n\
    \    if shift > len then\n        -- Reverse the digits\n        local rev = string.reverse(str)\n\
    \        local lead = string.sub(rev, 1, shift - len)\n        local tail = string.sub(rev,\
    \ shift - len + 1)\n        return tail .. lead\n    else\n        local lead\
    \ = string.sub(str, 1, len - shift)\n        local tail = string.sub(str, len\
    \ - shift + 1)\n        return tail .. lead\n    end\nend", "    local result\
    \ = tostring(x)\n    for i = 1, shift do\n        local digit = string.sub(result,\
    \ 1, 1)\n        result = string.sub(result, 2) .. digit\n    end\n    return\
    \ result\nend", "    local digits = { }\n    local digits_count = 0\n    local\
    \ r = x\n    while r > 0 do\n        digits_count = digits_count + 1\n       \
    \ digits[digits_count] = r % 10\n        r = (r - digits[digits_count]) / 10\n\
    \    end\n    local n = #digits\n    local result = 0\n    for i = 1, n do\n \
    \       local j = i + shift\n        if j > n then\n            j = j - n\n  \
    \      end\n        result = result * 10 + digits[j]\n    end\n    return result\n\
    end", "\tlocal str = tostring(x)\n\tlocal len = #str\n\tif shift < len then\n\t\
    \treturn (str:sub(shift+1, len) .. str:sub(1, shift))\n\telse\n\t\treturn (str:reverse())\n\
    \tend\nend", "  local digits = tostring(x)\n  local n = string.len(digits)\n \
    \ if n <= shift then\n    return string.reverse(digits)\n  end\n  return string.sub(digits,\
    \ shift + 1, n) .. string.sub(digits, 1, shift)\nend", "  local digits = {}\n\
    \  local num_digits = 1\n  local y = x", "  local n = #tostring(x)\n  if n ==\
    \ 0 then return x end\n  shift = shift % n\n  if shift < 0 then shift = shift\
    \ + n end\n  return (tostring(x):sub(shift+1) .. tostring(x):sub(1, shift))\n\
    end", "    local s = tostring(x)\n    local len = string.len(s)\n    if shift\
    \ > len then return string.reverse(s) end\n    local begin = string.sub(s, len\
    \ - shift + 1)\n    local end = string.sub(s, 1, len - shift)\n    return begin\
    \ .. end\nend", "\tlocal t = {}\n\tfor i = 1, #x do\n\t\tt[i] = x:sub(i, i)\n\t\
    end\n\tfor i = 1, shift do\n\t\tlocal c = table.remove(t, 1)\n\t\ttable.insert(t,\
    \ c)\n\tend\n\treturn table.concat(t)\nend", "    local result = {}\n    local\
    \ digits = 0\n    local m = x\n    while m > 0 do\n        m = math.floor(m /\
    \ 10)\n        digits = digits + 1\n    end\n    for i = 1, digits do\n      \
    \  local d = x % 10\n        if i >= shift then\n            table.insert(result,\
    \ 1, d)\n        else\n            table.insert(result, d)\n        end\n    \
    \    x = math.floor(x / 10)\n    end\n    return table.concat(result)\nend", " \
    \ if shift == 0 then\n    return tostring(x)\n  end\n  local t = {}\n  for d in\
    \ tostring(x):gmatch(\"%d\") do\n    table.insert(t, d)\n  end\n  local n = #t\n\
    \  for i = 1, shift do\n    table.insert(t, 1, table.remove(t, n))\n  end\n  return\
    \ table.concat(t)\nend", "    local n = #tostring(x)\n    local t = {}\n    for\
    \ i = 1, n do\n        t[i] = x % 10\n        x = math.floor(x / 10)\n    end\n\
    \    for i = 1, shift do\n        table.insert(t, 1, table.remove(t))\n    end\n\
    \    local result = {}\n    for i = 1, n do\n        result[i] = t[i]\n    end\n\
    \    return table.concat(result)\nend", "    x = tostring(x)\n    shift = shift\
    \ % #x\n    local rem = x:sub(1, shift)\n    x = x:sub(shift + 1)\n    return\
    \ (x .. rem)\nend", "  local n = 1\n  x = x + math.pow(10, shift)\n  x = tostring(x)\n\
    \  while x:sub(1,1) == \"0\" do\n    x = x:sub(2)\n    n = n + 1\n  end\n  return\
    \ x:sub(n)\nend", "    -- convert x to a string\n    local x_str = tostring(x)\n\
    \    -- convert x to a list and reverse it\n    local x_list = string_to_list(x_str)\n\
    \    x_list = reverse_list(x_list)\n    -- use append_list to rotate it\n    for\
    \ i = 1, shift do\n        x_list = append_list(x_list, remove_element(x_list,\
    \ 1))\n    end\n    x_list = reverse_list(x_list)\n    -- turn it back into a\
    \ string\n    x_str = list_to_string(x_list)\n    return x_str\nend", "    local\
    \ x_digits = int_to_digits(x)\n    local shift_digits = {}\n    for i=1,#x_digits\
    \ do\n        shift_digits[i] = x_digits[#x_digits-i+1]\n    end\n    local shift_str\
    \ = digits_to_str(shift_digits)\n    if (shift > 0) then\n        shift_str =\
    \ shift_str:sub(1, #shift_str-shift)\n    end\n    return shift_str\nend", " \
    \ local s = tostring(x)\n  return (string.reverse(s) .. s):sub(1, #s)\nend", " \
    \ local n = math.floor(math.log10(x))\n  local digits = {}\n  for i = 0, n do\n\
    \    digits[i] = math.floor(x / 10^i) % 10\n  end\n  for i = 1, shift do\n   \
    \ table.insert(digits, 1, table.remove(digits))\n  end\n  local s = \"\"\n  for\
    \ i = 0, n do\n    s = s .. tostring(digits[i])\n  end\n  return s\nend", "  local\
    \ s = tostring(x)\n  local l = #s\n  shift = shift % l\n  return (s:sub(l - shift\
    \ + 1, l) .. s:sub(1, l - shift))\nend", "    local s = tostring(x)\n    local\
    \ strlen = string.len(s)\n    if shift < strlen then\n        return string.sub(s,\
    \ strlen - shift + 1) .. string.sub(s, 1, strlen - shift)\n    else\n        return\
    \ string.reverse(s)\n    end\nend", "\t-- Convert integer to string\n\tx = tostring(x)\n\
    \t-- Allocate new string\n\tlocal r = \"\"\n\t-- Loop through the characters in\
    \ the string\n\tfor i = 1, #x do\n\t\tlocal c = x:sub(i, i)\n\t\t-- Calculate\
    \ index of digit in the string\n\t\tlocal j = i + shift\n\t\t-- If the index is\
    \ greater than the length of the string, subtract the\n\t\t-- string length from\
    \ the index\n\t\twhile j > #x do\n\t\t\tj = j - #x\n\t\tend\n\t\t-- Append character\
    \ to the result string\n\t\tr = r .. c\n\tend\n\t-- Return result string\n\treturn\
    \ r\nend", "    local digits = tostring(x)\n    shift = shift % #digits\n    if\
    \ shift == 0 then\n        return digits\n    else\n        return digits:sub(shift\
    \ + 1) .. digits:sub(1, shift)\n    end\nend", "  -- Count digits\n  local digits\
    \ = 0\n  local rem = x\n  repeat\n    rem = math.floor(rem / 10)\n    digits =\
    \ digits + 1\n  until rem == 0", "    local digits = {}\n    local d = 1\n   \
    \ local y = x\n    local z\n    while y > 0 do\n        y, z = math.floor(y /\
    \ 10), y % 10\n        digits[d] = z\n        d = d + 1\n    end\n    if shift\
    \ > d - 1 then\n        shift = d - 1\n    end\n    local c = table.concat(digits,\
    \ '', 1 + shift, d - 1)\n    local b = table.concat(digits, '', 1, shift)\n  \
    \  return c .. b\nend", "    local size = #tostring(x)\n    if shift > size then\n\
    \        shift = shift % size\n    end\n    local num_str = tostring(x)\n    local\
    \ result = string.sub(num_str, shift+1) .. string.sub(num_str, 1, shift)\n   \
    \ return result\nend", "    local t = { }\n    while x > 0 do\n        table.insert(t,\
    \ 1, x % 10)\n        x = math.floor(x / 10)\n    end\n    if shift >= #t then\n\
    \        return table.concat(t)\n    end\n    for i = 1, shift do\n        table.insert(t,\
    \ 1, table.remove(t))\n    end\n    return table.concat(t)\nend", "  local digit_table\
    \ = {}\n  local shifted_digit_table = {}\n  local num_digits = 0\n  local temp_x\
    \ = x\n  local i = 0\n  while temp_x > 0 do\n    digit_table[i] = temp_x % 10\n\
    \    temp_x = (temp_x - digit_table[i]) / 10\n    num_digits = num_digits + 1\n\
    \    i = i + 1\n  end\n  if shift > num_digits then\n    shift = num_digits\n\
    \  end\n  for i = 0, shift - 1 do\n    shifted_digit_table[i] = digit_table[num_digits\
    \ - shift + i]\n  end\n  for i = shift, num_digits - 1 do\n    shifted_digit_table[i]\
    \ = digit_table[i - shift]\n  end\n  local shifted_x = 0\n  for i = 0, num_digits\
    \ - 1 do\n    shifted_x = shifted_x * 10 + shifted_digit_table[i]\n  end\n  return\
    \ shifted_x\nend", "    local s = tostring(x)\n    local len = #s\n    if shift\
    \ >= len then\n        return string.reverse(s)\n    end\n    local r = string.sub(s,\
    \ shift + 1) .. string.sub(s, 1, shift)\n    return r\nend", "\tlocal digits =\
    \ bit.tobits(x)\n\tdigits = util.lshift(digits, shift)\n\treturn tostring(bit.tonumb(digits))\n\
    end", "  local l = string.len(x)\n  local d = string.sub(x, l - shift + 1, l)\n\
    \  local r = string.sub(x, 1, l - shift)\n  return d .. r\nend", "\tlocal digits\
    \ = {}\n\tlocal n = 0\n\twhile x > 0 do\n\t\tn = n + 1\n\t\tdigits[n] = x % 10\n\
    \t\tx = math.floor(x / 10)\n\tend\n\tlocal digits2 = {}\n\tlocal n2 = 0\n\tfor\
    \ i = 1, n do\n\t\tn2 = n2 + 1\n\t\tdigits2[n2] = digits[(i + shift - 1) % n +\
    \ 1]\n\tend\n\tlocal s = \"\"\n\tfor i = 1, n2 do\n\t\ts = s .. tostring(digits2[i])\n\
    \tend\n\treturn s\nend", "    local xs = string.format(\"%d\", x)\n    local xlen\
    \ = #xs\n    local s = xs\n    if shift < xlen then\n        s = s:sub(xlen -\
    \ shift + 1) .. s:sub(1, xlen - shift)\n    else\n        s = s:reverse()\n  \
    \  end\n    return s\nend", "    if x == 0 then\n        return \"0\"\n    end\n\
    \    local digits = { }\n    for d in (x .. \"\"):gmatch(\".\") do\n        digits[#digits\
    \ + 1] = d\n    end\n    local n = #digits\n    shift = shift % n\n    for i =\
    \ 1, shift do\n        table.insert(digits, 1, table.remove(digits, n))\n    end\n\
    \    return table.concat(digits)\nend", "\tlocal num_digits = #tostring(x)\n\t\
    local s = {}\n\tfor d = 1, num_digits do\n\t\ts[#s + 1] = math.floor(x % 10)\n\
    \t\tx = math.floor(x / 10)\n\tend\n\tfor i = 1, shift do\n\t\tlocal d = table.remove(s,\
    \ 1)\n\t\ts[#s + 1] = d\n\tend\n\tlocal n = 0\n\tfor d = 1, num_digits do\n\t\t\
    n = n * 10 + s[d]\n\tend\n\treturn tostring(n)\nend", "    -- Remove digits less\
    \ than 1\n    local digits = math.floor(math.log10(x))\n    local cshift = x *\
    \ 10^shift\n    local retval = cshift % 10^digits\n    return retval\nend", " \
    \   local n = 0\n    local i = x\n    while i > 0 do\n        i = math.floor(i\
    \ / 10)\n        n = n + 1\n    end\n    if shift > n then\n        x = tostring(x)\n\
    \        x = string.reverse(x)\n        return x\n    end\n    for i = 1, shift\
    \ do\n        x = (x % 10) * 10 ^ (n - 1) + math.floor(x / 10)\n    end\n    return\
    \ x\nend", "    if shift == 0 then\n        return x\n    end\n    local s = tostring(x)\n\
    \    local n = #s\n    if shift > n then\n        return string.reverse(s)\n \
    \   end\n    local d = string.sub(s, n - shift + 1, n)\n    local r = string.sub(s,\
    \ 1, n - shift)\n    return d .. r\nend", "    local x = tostring(x)\n    if #x\
    \ <= shift then\n        return string.reverse(x)\n    end\n    return string.sub(x,\
    \ shift + 1) .. string.sub(x, 1, shift)\nend", "  shift = shift % num_digits(x)\n\
    \  if shift == 0 then return x end\n  local first_digits = math.floor(x / power_of_ten(shift))\n\
    \  local last_digits = x % power_of_ten(shift)\n  return last_digits * power_of_ten(num_digits(first_digits))\
    \ + first_digits\nend", "    if shift == 0 then\n        return tostring(x)\n\
    \    end\n    local n = string.len(tostring(x))\n    if shift >= n then\n    \
    \    return string.reverse(tostring(x))\n    end\n    local res = {}\n    for\
    \ i = 1, n do\n        local j = (i - shift - 1) % n + 1\n        res[j] = string.sub(tostring(x),\
    \ i, i)\n    end\n    return table.concat(res)\nend", "    local result = 0\n\
    \    local number_of_digits = math.floor(math.log10(x)) + 1\n    shift = shift\
    \ % number_of_digits\n    while shift > 0 do\n        local last_digit = x % 10\n\
    \        local shifted_number = x / 10\n        result = result * 10 + last_digit\n\
    \        x = shifted_number\n        shift = shift - 1\n    end\n    if x > 0\
    \ then\n        x = x * 10 ^ number_of_digits\n        result = result + x\n \
    \   end\n    return result\nend", "    local len = string.len(x)\n    local digit\
    \ = math.floor(x % 10)\n    local rem = math.floor(x / 10)\n    local add_num\
    \ = digit * math.pow(10, len)\n    local res = (rem + add_num) * math.pow(10,\
    \ -shift)\n    return string.format(\"%d\", res)\nend", "    local str = tostring(x)\n\
    \    local n = string.len(str)\n    shift = shift % n\n    if shift == 0 then\n\
    \        return str\n    elseif shift < 0 then\n        shift = shift + n\n  \
    \  end\n    return string.sub(str, shift + 1) .. string.sub(str, 1, shift)\nend",
  "\tlocal digits = tostring(x)\n\tlocal ndigits = #digits\n\tshift = math.fmod(shift,\
    \ ndigits)\n\tif shift == 0 then\n\t\treturn digits\n\telseif shift > ndigits/2\
    \ then\n\t\treturn string.reverse(circular_shift(x, ndigits - shift))\n\telse\n\
    \t\treturn string.sub(digits, 1 + shift, ndigits) .. string.sub(digits, 1, shift)\n\
    \tend\nend", "  x = tostring(x)\n  local n = #x\n  if shift > n then\n    return\
    \ reverse(x)\n  end\n  return concat{reverse(sub(x, 1, shift)), reverse(sub(x,\
    \ shift + 1))}\nend", "  local d = 1; -- number of digits in x\n  while (x > math.pow(10,\
    \ d)) do\n    d = d + 1;\n  end\n  if (shift >= d) then\n    return string.reverse(x);\n\
    \  end\n  local r = 0;\n  local i = 0;\n  for i = 1, d do\n    r = r + (math.mod(x,\
    \ 10) * math.pow(10, i-1));\n    x = math.floor(x / 10);\n  end\n  return (r *\
    \ math.pow(10, d-shift)) + x;\nend", "    local n = string.len(x)\n    if shift\
    \ >= n then\n        return string.reverse(x)\n    end\n    local first = string.sub(x,\
    \ 1, shift)\n    local last = string.sub(x, shift + 1, n)\n    return last ..\
    \ first\nend", "  local i, num = 1, tostring(x)\n  local circular = ''\n  while\
    \ i < #num do\n    circular = circular .. string.sub(num, i, i)\n    i = i + 1\n\
    \  end\n  circular = circular .. string.sub(num, i, i)\n  return circular\nend",
  "  if x < 10 then return tostring(x) end\n  local s = tostring(x)\n  local shifted\
    \ = string.sub(s, #s - shift + 1) .. string.sub(s, 1, #s - shift)\n  return shifted\n\
    end", "  local digits = number_to_digits(x)\n  if shift > #digits then\n    --\
    \ Reverse the digits\n    table.sort(digits, function(a, b) return a > b end)\n\
    \  else\n    -- Rotate the digits\n    local temp = {}\n    for i = 1, shift do\n\
    \      temp[i] = digits[i]\n    end\n    for i = 1, #digits - shift do\n     \
    \ digits[i] = digits[i + shift]\n    end\n    for i = 1, shift do\n      digits[#digits\
    \ - shift + i] = temp[i]\n    end\n  end\n  return table.concat(digits)\nend",
  "    local format = string.format('%%0%dd', math.ceil(math.log10(x)))\n    local\
    \ sx = string.format(format, x)\n    local len = string.len(sx)\n    local result\
    \ = ''\n    for i = 0, len - 1 do\n        local j = i + shift\n        if j >=\
    \ len then\n            j = j - len\n        end\n        result = result .. string.sub(sx,\
    \ j + 1, j + 1)\n    end\n    return result\nend", "    x = tostring(x)\n    local\
    \ len = #x\n    if len <= shift then\n        return x:reverse()\n    end\n  \
    \  return (x:sub(len - shift + 1) .. x:sub(1, len - shift)):reverse()\nend", " \
    \ if shift >= length(x) then\n    return reverse(x)\n  end\n  shift = shift %\
    \ length(x)\n  return string.sub(x, shift + 1) .. string.sub(x, 1, shift)\nend",
  "    local digits = get_digits(x)\n    local n = #digits\n    if shift >= n then\n\
    \        return concat(reverse(digits))\n    end\n    local y = {}\n    for i\
    \ = 1, n do\n        y[i] = digits[(i + shift - 1) % n + 1]\n    end\n    return\
    \ concat(y)\nend", "  x = tostring(x)\n  shift = shift % #x\n  return x:sub(shift\
    \ + 1) .. x:sub(1, shift)\nend", "  shift = shift % #x\n  if shift == 0 then return\
    \ x end\n  return x:sub(#x-shift+1) .. x:sub(1, #x-shift)\nend", "  local digits\
    \ = string.reverse(tostring(x))\n  local len = #digits\n  local first = string.sub(digits,\
    \ shift % len + 1)\n  local second = string.sub(digits, 1, shift % len)\n  return\
    \ string.reverse(first .. second)\nend", "  local s = tostring(x)\n  local len\
    \ = #s\n  if shift >= len then\n    return s:reverse()\n  end\n  local prefix\
    \ = s:sub(1, len - shift)\n  local suffix = s:sub(len - shift + 1)\n  return suffix\
    \ .. prefix\nend", "  local y = string.reverse(tostring(x))\n  if shift > string.len(y)\
    \ then\n    return y\n  end\n  return string.sub(y, 1, shift) .. string.sub(y,\
    \ shift + 1)\nend", "  local l = math.floor(math.log10(x)) + 1\n  local s = x\
    \ % 10^shift\n  local n = (x - s)/10^shift\n  return (\"%d%0\"..l..\"d\"):format(s,\
    \ n)\nend", "  local str = tostring(x)\n  local digits = #str\n  if shift > digits\
    \ then\n    return str:reverse()\n  end\n  return (str:sub(digits-shift+1, digits)\
    \ .. str:sub(1, digits-shift))\nend", "    -- shift is the number of digits by\
    \ which the number x is to be\n    -- shifted to the right\n    x = tostring(x)\n\
    \    if shift > #x then\n        -- the number of shifts is greater than the number\
    \ of digits,\n        -- so shift the digits to the right by 1, reverse the digits,\n\
    \        -- and return the result as a string\n        local x1 = x:sub(#x, #x)\n\
    \        local x2 = x:sub(1, #x - 1)\n        return x1 .. x2\n    else\n    \
    \    -- return x shifted by shift as a string\n        local x1 = x:sub(#x - shift\
    \ + 1, #x)\n        local x2 = x:sub(1, #x - shift)\n        return x1 .. x2\n\
    \    end\nend", "    -- Convert the integer x to a string for processing.\n  \
    \  local digits = tostring(x)\n    -- The number of digits in the original integer.\n\
    \    local num_digits = #digits\n    -- Re-initialize the digits array with the\
    \ digit positions shifted.\n    for i = 1, num_digits do\n        digits[i] =\
    \ digits[i + shift] or digits[i + shift - num_digits]\n    end\n    -- Build and\
    \ return the resulting string.\n    return table.concat(digits)\nend", "  local\
    \ str = string.reverse(tostring(x))\n  local len = #str\n  local lshift = len\
    \ - shift\n  if lshift > 0 then\n    local start = string.sub(str, 1, lshift)\n\
    \    local endstr = string.sub(str, lshift + 1, len)\n    str = endstr .. start\n\
    \  end\n  return string.reverse(str)\nend", "    local digits = tostring(x)\n\
    \    local n = #digits\n    if shift > n then\n        return string.reverse(digits)\n\
    \    end\n    local s = string.sub(digits, n - shift + 1, n)\n    local s2 = string.sub(digits,\
    \ 1, n - shift)\n    return s .. s2\nend", "    local s = tostring(x)\n    local\
    \ res = s:sub(1, -1 * shift) .. s:sub(1, shift - 1)\n    return res\nend", "\t\
    local s = tostring(x)\n\treturn string.sub(s, #s - shift + 1) .. string.sub(s,\
    \ 1, #s - shift)\nend", "    local pow = math.floor(math.log10(x)) + 1\n    if\
    \ shift > pow then\n        return (tostring(x)):reverse()\n    end\n    local\
    \ l = x % (10 ^ shift)\n    local r = math.floor(x / (10 ^ shift))\n    return\
    \ tostring(l) .. tostring(r)\nend", "    local y = (\"%d\"):format(x)\n    if\
    \ shift >= y:len() then\n        return y:reverse()\n    end\n    local prefix\
    \ = y:sub(1, -shift - 1)\n    local postfix = y:sub(-shift)\n    return postfix\
    \ .. prefix\nend", "    if not x then return '' end\n    local digits = {}\n \
    \   while x > 0 do\n        table.insert(digits, x % 10)\n        x = math.floor(x\
    \ / 10)\n    end\n    if shift >= #digits then\n        for i = 1, math.floor(shift\
    \ / #digits) do\n            for j = 1, #digits do\n                table.insert(digits,\
    \ digits[j])\n            end\n        end\n    end\n    for i = 1, shift do\n\
    \        table.insert(digits, 1, table.remove(digits))\n    end\n    local result\
    \ = ''\n    for i = 1, #digits do\n        result = result .. tostring(digits[i])\n\
    \    end\n    return result\nend", "  local n = #tostring(x)\n  local s = n -\
    \ shift\n  if shift > n then\n    return string.reverse(tostring(x))\n  else\n\
    \    return string.sub(tostring(x), s + 1) .. string.sub(tostring(x), 1, s)\n\
    \  end\nend", "  local s = tostring(x)\n  local t = #s\n  local y = s\n  shift\
    \ = shift % t\n  if shift > 0 then\n    y = (s:sub(t - shift + 1, t) .. s:sub(1,\
    \ t - shift))\n  end\n  return y\nend", "    if x < 0 then\n        x = -x\n \
    \   end\n    if shift >= 6 then\n        x = int_reverse(x)\n    else\n      \
    \  x = int_rotate(x, shift)\n    end\n    return string.format(\"%06d\", x)\n\
    end", "    local digits = format(\"%d\", x)\n    local size = #digits\n    --\
    \ Return empty string if shift is greater than the number of digits.\n    if shift\
    \ >= size then\n        return \"\"\n    end\n    -- Return the number of digits\
    \ in x if shift is 0.\n    if shift == 0 then\n        return digits\n    end\n\
    \    -- Return the digits of x reversed if shift is less than the number of digits.\n\
    \    if shift < size then\n        return string.reverse(digits)\n    end\n  \
    \  -- Return the digits of x right shifted by 'shift'.\n    return string.sub(digits,\
    \ -shift) .. string.sub(digits, 1, -shift - 1)\nend", "  if shift == 0 then\n\
    \    return x\n  end\n  local len = (#tostring(x))\n  shift = shift % len\n  if\
    \ shift == 0 then\n    return x\n  end\n  local pre = math.floor(x / 10^shift)\n\
    \  local post = x % 10^shift\n  return (post * 10^(len - shift)) + pre\nend",
  "  local digits = x % 10\n  local remaining = math.floor(x / 10)\n  if remaining\
    \ == 0 then\n    return tostring(digits)\n  end\n  for _ = 1, shift do\n    local\
    \ digit = remaining % 10\n    remaining = math.floor(remaining / 10)\n    digits\
    \ = digits * 10 + digit\n    if remaining == 0 then\n      return tostring(digits)\n\
    \    end\n  end\n  return tostring(remaining) .. tostring(digits)\nend", "  local\
    \ digits = {}\n  local n = 0\n  while x ~= 0 do\n    digits[n+1] = x % 10\n  \
    \  x = x // 10\n    n = n + 1\n  end\n  if shift > n then\n    shift = shift %\
    \ n\n  end\n  if shift > 0 then\n    local left = {}\n    for i = 1, shift do\n\
    \      left[i] = digits[i]\n    end\n    for i = 1, n - shift do\n      digits[i]\
    \ = digits[i + shift]\n    end\n    for i = 1, shift do\n      digits[n - shift\
    \ + i] = left[i]\n    end\n  end\n  local s = \"\"\n  for i = 1, n do\n    s =\
    \ s .. string.char(digits[i] + string.byte(\"0\"))\n  end\n  return s\nend", "\t\
    local s = \"\"\n\tlocal n = 0\n\tx = x % (10^shift)\n\twhile (x ~= 0) do\n\t\t\
    s = s .. tostring(x % 10)\n\t\tx = math.floor(x / 10)\n\t\tn = n + 1\n\tend\n\t\
    if (n < shift) then\n\t\ts = s .. (\"0\"):rep(shift - n)\n\tend\n\tlocal r = \"\
    \"\n\twhile (s ~= \"\") do\n\t\tr = r .. s:sub(-1)\n\t\ts = s:sub(1, -2)\n\tend\n\
    \treturn r\nend", "  x = tostring(x)\n  shift = shift % #x\n  return x:sub(#x\
    \ - shift + 1) .. x:sub(1, #x - shift)\nend", "\tif shift == 0 then\n\t\treturn\
    \ tostring(x)\n\tend\n\tlocal digits = tonumber(tostring(x):reverse())\n\tlocal\
    \ mask = 10^shift - 1\n\tdigits = (digits % mask) * 10^(shift - mask + 1) + (digits\
    \ - digits % mask)\n\treturn tostring(digits):reverse()\nend", "  local y = tostring(x)\n\
    \  local n = #y\n  return y:sub(1, shift):reverse() .. y:sub(shift + 1, n)\nend",
  "    local function digit_shift(d, s)\n        return ((d + s) % 10)\n    end\n\
    \    local res = {}\n    local i = 0\n    local s = shift % #x\n    while x[i]\
    \ do\n        table.insert(res, digit_shift(x[i], s))\n        i = i + 1\n   \
    \ end\n    return res\nend", "    local s = tostring(x)\n    local y = string.sub(s,\
    \ shift + 1) .. string.sub(s, 1, shift)\n    return y\nend", "\tlocal l = #tostring(x)\n\
    \tshift = shift % l\n\treturn tostring(x):sub(shift + 1, l) .. tostring(x):sub(1,\
    \ shift)\nend", "    if shift == 0 then\n        return tostring(x)\n    end\n\
    \    local str = tostring(x)\n    local n = #str\n    local m = (shift % n)\n\
    \    return str:sub(m+1) .. str:sub(1, m)\nend", "    if x == 0 then\n       \
    \ return x\n    end\n    local d = math.ceil(math.log10(x))\n    shift = shift\
    \ % d\n    x = math.floor(x / 10 ^ shift)\n    local digit = x % 10\n    x = math.floor(x\
    \ / 10)\n    return tostring(digit) .. x\nend", "    local digits = (x .. \"\"\
    )\n    local len = #digits\n    if shift >= len then\n        return string.reverse(digits)\n\
    \    end\n    return string.sub(digits, shift + 1, len) .. string.sub(digits,\
    \ 1, shift)\nend", "    local xlen = #x\n    if xlen == 0 then\n        return\
    \ x\n    end\n    shift = shift % xlen\n    return x:sub(xlen - shift + 1, xlen)\
    \ .. x:sub(1, xlen - shift)\nend", "    x = tostring(x)\n    local len = #x\n\
    \    shift = shift % len\n    local p1 = string.sub(x, 1, shift)\n    local p2\
    \ = string.sub(x, shift + 1, len)\n    return p2 .. p1\nend", "    local n_digits\
    \ = math.ceil(math.log10(x))\n    if shift > n_digits then\n        return tostring(x):reverse()\n\
    \    end\n    local left = math.floor(x / 10^shift)\n    local right = x % 10^shift\n\
    \    local ln = math.ceil(math.log10(left))\n    return tostring(left * 10^n_digits\
    \ + right)\nend", "\tlocal digits = floor(log10(x)) + 1\n\tif shift >= digits\
    \ then\n\t\treturn string.reverse(tostring(x))\n\tend\n\tlocal x1 = tostring(x)\n\
    \tlocal x2 = string.sub(x1, digits - shift + 1)\n\tlocal x3 = string.sub(x1, 1,\
    \ digits - shift)\n\treturn x2 .. x3\nend", "  local s = tostring(x)\n  local\
    \ len = #s\n  shift = shift % len\n  return string.sub(s, len - shift + 1) ..\
    \ string.sub(s, 1, len - shift)\nend", "\tlocal n = tostring(x)\n\tlocal nlen\
    \ = #n\n\tlocal nlen_left = nlen - shift\n\tlocal nlen_right = shift\n\tif shift\
    \ > nlen then\n\t\tn = string.reverse(n)\n\telse\n\t\tlocal n_left = string.sub(n,\
    \ 1, nlen_left)\n\t\tlocal n_right = string.sub(n, nlen_left + 1, nlen)\n\t\t\
    n = n_right .. n_left\n\tend\n\treturn n\nend", "\tlocal str = tostring(x)\n\t\
    shift = shift % #str\n\treturn str:sub(shift + 1) .. str:sub(1, shift)\nend",
  "\tshift = shift % #x\n\tlocal a = x:sub(1, #x - shift)\n\tlocal b = x:sub(#x -\
    \ shift + 1, #x)\n\treturn b .. a\nend", "    -- Convert to string\n    local\
    \ s = string.format(\"%d\", x)\n    -- Get the length of the string\n    local\
    \ n = string.len(s)\n    -- Copy the string to a buffer so it can be modified.\n\
    \    local buf = string.rep(\" \", n)\n    for i = 1, n do\n        buf[i] = s[i]\n\
    \    end\n    -- Circular shift the string\n    for i = 1, shift do\n        local\
    \ x = buf[n]\n        for j = n, 2, -1 do\n            buf[j] = buf[j - 1]\n \
    \       end\n        buf[1] = x\n    end\n    -- Return the buffer as a string\n\
    \    return string.format(\"%s\", buf)\nend", "\tlocal n = 1;\n\twhile x >= 10^n\
    \ do\n\t\tn = n + 1;\n\tend\n\tlocal result = (x % 10^shift) * 10^(n - shift);\n\
    \treturn tostring(result + math.floor(x / 10^shift));\nend", "\tlocal function\
    \ rev_digits(n)\n\t\tlocal n_rev = 0\n\t\twhile n > 0 do\n\t\t\tn_rev = n_rev\
    \ * 10 + n % 10\n\t\t\tn = math.floor(n / 10)\n\t\tend\n\t\treturn n_rev\n\tend",
  "  -- cache the number of digits of x once\n  local digits = math.floor(math.log10(x))\
    \ + 1\n  if shift >= digits then\n    return string.reverse(tostring(x))\n  end\n\
    \  local rx = x % 10^shift\n  local qx = (x - rx) / 10^shift\n  return rx * 10^(digits\
    \ - shift) + qx\nend", "    local str = tostring(x)\n    local n = #str\n    if\
    \ shift > n then\n        return strrev(str)\n    end\n    local h = strsub(str,\
    \ 1, shift)\n    local t = strsub(str, shift + 1)\n    return t .. h\nend", "\t\
    x = math.abs(x)\n\tlocal s = tostring(x)\n\tlocal l = #s\n\tif shift == 0 or shift\
    \ == l then\n\t\treturn s\n\telseif shift < 0 then\n\t\tshift = l + shift\n\t\
    end\n\treturn string.sub(s, shift + 1) .. string.sub(s, 1, shift)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
