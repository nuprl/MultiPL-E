name: HumanEval_89_encrypt
language: lua
prompt: "-- Create a function encrypt that takes a string as an argument and\n-- returns\
  \ a string encrypted with the alphabet being rotated. \n-- The alphabet should be\
  \ rotated in a manner such that the letters \n-- shift down by two multiplied to\
  \ two places.\n-- For example:\nlocal function encrypt(s)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = encrypt\n\
  \    lu.assertEquals(candidate('hi'), 'lm')\n    lu.assertEquals(candidate('asdfghjkl'),\
  \ 'ewhjklnop')\n    lu.assertEquals(candidate('gf'), 'kj')\n    lu.assertEquals(candidate('et'),\
  \ 'ix')\n    lu.assertEquals(candidate('faewfawefaewg'), 'jeiajeaijeiak')\n    lu.assertEquals(candidate('hellomyfriend'),\
  \ 'lippsqcjvmirh')\n    lu.assertEquals(candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh'),\
  \ 'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl')\n    lu.assertEquals(candidate('a'),\
  \ 'e')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\t\nend", "  local a = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  local b =\
    \ string.sub(a, 3) .. string.sub(a, 1, 2)\n  return string.upper(string.gsub(s,\
    \ \"[%a]\", function(x)\n    return string.sub(b, string.find(a, x, 1, true))\n\
    \  end))\nend\nassert_equal('CDEFG', encrypt('ABCDE'))\nassert_equal('EFGHI',\
    \ encrypt('CDEFG'))\nassert_equal('CDEFG', encrypt('EFGHI'))", "  local alphabet\
    \ = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' }\n  local encrypt = ''\n\
    \  local char = ''\n  local index = 0\n  local int = 2\n  for i = 1, #s do\n \
    \   char = s:sub(i, i)\n    index = 0\n    while index < #alphabet do\n      if\
    \ char == alphabet[index] then\n        char = alphabet[((index * int) % 26) +\
    \ 1]\n        break\n      end\n      index = index + 1\n    end\n    encrypt\
    \ = encrypt .. char\n  end\n  return encrypt\nend", "  local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \  local newstr = \"\"\n  s = s:lower()\n  for i = 1, #s do\n    local found =\
    \ false\n    for k, v in pairs(alphabet) do\n      if s:sub(i,i) == v then\n \
    \       local pos = (k + (2 * k)) % 26 + 1\n        newstr = newstr .. alphabet[pos]\n\
    \        found = true\n      end\n    end\n    if not found then\n      newstr\
    \ = newstr .. s:sub(i,i)\n    end\n  end\n  return newstr\nend", "\tlocal alpha\
    \ = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"}\n\tlocal s = s:lower()\n\tlocal fin = \"\"\n\t\
    for i=1, s:len() do\n\t\tlocal inString = false\n\t\tfor j=1, alpha:len() do\n\
    \t\t\tif (s:sub(i,i) == alpha[j]) then\n\t\t\t\tlocal newLoc = j + i*2\n\t\t\t\
    \tif (newLoc > alpha:len()) then\n\t\t\t\t\tnewLoc = newLoc - alpha:len()\n\t\t\
    \t\tend\n\t\t\t\tfin = fin .. alpha[newLoc]\n\t\t\t\tinString = true\n\t\t\tend\n\
    \t\tend\n\t\tif (inString == false) then\n\t\t\tfin = fin .. s:sub(i,i)\n\t\t\
    end\n\tend\n\treturn fin\nend", "    -- your code here\n    local enc = \"\"\n\
    \    for i = 1, #s do\n        local c = s:sub(i,i)\n        local b = string.byte(c)\n\
    \        if b >= 65 and b <= 90 then\n            b = b + 2*2\n            if\
    \ b > 90 then\n                b = b - 26\n            end\n        elseif b >=\
    \ 97 and b <= 122 then\n            b = b + 2*2\n            if b > 122 then\n\
    \                b = b - 26\n            end\n        end\n        enc = enc ..\
    \ string.char(b)\n    end\n    return enc\nend", "\tlocal enc = ''\n\ts = string.lower(s)\n\
    \t\n\tfor i = 1, #s do\n\t\tlocal c = s:sub(i, i)\n\t\tlocal o = 0\n\t\tif c >=\
    \ 'a' and c <= 'z' then\n\t\t\to = c:byte() - ('a'):byte()\n\t\t\to = o + 2 *\
    \ 2\n\t\t\to = o % 26\n\t\t\to = o + ('a'):byte()\n\t\t\tc = string.char(o)\n\t\
    \tend\n\t\tenc = enc .. c\n\tend\n\t\n\treturn enc\nend", "  -- ...\nend", " \
    \ return s:gsub(\"%a\", function(c)\n  -- calculate the ascii code\n    local\
    \ ascii = string.byte(c)\n    if ascii >= 65 and ascii <= 90 then\n      -- if\
    \ the ascii code is between 65-90, return the \n      -- encrypted letter\n  \
    \    return string.char((ascii - 65 + 2) % 26 + 65)\n    elseif ascii >= 97 and\
    \ ascii <= 122 then\n      -- if the ascii code is between 97-122, return the\
    \ \n      -- encrypted letter\n      return string.char((ascii - 97 + 2) % 26\
    \ + 97)\n    else\n      -- otherwise return the original letter\n      return\
    \ c\n    end\n  end)\nend", "  if not string.match(s, \"[a-zA-Z]\") then\n   \
    \ return nil\n  end\n  -- Filter the string to only have alphabetic characters.\n\
    \  s = string.lower(string.gsub(s, \"[^a-zA-Z]\", \"\"))\n  local s_encrypted\
    \ = \"\"\n  for letter in string.gmatch(s, \"[a-z]\") do\n    local position =\
    \ string.byte(letter)\n    -- The \n    position = position + 2 * 2\n    if position\
    \ > 122 then\n      position = position - 26\n    end\n    -- Convert the number\
    \ back to a character, and add it to the string.\n    s_encrypted = s_encrypted\
    \ .. string.char(position)\n  end\n  return s_encrypted\nend", "  return s\nend",
  "\t-- create a copy of the string\n\tlocal out = s:gsub(\".\", function(c)\n\t\t\
    local upper = c:upper()\n\t\tlocal offset = upper:byte() - \"A\":byte()\n\t\t\
    -- ^ gets the offset of the letter\n\t\tif offset < 0 or offset > 25 then\n\t\t\
    \treturn c\n\t\tend\n\t\t-- ^ if it's not a letter, then just return it\n\t\t\
    return string.char((offset + 4) % 26 + \"A\":byte())\n\t\t-- ^ rotate it 4 letters\
    \ down the alphabet\n\tend)\n\treturn out\nend", "\tlocal a = {}\n\tfor i = 1,\
    \ #s do\n\t\ta[i] = strsub(s, i, i)\n\tend\n\tlocal t = {}\n\tfor i = 1, #a do\n\
    \t\tlocal b = a[i]\n\t\tif #b == 1 then\n\t\t\tif strbyte(b) < 123 and strbyte(b)\
    \ > 96 then\n\t\t\t\tlocal c = strbyte(b)\n\t\t\t\tif c == 121 then\n\t\t\t\t\t\
    c = c - 25\n\t\t\t\telseif c == 122 then\n\t\t\t\t\tc = c - 26\n\t\t\t\telse\n\
    \t\t\t\t\tc = c + 2\n\t\t\t\tend\n\t\t\t\tt[i] = strchar(c)\n\t\t\telseif strbyte(b)\
    \ < 91 and strbyte(b) > 64 then\n\t\t\t\tlocal c = strbyte(b)\n\t\t\t\tif c ==\
    \ 89 then\n\t\t\t\t\tc = c - 25\n\t\t\t\telseif c == 90 then\n\t\t\t\t\tc = c\
    \ - 26\n\t\t\t\telse\n\t\t\t\t\tc = c + 2\n\t\t\t\tend\n\t\t\t\tt[i] = strchar(c)\n\
    \t\t\telse\n\t\t\t\tt[i] = b\n\t\t\tend\n\t\telse\n\t\t\tt[i] = b\n\t\tend\n\t\
    end\n\tlocal e = \"\"\n\tfor i = 1, #t do\n\t\te = e .. t[i]\n\tend\n\treturn\
    \ e\nend", "  local result = \"\"\n  -- TODO: Do this!\n  return result\nend",
  "  -- your code here\n  local t,i,a = {},1,{}\n  for i=1,26 do\n    table.insert(a,string.char(string.byte('a')+i-1))\n\
    \  end\n  for i = 1,#s do\n    for j = 1,#a do\n      if s:sub(i,i) == a[j] then\n\
    \        table.insert(t,a[(j-1)*2+1])\n      end\n    end\n  end\n  return table.concat(t)\n\
    end", "\t-- Extract the letters, numbers, and special characters from the string\n\
    \tlocal letters, numbers, specials = string.gmatch(s, \"(%a+)|(%d+)|(%W+)\")",
  "  local output = \"\"\n  for i = 1, #s do\n    local c = s:sub(i,i)\n    if (c\
    \ >= \"a\" and c <= \"x\") or (c >= \"A\" and c <= \"X\") then\n      output =\
    \ output .. string.char(s:byte(i) + 2)\n    elseif c == \"y\" then\n      output\
    \ = output .. \"a\"\n    elseif c == \"z\" then\n      output = output .. \"b\"\
    \n    elseif c == \"Y\" then\n      output = output .. \"A\"\n    elseif c ==\
    \ \"Z\" then\n      output = output .. \"B\"\n    else\n      output = output\
    \ .. c\n    end\n  end\n  return output\nend", "    local s = s:lower()\n    local\
    \ start = 1\n    local e = \"\"\n    for i = 1, #s do\n        if s:byte(i) >\
    \ 96 and s:byte(i) < 123 then\n            e = e .. string.char(s:byte(i) + (1\
    \ - start) * 2)\n            start = -start\n        else\n            e = e ..\
    \ s:sub(i, i)\n        end\n    end\n    return e\nend", "\treturn 'YOUR CODE'\n\
    end", "\tlocal alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\tlocal ciphertext =\
    \ \"\"\n\tfor i = 1, #s do\n\t\tlocal c = s:sub(i,i)\n\t\tif c == ' ' then ciphertext\
    \ = ciphertext .. c\n\t\telse\n\t\t\tlocal index = (alphabet:find(c)-1) * 2\n\t\
    \t\tciphertext = ciphertext .. alphabet:sub(index,index)\n\t\tend\n\tend\n\treturn\
    \ ciphertext\nend", "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  return\
    \ string.gsub(s, \"%a\", function(c)\n    return string.sub(alphabet, (string.find(alphabet,\
    \ c) + 2 * 2) % 26 + 1, (string.find(alphabet, c) + 2 * 2) % 26 + 1)\n  end)\n\
    end", "    local s = s:lower()\n    local abc = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    local abc2 = abc:sub(3) .. abc:sub(1,2)\n    local t = {}\n    for i = 1,\
    \ #s do\n        local c = s:sub(i,i)\n        local n = c:find(abc)\n       \
    \ local c2 = c\n        if n then\n            c2 = abc2:sub(n,n)\n        end\n\
    \        t[#t+1] = c2\n    end\n    return table.concat(t)\nend\nprint(encrypt(\"\
    abcdef\"))\nprint(encrypt(\"third\"))\nprint(encrypt(\"abcdefghijklmnopqrstuvwxyz\"\
    ))", "  -- your code goes here\n  local result = \"\"\n  local rotate = 2\n  local\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  local str = s:lower()\n  local\
    \ ALPHALEN = 26\n  local SKIP = ALPHALEN - rotate\n  local start = 1\n  local\
    \ finish = ALPHALEN\n  local first = string.sub(alphabet, start, SKIP)\n  local\
    \ second = string.sub(alphabet, rotate + 1, finish)\n  local shifted = first ..\
    \ second\n  for i = 1, str:len() do\n    local c = str:sub(i,i)\n    local n =\
    \ string.find(alphabet, c)\n    if n then\n      result = result .. string.sub(shifted,\
    \ n, n)\n    else\n      result = result .. c\n    end\n  end\n  return result\n\
    end", "\treturn string.gsub(s, \"([%w])\", function(ch)\n\t\treturn string.char(string.byte(ch)\
    \ + 2)\n\tend)\nend\nprint(encrypt(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"))\nprint(encrypt(\"\
    abcdefghijklmnopqrstuvwxyz\"))\nprint(encrypt(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"))\n\
    print(encrypt(\"abcdefghijklmnopqrstuvwxyz\"))", "  local result = {}\n  for i\
    \ = 1, #s do\n    local c = s:sub(i,i)\n    local ascii = string.byte(c)\n   \
    \ if ascii < 122 and ascii > 96 then\n      ascii = ascii + 4\n    elseif ascii\
    \ < 122 and ascii > 90 then\n      ascii = ascii - 22\n    elseif ascii < 90 and\
    \ ascii > 64 then\n      ascii = ascii + 4\n    elseif ascii < 90 and ascii >\
    \ 58 then\n      ascii = ascii - 22\n    end\n    result[i] = string.char(ascii)\n\
    \  end\n  return table.concat(result)\nend", "   local result = {}\n   for i =\
    \ 1,#s do\n      local pos = s:sub(i,i):byte()\n      local resultPos = (pos %\
    \ 2 == 0) and pos + 2 or pos + 3\n      if resultPos > 255 then resultPos = resultPos\
    \ - 255 end\n      table.insert(result, string.char(resultPos))\n   end\n   return\
    \ table.concat(result)\nend", "    local ciphertext = \"\"\n    for i = 1, #s\
    \ do\n        local c = s:sub(i,i)\n        if c:match(\"%a\") then\n        \
    \    local offset = (c:byte() - 96) * 2\n            if offset > 26 then\n   \
    \             offset = offset - 26\n            end\n            local ascii =\
    \ 96 + offset\n            ciphertext = ciphertext .. string.char(ascii)\n   \
    \     else\n            ciphertext = ciphertext .. c\n        end\n    end\n \
    \   return ciphertext\nend", end, "    local a = string.byte('a')\n    local shift\
    \ = a - 2*2\n    local ret = {}\n    for i = 1,#s do\n        local v = string.byte(s,i)\n\
    \        if v >= a and v <= a + 25 then\n            v = shift + (v - a)\n   \
    \     end\n        ret[i] = string.char(v)\n    end\n    return table.concat(ret)\n\
    end", "\tlocal h = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\tlocal upper = string.upper(s)\n\
    \tlocal x = \"\"\n\tfor i = 1, #upper do\n\t\tlocal let = string.sub(upper, i,\
    \ i)\n\t\tlocal index = string.find(h, let)\n\t\tlocal newIndex = (index + (#h\
    \ * 2))\n\t\tlocal newLet = string.sub(h, newIndex, newIndex)\n\t\tx = x .. newLet\n\
    \tend\n\treturn x\nend", "    -- TODO: Implement your function here\n    return\
    \ s\nend", "    local out = \"\"\n    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    for i = 1, #s do\n        local char = s:sub(i, i)\n        local index\
    \ = alphabet:find(char)\n        local new_index = index + 2 * 2\n        local\
    \ new_char = alphabet:sub(new_index, new_index)\n        out = out .. new_char\n\
    \    end\n    return out\nend", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  local cipher = ''\n  for i = 1, #s do\n    local c = s:sub(i,i)\n    if alphabet:find(c)\
    \ then\n      local ai = (alphabet:find(c) + 2) % #alphabet\n      cipher = cipher\
    \ .. alphabet:sub(ai,ai)\n    else\n      cipher = cipher .. c\n    end\n  end\n\
    \  return cipher\nend", "    local t={}\n    local a,b,c,d\n    local l=string.len(s)\n\
    \    local alp='zabcdefghijklmnopqrstuvwxyz'\n    for i=1,l do\n        a=string.sub(s,i,i)\n\
    \        b=string.find(alp,a)\n        if b==nil then\n            table.insert(t,a)\n\
    \        else\n            c=b+4\n            if c>26 then\n                c=c-26\n\
    \            end\n            d=string.sub(alp,c,c)\n            table.insert(t,d)\n\
    \        end\n    end\n    s=table.concat(t)\n    return s\nend", "    local str\
    \ = \"\"\n    local lower = {}\n    local upper = {}\n    local length = string.len(s)\n\
    \    local i\n    local shift = 2 * 2\n    local lower_start = string.byte(\"\
    a\")\n    local lower_end = string.byte(\"z\")\n    local upper_start = string.byte(\"\
    A\")\n    local upper_end = string.byte(\"Z\")\n    for i = lower_start, lower_end\
    \ do\n        lower[i] = string.char(i)\n    end\n    for i = upper_start, upper_end\
    \ do\n        upper[i] = string.char(i)\n    end\n    for i = 1, length do\n \
    \       local c = string.byte(s, i)\n        if c >= lower_start and c <= lower_end\
    \ then\n            local index = ((c - lower_start + shift) % 26) + lower_start\n\
    \            str = str .. lower[index]\n        elseif c >= upper_start and c\
    \ <= upper_end then\n            local index = ((c - upper_start + shift) % 26)\
    \ + upper_start\n            str = str .. upper[index]\n        else\n       \
    \     str = str .. string.char(c)\n        end\n    end\n    return str\nend",
  "\tencrypt = crypt.rot2(s)\n\treturn encrypt\nend", "   local encrypt = {}\n   local\
    \ alphabet = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n   for char in s:gmatch\".\" do\n   \
    \  local n = {}\n     for k, v in pairs(alphabet) do\n       if v == char then\n\
    \       \t n[k] = char\n       end\n     end\n     for k, v in pairs(n) do\n \
    \      local x = k + 2 * 2\n       if x > #alphabet then\n       \t x = x - 26\n\
    \       end\n       encrypt[#encrypt + 1] = alphabet[x]\n     end\n   end\n  \
    \ return table.concat(encrypt)\nend", "    local function shift_char(c)\n    \
    \    if string.byte(c) >= string.byte('a') and string.byte(c) <= string.byte('z')\
    \ then\n            local n = string.byte(c) + 2\n            if n > string.byte('z')\
    \ then\n                n = n - string.byte('z') + string.byte('a') - 1\n    \
    \        end\n            return string.char(n)\n        elseif string.byte(c)\
    \ >= string.byte('A') and string.byte(c) <= string.byte('Z') then\n          \
    \  local n = string.byte(c) + 2\n            if n > string.byte('Z') then\n  \
    \              n = n - string.byte('Z') + string.byte('A') - 1\n            end\n\
    \            return string.char(n)\n        else\n            return c\n     \
    \   end\n    end\n    local result = \"\"\n    for i = 1, string.len(s) do\n \
    \       result = result .. shift_char(string.sub(s, i, i))\n    end\n    return\
    \ result\nend", "\tlocal d = {}\n\tfor i = 1, #s do\n\t\tlocal c = s:sub(i,i)\n\
    \t\ttable.insert(d, string.char(ASCII.lower(c) + 4))\n\tend\n\treturn table.concat(d)\n\
    end", "  -- ...\nend", "    -- your code here\n    local encryptWord = \"\"\n\
    \    for letter in s:gmatch(\"%a\") do\n        local newLetter = string.byte(letter)\
    \ + 2\n        if newLetter > 122 then\n            newLetter = newLetter - 26\n\
    \        end\n        encryptWord = encryptWord .. string.char(newLetter)\n  \
    \  end\n    return encryptWord\nend", "\tlocal enc = \"\"\n\tfor i = 1, s:len()\
    \ do\n\t\tlocal c = s:sub(i, i)\n\t\tlocal p = ALPHABET:find(c)\n\t\tif p then\n\
    \t\t\tlocal e = ALPHABET:sub(p + 1, p + 1)\n\t\t\tenc = enc .. e\n\t\telse\n\t\
    \t\tenc = enc .. c\n\t\tend\n\tend\n\treturn enc\nend", "    local s2 = \"\"\n\
    \    for i = 1, #s do\n        local c = s:sub(i,i)\n        local b = string.byte(c)\n\
    \        if b >= string.byte(\"a\") and b <= string.byte(\"z\") then\n       \
    \     b = b + (2 * 2)\n            if b > string.byte(\"z\") then\n          \
    \      b = b - 26\n            end\n        elseif b >= string.byte(\"A\") and\
    \ b <= string.byte(\"Z\") then\n            b = b + (2 * 2)\n            if b\
    \ > string.byte(\"Z\") then\n                b = b - 26\n            end\n   \
    \     end\n        s2 = s2 .. string.char(b)\n    end\n    return s2\nend", " \
    \   s = string.lower(s)\n    local e = \"\"\n    for i = 1, #s do\n        local\
    \ c = string.byte(s, i)\n        if (c >= 97 and c <= 122) then\n            c\
    \ = c + 2\n            if (c > 122) then\n                c = c - 26\n       \
    \     end\n        end\n        e = e .. string.char(c)\n    end\n    return e\n\
    end", "  local alph = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"\
    , \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n  local alphabet = {}\n  local\
    \ newString = \"\"\n  local i = 1\n  local j = 1\n  local index = 0\n  local index2\
    \ = 0\n  local cipher = 2 * 2\n  local letter\n  local newletter\n  local newString\
    \ = \"\"\n  while i <= #alph do\n    alphabet[j] = alph[i]\n    if i == cipher\
    \ then\n      break\n    end\n    i = i + 1\n    j = j + 1\n  end\n  i = i + 1\n\
    \  while i <= #alph do\n    alphabet[j] = alph[i]\n    j = j + 1\n    i = i +\
    \ 1\n  end\n  i = 1\n  while i <= #alph do\n    alphabet[j] = alph[i]\n    j =\
    \ j + 1\n    i = i + 1\n  end\n  while i <= cipher do\n    alphabet[j] = alph[i]\n\
    \    j = j + 1\n    i = i + 1\n  end\n  i = 1\n  while i <= #s do\n    letter\
    \ = string.sub(s, i, i)\n    for k = 1, #alph do\n      if alph[k] == letter then\n\
    \        index = k\n        break\n      end\n    end\n    newletter = alphabet[index]\n\
    \    newString = newString .. newletter\n    i = i + 1\n  end\n  return newString\n\
    end", "  local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \  local encryptedString = \"\"\n  for i = 1, #s do\n    local c = s:sub(i,i)\n\
    \    if c == ' ' then\n      encryptedString = encryptedString .. ' '\n    else\n\
    \      local index = nil\n      for j = 1, #alphabet do\n        if alphabet[j]\
    \ == c then\n          index = j\n          break\n        end\n      end\n  \
    \    local newIndex = (index + (2 * 2)) % #alphabet\n      if newIndex == 0 then\n\
    \        newIndex = 26\n      end\n      encryptedString = encryptedString ..\
    \ alphabet[newIndex]\n    end\n  end\n  return encryptedString\nend", "  local\
    \ result = {}\n  for i=1, #s do\n    local char = s:sub(i,i)\n    if char == \"\
    \ \" then\n      table.insert(result, \" \")\n    else\n      local currIndex\
    \ = string.find(alphabet, char)\n      local newChar = alphabet:sub(currIndex\
    \ + (i-1)*2, currIndex + (i-1)*2)\n      table.insert(result, newChar)\n    end\n\
    \  end\n  return table.concat(result)\nend", "   local result = \"\"\n   for i\
    \ = 1, #s do\n      local code = string.byte(s, i)\n      if code >= 97 and code\
    \ <= 122 then\n         code = code + 2\n         if code > 122 then\n       \
    \     code = code - 26\n         end\n      elseif code >= 65 and code <= 90 then\n\
    \         code = code + 2\n         if code > 90 then\n            code = code\
    \ - 26\n         end\n      end\n      result = result .. string.char(code)\n\
    \   end\n   return result\nend", "    local s2 = \"\"\n    for i = 1,#s do\n \
    \       s2 = s2 .. string.char(string.byte(s,i)+2*2)\n    end\n    return s2\n\
    end", "\tlocal result = \"\"\n\tfor i = 1, #s do\n\t\tlocal c = s:sub(i,i)\n\t\
    \tlocal b = c:byte()\n\t\tif b >= 65 and b <= 90 then\n\t\t\tb = b + 2*2\n\t\t\
    \tif b > 90 then\n\t\t\t\tb = b - 26\n\t\t\tend\n\t\telseif b >= 97 and b <= 122\
    \ then\n\t\t\tb = b + 2*2\n\t\t\tif b > 122 then\n\t\t\t\tb = b - 26\n\t\t\tend\n\
    \t\tend\n\t\tresult = result .. string.char(b)\n\tend\n\treturn result\nend",
  "    local alpha = 'abcdefghijklmnopqrstuvwxyz'\n    local enc = ''\n    for i =\
    \ 1, #s do\n        local c = s:sub(i, i)\n        local idx = alpha:find(c)\n\
    \        if idx == nil then\n            enc = enc .. c\n        else\n      \
    \      local idx2 = idx + 2 * 2\n            if idx2 > #alpha then\n         \
    \       idx2 = idx2 - #alpha\n            end\n            enc = enc .. alpha:sub(idx2,\
    \ idx2)\n        end\n    end\n    return enc\nend", "   local encrypt = {}\n\
    \   -- Loop through each character in the string and keep\n   -- the characters\
    \ that are not letters\n   for i = 1, #s do\n      local c = s:sub(i,i)\n    \
    \  if c:match(\"%a\") then\n         local charCode = string.byte(c) + 8\n   \
    \      if charCode > 122 then\n            charCode = charCode - 26\n        \
    \ end\n         table.insert(encrypt, string.char(charCode))\n      else\n   \
    \      table.insert(encrypt, c)\n      end\n   end\n   return table.concat(encrypt)\n\
    end", "    local letters = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"\
    s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    local s = string.lower(s)\n\
    \    local enc = \"\"\n    for i = 1, #s do\n        local l = s:sub(i, i)\n \
    \       local idx = 1\n        for j = 1, #letters do\n            if l == letters[j]\
    \ then\n                idx = j\n                break\n            end\n    \
    \    end\n        enc = enc .. letters[idx]\n    end\n    return enc\nend", " \
    \   -- TODO: Implement the function\n    local encrypted = {}\n    local key =\
    \ {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \    local key_s = {'c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','a','b'}\n\
    \    for i = 1, #s do\n        local char = s:sub(i,i)\n        local char_code\
    \ = string.byte(char)\n        if char_code >= 97 and char_code <= 122 then\n\
    \            for j = 1, 26 do\n                if char == key[j] then\n      \
    \              table.insert(encrypted, key_s[j])\n                end\n      \
    \      end\n        else\n            table.insert(encrypted, char)\n        end\n\
    \    end\n    return table.concat(encrypted)\nend", "    local i = 1\n    local\
    \ new_string = \"\"\n    while i <= #s do\n        local char = string.sub(s,\
    \ i, i)\n        local new_char = string.char(string.byte(char) + (2 * 2))\n \
    \       new_string = new_string .. new_char\n        i = i + 1\n    end\n    return\
    \ new_string\nend", "\t-- create a place for the encrypted string to go\n\tlocal\
    \ enc = \"\"\n\t-- for each character in the string s, add it to the encrypted\
    \ string.\n\tfor i = 1, #s do\n\t\t-- get the letter to encrypt\n\t\tlocal l =\
    \ s:sub(i,i)\n\t\t-- check to see if the letter is in the alphabet\n\t\tif l:find(\"\
    %a\") then\n\t\t\t-- convert the letter to its ascii value\n\t\t\tlocal n = l:byte()\n\
    \t\t\t-- if the letter is uppercase, start at 65\n\t\t\tif l:find(\"%u\") then\n\
    \t\t\t\tn = n - 65\n\t\t\t-- if the letter is lowercase, start at 97\n\t\t\telseif\
    \ l:find(\"%l\") then\n\t\t\t\tn = n - 97\n\t\t\tend\n\t\t\t-- add 2 to the ascii\
    \ value (base 26), accounting for wrap around\n\t\t\tn = (n + 2) % 26\n\t\t\t\
    -- add the ascii value to the encrypted string\n\t\t\tenc = enc .. string.char(n\
    \ + 65)\n\t\t-- if the letter is not in the alphabet, just add it to the encrypted\
    \ string\n\t\telse\n\t\t\tenc = enc .. l\n\t\tend\n\tend\n\t-- return the encrypted\
    \ string\n\treturn enc\nend", "  local s2 = ''\n  local s2c = 0\n  local s2c1\
    \ = 0\n  local s2c2 = 0\n  local s2c3 = 0\n  local s2c4 = 0\n  local ch1 = 0\n\
    \  local ch2 = 0\n  local ch3 = 0\n  local ch4 = 0\n  local ch5 = 0\n  local ch6\
    \ = 0\n  local ch7 = 0\n  local ch8 = 0\n  for i = 1, #s do\n    s2c = s2c + 1\n\
    \    if s2c <= #s then\n      s2c1 = s2c * 2\n      s2c2 = s2c1 + 1\n      s2c3\
    \ = s2c2 + 1\n      s2c4 = s2c3 + 1\n      ch1 = string.sub(s, s2c, s2c)\n   \
    \   ch2 = string.sub(s, s2c1, s2c1)\n      ch3 = string.sub(s, s2c2, s2c2)\n \
    \     ch4 = string.sub(s, s2c3, s2c3)\n      ch5 = string.sub(s, s2c4, s2c4)\n\
    \      ch6 = string.sub(s, s2c3, s2c3)\n      ch7 = string.sub(s, s2c2, s2c2)\n\
    \      ch8 = string.sub(s, s2c1, s2c1)\n      if ch1 == nil then ch1 = '' end\n\
    \      if ch2 == nil then ch2 = '' end\n      if ch3 == nil then ch3 = '' end\n\
    \      if ch4 == nil then ch4 = '' end\n      if ch5 == nil then ch5 = '' end\n\
    \      if ch6 == nil then ch6 = '' end\n      if ch7 == nil then ch7 = '' end\n\
    \      if ch8 == nil then ch8 = '' end\n      s2 = s2 .. ch2 .. ch3 .. ch4 ..\
    \ ch5 .. ch6 .. ch7 .. ch8 .. ch1\n    end\n  end\n  return s2\nend", "    local\
    \ alphabet = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    local letter = {}\n    local encryption\
    \ = \"\"\n    for i = 1, #s do\n        for j = 1, #alphabet do\n            if\
    \ s:sub(i, i) == alphabet[j] then\n                if j > 23 then\n          \
    \          table.insert(letter, alphabet[j-22])\n                else\n      \
    \              table.insert(letter, alphabet[j+4])\n                end\n    \
    \        end\n        end\n    end\n    for k = 1, #letter do\n        encryption\
    \ = encryption .. letter[k]\n    end\n    return encryption\nend", "    local\
    \ len = #s\n    local out = \"\"\n    for i = 1, len do\n        local s_i = s:sub(i,\
    \ i)\n        if s_i == ' ' then\n            out = out .. s_i\n        else\n\
    \            local index = string.find(alphabet, s_i)\n            local real_index\
    \ = index + math.pow(2, 2)\n            if real_index > #alphabet then\n     \
    \           real_index = real_index - #alphabet\n            end\n           \
    \ out = out .. alphabet:sub(real_index, real_index)\n        end\n    end\n  \
    \  return out\nend", "\tlocal encrypt=''\n\tlocal c\n\tfor c in s:gmatch(\".\"\
    ) do\n\t\tlocal rot2=(c:byte()-0x41+2*2)%26\n\t\tlocal rot1=(c:byte()-0x41+1*2)%26\n\
    \t\tencrypt=encrypt..string.char(rot2+0x41)..string.char(rot1+0x41)\n\tend\n\t\
    return encrypt\nend", "  -- your code here\nend", "    local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \    local result = ''\n    local new_idx", "    local result = \"\"\n    local\
    \ length = string.len(s)\n    for i = 1, length do\n        local currentChar\
    \ = string.sub(s, i, i)\n        local charNumber = string.byte(currentChar)\n\
    \        charNumber = charNumber + 2 * 2\n        local resultChar = string.char(charNumber)\n\
    \        result = result .. resultChar\n    end\n    return result\nend\nprint(encrypt(\"\
    zentral\"))", "  -- replace with your code\n  return s\nend", "    local enc =\
    \ \"\"\n    local a = string.byte(\"a\")\n    local z = string.byte(\"z\")\n \
    \   for i = 1, #s do\n        local c = string.byte(s, i)\n        if c >= a and\
    \ c <= z then\n            c = c + 4\n            if c > z then\n            \
    \    c = a + (c - z) - 1\n            end\n        end\n        enc = enc .. string.char(c)\n\
    \    end\n    return enc\nend\nprint(encrypt(\"abz\")) --> edb\nprint(encrypt(\"\
    andrew was here\")) --> gqjfydw jtdw xjhj", "\tlocal my_alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tlocal my_encrypted_alphabet = \"cdefghijklmnopqrstuvwxyzab\"\n\treturn string.gsub(s,\
    \ \"%a\", function(c) return string.sub(my_encrypted_alphabet, string.find(my_alphabet,\
    \ c), string.find(my_alphabet, c)) end)\nend", "    local p = {}\n    for i =\
    \ 1, #s do\n        table.insert(p, string.byte(s, i))\n    end\n    for i = 1,\
    \ #p do\n        p[i] = p[i] + (#p - i) * 2\n    end\n    return string.char(unpack(p))\n\
    end", "    local a = {}\n    for i = 1, #s do\n        a[i] = string.byte(s, i)\n\
    \    end\n    local r = {}\n    for i = 1, #a do\n        r[i] = string.char(a[i]\
    \ + (i * 2))\n    end\n    return table.concat(r)\nend", "    return s:gsub(\"\
    %a\",function(c)\n        local a = string.byte(\"a\")\n        local z = string.byte(\"\
    z\")\n        local A = string.byte(\"A\")\n        local Z = string.byte(\"Z\"\
    )\n        local v = string.byte(c)\n        if v >= a and v <= z then\n     \
    \       return string.char(((v-a+2)%26)+a)\n        elseif v >= A and v <= Z then\n\
    \            return string.char(((v-A+2)%26)+A)\n        else\n            return\
    \ c\n        end\n    end)\nend", "\tlocal encryptedString = \"\"\n\tlocal offset\
    \ = 2\n\tfor i = 1, #s do\n\t\tlocal char = s:sub(i, i)\n\t\tlocal charIndex =\
    \ string.find(alphabet, char)", "  local e = {}\n  for i = 1, #s do\n    local\
    \ c = s:sub(i, i)\n    if c ~= \" \" then\n      e[i] = string.char(\n       \
    \ (string.byte(c) + (2 * 2) -  string.byte(\"a\")) % 26 +  string.byte(\"a\")\n\
    \      )\n    else\n      e[i] = \" \"\n    end\n  end\n  return table.concat(e)\n\
    end", "    local d = {};\n    for i = 1, #s do\n        local c = s:sub(i, i);\n\
    \        if(c:match(\"[A-Z]\")) then\n            c = string.char((c:byte() -\
    \ 65 + 13) % 26 + 65);\n        elseif(c:match(\"[a-z]\")) then\n            c\
    \ = string.char((c:byte() - 97 + 13) % 26 + 97);\n        end\n        d[#d +\
    \ 1] = c;\n    end\n    return table.concat(d);\nend\nassert(encrypt(\"Hello World\"\
    ) == \"Uryyb Jbeyq\")\nassert(encrypt(\"Hello\") == \"Uryyb\")", "  -- body\n\
    \  local result = \"\"\n  for i = 1, #s do\n    local c = s:sub(i,i)\n    if c\
    \ == \" \" then\n      result = result .. \" \"\n    else\n      result = result\
    \ .. string.char(string.byte(c) - 2)\n    end\n  end\n  return result\nend", " \
    \   return s:gsub(\".\", function(c)\n        local n = c:byte() - 65\n      \
    \  if n >= 0 and n <= 25 then\n            return string.char(((n + 2 * 2) % 26)\
    \ + 65)\n        else\n            return c\n        end\n    end)\nend\nassert(encrypt(\"\
    HELLO\") == \"JGNNQ\")\nassert(encrypt(\"monday\") == \"opqfgv\")\nassert(encrypt(\"\
    TUESDAY\") == \"VWGUFW\")", "    local t = {}\n    local alphabet = {}\n    local\
    \ index = 1\n    local a\n    for i = 1, 26 do\n        alphabet[i] = string.char(i\
    \ + 64)\n    end\n    local skip = 2\n    for j = 1, 2 do\n        for i = 1,\
    \ #alphabet do\n            if i + skip <= #alphabet then\n                t[index]\
    \ = alphabet[i + skip]\n                index = index + 1\n            else\n\
    \                a = (i + skip) - #alphabet\n                t[index] = alphabet[a]\n\
    \                index = index + 1\n            end\n        end\n        skip\
    \ = skip * 2\n    end\n    local output = \"\"\n    for i = 1, #s do\n       \
    \ for j = 1, #alphabet do\n            if s:sub(i, i) == alphabet[j] then\n  \
    \              output = output .. t[j]\n            end\n        end\n    end\n\
    \    return output\nend", "  \nend", end, "\treturn caesar(s, 13)\nend", "\tlocal\
    \ s = s:lower()\n\tlocal temp = {}\n\tfor i = 1, #s do\n\t\tlocal c = s:sub(i,i)\n\
    \t\tif c == \"z\" then c = \"b\" end\n\t\tif c == \"y\" then c = \"a\" end\n\t\
    \tif c:match(\"%a\") then\n\t\t\tc = string.char(string.byte(c) + 2)\n\t\tend\n\
    \t\ttable.insert(temp, c)\n\tend\n\tlocal newString = table.concat(temp)\n\treturn\
    \ newString\nend", "  local shift = 2 * 2\n  local char_to_number = {}\n  local\
    \ number_to_char = {}\n  local char_array = {}\n  local number_array = {}\n  local\
    \ output = \"\"\n  local s_length = string.len(s)\n  local char_index = 0\n  local\
    \ number_index = 0\n  local temp_number = 0\n  local temp_char = \"\"\n  for i\
    \ = 0, s_length do\n    char_array[i] = string.sub(s, i, i)\n  end\n  for k, v\
    \ in pairs(char_array) do\n    char_to_number[v] = k\n  end\n  for k, v in pairs(char_to_number)\
    \ do\n    number_to_char[v] = k\n  end\n  for k, v in pairs(char_to_number) do\n\
    \    temp_number = v\n    number_array[k] = temp_number + shift\n  end\n  for\
    \ k, v in pairs(number_array) do\n    temp_char = number_to_char[v]\n    output\
    \ = output .. temp_char\n  end\n  return output\nend", "  \n  -- get the string\
    \ length\n  local len = #s\n  \n  -- create an output string\n  local out = \"\
    \"\n  \n  -- loop from 1 to the length of the string\n  for i = 1, len do\n  \
    \  \n    -- get the i-th character in the string\n    local c = s:sub(i, i)\n\
    \    \n    -- convert it to the corresponding number\n    local n = c:byte()\n\
    \    \n    -- check if it's a letter\n    if isalpha(n) then\n      \n      --\
    \ increment the value and if it goes over the letter range\n      -- (because\
    \ of rotation), subtract the length of the alphabet\n      -- to wrap it around\n\
    \      n = n + (i * 2)\n      if n > 90 then\n        n = n - 26\n      end\n\
    \      \n      -- convert it back to a character and add it to the output\n  \
    \    c = string.char(n)\n      out = out .. c\n      \n    else -- if it's not\
    \ a letter, simply add it to the output string\n      out = out .. c\n    end\n\
    \  end\n  \n  -- return the output string\n  return out\nend", "    s = string.lower(s)\n\
    \    local alp = \"abcdefghijklmnopqrstuvwxyz\"\n    local encrypted = \"\"\n\
    \    for i = 1, #s do\n        local c = string.sub(s, i, i)\n        local pos\
    \ = string.find(alp, c)\n        if pos then\n            local new_pos = (pos\
    \ + (2 * 2)) % #alp\n            encrypted = encrypted .. string.sub(alp, new_pos,\
    \ new_pos)\n        else\n            encrypted = encrypted .. c\n        end\n\
    \    end\n    return encrypted\nend", "  local output = ''\n  local alphabet =\
    \ 'abcdefghijklmnopqrstuvwxyz'\n  local cypher = alphabet:sub(1,#alphabet-3) ..\
    \ alphabet:sub(#alphabet-1,#alphabet) .. alphabet:sub(#alphabet-2,#alphabet-2)\n\
    \  for i = 1, #s do\n    local char = s:sub(i,i)\n    if char:find('%a') then\n\
    \      output = output .. cypher:sub(alphabet:find(char),alphabet:find(char))\n\
    \    else\n      output = output .. char\n    end\n  end\n  return output\nend",
  "   -- YOUR CODE GOES HERE\n   return string.gsub(s, \"[%a]\", function(x)\n   \
    \   local b = string.byte(x) + 2\n      if b > 90 then\n         b = b - 26\n\
    \      end\n      return string.char(b)\n   end)\nend", "\tlocal result = {}\n\
    \tfor i = 1, #s do\n\t\tlocal char = s:sub(i, i)\n\t\tlocal rot = char:byte()\
    \ + (((i - 1) * 2) % 26)\n\t\tif rot > 122 then\n\t\t\trot = rot - 26\n\t\tend\n\
    \t\tresult[i] = string.char(rot)\n\tend\n\treturn table.concat(result)\nend",
  "  -- your code here\nend", "   local enc = {}\n   for i = 1, string.len(s) do\n\
    \      if (string.byte(s, i) >= 65 and string.byte(s, i) <= 90) or\n         (string.byte(s,\
    \ i) >= 97 and string.byte(s, i) <= 122) then\n            local c = string.byte(s,\
    \ i) + (i*2)\n            if c > 122 then\n               c = c - 26\n       \
    \     end\n            table.insert(enc, string.char(c))\n      else\n       \
    \  table.insert(enc, string.char(string.byte(s, i)))\n      end\n   end\n   return\
    \ table.concat(enc)\nend", "  local result = \"\"\n  for i = 1, string.len(s)\
    \ do\n    local c = string.sub(s, i, i)\n    result = result .. encrypt_char(c)\n\
    \  end\n  return result\nend", "    local newStr = ''", "\t-- code goes here!\n\
    \tnew_string = string.gsub(s, \".\", {\n\t\t[\"a\"] = \"C\", [\"b\"] = \"D\",\
    \ [\"c\"] = \"E\", [\"d\"] = \"F\", [\"e\"] = \"G\", [\"f\"] = \"H\", [\"g\"]\
    \ = \"I\", [\"h\"] = \"J\", [\"i\"] = \"K\", [\"j\"] = \"L\", [\"k\"] = \"M\"\
    , [\"l\"] = \"N\", [\"m\"] = \"O\", [\"n\"] = \"P\", [\"o\"] = \"Q\", [\"p\"]\
    \ = \"R\", [\"q\"] = \"S\", [\"r\"] = \"T\", [\"s\"] = \"U\", [\"t\"] = \"V\"\
    , [\"u\"] = \"W\", [\"v\"] = \"X\", [\"w\"] = \"Y\", [\"x\"] = \"Z\", [\"y\"]\
    \ = \"A\", [\"z\"] = \"B\", [\"A\"] = \"C\", [\"B\"] = \"D\", [\"C\"] = \"E\"\
    , [\"D\"] = \"F\", [\"E\"] = \"G\", [\"F\"] = \"H\", [\"G\"] = \"I\", [\"H\"]\
    \ = \"J\", [\"I\"] = \"K\", [\"J\"] = \"L\", [\"K\"] = \"M\", [\"L\"] = \"N\"\
    , [\"M\"] = \"O\", [\"N\"] = \"P\", [\"O\"] = \"Q\", [\"P\"] = \"R\", [\"Q\"]\
    \ = \"S\", [\"R\"] = \"T\", [\"S\"] = \"U\", [\"T\"] = \"V\", [\"U\"] = \"W\"\
    , [\"V\"] = \"X\", [\"W\"] = \"Y\", [\"X\"] = \"Z\", [\"Y\"] = \"A\", [\"Z\"]\
    \ = \"B\"\n\t\t})\n\treturn new_string\nend", "\tlocal result = \"\"\n\tfor c\
    \ in s:gmatch\".\" do\n\t\tlocal i = c:byte() - 97\n\t\ti = (i * 2) % 26\n\t\t\
    result = result .. string.char(i + 97)\n\tend\n\treturn result\nend", "    local\
    \ offset=2*2\n    local alph=\"abcdefghijklmnopqrstuvwxyz\"\n    local e=s:gsub(\"\
    .\",function(c) \n        local t=c:lower()\n        local p=alph:find(t)\n  \
    \      if p then\n            return alph:sub(p+offset,p+offset)\n        else\n\
    \            return c\n        end\n    end)\n    return e\nend", "  local encrypted\
    \ = \"\"\n  for i = 1, #s do\n    local c = s:sub(i,i)\n    if c:match(\"%a\"\
    ) then\n      local encoded = c:byte() + 2*2\n      if encoded > 122 then encoded\
    \ = encoded - 26 end\n      encrypted = encrypted .. string.char(encoded)\n  \
    \  else\n      encrypted = encrypted .. c\n    end\n  end\n  return encrypted\n\
    end", "\tlocal e = \"\"\n\tfor i = 1, #s do\n\t\tlocal c = s:sub(i, i)\n\t\tlocal\
    \ pos = string.find(letters, c)\n\t\tif pos then\n\t\t\te = e .. letters:sub(pos\
    \ + 4, pos + 4)\n\t\telse\n\t\t\te = e .. c\n\t\tend\n\tend\n\treturn e\nend",
  "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    local s2 = ''\n    for i\
    \ = 1, #s do\n        local c = s:sub(i, i)\n        local p = string.find(alphabet,\
    \ c)\n        if p then\n            p = p + 2\n            s2 = s2 .. alphabet:sub(p,\
    \ p)\n        else\n            s2 = s2 .. c\n        end\n    end\n    return\
    \ s2\nend", "\tlocal len = #s;\n\tlocal offset = 2 * 2;\n\tlocal s2 = \"\";\n\t\
    for i = 1, len do\n\t\tlocal b = string.byte(s, i);\n\t\tif b >= string.byte(\"\
    a\") and b <= string.byte(\"z\") then\n\t\t\tb = b + offset;\n\t\t\tif b > string.byte(\"\
    z\") then\n\t\t\t\tb = b - string.byte(\"z\") + string.byte(\"a\") - 1;\n\t\t\t\
    end\n\t\telseif b >= string.byte(\"A\") and b <= string.byte(\"Z\") then\n\t\t\
    \tb = b + offset;\n\t\t\tif b > string.byte(\"Z\") then\n\t\t\t\tb = b - string.byte(\"\
    Z\") + string.byte(\"A\") - 1;\n\t\t\tend\n\t\tend\n\t\ts2 = s2 .. string.char(b);\n\
    \tend\n\treturn s2;\nend", "    local rotated_alphabet = string.gsub(string.lower(s),\
    \ \"[^a-z]\", \"\")\n    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n   \
    \ local new_string = \"\"\n    for i = 1, #rotated_alphabet do\n        local\
    \ char = string.sub(rotated_alphabet, i, i)\n        local position = string.find(alphabet,\
    \ char)\n        new_string = new_string .. string.sub(alphabet, position - 2,\
    \ position - 2)\n    end\n    return new_string\nend", "  local ret = {}\n  for\
    \ i = 1,#s do\n    local i = s:byte(i)\n    if (i >=65 and i <=90) then\n    \
    \  i = i+2\n      if (i > 90) then\n        i = i-26\n      end\n    elseif (i\
    \ >=97 and i <=122) then\n      i = i+2\n      if (i > 122) then\n        i =\
    \ i-26\n      end\n    end\n    ret[#ret+1] = string.char(i)\n  end\n  return\
    \ table.concat(ret)\nend", "  local alph = \"abcdefghijklmnopqrstuvwxyz\"\n  local\
    \ new_alph = alph:sub(1, 4) .. alph:sub(9, 26)\n  local new_string = \"\"\n  for\
    \ i=1, s:len() do\n    local char = s:sub(i, i)\n    local k = alph:find(char)\n\
    \    if k then\n      new_string = new_string .. new_alph:sub(k, k)\n    else\n\
    \      new_string = new_string .. char\n    end\n  end\n  return new_string\n\
    end", "\tlocal t = {}\n\tfor i = 1, string.len(s) do\n\t\tlocal c = string.sub(s,\
    \ i, i)\n\t\tif c == 'a' then\n\t\t\tc = 'c'\n\t\telseif c == 'b' then\n\t\t\t\
    c = 'd'\n\t\telseif c == 'c' then\n\t\t\tc = 'e'\n\t\telseif c == 'd' then\n\t\
    \t\tc = 'f'\n\t\telseif c == 'e' then\n\t\t\tc = 'g'\n\t\telseif c == 'f' then\n\
    \t\t\tc = 'h'\n\t\telseif c == 'g' then\n\t\t\tc = 'i'\n\t\telseif c == 'h' then\n\
    \t\t\tc = 'j'\n\t\telseif c == 'i' then\n\t\t\tc = 'k'\n\t\telseif c == 'j' then\n\
    \t\t\tc = 'l'\n\t\telseif c == 'k' then\n\t\t\tc = 'm'\n\t\telseif c == 'l' then\n\
    \t\t\tc = 'n'\n\t\telseif c == 'm' then\n\t\t\tc = 'o'\n\t\telseif c == 'n' then\n\
    \t\t\tc = 'p'\n\t\telseif c == 'o' then\n\t\t\tc = 'q'\n\t\telseif c == 'p' then\n\
    \t\t\tc = 'r'\n\t\telseif c == 'q' then\n\t\t\tc = 's'\n\t\telseif c == 'r' then\n\
    \t\t\tc = 't'\n\t\telseif c == 's' then\n\t\t\tc = 'u'\n\t\telseif c == 't' then\n\
    \t\t\tc = 'v'\n\t\telseif c == 'u' then\n\t\t\tc = 'w'\n\t\telseif c == 'v' then\n\
    \t\t\tc = 'x'\n\t\telseif c == 'w' then\n\t\t\tc = 'y'\n\t\telseif c == 'x' then\n\
    \t\t\tc =", "    local result = {}\n    for i = 1, #s do\n        local ch = s:sub(i,\
    \ i)\n        local ind = string.find(alphabet, ch)\n        local newInd = ind\
    \ + (2 * 2)\n        if newInd > 26 then\n            newInd = newInd - 26\n \
    \       end\n        result[i] = alphabet:sub(newInd, newInd)\n    end\n    return\
    \ table.concat(result)\nend", "    -- TODO: code goes here\nend", "    local result\
    \ = {}\n    for i = 1, #s do\n        local c = s:sub(i, i)\n        local n =\
    \ c:byte()\n        n = n + 4\n        c = string.char(n)\n        table.insert(result,\
    \ c)\n    end\n    return table.concat(result)\nend", "  local s_enc = \"\"\n\
    \  local s_len = string.len(s)\n  for i = 1, s_len do\n    local char = string.sub(s,\
    \ i, i)\n    local char_enc = string.sub(alphabet, string.find(alphabet, char)\
    \ + 4, string.find(alphabet, char) + 4)\n    s_enc = s_enc .. char_enc\n  end\n\
    \  return s_enc\nend", "    -- Write your code here\nend", "  local s = string.gsub(s,\
    \ \"a\", \"c\")\n  local s = string.gsub(s, \"b\", \"d\")\n  local s = string.gsub(s,\
    \ \"c\", \"e\")\n  local s = string.gsub(s, \"d\", \"f\")\n  local s = string.gsub(s,\
    \ \"e\", \"g\")\n  local s = string.gsub(s, \"f\", \"h\")\n  local s = string.gsub(s,\
    \ \"g\", \"i\")\n  local s = string.gsub(s, \"h\", \"j\")\n  local s = string.gsub(s,\
    \ \"i\", \"k\")\n  local s = string.gsub(s, \"j\", \"l\")\n  local s = string.gsub(s,\
    \ \"k\", \"m\")\n  local s = string.gsub(s, \"l\", \"n\")\n  local s = string.gsub(s,\
    \ \"m\", \"o\")\n  local s = string.gsub(s, \"n\", \"p\")\n  local s = string.gsub(s,\
    \ \"o\", \"q\")\n  local s = string.gsub(s, \"p\", \"r\")\n  local s = string.gsub(s,\
    \ \"q\", \"s\")\n  local s = string.gsub(s, \"r\", \"t\")\n  local s = string.gsub(s,\
    \ \"s\", \"u\")\n  local s = string.gsub(s, \"t\", \"v\")\n  local s = string.gsub(s,\
    \ \"u\", \"w\")\n  local s = string.gsub(s, \"v\", \"x\")\n  local s = string.gsub(s,\
    \ \"w\", \"y\")\n  local s = string.gsub(s, \"x\", \"z\")\n  local s = string.gsub(s,\
    \ \"y\", \"a\")\n  local s = string.gsub(s, \"z\", \"b\")\n  return s\nend", "\t\
    local encrypteddata = \"\"\n\tfor i = 1, #s do\n\t\tencrypteddata = encrypteddata\
    \ .. string.char(s:byte(i) + (2 * 2))\n\tend\n\treturn encrypteddata\nend", " \
    \  local encrypted_text = \"\"\n   local space = 0\n   for i=1, #s do\n      local\
    \ c = s:sub(i,i)\n      if c == \" \" then\n         space = space + 1\n     \
    \ else\n         local b = string.byte(c)\n         local shifted = b - 2 * 2\n\
    \         if shifted < string.byte(\"a\") then\n            shifted = shifted\
    \ + 26\n         end\n         c = string.char(shifted)\n      end\n      encrypted_text\
    \ = encrypted_text .. c\n   end\n   return encrypted_text, space\nend", "  local\
    \ a = {}\n  local len = string.len(s)\n  for i = 1, len do\n    local byte = string.byte(s,\
    \ i)\n    table.insert(a, byte)\n  end\n  local last = #a\n  local result = {}\n\
    \  for i = 1, last do\n    local b = a[i]\n    local next = a[i + 1]\n    local\
    \ new = b + next\n    table.insert(result, new)\n  end\n  return table.concat(result)\n\
    end", "    local s = s\n    local alpha = {\"a\", \"b\", \"c\", \"d\", \"e\",\
    \ \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    local\
    \ newAlpha = {}\n    local count = 0\n    local x = 0\n    local newS = \"\"\n\
    \    for i=1, #alpha do\n        if (x % 2 == 0) then\n            count = count\
    \ + 2\n        end\n        x = x + 1\n        newAlpha[i] = alpha[(i + count)\
    \ % #alpha + 1]\n    end\n    for j=1, #s do\n        for k=1, #alpha do\n   \
    \         if (s:sub(j, j) == alpha[k]) then\n                newS = newS .. newAlpha[k]\n\
    \            end\n        end\n    end\n    return newS\nend", "  local key =\
    \ {\n    ['a'] = 'c', ['b'] = 'd', ['c'] = 'e', ['d'] = 'f', ['e'] = 'g', ['f']\
    \ = 'h', ['g'] = 'i', ['h'] = 'j', ['i'] = 'k', ['j'] = 'l', ['k'] = 'm', ['l']\
    \ = 'n', ['m'] = 'o', ['n'] = 'p', ['o'] = 'q', ['p'] = 'r', ['q'] = 's', ['r']\
    \ = 't', ['s'] = 'u', ['t'] = 'v', ['u'] = 'w', ['v'] = 'x', ['w'] = 'y', ['x']\
    \ = 'z', ['y'] = 'a', ['z'] = 'b'\n  }\n  return (s:gsub('.', key))\nend", " \
    \   local alphabets = \"abcdefghijklmnopqrstuvwxyz\"\n    local len = string.len(alphabets)\n\
    \    local result = \"\"\n    for i = 1, string.len(s) do\n        local c = string.sub(s,\
    \ i, i)\n        local p = string.find(alphabets, c)\n        local idx = p\n\
    \        if p >= len - 2 then\n            idx = 2 * p - len\n        else\n \
    \           idx = 2 * p\n        end\n        result = result .. string.sub(alphabets,\
    \ idx, idx)\n    end\n    return result\nend", "    local alphabet = { \"a\",\
    \ \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\" }\n    local s = string.lower(s)\n    local output = \"\"\
    \n    local i = 0\n    while i < string.len(s) do\n        local c = string.sub(s,\
    \ i, i)\n        if c == \" \" then\n            output = output .. \" \"\n  \
    \      else\n            local value = 0\n            local found = false\n  \
    \          local j = 0\n            while not found and j < table.getn(alphabet)\
    \ do\n                if alphabet[j] == c then\n                    value = j\n\
    \                    found = true\n                end\n                j = j\
    \ + 1\n            end\n            output = output .. alphabet[(value + (2 *\
    \ 2)) % 26]\n        end\n        i = i + 1\n    end\n    return output\nend",
  "  local alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n \
    \ local alphabetLen = #alphabet\n  local alphabetRotated = alphabet:sub(5) ..\
    \ alphabet:sub(1, 4)\n  return s:gsub(\".\", function(letter)\n    local rotIndex\
    \ = alphabet:find(letter)\n    if rotIndex then\n      letter = alphabetRotated:sub(rotIndex,\
    \ rotIndex)\n    end\n    return letter\n  end)\nend", "   return encrypt_decrypt(s,2)\n\
    end", "  s = string.lower(s)\n  local i = 1\n  local result = \"\"\n  while i\
    \ <= #s do\n    local ch = string.byte(s, i)\n    if (ch >= string.byte(\"a\"\
    ) and ch <= string.byte(\"z\")) then\n      ch = ch + 2\n      if ch > string.byte(\"\
    z\") then\n        ch = ch - 26\n      end\n    end\n    result = result .. string.char(ch)\n\
    \    i = i + 1\n  end\n  return result\nend", "    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    local out = {}\n    local str = string.lower(s)\n    for c in string.gmatch(str,\
    \ \".\") do\n        local pos = string.find(alphabet, c)\n        if pos then\n\
    \            table.insert(out, string.sub(alphabet, pos + 2, pos + 2))\n     \
    \   else\n            table.insert(out, c)\n        end\n    end\n    return table.concat(out)\n\
    end", "    local enc = \"\"\n    for i = 1, #s do\n        enc = enc .. string.char(string.byte(s,\
    \ i) + 4)\n    end\n    return enc\nend", "    -- empty string\n    if string.len(s)\
    \ == 0 then\n        return s\n    end\n    -- create a table\n    local tbl =\
    \ {}\n    -- define the table and add content to it\n    for i=1,26 do\n     \
    \   tbl[i] = string.char(i+64)\n    end\n    tbl[27] = \" \"\n    tbl[28] = \"\
    '\"\n    -- create a dictionary with key values that can be accessed\n    local\
    \ dict = {}\n    for i=1,28 do\n        dict[tbl[i]] = i\n    end\n    -- holds\
    \ the encrypted string\n    local encrypt = {}\n    -- loop through the string\n\
    \    for i=1,string.len(s) do\n        -- position of the index of the string\
    \ in the dictionary\n        local index = dict[string.sub(s,i,i)]\n        --\
    \ rotate index\n        if index ~= nil then\n            local newindex = index\
    \ + i*2\n            -- constraint: if the index goes out of the range of the\
    \ alphabet then loop it around\n            if newindex > 28 then\n          \
    \      newindex = newindex - 28\n            end\n            encrypt[i] = tbl[newindex]\n\
    \        end\n    end\n    -- join the strings of the encrypted message into one\
    \ string\n    return table.concat(encrypt,\"\")\nend", "    local encrypted_string\
    \ = ''\n    for i = 1, #s do\n        local character = s:sub(i, i)\n        if\
    \ character:match('%a') then\n            local alphabet_position = (character:byte()\
    \ - 97)\n            local encrypted_position = (alphabet_position + 2) * 2 -\
    \ 1\n            local encrypted_character = string.char(97 + encrypted_position)\n\
    \            encrypted_string = encrypted_string .. encrypted_character\n    \
    \    else\n            encrypted_string = encrypted_string .. character\n    \
    \    end\n    end\n    return encrypted_string\nend", "  local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \  local newString = ''\n  for i = 1, #s do\n    local curLetter = s:sub(i,i)\n\
    \    local index = 1\n    for j = 1, #alphabet do\n      if curLetter == alphabet[j]\
    \ then\n        index = j\n      end\n    end\n    local newIndex = index + 2\
    \ * 2\n    if newIndex > #alphabet then\n      newIndex = newIndex - #alphabet\n\
    \    end\n    local newLetter = alphabet[newIndex]\n    newString = newString\
    \ .. newLetter\n  end\n  return newString\nend", "  -- stuff here\nend", "  --\
    \ your implementation goes here\nend", "  -- Get length of string\n  local len\
    \ = string.len(s)\n  -- Create empty string\n  local e = \"\"\n  -- Iterate over\
    \ each character\n  for i = 1, len do\n    -- Get character at position i in string\
    \ s\n    local c = string.sub(s, i, i)\n    -- Get the ASCII value of the character\n\
    \    local ascii = string.byte(c)\n    -- Add 2 to ASCII value\n    ascii = ascii\
    \ + 2\n    -- Convert back to character\n    c = string.char(ascii)\n    -- Add\
    \ to our encrypted string\n    e = e .. c\n  end\n  -- Return our encrypted string\n\
    \  return e\nend", "  local alpha = 'abcdefghijklmnopqrstuvwxyz'\n  local result\
    \ = ''\n  for i = 1, #s do\n    local c = s:sub(i,i)\n    local p = alpha:find(c)\n\
    \    if p then\n      p = p + 2 * 2\n      if p > #alpha then\n        p = p -\
    \ #alpha\n      end\n      c = alpha:sub(p,p)\n    end\n    result = result ..\
    \ c\n  end\n  return result\nend", "   s = string.lower(s)\n   local function\
    \ map(c)\n      if c >= string.byte('a') and c <= string.byte('z') then\n    \
    \     c = c + 2\n         if c > string.byte('z') then\n            c = c - 26\n\
    \         end\n      end\n      return string.char(c)\n   end\n   return string.gsub(s,\
    \ \"(.)\", map)\nend\nassert(encrypt(\"cats\") == \"ecwv\")\nassert(encrypt(\"\
    cabbages\") == \"edccfguio\")", "    local result = \"\"\n    for i = 1, #s do\n\
    \        local c = s:sub(i,i)\n        if c == ' ' then\n            result =\
    \ result .. c\n        else\n            local index = table.indexof(alphabet,\
    \ c)\n            index = (index + (2 * 2)) % #alphabet\n            result =\
    \ result .. alphabet[index + 1]\n        end\n    end\n    return result\nend",
  "    local plaintext = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\",\
    \ \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    local ciphertext = {\"\
    c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\
    y\", \"z\", \"a\", \"b\"}\n    local num_upper = 0\n    local length = string.len(s)\n\
    \    local new_string = \"\"\n    for i = 1, length do\n        if string.find(s,\
    \ string.upper(s)) then\n            num_upper = num_upper + 1\n        end\n\
    \    end\n    for i = 1, length do\n        local c = string.sub(s, i, i)\n  \
    \      local flag = 0\n        for j = 1, 26 do\n            if c == plaintext[j]\
    \ then\n                c = ciphertext[j]\n                flag = 1\n        \
    \        break\n            end\n        end\n        if flag == 0 then\n    \
    \        for j = 1, 26 do\n                if c == string.upper(plaintext[j])\
    \ then\n                    c = string.upper(ciphertext[j])\n                \
    \    break\n                end\n            end\n        end\n        new_string\
    \ = new_string .. c\n    end\n    return new_string\nend", "  -- implement your\
    \ code here\n  local string.gsub(s, \" \", \"\")\n  local letters = {}\n  for\
    \ i = 1, #s do\n    table.insert(letters, s:sub(i, i))\n  end\n  local encrypted\
    \ = \"\"\n  for i = 1, #letters do\n    local letter = letters[i]\n    local ascii_code\
    \ = string.byte(letter)\n    if ascii_code == 90 then\n      ascii_code = 65\n\
    \    elseif ascii_code == 122 then\n      ascii_code = 97\n    else\n      ascii_code\
    \ = ascii_code + 2\n    end\n    letter = string.char(ascii_code)\n    encrypted\
    \ = encrypted .. letter\n  end\n  return encrypted\nend", "    local n = ''\n\
    \    for i = 1, #s do\n        local c = s:byte(i)\n        if c >= 65 and c <=\
    \ 90 then\n            n = n .. string.char((c - 65 + 1) % 26 + 65)\n        elseif\
    \ c >= 97 and c <= 122 then\n            n = n .. string.char((c - 97 + 1) % 26\
    \ + 97)\n        else\n            n = n .. string.char(c)\n        end\n    end\n\
    \    return n\nend", "   local upperAlphabet = getUpperAlphabet()\n   local lowerAlphabet\
    \ = getLowerAlphabet()\n   local encryptedString = ''\n   local sLength = string.len(s)\n\
    \   local alphabetLength = string.len(upperAlphabet)\n   local isUpper = false\n\
    \   local newIndex = 0\n   local sIndex = 1\n   local alphabetIndex = 1\n   local\
    \ isLetter = false\n   local isSpace = false\n   local newChar = ''\n   while\
    \ sIndex <= sLength do\n      --print('sIndex: ' .. sIndex)\n      isUpper = string.match(s,\
    \ '[A-Z]')\n      if isUpper then\n         isLetter = string.match(s:sub(sIndex,\
    \ sIndex), '[A-Z]')\n         if isLetter then\n            alphabetIndex = 1\n\
    \            while alphabetIndex <= alphabetLength do\n               if s:sub(sIndex,\
    \ sIndex) == upperAlphabet:sub(alphabetIndex, alphabetIndex) then\n          \
    \        newIndex = alphabetIndex + 2\n                  if newIndex > alphabetLength\
    \ then\n                     newIndex = newIndex - alphabetLength\n          \
    \        end\n                  newChar = upperAlphabet:sub(newIndex, newIndex)\n\
    \                  encryptedString = encryptedString .. newChar\n            \
    \      --print('upper char found: ' .. s:sub(sIndex, sIndex))\n              \
    \    --print('encrypted char: ' .. newChar)\n               end\n            \
    \   alphabetIndex = alphabetIndex + 1\n            end\n         else\n      \
    \      isSpace = string.match(s:sub(sIndex, sIndex), ' ')\n            if isSpace\
    \ then\n               encryptedString = encryptedString .. ' '\n            end\n\
    \         end\n      else\n         isLetter = string.match(s:sub(sIndex, sIndex),\
    \ '[a-z]')\n         if isLetter then\n            alphabetIndex = 1\n       \
    \     while alphabetIndex <= alphabetLength do\n               if s:sub(sIndex,\
    \ sIndex) == lowerAlphabet:sub(alphabetIndex, alphabetIndex) then\n          \
    \        newIndex = alphabetIndex + 2\n                  if newIndex > alphabetLength\
    \ then\n                     newIndex = newIndex - alphabetLength\n          \
    \        end\n                  newChar = lowerAlphabet:sub(newIndex, newIndex)\n\
    \                  encryptedString", end, "  local enc = ''\n  for i = 1, #s do\n\
    \    local c = s:sub(i,i)\n    if (c >= 'a' and c <= 'z') then\n      enc = enc\
    \ .. string.char(97 + ((string.byte(c) - 97 + 2*2) % 26))\n    elseif (c >= 'A'\
    \ and c <= 'Z') then\n      enc = enc .. string.char(65 + ((string.byte(c) - 65\
    \ + 2*2) % 26))\n    else\n      enc = enc .. c\n    end\n  end\n  return enc\n\
    end\nprint(encrypt('Hello World'))\nprint(encrypt('Ruby is cool'))\nprint(encrypt('abc'))\n\
    print(encrypt('xyz'))\nprint(encrypt('XYZ'))\nprint(encrypt('abc123'))", "  --\
    \ YOUR CODE HERE\nend", "\treturn s:gsub(\".\", function(c)\n\t\treturn string.char(string.byte(c)\
    \ + (((string.byte(c) - 97) % 26) * 2))\n\tend)\nend", "\tlocal a = {}\n\tlocal\
    \ i = 1\n\tfor c in s:gmatch'.' do\n\t\tlocal j = string.byte(c)\n\t\tif j >=\
    \ 65 and j <= 90 then\n\t\t\ta[i] = string.char((j - 65 + (26 - (2 * 2))) % 26\
    \ + 65)\n\t\telseif j >= 97 and j <= 122 then\n\t\t\ta[i] = string.char((j - 97\
    \ + (26 - (2 * 2))) % 26 + 97)\n\t\telse\n\t\t\ta[i] = c\n\t\tend\n\t\ti = i +\
    \ 1\n\tend\n\treturn table.concat(a)\nend", "   local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \   local s = s:lower()\n   local t = {}\n   for l in s:gmatch(\".\") do\n   \
    \   for i, al in ipairs(alphabet) do\n         if l == al then\n            if\
    \ i > 23 then\n               t[#t+1] = alphabet[i - 23]\n            elseif i\
    \ > 21 then\n               t[#t+1] = alphabet[i - 21]\n            else\n   \
    \            t[#t+1] = alphabet[i + 2]\n            end\n         end\n      end\n\
    \   end\n   return table.concat(t)\nend", "\tlocal t = {}\n\tfor i = 1, #s do\n\
    \t\tlocal c = s:sub(i, i)\n\t\tlocal n = string.byte(c)\n\t\tif c == ' ' then\n\
    \t\t\ttable.insert(t, ' ')\n\t\telseif c == 'x' then\n\t\t\ttable.insert(t, 'a')\n\
    \t\telseif c == 'y' then\n\t\t\ttable.insert(t, 'b')\n\t\telseif c == 'z' then\n\
    \t\t\ttable.insert(t, 'c')\n\t\telse\n\t\t\tlocal d = (n + 2) % #s\n\t\t\ttable.insert(t,\
    \ string.char(d))\n\t\tend\n\tend\n\treturn table.concat(t)\nend\nprint(encrypt('foo\
    \ bar baz')) --> hqq cds dcb\nprint(encrypt('foobarbaz')) --> hqqcdsdcb\nprint(encrypt('z'))\
    \ --> b\nprint(encrypt('xyz')) --> abc", "\tlocal letters = {\"a\", \"b\", \"\
    c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\
    y\", \"z\"}\n\tlocal t = {}\n\tlocal x = string.len(s)\n\tfor i = 1, x do\n\t\t\
    t[i] = string.sub(s, i, i)\n\tend\n\tlocal result = \"\"\n\tfor i = 1, x do\n\t\
    \tlocal k = string.lower(t[i])\n\t\tlocal flag = true\n\t\tfor j = 1, 26 do\n\t\
    \t\tif k == letters[j] then\n\t\t\t\tif j >= 2 and j <= 12 then\n\t\t\t\t\tk =\
    \ letters[j + 10]\n\t\t\t\telseif j > 12 and j <= 24 then\n\t\t\t\t\tk = letters[j\
    \ - 10]\n\t\t\t\telseif j == 1 then\n\t\t\t\t\tk = letters[3]\n\t\t\t\telseif\
    \ j == 25 then\n\t\t\t\t\tk = letters[23]\n\t\t\t\telseif j == 26 then\n\t\t\t\
    \t\tk = letters[24]\n\t\t\t\tend\n\t\t\t\tif string.lower(t[i]) ~= t[i] then\n\
    \t\t\t\t\tk = string.upper(k)\n\t\t\t\tend\n\t\t\t\tresult = result .. k\n\t\t\
    \t\tflag = false\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\tif flag then\n\t\t\t\
    result = result .. t[i]\n\t\tend\n\tend\n\treturn result\nend\nprint(encrypt(\"\
    abcd efgh ijkl mnop qrst uvwx yzAB CDEF GHIJ KLMN OPQR STUV WXYZ abcd efgh ijkl\
    \ mnop qrst uvwx yz\"))", "    local encryptedText = \"\"\n    for i = 1, #s do\n\
    \        local char = s:sub(i, i)\n        local charCode = string.byte(char)\n\
    \        local encryptedCharCode = 0\n        if charCode >= 65 and charCode <=\
    \ 90 then\n            encryptedCharCode = charCode + (2 * 2)\n            if\
    \ encryptedCharCode > 90 then\n                encryptedCharCode = encryptedCharCode\
    \ - 26\n            end\n        elseif charCode >= 97 and charCode <= 122 then\n\
    \            encryptedCharCode = charCode + (2 * 2)\n            if encryptedCharCode\
    \ > 122 then\n                encryptedCharCode = encryptedCharCode - 26\n   \
    \         end\n        else\n            encryptedCharCode = charCode\n      \
    \  end\n        encryptedText = encryptedText .. string.char(encryptedCharCode)\n\
    \    end\n    return encryptedText\nend", "    s = s:lower()\n    local encrypted\
    \ = \"\"\n    for i = 1, #s do\n        local c = s:sub(i, i)\n        if c >=\
    \ \"a\" and c <= \"z\" then\n            local c2 = c:byte() + 2 * 2\n       \
    \     if c2 > \"z\":byte() then\n                c2 = c2 - 26\n            end\n\
    \            encrypted = encrypted .. string.char(c2)\n        else\n        \
    \    encrypted = encrypted .. c\n        end\n    end\n    return encrypted\n\
    end", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    local a = string.sub(alphabet,\
    \ 1, 2)\n    local b = string.sub(alphabet, 3)\n    alphabet = b .. a\n    a =\
    \ string.sub(alphabet, 1, 2)\n    b = string.sub(alphabet, 3)\n    alphabet =\
    \ b .. a\n    return string.gsub(s, \"%a\", alphabet)\nend\nprint(encrypt('dzs'))",
  "  local out = {}\n  for c in s:gmatch\".\" do\n    out[#out+1] = string.char((string.byte(c)\
    \ + 2 * 2 - 65) % 26 + 65)\n  end\n  return table.concat(out)\nend", "\tlocal\
    \ function rotate(i)\n\t\treturn (i+4)%26\n\tend\n\t\n\tlocal function enc(c)\n\
    \t\tlocal char\n\t\tif c:byte() >= string.byte('a') and c:byte() <= string.byte('z')\
    \ then\n\t\t\tlocal r\n\t\t\tr = rotate(c:byte() - string.byte('a'))\n\t\t\tchar\
    \ = string.char(string.byte('a') + r)\n\t\telseif c:byte() >= string.byte('A')\
    \ and c:byte() <= string.byte('Z') then\n\t\t\tlocal r\n\t\t\tr = rotate(c:byte()\
    \ - string.byte('A'))\n\t\t\tchar = string.char(string.byte('A') + r)\n\t\telse\n\
    \t\t\tchar = c\n\t\tend\n\t\treturn char\n\tend\n\t\n\tlocal function decrypt(s)\n\
    \t\tlocal function rotate(i)\n\t\t\treturn (i-4)%26\n\t\tend\n\t\t\n\t\tlocal\
    \ function dec(c)\n\t\t\tlocal char\n\t\t\tif c:byte() >= string.byte('a') and\
    \ c:byte() <= string.byte('z') then\n\t\t\t\tlocal r\n\t\t\t\tr = rotate(c:byte()\
    \ - string.byte('a'))\n\t\t\t\tchar = string.char(string.byte('a') + r)\n\t\t\t\
    elseif c:byte() >= string.byte('A') and c:byte() <= string.byte('Z') then\n\t\t\
    \t\tlocal r\n\t\t\t\tr = rotate(c:byte() - string.byte('A'))\n\t\t\t\tchar = string.char(string.byte('A')\
    \ + r)\n\t\t\telse\n\t\t\t\tchar = c\n\t\t\tend\n\t\t\treturn char\n\t\tend\n\t\
    \t\n\t\treturn string.gsub(s, '.', dec)\n\tend\n\t\n\treturn string.gsub(s, '.',\
    \ enc)\nend", "\tlocal answer = \"\"\n\tfor i = 1, #s do\n\t\tlocal c = s:sub(i,i)\n\
    \t\tlocal b = c:byte()\n\t\tlocal shifted = b + 4\n\t\tif shifted > 126 then\n\
    \t\t\tshifted = shifted - 94\n\t\tend\n\t\tlocal letter = string.char(shifted)\n\
    \t\tanswer = answer .. letter\n\tend\n\treturn answer\nend", "  -- do something\n\
    end", "  local result = \"\"\n  for i = 1, #s do\n    local c = s:sub(i,i)\n \
    \   if c >= \"a\" and c <= \"z\" then\n      local index = c:byte() - 97\n   \
    \   local newIndex = (index + (2 * 2)) % 26\n      result = result .. string.char(newIndex\
    \ + 97)\n    elseif c >= \"A\" and c <= \"Z\" then\n      local index = c:byte()\
    \ - 65\n      local newIndex = (index + (2 * 2)) % 26\n      result = result ..\
    \ string.char(newIndex + 65)\n    else\n      result = result .. c\n    end\n\
    \  end\n  return result\nend", "\tlocal t = {}\n\tlocal s2 = s:gsub('%w', function(c)\
    \ \n\t\treturn string.char(string.byte(c) + 2)\n\tend)\n\treturn s2\nend", " \
    \   local alphabet = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\",\
    \ \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"\
    , \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    local encrypted = \"\"\
    \n    for i = 1, #s do\n        local _, index = string.find(s, string.sub(s,\
    \ i, i))\n        if index ~= nil then\n            if index >= 19 then\n    \
    \            encrypted = encrypted .. alphabet[index - 18]\n            else\n\
    \                encrypted = encrypted .. alphabet[index + 8]\n            end\n\
    \        end\n    end\n    return encrypted\nend", "\tlocal encrypted = \"\"\n\
    \tlocal alpha = \"abcdefghijklmnopqrstuvwxyz\"\n\tlocal alphabet = alpha .. alpha\n\
    \tlocal z = alphabet:find(\"a\")\n\tfor i = 1, #s do\n\t\tlocal c = s:sub(i,i)\n\
    \t\tif c:find(\"%w\") then\n\t\t\tencrypted = encrypted .. alphabet:sub(2*(z -\
    \ c:byte()) + 1, 2*(z - c:byte()) + 2)\n\t\telse\n\t\t\tencrypted = encrypted\
    \ .. c\n\t\tend\n\tend\n\treturn encrypted\nend", "  --[[\n  The first letter\
    \ in the alphabet should be replaced with the 3rd letter,\n  the second letter\
    \ with the 4th, and so on, until the 25th letter, which\n  should be replaced\
    \ with the 1st letter.\n  The 26th letter should be replaced with the 2nd letter,\
    \ and so on, until\n  the end of the string is reached.\n  --]]\n  --[[\n  For\
    \ example, if the string \"hello\" is given, return the string \"ifmmp\"\n  --]]\n\
    \  local letters = {\n    \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"\
    h\", \"i\", \"j\", \"k\", \"l\", \"m\",\n    \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\n  }\n  local str = \"\
    \"\n  for i = 1, #s do\n    for j = 1, #letters do\n      if s:sub(i, i) == letters[j]\
    \ then\n        str = str .. letters[(j * 2) - 1]\n      end\n    end\n  end\n\
    \  return str\nend", "  -- TODO\nend", end, "\tlocal enc_str = {}\n\tfor i=1,string.len(s)\
    \ do\n\t\tlocal char = string.sub(s,i,i)\n\t\tlocal new_char = string.byte(char)\
    \ + 2*2\n\t\ttable.insert(enc_str,string.char(new_char))\n\tend\n\tenc_str = table.concat(enc_str)\n\
    \treturn enc_str\nend", "    -- ...\nend", end, "\tlocal str = {}\n\tfor i=1,\
    \ string.len(s) do\n\t\tlocal c = string.byte(s, i)\n\t\tif c >= 65 and c <= 90\
    \ then\n\t\t\tc = c + 2\n\t\t\tif c > 90 then\n\t\t\t\tc = c - 26\n\t\t\tend\n\
    \t\telseif c >= 97 and c <= 122 then\n\t\t\tc = c + 2\n\t\t\tif c > 122 then\n\
    \t\t\t\tc = c - 26\n\t\t\tend\n\t\tend\n\t\tstr[i] = string.char(c)\n\tend\n\t\
    return table.concat(str)\nend", "    local result = \"\"\n    for i = 1, #s do\n\
    \        local c = s:sub(i,i)\n        result = result .. (letters[c] or c)\n\
    \    end\n    return result\nend", "    local output = \"\"\n    for i = 1, #s\
    \ do\n        local c = s:sub(i,i)\n        local byte = string.byte(c)\n    \
    \    local encrypted_byte = nil\n        if byte >= 65 and byte <= 90 then\n \
    \           encrypted_byte = ((byte - 65 + 26 - 52) % 26) + 65\n        elseif\
    \ byte >= 97 and byte <= 122 then\n            encrypted_byte = ((byte - 97 +\
    \ 26 - 52) % 26) + 97\n        else\n            encrypted_byte = byte\n     \
    \   end\n        output = output .. string.char(encrypted_byte)\n    end\n   \
    \ return output\nend", "    local alphabet = {}\n    for i = 65,90 do\n      \
    \  table.insert(alphabet,string.char(i))\n    end\n    local new_s = \"\"\n  \
    \  for i = 1,#s do\n        local index = 0\n        for j = 1,#alphabet do\n\
    \            if s:sub(i,i) == alphabet[j] then\n                index = j\n  \
    \          end\n        end\n        if index + (2*2) > #alphabet then\n     \
    \       index = index + (2*2) - 26\n        else\n            index = index +\
    \ (2*2)\n        end\n        new_s = new_s .. alphabet[index]\n    end\n    return\
    \ new_s\nend\nprint(encrypt(\"HELLO\")) -- JGNNQ", "\tlocal result = \"\"\n\t\n\
    \tfor i = 1, #s do\n\t\tlocal c = s:sub(i, i)\n\t\tif c:find(\"%w\") then\n\t\t\
    \tlocal n = c:byte()\n\t\t\tlocal m = (n - 97) * 2 + 97\n\t\t\tlocal r = string.char(m)\n\
    \t\t\tresult = result .. r\n\t\telse\n\t\t\tresult = result .. c\n\t\tend\n\t\
    end\n\t\n\treturn result\nend", "  local alphabet = {\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    }\n  local newWord = {}\n  for i=1, #s do\n    for x=1, #alphabet do\n      if\
    \ s:sub(i,i) == alphabet[x] then\n        if alphabet[x+2] == nil then\n     \
    \     table.insert(newWord, alphabet[x+2-26])\n        else\n          table.insert(newWord,\
    \ alphabet[x+2])\n        end\n      end\n    end\n  end\n  return table.concat(newWord)\n\
    end", "    s = s:lower()\n    local t = {}\n    for i = 1, #s do\n        local\
    \ c = s:sub(i, i)\n        if c >= 'a' and c <= 'z' then\n            local n\
    \ = c:byte() - 'a':byte() + 1 + 2*2\n            while n > 26 do\n           \
    \     n = n - 26\n            end\n            t[#t+1] = string.char(n + 'a':byte()\
    \ - 1)\n        else\n            t[#t+1] = c\n        end\n    end\n    return\
    \ table.concat(t)\nend\nassert(encrypt(\"hello\") == \"jgnnq\")\nassert(encrypt(\"\
    \") == \"\")\nassert(encrypt(\"HELLO\") == \"JGNNQ\")\nassert(encrypt(\"hello\
    \ world\") == \"jgnnq yqtnf\")\nassert(encrypt(\"hello world!\") == \"jgnnq yqtnf!\"\
    )\nprint(\"tests passed\")", "\tlocal t = {}\n\tfor i=1,#s do\n\t\tlocal c = s:sub(i,i)\n\
    \t\tif c==\" \" then\n\t\t\ttable.insert(t,c)\n\t\telse\n\t\t\ttable.insert(t,\
    \ string.char(string.byte(c) + 2*2))\n\t\tend\n\tend\n\treturn table.concat(t)\n\
    end", "    -- Initialize an empty string to store our encrypted message\n    local\
    \ encstr = \"\"\n    -- For each letter in our string, add it to our encrypted\
    \ string.\n    -- Encrypt the letter based on our encryption rules\n    for i\
    \ = 1, #s do\n        -- Get the ASCII value for the letter and subtract it from\
    \ the \n        -- ASCII value for 'a'.\n        local l = s:sub(i, i)\n     \
    \   local c = l:byte() - 'a':byte()\n        -- The encrypted value is based on\
    \ the rule.\n        local enc = (c * 2 + 2) % 26\n        -- Add the encrypted\
    \ letter to our encrypted string\n        encstr = encstr .. string.char(enc +\
    \ 'a':byte())\n    end\n    -- Return the encrypted string\n    return encstr\n\
    end", "    local t = {}\n    for i = 1, string.len(s) do\n        local c = string.sub(s,\
    \ i, i)\n        local o = string.byte(c)\n        if o >= 65 and o <= 90 then\n\
    \            o = o + 2\n            if o > 90 then\n                o = o - 26\n\
    \            end\n        elseif o >= 97 and o <= 122 then\n            o = o\
    \ + 2\n            if o > 122 then\n                o = o - 26\n            end\n\
    \        end\n        t[i] = string.char(o)\n    end\n    return table.concat(t)\n\
    end", "    local function encryptChr(c)\n        local a = string.byte('a')\n\
    \        local z = string.byte('z')\n        local charCode = string.byte(c)\n\
    \        charCode = charCode + 4\n        if charCode > z then\n            charCode\
    \ = a + (charCode - z) - 1\n        end\n        return string.char(charCode)\n\
    \    end\n    local encrypted = ''\n    for c in s:gmatch('.') do\n        encrypted\
    \ = encrypted .. encryptChr(c)\n    end\n    return encrypted\nend", "  local\
    \ res = {}\n  local alphabet = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\
    , \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n  for i = 1, #s do\n\
    \    local c = s:sub(i,i)\n    for j = 1, #alphabet do\n      if c == alphabet[j]\
    \ then\n        res[i] = alphabet[(j+2)%#alphabet+1]\n      end\n    end\n  end\n\
    \  return table.concat(res)\nend", "    local strLen = string.len(s)\n    local\
    \ encryptedStr = \"\"\n    for i = 1, strLen do\n        local strChar = string.sub(s,\
    \ i, i)\n        local encChar = string.char(string.byte(strChar) + 4)\n     \
    \   encryptedStr = encryptedStr .. encChar\n    end\n    return encryptedStr\n\
    end", "\tlocal new_string = {}\n\tlocal alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \tlocal index = 0\n\tfor i = 1, #s do\n\t\tindex = 0\n\t\tfor j = 1, #alphabet\
    \ do\n\t\t\tif s:sub(i,i) == alphabet[j] then\n\t\t\t\tindex = j + 2\n\t\t\t\t\
    break\n\t\t\tend\n\t\tend\n\t\tif index > 0 then\n\t\t\ttable.insert(new_string,\
    \ alphabet[index])\n\t\telse\n\t\t\ttable.insert(new_string, s:sub(i,i))\n\t\t\
    end\n\tend\n\treturn table.concat(new_string)\nend", "  -- Split string into an\
    \ array of characters\n  local characters = {}\n  for c in s:gmatch(\".\") do\n\
    \    table.insert(characters, c)\n  end", "    -- create a string with all the\
    \ letters and spaces of the alphabet.\n    local alphabet = \" abcdefghijklmnopqrstuvwxyz\"\
    \n    -- create a table where each letter will be a value keyed by the location\n\
    \    -- of the letter in the alphabet.\n    local cipher = {}\n    -- for each\
    \ letter in the alphabet string\n    for i = 1, #alphabet do\n        -- add the\
    \ value to the table such that the key is the location of\n        -- the letter\
    \ in the alphabet string and the value is the letter in\n        -- the string\
    \ and the value is the location of the letter in the\n        -- alphabet.\n \
    \       cipher[i] = alphabet:sub(i, i)\n    end\n    -- create a new string to\
    \ store the encrypted message.\n    local encrypted_message = \"\"\n    -- for\
    \ each letter in the string to be encrypted\n    for letter in s:gmatch(\".\"\
    ) do\n        -- if the letter is a space.\n        if letter == \" \" then\n\
    \            -- add a space to the encrypted message\n            encrypted_message\
    \ = encrypted_message .. \" \"\n        -- else\n        else\n            --\
    \ create a local variable to store the location of the letter in\n           \
    \ -- the alphabet.\n            local x = 0\n            -- for each letter in\
    \ the alphabet\n            for i = 1, #alphabet do\n                -- if the\
    \ letter in the alphabet is the same as the current\n                -- letter\
    \ in the string to be encrypted\n                if letter == alphabet:sub(i,\
    \ i) then\n                    -- then set the local variable x to that location\
    \ in the\n                    -- alphabet.\n                    x = i\n      \
    \          end\n            end\n            -- add the cipher letter at that\
    \ location to the encrypted\n            -- message.\n            encrypted_message\
    \ = encrypted_message .. cipher[x + (2 * 2)]\n        end\n    end\n    -- return\
    \ the encrypted message.\n    return encrypted_message\nend", "    s = s:lower()\n\
    \    local ans = {}\n    for i = 1, #s do\n        local c = s:sub(i, i)\n   \
    \     if c == 'z' then\n            c = 'b'\n        elseif c == 'y' then\n  \
    \          c = 'a'\n        else\n            c = string.char(string.byte(c) +\
    \ 2)\n        end\n        ans[#ans + 1] = c\n    end\n    return table.concat(ans)\n\
    end", "    local s2 = \"\"\n    for i = 1, #s do\n        local c = s:sub(i,i)\n\
    \        if c >= \"a\" and c <= \"z\" then\n            c = string.char(((c:byte()\
    \ - 97 + (26-4)) % 26) + 97)\n        elseif c >= \"A\" and c <= \"Z\" then\n\
    \            c = string.char(((c:byte() - 65 + (26-4)) % 26) + 65)\n        end\n\
    \        s2 = s2 .. c\n    end\n    return s2\nend", "    --\nend", "  local out\
    \ = {}\n  for i = 1,#s do\n    local c = s:sub(i,i)\n    if c:match('[a-z]') then\n\
    \      out[#out+1] = string.char((c:byte() - 97 + 2*2) % 26 + 97)\n    elseif\
    \ c:match('[A-Z]') then\n      out[#out+1] = string.char((c:byte() - 65 + 2*2)\
    \ % 26 + 65)\n    else\n      out[#out+1] = c\n    end\n  end\n  return table.concat(out)\n\
    end", "   -- Convert to lowercase\n   s = s:lower()\n   local result = {}\n  \
    \ for c in s:gmatch(\".\") do\n      if c:byte() >= 97 and c:byte() <= 122 then\n\
    \         -- Lowercase\n         result[#result+1] = string.char((c:byte() - 97\
    \ + 2*2) % 26 + 97)\n      elseif c:byte() >= 65 and c:byte() <= 90 then\n   \
    \      -- Uppercase\n         result[#result+1] = string.char((c:byte() - 65 +\
    \ 2*2) % 26 + 65)\n      else\n         -- Other character (e.g. punctuation mark)\n\
    \         result[#result+1] = c\n      end\n   end\n   return table.concat(result)\n\
    end", "  local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  local new_alphabet =\
    \ alphabet:sub(3) .. alphabet:sub(1,2)\n  local function encrypt_char(c)\n   \
    \ if c:match('%a') then\n      local index = alphabet:find(c)\n      return new_alphabet:sub(index,\
    \ index)\n    else\n      return c\n    end\n  end\n  return s:gsub('%a', encrypt_char)\n\
    end", "  local cipher_table = {}\n  local ascii_table = {string.byte(s,1,#s)}\n\
    \  local mod = 0\n  for i = 1,#ascii_table do\n    if ascii_table[i] == 32 then\n\
    \      table.insert(cipher_table, ascii_table[i])\n    else\n      mod = (ascii_table[i]\
    \ - 65)%26 + 65\n      if mod == 64 then\n        mod = 90\n      elseif mod ==\
    \ 91 then\n        mod = 65\n      end\n      table.insert(cipher_table, mod)\n\
    \    end\n  end\n  return string.char(unpack(cipher_table))\nend", "    local\
    \ result = \"\"\n    local n = string.len(s)\n    for i = 1, n do\n        local\
    \ c = string.sub(s, i, i)\n        local code = string.byte(c)\n        local\
    \ shifted = code + 2 * 2\n        local char = string.char(shifted)\n        result\
    \ = result .. char\n    end\n    return result\nend", "\tlocal t = {}\n\tfor c\
    \ in s:gmatch(\".\") do\n\t\tlocal b = c:byte()\n\t\tif b >= 65 and b <= 90 then\n\
    \t\t\tt[#t+1] = string.char(((b-65)*2 + 2) % 26 + 65)\n\t\telseif b >= 97 and\
    \ b <= 122 then\n\t\t\tt[#t+1] = string.char(((b-97)*2 + 2) % 26 + 97)\n\t\telse\n\
    \t\t\tt[#t+1] = c\n\t\tend\n\tend\n\treturn table.concat(t)\nend", "  local newStr\
    \ = \"\"\n  for i = 1, #s do\n    local c = s:sub(i,i)\n    if c == \"z\" then\n\
    \      newStr = newStr .. \"b\"\n    elseif c == \"y\" then\n      newStr = newStr\
    \ .. \"a\"\n    else\n      newStr = newStr .. string.char(string.byte(c) + 2)\n\
    \    end\n  end\n  return newStr\nend", "    return (s:gsub(\"%a\", function(c)\n\
    \        if c:byte() >= string.byte(\"A\") and c:byte() <= string.byte(\"z\")\
    \ then\n            local s = string.char(c:byte() + 4)\n            if c:byte()\
    \ > string.byte(\"Z\") and c:byte() < string.byte(\"a\") then\n              \
    \  s = string.char(c:byte() + 20)\n            end\n            return s\n   \
    \     else\n            return c\n        end\n    end))\nend", "    -- This is\
    \ how you can use string.sub\n    -- string.sub(s, 3, 5) returns the substring\
    \ of s starting at\n    -- index 3 and ending at index 5.\n    return string.sub(s,\
    \ 3, 5)\nend", "    local al = { \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\" }\n    local newAl\
    \ = { \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\
    y\", \"z\", \"a\", \"b\", \"c\" }\n    local newS = \"\"\n    for c in s:gmatch(\"\
    .\") do\n        for i = 1, #al do\n            if c == al[i] then\n         \
    \       newS = newS .. newAl[i]\n            end\n        end\n    end\n    return\
    \ newS\nend", "\tlocal sLength = s:len()\n\tlocal result = {}\n\tlocal alphabet\
    \ = {}\n\tfor i = 65, 122 do\n\t\ttable.insert(alphabet, string.char(i))\n\tend\n\
    \tlocal alphabetLength = #alphabet\n\tfor i = 1, sLength do\n\t\tlocal letter\
    \ = s:sub(i, i)\n\t\tfor j = 1, alphabetLength do\n\t\t\tif letter == alphabet[j]\
    \ then\n\t\t\t\ttable.insert(result, alphabet[j + 2 * 2])\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn table.concat(result)\nend", "    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local str = ''\n    local s_lower = string.lower(s)\n    for i = 1, string.len(s_lower)\
    \ do\n        local letter = string.sub(s_lower, i, i)\n        local index =\
    \ string.find(alphabet, letter)\n        local new_index = index + (2 * 2)\n \
    \       if index > 25 then new_index = new_index - 26 end\n        local new_letter\
    \ = string.sub(alphabet, new_index, new_index)\n        str = str .. new_letter\n\
    \    end\n    return str\nend", "  local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  local encrypted_alphabet = \"\"\n  local encrypted_string = \"\"\n  local\
    \ i = 0\n  while i < #alphabet do\n    i = i + 1\n    if i < #alphabet - 1 then\n\
    \      encrypted_alphabet = encrypted_alphabet .. alphabet:sub(i + 2, i + 2)\n\
    \    elseif i == #alphabet - 1 then\n      encrypted_alphabet = encrypted_alphabet\
    \ .. alphabet:sub(1, 1)\n      encrypted_alphabet = encrypted_alphabet .. alphabet:sub(2,\
    \ 2)\n    else\n      encrypted_alphabet = encrypted_alphabet .. alphabet:sub(1,\
    \ 1)\n    end\n  end\n  local j = 0\n  while j < #s do\n    j = j + 1\n    local\
    \ letter = string.lower(s:sub(j, j))\n    local k = 0\n    while k < #alphabet\
    \ do\n      k = k + 1\n      if letter == alphabet:sub(k, k) then\n        encrypted_string\
    \ = encrypted_string .. encrypted_alphabet:sub(k, k)\n      end\n    end\n  end\n\
    \  return encrypted_string\nend", "    local result = ''\n    local letters =\
    \ {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\
    \ 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}\n    for i=1, #s do\n\
    \        local c = s:sub(i,i)\n        local number = #letters\n        for j=1,\
    \ number do\n            if letters[j] == c then\n                --print(c, j,\
    \ number)\n                local newLetter = ''\n                local newIndex\
    \ = j+number-2\n                if newIndex > number then\n                  \
    \  newIndex = newIndex - number\n                end\n                newLetter\
    \ = letters[newIndex]\n                result = result .. newLetter\n        \
    \    end\n        end\n    end\n    return result\nend", "    local encryptString\
    \ = ''\n    local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}\n\
    \    for i=1, #s do\n        if s[i] == ' ' then\n            encryptString =\
    \ encryptString .. ' '\n        else\n            for j=1, #alphabet do\n    \
    \            if s[i] == alphabet[j] then\n                    if (j+4) > #alphabet\
    \ then\n                        encryptString = encryptString .. alphabet[j+4-#alphabet]\n\
    \                    else\n                        encryptString = encryptString\
    \ .. alphabet[j+4]\n                    end\n                end\n           \
    \ end\n        end\n    end\n    return encryptString\nend", "    local alphabet\
    \ = {}\n    local encrypted = \"\"\n    for i = 1, #s do\n        -- If the character\
    \ is between A and Z, then encrypt it.\n        if string.match(s:sub(i, i), \"\
    %A\") then\n            -- Add the lowercase alphabet from 'a' to 'z' to table.\n\
    \            for i = 1, #string.lower(s) do\n                alphabet[i] = string.char(string.byte('a')\
    \ - 1 + i)\n            end\n            -- Move every alphabet by two.\n    \
    \        for i = 1, #alphabet do\n                alphabet[i] = alphabet[i - 2]\n\
    \            end\n            -- Get the index of the alphabet in the string.\n\
    \            local index = string.byte(s:sub(i, i)) - string.byte('a') + 1\n \
    \           -- Encrypt the alphabet by shifting it to the right in the alphabet\
    \ table.\n            encrypted = encrypted .. alphabet[index]\n        -- Else,\
    \ the character is not a letter, so just keep it.\n        else\n            encrypted\
    \ = encrypted .. s:sub(i, i)\n        end\n    end\n    return encrypted\nend",
  "    local alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    local result = \"\"\n\
    \    for i = 1, #s do\n        local c = s:sub(i,i)\n        local idx = alphabet:find(c)\n\
    \        if idx then\n            local rot = (idx + 2) % 26\n            result\
    \ = result .. alphabet:sub(rot, rot)\n        else\n            result = result\
    \ .. c\n        end\n    end\n    return result\nend", "    local dict = {}\n\
    \    local encrypted = \"\"\n    local char\n    local count = 1\n    local code\n\
    \    for char in string.gmatch(s, \".\") do\n        if (dict[char] == nil) then\n\
    \            dict[char] = char:byte()\n        end\n        code = dict[char]\
    \ + 4\n        encrypted = encrypted .. string.char(code)\n    end\n    return\
    \ encrypted\nend", "  local function rot(c)\n    local b = string.byte(c)\n  \
    \  if b >= string.byte('a') and b <= string.byte('z') then\n      b = b + 2\n\
    \      if b > string.byte('z') then\n        b = b - 26\n      end\n    elseif\
    \ b >= string.byte('A') and b <= string.byte('Z') then\n      b = b + 2\n    \
    \  if b > string.byte('Z') then\n        b = b - 26\n      end\n    end\n    return\
    \ string.char(b)\n  end\n  return string.gsub(s, \"(%a)\", rot)\nend", "    assert_string(s)\n\
    \    local abc = 'abcdefghijklmnopqrstuvwxyz'\n    local result = ''\n    for\
    \ _, c in utf8.codes(s) do\n        local lower = utf8.char(c):lower()\n     \
    \   local index = abc:find(lower)\n        if index then\n            local encrypted_index\
    \ = (index + (2 * 2)) % #abc\n            local encrypted_c = abc:sub(encrypted_index,\
    \ encrypted_index)\n            local c_case = utf8.char(c):lower() == utf8.char(c)\
    \ and 'lower' or 'upper'\n            if c_case == 'lower' then\n            \
    \    result = result .. encrypted_c\n            else\n                result\
    \ = result .. encrypted_c:upper()\n            end\n        else\n           \
    \ result = result .. utf8.char(c)\n        end\n    end\n    return result\nend",
  "    local s = string.lower(s)\n    local alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    local encrypt = alphabet:sub(3) .. alphabet:sub(1,2)\n    local encrypted\
    \ = {}\n    for i=1,#s do\n        local c = s:sub(i,i)\n        local offset\
    \ = string.find(alphabet, c)\n        if offset then\n            encrypted[i]\
    \ = encrypt:sub(offset,offset)\n        else\n            encrypted[i] = c\n \
    \       end\n    end\n    return table.concat(encrypted)\nend", "    local encrypted\
    \ = {}\n    for i = 1, #s do\n        table.insert(encrypted, s:sub(i, i):byte()\
    \ + 2 * 2)\n    end\n    return string.char(unpack(encrypted))\nend", "  local\
    \ alphabet = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"\
    u\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n  local alphabet_hash = {}\n  for i =\
    \ 1, #alphabet do\n    alphabet_hash[alphabet[i]] = i\n  end\n  local string_hash\
    \ = {}\n  for i = 1, #s do\n    string_hash[i] = s:sub(i, i)\n  end\n  local encrypted_string\
    \ = \"\"\n  for i = 1, #string_hash do\n    if string_hash[i] == \" \" then\n\
    \      encrypted_string = encrypted_string .. \" \"\n    elseif alphabet_hash[string_hash[i]]\
    \ < #alphabet - 4 then\n      encrypted_string = encrypted_string .. alphabet[alphabet_hash[string_hash[i]]\
    \ + 4]\n    else\n      encrypted_string = encrypted_string .. alphabet[alphabet_hash[string_hash[i]]\
    \ - 22]\n    end\n  end\n  return encrypted_string\nend", "  return s:gsub('%a',\
    \ function(x)\n\t\tlocal n = string.byte(x)\n\t\tif n >= string.byte('a') and\
    \ n <= string.byte('z') then\n\t\t  n = n + 2\n\t\t  if n > string.byte('z') then\n\
    \t\t\tn = n - string.byte('z') + string.byte('a') - 1\n\t\t  end\n\t\t  return\
    \ string.char(n)\n\t\telseif n >= string.byte('A') and n <= string.byte('Z') then\n\
    \t\t  n = n + 2\n\t\t  if n > string.byte('Z') then\n\t\t\tn = n - string.byte('Z')\
    \ + string.byte('A') - 1\n\t\t  end\n\t\t  return string.char(n)\n\t\telse\n\t\
    \t  return x\n\t\tend\n\t  end)\nend", "    local s2 = \"\"\n    for i = 1, #s\
    \ do\n        local c = s:sub(i,i)\n        local b = string.byte(c)\n       \
    \ if b >= string.byte(\"a\") and b <= string.byte(\"z\") then\n            b =\
    \ b + 4\n            if b > string.byte(\"z\") then b = b - 26 end\n        elseif\
    \ b >= string.byte(\"A\") and b <= string.byte(\"Z\") then\n            b = b\
    \ + 4\n            if b > string.byte(\"Z\") then b = b - 26 end\n        end\n\
    \        s2 = s2 .. string.char(b)\n    end\n    return s2\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
