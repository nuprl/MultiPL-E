name: HumanEval_49_modp
language: lua
prompt: "-- Return 2^n modulo p (be aware of numerics).\nlocal function modp(n, p)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = modp\n\
  \    lu.assertEquals(candidate(3, 5), 3)\n    lu.assertEquals(candidate(1101, 101),\
  \ 2)\n    lu.assertEquals(candidate(0, 101), 1)\n    lu.assertEquals(candidate(3,\
  \ 11), 8)\n    lu.assertEquals(candidate(100, 101), 1)\n    lu.assertEquals(candidate(30,\
  \ 5), 4)\n    lu.assertEquals(candidate(31, 5), 3)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local r = 1\n  while n > 0 do\n    if n % 2 == 1 then\n      r =\
    \ (r * 2) % p\n    end\n    n = n // 2\n  end\n  return r\nend", "    local r\
    \ = 1\n    for i = 1, n do\n        r = r * 2 % p\n    end\n    return r\nend",
  "\tlocal result = 1\n\tlocal h = 1\n\twhile h ~= 0 do\n\t\th = math.fmod(n, 2)\n\
    \t\tn = math.floor(n / 2)\n\t\tif h == 1 then\n\t\t\tresult = (result * h) % p\n\
    \t\tend\n\t\th = (2 * h) % p\n\tend\n\treturn result\nend", "\tlocal r = 1\n\t\
    while n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tr = (r * 2) % p\n\t\tend\n\t\tn\
    \ = n >> 1\n\tend\n\treturn r\nend", "    local r = 1\n    local b = 2\n    while\
    \ n > 0 do\n        if n % 2 == 1 then\n            r = r * b % p\n        end\n\
    \        n = math.floor(n / 2)\n        b = b * b % p\n    end\n    return r\n\
    end", "  local lr = bit32.rshift(n, 16) % p\n  local rr = n % p\n  local r = (lr*65536\
    \ + rr) % p\n  if r < 0 then r = r + p end\n  return r\nend", "    if n==0 then\
    \ return 1 end\n    if n%2 == 0 then return modp(n/2, p)^2 % p end\n    return\
    \ n*modp(n-1, p) % p\nend", "    if p == 1 then\n        return 0\n    end\n \
    \   local res = 1\n    local p2 = p\n    while n > 0 do\n        if n % 2 == 1\
    \ then\n            res = (res * p2) % p\n        end\n        p2 = (p2 * p2)\
    \ % p\n        n = math.floor(n / 2)\n    end\n    return res\nend", "  return\
    \ mod(2^n, p)\nend", "\tlocal result = 1\n\tfor i = 1, n do\n\t\tresult = (result\
    \ * 2) % p\n\tend\n\treturn result\nend", "    local ret = 1\n    local x = 2\
    \ % p\n    for _, d in ipairs(digits(n)) do\n        if d == 1 then\n        \
    \    ret = (ret * x) % p\n        end\n        x = (x * x) % p\n    end\n    return\
    \ ret\nend", "    local x = 1\n    for i = 1, n do\n        x = (x * 2) % p\n\
    \    end\n    return x\nend", "\tif n >= p then\n\t\treturn n % p\n\telse\n\t\t\
    return n\n\tend\nend", "  if n < 0 then\n    return n + p\n  else\n    return\
    \ n % p\n  end\nend", "  local u = mpz.new('2')\n  mpz.powm_ui(u, u, n, p)\n \
    \ return u:get_str()\nend", "  local z = 0\n  local y = 1\n  local x = n\n  local\
    \ p1 = p\n  local n1 = 0\n  local n2 = 1\n  local n3\n  local r\n  while x ~=\
    \ 0 do\n    local q = floor(p1 / x)\n    n3 = n1\n    n1 = n2\n    n2 = n3 - q\
    \ * n2\n    r = p1 - q * x\n    p1 = x\n    x = r\n    z = n1\n  end\n  if p1\
    \ ~= 1 then return 0 end\n  if z < 0 then z = z + p end\n  return z\nend", " \
    \   local t = 1\n    for i = 0, n - 1 do\n        t = (t * 2) % p\n    end\n \
    \   return t\nend", "    return (2^n - 1) % p\nend", "\tlocal k = 0\n\tlocal m\
    \ = 1\n\twhile n > 0 do\n\t\tlocal i = n % 2\n\t\tn = (n - i) / 2\n\t\tk = k +\
    \ 1\n\t\tif i == 1 then\n\t\t\tm = (m * g[k]) % p\n\t\tend\n\tend\n\treturn m\n\
    end", "\tif p <= 2^53 then\n\t\treturn 2^n % p\n\telse\n\t\t-- 2^53 has 15 digits,\
    \ so floor((p-1)/2^53) = floor(log10(p-1)/log10(2^53)) <= floor(log10(p-1)/15)\n\
    \t\t-- -> 2^n mod p < 10^k -> k = floor(log10(p-1)/15)\n\t\tlocal k = math.floor(math.log10(p-1)/15)\n\
    \t\tlocal t = {}\n\t\tfor i = 1, k do\n\t\t\tt[i] = 2^(n % 2^53)\n\t\t\tn = math.floor(n\
    \ / 2^53)\n\t\tend\n\t\tlocal res = 1\n\t\tfor i = 1, k do\n\t\t\tres = (res *\
    \ t[i]) % p\n\t\tend\n\t\treturn res\n\tend\nend", "    local v = 1\n    local\
    \ p_bits = #bit.tohex(p)\n    local p_mask = tonumber(string.rep('f', p_bits),\
    \ 16)\n    while n ~= 0 do\n        if (n & 1) ~= 0 then\n            v = (v *\
    \ 2) % p\n        end\n        n = n >> 1\n    end\n    return v & p_mask\nend",
  "\treturn (band(n, p - 1) + n) % p\nend", "    return (powmod(2, n) - 1) % p\nend",
  "\tlocal n2=n%p\n\tif n2<0 then n2=n2+p end\n\treturn 2^n2%p\nend", "    local r\
    \ = 1\n    for i = 1, n do\n        r = r * 2 % p\n    end\n    return r\nend",
  "\treturn n - (n/p):floor()*p\nend", "\tlocal i = 1\n\tlocal m = 2 % p\n\twhile\
    \ i < n do\n\t\tm = (m * m) % p\n\t\ti = i + 1\n\tend\n\treturn m\nend", "   \
    \ local res = 1\n    while n > 0 do\n        if n % 2 == 1 then\n            res\
    \ = (res * 2) % p\n        end\n        n = math.floor(n / 2)\n        if n >\
    \ 0 then\n            p = (p * p) % prime\n        end\n    end\n    return res\n\
    end", "\tlocal nn = n\n\tn = n % p\n\tif n < 0 then\n\t\tn = n + p\n\tend\n\t\
    if n > 0.5 * p then\n\t\tn = n - p\n\tend\n\tif n < -0.5 * p then\n\t\tn = n +\
    \ p\n\tend\n\t--if n ~= nn then print(n,nn) end\n\treturn n\nend", "\t-- http://en.wikipedia.org/wiki/Modular_exponentiation\n\
    \tlocal r = 1\n\tfor i = 1, n do\n\t\tr = (r * 2) % p\n\tend\n\treturn r\nend",
  "  if n >= p then return n - p end\n  return n\nend", "  local res = 1\n  local\
    \ y = 2\n  while n > 0 do\n    if n % 2 == 1 then\n      res = (res * y) % p\n\
    \    end\n    y = (y * y) % p\n    n = math.floor(n / 2)\n  end\n  return res\n\
    end", "  local r = 1\n  for i = 0, n - 1 do\n    r = r * 2 % p\n  end\n  return\
    \ r\nend", "\tif p == 2 then\n\t\treturn 1\n\tend\n\tn = n % (p - 1)\n\treturn\
    \ (2 ^ n - 1) % p\nend", "  local n = n % p\n  local n1 = n\n  n = n * n\n  local\
    \ n2 = n\n  n = n * n\n  local n3 = n\n  n = n * n\n  local n4 = n\n  n = n *\
    \ n\n  local n5 = n\n  return n5 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1\
    \ * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 *\
    \ n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1\
    \ * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 *\
    \ n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1\
    \ * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 *\
    \ n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1\
    \ * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 *\
    \ n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1\
    \ * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 * n1 *", "\tif n == 0\
    \ then\n\t\treturn 1\n\telseif n < 0 then\n\t\treturn modp(n + p, p)\n\telse\n\
    \t\treturn (2 * modp(n - 1, p)) % p\n\tend\nend", "  if n == 0 then\n    return\
    \ 1\n  elseif n == 1 then\n    return 2\n  elseif n % 2 == 0 then\n    local m\
    \ = modp(n / 2, p)\n    return (m * m) % p\n  else\n    return (2 * modp(n - 1,\
    \ p)) % p\n  end\nend", "  local k = math.floor(n/p)\n  return 2^(n-k*p) % p\n\
    end", "\tif n == 0 then\n\t\treturn 1\n\telseif n % 2 == 0 then\n\t\treturn modp(n/2,\
    \ p)^2 % p\n\telse\n\t\treturn modp(n/2, p)^2 * 2 % p\n\tend\nend", "\tif p ==\
    \ 2 then\n\t\treturn 1\n\tend\n\tn = n % (p - 1)\n\t-- compute \\prod_{i=0}^{n-1}\
    \ 2^i mod p\n\tlocal res = 1\n\tlocal base = 2\n\twhile n > 0 do\n\t\tif n % 2\
    \ == 1 then\n\t\t\tres = (res * base) % p\n\t\tend\n\t\tbase = (base * base) %\
    \ p\n\t\tn = math.floor(n / 2)\n\tend\n\treturn res\nend", "    if p == 2 then\n\
    \        return n % 2\n    else\n        return (2^n % p)\n    end\nend", "\t\
    if n == 0 then\n\t\treturn 1\n\telseif n == 1 then\n\t\treturn 2\n\telseif n ==\
    \ 2 then\n\t\treturn 4\n\telseif n == 3 then\n\t\treturn 8\n\telseif n == 4 then\n\
    \t\treturn 16\n\telseif n == 5 then\n\t\treturn 5\n\telseif n == 6 then\n\t\t\
    return 10\n\telseif n == 7 then\n\t\treturn 20\n\telseif n == 8 then\n\t\treturn\
    \ 13\n\telseif n == 9 then\n\t\treturn 26\n\telseif n == 10 then\n\t\treturn 17\n\
    \telseif n == 11 then\n\t\treturn 34\n\telseif n == 12 then\n\t\treturn 29\n\t\
    elseif n == 13 then\n\t\treturn 58\n\telseif n == 14 then\n\t\treturn 37\n\telseif\
    \ n == 15 then\n\t\treturn 74\n\telseif n == 16 then\n\t\treturn 49\n\telseif\
    \ n == 17 then\n\t\treturn 98\n\telseif n == 18 then\n\t\treturn 53\n\telseif\
    \ n == 19 then\n\t\treturn 106\n\telseif n == 20 then\n\t\treturn 61\n\telseif\
    \ n == 21 then\n\t\treturn 122\n\telseif n == 22 then\n\t\treturn 85\n\telseif\
    \ n == 23 then\n\t\treturn 170\n\telseif n == 24 then\n\t\treturn 77\n\telseif\
    \ n == 25 then\n\t\treturn 154\n\telseif n == 26 then\n\t\treturn 41\n\telseif\
    \ n == 27 then\n\t\treturn 82\n\telseif n == 28 then\n\t\treturn 173\n\telseif\
    \ n == 29 then\n\t\treturn 116\n\telseif n == 30 then\n\t\treturn 157\n\telseif\
    \ n == 31 then\n\t\treturn 192\n\telseif n == 32 then\n\t\treturn 109\n\telseif\
    \ n == 33 then\n\t\treturn 218\n\telseif n == 34 then\n\t\treturn 189\n\telseif\
    \ n == 35 then\n\t\treturn 238\n\telseif n == 36 then\n\t\treturn 241\n\telseif\
    \ n == 37 then\n\t\treturn 254\n\telseif n == 38 then\n\t\treturn 227\n\telseif\
    \ n ==", "  if n == 0 then\n    return 1\n  elseif n == 1 then\n    return 2\n\
    \  elseif n == 2 then\n    return 4\n  elseif n == 3 then\n    return 8\n  elseif\
    \ n == 4 then\n    return 7\n  elseif n == 5 then\n    return 5\n  elseif n ==\
    \ 6 then\n    return 1\n  elseif n == 7 then\n    return 3\n  elseif n == 8 then\n\
    \    return 6\n  elseif n == 9 then\n    return 12\n  elseif n == 10 then\n  \
    \  return 11\n  elseif n == 11 then\n    return 9\n  elseif n == 12 then\n   \
    \ return 10\n  elseif n == 13 then\n    return 14\n  elseif n == 14 then\n   \
    \ return 15\n  elseif n == 15 then\n    return 13\n  elseif n == 16 then\n   \
    \ return 19\n  elseif n == 17 then\n    return 18\n  elseif n == 18 then\n   \
    \ return 16\n  elseif n == 19 then\n    return 17\n  elseif n == 20 then\n   \
    \ return 23\n  elseif n == 21 then\n    return 22\n  elseif n == 22 then\n   \
    \ return 20\n  elseif n == 23 then\n    return 21\n  elseif n == 24 then\n   \
    \ return 27\n  elseif n == 25 then\n    return 26\n  elseif n == 26 then\n   \
    \ return 24\n  elseif n == 27 then\n    return 25\n  elseif n == 28 then\n   \
    \ return 31\n  elseif n == 29 then\n    return 30\n  elseif n == 30 then\n   \
    \ return 28\n  elseif n == 31 then\n    return 29\n  elseif n == 32 then\n   \
    \ return 36\n  elseif n == 33 then\n    return 35\n  elseif n == 34 then\n   \
    \ return 33\n  elseif n == 35 then\n    return 34\n  elseif n == 36 then\n   \
    \ return 32\n  elseif n == 37 then\n    return 39\n  elseif n == 38 then\n   \
    \ return 38\n  elseif n == 39 then\n    return 37\n  elseif n == 40 then\n   \
    \ return 43\n  elseif n == 41 then\n    return 42\n  elseif n == 42 then\n", " \
    \ local r = 1\n  for i = 1, n do\n    r = (r * 2) % p\n  end\n  return r\nend",
  "\t-- The most significant bit of n.\n\tlocal w, i = floor(log(n) / log(2)), 0\n\
    \t-- The corresponding power of 2.\n\tlocal x = 2^w\n\t-- The result.\n\tlocal\
    \ y = 1\n\twhile x > 0 do\n\t\tif x % 2 ~= 0 then\n\t\t\ty = (y * 2) % p\n\t\t\
    end\n\t\tx = floor(x / 2)\n\t\ty = (y * y) % p\n\tend\n\treturn y\nend", "  local\
    \ r = 1\n  while n > 0 do\n    if n % 2 == 1 then\n      r = (r * 2) % p\n   \
    \ end\n    n = math.floor(n / 2)\n  end\n  return r\nend", "  return tonumber(n)\
    \ % p\nend", "\treturn math.fmod(2^n, p)\nend", "  if n == 0 then\n    return\
    \ 1\n  elseif n < 0 then\n    return modp(p - 1 - (-n % (p - 1)), p)\n  else\n\
    \    local acc = 1\n    for _ = 1, n do\n      acc = (acc * 2) % p\n    end\n\
    \    return acc\n  end\nend", "    local a = 1\n    local base = 2\n    while\
    \ n > 0 do\n        if math.fmod(n, 2) == 1 then\n            a = math.fmod(a\
    \ * base, p)\n        end\n        base = math.fmod(base * base, p)\n        n\
    \ = math.floor(n / 2)\n    end\n    return a\nend", "  local z = 1\n  for i =\
    \ 1, n do\n    z = z * 2 % p\n  end\n  return z\nend", "\tif n < p then\n\t\t\
    return pcall(bit.bxor, n, p) and bit.bxor(n, p) or n\n\tend\n\tlocal m = 1\n\t\
    for i = 1, p do\n\t\tm = 2 * m % p\n\tend\n\tlocal r = 1\n\twhile n > 0 do\n\t\
    \tif n % 2 == 1 then\n\t\t\tr = (r * m) % p\n\t\tend\n\t\tm = (m * m) % p\n\t\t\
    n = math.floor(n / 2)\n\tend\n\treturn r\nend", "    local r = 1\n    for i =\
    \ 1,n do\n        r = (r * 2) % p\n    end\n    return r\nend", "    if n == 0\
    \ then\n        return 1\n    elseif n % 2 == 0 then\n        return modp(n/2,\
    \ p)^2 % p\n    else\n        return (modp(n-1, p)^2 % p) * (2 % p) % p\n    end\n\
    end", "  local n1 = n\n  n = n % p\n  if n < 0 then\n    n = n + p\n  end\n  local\
    \ n2 = n\n  return n\nend", "  local r = 1\n  while n > 0 do\n    if n % 2 ==\
    \ 1 then\n      r = (r * 2) % p\n    end\n    n = math.floor(n / 2)\n  end\n \
    \ return r\nend", "  local r = 1\n  for i = 1, n do\n    r = (r * 2) % p\n  end\n\
    \  return r\nend", "  local r = 1\n  for i = 1, n do\n    r = (r * 2) % p\n  end\n\
    \  return r\nend", "  local r = 1\n  while n > 0 do\n    if n % 2 == 1 then\n\
    \      r = r * 2 % p\n    end\n    n = floor(n / 2)\n  end\n  return r\nend",
  "\tif n < 1 then\n\t\treturn 1\n\telse\n\t\treturn ((2 ^ n) % p)\n\tend\nend", "\t\
    local res = 1\n\twhile n ~= 0 do\n\t\tif n % 2 == 1 then\n\t\t\tres = (res * 2)\
    \ % p\n\t\tend\n\t\tn = math.floor(n / 2)\n\tend\n\treturn res\nend", "  -- Note\
    \ that 2^n is always a multiple of 2, so the last bit is 0.\n  -- Also note that\
    \ for large n, 2^n is nearly equal to p.\n  -- Hence, 2^n mod p = (2^n - p) mod\
    \ p.", "\t-- The point is that 2^(2^n - 1) - 1 is divisible by 2^n - 1\n\tlocal\
    \ q = 1\n\tlocal b = 2\n\tfor i = 0, n - 1 do\n\t\tb = b * b % p\n\t\tq = q *\
    \ b % p\n\tend\n\treturn q\nend", "  --~ local a = 1\n  --~ local t = 2\n  --~\
    \ while n > 0 do\n    --~ if n % 2 == 1 then\n      --~ a = (a * t) % p\n    --~\
    \ end\n    --~ n = math.floor(n / 2)\n    --~ t = (t * t) % p\n  --~ end\n  --~\
    \ return a\n  return 2^n % p\nend", "    local p = tonumber(p) or 0\n    local\
    \ n = tonumber(n) or 0\n    if n == 0 then\n        return 1\n    elseif n > 0\
    \ then\n        return (2 * modp(n - 1, p)) % p\n    elseif n < 0 then\n     \
    \   return (p - 1) * modp(n + 1, p) % p\n    end\nend", "\t--print(\"modp\", n,\
    \ p)\n\tassert(n >= 0)\n\tassert(n < p)\n\tassert(isint(n))\n\tassert(isint(p))\n\
    \tlocal n_leading_zeros = leading_zeros(n)\n\tlocal p_leading_zeros = leading_zeros(p)\n\
    \t--print(\"n_leading_zeros\", n_leading_zeros)\n\t--print(\"p_leading_zeros\"\
    , p_leading_zeros)\n\tif n_leading_zeros < p_leading_zeros then\n\t\treturn (1\
    \ << n_leading_zeros) % p\n\telse\n\t\treturn 0\n\tend\nend", "\tn = n % p", " \
    \ local function mulmod(a, b, p)\n    local res = 0\n    a = a % p\n    while\
    \ b > 0 do\n      if b % 2 == 1 then\n        res = (res + a) % p\n      end\n\
    \      a = (a * 2) % p\n      b = math.floor(b / 2)\n    end\n    return res\n\
    \  end\n  return mulmod(2, n, p - 1)\nend", "    local result = 1\n    for i =\
    \ 1, n do\n        result = (result * 2) % p\n    end\n    return result\nend",
  "  local result = 1\n  for i = 1, n do\n    result = (result * 2) % p\n  end\n \
    \ return result\nend", "\tif (n < 0) then\n\t\terror(\"not implemented\")\n\t\
    end\n\tif (n == 0) then\n\t\treturn 1\n\tend\n\tlocal res = 1\n\tlocal c = 2\n\
    \twhile (n > 0) do\n\t\tif (n % 2 == 1) then\n\t\t\tres = (res * c) % p\n\t\t\
    end\n\t\tc = (c * c) % p\n\t\tn = math.floor(n / 2)\n\tend\n\treturn res\nend",
  "  local res = 1\n  for i = 1, n do\n    res = res * 2 % p\n  end\n  return res\n\
    end", '  local np = n % p', "\tif n <= -1 then\n\t\treturn 0\n\telseif n == 0\
    \ then\n\t\treturn 1\n\telseif n == 1 then\n\t\treturn p\n\telseif n % 2 == 0\
    \ then\n\t\tlocal y = modp(n / 2, p)\n\t\treturn (y * y) % p\n\telse\n\t\treturn\
    \ (p * modp(n - 1, p)) % p\n\tend\nend", "    if n >= p then n = n % p end\n \
    \   local result = 1\n    local k = 0\n    while (n > 0) do\n        if (n % 2\
    \ == 1) then\n            result = (result * Primorial[k+1]) % p\n        end\n\
    \        n = math.floor(n / 2)\n        k = k + 1\n    end\n    return result\n\
    end", "  local res = 1\n  local exp = n\n  while exp > 0 do\n    if exp % 2 ==\
    \ 1 then\n      res = (res * n) % p\n    end\n    n = (n * n) % p\n    exp = math.floor(exp\
    \ / 2)\n  end\n  return res\nend", "    n = n % p\n    if n < 0 then\n       \
    \ n = n + p\n    end\n    return n\nend", "\tlocal r = 1\n\tlocal b = 2\n\twhile\
    \ n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tr = (r * b) % p\n\t\tend\n\t\tn = math.floor(n\
    \ / 2)\n\t\tb = (b * b) % p\n\tend\n\treturn r\nend", "    local x = BigNum(2)\n\
    \    local y = BigNum(1)\n    while n > 0 do\n        if n % 2 == 1 then\n   \
    \         y = (x * y) % p\n        end\n        x = (x * x) % p\n        n = math.floor(n\
    \ / 2)\n    end\n    return y\nend", "\tlocal r = 1\n\twhile n > 0 do\n\t\tif\
    \ n % 2 == 1 then\n\t\t\tr = (r * 2) % p\n\t\tend\n\t\tn = math.floor(n / 2)\n\
    \tend\n\treturn r\nend", "  local r = 1\n  while n > 0 do\n    if n % 2 == 1 then\n\
    \      r = (r * 2) % p\n    end\n    n = math.floor(n / 2)\n  end\n  return r\n\
    end", '  local pow2 = {{2,0},{4,0},{8,0},{16,0},{32,0},{64,0},{128,0},{256,0},{512,0},{1024,0},{2048,0},{4096,0},{8192,0},{16384,0},{32768,0},{65536,0},{131072,0},{262144,0},{524288,0},{1048576,0},{2097152,0},{4194304,0},{8388608,0},{16777216,0},{33554432,0},{67108864,0},{134217728,0},{268435456,0},{536870912,0},{1073741824,0},{2147483648,0},{4294967296,0},{8589934592,0},{17179869184,0},{34359738368,0},{68719476736,0},{137438953472,0},{274877906944,0},{549755813888,0},{1099511627776,0},{2199023255552,0},{4398046511104,0},{8796093022208,0},{17592186044416,0},{35184372088832,0},{70368744177664,0},{140737488355328,0},{281474976710656,0},{562949953421312,0},{1125899906842624,0},{2251799813685248,0},{4503599627370496,0},{9007199254740992,0},{18014398509481984,0},{36028797018963968,0},{72057594037927936,0},{144115188075855872,0},{288230376151711744,0},{576460752303423488,0},{1152921504606846976,0},{2305843009213693952,0},',
  "    local r = 1\n    for i = 1, n do\n        r = (r * 2) % p\n    end\n    return\
    \ r\nend", "\treturn n % p + (n < 0 and p or 0)\nend", "  return (2^n-1) % p\n\
    end", "  local x = 1\n  local y = 2\n  while n > 0 do\n    if n % 2 == 1 then\n\
    \      x = (x * y) % p\n    end\n    y = (y * y) % p\n    n = math.floor(n / 2)\n\
    \  end\n  return x\nend", "\tif p == 1 then return 0 end\n\tif n == 0 then return\
    \ 1 end\n\tif n % 2 == 0 then\n\t\tlocal r = modp(n/2, p)\n\t\treturn (r*r) %\
    \ p\n\telse\n\t\treturn (modp(n-1, p) * 2) % p\n\tend\nend", "  local x = 2\n\
    \  local r = 1\n  while n > 0 do\n    if n%2 == 1 then\n      r = (r*x)%p\n  \
    \  end\n    x = (x*x)%p\n    n = (n-n%2)/2\n  end\n  return r\nend", "  if p <=\
    \ 1 then\n    return 0\n  end\n  local r = 1\n  local b = 2\n  local e = math.floor(n\
    \ % 32)\n  for i = 1, e do\n    r = (r * b) % p\n  end\n  return r\nend", "  if\
    \ n > p then\n    n = n % p\n  end\n  local r = 1\n  while n > 0 do\n    if n\
    \ % 2 == 1 then\n      r = (r * a) % p\n    end\n    a = (a * a) % p\n    n =\
    \ math.floor(n / 2)\n  end\n  return r\nend", "  if n >= p then\n    n = n % p\n\
    \  end\n  if n > math.floor(p/2) then\n    n = n - p\n  end\n  return n\nend",
  "\tlocal s = 1\n\tfor i = 1, n do\n\t\ts = (s * 2) % p\n\tend\n\treturn s\nend",
  "    --assert(n <= floor(log(p, 2)))\n    local nn = n % p\n    local res = 1\n\
    \    while nn > 0 do\n        res = (res * 2) % p\n        nn = nn - 1\n    end\n\
    \    return res\nend", "  local res = 1\n  for i = 0, 31 do\n    if n & (1 <<\
    \ i) ~= 0 then\n      res = (res * res) % p\n    end\n  end\n  return res\nend",
  "    local a = 1\n    for i = 1, n do\n        a = (a * 2) % p\n    end\n    return\
    \ a\nend", "  local p_inv = floor(p^(1/2))\n  return gmp.powmod(2, gmp.mul(gmp.mul(n,\
    \ p_inv), p_inv), p)\nend", "    local z = 1\n    for i = 1, n do\n        z =\
    \ (z * 2) % p\n    end\n    return z\nend", "\tif n == 0 then\n\t\treturn 1\n\t\
    elseif n == 1 then\n\t\treturn 2\n\telseif n == 2 then\n\t\treturn 4\n\telseif\
    \ n == 3 then\n\t\treturn 8\n\telseif n == 4 then\n\t\treturn 16\n\telseif n ==\
    \ 5 then\n\t\treturn 32\n\telseif n == 6 then\n\t\treturn 64\n\telseif n == 7\
    \ then\n\t\treturn 128\n\telseif n == 8 then\n\t\treturn 256\n\telseif n == 9\
    \ then\n\t\treturn 512\n\telseif n == 10 then\n\t\treturn 1024\n\telseif n ==\
    \ 11 then\n\t\treturn 2048\n\telseif n == 12 then\n\t\treturn 4096\n\telseif n\
    \ == 13 then\n\t\treturn 8192\n\telseif n == 14 then\n\t\treturn 16384\n\telseif\
    \ n == 15 then\n\t\treturn 32768\n\telseif n == 16 then\n\t\treturn 65536\n\t\
    elseif n == 17 then\n\t\treturn 131072\n\telseif n == 18 then\n\t\treturn 262144\n\
    \telseif n == 19 then\n\t\treturn 524288\n\telseif n == 20 then\n\t\treturn 1048576\n\
    \telseif n == 21 then\n\t\treturn 2097152\n\telseif n == 22 then\n\t\treturn 4194304\n\
    \telseif n == 23 then\n\t\treturn 8388608\n\telseif n == 24 then\n\t\treturn 16777216\n\
    \telseif n == 25 then\n\t\treturn 33554432\n\telseif n == 26 then\n\t\treturn\
    \ 67108864\n\telseif n == 27 then\n\t\treturn 134217728\n\telseif n == 28 then\n\
    \t\treturn 268435456\n\telseif n == 29 then\n\t\treturn 536870912\n\telseif n\
    \ == 30 then\n\t\treturn 1073741824\n\telseif n == 31 then\n\t\treturn 2147483648\n\
    \telseif n == 32 then\n\t\treturn 4294967296\n\telseif n == 33 then\n\t\treturn\
    \ 8589934592\n\telseif n == 34 then\n\t\treturn 17179869184\n\telseif n", "  \
    \  local nmod2 = n % 2\n    if nmod2 == 0 then\n        return modp(n/2, p)^2\
    \ % p\n    else\n        return (modp((n-1)/2, p)^2 * 2) % p\n    end\nend", " \
    \   local y = 1\n    while n > 0 do\n        if n % 2 == 1 then\n            y\
    \ = (y * 2) % p\n        end\n        n = math.floor(n / 2)\n    end\n    return\
    \ y\nend", "    -- TODO\n    -- Hint: recursion.\n    -- Use the fact that if\
    \ p is prime, then 2^(p-1) == 1 mod p.\n    if n == 0 then\n        return 1\n\
    \    elseif n == 1 then\n        return 2\n    else\n        return (modp(n -\
    \ 1, p) * 2) % p\n    end\nend", "  return powmod(2, n, p)\nend", "  if p == 2\
    \ then\n    return n & 1\n  else\n    return (2^n) % p\n  end\nend", "    local\
    \ result = 1\n    local power = n\n    while power > 0 do\n        if power %\
    \ 2 == 1 then\n            result = (result * n) % p\n        end\n        n =\
    \ (n * n) % p\n        power = math.floor(power / 2)\n    end\n    return result\n\
    end", "\tlocal r = 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tr = (r *\
    \ 2) % p\n\t\tend\n\t\tn = math.floor(n / 2)\n\tend\n\treturn r\nend", "    return\
    \ n % p;\nend", "  local t = 1\n  for i = 1, n do\n    t = (t * 2) % p\n  end\n\
    \  return t\nend", "  if n == 0 then\n    return 1\n  elseif n == 1 then\n   \
    \ return 2\n  elseif n % 2 == 0 then\n    return (modp(n/2, p)^2) % p\n  else\n\
    \    return (2 * modp(n-1, p)) % p\n  end\nend", "    local r = 1\n    while n\
    \ > 0 do\n        if n % 2 == 1 then\n            r = (r * 2) % p\n        end\n\
    \        n = math.floor(n / 2)\n    end\n    return r\nend", "  local r = 1\n\
    \  for i = 1, n do\n    r = (r * 2) % p\n  end\n  return r\nend", "  if n == 0\
    \ then\n    return 1\n  elseif n < 0 then\n    return nil\n  else\n    local d\
    \ = modp(n/2, p)\n    if n % 2 == 0 then\n      return (d*d) % p\n    else\n \
    \     return (d*d*2) % p\n    end\n  end\nend", "    if p == 2 then\n        return\
    \ bit.band(n, 1)\n    else\n        return (bit.band(n, 1) * p + math.fmod(n,\
    \ p)) % p\n    end\nend", "\tif n == 0 then\n\t\treturn 1\n\telseif n == 1 then\n\
    \t\treturn 2\n\telseif math.fmod(n, 2) == 0 then\n\t\tlocal res = modp(n/2, p)\n\
    \t\treturn (res * res) % p\n\telse\n\t\treturn (2 * modp(n-1, p)) % p\n\tend\n\
    end", "  if n < p then\n    return 2^n % p\n  else\n    -- we have to take the\
    \ order into account\n    return modp(n % (p-1), p)\n  end\nend", "\tlocal r =\
    \ 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tr = (r * x) % p\n\t\tend\n\
    \t\tn = (n - n % 2) / 2\n\t\tx = (x * x) % p\n\tend\n\treturn r\nend", "  local\
    \ res = 1\n  while n > 0 do\n    if n%2 == 1 then\n      res = (res*2)%p\n   \
    \ end\n    n = floor(n/2)\n    if n > 0 then\n      res = (res*res)%p\n    end\n\
    \  end\n  return res\nend", "  local x = 1\n  local y = 2\n  while n > 0 do\n\
    \    if n % 2 == 1 then\n      x = (x * y) % p\n    end\n    y = (y * y) % p\n\
    \    n = math.floor(n / 2)\n  end\n  return x\nend", "    local r = 1\n    for\
    \ j = 0, (n-1) do\n        r = r * 2 % p\n    end\n    return r\nend", "\tif p\
    \ == 2 then\n\t\treturn 1\n\tend\n\tlocal r = 1\n\twhile n > 0 do\n\t\tif bit.band(n,\
    \ 1) == 1 then\n\t\t\tr = (r * 2) % p\n\t\tend\n\t\tn = bit.rshift(n, 1)\n\tend\n\
    \treturn r\nend", "  n = n % p\n  if n < 0 then n = n + p end\n  return n\nend",
  "\tlocal result = 1\n\tfor i = 1, n do\n\t\tresult = result * 2 % p\n\tend\n\treturn\
    \ result\nend", "\tif p == 1 then return 0 end\n\tlocal r = 1\n\tfor i = 1, n\
    \ do\n\t\tr = r * 2 % p\n\tend\n\treturn r\nend", "    local r = 1\n    while\
    \ n > 0 do\n        if n % 2 == 1 then\n            r = r * 2 % p\n        end\n\
    \        n = math.floor(n / 2)\n    end\n    return r\nend", "\t--[[\n\t-- This\
    \ can be done much faster, but the speed difference doesn't matter here.\n\tif\
    \ n == 0 then\n\t\treturn 1\n\telseif n == 1 then\n\t\treturn 2\n\telse\n\t\t\
    return (2 * modp(n - 1, p)) % p\n\tend\n\t--]]\n\t\n\t-- This is much faster,\
    \ but is numerically unstable:\n\t--return 2 ^ n % p\n\t\n\t-- So we use this\
    \ (it's much slower, though):\n\tif n == 0 then\n\t\treturn 1\n\telseif n == 1\
    \ then\n\t\treturn 2\n\telse\n\t\tlocal b = 2\n\t\tlocal e = 1\n\t\twhile e <\
    \ n do\n\t\t\te = e + 1\n\t\t\tb = (b * 2) % p\n\t\tend\n\t\treturn b\n\tend\n\
    end", "  if n == 0 then\n    return 1\n  elseif n < 0 then\n    n = n + p*p\n\
    \  end\n  local r = 1\n  while n > 0 do\n    if n % 2 == 1 then\n      r = (r\
    \ * 2) % p\n    end\n    n = math.floor(n / 2)\n  end\n  return r\nend", "\tn\
    \ = n % p\n\tif p < 2^(53 - n) then return n end\n\tn = 2^n\n\treturn n % p\n\
    end", "    local result = 1\n    local x = 2", "\tif n < 64 then\n\t\treturn bit.band(2^n,\
    \ p)\n\telse\n\t\tn = modp(n, 64)\n\t\treturn bit.band(2^n - 1, p)\n\tend\nend",
  "\tlocal res = 1;\n\tlocal two_to_the_n = 2;\n\twhile n > 0 do\n\t\tif n % 2 ==\
    \ 1 then\n\t\t\tres = (res * two_to_the_n) % p;\n\t\tend\n\t\tn = math.floor(n\
    \ / 2);\n\t\ttwo_to_the_n = (two_to_the_n * two_to_the_n) % p;\n\tend\n\treturn\
    \ res;\nend", "    --print(\"modp(\", n, \",\", p, \")\")\n    if n == 0 then\n\
    \        return 1\n    elseif n == 1 then\n        return 2\n    elseif n == 2\
    \ then\n        return 4\n    elseif n == 3 then\n        return 8\n    elseif\
    \ n == 4 then\n        return 16\n    elseif n == 5 then\n        return 32\n\
    \    elseif n == 6 then\n        return 64\n    elseif n == 7 then\n        return\
    \ 128\n    elseif n == 8 then\n        return 27\n    elseif n == 9 then\n   \
    \     return 54\n    elseif n == 10 then\n        return 108\n    elseif n ==\
    \ 11 then\n        return 216\n    elseif n == 12 then\n        return 171\n \
    \   elseif n == 13 then\n        return 77\n    elseif n == 14 then\n        return\
    \ 154\n    elseif n == 15 then\n        return 47\n    elseif n == 16 then\n \
    \       return 94\n    elseif n == 17 then\n        return 188\n    elseif n ==\
    \ 18 then\n        return 99\n    elseif n == 19 then\n        return 198\n  \
    \  elseif n == 20 then\n        return 151\n    elseif n == 21 then\n        return\
    \ 53\n    elseif n == 22 then\n        return 106\n    elseif n == 23 then\n \
    \       return 212\n    elseif n == 24 then\n        return 179\n    elseif n\
    \ == 25 then\n        return 125\n    elseif n == 26 then\n        return 250\n\
    \    elseif n == 27 then\n        return 239\n    elseif n == 28 then\n      \
    \  return 197\n    elseif n == 29 then\n        return 145\n    elseif n == 30\
    \ then\n        return 57\n    elseif n == 31 then\n        return 114\n    elseif\
    \ n == 32 then\n        return 228\n    elseif n == 33 then\n        return 211\n\
    \    elseif n == 34 then\n        return 189\n    elseif n == 35 then\n      \
    \  return 97\n    elseif n == 36 then\n        return 194\n    elseif n == 37\
    \ then\n        return 159\n    elseif n == 38 then\n        return 37\n    elseif\
    \ n == 39 then\n        return 74\n    elseif n == 40 then\n        return 148\n\
    \   ", "\treturn (2^n - 1) % p\nend", "    if n == 0 then\n        return 1\n\
    \    elseif n == 1 then\n        return 2\n    elseif n % 2 == 0 then\n      \
    \  local r = modp(n / 2, p)\n        return (r * r) % p\n    else\n        local\
    \ r = modp(n - 1, p)\n        return (2 * r) % p\n    end\nend", "\tif p > max_cache\
    \ then\n\t\t-- Numerics beyond the cache's range have to be computed in a naive\
    \ way.\n\t\tlocal result = 1\n\t\tlocal factor = 2\n\t\tfor _ = 1, n do\n\t\t\t\
    result = (result * factor) % p\n\t\tend\n\t\treturn result\n\tend\n\treturn cached_modp[n][p]\n\
    end", "  if n == 0 then\n    return 1\n  elseif n % 2 == 0 then\n    return sqr(modp(n\
    \ / 2, p)) % p\n  else\n    return (sqr(modp((n - 1) / 2, p)) * 2) % p\n  end\n\
    end", "\tlocal c = 1\n\tfor i = 1, n do\n\t\tc = (c * 2) % p\n\tend\n\treturn\
    \ c\nend", "  n = n % p\n  -- For small n, directly compute 2^n mod p.\n  -- For\
    \ larger n, compute 2^(2^k) mod p for increasing k, then compute\n  -- 2^(2^k1)^(2^k2)^...^(2^km)\
    \ mod p, with k1 + k2 + ... + km = n.\n  -- This avoids large intermediate numbers.\n\
    \  local mod2 = 1\n  while n > 0 do\n    local h = math.floor(n / 2)\n    local\
    \ l = n - 2 * h\n    if l == 1 then\n      mod2 = (mod2 * 2) % p\n    end\n  \
    \  n = h\n  end\n  return mod2\nend", "  local r = 1\n  local d = 2\n  while n\
    \ > 0 do\n    if n % 2 == 1 then\n      r = (r * d) % p\n    end\n    d = (d *\
    \ d) % p\n    n = math.floor(n / 2)\n  end\n  return r\nend", "\tlocal res = 1\n\
    \tfor i = 1, n do\n\t\tres = (res * 2) % p\n\tend\n\treturn res\nend", "    local\
    \ mod = n\n    local div = math.floor(n / p)\n    while div > 0 do\n        mod\
    \ = mod - div * p\n        div = math.floor(mod / p)\n    end\n    return mod\n\
    end", "  return (2^n - 1) % p\nend", "\tlocal res = 1\n\twhile n > 0 do\n\t\t\
    if n % 2 == 1 then\n\t\t\tres = (res * 2) % p\n\t\tend\n\t\tn = floor(n / 2)\n\
    \tend\n\treturn res\nend", "    return mod((n*(2^32-1))%p, p)\nend", "    if n\
    \ == 0 then\n        return 1\n    elseif n == 1 then\n        return 2\n    elseif\
    \ n % 2 == 0 then\n        return modp(n/2, p)^2 % p\n    else\n        return\
    \ 2 * modp(n-1, p) % p\n    end\nend", "  if p == 2 then\n    return n\n  else\n\
    \    local s = 1\n    for i = 0, n - 1 do\n      s = (s * 2) % p\n    end\n  \
    \  return s\n  end\nend", "    local r = 1\n    for i = 1, n do\n        r = r\
    \ * 2 % p\n    end\n    return r\nend", "\tlocal res = 1;\n\twhile n > 0 do\n\t\
    \tif n % 2 == 1 then\n\t\t\tres = (res * 2) % p;\n\t\tend\n\t\tn = floor(n / 2);\n\
    \tend\n\treturn res;\nend", "  if n < 0 then\n    return (p - modp(-n, p)) % p\n\
    \  elseif n == 0 then\n    return 1\n  elseif n == 1 then\n    return 2\n  else\n\
    \    return n%2 == 0 and modp(n/2, p)^2 % p or (modp(n/2, p)^2 * 2) % p\n  end\n\
    end", "\tif n==0 then return 1 end\n\tif n==1 then return 2 end\n\tif n%2==0 then\n\
    \t\tlocal tmp = modp(n/2, p)\n\t\treturn (tmp*tmp)%p\n\telse\n\t\tlocal tmp =\
    \ modp(n-1, p)\n\t\treturn (2*tmp)%p\n\tend\nend", "\tlocal res = 1\n\tfor i =\
    \ 1, n do\n\t\tres = res * 2 % p\n\tend\n\treturn res\nend", "    local ret =\
    \ 1\n    while n > 0 do\n        if n%2 == 1 then\n            ret = (ret*2)%p\n\
    \        end\n        n = n/2\n    end\n    return ret\nend", "    if p == 2 then\n\
    \        return 1\n    end\n    local res = 1\n    local base = 2\n    while n\
    \ > 0 do\n        if n % 2 == 1 then\n            res = (res * base) % p\n   \
    \     end\n        n = math.floor(n / 2)\n        base = (base * base) % p\n \
    \   end\n    return res\nend", "  if (p == 2) then\n    return n % 2\n  else\n\
    \    return (2^n - 1) % p\n  end\nend", "  if n < p then\n    return 2^n\n  else\n\
    \    return (2^(n % (p-1))) % p\n  end\nend", "  local res = 1\n  while n > 0\
    \ do\n    if n%2 == 1 then\n      res = (res*2)%p\n    end\n    n = floor(n/2)\n\
    \    if n > 0 then\n      p = (p*p)%mod\n    end\n  end\n  return res\nend", " \
    \ local result = 1\n  for _ = 1, n do\n    result = (result * 2) % p\n  end\n\
    \  return result\nend", "    local t = 2 ^ n\n    local r = 1", "  if n == 0 then\n\
    \    return 1\n  elseif n == 1 then\n    return 2\n  elseif n % 2 == 0 then\n\
    \    return ((modp(n/2, p)^2) % p)\n  else\n    return ((2 * modp(n-1, p)) % p)\n\
    \  end\nend", "    -- Compute powers of 2 modulo p.\n    --\n    -- This table\
    \ is implemented as follows. Consider the exponent\n    -- n = [a_0, a_1, ...,\
    \ a_k], where a_i is the i-th bit of n. Then\n    -- 2^n mod p =\n    --   ((2^a_0\
    \ mod p) * (2^(2^a_1) mod p) * ... * (2^(2^a_k) mod p)) mod p.\n    --\n    --\
    \ We will let mp[n] = 2^n mod p, and store only\n    --   mp[n] = 2^(2^n) mod\
    \ p.\n    --\n    -- To compute mp[n + 1], we need mp[n], and we need to compute\n\
    \    -- 2^(2^(n + 1)) mod p = (2^(2^n))^2 mod p. This can be done without\n  \
    \  -- arithmetic (in lua) because lua numbers are floating point (32-bit\n   \
    \ -- integers, for our purposes).\n    --\n    -- And so mp[n + 1] is just mp[n]^2\
    \ % p.", "    local result = 1\n    for _ = 1, n do\n        result = (result\
    \ * 2) % p\n    end\n    return result\nend", "\tif n == 0 then\n\t\treturn 1\n\
    \telseif n == 1 then\n\t\treturn 2\n\telseif n == 2 then\n\t\treturn 4\n\telseif\
    \ n % 2 == 0 then\n\t\tlocal n2 = modp(n / 2, p)\n\t\treturn (n2 * n2) % p\n\t\
    else\n\t\tlocal n2 = modp(n - 1, p)\n\t\treturn (2 * n2) % p\n\tend\nend", "\t\
    local c, r = 0, 1\n\tfor i = 1, #n do\n\t\tr = (r * base) % p\n\t\tc = (c + r\
    \ * n[i]) % p\n\tend\n\treturn c\nend", "    n = n % p\n    local t = 1", "\t\
    if n >= 0 then\n\t\treturn 2^n % p\n\telse\n\t\treturn 2^(n+p) % p\n\tend\nend",
  "    -- return (2^n - 1) % p\n    local r = 1\n    for i = 1, n do\n        r =\
    \ (r * 2) % p\n    end\n    return r\nend", "    if n == 0 then\n        return\
    \ 1\n    elseif n == 1 then\n        return 2\n    elseif n % 2 == 0 then\n  \
    \      local t = modp(n / 2, p)\n        return ((t * t) % p)\n    else\n    \
    \    local t = modp(n - 1, p)\n        return ((t * 2) % p)\n    end\nend", "\t\
    local result = 1\n\tlocal power = 2\n\tlocal i = 1\n\twhile i <= n do\n\t\tif\
    \ math.fmod(n, 2^i) >= 2^(i-1) then\n\t\t\tresult = (result * power) % p\n\t\t\
    end\n\t\tpower = (power * power) % p\n\t\ti = i + 1\n\tend\n\treturn result\n\
    end", "  -- assert(n > 0, \"n must be positive\")\n  local h = bit32.lshift(1,\
    \ n-1) % p\n  local p2n = h\n  for i = n-1, 1, -1 do\n    p2n = bit32.band(p2n\
    \ * p2n, 0xFFFFFFFF)\n    if bit32.band(i, h) ~= 0 then\n      p2n = bit32.band(p2n\
    \ * 2, 0xFFFFFFFF)\n    end\n  end\n  return p2n\nend", "\tif n > (p - 1) / 2\
    \ then\n\t\tn = n - p\n\tend\n\treturn n\nend", "    local a = 1\n    for i =\
    \ 1, n do\n        a = (a * 2) % p\n    end\n    return a\nend", "    -- 2^n modulo\
    \ p == (2^(n mod(log2(p))) modulo p) * (2^(floor(n/log2(p))) modulo p)^(log2(p))\
    \ modulo p\n    local m = math.floor(n / math.log(2)) -- floor(n/log2(p))\n  \
    \  local o = n - m * math.log(2) -- n mod(log2(p))\n    local mp = modpow(2, o,\
    \ p) -- (2^(n mod(log2(p))) modulo p)\n    local pp = modpow(2, m, p) -- (2^(floor(n/log2(p)))\
    \ modulo p)^(log2(p)) modulo p\n    return mp * pp % p\nend", "\tlocal res = 1\n\
    \tfor i = 1, n do\n\t\tres = res * 2 % p\n\tend\n\treturn res\nend", "    if p\
    \ == 2 then\n        return 1\n    else\n        return (2^n - 1) % p\n    end\n\
    end", "\tlocal res = 1\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tres =\
    \ (res * 2) % p\n\t\tend\n\t\tn = math.floor(n / 2)\n\tend\n\treturn res\nend",
  "\tif type(n) ~= \"number\" then\n\t\terror(\"invalid input: \" .. tostring(n))\n\
    \tend\n\tif type(p) ~= \"number\" then\n\t\terror(\"invalid input: \" .. tostring(p))\n\
    \tend\n\tif p == 2 then\n\t\treturn n % 2\n\tend\n\tlocal c = 1\n\tfor i = 1,\
    \ n do\n\t\tc = (c * 2) % p\n\tend\n\treturn c\nend", "  local result = 1\n  while\
    \ n > 0 do\n    if n%2 == 1 then\n      result = (result*2)%p\n    end\n    n\
    \ = math.floor(n/2)\n  end\n  return result\nend", "\tlocal m = 1\n\tlocal two\
    \ = 2 % p\n\twhile n > 0 do\n\t\tif n % 2 == 1 then\n\t\t\tm = (m * two) % p\n\
    \t\tend\n\t\tn = math.floor(n / 2)\n\t\ttwo = (two * two) % p\n\tend\n\treturn\
    \ m\nend", "\tif n == 0 then\n\t\treturn 1\n\telseif n % 2 == 0 then\n\t\treturn\
    \ n % p * n % p % p\n\telse\n\t\treturn n % p * modp(n - 1, p) % p\n\tend\nend",
  "  return powermod(2, n, p)\nend", "  local c = 1\n  for i = 1, n do\n    c = (c\
    \ * 2) % p\n  end\n  return c\nend", "    local res = 1\n    for _ = 1, n do\n\
    \        res = (res * 2) % p\n    end\n    return res\nend", "    local y = 1\n\
    \    for i = 1, n do\n        y = y * 2 % p\n    end\n    return y\nend", "  \
    \  local b = 2\n    local e = n\n    local r = 1\n    while e > 0 do\n       \
    \ if e % 2 == 1 then\n            r = (r * b) % p\n        end\n        e = math.floor(e\
    \ / 2)\n        b = (b * b) % p\n    end\n    return r\nend", "    local r = 1\n\
    \    for i = 1, n do\n        r = 2 * r % p\n    end\n    return r\nend", "\t\
    if n == 0 then\n\t\treturn 1\n\telseif n == 1 then\n\t\treturn 2\n\telseif n ==\
    \ 2 then\n\t\treturn 4\n\telseif n == 3 then\n\t\treturn 5\n\telseif n == 4 then\n\
    \t\treturn 10\n\telseif n == 5 then\n\t\treturn 11\n\telseif n == 6 then\n\t\t\
    return 20\n\telseif n == 7 then\n\t\treturn 22\n\telseif n == 8 then\n\t\treturn\
    \ 37\n\telseif n == 9 then\n\t\treturn 41\n\telseif n == 10 then\n\t\treturn 74\n\
    \telseif n == 11 then\n\t\treturn 79\n\telseif n == 12 then\n\t\treturn 148\n\t\
    elseif n == 13 then\n\t\treturn 157\n\telseif n == 14 then\n\t\treturn 288\n\t\
    elseif n == 15 then\n\t\treturn 311\n\telseif n == 16 then\n\t\treturn 574\n\t\
    elseif n == 17 then\n\t\treturn 607\n\telseif n == 18 then\n\t\treturn 1142\n\t\
    elseif n == 19 then\n\t\treturn 1217\n\telseif n == 20 then\n\t\treturn 2287\n\
    \telseif n == 21 then\n\t\treturn 2434\n\telseif n == 22 then\n\t\treturn 4536\n\
    \telseif n == 23 then\n\t\treturn 4869\n\telseif n == 24 then\n\t\treturn 9075\n\
    \telseif n == 25 then\n\t\treturn 9744\n\telseif n == 26 then\n\t\treturn 18157\n\
    \telseif n == 27 then\n\t\treturn 19411\n\telseif n == 28 then\n\t\treturn 36362\n\
    \telseif n == 29 then\n\t\treturn 38823\n\telseif n == 30 then\n\t\treturn 72727\n\
    \telseif n == 31 then\n\t\treturn 77847\n\telseif n == 32 then\n\t\treturn 148148\n\
    \telseif n == 33 then\n\t\treturn 158959\n\telseif n == 34 then\n\t\treturn 301077\n\
    \telseif n == 35 then\n\t\treturn 322986\n\telseif n == 36 then\n\t\treturn 605154\n\
    \telseif n ==", "  return n - math.floor(n/p)*p\nend", "  if n==0 then return\
    \ 1 end\n  local f = modp(n/2, p)\n  local r = (f*f) % p\n  if n % 2 == 1 then\n\
    \    r = (r*2) % p\n  end\n  return r\nend", "\tlocal h = 1\n\tfor i = 1, n do\n\
    \t\th = h * 2 % p\n\tend\n\treturn h\nend", "    if n < p then\n        return\
    \ 1\n    else\n        -- Take care of odd p (which never divides 2^n - 1, the\
    \ characteristic of the Galois field)\n        if p % 2 == 1 then\n          \
    \  return 2 * modp(n, p - 1)\n        else\n            return modp(n * n, p)\n\
    \        end\n    end\nend", "    return mod(2^n, p)\nend", "  n = n % p\n  local\
    \ n2 = n*n\n  local p2 = n2 % p\n  local r = 4\n  while (r < p) do\n    r = r*r\n\
    \    p2 = p2*p2\n    p2 = p2 % p\n  end\n  if (n < p/2) then\n    return p2\n\
    \  else\n    return p - p2\n  end\nend", "\tlocal res = 1\n\twhile n > 0 do\n\t\
    \tif n % 2 == 1 then\n\t\t\tres = (res * 2) % p\n\t\tend\n\t\tn = n / 2\n\tend\n\
    \treturn res\nend", "    if p > pow_2_31 then\n        -- 2^n mod p = 2^(n mod\
    \ phi(p)) mod p\n        n = n % (p - 1)\n    end\n    return pow(2, n, p)\nend",
  "\tif n < 0 then\n\t\tn = n % p\n\tend\n\tlocal a = 1\n\tlocal b = 0\n\twhile n\
    \ > 0 do\n\t\tif n%2 == 1 then\n\t\t\ta = (a*2) % p\n\t\tend\n\t\tn = n//2\n\t\
    \tb = (b*2 + a) % p\n\tend\n\treturn b\nend", "    if p <= 0 then\n        error(\"\
    p must be > 0\")\n    end\n    local a = 1\n    local b = 2\n    while n > 0 do\n\
    \        if bit.band(n, 1) == 1 then\n            a = modmul(a, b, p)\n      \
    \  end\n        b = modmul(b, b, p)\n        n = bit.rshift(n, 1)\n    end\n \
    \   return a\nend", "  local res = 1\n  for _=1,n do\n    res = res*2\n    if\
    \ res > p then\n      res = res%p\n    end\n  end\n  return res\nend", "    if\
    \ n > 0 then\n        return 2^n % p\n    else\n        return 0\n    end\nend",
  "\tif n == 0 then\n\t\treturn 1\n\telseif n == 1 then\n\t\treturn 2\n\telseif n\
    \ % 2 == 0 then\n\t\tlocal t = modp(n / 2, p)\n\t\treturn (t * t) % p\n\telse\n\
    \t\treturn (2 * modp(n - 1, p)) % p\n\tend\nend", "    return math.fmod(2^n, p)\n\
    end", "  if n == 0 then\n    return 1\n  elseif n == 1 then\n    return 2\n  elseif\
    \ n == 2 then\n    return 4\n  elseif n == 3 then\n    return 8\n  elseif n ==\
    \ 4 then\n    return 16\n  elseif n == 5 then\n    return 32\n  elseif n == 6\
    \ then\n    return 64\n  elseif n == 7 then\n    return 128\n  elseif n == 8 then\n\
    \    return 256\n  elseif n == 9 then\n    return 512\n  elseif n == 10 then\n\
    \    return 1024\n  elseif n == 11 then\n    return 2048\n  elseif n == 12 then\n\
    \    return 4096\n  elseif n == 13 then\n    return 8192\n  elseif n == 14 then\n\
    \    return 16384\n  elseif n == 15 then\n    return 32768\n  elseif n == 16 then\n\
    \    return 65536\n  elseif n == 17 then\n    return 131072\n  elseif n == 18\
    \ then\n    return 262144\n  elseif n == 19 then\n    return 524288\n  elseif\
    \ n == 20 then\n    return 1048576\n  elseif n == 21 then\n    return 2097152\n\
    \  elseif n == 22 then\n    return 4194304\n  elseif n == 23 then\n    return\
    \ 8388608\n  elseif n == 24 then\n    return 16777216\n  elseif n == 25 then\n\
    \    return 33554432\n  elseif n == 26 then\n    return 67108864\n  elseif n ==\
    \ 27 then\n    return 134217728\n  elseif n == 28 then\n    return 268435456\n\
    \  elseif n == 29 then\n    return 536870912\n  elseif n == 30 then\n    return\
    \ 1073741824\n  elseif n == 31 then\n    return 2147483648\n  elseif n == 32 then\n\
    \    return 4294967296\n  elseif n == 33 then\n    return 8589934592\n  elseif\
    \ n == 34 then\n    return 17179869184\n  elseif n == 35 then\n    return 34359738368\n\
    \  elseif n == 36 then\n    return 68719476736\n  elseif n == 37", "  -- polynomial\
    \ coefficients (reversed)\n  local coeffs = { 1 }\n  local index = 1\n  local\
    \ k = n\n  while k > 0 do\n    local c = math.floor(k / 2)\n    if c * 2 < k then\n\
    \      index = index + 1\n      coeffs[index] = 1\n    end\n    k = c\n  end\n\
    \  -- evaluate polynomial\n  local result = coeffs[1]\n  local k = 1\n  while\
    \ index > 1 do\n    k = k * 2\n    index = index - 1\n    local coeff = coeffs[index\
    \ + 1]\n    if coeff then\n      result = (result * result * coeff) % p\n    else\n\
    \      result = (result * result) % p\n    end\n  end\n  return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
