name: HumanEval_6_parse_nested_parens
language: lua
prompt: "-- Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n-- For each of the group, output the deepest\
  \ level of nesting of parentheses.\n-- E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\nlocal function parse_nested_parens(paren_string)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = parse_nested_parens\n\
  \    lu.assertEquals(candidate('(()()) ((())) () ((())()())'), {2, 3, 1, 3})\n \
  \   lu.assertEquals(candidate('() (()) ((())) (((())))'), {1, 2, 3, 4})\n    lu.assertEquals(candidate('(()(())((())))'),\
  \ {4})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local stack = Stack:new()\n  local max_depth = 0\n  local current_depth\
    \ = 0\n  for i=1,#paren_string do\n    local c = paren_string:sub(i,i)\n    if\
    \ c == '(' then\n      current_depth = current_depth + 1\n      max_depth = math.max(max_depth,\
    \ current_depth)\n      stack:push(c)\n    elseif c == ')' then\n      stack:pop()\n\
    \      current_depth = current_depth - 1\n    end\n  end\n  return max_depth\n\
    end", "    local max_nesting_level = 0\n    local nesting_level = 0\n    for c\
    \ in paren_string:gmatch('.') do\n        if c == '(' then\n            nesting_level\
    \ = nesting_level + 1\n            if nesting_level > max_nesting_level then\n\
    \                max_nesting_level = nesting_level\n            end\n        elseif\
    \ c == ')' then\n            nesting_level = nesting_level - 1\n        end\n\
    \    end\n    return max_nesting_level\nend", "\tif not paren_string or paren_string\
    \ == \"\" then\n\t\treturn {}\n\tend\n\t\n\tlocal paren_tbl = {}\n\tfor paren\
    \ in string.gmatch(paren_string, \"%b()\") do\n\t\tlocal count = 0\n\t\tfor _\
    \ in string.gmatch(paren, \"()\") do\n\t\t\tcount = count + 1\n\t\tend\n\t\ttable.insert(paren_tbl,\
    \ count)\n\tend\n\treturn paren_tbl\nend", "\tlocal nparens = #paren_string\n\t\
    local rparens = {}\n\tlocal i\n\tfor i = 1, nparens do\n\t\tlocal paren = {}\n\
    \t\tlocal str = paren_string[i]\n\t\tlocal last_start = 1\n\t\tlocal last_end\
    \ = 0\n\t\tlocal level = 0\n\t\twhile true do\n\t\t\tlocal start, end_ = string.find(str,\
    \ \"()\", last_end + 1)\n\t\t\tif start then\n\t\t\t\tlocal c = string.sub(str,\
    \ start + 1, end_)\n\t\t\t\tif c == \"(\" then\n\t\t\t\t\tlevel = level + 1\n\t\
    \t\t\telse\n\t\t\t\t\tlevel = level - 1\n\t\t\t\tend\n\t\t\t\tif level == 0 then\n\
    \t\t\t\t\tif string.sub(str, last_start, start - 1) ~= \"\" then\n\t\t\t\t\t\t\
    table.insert(paren, string.sub(str, last_start, start - 1))\n\t\t\t\t\tend\n\t\
    \t\t\t\tlast_start = end_ + 1\n\t\t\t\tend\n\t\t\t\tlast_end = end_\n\t\t\telse\n\
    \t\t\t\ttable.insert(paren, string.sub(str, last_start))\n\t\t\t\tbreak\n\t\t\t\
    end\n\t\tend\n\t\ttable.insert(rparens, paren)\n\tend\n\treturn rparens\nend",
  "    local i = 1\n    local max_depth = 0\n    local current_depth = 0\n    local\
    \ paren_table = {}\n    for i = 1, string.len(paren_string) do\n        if (string.sub(paren_string,\
    \ i, i) == \"(\") then\n            current_depth = current_depth + 1\n      \
    \      if (current_depth > max_depth) then\n                max_depth = current_depth\n\
    \            end\n        elseif (string.sub(paren_string, i, i) == \")\") then\n\
    \            current_depth = current_depth - 1\n        end\n    end\n    table.insert(paren_table,\
    \ max_depth)\n    return paren_table\nend", "\tlocal current_level = 0\n\tlocal\
    \ max_level = 0\n\tfor i = 1, #paren_string do\n\t\tlocal c = paren_string:sub(i,\
    \ i)\n\t\tif c == '(' then\n\t\t\tcurrent_level = current_level + 1\n\t\t\tif\
    \ current_level > max_level then\n\t\t\t\tmax_level = current_level\n\t\t\tend\n\
    \t\telseif c == ')' then\n\t\t\tcurrent_level = current_level - 1\n\t\tend\n\t\
    end\n\treturn max_level\nend", "  local count = 0\n  local max_count = 0\n  for\
    \ i = 1, #paren_string do\n    if paren_string:sub(i, i) == '(' then\n      count\
    \ = count + 1\n      if count > max_count then\n        max_count = count\n  \
    \    end\n    elseif paren_string:sub(i, i) == ')' then\n      count = count -\
    \ 1\n    end\n  end\n  return max_count\nend", "    local level = 0\n    local\
    \ max_level = 0\n    for _, paren in string.gmatch(paren_string, \"(.)\") do\n\
    \        if paren == \"(\" then\n            level = level + 1\n            if\
    \ level > max_level then\n                max_level = level\n            end\n\
    \        elseif paren == \")\" then\n            level = level - 1\n        end\n\
    \    end\n    return max_level\nend", "    local list = {}\n    for group in string.gmatch(paren_string,\
    \ \"[^%s]+\") do\n        local len = group:len()\n        local max_level = 0\n\
    \        local level = 0\n        for i = 1, len do\n            local c = group:sub(i,\
    \ i)\n            if c == \"(\" then\n                level = level + 1\n    \
    \        elseif c == \")\" then\n                level = level - 1\n         \
    \   end\n            if level > max_level then\n                max_level = level\n\
    \            end\n        end\n        table.insert(list, max_level)\n    end\n\
    \    return list\nend", "\tif paren_string == \"\" then\n\t\treturn \"\"\n\tend\n\
    \tlocal paren_list = string.split(paren_string, \" \")\n\tlocal max_depth = 0\n\
    \tlocal function recurse(input, depth)\n\t\tdepth = depth + 1\n\t\tlocal len =\
    \ #input\n\t\tfor i = 1, len do\n\t\t\tlocal c = input:sub(i, i)\n\t\t\tif c ==\
    \ \"(\" then\n\t\t\t\trecurse(input:sub(i+1), depth)\n\t\t\telseif c == \")\"\
    \ then\n\t\t\t\tmax_depth = math.max(max_depth, depth)\n\t\t\t\treturn\n\t\t\t\
    end\n\t\tend\n\tend\n\tfor _, paren_group in ipairs(paren_list) do\n\t\trecurse(paren_group,\
    \ 0)\n\tend\n\treturn max_depth\nend", "    local groups = {}\n    for i = 1,\
    \ #paren_string do\n        local c = paren_string:sub(i, i)\n        if c ==\
    \ ' ' then\n            table.insert(groups, current_group)\n            current_group\
    \ = {}\n        else\n            table.insert(current_group, c)\n        end\n\
    \    end\n    table.insert(groups, current_group)\n    local parsed_groups = {}\n\
    \    for i = 1, #groups do\n        table.insert(parsed_groups, parse_group(groups[i]))\n\
    \    end\n    return parsed_groups\nend", "    local levels = {}\n    local level\
    \ = 0\n    for char in paren_string:gmatch\".\" do\n        if char == \"(\" then\n\
    \            level = level + 1\n        elseif char == \")\" then\n          \
    \  level = level - 1\n        end\n        levels[#levels + 1] = level\n    end\n\
    \    return levels\nend", "  -- Convert the string into an array of groups.\n\
    \  local groups = {}\n  for group in paren_string:gmatch(\"%S+\") do\n    table.insert(groups,\
    \ group)\n  end", "\tlocal level = 0\n\tlocal max_level = 0\n\tlocal max_level_string\
    \ = {}\n\tfor _, paren in utf8.codes(paren_string) do\n\t\tif paren == 40 then\
    \ -- 40 is open paren\n\t\t\tlevel = level + 1\n\t\t\tif level > max_level then\n\
    \t\t\t\tmax_level = level\n\t\t\tend\n\t\telseif paren == 41 then -- 41 is close\
    \ paren\n\t\t\tlevel = level - 1\n\t\tend\n\tend\n\ttable.insert(max_level_string,\
    \ max_level)\n\treturn table.concat(max_level_string, \" \")\nend", "    local\
    \ res_table = {}\n    local paren_array = string.split(paren_string, ' ')\n  \
    \  for i,v in ipairs(paren_array) do\n        local level = 0\n        local max_level\
    \ = 0\n        for c in v:gmatch(\".\") do\n            if c == '(' then\n   \
    \             level = level + 1\n            elseif c == ')' then\n          \
    \      level = level - 1\n            end\n            if level > max_level then\n\
    \                max_level = level\n            end\n        end\n        res_table[i]\
    \ = max_level\n    end\n    return res_table\nend", "  -- Create a lookup table\
    \ (hash-table) for storing #levels of nesting per each group\n  local nest_depth\
    \ = {}\n  -- First, split the string by spaces\n  for group in paren_string:gmatch(\"\
    %S+\") do\n    -- Then, for each group, loop through the parentheses\n    local\
    \ depth = 0\n    local max_depth = 0\n    for i = 1, #group do\n      -- If the\
    \ char is a \"(\"\n      if group:sub(i, i) == \"(\" then\n        -- Increase\
    \ current depth\n        depth = depth + 1\n        -- Update the maximum depth\
    \ if current depth is higher\n        if depth > max_depth then\n          max_depth\
    \ = depth\n        end\n      -- If the char is a \")\"\n      elseif group:sub(i,\
    \ i) == \")\" then\n        -- Decrease current depth\n        depth = depth -\
    \ 1\n      end\n    end\n    -- Store the maximum depth for the current group\n\
    \    nest_depth[group] = max_depth\n  end\n  -- Return the lookup table\n  return\
    \ nest_depth\nend", "    local depth = 0\n    local max_depth = 0\n    for i =\
    \ 1, string.len(paren_string) do\n        local paren = string.sub(paren_string,\
    \ i, i)\n        if paren == \"(\" then\n            depth = depth + 1\n     \
    \       if depth > max_depth then\n                max_depth = depth\n       \
    \     end\n        elseif paren == \")\" then\n            depth = depth - 1\n\
    \        end\n    end\n    return max_depth\nend", "\t-- Separate the parenthesis\
    \ strings from the others.\n\tlocal paren_strings = string.split(paren_string,\
    \ \" \")\n\t-- For each of the parenthesis string, count the depth of nesting.\n\
    \tlocal paren_depths = {}\n\tfor i = 1, #paren_strings do\n\t\t-- Initialize the\
    \ max depth to 0.\n\t\tlocal max_depth = 0\n\t\t-- Initialize the depth.\n\t\t\
    local depth = 0\n\t\t-- Loop through each of the character in the string.\n\t\t\
    for j = 1, #paren_strings[i] do\n\t\t\tif paren_strings[i]:sub(j, j) == \"(\"\
    \ then\n\t\t\t\t-- If the character is \"(\", increment the depth by 1.\n\t\t\t\
    \tdepth = depth + 1\n\t\t\t\t-- Update the max depth if necessary.\n\t\t\t\tif\
    \ depth > max_depth then\n\t\t\t\t\tmax_depth = depth\n\t\t\t\tend\n\t\t\telseif\
    \ paren_strings[i]:sub(j, j) == \")\" then\n\t\t\t\t-- If the character is \"\
    )\", decrement the depth by 1.\n\t\t\t\tdepth = depth - 1\n\t\t\tend\n\t\tend\n\
    \t\t-- Add the max depth of this parenthesis string to the table of depths.\n\t\
    \ttable.insert(paren_depths, max_depth)\n\tend\n\t-- Return the string of depths.\n\
    \treturn table.concat(paren_depths, \" \")\nend", "  local outer_paren_index =\
    \ 1\n  local depth_list = {}\n  while true do\n    local inner_paren_index = paren_string:find('%b()',\
    \ outer_paren_index)\n    if not inner_paren_index then\n      break\n    end\n\
    \    local depth = 1\n    while paren_string:sub(inner_paren_index + depth, inner_paren_index\
    \ + depth) == '(' do\n      depth = depth + 1\n    end\n    table.insert(depth_list,\
    \ depth)\n    outer_paren_index = inner_paren_index + 1\n  end\n  return depth_list\n\
    end", "\tlocal s = tf_string.split(paren_string, \" \")\n\tlocal result = {}\n\
    \tfor i, v in ipairs(s) do\n\t\ttable.insert(result, parse_max_depth(v))\n\tend\n\
    \treturn result\nend", "    local max_level = 0\n    local level = 0\n    for\
    \ i = 1, #paren_string do\n        local c = paren_string:sub(i, i)\n        if\
    \ c == '(' then\n            level = level + 1\n            if level > max_level\
    \ then\n                max_level = level\n            end\n        elseif c ==\
    \ ')' then\n            level = level - 1\n        end\n    end\n    return max_level\n\
    end", "    local level = 0\n    local max_level = 0\n    for i = 1, #paren_string\
    \ do\n        local char = paren_string:sub(i, i)\n        if char == '(' then\n\
    \            level = level + 1\n            if level > max_level then\n      \
    \          max_level = level\n            end\n        elseif char == ')' then\n\
    \            level = level - 1\n        end\n    end\n    return max_level\nend",
  "    local depth = 0\n    local max_depth = 0\n    for paren in paren_string:gmatch('%(%(?')\
    \ do\n        if paren == '(' then\n            depth = depth + 1\n          \
    \  if depth > max_depth then\n                max_depth = depth\n            end\n\
    \        else\n            depth = depth - 1\n        end\n    end\n    return\
    \ max_depth\nend", "    -- Parse groups of parentheses.\n    local groups = {}\n\
    \    for s in paren_string:gmatch(\"%b()\") do\n        -- For each group, parse\
    \ pairs of parentheses.\n        local pairs = {}\n        for s in s:gmatch(\"\
    %b()\") do\n            -- Ignore any parentheses that cannot be parsed as a number.\n\
    \            local i = tonumber(s:sub(2, -2))\n            if i then\n       \
    \         pairs[#pairs + 1] = i\n            end\n        end\n        groups[#groups\
    \ + 1] = pairs\n    end\n    return groups\nend", "  -- If a number is passed\
    \ as a parameter instead of a string, then just return it\n  if not paren_string\
    \ then return end\n  local number = tonumber(paren_string)\n  if number then return\
    \ number end", "  local deeper, deepest = 0, 0\n  local chars = ustring.to_char_table(paren_string)\n\
    \  for _, v in ipairs(chars) do\n    if v == \"(\" then\n      deeper = deeper\
    \ + 1\n      if deeper > deepest then\n        deepest = deeper\n      end\n \
    \   elseif v == \")\" then\n      deeper = deeper - 1\n    end\n  end\n  return\
    \ deepest\nend", "  local max_level = 0\n  for paren_string in paren_string:gmatch(\"\
    %S+\") do\n    local cur_level = 0\n    for char in paren_string:gmatch(\".\"\
    ) do\n      if char == \"(\" then\n        cur_level = cur_level + 1\n      elseif\
    \ char == \")\" then\n        cur_level = cur_level - 1\n      end\n      if cur_level\
    \ > max_level then\n        max_level = cur_level\n      end\n    end\n  end\n\
    \  return max_level\nend", "\tlocal level_max = {}\n\tlocal open_parens = 0\n\t\
    local level = 0\n\tfor s in paren_string:gmatch(\"%S+\") do\n\t\tfor c in s:gmatch\"\
    .\" do\n\t\t\tif c == \"(\" then\n\t\t\t\topen_parens = open_parens + 1\n\t\t\t\
    \tlevel = level + 1\n\t\t\t\tif level > level_max[open_parens] then\n\t\t\t\t\t\
    level_max[open_parens] = level\n\t\t\t\tend\n\t\t\telseif c == \")\" then\n\t\t\
    \t\tlevel = level - 1\n\t\t\tend\n\t\tend\n\t\topen_parens = 0\n\t\tlevel = 0\n\
    \tend\n\treturn table.concat(level_max, \" \")\nend", '  local paren_levels =
    {}', "  local max_nesting = 0\n  local current_nesting = 0\n  for c in paren_string:gmatch('.')\
    \ do\n    if c == '(' then\n      current_nesting = current_nesting + 1\n    \
    \  if current_nesting > max_nesting then\n        max_nesting = current_nesting\n\
    \      end\n    elseif c == ')' then\n      current_nesting = current_nesting\
    \ - 1\n    end\n  end\n  return max_nesting\nend", "\tlocal open_parens = 0\n\t\
    local max_depth = 0\n\tlocal current_depth = 0\n\tfor c in paren_string:gmatch(\"\
    .\") do\n\t\tcurrent_depth = current_depth + 1\n\t\tif c == \"(\" then\n\t\t\t\
    open_parens = open_parens + 1\n\t\t\tif open_parens > max_depth then\n\t\t\t\t\
    max_depth = open_parens\n\t\t\tend\n\t\telseif c == \")\" then\n\t\t\topen_parens\
    \ = open_parens - 1\n\t\tend\n\tend\n\tassert(open_parens == 0, \"Error: malformed\
    \ parenthesis string\")\n\treturn max_depth\nend", "    assert(paren_string ~=\
    \ nil, \"Error in input, nil string is not allowed\")\n    local idx = 1\n   \
    \ local max = -1\n    local strlen = string.len(paren_string)\n    for i = 1,\
    \ strlen do\n        if string.sub(paren_string, i, i) == \"(\" then\n       \
    \     idx = idx + 1\n        elseif string.sub(paren_string, i, i) == \")\" then\n\
    \            if idx > max then\n                max = idx\n            end\n \
    \           idx = idx - 1\n        end\n    end\n    return max\nend", "    --\
    \ Split by space and then parse each individual group\n    for str in stringx.split(paren_string)\
    \ do\n        local max_depth = 0\n        local depth = 0\n        for c in str:gmatch('.')\
    \ do\n            if c == '(' then\n                depth = depth + 1\n      \
    \          max_depth = math.max(max_depth, depth)\n            elseif c == ')'\
    \ then\n                depth = depth - 1\n            end\n        end\n    \
    \    print(max_depth)\n    end\nend", "  local levels = {}\n  local acc = 0\n\
    \  for i = 1, #paren_string do\n    local c = paren_string:sub(i, i)\n    if c\
    \ == '(' then\n      acc = acc + 1\n    elseif c == ')' then\n      acc = acc\
    \ - 1\n    elseif c == ' ' then\n      levels[#levels + 1] = acc\n    end\n  end\n\
    \  return levels\nend", "\tlocal max_nest = 0\n\tlocal cur_nest = 0\n\tfor i =\
    \ 1, #paren_string do\n\t\tlocal char = paren_string:sub(i, i)\n\t\tif char ==\
    \ '(' then\n\t\t\tcur_nest = cur_nest + 1\n\t\t\tif cur_nest > max_nest then\n\
    \t\t\t\tmax_nest = cur_nest\n\t\t\tend\n\t\telseif char == ')' then\n\t\t\tcur_nest\
    \ = cur_nest - 1\n\t\tend\n\tend\n\treturn max_nest\nend", "    local paren_arr\
    \ = split(paren_string, \" \")\n    local max_nest = 0\n    for _, paren in ipairs(paren_arr)\
    \ do\n        local nest = paren_nesting(paren)\n        if nest > max_nest then\n\
    \            max_nest = nest\n        end\n    end\n    return max_nest\nend",
  "  local paren_table = {}\n  for _, s in ipairs(stringx.split(paren_string)) do\n\
    \    local max_depth = 0\n    local depth = 0\n    for i = 1, #s do\n      local\
    \ c = s:sub(i, i)\n      if c == '(' then\n        depth = depth + 1\n      elseif\
    \ c == ')' then\n        depth = depth - 1\n      end\n      max_depth = math.max(max_depth,\
    \ depth)\n    end\n    table.insert(paren_table, max_depth)\n  end\n  return paren_table\n\
    end", "    local level = 0\n    local max_level = 0\n    for i = 1, #paren_string\
    \ do\n        local char = paren_string:sub(i, i)\n        if char == '(' then\n\
    \            level = level + 1\n            if level > max_level then\n      \
    \          max_level = level\n            end\n        elseif char == ')' then\n\
    \            level = level - 1\n        end\n    end\n    return max_level\nend",
  "  local paren_strings = {}\n  local previous_start = 0\n  for paren_start, paren_end\
    \ in paren_string:gmatch(\"()%s*()\") do\n    if paren_start ~= 1 then\n     \
    \ table.insert(paren_strings, paren_string:sub(previous_start, paren_start - 1))\n\
    \    end\n    previous_start = paren_end\n  end\n  if previous_start <= #paren_string\
    \ then\n    table.insert(paren_strings, paren_string:sub(previous_start))\n  end\n\
    \  local max_level = 0\n  for i = 1, #paren_strings do\n    max_level = math.max(max_level,\
    \ parse_single_paren(paren_strings[i]))\n  end\n  return max_level\nend", "  local\
    \ max_num_nested_parentheses = 0\n  for group in string.gmatch(paren_string, \"\
    %(([^%(]*)%)\") do\n    local num_nested_parentheses = 0\n    for char in string.gmatch(group,\
    \ \".\") do\n      if char == \"(\" then\n        num_nested_parentheses = num_nested_parentheses\
    \ + 1\n      elseif char == \")\" then\n        num_nested_parentheses = num_nested_parentheses\
    \ - 1\n      end\n    end\n    if num_nested_parentheses > max_num_nested_parentheses\
    \ then\n      max_num_nested_parentheses = num_nested_parentheses\n    end\n \
    \ end\n  return max_num_nested_parentheses\nend", "  local paren_tab = string.split(paren_string,\
    \ \" \")\n  local paren_count = {}\n  for _, v in ipairs(paren_tab) do\n    local\
    \ paren_curr_count = {}\n    local level = 0\n    for i = 1, #v do\n      if v:sub(i,\
    \ i) == \"(\" then\n        level = level + 1\n        paren_curr_count[level]\
    \ = 1\n      elseif v:sub(i, i) == \")\" then\n        paren_curr_count[level]\
    \ = nil\n        level = level - 1\n      end\n    end\n    paren_count[#paren_count\
    \ + 1] = level\n  end\n  return paren_count\nend", "    local depth = 0\n    local\
    \ max_depth = 0\n    for i = 1, #paren_string do\n        if paren_string:sub(i,\
    \ i) == '(' then\n            depth = depth + 1\n            if depth > max_depth\
    \ then\n                max_depth = depth\n            end\n        elseif paren_string:sub(i,\
    \ i) == ')' then\n            depth = depth - 1\n        end\n    end\n    return\
    \ max_depth\nend", "  local paren_list = {}\n  local cur_paren = \"\"\n  local\
    \ n_paren = 0\n  local n_max_paren = 0\n  local i = 1\n  while i <= #paren_string\
    \ do\n    if paren_string:sub(i,i) == \"(\" then\n      cur_paren = cur_paren\
    \ .. \"(\"\n      n_paren = n_paren + 1\n      if n_paren > n_max_paren then\n\
    \        n_max_paren = n_paren\n      end\n    elseif paren_string:sub(i,i) ==\
    \ \")\" then\n      cur_paren = cur_paren .. \")\"\n      n_paren = n_paren -\
    \ 1\n    elseif paren_string:sub(i,i) == \" \" then\n      table.insert(paren_list,\
    \ cur_paren)\n      cur_paren = \"\"\n      n_paren = 0\n      n_max_paren = 0\n\
    \    end\n    i = i + 1\n  end\n  table.insert(paren_list, cur_paren)\n  return\
    \ paren_list, n_max_paren\nend", "    local iter = paren_string:gmatch(\"%w+\"\
    )\n    local paren_list = {}\n    local level_list = {}\n    local paren_level\
    \ = 0\n    local max_level = 0\n    for sub in iter do\n        local paren_count\
    \ = {}\n        -- count parentheses in a group string\n        for i in sub:gmatch(\"\
    (%()\") do\n            paren_count[\"(\"] = (paren_count[\"(\"] or 0) + 1\n \
    \       end\n        for i in sub:gmatch(\"%)\") do\n            paren_count[\"\
    )\"] = (paren_count[\")\"] or 0) + 1\n        end\n        -- if parentheses are\
    \ balanced\n        if paren_count[\"(\"] == paren_count[\")\"] then\n       \
    \     paren_level = paren_level + paren_count[\"(\"]\n            table.insert(paren_list,\
    \ sub)\n            table.insert(level_list, paren_level)\n            max_level\
    \ = math.max(max_level, paren_level)\n        -- if parentheses are not balanced,\
    \ then check if they're nested\n        else\n            -- (x)x\n          \
    \  if paren_count[\"(\"] == paren_count[\")\"] + 1 then\n                paren_level\
    \ = paren_level + paren_count[\"(\"]\n                table.insert(paren_list,\
    \ sub)\n                table.insert(level_list, paren_level)\n              \
    \  max_level = math.max(max_level, paren_level)\n            -- (xx)\n       \
    \     elseif paren_count[\"(\"] + 1 == paren_count[\")\"] then\n             \
    \   paren_level = paren_level + paren_count[\"(\"]\n                table.insert(paren_list,\
    \ sub)\n                table.insert(level_list, paren_level)\n              \
    \  max_level = math.max(max_level, paren_level)\n            -- (x)\n        \
    \    elseif paren_count[\"(\"] == 1 and paren_count[\")\"] == 1 then\n       \
    \         table.insert(paren_list, sub)\n                table.insert(level_list,\
    \ 0)\n            else\n                print(\"This string", "  local match_result,\
    \ count\n  local out_string = \"\"\n  for word in string.gmatch(paren_string,\
    \ \"%S+\") do\n    count = 0\n    for match_result in string.gmatch(word, \"()\"\
    ) do\n      count = count + 1\n    end\n    out_string = out_string .. count ..\
    \ \" \"\n  end\n  return out_string\nend", "  -- each pair of parentheses has\
    \ a level of nesting\n  -- the level is one greater than that of its parent\n\
    \  -- the top level has nesting 0\n  local bracket_nesting = 0\n  local max_nesting\
    \ = 0\n  local depth_table = {}\n  for i = 1, #paren_string do\n    local c =\
    \ paren_string:sub(i, i)\n    if c == '(' then\n      bracket_nesting = bracket_nesting\
    \ + 1\n      max_nesting = math.max(max_nesting, bracket_nesting)\n    elseif\
    \ c == ')' then\n      bracket_nesting = bracket_nesting - 1\n    end\n    --\
    \ don't store the bracket nesting info at the top level\n    if bracket_nesting\
    \ > 0 then\n      depth_table[i] = bracket_nesting\n    end\n  end\n  -- a table\
    \ with keys of the position of each right bracket, and\n  -- the value the max\
    \ depth at that position\n  return depth_table, max_nesting\nend", "    local\
    \ paren_depth = {0}\n    local current_depth = 1\n    local max_depth = 0\n  \
    \  local open_parens = {\"(\"}\n    local close_parens = {\")\"}\n    for i =\
    \ 1, #paren_string do\n        local current_character = paren_string:sub(i, i)\n\
    \        for j = 1, #open_parens do\n            if current_character == open_parens[j]\
    \ then\n                current_depth = current_depth + 1\n                if\
    \ current_depth > max_depth then\n                    max_depth = current_depth\n\
    \                end\n                paren_depth[#paren_depth + 1] = current_depth\n\
    \                break\n            elseif current_character == close_parens[j]\
    \ then\n                current_depth = current_depth - 1\n                paren_depth[#paren_depth\
    \ + 1] = current_depth\n                break\n            end\n        end\n\
    \    end\n    return paren_depth\nend", "    local max_level = 0\n    for _, paren\
    \ in ipairs(stringx.split(paren_string)) do\n        local level = 0\n       \
    \ for _ in paren:gmatch('%(') do\n            level = level + 1\n        end\n\
    \        max_level = math.max(max_level, level)\n    end\n    return max_level\n\
    end", "\tlocal max_depth = 0\n\tlocal curr_depth = 0\n\tlocal i = 1\n\twhile i\
    \ <= #paren_string do\n\t\tif paren_string:sub(i, i) == '(' then\n\t\t\tcurr_depth\
    \ = curr_depth + 1\n\t\t\tif curr_depth > max_depth then\n\t\t\t\tmax_depth =\
    \ curr_depth\n\t\t\tend\n\t\telseif paren_string:sub(i, i) == ')' then\n\t\t\t\
    curr_depth = curr_depth - 1\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn max_depth\n\
    end", "  local deepest_nesting = 0\n  local current_nesting = 0\n  local i = 1\n\
    \  while i <= #paren_string do\n    if paren_string:sub(i, i) == '(' then\n  \
    \    current_nesting = current_nesting + 1\n      if current_nesting > deepest_nesting\
    \ then\n        deepest_nesting = current_nesting\n      end\n    elseif paren_string:sub(i,\
    \ i) == ')' then\n      current_nesting = current_nesting - 1\n    end\n    i\
    \ = i + 1\n  end\n  return deepest_nesting\nend", "    local nParens = {}\n  \
    \  local counter = 0\n    local acc = 0\n    for i=1,string.len(paren_string)\
    \ do\n        if string.sub(paren_string,i,i) == '(' then\n            counter\
    \ = counter + 1\n            acc = acc + 1\n        elseif string.sub(paren_string,i,i)\
    \ == ')' then\n            counter = counter - 1\n            if counter == 0\
    \ then\n                nParens[#nParens+1] = acc\n                acc = 0\n \
    \           end\n        end\n    end\n    return nParens\nend", "  -- The code\
    \ below will work for the one level nested parens in the exampel above.\n  --\
    \ For multiple levels nested parens, you need to implement some stack logic.\n\
    \  local max_depth = 0\n  local depth = 0\n  local token_index = 1\n  while token_index\
    \ <= #paren_string do\n    local token = paren_string:sub(token_index, token_index)\n\
    \    if token == '(' then\n      depth = depth + 1\n      if depth > max_depth\
    \ then\n        max_depth = depth\n      end\n    elseif token == ')' then\n \
    \     depth = depth - 1\n    end\n    token_index = token_index + 1\n  end\n \
    \ return max_depth\nend", "    local s = preprocessing(paren_string)\n    local\
    \ paren_count = count_parens(s)\n    local max_paren_count = count_max_parens(paren_count)\n\
    \    return max_paren_count\nend", "    return paren_string:gsub('%b()', function(x)\
    \ return 1 + parse_nested_parens(x:sub(2, -2)) end)\nend", "  if not paren_string\
    \ then return nil end\n  local paren_strings = utils.split(paren_string)\n  local\
    \ max_nest_lens = {}\n  for _, ps in ipairs(paren_strings) do\n    local max_nest_len\
    \ = nil\n    local cur_nest_len = 0\n    for _, char in utils.unicode_utf8_string_iter(ps)\
    \ do\n      if char == '(' then\n        cur_nest_len = cur_nest_len + 1\n   \
    \   elseif char == ')' then\n        cur_nest_len = cur_nest_len - 1\n      end\n\
    \      if cur_nest_len > max_nest_len then\n        max_nest_len = cur_nest_len\n\
    \      end\n    end\n    table.insert(max_nest_lens, max_nest_len)\n  end\n  return\
    \ max_nest_lens\nend", "    local depth = 0\n    local max_depth = 0\n    for\
    \ i = 1, #paren_string do\n        if paren_string:sub(i, i) == '(' then\n   \
    \         depth = depth + 1\n            if depth > max_depth then\n         \
    \       max_depth = depth\n            end\n        elseif paren_string:sub(i,\
    \ i) == ')' then\n            depth = depth - 1\n        end\n    end\n    return\
    \ max_depth\nend", "    local count = 0\n    local max_count = 0\n    for c in\
    \ paren_string:gmatch(\".\") do\n        if c == \"(\" then\n            count\
    \ = count + 1\n            if count > max_count then\n                max_count\
    \ = count\n            end\n        elseif c == \")\" then\n            count\
    \ = count - 1\n        end\n    end\n    return max_count\nend", "    local paren_table\
    \ = {}\n    local sub_group = {}\n    local max_level = 0\n    for i = 1, #paren_string\
    \ do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n   \
    \         table.insert(sub_group, '(')\n        elseif c == ')' then\n       \
    \     table.insert(sub_group, ')')\n        elseif c == ' ' then\n           \
    \ table.insert(paren_table, sub_group)\n            if #sub_group > max_level\
    \ then\n                max_level = #sub_group\n            end\n            sub_group\
    \ = {}\n        end\n    end\n    return paren_table, max_level\nend", "\tlocal\
    \ max_level = 1\n\tlocal level = 1\n\tfor c in paren_string:gmatch\".\" do\n\t\
    \tif c == \"(\" then\n\t\t\tlevel = level + 1\n\t\t\tif level > max_level then\n\
    \t\t\t\tmax_level = level\n\t\t\tend\n\t\telseif c == \")\" then\n\t\t\tlevel\
    \ = level - 1\n\t\tend\n\tend\n\treturn max_level\nend", "\t-- Split the groups\n\
    \tlocal groups = {}\n\tstringx.split(paren_string, \" \", function(str)\n\t\t\
    table.insert(groups, str)\n\tend)", "    local counters = {}\n    for i = 1, #paren_string\
    \ do\n        local ch = paren_string:sub(i, i)\n        if ch == '(' then\n \
    \           table.insert(counters, 0)\n        elseif ch == ')' then\n       \
    \     table.insert(counters, counters[#counters] + 1)\n            table.remove(counters,\
    \ #counters - 1)\n        end\n    end\n    return counters\nend", "  local paren_list\
    \ = seq.list_from_string(paren_string)\n  local depth = 0\n  local depth_list\
    \ = {}\n  for i = 1, #paren_list do\n    if paren_list[i] == '(' then\n      depth\
    \ = depth + 1\n    elseif paren_list[i] == ')' then\n      table.insert(depth_list,\
    \ depth)\n      depth = depth - 1\n    end\n  end\n  return table.concat(depth_list,\
    \ ' ')\nend", "  local paren_list = stringx.split(paren_string, ' ')\n  local\
    \ max_nest_list = {}\n  for i, paren in ipairs(paren_list) do\n    local stack\
    \ = Stack:new()\n    local max_nest = 0\n    for j=1, #paren do\n      local char\
    \ = paren:sub(j, j)\n      if char == '(' then\n        stack:push(char)\n   \
    \   elseif char == ')' then\n        stack:pop()\n      end\n      max_nest =\
    \ math.max(max_nest, stack:size())\n    end\n    table.insert(max_nest_list, max_nest)\n\
    \  end\n  return max_nest_list\nend", "\tlocal max_level = 0\n\tfor group in paren_string:gmatch(\"\
    %b()\") do\n\t\tlocal level = group:match(\"^(%b())\") and 2 or 1\n\t\tfor paren\
    \ in group:gmatch(\"%b()\") do\n\t\t\tlevel = level + 1\n\t\tend\n\t\tmax_level\
    \ = math.max(max_level, level)\n\tend\n\treturn max_level\nend", "    local paren_arr\
    \ = split(paren_string, ' ')\n    local paren_counts = {}\n    for i = 1, #paren_arr\
    \ do\n        local paren_count = 0\n        local paren_str = paren_arr[i]\n\
    \        local paren_len = string.len(paren_str)\n        local is_end = false\n\
    \        for j = 1, paren_len do\n            local cur_char = string.sub(paren_str,\
    \ j, j)\n            if cur_char == '(' then\n                paren_count = paren_count\
    \ + 1\n            elseif cur_char == ')' then\n                paren_count =\
    \ paren_count - 1\n            end\n            if paren_count < 0 then\n    \
    \            is_end = true\n                break\n            end\n        end\n\
    \        if not is_end then\n            table.insert(paren_counts, paren_count)\n\
    \        end\n    end\n    return paren_counts\nend", "  local max_nesting = 0\n\
    \  local nesting = 0\n  for i = 1, #paren_string do\n    local ch = paren_string:sub(i,\
    \ i)\n    if ch == '(' then\n      nesting = nesting + 1\n      if nesting > max_nesting\
    \ then\n        max_nesting = nesting\n      end\n    elseif ch == ')' then\n\
    \      nesting = nesting - 1\n    end\n  end\n  return max_nesting\nend", "  local\
    \ deepest_level = 0\n  local paren_level = 0\n  for i=1,#paren_string do\n   \
    \ if paren_string:sub(i,i) == '(' then\n      paren_level = paren_level + 1\n\
    \      if paren_level > deepest_level then\n        deepest_level = paren_level\n\
    \      end\n    elseif paren_string:sub(i,i) == ')' then\n      paren_level =\
    \ paren_level - 1\n    end\n  end\n  return deepest_level\nend", "  local groups\
    \ = split(paren_string, \" \")\n  local result = {}\n  for _, group in ipairs(groups)\
    \ do\n    local level = 0\n    local max = 0\n    for char in group:gmatch(\"\
    .\") do\n      if char == \"(\" then\n        level = level + 1\n      elseif\
    \ char == \")\" then\n        level = level - 1\n      end\n      max = math.max(max,\
    \ level)\n    end\n    result[#result + 1] = max\n  end\n  return result\nend",
  "  -- find all groups of parentheses\n  local paren_groups = {}\n  for paren_group\
    \ in paren_string:gmatch(\"%b()\") do\n    table.insert(paren_groups, paren_group)\n\
    \  end", "    local paren_levels = {}\n    for g = 1, #groups_to_process do\n\
    \        local max_level = 0\n        local current_level = 0\n        local group\
    \ = groups_to_process[g]\n        -- Remove outermost parentheses of each group\n\
    \        group = group:sub(2, group:len() - 1)\n        -- Find the deepest level\
    \ of nesting of parentheses\n        for p = 1, #group do\n            local paren\
    \ = group:sub(p, p)\n            if paren == \"(\" then\n                current_level\
    \ = current_level + 1\n            elseif paren == \")\" then\n              \
    \  current_level = current_level - 1\n            end\n            if current_level\
    \ > max_level then\n                max_level = current_level\n            end\n\
    \        end\n        paren_levels[g] = max_level\n    end\n    return paren_levels\n\
    end", "    local paren_cnt = 0\n    local paren_max = 0\n    for i=1,#paren_string\
    \ do\n        local char = paren_string:sub(i,i)\n        if char == '(' then\n\
    \            paren_cnt = paren_cnt + 1\n            if paren_cnt > paren_max then\n\
    \                paren_max = paren_cnt\n            end\n        elseif char ==\
    \ ')' then\n            paren_cnt = paren_cnt - 1\n        end\n    end\n    return\
    \ paren_max\nend", "  assert(type(paren_string) == 'string')\n  local paren_tokens\
    \ = stringx.split(paren_string)\n  local max_nesting = 0\n  for _, paren_token\
    \ in ipairs(paren_tokens) do\n    local current_nesting = get_paren_nesting(paren_token)\n\
    \    if current_nesting > max_nesting then\n      max_nesting = current_nesting\n\
    \    end\n  end\n  return max_nesting\nend", "  local function get_max_level(parentheses_str)\n\
    \    local max_level = 0\n    local current_level = 0\n    for i = 1, #parentheses_str\
    \ do\n      local ch = parentheses_str:sub(i, i)\n      if ch == '(' then\n  \
    \      current_level = current_level + 1\n        if current_level > max_level\
    \ then\n          max_level = current_level\n        end\n      elseif ch == ')'\
    \ then\n        current_level = current_level - 1\n      end\n    end\n    return\
    \ max_level\n  end", "    -- key: depth, value: [index]\n    local depth_counter\
    \ = {}\n    local depth = 0\n    for i = 1, string.len(paren_string) do\n    \
    \    if string.sub(paren_string, i, i) == \"(\" then\n            depth = depth\
    \ + 1\n            if depth_counter[depth] == nil then\n                depth_counter[depth]\
    \ = {}\n            end\n            table.insert(depth_counter[depth], i)\n \
    \       elseif string.sub(paren_string, i, i) == \")\" then\n            table.insert(depth_counter[depth],\
    \ i)\n            depth = depth - 1\n        end\n    end\n    local max_depth\
    \ = 0\n    for depth, depth_indexes in pairs(depth_counter) do\n        if #depth_indexes\
    \ > max_depth then\n            max_depth = #depth_indexes\n        end\n    end\n\
    \    return max_depth\nend", "    local num_parens = {}\n    local max_depth =\
    \ 0\n    local current_depth = 0\n    for i = 1, #paren_string do\n        local\
    \ this_char = paren_string:sub(i, i)\n        if this_char == '(' then\n     \
    \       current_depth = current_depth + 1\n            if current_depth > max_depth\
    \ then\n                max_depth = current_depth\n            end\n        elseif\
    \ this_char == ')' then\n            current_depth = current_depth - 1\n     \
    \   end\n        if this_char == ' ' then\n            num_parens[#num_parens\
    \ + 1] = max_depth\n            max_depth = 0\n            current_depth = 0\n\
    \        end\n    end\n    return num_parens\nend", "\tlocal paren_depth = {}\n\
    \tfor i = 1, #paren_string do\n\t\tlocal paren = paren_string:sub(i, i)\n\t\t\
    if paren == '(' then\n\t\t\ttable.insert(paren_depth, 1)\n\t\telseif paren ==\
    \ ')' then\n\t\t\ttable.insert(paren_depth, -1)\n\t\tend\n\tend\n\tlocal deepest_depth\
    \ = 0\n\tlocal running_depth = 0\n\tfor i = 1, #paren_depth do\n\t\tlocal value\
    \ = paren_depth[i]\n\t\trunning_depth = running_depth + value\n\t\tif running_depth\
    \ > deepest_depth then\n\t\t\tdeepest_depth = running_depth\n\t\tend\n\tend\n\t\
    return deepest_depth\nend", "  local levels = {}\n  local paren_groups = stringx.split(paren_string,\
    \ ' ')\n  for _, group in ipairs(paren_groups) do\n    local level = 0\n    local\
    \ max_level = 0\n    for char in stringx.chars(group) do\n      if char == '('\
    \ then\n        level = level + 1\n      elseif char == ')' then\n        level\
    \ = level - 1\n      end\n      max_level = math.max(max_level, level)\n    end\n\
    \    table.insert(levels, max_level)\n  end\n  return levels\nend", "  local levels\
    \ = {}\n  local level = 0\n  for i = 1, #paren_string do\n    local c = paren_string:sub(i,\
    \ i)\n    if c == '(' then\n      level = level + 1\n    elseif c == ')' then\n\
    \      levels[level] = levels[level] or 0\n      levels[level] = levels[level]\
    \ + 1\n      level = level - 1\n    end\n  end\n  local max_level = 0\n  for k,\
    \ v in pairs(levels) do\n    if v > max_level then\n      max_level = v\n    end\n\
    \  end\n  return max_level\nend", "    local group = {}\n    local group_idx =\
    \ 1\n    local start_idx = nil\n    local max_level = 0\n    local level = 0\n\
    \    for i = 1, #paren_string do\n        if paren_string:sub(i, i) == '(' then\n\
    \            if start_idx == nil then\n                start_idx = i\n       \
    \     end\n            level = level + 1\n            if level > max_level then\n\
    \                max_level = level\n            end\n        elseif paren_string:sub(i,\
    \ i) == ')' then\n            level = level - 1\n            if level == 0 then\n\
    \                group[group_idx] = {start_idx, i}\n                group_idx\
    \ = group_idx + 1\n                start_idx = nil\n            end\n        end\n\
    \    end\n    if max_level > 0 then\n        return group, max_level\n    else\n\
    \        return group, 0\n    end\nend", "  local nested_levels = {}\n  for word\
    \ in string.gmatch(paren_string, \"[^%s]+\") do\n    local level = 0\n    local\
    \ max_level = 0\n    for char in string.gmatch(word, \".\") do\n      if char\
    \ == \"(\" then\n        level = level + 1\n        if level > max_level then\n\
    \          max_level = level\n        end\n      elseif char == \")\" then\n \
    \       level = level - 1\n      end\n    end\n    table.insert(nested_levels,\
    \ max_level)\n  end\n  return nested_levels\nend", "    local paren_level_max\
    \ = 0\n    local paren_level = 0\n    local output = \"\"\n    for i = 1, string.len(paren_string)\
    \ do\n        if string.sub(paren_string, i, i) == \"(\" then\n            paren_level\
    \ = paren_level + 1\n            if paren_level > paren_level_max then\n     \
    \           paren_level_max = paren_level\n            end\n        elseif string.sub(paren_string,\
    \ i, i) == \")\" then\n            paren_level = paren_level - 1\n        elseif\
    \ string.sub(paren_string, i, i) == \" \" then\n            output = output ..\
    \ \" \" .. paren_level_max\n            paren_level_max = 0\n            paren_level\
    \ = 0\n        end\n    end\n    output = output .. \" \" .. paren_level_max\n\
    \    return output\nend", "\tlocal level_map = {}\n\tlocal level = 0\n\tlocal\
    \ function record_level(c)\n\t\tlevel = level + 1\n\t\tlevel_map[level] = level_map[level]\
    \ or 0\n\t\tlevel_map[level] = level_map[level] + 1\n\tend\n\tlocal function decrement_level(c)\n\
    \t\tlevel_map[level] = level_map[level] - 1\n\t\tif level_map[level] == 0 then\n\
    \t\t\tlevel_map[level] = nil\n\t\t\tlevel = level - 1\n\t\tend\n\tend\n\tfor i\
    \ = 1, #paren_string do\n\t\tlocal c = paren_string:sub(i, i)\n\t\tif c == '('\
    \ then\n\t\t\trecord_level(c)\n\t\telseif c == ')' then\n\t\t\tdecrement_level(c)\n\
    \t\tend\n\tend\n\treturn level_map\nend", "  local function parse_nested_parens_aux(paren_string,\
    \ paren_level)\n    if #paren_string == 0 then\n      return paren_level\n   \
    \ elseif paren_string:sub(1, 1) == '(' then\n      return parse_nested_parens_aux(paren_string:sub(2),\
    \ paren_level + 1)\n    elseif paren_string:sub(1, 1) == ')' then\n      return\
    \ parse_nested_parens_aux(paren_string:sub(2), paren_level - 1)\n    elseif paren_string:sub(1,\
    \ 1) == ' ' then\n      return parse_nested_parens_aux(paren_string:sub(2), paren_level)\n\
    \    else\n      return nil\n    end\n  end\n  if #paren_string == 0 then\n  \
    \  return '0'\n  else\n    local paren_level = 0\n    local result = ''\n    for\
    \ i = 1, #paren_string do\n      local paren_level = parse_nested_parens_aux(paren_string:sub(i),\
    \ paren_level)\n      if paren_level == nil then\n        return paren_level\n\
    \      elseif paren_level == 0 then\n        result = result .. paren_level ..\
    \ ' '\n      end\n    end\n    return result\n  end\nend", "  local paren_depth\
    \ = {}\n  local paren_count = 0\n  local max_depth = 0\n  for c in paren_string:gmatch(\"\
    .\") do\n    if c == \"(\" then\n      paren_count = paren_count + 1\n      max_depth\
    \ = math.max(max_depth, paren_count)\n    elseif c == \")\" then\n      paren_count\
    \ = paren_count - 1\n    end\n  end\n  for i = 1, max_depth do\n    paren_depth[i]\
    \ = 0\n  end\n  paren_count = 0\n  for c in paren_string:gmatch(\".\") do\n  \
    \  if c == \"(\" then\n      paren_count = paren_count + 1\n      paren_depth[paren_count]\
    \ = paren_depth[paren_count] + 1\n    elseif c == \")\" then\n      paren_depth[paren_count]\
    \ = paren_depth[paren_count] - 1\n      paren_count = paren_count - 1\n    end\n\
    \  end\n  local res = {}\n  for i = 1, max_depth do\n    res[i] = paren_depth[i]\n\
    \  end\n  return res\nend", "    local paren_levels = {}\n    local paren_level\
    \ = 0\n    local paren_string_len = string.len(paren_string)\n    local current_char\n\
    \    for i = 1, paren_string_len do\n        current_char = string.sub(paren_string,\
    \ i, i)\n        if current_char == \"(\" then\n            paren_level = paren_level\
    \ + 1\n        elseif current_char == \")\" then\n            table.insert(paren_levels,\
    \ paren_level)\n            paren_level = paren_level - 1\n        end\n    end\n\
    \    return paren_levels\nend", "  local output = {}\n  for group in paren_string:gmatch(\"\
    [%(%) ]+\") do\n    if group:len() > 0 then\n      local level = 1\n      local\
    \ max_level = 1\n      for _, char in ipairs(group:gmatch(\".\")) do\n       \
    \ if char == \"(\" then\n          level = level + 1\n          if level > max_level\
    \ then\n            max_level = level\n          end\n        elseif char == \"\
    )\" then\n          level = level - 1\n        end\n      end\n      output[#output\
    \ + 1] = max_level\n    end\n  end\n  return output\nend", "    local depth_stack\
    \ = {0}\n    local depth_record = {}\n    for i=1, #paren_string do\n        local\
    \ c = paren_string:sub(i,i)\n        if c == '(' then\n            depth_stack[#depth_stack+1]\
    \ = depth_stack[#depth_stack] + 1\n        elseif c == ')' then\n            local\
    \ d = depth_stack[#depth_stack]\n            table.remove(depth_stack)\n     \
    \       depth_record[d] = true\n        end\n    end\n    return depth_record\n\
    end", "    local num_parens = 0\n    local max_num_parens = 0\n    for i = 1,\
    \ #paren_string do\n        local c = paren_string:sub(i, i)\n        if c ==\
    \ '(' then\n            num_parens = num_parens + 1\n        elseif c == ')' then\n\
    \            num_parens = num_parens - 1\n        end\n        max_num_parens\
    \ = math.max(max_num_parens, num_parens)\n    end\n    return max_num_parens\n\
    end", "\tlocal groups = split(paren_string, '%s+')\n\tlocal depths = {}\n\tfor\
    \ _, group in ipairs(groups) do\n\t\tif group ~= '' then\n\t\t\tlocal depth =\
    \ 0\n\t\t\tlocal max_depth = 0\n\t\t\tfor c in group:gmatch('[%(%)]') do\n\t\t\
    \t\tif c == '(' then\n\t\t\t\t\tdepth = depth + 1\n\t\t\t\telse\n\t\t\t\t\tdepth\
    \ = depth - 1\n\t\t\t\tend\n\t\t\t\tif depth > max_depth then\n\t\t\t\t\tmax_depth\
    \ = depth\n\t\t\t\tend\n\t\t\tend\n\t\t\tdepths[#depths + 1] = max_depth\n\t\t\
    end\n\tend\n\treturn depths\nend", "    local level = 0\n    local max_level =\
    \ 0\n    for i = 1, #paren_string do\n        if paren_string:sub(i, i) == '('\
    \ then\n            level = level + 1\n            if level > max_level then\n\
    \                max_level = level\n            end\n        elseif paren_string:sub(i,\
    \ i) == ')' then\n            level = level - 1\n        end\n    end\n    if\
    \ level ~= 0 then\n        error('Unbalanced parenthesis: ' .. paren_string)\n\
    \    end\n    return max_level\nend", "    local max_depth = 0\n    local depth\
    \ = 0\n    local depth_table = {}\n    for c in paren_string:gmatch'.' do\n  \
    \      if c == '(' then\n            depth = depth + 1\n            if depth >\
    \ max_depth then\n                max_depth = depth\n            end\n       \
    \ elseif c == ')' then\n            depth = depth - 1\n        end\n    end\n\
    \    return max_depth\nend", "  local max_level = 0\n  local current_level = 0\n\
    \  local paren_type = \"\"\n  local table_out = {}\n  for idx = 1, string.len(paren_string)\
    \ do\n    local current_char = string.sub(paren_string, idx, idx)\n    if current_char\
    \ == \"(\" then\n      paren_type = current_char\n      current_level = current_level\
    \ + 1\n      if current_level > max_level then\n        max_level = current_level\n\
    \      end\n    elseif current_char == \")\" then\n      paren_type = current_char\n\
    \      current_level = current_level - 1\n    elseif current_char == \" \" then\n\
    \      table.insert(table_out, max_level)\n      max_level = 0\n      current_level\
    \ = 0\n    end\n  end\n  if paren_type == \")\" then\n    current_level = current_level\
    \ + 1\n  end\n  table.insert(table_out, max_level + current_level)\n  return table_out\n\
    end", "    local levels = {}\n    local max_level = 0\n    local depth = 0\n \
    \   for c in paren_string:gmatch(\".\") do\n        if c == \"(\" then\n     \
    \       depth = depth + 1\n            if depth > max_level then\n           \
    \     max_level = depth\n            end\n        elseif c == \")\" then\n   \
    \         depth = depth - 1\n        end\n    end\n    return max_level\nend",
  "\tlocal count = 0\n\tlocal paren_table = {}\n\tlocal levels = {}\n\tlocal level\
    \ = 0\n\tfor i = 1, #paren_string do\n\t\tlocal char = paren_string:sub(i, i)\n\
    \t\tif char == \"(\" then\n\t\t\ttable.insert(paren_table, char)\n\t\t\tlevel\
    \ = level + 1\n\t\t\ttable.insert(levels, level)\n\t\telseif char == \")\" then\n\
    \t\t\ttable.insert(paren_table, char)\n\t\t\tlevel = level - 1\n\t\t\ttable.insert(levels,\
    \ level)\n\t\tend\n\tend\n\treturn levels\nend", "  local paren_groups = {}\n\
    \  for paren_group in paren_string:gmatch(\"%b()\") do\n    local paren_depth\
    \ = 1\n    local paren_max = 1\n    for i = 2, #paren_group do\n      local char\
    \ = paren_group:sub(i, i)\n      if char == \"(\" then\n        paren_depth =\
    \ paren_depth + 1\n        if paren_depth > paren_max then\n          paren_max\
    \ = paren_depth\n        end\n      elseif char == \")\" then\n        paren_depth\
    \ = paren_depth - 1\n      end\n    end\n    table.insert(paren_groups, paren_max)\n\
    \  end\n  return paren_groups\nend", "    local start_pos = 1\n    local end_pos\
    \ = paren_string:find(\" \")\n    local paren_tbl = {}\n    local group = 1\n\
    \    local depth = 0\n    local max_depth = 0\n    while end_pos do\n        paren_tbl[group]\
    \ = paren_string:sub(start_pos, end_pos - 1)\n        start_pos = end_pos + 1\n\
    \        end_pos = paren_string:find(\" \", start_pos)\n        group = group\
    \ + 1\n    end\n    paren_tbl[group] = paren_string:sub(start_pos)\n    for _,\
    \ paren_group in ipairs(paren_tbl) do\n        for paren in paren_group:gmatch(\"\
    %(\") do\n            depth = depth + 1\n            if depth > max_depth then\n\
    \                max_depth = depth\n            end\n        end\n        for\
    \ paren in paren_group:gmatch(\"%)\") do\n            depth = depth - 1\n    \
    \    end\n    end\n    return max_depth\nend", "  local output = {}\n  local max_depth\
    \ = 0\n  local current_depth = 0\n  for current_char in paren_string:gmatch(\"\
    .\") do\n    if current_char == \"(\" then\n      current_depth = current_depth\
    \ + 1\n      if current_depth > max_depth then\n        max_depth = current_depth\n\
    \      end\n    elseif current_char == \")\" then\n      if current_depth > 0\
    \ then\n        current_depth = current_depth - 1\n      end\n    end\n  end\n\
    \  return max_depth\nend", "\tlocal paren_levels = {}", "  local output = {}\n\
    \  local groups = stringx.split(paren_string, \" \")\n  for _, group in ipairs(groups)\
    \ do\n    table.insert(output, stringx.count(group, \"(\"))\n  end\n  return output\n\
    end", "  local groups = stringx.split(paren_string, ' ')\n  local max_levels =\
    \ {}\n  for i = 1, #groups do\n    local parens = stringx.split(groups[i], '')\n\
    \    local level = 0\n    local max_level = 0\n    for j = 1, #parens do\n   \
    \   if parens[j] == '(' then\n        level = level + 1\n      elseif parens[j]\
    \ == ')' then\n        level = level - 1\n      end\n      max_level = math.max(max_level,\
    \ level)\n    end\n    max_levels[i] = max_level\n  end\n  return max_levels\n\
    end", "  local paren_groups = {}\n  for paren_group in paren_string:gmatch(\"\
    %(([^%(]*)%)\") do\n    local level = 0\n    local max_level = 0\n    for c in\
    \ paren_group:gmatch(\".\") do\n      if c == \"(\" then\n        level = level\
    \ + 1\n      elseif c == \")\" then\n        level = level - 1\n      end\n  \
    \    max_level = math.max(max_level, level)\n    end\n    table.insert(paren_groups,\
    \ max_level)\n  end\n  return paren_groups\nend", "    local max = 0\n    for\
    \ paren_group in paren_string:gmatch(\"%b()\") do\n        local level = 0\n \
    \       local paren_group_length = #paren_group\n        for i = 1, paren_group_length\
    \ do\n            local c = paren_group:sub(i, i)\n            if c == \"(\" then\n\
    \                level = level + 1\n            elseif c == \")\" then\n     \
    \           level = level - 1\n            end\n        end\n        if level\
    \ > max then\n            max = level\n        end\n    end\n    return max\n\
    end", "\tlocal max_depth = 0\n\tlocal current_depth = 0\n\tfor paren in paren_string:gmatch(\"\
    (.)\") do\n\t\tif paren == \"(\" then\n\t\t\tcurrent_depth = current_depth + 1\n\
    \t\t\tif current_depth > max_depth then\n\t\t\t\tmax_depth = current_depth\n\t\
    \t\tend\n\t\telseif paren == \")\" then\n\t\t\tcurrent_depth = current_depth -\
    \ 1\n\t\tend\n\tend\n\treturn max_depth\nend", "  local temp = paren_string:gsub('%s','')\n\
    \  local depth = 0\n  local max = 0\n  local parens = {}\n  for i = 1, #temp do\n\
    \    local p = temp:sub(i,i)\n    if p == '(' then\n      table.insert(parens,\
    \ p)\n      depth = depth + 1\n      if depth > max then\n        max = depth\n\
    \      end\n    elseif p == ')' then\n      table.remove(parens)\n      depth\
    \ = depth - 1\n    end\n  end\n  return max\nend", "\tlocal max_depth = 0\n\t\
    local paren_depth = 0\n\tlocal paren_depth_table = {}\n\tfor group in string.gmatch(paren_string,\
    \ \"%S+\") do\n\t\tparen_depth = 0\n\t\tfor char in string.gmatch(group, \".\"\
    ) do\n\t\t\tif char == \"(\" then\n\t\t\t\tparen_depth = paren_depth + 1\n\t\t\
    \t\tif paren_depth > max_depth then\n\t\t\t\t\tmax_depth = paren_depth\n\t\t\t\
    \tend\n\t\t\telseif char == \")\" then\n\t\t\t\tparen_depth = paren_depth - 1\n\
    \t\t\tend\n\t\tend\n\t\ttable.insert(paren_depth_table, paren_depth)\n\tend\n\t\
    return max_depth, paren_depth_table\nend", "    local count = 0\n    local max\
    \ = 0\n    for p in paren_string:gmatch'()' do\n        local c = paren_string:sub(p,\
    \ p)\n        if c == '(' then\n            count = count + 1\n            max\
    \ = math.max(max, count)\n        elseif c == ')' then\n            count = count\
    \ - 1\n        end\n    end\n    return max\nend", "  local num_parens = {}\n\
    \  for paren_str in paren_string:gmatch(\"%S+\") do\n    local depth = 0\n   \
    \ local max_depth = 0\n    for paren in paren_str:gmatch(\"%(|%)\") do\n     \
    \ if paren == \"(\" then\n        depth = depth + 1\n      else\n        depth\
    \ = depth - 1\n      end\n      max_depth = math.max(max_depth, depth)\n    end\n\
    \    if depth ~= 0 then\n      return nil\n    end\n    table.insert(num_parens,\
    \ max_depth)\n  end\n  return num_parens\nend", "    local level = 0\n    local\
    \ max_level = 0\n    for char in paren_string:gmatch('.') do\n        if char\
    \ == '(' then\n            level = level + 1\n            if level > max_level\
    \ then\n                max_level = level\n            end\n        elseif char\
    \ == ')' then\n            level = level - 1\n        end\n    end\n    return\
    \ max_level\nend", "    local paren_level = 0\n    local max_level = 0\n    for\
    \ i=1, #paren_string do\n        if paren_string:sub(i,i) == '(' then\n      \
    \      paren_level = paren_level + 1\n            if paren_level > max_level then\n\
    \                max_level = paren_level\n            end\n        elseif paren_string:sub(i,i)\
    \ == ')' then\n            paren_level = paren_level - 1\n        end\n    end\n\
    \    return max_level\nend", "\tlocal paren_level = 0\n\tlocal max_paren_level\
    \ = 0\n\tlocal max_paren_groups = {}\n\tfor index = 1, #paren_string do\n\t\t\
    local char = paren_string:sub(index, index)\n\t\tif char == \"(\" then\n\t\t\t\
    paren_level = paren_level + 1\n\t\t\tif paren_level > max_paren_level then\n\t\
    \t\t\tmax_paren_level = paren_level\n\t\t\tend\n\t\telseif char == \")\" then\n\
    \t\t\tif paren_level == max_paren_level then\n\t\t\t\ttable.insert(max_paren_groups,\
    \ {index, paren_level})\n\t\t\tend\n\t\t\tparen_level = paren_level - 1\n\t\t\
    end\n\tend\n\treturn max_paren_groups\nend", "\tlocal max_depth = 0\n\tlocal paren_char\
    \ = '('\n\tlocal count = 0\n\tfor i = 1, #paren_string do\n\t\tlocal s = paren_string:sub(i,\
    \ i)\n\t\tif s == paren_char then\n\t\t\tcount = count + 1\n\t\t\tif count > max_depth\
    \ then\n\t\t\t\tmax_depth = count\n\t\t\tend\n\t\telseif s == ')' then\n\t\t\t\
    count = count - 1\n\t\tend\n\tend\n\treturn max_depth\nend", "    local groups\
    \ = stringx.split(paren_string, ' ')\n    local max_levels = {}\n    for i, group\
    \ in ipairs(groups) do\n        local level = 0\n        local max_level = 0\n\
    \        for j = 1, #group do\n            if group:sub(j, j) == '(' then\n  \
    \              level = level + 1\n            elseif group:sub(j, j) == ')' then\n\
    \                level = level - 1\n            end\n            max_level = math.max(max_level,\
    \ level)\n        end\n        table.insert(max_levels, max_level)\n    end\n\
    \    return max_levels\nend", "    local level_table = {}\n    local current_level\
    \ = 0\n    local opening_paren_index = 0\n    local closing_paren_index = 0\n\
    \    local paren_length = string.len(paren_string)\n    local char_index\n   \
    \ for char_index = 1, paren_length do\n        local current_char = string.sub(paren_string,\
    \ char_index, char_index)\n        if current_char == \"(\" then\n           \
    \ opening_paren_index = char_index\n            current_level = current_level\
    \ + 1\n        elseif current_char == \")\" then\n            closing_paren_index\
    \ = char_index\n            level_table[opening_paren_index] = current_level\n\
    \            level_table[closing_paren_index] = current_level\n            current_level\
    \ = current_level - 1\n        end\n    end\n    return level_table\nend", "\t\
    local res = {}\n\tlocal tokens = tokenize(paren_string)\n\tlocal curr_level =\
    \ 0\n\tlocal curr_max = 0\n\tfor i = 1, #tokens do\n\t\tlocal t = tokens[i]\n\t\
    \tlocal token_value = t[2]\n\t\tif t[1] == '(' then\n\t\t\tcurr_level = curr_level\
    \ + 1\n\t\t\tif curr_level > curr_max then\n\t\t\t\tcurr_max = curr_level\n\t\t\
    \tend\n\t\telseif t[1] == ')' then\n\t\t\tcurr_level = curr_level - 1\n\t\tend\n\
    \tend\n\treturn curr_max\nend", "\tlocal depth = 0\n\tlocal max = 0\n\tfor c in\
    \ paren_string:gmatch('.') do\n\t\tif c == '(' then\n\t\t\tdepth = depth + 1\n\
    \t\t\tif depth > max then\n\t\t\t\tmax = depth\n\t\t\tend\n\t\telseif c == ')'\
    \ then\n\t\t\tdepth = depth - 1\n\t\tend\n\tend\n\treturn max\nend", "    local\
    \ groups = paren_string:split(' ')\n    local deepest_level = 0\n    for _, paren_group\
    \ in ipairs(groups) do\n        local level = 0\n        for _, char in ipairs(paren_group:split(''))\
    \ do\n            if char == '(' then\n                level = level + 1\n   \
    \         elseif char == ')' then\n                level = level - 1\n       \
    \     end\n        end\n        if level > deepest_level then\n            deepest_level\
    \ = level\n        end\n    end\n    return deepest_level\nend", "    local paren_list\
    \ = stringx.split(paren_string, ' ')\n    local max_depth = 0\n    for i = 1,\
    \ #paren_list do\n        local stack_top = 0\n        for j = 1, #paren_list[i]\
    \ do\n            if paren_list[i]:sub(j, j) == '(' then\n                stack_top\
    \ = stack_top + 1\n            elseif paren_list[i]:sub(j, j) == ')' then\n  \
    \              stack_top = stack_top - 1\n            end\n            if stack_top\
    \ > max_depth then\n                max_depth = stack_top\n            end\n \
    \       end\n    end\n    return max_depth\nend", "\tlocal level = 1\n\tlocal\
    \ max_level = 1\n\tlocal len = string.len(paren_string)\n\tlocal acc = \"\"\n\t\
    \n\tfor i = 1, len do\n\t\tlocal char = string.sub(paren_string, i, i)\n\t\t\n\
    \t\tif char == \"(\" then\n\t\t\tlevel = level + 1\n\t\t\tif level > max_level\
    \ then\n\t\t\t\tmax_level = level\n\t\t\tend\n\t\telseif char == \")\" then\n\t\
    \t\tlevel = level - 1\n\t\tend\n\tend\n\t\n\treturn max_level\nend", "    -- Split\
    \ the string on spaces to separate the groups.\n    local groups = stringx.split(paren_string,\
    \ ' ')\n    local max_depth = 0\n    local output = ''\n    for _, group in ipairs(groups)\
    \ do\n        -- Each of the parentheses is either an opening one '(', a closing\
    \ one ')' or a non-parentheses character.\n        -- If we count the number of\
    \ opening parentheses minus the number of closing parentheses,\n        -- the\
    \ minimum of this value is the number of levels of nesting.\n        local count\
    \ = 0\n        for c in stringx.chars(group) do\n            if c == '(' then\n\
    \                count = count + 1\n            elseif c == ')' then\n       \
    \         count = count - 1\n            end\n        end\n        if max_depth\
    \ < count then\n            max_depth = count\n        end\n        output = output\
    \ .. count .. ' '\n    end\n    -- Remove the trailing space.\n    return output:sub(1,\
    \ -2)\nend", "    local max_depth = 0\n    local curr_depth = 0\n    local first_paren\
    \ = true\n    for c in paren_string:gmatch('.') do\n        if first_paren then\n\
    \            if c == ' ' then\n                first_paren = false\n         \
    \   elseif c == '(' then\n                curr_depth = 1\n                first_paren\
    \ = false\n            else\n                error('string must begin with \"\
    (\"')\n            end\n        else\n            if c == '(' then\n         \
    \       curr_depth = curr_depth + 1\n            elseif c == ')' then\n      \
    \          curr_depth = curr_depth - 1\n            elseif c == ' ' then\n   \
    \             if curr_depth > max_depth then\n                    max_depth =\
    \ curr_depth\n                end\n                curr_depth = 0\n          \
    \  else\n                error('string must consist of only parenthesis, commas,\
    \ and whitespace')\n            end\n        end\n    end\n    if curr_depth >\
    \ max_depth then\n        max_depth = curr_depth\n    end\n    return max_depth\n\
    end", "  local num_parens = 0\n  local max_parens = 0\n  for i = 1, #paren_string\
    \ do\n    local cur_char = paren_string:sub(i, i)\n    if cur_char == '(' then\n\
    \      num_parens = num_parens + 1\n      if num_parens > max_parens then\n  \
    \      max_parens = num_parens\n      end\n    elseif cur_char == ')' then\n \
    \     num_parens = num_parens - 1\n    end\n  end\n  return max_parens\nend",
  "  local levels = {}\n  for sub_paren in paren_string:gmatch(\"%b()\") do\n    table.insert(levels,\
    \ get_nested_parens_level(sub_paren))\n  end\n  return table.concat(levels, \"\
    \ \")\nend", "  local levels = {}\n  for paren_group in paren_string:gmatch(\"\
    %b()\") do\n    local stack = {}\n    for paren in paren_group:gmatch(\".\") do\n\
    \      if paren == \"(\" then\n        table.insert(stack, paren)\n      elseif\
    \ paren == \")\" then\n        if #stack > 0 then\n          table.remove(stack)\n\
    \        else\n          -- If we encounter a closing paren with no matching opening\
    \ paren, it means we have a nested parens\n          -- in the wrong order, i.e.\
    \ like )( or ()).\n          -- In such cases, we treat this paren as its own\
    \ group.\n          table.insert(levels, 0)\n          break\n        end\n  \
    \    end\n    end\n    table.insert(levels, #stack)\n  end\n  return levels\n\
    end", "    local levels = {}\n    local level = 0\n    for c in paren_string:gmatch(\"\
    .\") do\n        if c == \"(\" then\n            level = level + 1\n        elseif\
    \ c == \")\" then\n            level = level - 1\n        end\n        levels[#levels\
    \ + 1] = level\n    end\n    return table.concat(levels, \" \")\nend", "\t-- local\
    \ str_split = split(paren_string, \" \")\n\tlocal str_split = stringx.split(paren_string,\
    \ \" \")\n\tlocal answer = {}\n\tfor i = 1, #str_split do\n\t\tlocal input = str_split[i]\n\
    \t\tlocal paren_count = 0\n\t\tlocal max_count = 0\n\t\tfor j = 1, #input do\n\
    \t\t\tlocal cur_char = input:sub(j, j)\n\t\t\tif cur_char == \"(\" then\n\t\t\t\
    \tparen_count = paren_count + 1\n\t\t\telseif cur_char == \")\" then\n\t\t\t\t\
    paren_count = paren_count - 1\n\t\t\tend\n\t\t\tif paren_count > max_count then\n\
    \t\t\t\tmax_count = paren_count\n\t\t\tend\n\t\tend\n\t\ttable.insert(answer,\
    \ max_count)\n\tend\n\treturn answer\nend", "  local max_parens = 0\n  local paren_count\
    \ = 0\n  for i = 1, #paren_string do\n    local char = paren_string:sub(i, i)\n\
    \    if char == '(' then\n      paren_count = paren_count + 1\n      if paren_count\
    \ > max_parens then\n        max_parens = paren_count\n      end\n    elseif char\
    \ == ')' then\n      paren_count = paren_count - 1\n    end\n  end\n  return max_parens\n\
    end", "    -- Find all unique opening and closing parentheses.\n    local open,\
    \ close = {}, {}\n    for char in paren_string:gmatch('%S') do\n        if char\
    \ == '(' then\n            table.insert(open, char)\n        elseif char == ')'\
    \ then\n            table.insert(close, char)\n        end\n    end", "  -- TODO:\
    \ Do a sanity check on the input\n  -- The idea is to maintain a stack of opening\
    \ parentheses while looking at the input\n  -- and updating the stack by popping\
    \ whenever a closing parenthesis is encountered.\n  -- We use a stack as the open\
    \ parentheses could either be in the same line or in a different line.\n  -- It\
    \ is easier to keep track of this information using a stack.\n  local stack =\
    \ {};\n  local nest_count = 0;\n  local stack_top = 1;\n  for i = 1, string.len(paren_string)\
    \ do\n    local char = string.sub(paren_string, i, i);\n    if char == \"(\" then\n\
    \      stack[stack_top] = char;\n      stack_top = stack_top + 1;\n    elseif\
    \ char == \")\" then\n      stack_top = stack_top - 1;\n      -- stack is empty\
    \ and we still encounter a closing paren, some error!\n      assert(stack_top\
    \ >= 1, \"Invalid input!\");\n    end\n    nest_count = math.max(nest_count, stack_top\
    \ - 1);\n  end\n  return nest_count;\nend", "  local depths = {}\n  -- Break the\
    \ string into groups of parentheses delimited by spaces.\n  local groups = stringx.split(paren_string,\
    \ ' ')\n  for _,group in ipairs(groups) do\n    local depth = 0\n    local max_depth\
    \ = 0\n    for c in group:gmatch('.') do\n      if c == '(' then\n        depth\
    \ = depth + 1\n        max_depth = math.max(max_depth, depth)\n      elseif c\
    \ == ')' then\n        depth = depth - 1\n      end\n    end\n    table.insert(depths,\
    \ max_depth)\n  end\n  return depths\nend", "    local groups = {}\n    for _,\
    \ group in ipairs(paren_string:split(\"%s+\")) do\n        local level = 0\n \
    \       local max_level = 0\n        for paren in group:gmatch(\"[()]\") do\n\
    \            if paren == \"(\" then\n                level = level + 1\n     \
    \       else\n                level = level - 1\n            end\n           \
    \ max_level = math.max(max_level, level)\n        end\n        table.insert(groups,\
    \ max_level)\n    end\n    return groups\nend", "    local depth_table = {}\n\
    \    local depth = 0\n    local count = 0\n    for _, c in utf8.codes(paren_string)\
    \ do\n        if c == 40 then\n            depth = depth + 1\n        elseif c\
    \ == 41 then\n            depth = depth - 1\n        end\n        if depth > count\
    \ then\n            count = depth\n        end\n        table.insert(depth_table,\
    \ tostring(count))\n    end\n    return table.concat(depth_table, \" \")\nend",
  "\tlocal paren_groups = stringx.split(paren_string)\n\tlocal paren_depth = torch.zeros(#paren_groups)\n\
    \tfor i = 1, #paren_groups do\n\t\tparen_depth[i] = calc_nested_parens(paren_groups[i])\n\
    \tend\n\treturn paren_depth\nend", "  local _, groups = string.gsub(paren_string,\
    \ \"%(\", \"\")\n  local group_splits = utils.split(paren_string, \" \")\n  local\
    \ depths = {}\n  for i, v in ipairs(group_splits) do\n    local depth = 0\n  \
    \  local str_len = string.len(v)\n    local curr_paren = \"\"\n    for j = 1,\
    \ str_len do\n      curr_paren = string.sub(v, j, j)\n      if curr_paren == \"\
    (\" then\n        depth = depth + 1\n      elseif curr_paren == \")\" then\n \
    \       depth = depth - 1\n      end\n    end\n    depths[i] = depth\n  end\n\
    \  return depths\nend", "\tassert(type(paren_string) == \"string\")\n\t\n\tlocal\
    \ parenthesis_array = {}\n\tfor _, substring in ipairs(str_split(paren_string,\
    \ \" +\")) do\n\t\tlocal stack = Stack:new()\n\t\tlocal depth = 0\n\t\tfor c in\
    \ substring:gmatch(\".\") do\n\t\t\tif c == \"(\" then\n\t\t\t\tstack:push(\"\
    (\")\n\t\t\t\tdepth = math.max(depth, stack:size())\n\t\t\telseif c == \")\" then\n\
    \t\t\t\tstack:pop()\n\t\t\tend\n\t\tend\n\t\t\n\t\tparenthesis_array[#parenthesis_array\
    \ + 1] = depth\n\tend\n\t\n\treturn parenthesis_array\nend", "\t-- We will first\
    \ split the string into tokens\n\tlocal tokens = {}\n\tfor m in paren_string:gmatch(\"\
    ([()]+)\") do\n\t\ttokens[#tokens + 1] = m\n\tend\n\tlocal depth = 0\n\tlocal\
    \ nesting_depth = {}\n\tlocal cur_idx = 1\n\tlocal paren_map = {\n\t\t[\"(\"]\
    \ = \")\",\n\t\t[\")\"] = \"(\"\n\t}\n\tfor _, token in ipairs(tokens) do\n\t\t\
    if token:len() > 1 then\n\t\t\t-- Multiple opening or closing parens, should be\
    \ the same character\n\t\t\tlocal first_char = token:sub(1, 1)\n\t\t\tlocal rest_char\
    \ = token:sub(2, -1)\n\t\t\tif first_char ~= rest_char then\n\t\t\t\terror(\"\
    Nested parentheses string is malformed, improper multiple parens: \" .. paren_string)\n\
    \t\t\tend\n\t\t\tif first_char == \"(\" then\n\t\t\t\tdepth = depth + token:len()\n\
    \t\t\t\tnesting_depth[cur_idx] = depth\n\t\t\telse\n\t\t\t\tdepth = depth - token:len()\n\
    \t\t\t\tnesting_depth[cur_idx] = depth\n\t\t\tend\n\t\telse\n\t\t\tlocal paren_char\
    \ = token:sub(1, 1)\n\t\t\tlocal opposite_paren_char = paren_map[paren_char]\n\
    \t\t\tif paren_char == \"(\" then\n\t\t\t\tdepth = depth + 1\n\t\t\t\tnesting_depth[cur_idx]\
    \ = depth\n\t\t\telse\n\t\t\t\tdepth = depth - 1\n\t\t\t\tnesting_depth[cur_idx]\
    \ = depth\n\t\t\tend\n\t\tend\n\t\tcur_idx = cur_idx + 1\n\tend\n\treturn table.unpack(nesting_depth)\n\
    end", "  local paren_array = split(paren_string, \" \")\n  local max_count = 0\n\
    \  for _, v in ipairs(paren_array) do\n    max_count = math.max(max_count, char_count(v,\
    \ '('))\n  end\n  return max_count\nend", "    local paren_tokens = stringx.split(paren_string)\n\
    \    local max_level = 0\n    for _, token in ipairs(paren_tokens) do\n      \
    \  local level = 0\n        for i = 1, #token do\n            if token:sub(i,\
    \ i) == '(' then\n                level = level + 1\n            elseif token:sub(i,\
    \ i) == ')' then\n                level = level - 1\n            end\n       \
    \ end\n        max_level = math.max(max_level, level)\n    end\n    return max_level\n\
    end", "  local deepest_depth = 0\n  local current_depth = 0\n  for index = 1,\
    \ #paren_string do\n    local current_char = paren_string:sub(index, index)\n\
    \    if current_char == \"(\" then\n      current_depth = current_depth + 1\n\
    \      if current_depth > deepest_depth then\n        deepest_depth = current_depth\n\
    \      end\n    elseif current_char == \")\" then\n      current_depth = current_depth\
    \ - 1\n    end\n  end\n  return deepest_depth\nend", "\tlocal group_start = 1\n\
    \tlocal group_count = 0\n\tlocal max_level = 0\n\tlocal cur_level = 0\n\tlocal\
    \ paren_string_length = string.len(paren_string)\n\tfor i = 1, paren_string_length\
    \ do\n\t\tlocal char = string.sub(paren_string, i, i)\n\t\tif (char == \"(\")\
    \ then\n\t\t\tcur_level = cur_level + 1\n\t\t\tif (cur_level > max_level) then\n\
    \t\t\t\tmax_level = cur_level\n\t\t\tend\n\t\telseif (char == \")\") then\n\t\t\
    \tcur_level = cur_level - 1\n\t\telseif (char == \" \") then\n\t\t\tgroup_count\
    \ = group_count + 1\n\t\t\tgroup_start = i + 1\n\t\tend\n\tend\n\treturn group_count\
    \ + 1, max_level\nend", "    local depths = {}\n    local level = 0\n    for m\
    \ in paren_string:gmatch(\"([^ ]+)\") do\n        local paren_level = 0\n    \
    \    for c in m:gmatch(\".\") do\n            if c == \"(\" then\n           \
    \     paren_level = paren_level + 1\n            elseif c == \")\" then\n    \
    \            paren_level = paren_level - 1\n            end\n        end\n   \
    \     if paren_level ~= 0 then\n            return nil\n        end\n        local\
    \ max_level = 0\n        for c in m:gmatch(\".\") do\n            if c == \"(\"\
    \ then\n                level = level + 1\n                if level > max_level\
    \ then\n                    max_level = level\n                end\n         \
    \   elseif c == \")\" then\n                level = level - 1\n            end\n\
    \        end\n        table.insert(depths, max_level)\n    end\n    return depths\n\
    end", "    local levels = {}\n    for level in paren_string:gmatch(\"[%(%)]+\"\
    ) do\n        local count = 0\n        local max = 0\n        for paren in level:gmatch(\"\
    .\") do\n            if paren == \"(\" then\n                count = count + 1\n\
    \            else\n                count = count - 1\n            end\n      \
    \      if count > max then\n                max = count\n            end\n   \
    \     end\n        table.insert(levels, max)\n    end\n    return levels\nend",
  "    local depths = {}\n    for match in paren_string:gmatch(\"%b()\") do\n    \
    \    depths[#depths + 1] = get_parentheses_depth(match)\n    end\n    return depths\n\
    end", "    local paren_groups = util.string_split(paren_string, \" \")\n    local\
    \ result = {}\n    for _, paren_group in ipairs(paren_groups) do\n        local\
    \ max_level = 0\n        local level = 0\n        for i = 1, #paren_group do\n\
    \            local char = paren_group:sub(i, i)\n            if char == \"(\"\
    \ then\n                level = level + 1\n            elseif char == \")\" then\n\
    \                level = level - 1\n            end\n            max_level = math.max(max_level,\
    \ level)\n        end\n        result[#result + 1] = max_level\n    end\n    return\
    \ result\nend", "  local paren_counts = {}\n  local paren_level = 0\n  for token\
    \ in paren_string:gmatch(\"%S+\") do\n    for char in token:gmatch(\".\") do\n\
    \      if char == \"(\" then\n        paren_level = paren_level + 1\n      elseif\
    \ char == \")\" then\n        paren_level = paren_level - 1\n      end\n    end\n\
    \    paren_counts[#paren_counts + 1] = paren_level\n  end\n  return paren_counts\n\
    end", "    if (type(paren_string) ~= \"string\") then\n        return nil\n  \
    \  end", "    local paren_level = {}\n    local max_nest = 0\n    for level in\
    \ paren_string:gmatch(\"%b()\") do\n        if level:find(\"%b()\") then\n   \
    \         paren_level[#paren_level + 1] = #level - level:gsub(\"%b()\", \"\")\n\
    \        else\n            paren_level[#paren_level + 1] = 1\n        end\n  \
    \      if paren_level[#paren_level] > max_nest then\n            max_nest = paren_level[#paren_level]\n\
    \        end\n    end\n    return max_nest\nend", "  local max_depth = 0\n  local\
    \ current_depth = 0\n  local len = paren_string:len()\n  for i = 1, len do\n \
    \   local char = paren_string:sub(i, i)\n    if char == '(' then\n      current_depth\
    \ = current_depth + 1\n      if current_depth > max_depth then\n        max_depth\
    \ = current_depth\n      end\n    elseif char == ')' then\n      current_depth\
    \ = current_depth - 1\n    end\n  end\n  return max_depth\nend", "    local paren_groups\
    \ = {}\n    for paren_group in string.gmatch(paren_string, \"([^%s]+)\") do\n\
    \        table.insert(paren_groups, paren_group)\n    end\n    local outputs =\
    \ {}\n    for i = 1, #paren_groups do\n        local paren_group = paren_groups[i]\n\
    \        local depth = 0\n        local max_depth = 0\n        for i = 1, #paren_group\
    \ do\n            local char = paren_group:sub(i, i)\n            if char == \"\
    (\" then\n                depth = depth + 1\n            elseif char == \")\"\
    \ then\n                depth = depth - 1\n            end\n            if depth\
    \ > max_depth then\n                max_depth = depth\n            end\n     \
    \   end\n        table.insert(outputs, max_depth)\n    end\n    return outputs\n\
    end", "    local paren_depth = 0\n    local max_depth = 0\n    for i = 1, #paren_string\
    \ do\n        local c = paren_string:sub(i, i)\n        if c == '(' then\n   \
    \         paren_depth = paren_depth + 1\n            if paren_depth > max_depth\
    \ then\n                max_depth = paren_depth\n            end\n        elseif\
    \ c == ')' then\n            paren_depth = paren_depth - 1\n        end\n    end\n\
    \    return max_depth\nend", "    local i = 1\n    local count = 0\n    local\
    \ max_count = 0\n    local result = {}\n    for n, c in utf8.codes(paren_string)\
    \ do\n        -- The utf8 library returns numeric codes for each character. For\
    \ the open parenthesis,\n        -- the numeric code returned is 40, for the close\
    \ parenthesis, it is 41.\n        if c == 40 then\n            count = count +\
    \ 1\n            if count > max_count then\n                max_count = count\n\
    \            end\n        elseif c == 41 then\n            count = count - 1\n\
    \        end\n        i = i + 1\n    end\n    -- The result that we want to return\
    \ is a table consisting of the maximum number of nested parenthesis\n    -- followed\
    \ by all the numbers counting the levels of nesting of each group.\n    result[1]\
    \ = max_count\n    result[2] = count\n    return result\nend", "  local levels\
    \ = {}\n  local current_level = 0\n  for i = 1, #paren_string do\n    local c\
    \ = paren_string:sub(i, i)\n    if c == '(' then\n      current_level = current_level\
    \ + 1\n    elseif c == ')' then\n      current_level = current_level - 1\n   \
    \ end\n    table.insert(levels, current_level)\n  end\n  return levels\nend",
  "  local paren_indices = { }\n  local paren_levels = { }\n  local curr_level = 0\n\
    \  for c in paren_string:gmatch(\".\") do\n    if c == \"(\" then\n      curr_level\
    \ = curr_level + 1\n      table.insert(paren_indices, curr_level)\n    elseif\
    \ c == \")\" then\n      table.insert(paren_indices, curr_level)\n      curr_level\
    \ = curr_level - 1\n    end\n  end\n  local max_level = 0\n  for i = 1, #paren_indices\
    \ do\n    local level = paren_indices[i]\n    if level > max_level then\n    \
    \  max_level = level\n    end\n    table.insert(paren_levels, level)\n  end\n\
    \  return paren_levels\nend", "    local max_levels = 0\n    local function max_paren_levels(s)\n\
    \        local level = 0\n        for c in s:gmatch(\".\") do\n            if\
    \ c == \"(\" then\n                level = level + 1\n            elseif c ==\
    \ \")\" then\n                level = level - 1\n            end\n           \
    \ max_levels = math.max(max_levels, level)\n        end\n    end\n    for s in\
    \ paren_string:gmatch(\"%b()\") do\n        max_paren_levels(s)\n    end\n   \
    \ return max_levels\nend", "    -- TODO\nend", "\tlocal parsed_nested_parens =\
    \ {}\n\tlocal paren_groups = split(paren_string, \" \")\n\tfor _, group in ipairs(paren_groups)\
    \ do\n\t\tlocal curr_level = 0\n\t\tlocal max_level = 0\n\t\tfor i = 1, #group\
    \ do\n\t\t\tlocal char = group:sub(i, i)\n\t\t\tif char == \"(\" then\n\t\t\t\t\
    curr_level = curr_level + 1\n\t\t\telseif char == \")\" then\n\t\t\t\tcurr_level\
    \ = curr_level - 1\n\t\t\tend\n\t\t\tif curr_level > max_level then\n\t\t\t\t\
    max_level = curr_level\n\t\t\tend\n\t\tend\n\t\ttable.insert(parsed_nested_parens,\
    \ max_level)\n\tend\n\treturn parsed_nested_parens\nend", "  -- Remove all the\
    \ whitespaces since it is irrelevant for the calculation\n  paren_string = paren_string:gsub(\"\
    %s+\", \"\")\n  local max_level = 0\n  local current_level = 0\n  for i = 1, paren_string:len()\
    \ do\n    local current_char = paren_string:sub(i, i)\n    if current_char ==\
    \ \"(\" then\n      current_level = current_level + 1\n      if current_level\
    \ > max_level then\n        max_level = current_level\n      end\n    elseif current_char\
    \ == \")\" then\n      current_level = current_level - 1\n    end\n  end\n  return\
    \ max_level\nend", "    local levels = {}\n    local depth = 0\n    for char in\
    \ paren_string:gmatch('.') do\n        if char == '(' then\n            depth\
    \ = depth + 1\n        elseif char == ')' then\n            table.insert(levels,\
    \ depth)\n            depth = depth - 1\n        end\n    end\n    return levels\n\
    end", "    if paren_string == nil then\n        return nil\n    end\n    local\
    \ tokens = paren_string:split(\" \")\n    local depths = {}\n    for _, token\
    \ in ipairs(tokens) do\n        local depth = 0\n        local max_depth = 0\n\
    \        for char in token:gmatch(\".\") do\n            if char == \"(\" then\n\
    \                depth = depth + 1\n            elseif char == \")\" then\n  \
    \              depth = depth - 1\n            end\n            if depth > max_depth\
    \ then\n                max_depth = depth\n            end\n        end\n    \
    \    table.insert(depths, max_depth)\n    end\n    return depths\nend", "  local\
    \ deep_levels = {}\n  local paren_groups = stringx.split(paren_string, ' ')\n\
    \  for _, paren_group in ipairs(paren_groups) do\n    local deep_level = 0\n \
    \   local max_deep_level = 0\n    for char in paren_group:gmatch('.') do\n   \
    \   if char == '(' then\n        deep_level = deep_level + 1\n      elseif char\
    \ == ')' then\n        deep_level = deep_level - 1\n      end\n      if deep_level\
    \ > max_deep_level then\n        max_deep_level = deep_level\n      end\n    end\n\
    \    deep_levels[#deep_levels + 1] = max_deep_level\n  end\n  return deep_levels\n\
    end", "  local results = {}\n  for g in paren_string:gmatch(\"%b()\") do\n   \
    \ local depth = 0\n    local current_max = 0\n    for c in g:gmatch(\".\") do\n\
    \      if c == \"(\" then\n        depth = depth + 1\n        current_max = math.max(current_max,\
    \ depth)\n      elseif c == \")\" then\n        depth = depth - 1\n      end\n\
    \    end\n    table.insert(results, current_max)\n  end\n  return results\nend",
  "  paren_string = paren_string:gsub(\" \", \"\")\n  local open_count = 0\n  local\
    \ max_open_count = 0\n  for i = 1, #paren_string do\n    local c = paren_string:sub(i,\
    \ i)\n    if c == \"(\" then\n      open_count = open_count + 1\n      if open_count\
    \ > max_open_count then\n        max_open_count = open_count\n      end\n    elseif\
    \ c == \")\" then\n      open_count = open_count - 1\n    end\n  end\n  return\
    \ max_open_count\nend", "  local curr_nest_level = 0\n  local max_nest_level =\
    \ 0\n  for _, paren in utf8.gmatch(paren_string, '.') do\n    if paren == '('\
    \ then\n      curr_nest_level = curr_nest_level + 1\n      if curr_nest_level\
    \ > max_nest_level then\n        max_nest_level = curr_nest_level\n      end\n\
    \    elseif paren == ')' then\n      curr_nest_level = curr_nest_level - 1\n \
    \   end\n  end\n  return max_nest_level\nend", "    local max_level = 0\n    local\
    \ level = 0\n    for char in paren_string:gmatch(\".\") do\n        if char ==\
    \ \"(\" then\n            level = level + 1\n            if level > max_level\
    \ then\n                max_level = level\n            end\n        elseif char\
    \ == \")\" then\n            level = level - 1\n        end\n    end\n    return\
    \ max_level\nend", "  local depth_table = {}\n  local match_str, match_table\n\
    \  local max_depth, curr_depth\n  local result_str = \"\"\n  local i, j\n  --\
    \ Iterate through each group of parentheses in the string\n  for match_str, match_table\
    \ in paren_string:gmatch(\"([%(%)]+)%s?()\") do\n    -- The following loop iterates\
    \ through the characters of the current match_str\n    curr_depth = 0\n    max_depth\
    \ = 0\n    for i = 1, #match_str do\n      -- In case of opening parenthesis,\
    \ increase the nesting level by 1\n      if match_str:sub(i, i) == \"(\" then\n\
    \        curr_depth = curr_depth + 1\n      -- In case of closing parenthesis,\
    \ reduce the nesting level by 1\n      elseif match_str:sub(i, i) == \")\" then\n\
    \        curr_depth = curr_depth - 1\n      end\n      -- Update the maximum depth\
    \ of nesting\n      if curr_depth > max_depth then\n        max_depth = curr_depth\n\
    \      end\n    end\n    -- The following line adds a group identifier to the\
    \ result string\n    result_str = result_str .. match_table .. max_depth .. \"\
    \ \"\n  end\n  -- Remove the trailing space\n  result_str = result_str:sub(1,\
    \ #result_str - 1)\n  return result_str\nend", "    local level_counts = {}\n\
    \    local max_level = 1\n    local prev_level = 1\n    local curr_level = 1\n\
    \    local my_parens = stringx.split(paren_string)\n    for i = 1, #my_parens\
    \ do\n        local my_paren = my_parens[i]\n        level_counts[i] = prev_level\n\
    \        for j = 1, #my_paren do\n            if my_paren:sub(j, j) == '(' then\n\
    \                curr_level = curr_level + 1\n            elseif my_paren:sub(j,\
    \ j) == ')' then\n                curr_level = curr_level - 1\n            end\n\
    \            level_counts[i] = math.max(level_counts[i], curr_level)\n       \
    \ end\n        if curr_level ~= 1 then\n            error('unbalanced parentheses\
    \ in input string: ' .. my_paren)\n        end\n        prev_level = curr_level\n\
    \    end\n    return level_counts\nend", "    local groups = {}\n    local num_groups\
    \ = 0\n    local i = 1\n    while i <= #paren_string do\n        local start_paren,\
    \ end_paren = paren_string:find(\"%b()\", i)\n        if start_paren then\n  \
    \          i = end_paren + 1\n            num_groups = num_groups + 1\n      \
    \      groups[num_groups] = paren_string:sub(start_paren, end_paren)\n       \
    \ else\n            break\n        end\n    end\n    if num_groups == 0 then\n\
    \        return \"\"\n    end\n    local max_depth = -1\n    for i = 1, num_groups\
    \ do\n        local group = groups[i]\n        local num_parens = 0\n        local\
    \ max_parens = 0\n        for j = 1, #group do\n            local c = group:sub(j,\
    \ j)\n            if c == \"(\" then\n                num_parens = num_parens\
    \ + 1\n            elseif c == \")\" then\n                num_parens = num_parens\
    \ - 1\n            end\n            if num_parens > max_parens then\n        \
    \        max_parens = num_parens\n            end\n        end\n        if max_parens\
    \ > max_depth then\n            max_depth = max_parens\n        end\n    end\n\
    \    return max_depth\nend", "\tlocal levels = {}\n\tlocal paren_level = 0\n\t\
    local max_level = 0\n\tfor i = 1, #paren_string do\n\t\tlocal c = paren_string:sub(i,\
    \ i)\n\t\tif c == '(' then\n\t\t\tparen_level = paren_level + 1\n\t\t\tif paren_level\
    \ > max_level then\n\t\t\t\tmax_level = paren_level\n\t\t\tend\n\t\telseif c ==\
    \ ')' then\n\t\t\tlevels[paren_level] = true\n\t\t\tparen_level = paren_level\
    \ - 1\n\t\t\tif paren_level < 0 then\n\t\t\t\terror('parse_nested_parens: Missing\
    \ opening parenthesis in \"' .. paren_string .. '\" at position ' .. i)\n\t\t\t\
    end\n\t\tend\n\tend\n\tif paren_level > 0 then\n\t\terror('parse_nested_parens:\
    \ Missing closing parenthesis in \"' .. paren_string .. '\"')\n\tend\n\treturn\
    \ levels\nend", "  local table = {}\n  -- Iterate over the string's character\
    \ by character.\n  -- For each opening parens, increment the count.\n  -- For\
    \ each closing parens, decrement the count and check if it's the lowest found\
    \ so far.\n  -- If it is, store the number of parens at that level.\n  local count\
    \ = 0\n  local index = 1\n  for i=1,#paren_string do\n    if string.sub(paren_string,\
    \ i, i) == \"(\" then\n      count = count + 1\n    elseif string.sub(paren_string,\
    \ i, i) == \")\" then\n      count = count - 1\n      if count < 0 then count\
    \ = 0 end\n      if count == 0 then\n        table[index] = count\n        index\
    \ = index + 1\n      end\n    end\n  end\n  return table\nend", "\tlocal paren_table\
    \ = {}\n\tlocal max_nesting = 0\n\tfor paren in paren_string:gmatch('%S+') do\n\
    \t\tlocal level = 0\n\t\tlocal max_level = 0\n\t\tfor c in paren:gmatch('.') do\n\
    \t\t\tif c == '(' then\n\t\t\t\tlevel = level + 1\n\t\t\t\tif level > max_level\
    \ then\n\t\t\t\t\tmax_level = level\n\t\t\t\tend\n\t\t\telseif c == ')' then\n\
    \t\t\t\tlevel = level - 1\n\t\t\tend\n\t\tend\n\t\ttable.insert(paren_table, max_level)\n\
    \t\tif max_level > max_nesting then\n\t\t\tmax_nesting = max_level\n\t\tend\n\t\
    end\n\treturn paren_table, max_nesting\nend", "    local max_nesting = 0\n   \
    \ for level in paren_string:gmatch(\"[()]+\") do\n        -- Each level is a group\
    \ of parentheses.\n        -- Strip the outermost parentheses.\n        local\
    \ level_stripped = level:sub(2, -2)\n        -- Find the max nesting level by\
    \ counting the number of '(' in the stripped level.\n        local level_nesting\
    \ = #level_stripped:gsub(\"%(\", \"\")\n        if level_nesting > max_nesting\
    \ then\n            max_nesting = level_nesting\n        end\n    end\n    return\
    \ max_nesting\nend", "    local levels = {}\n    local current_level = 0\n   \
    \ for i = 1, #paren_string do\n        local current_char = paren_string:sub(i,\
    \ i)\n        if current_char == \"(\" then\n            current_level = current_level\
    \ + 1\n        elseif current_char == \")\" then\n            table.insert(levels,\
    \ current_level)\n            current_level = current_level - 1\n        end\n\
    \    end\n    return levels\nend", "  local count = 0\n  local max = 0\n  for\
    \ paren in paren_string:gmatch(\".\") do\n    if paren == \"(\" then\n      count\
    \ = count + 1\n      if count > max then\n        max = count\n      end\n   \
    \ elseif paren == \")\" then\n      count = count - 1\n    end\n  end\n  return\
    \ max\nend", "    local paren_stack = {}\n    local deepest_level = 0\n    local\
    \ current_level = 0\n    for char in paren_string:gmatch('.') do\n        if char\
    \ == '(' then\n            paren_stack[#paren_stack + 1] = '('\n            current_level\
    \ = current_level + 1\n            if current_level > deepest_level then\n   \
    \             deepest_level = current_level\n            end\n        elseif char\
    \ == ')' then\n            if paren_stack[#paren_stack] == '(' then\n        \
    \        paren_stack[#paren_stack] = nil\n                current_level = current_level\
    \ - 1\n            else\n                -- Invalid nesting of parentheses.\n\
    \                return -1\n            end\n        end\n    end\n    if #paren_stack\
    \ ~= 0 then\n        -- Invalid nesting of parentheses.\n        return -1\n \
    \   end\n    return deepest_level\nend", "    local depth = 0\n    local max_depth\
    \ = 0\n    for i = 1, #paren_string do\n        if paren_string:sub(i, i) == '('\
    \ then\n            depth = depth + 1\n            if depth > max_depth then\n\
    \                max_depth = depth\n            end\n        elseif paren_string:sub(i,\
    \ i) == ')' then\n            depth = depth - 1\n        end\n    end\n    return\
    \ max_depth\nend", "    local current_depth, max_depth = 0, 0\n    local token,\
    \ depth\n    local last_pos = 1\n    local str_len = string.len(paren_string)\n\
    \    while last_pos <= str_len do\n        token, last_pos = get_next_token(paren_string,\
    \ last_pos)\n        depth = get_nesting_depth(token)\n        if depth == -1\
    \ then\n            if max_depth < current_depth then\n                max_depth\
    \ = current_depth\n            end\n            current_depth = 0\n        else\n\
    \            current_depth = current_depth + depth\n        end\n    end\n   \
    \ return max_depth\nend", "  local levels = {}\n  for _, paren_group in ipairs(stringx.split(paren_string,\
    \ \" \")) do\n    local level = 0\n    local max_level = 0\n    for _, paren in\
    \ utf8.next, paren_group do\n      if paren == \"(\" then\n        level = level\
    \ + 1\n      elseif paren == \")\" then\n        level = level - 1\n      end\n\
    \      max_level = math.max(max_level, level)\n    end\n    table.insert(levels,\
    \ max_level)\n  end\n  return levels\nend", "  local depth_max = 0\n  local depth_cur\
    \ = 0\n  local paren_stack = {}\n  local paren_table = {}\n  for char in paren_string:gmatch('.')\
    \ do\n    table.insert(paren_table, char)\n  end\n  for index,char in ipairs(paren_table)\
    \ do\n    if char == '(' then\n      depth_cur = depth_cur + 1\n      table.insert(paren_stack,\
    \ index)\n    elseif char == ')' then\n      depth_cur = depth_cur - 1\n     \
    \ table.remove(paren_stack)\n    end\n    if depth_cur > depth_max then\n    \
    \  depth_max = depth_cur\n    end\n  end\n  return depth_max\nend", "\tlocal max_level\
    \ = 0\n\tfor paren in paren_string:gmatch(\"%b()\") do\n\t\tlocal level = 0\n\t\
    \tlocal function count_parens()\n\t\t\tlevel = level + 1\n\t\t\tmax_level = math.max(max_level,\
    \ level)\n\t\tend\n\t\tparen:gsub(\"%(\", count_parens)\n\t\tparen:gsub(\"%)\"\
    , function() level = level - 1 end)\n\tend\n\treturn max_level\nend", "  local\
    \ max_depth = 0\n  for group in paren_string:gmatch(\"%b()\") do\n    local depth\
    \ = 0\n    for c in group:gmatch(\".\") do\n      if c == \"(\" then\n       \
    \ depth = depth + 1\n      elseif c == \")\" then\n        depth = depth - 1\n\
    \      end\n    end\n    if depth > max_depth then\n      max_depth = depth\n\
    \    end\n  end\n  return max_depth\nend", "\tlocal max_depth = 0\n\tlocal current_depth\
    \ = 0\n\t\n\tlocal function parens_depth(s)\n\t\tfor i = 1, #s do\n\t\t\tlocal\
    \ cur_char = s:sub(i, i)\n\t\t\tif cur_char == \"(\" then\n\t\t\t\tcurrent_depth\
    \ = current_depth + 1\n\t\t\t\tif current_depth > max_depth then\n\t\t\t\t\tmax_depth\
    \ = current_depth\n\t\t\t\tend\n\t\t\telseif cur_char == \")\" then\n\t\t\t\t\
    current_depth = current_depth - 1\n\t\t\tend\n\t\tend\n\tend\n\t\n\tfor token\
    \ in paren_string:gmatch(\"%S+\") do\n\t\tcurrent_depth = 0\n\t\tparens_depth(token)\n\
    \t\tio.write(max_depth, \" \")\n\tend\n\tio.write(\"\\n\")\nend", "  -- Remove\
    \ spaces from string.\n  local paren_string = paren_string:gsub(\" \", \"\")\n\
    \  -- Get the number of nested parentheses for each group.\n  local num_nested_parens\
    \ = {}\n  local paren_index = 1\n  while paren_index <= #paren_string do\n   \
    \ local start_paren_index = paren_index\n    local end_paren_index = paren_index\n\
    \    while paren_string:sub(paren_index, paren_index) == \"(\" do\n      start_paren_index\
    \ = paren_index\n      -- Find the number of parentheses that need to be closed.\n\
    \      local num_parens_to_close = 1\n      while num_parens_to_close > 0 do\n\
    \        end_paren_index = end_paren_index + 1\n        local paren = paren_string:sub(end_paren_index,\
    \ end_paren_index)\n        if paren == \"(\" then\n          num_parens_to_close\
    \ = num_parens_to_close + 1\n        elseif paren == \")\" then\n          num_parens_to_close\
    \ = num_parens_to_close - 1\n        end\n      end\n      paren_index = end_paren_index\
    \ + 1\n    end\n    -- Add the number of nested parentheses to our list.\n   \
    \ table.insert(num_nested_parens, end_paren_index - start_paren_index)\n  end\n\
    \  return num_nested_parens\nend", "  local cur_lvl = 0\n  local paren_levels\
    \ = {}\n  for i=1,#paren_string do\n    local paren = paren_string:sub(i,i)\n\
    \    if paren == '(' then\n      cur_lvl = cur_lvl + 1\n    elseif paren == ')'\
    \ then\n      cur_lvl = cur_lvl - 1\n    end\n    table.insert(paren_levels, cur_lvl)\n\
    \  end\n  return paren_levels\nend", "\tlocal levels = {}\n\tfor i, group in ipairs(paren_string:split(\"\
    \ \")) do\n\t\tlocal level = 0\n\t\tlocal max_level = 0\n\t\tfor paren in group:gmatch(\"\
    [()]\") do\n\t\t\tif paren == \"(\" then\n\t\t\t\tlevel = level + 1\n\t\t\telse\n\
    \t\t\t\tlevel = level - 1\n\t\t\tend\n\t\t\tmax_level = math.max(max_level, level)\n\
    \t\tend\n\t\tlevels[i] = max_level\n\tend\n\treturn levels\nend", "  local groups\
    \ = stringx.split(paren_string, \" \")\n  local depths = torch.IntTensor(#groups)\n\
    \  for i = 1, #groups do\n    depths[i] = parse_parens(groups[i])\n  end\n  return\
    \ depths\nend", "  local function max(a, b)\n    if a > b then\n      return a\n\
    \    else\n      return b\n    end\n  end", "\tlocal LEVEL = 1\n\tlocal brace_nesting_level\
    \ = 0\n\tlocal paren_nesting_level = 0\n\tlocal max_nesting_level = 0\n\tlocal\
    \ inside_paren = false\n\tlocal inside_brace = false\n\tlocal paren_index = 1\n\
    \tlocal brace_index = 1\n\tfor i = 1,#paren_string do\n\t\tlocal a = paren_string:sub(i,i)\n\
    \t\tif a == \"(\" then\n\t\t\tif inside_brace then\n\t\t\t\tbrace_nesting_level\
    \ = brace_nesting_level + 1\n\t\t\telse\n\t\t\t\tinside_paren = true\n\t\t\t\t\
    inside_brace = false\n\t\t\t\tbrace_nesting_level = 0\n\t\t\t\tparen_nesting_level\
    \ = paren_nesting_level + 1\n\t\t\t\tif paren_nesting_level > max_nesting_level\
    \ then\n\t\t\t\t\tmax_nesting_level = paren_nesting_level\n\t\t\t\tend\n\t\t\t\
    end\n\t\telseif a == \")\" then\n\t\t\tif inside_brace then\n\t\t\t\tbrace_nesting_level\
    \ = brace_nesting_level - 1\n\t\t\telse\n\t\t\t\tinside_paren = false\n\t\t\t\t\
    inside_brace = false\n\t\t\t\tbrace_nesting_level = 0\n\t\t\t\tparen_nesting_level\
    \ = paren_nesting_level - 1\n\t\t\tend\n\t\telseif a == \"{\" then\n\t\t\tif inside_paren\
    \ then\n\t\t\t\tparen_nesting_level = paren_nesting_level + 1\n\t\t\telse\n\t\t\
    \t\tinside_paren = false\n\t\t\t\tinside_brace = true\n\t\t\t\tparen_nesting_level\
    \ = 0\n\t\t\t\tbrace_nesting_level = brace_nesting_level + 1\n\t\t\t\tif brace_nesting_level\
    \ > max_nesting_level then\n\t\t\t\t\tmax_nesting_level = brace_nesting_level\n\
    \t\t\t\tend\n\t\t\tend\n\t\telseif a == \"}\" then", "\tlocal groups = paren_string:split('\
    \ ')\n\tlocal max_depth = {}\n\tlocal depth = 0\n\tlocal group_counter = 1\n\t\
    for i = 1, #groups do\n\t\tlocal char = groups[i]\n\t\tif char == '(' then\n\t\
    \t\tdepth = depth + 1\n\t\telseif char == ')' then\n\t\t\tdepth = depth - 1\n\t\
    \tend\n\t\tif i == #groups or groups[i + 1] == '(' then\n\t\t\tif depth > max_depth[group_counter]\
    \ then\n\t\t\t\tmax_depth[group_counter] = depth\n\t\t\tend\n\t\t\tgroup_counter\
    \ = group_counter + 1\n\t\tend\n\tend\n\treturn table.concat(max_depth, ' ')\n\
    end", "  local paren_levels = {}\n  local paren_level = 0\n  local temp_num =\
    \ ''\n  local is_in_paren = false\n  local function on_char(ch)\n    if ch ==\
    \ '(' then\n      if is_in_paren then\n        paren_level = paren_level + 1\n\
    \      else\n        is_in_paren = true\n      end\n    elseif ch == ')' then\n\
    \      if is_in_paren then\n        paren_level = paren_level - 1\n        if\
    \ paren_level == 0 then\n          paren_levels[#paren_levels + 1] = temp_num\n\
    \          temp_num = ''\n          is_in_paren = false\n        end\n      end\n\
    \    elseif is_in_paren then\n      temp_num = temp_num .. ch\n    end\n  end\n\
    \  for i = 1, #paren_string do\n    on_char(paren_string:sub(i, i))\n  end\n \
    \ return paren_levels\nend", "    if not paren_string then\n        return ''\n\
    \    end\n    local output = ''\n    local result = {}\n    local P = lpeg.P\n\
    \    local R = lpeg.R\n    local S = lpeg.S\n    local C = lpeg.C\n    local Ct\
    \ = lpeg.Ct\n    local Cg = lpeg.Cg\n    local Cp = lpeg.Cp\n    local Cc = lpeg.Cc\n\
    \    local Cf = lpeg.Cf\n    local V = lpeg.V\n    local get_max_nesting = function(acc,\
    \ n)\n        local max_nesting = acc.max_nesting\n        if not max_nesting\
    \ then\n            max_nesting = 0\n        end\n        local max_nesting_new\
    \ = n and n.max_nesting\n        if max_nesting_new and max_nesting_new > max_nesting\
    \ then\n            max_nesting = max_nesting_new\n        end\n        return\
    \ acc.output and (max_nesting + 1) or max_nesting\n    end\n    local paren_grammar\
    \ = P{\n        'paren_grammar',\n        paren_grammar = (\n            Ct(\n\
    \                ((\n                    -- start a group when meet '('\n    \
    \                P'(' * Cp() * Cg(Cc(0), 'max_nesting') *\n                  \
    \  V'paren_grammar' *\n                    -- output accumulated max nesting when\
    \ meet ')'\n                    (\n                        P')' * Cp() * Cg(Cf(Cc(0),\
    \ get_max_nesting), 'max_nesting')\n                    )\n                ) +\n\
    \                -- return 0 when meet ')'\n                P')' * Cp() * Cg(Cc(0),\
    \ 'max_nesting')\n                )^0\n            ) * Cp()\n        )\n    }\n\
    \    paren_grammar = paren_grammar + V'paren_grammar'\n    result = paren_grammar:match(paren_string)\n\
    \    if not result then\n        return ''\n    end\n    for i = 1, #result do\n\
    \        output = output .. ' ' .. tostring(", "  local nest_levels = {}\n  for\
    \ match in paren_string:gmatch(\"([%(%)]+)\") do\n    local curr_level = 0\n \
    \   local nested_level = 0\n    for char in match:gmatch(\".\") do\n      if char\
    \ == \"(\" then\n        curr_level = curr_level + 1\n        nested_level = math.max(nested_level,\
    \ curr_level)\n      else\n        curr_level = curr_level - 1\n      end\n  \
    \  end\n    table.insert(nest_levels, nested_level)\n  end\n  return nest_levels\n\
    end", "\tlocal ret = {}\n\tlocal prev_level = 0\n\tlocal curr_level = 0\n\t\n\t\
    paren_string:gsub(\"[%(%)]\", function(p)\n\t\tif p == \"(\" then\n\t\t\tcurr_level\
    \ = curr_level + 1\n\t\telseif p == \")\" then\n\t\t\tif curr_level > prev_level\
    \ then\n\t\t\t\tprev_level = curr_level\n\t\t\tend\n\t\t\tcurr_level = curr_level\
    \ - 1\n\t\tend\n\tend)\n\t\n\tret[#ret + 1] = prev_level\n\treturn ret\nend",
  "  local MAX_LEVEL = 0\n  local current_level = 0\n  for i=1,#paren_string do\n\
    \    local curr_char = paren_string:sub(i,i)\n    if curr_char == '(' then\n \
    \     current_level = current_level + 1\n      if current_level > MAX_LEVEL then\n\
    \        MAX_LEVEL = current_level\n      end\n    elseif curr_char == ')' then\n\
    \      current_level = current_level - 1\n    end\n  end\n  return MAX_LEVEL\n\
    end", "    local paren_string = paren_string:gsub(\"%s+\", \"\")\n    local depth_vec\
    \ = {}\n    local temp_depth = 0\n    for i = 1, #paren_string do\n        if\
    \ paren_string:sub(i, i) == \"(\" then\n            temp_depth = temp_depth +\
    \ 1\n        elseif paren_string:sub(i, i) == \")\" then\n            depth_vec[#depth_vec\
    \ + 1] = temp_depth\n            temp_depth = temp_depth - 1\n        end\n  \
    \  end\n    return depth_vec\nend", "  local max_nesting = 0\n  local nesting\
    \ = 0\n  for i = 1, #paren_string do\n    if paren_string:sub(i, i) == '(' then\n\
    \      nesting = nesting + 1\n      if nesting > max_nesting then\n        max_nesting\
    \ = nesting\n      end\n    elseif paren_string:sub(i, i) == ')' then\n      nesting\
    \ = nesting - 1\n    end\n  end\n  return max_nesting\nend", "\tlocal i = 1\n\t\
    local str_len = #paren_string\n\tlocal paren_groups = {}\n\tlocal paren_group\
    \ = {}\n\twhile i <= str_len do\n\t\tlocal byte = string.byte(paren_string, i)\n\
    \t\tif byte == 32 then\n\t\t\ttable.insert(paren_groups, paren_group)\n\t\t\t\
    paren_group = {}\n\t\telse\n\t\t\ttable.insert(paren_group, byte)\n\t\tend\n\t\
    \ti = i + 1\n\tend\n\ttable.insert(paren_groups, paren_group)\n\tlocal result\
    \ = {}\n\tfor _, grp in ipairs(paren_groups) do\n\t\tlocal grp_len = #grp\n\t\t\
    local max_depth = 0\n\t\tlocal curr_depth = 0\n\t\tfor j = 1, grp_len do\n\t\t\
    \tlocal c = grp[j]\n\t\t\tif c == 40 then\n\t\t\t\tcurr_depth = curr_depth + 1\n\
    \t\t\t\tif curr_depth > max_depth then\n\t\t\t\t\tmax_depth = curr_depth\n\t\t\
    \t\tend\n\t\t\telseif c == 41 then\n\t\t\t\tcurr_depth = curr_depth - 1\n\t\t\t\
    end\n\t\tend\n\t\ttable.insert(result, max_depth)\n\tend\n\treturn result\nend",
  "    local levels = {}\n    for group in paren_string:gmatch(\"[%(%) ]+\") do\n\
    \        local level = 0\n        for _ in group:gmatch(\"%(\") do\n         \
    \   level = level + 1\n        end\n        levels[#levels + 1] = level\n    end\n\
    \    return levels\nend", "    if paren_string == nil then\n        return \"\"\
    \n    end\n    local deepest_level = 0\n    local paren_level = 0\n    for i=1,string.len(paren_string)\
    \ do\n        local c = string.sub(paren_string, i, i)\n        if c == \"(\"\
    \ then\n            paren_level = paren_level + 1\n            if paren_level\
    \ > deepest_level then\n                deepest_level = paren_level\n        \
    \    end\n        elseif c == \")\" then\n            paren_level = paren_level\
    \ - 1\n        end\n    end\n    return string.rep(\" \", deepest_level - 1)\n\
    end", "\tlocal t = {}\n\tlocal i = 1\n\twhile true do\n\t\tlocal p = string.find(paren_string,\
    \ ' ', i)\n\t\tif p == nil then\n\t\t\tif i > #paren_string then\n\t\t\t\tbreak\n\
    \t\t\tend\n\t\t\ttable.insert(t, paren_string:sub(i))\n\t\t\tbreak\n\t\tend\n\t\
    \ttable.insert(t, paren_string:sub(i, p-1))\n\t\ti = p + 1\n\tend\n\tlocal a =\
    \ {}\n\tfor i = 1, #t do\n\t\tlocal max = 0\n\t\tlocal count = 0\n\t\tfor j =\
    \ 1, #t[i] do\n\t\t\tif t[i]:sub(j, j) == '(' then\n\t\t\t\tcount = count + 1\n\
    \t\t\telseif t[i]:sub(j, j) == ')' then\n\t\t\t\tcount = count - 1\n\t\t\tend\n\
    \t\t\tif count > max then\n\t\t\t\tmax = count\n\t\t\tend\n\t\tend\n\t\ttable.insert(a,\
    \ max)\n\tend\n\treturn a\nend", '    local paren_pattern = "(%b())"', "    local\
    \ depth = 0\n    local max_depth = 0\n    for s in paren_string:gmatch(\".\")\
    \ do\n        if s == \"(\" then\n            depth = depth + 1\n            if\
    \ depth > max_depth then\n                max_depth = depth\n            end\n\
    \        elseif s == \")\" then\n            depth = depth - 1\n        end\n\
    \    end\n    return max_depth\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
