name: HumanEval_91_is_bored
language: lua
prompt: "-- You'll be given a string of words, and your task is to count the number\n\
  -- of boredoms. A boredom is a sentence that starts with the word \"I\".\n-- Sentences\
  \ are delimited by '.', '?' or '!'.\n-- For example:\nlocal function is_bored(S)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_bored\n\
  \    lu.assertEquals(candidate('Hello world'), 0)\n    lu.assertEquals(candidate('Is\
  \ the sky blue?'), 0)\n    lu.assertEquals(candidate('I love It !'), 1)\n    lu.assertEquals(candidate('bIt'),\
  \ 0)\n    lu.assertEquals(candidate('I feel good today. I will be productive. will\
  \ kill It'), 2)\n    lu.assertEquals(candidate('You and I are going for a walk'),\
  \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  return S:match(\"^%s*I\") ~= nil\nend", "    if S == \"\" then return\
    \ false end\n    local a, b = S:match(\"^%s*(%a+)(.*)\")\n    if a == \"I\" then\
    \ return true end\n    return false\nend", "   local x,_ = S:find(\"^[ \\t]*I\"\
    ,1,true)\n   return x ~= nil\nend", "   return string.sub(S, 1, 1) == \"I\"\n\
    end", "  return S:sub(1,1) == \"I\"\nend", "  return S:sub(1, 1) == \"I\"\nend",
  "    return S:match \"^%s*I\" and true or false\nend", "    local subs = string.split(S,\
    \ \" \")\n    if subs[1] == \"I\" then\n        return true\n    end\n    return\
    \ false\nend", "    if S == \"I\" then\n        return true\n    end\n    return\
    \ false\nend", "  -- Split S into separate sentences.\n  local sentences = S:split('[%.!?]')\n\
    \  local boredoms = 0\n  for i,sentence in ipairs(sentences) do\n    -- Trim the\
    \ spaces around the sentence.\n    sentence = sentence:trim()\n    -- Check if\
    \ the sentence starts with \"I\", if so, add one to the boredom\n    -- count.\n\
    \    if sentence:sub(1, 1) == 'I' then\n      boredoms = boredoms + 1\n    end\n\
    \  end\n  return boredoms\nend", '   -- return true if S is a sentence that starts
    with "I"', "  if string.match(S, \"^I%s\") == nil then\n    return \"not bored\"\
    \n  else\n    return \"bored\"\n  end\nend", "   return string.sub(S, 1, 1) ==\
    \ \"I\"\nend", "   -- Check whether the given sentence S is a boredom.\n   if\
    \ #S < 2 then return false end\n   if S:sub(1,1) ~= \"I\" then return false end\n\
    \   local c = S:sub(2,2)\n   if c ~= \" \" and c ~= \"'\" and c ~= \":\" then\
    \ return false end\n   return true\nend", "  return S:match(\"^I\") and true or\
    \ false\nend", "    return S:find(\"^%s*I\")\nend", "    -- O(log N)\n    return\
    \ S:find(\"I[ \\t]\") ~= nil\nend", "   return S:match('^I')\nend", "    if S:sub(1,1)\
    \ == \"I\" then\n        return true\n    else\n        return false\n    end\n\
    end", "  local state = 'bored'\n  for word in S:gmatch'%S+' do\n    if state ==\
    \ 'bored' then\n      if word == 'I' then\n        state = 'not-bored'\n     \
    \ end\n    elseif state == 'not-bored' then\n      if word == '.' or word == '?'\
    \ or word == '!' then\n        state = 'bored'\n      end\n    end\n  end\n  return\
    \ state == 'not-bored'\nend", "   return S:match('^I') ~= nil\nend", "   return\
    \ S:sub(1,1) == \"I\"\nend", "   -- Find the first word and make sure it's 'I'.\n\
    \   local _, pos = S:find('%a+')\n   if not pos then return 0 end\n   if S:sub(1,\
    \ pos-1) ~= 'I' then return 0 end", "  local A = S:split(\"[%.%?!]\") -- Split\
    \ into sentence\n  for i = 1, #A do\n    if A[i]:find(\"^[%s]*I\") then\n    \
    \  return true\n    end\n  end\n  return false\nend", "    -- Complete this function\n\
    end", "   for w in S:gmatch(\"[^%s]+\") do -- each word in S\n      if w:match(\"\
    ^I$\") then\n         return true\n      end\n   end\n   return false\nend\nboredoms\
    \ \"I am bored.\"", "    -- sentences = string.gmatch(S, \"[^%.!?]+\")\n    local\
    \ sentences = split(S, \"[%.!?]\")\n    for _,s in ipairs(sentences) do\n    \
    \    if s:match(\"^%s*I\") then\n            return true\n        end\n    end\n\
    \    return false\nend", "   return S:match(\"^%s*I%s\")\nend", "    return S:sub(1,1)\
    \ == \"I\"\nend", "    -- return true if S is a boredom\nend", "    local state\
    \ = 0\n    for c in S:gmatch('.') do\n        if state == 0 then\n           \
    \ if c:match('%s') then\n                -- do nothing\n            elseif c ==\
    \ 'I' then\n                state = 1\n            else\n                state\
    \ = 2\n            end\n        elseif state == 1 then\n            if c:match('%s')\
    \ then\n                state = 3\n            elseif c == '.' or c == '?' or\
    \ c == '!' then\n                return true\n            else\n             \
    \   state = 2\n            end\n        elseif state == 2 then\n            if\
    \ c == '.' or c == '?' or c == '!' then\n                return false\n      \
    \      end\n        elseif state == 3 then\n            if c == '.' or c == '?'\
    \ or c == '!' then\n                return true\n            elseif c:match('%s')\
    \ then\n                -- do nothing\n            else\n                state\
    \ = 2\n            end\n        end\n    end\n    return false\nend", "   -- WTF?\
    \ The string module was removed from lua 5.2! Not that it mattered\n   -- since\
    \ these problems aren't case sensitive.\n   return S:match('^%s*I%s') ~= nil\n\
    end", "  return S:sub(1, 1) == \"I\"\nend", "    local index = S:find(\"I\")\n\
    \    if index == 1 then\n        return true\n    end\n    return false\nend",
  "  local i = 1\n  while i <= #S do\n    local c = S:sub(i, i)\n    if c == '.' or\
    \ c == '?' or c == '!' then\n      -- end of sentence\n      if S:sub(1, i - 1)\
    \ == 'I' then\n        return true\n      end\n      i = i + 1\n    else\n   \
    \   i = i + 1\n    end\n  end\n  return false\nend", "    local head, tail = S:match(\"\
    ^(I)(.*)\")\n    if head == \"I\" then\n        return tail:match(\"^%s[a-z].*\"\
    )\n    end\nend", "  return true\nend", "    if S:len() < 2 then return false\
    \ end\n    local c = S:sub(1,1)\n    if c ~= \"I\" then return false end\n   \
    \ c = S:sub(2,2)\n    if c ~= \" \" then return false end\n    return true\nend",
  "    return S:find(\"^I\") ~= nil\nend", "    return string.sub(S, 1, 1) == \"I\"\
    \nend", "  --[[\n  for w in S:gmatch(\"%w+\") do\n    if w == \"I\" then\n   \
    \   return true\n    end\n  end\n  return false\n  --]]\n  return S:find(\"^I\"\
    ) ~= nil\nend", "   return S:sub(1, 1) == \"I\"\nend", "  return S:find(\"^I\"\
    ) ~= nil\nend", "  return S:sub(1, 1) == \"I\"\nend", "   local boredoms = 0\n\
    \   local words = {}\n   local i = 1\n   local start = 1\n   while i <= #S do\n\
    \      if S:sub(i,i) == ' ' then\n         if #words > 0 then\n            if\
    \ (words[1] == 'I') and (words[2] == 'am') then\n               boredoms = boredoms\
    \ + 1\n            end\n            words = {}\n         end\n         start =\
    \ i + 1\n      elseif (S:sub(i,i) == '.') or (S:sub(i,i) == '?') or (S:sub(i,i)\
    \ == '!') then\n         if #words > 0 then\n            if (words[1] == 'I')\
    \ and (words[2] == 'am') then\n               boredoms = boredoms + 1\n      \
    \      end\n            words = {}\n         end\n         start = i + 1\n   \
    \   else\n         table.insert(words, S:sub(start,i))\n      end\n      i = i\
    \ + 1\n   end\n   if #words > 0 then\n      if (words[1] == 'I') and (words[2]\
    \ == 'am') then\n         boredoms = boredoms + 1\n      end\n   end\n   return\
    \ boredoms\nend\nprint(is_bored('I am sooo bored.'))\nprint(is_bored('I am sooo\
    \ bored. Hello world!'))\nprint(is_bored('I am sooo bored. Hello world! Want to\
    \ go to the movies?'))\nprint(is_bored('How are you?'))\nprint(is_bored('Hi!'))\n\
    print(is_bored('I am bored.'))\nprint(is_bored('I am really really bored. I am\
    \ so bored!'))\nprint(is_bored('I am bored out of my mind. I can\\'t wait to get\
    \ home.'))\nprint(is_bored('I am sooo bored. Hello world! Want to go to the movies?\
    \ Hell yeah!'))\nprint(is_bored('I am sooo bored. Hello world! Want to go to the\
    \ movies? Hell yeah! I am bored out of my mind. I can\\'t wait to get home.'))\n\
    print(", "   return S:match(\"^I .*$\")\nend", "    return S:lower():match('^i')\
    \ ~= nil\nend", "  return (string.match(S, 'I') == 'I')\nend", "  -- start of\
    \ sentence, then I\n  return S:match \"^%s*I\"\nend", "  return S:sub(1,1) ==\
    \ \"I\"\nend", "    local words = string.gmatch(S, '%S+')\n    local first_word\
    \ = words()\n    return first_word == 'I'\nend", "    return (S:sub(1,1) == \"\
    I\")\nend", "    return string.sub(S, 1, 1) == \"I\"\nend", "  S = \"I am bored.\"\
    \n  count_boredoms(S)\n  --output : 1\n  S = \"I am really really bored.\"\n \
    \ count_boredoms(S)\n  --output : 1\n  S = \"I am bored. I am bored\"\n  count_boredoms(S)\n\
    \  --output : 2\n  S = \"I am bored. I am bored. I am bored. I am bored\"\n  count_boredoms(S)\n\
    \  --output : 4\n  S = \"I am bored! I am bored?\"\n  count_boredoms(S)\n  --output\
    \ : 2\n  S = \"I am bored. I am very bored. I am very very bored.\"\n  count_boredoms(S)\n\
    \  --output : 3\n  S = \"I am bored. You are bored. You are very bored. They are\
    \ very bored\"\n  count_boredoms(S)\n  --output : 1\n  S = \"I am not bored. You\
    \ are bored. You are very bored. They are very bored\"\n  count_boredoms(S)\n\
    \  --output : 0\n  S = \"I am bored. I am bored\"\n  count_boredoms(S)\n  --output\
    \ : 2\n  S = \"I am bored.\"\n  count_boredoms(S)\n  --output : 1\n  S = \"I am\
    \ bored! I am bored?\"\n  count_boredoms(S)\n  --output : 2\n  S = \"I am bored.\
    \ I am bored.\"\n  count_boredoms(S)\n  --output : 2\n  S = \"I am bored. I am\
    \ bored. I am bored. I am bored\"\n  count_boredoms(S)\n  --output : 4\n  S =\
    \ \"I am bored. I am bored. I am bored.\"\n  count_boredoms(S)\n  --output : 3\n\
    \  S = \"I am bored. I am very bored. I am very very bored.\"\n  count_boredoms(S)\n\
    \  --output : 3\n  S = \"I am bored. I am very bored. I am very very bored. I\
    \ am very very very bored.\"\n  count_b", "    local bor = 0\n    -- split on\
    \ punctuation\n    local punctuation = {'.', '?', '!'}\n    local is_punct = {}\n\
    \    for _, p in ipairs(punctuation) do\n        is_punct[p] = true\n    end\n\
    \    local words = {}\n    for w in string.gmatch(S, '%w+') do\n        words[#words\
    \ + 1] = w\n    end\n    for i = 1, #words do\n        local w = words[i]\n  \
    \      local punct = words[i + 1]\n        if w == 'I' and is_punct[punct] then\n\
    \            bor = bor + 1\n        end\n    end\n    return bor\nend", "   local\
    \ n = 0\n   for w in S:gmatch(\"%S+\") do\n      if w == \"I\" then\n        \
    \ n = n + 1\n      end\n   end\n   return n\nend", "  return S:match('^I.*')\n\
    end", "   local words = S:split()\n   if words[1] == \"I\" then\n      return\
    \ true\n   else\n      return false\n   end\nend", "    if (#S > 0) and string.upper(S:sub(1,1))\
    \ == \"I\" then\n        return true\n    end\n    return false\nend", "  return\
    \ S:match(\"^I\") ~= nil\nend", "   return S:match(\"^%s*I\") ~= nil\nend", " \
    \   -- \"I am bored!\" = 1\n    -- \"I want to eat!\" = 1\n    -- \"I am bored!\
    \ I am hungry!\" = 2\n    -- \"I am bored? I am hungry!\" = 2\n    -- \"I am bored\"\
    \ = 1\n    -- \"Let's go skateboard in the park!\" = 0\n    -- \"I want to, but\
    \ I can't\" = 1\n    -- \"Why me... Why\" = 1\n    -- \"I am doing good. I think\"\
    \ = 1\n    local function tsplit(s, delimiter)\n        result = {};\n       \
    \ for match in (s..delimiter):gmatch(\"(.-)\"..delimiter) do\n            table.insert(result,\
    \ match);\n        end\n        return result;\n    end\n    local sentences =\
    \ tsplit(S, \"!\")\n    local count = 0\n    for i,v in ipairs(sentences) do\n\
    \        if(v:sub(1,1) == \"I\") then\n            count = count + 1\n       \
    \ end\n    end\n    return count\nend", "    local state = \"start\"\n    for\
    \ c in S:gmatch(\".\") do\n        if state == \"start\" then\n            if\
    \ c == \"I\" then\n                state = \"I\"\n            elseif c == \" \"\
    \ then\n                state = \"start\"\n            else\n                state\
    \ = \"other\"\n            end\n        elseif state == \"I\" then\n         \
    \   if c == \" \" then\n                state = \"start\"\n            else\n\
    \                state = \"other\"\n            end\n        elseif state == \"\
    other\" then\n            if c == \".\" or c == \"?\" or c == \"!\" then\n   \
    \             state = \"start\"\n            end\n        end\n    end\n    return\
    \ state == \"I\"\nend\nprint(is_bored(\"I am bored.\"))\nprint(is_bored(\"I am\
    \ not bored.\"))\nprint(is_bored(\"I am bored\"))\nprint(is_bored(\"I am bored!\"\
    ))\nprint(is_bored(\"I am boring!\"))\nprint(is_bored(\"I am boring. You are boring.\"\
    ))", "  -- Split the string into sentences.\n  local sentences = S:split(\"[.?!]\"\
    )\n  -- Remove any leading or trailing spaces.\n  for i, sentence in ipairs(sentences)\
    \ do\n    sentences[i] = sentence:trim()\n  end\n  -- Count the boring sentences.\n\
    \  local n = 0\n  for _, sentence in ipairs(sentences) do\n    if sentence:sub(1,\
    \ 1) == \"I\" then\n      n = n + 1\n    end\n  end\n  return n\nend", "  if (S:sub(1,2)\
    \ == \"I \") then\n    return true\n  else\n    return false\n  end\nend", " \
    \ for i = 1, #S do\n    if S:sub(i, i) == 'I' then\n      return true\n    end\n\
    \  end\n  return false\nend", "  local ww, w = {}, ''\n  local inside_sentence\
    \ = false\n  for _, c in ipairs(utf8.totable(S)) do\n    if inside_sentence then\n\
    \      if utf8.match(c, '[!.?]') then\n        inside_sentence = false\n     \
    \   table.insert(ww, w)\n        w = ''\n      else\n        w = w .. c\n    \
    \  end\n    else\n      if c == 'I' then\n        inside_sentence = true\n   \
    \     w = 'I'\n      end\n    end\n  end\n  local boredoms = 0\n  for _, w in\
    \ ipairs(ww) do\n    if utf8.match(w, '^I ') then\n      boredoms = boredoms +\
    \ 1\n    end\n  end\n  return boredoms\nend", "    for T in S:gmatch(\"[^.!?]+\"\
    ) do\n        if T:match(\"^I\") then\n            return 1\n        end\n   \
    \ end\n    return 0\nend", "    return #S:match('^I ') > 0\nend", "    return\
    \ string.sub(S, 1, 1) == \"I\"\nend", "   local i = 1\n   while S:sub(i,i) ==\
    \ ' ' do i = i + 1 end\n   if S:sub(i,i+1) == 'I ' then return true end\n   return\
    \ false\nend", "   -- your solution\nend", "  return #S >= 2 and S:sub(1,1) ==\
    \ \"I\" and S:sub(2,2) == \" \"\nend", "    return (S:sub(1, 1) == \"I\")\nend",
  "  local s = S:lower() -- insensitive to case\n  local start = s:find(\"i\",1,true)\
    \ -- insensitive to case\n  if start == 1 then\n    return true\n  else\n    return\
    \ false\n  end\nend", "  return string.match(S, \"^[%s]*I.*$\") ~= nil\nend",
  "   return (S:match(\"^I \") ~= nil)\nend", "    return string.find(S,\"^I\") ~=\
    \ nil\nend", "    return S:find(\"I \") == 1\nend", "   local function is_bored(s)\n\
    \      for w in s:gmatch(\"%S+\") do\n         if w == \"I\" then return true\
    \ end\n      end\n      return false\n   end\n   local boredoms = 0\n   for s\
    \ in S:gmatch(\"[^%.!?]+\") do\n      if is_bored(s) then boredoms = boredoms\
    \ + 1 end\n   end\n   return boredoms\nend", "  if not S:find(\"^I\") then return\
    \ 0 end\n  return 1\nend", "    return S:match\"^I\"\nend", "    return S:find(\"\
    ^I\")\nend", "    return S:match('^%s*I') ~= nil\nend", "    return S:sub(1,1)\
    \ == \"I\"\nend", "    local boredoms = 0\n    local start = S:find(\"I\")\n \
    \   local end_point = S:find(\"[.?!]\")\n    while start and end_point do\n  \
    \      if start < end_point then\n            boredoms = boredoms + 1\n      \
    \  end\n        S = S:sub(end_point + 1)\n        start = S:find(\"I\")\n    \
    \    end_point = S:find(\"[.?!]\")\n    end\n    return boredoms\nend\nassert(is_bored(\"\
    I am? bored! I\") == 2)\nassert(is_bored(\"I am bored! I. I am bored\") == 3)",
  "    -- TODO: Write code here\nend\nprint(is_bored(\"I am bored. I hate being bored.\
    \ I am happy\"))\nprint(is_bored(\"I am happy. I love being happy. I hate being\
    \ bored\"))", "    return S:match('^I ') ~= nil\nend", "    return S:find \"^I\"\
    \ ~= nil\nend", "   local c = S:sub(1,1)\n   return c == 'I'\nend", "    for word\
    \ in S:gmatch(\"%w+\") do\n        if word == \"I\" then\n            return true\n\
    \        end\n    end\n    return false\nend", "    -- Pattern we're looking for:\
    \ \"I\" followed by zero or more spaces.\n    local P = \"^I%s*\"\n    -- The\
    \ 'find' function of strings simply looks for the pattern P\n    -- in S, and\
    \ returns the index of the start of the first match,\n    -- or nil if there is\
    \ no match.\n    local i = S:find(P)\n    return i and true or false\nend", " \
    \  if S:sub(1,1) == \"I\" then\n      return 1\n   else\n      return 0\n   end\n\
    end", "    return S:sub(1, 1) == \"I\"\nend", "   local x = S:match(\"^I(.*)\"\
    )\n   return x and #x > 1\nend", "   for s in S:gmatch('I[^%.!%?]+') do\n    \
    \  return true\n   end\n   return false\nend\nboredom_count :: String -> Int\n\
    boredom_count xs = length . filter is_bored . sentences $ xs", "    return string.sub(S,\
    \ 1, 1) == \"I\"\nend", "  return S:sub(1,1) == \"I\"\nend", "    if S == 'I'\
    \ then\n        return true\n    end\n    return false\nend", "   return S:find\
    \ \"^I\"\nend", "   return S:sub(1, 1) == \"I\"\nend", "    return (string.sub(S,\
    \ 1, 1) == \"I\")\nend", "    return string.sub(S,1,1) == \"I\"\nend", "    if\
    \ S == nil then return false end\n    return string.sub(S, 1, 1) == \"I\"\nend",
  "   if S:sub(1,2) == \"I \" then\n      return true\n   else\n      return false\n\
    \   end\nend", "  if S == \"\" then return 0 end\n  local count = 0\n  local i\
    \ = 1\n  while i <= #S do\n    if (S:sub(i, i+1) == \"I \") then\n      count\
    \ = count + 1\n    end\n    i = i + 1\n  end\n  return count\nend\nassert(is_bored(\"\
    I am so bored.\") == 1)\nassert(is_bored(\"I am so bored! I am so bored.\") ==\
    \ 2)\nassert(is_bored(\"I am so bored. I am so bored!\") == 2)\nassert(is_bored(\"\
    I. am. so. bored!\") == 1)\nassert(is_bored(\"I am so bored. I am so bored! I\
    \ am so bored. I am so bored!\") == 4)\nassert(is_bored(\"Hello. World!\") ==\
    \ 0)\nassert(is_bored(\"Hello. World? I am so bored!\") == 1)\nassert(is_bored(\"\
    How? Bored! I? Am! Not!\") == 1)\nassert(is_bored(\"\") == 0)", "    -- If there\
    \ are no '.', '?' or '!', or if there is an 'I' before any\n    -- of them, then\
    \ it's a boredom.\n    local i = 1\n    while i <= S:len() do\n        if S:sub(i,\
    \ i) == 'I' then\n            return true\n        elseif S:sub(i, i) == '.' or\
    \ S:sub(i, i) == '?' or S:sub(i, i) == '!' then\n            return false\n  \
    \      end\n        i = i + 1\n    end\n    return false\nend", "    return S:find\
    \ \"^I\" ~= nil\nend", "   if string.match(S, \"^I\") then\n      return 1\n \
    \  else\n      return 0\n   end\nend", "  if string.find(S, \"I\", 1, true) ==\
    \ 1 then\n    return true\n  else\n    return false\n  end\nend", "    local parts\
    \ = strings.split(S, \"[!?.]\")\n    for i, part in ipairs(parts) do\n       \
    \ local words = strings.split(part, \" \")\n        if words[1] == \"I\" then\n\
    \            return true\n        end\n    end\n    return false\nend", "    --[[\n\
    \    if S:sub(1,2) == \"I \" then\n        return true\n    else\n        return\
    \ false\n    end\n    --]]\n    -- This can be simplified to\n    return S:sub(1,2)\
    \ == \"I \"\nend", "   return S:sub(1, 1) == \"I\"\nend", "    -- If no match,\
    \ return nil\n    local name, _ = string.match(S, \"^I am (.+)$\")\n    if name\
    \ then\n        return name\n    end\nend", "  return S:sub(1, 1) == \"I\"\nend",
  "    local s = S:find(\"I\")\n    return (s == 1)\nend", "    local f = S:find(\"\
    I\", 1, true)\n    return f == 1 and true or false\nend", "  -- \"I\" is at the\
    \ beginning of the string?\n  return string.find(S, \"^I\") ~= nil\nend", "  \
    \  local is = false\n    local function foo(w)\n        if is then\n         \
    \   is = false\n        elseif w == \"I\" then\n            is = true\n      \
    \  end\n    end\n    for w in S:gmatch(\"([^%.!?]+)\") do\n        foo(w)\n  \
    \  end\n    return is\nend", "   return string.find(S, \"^I\") ~= nil\nend", " \
    \   S = string.lower(S)\n    return not S:find(\"i am not bored\")\n        and\
    \ not S:find(\"i am not bored\")\n        and not S:find(\"i am not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n\
    \        and not S:find(\"not bored\")\n        and not S:find(\"not bored\")\n",
  "    if not S:match(\"^%s*I\") then\n        return false\n    end\n    for w in\
    \ S:gmatch(\"%S+\") do\n        if w:match(\"[.?!]\") then\n            return\
    \ true\n        end\n    end\n    return false\nend", "  return (S:match(\"I \"\
    ) ~= nil)\nend", "    local count = 0\n    local current = \"\"\n    for i = 1,\
    \ #S do\n        local c = S:sub(i, i)\n        if c == \".\" or c == \"?\" or\
    \ c == \"!\" then\n            if current:match(\"^I\") then\n               \
    \ count = count + 1\n            end\n            current = \"\"\n        else\n\
    \            current = current .. c\n        end\n    end\n    return count\n\
    end", "  return S:match('^%s*I') or false\nend", "  -- Split the sentence into\
    \ words\n  local words = string.split(S, \" \")\n  -- If the first word is \"\
    I\", it's a boredom!\n  return words[1] == \"I\"\nend", "    return string.match(S,\
    \ \"^I\")\nend", "   -- Input : the string S\n   -- Output: whether the sentence\
    \ starting at index i is a boredom\n   -- Example: is_bored(\"I am bored.\") returns\
    \ true\n   return (string.sub(S, 1, 2) == \"I \")\nend", "  return S:match('^I')\n\
    end", "  return S:match(\"^%s*I%s\")\nend", "   S = \"!\" .. S .. \"!\"\n   local\
    \ b = 0\n   for _, match in S:gmatch(\"!.-I.-[.?!]!\") do\n      b = b + 1\n \
    \  end\n   return b\nend", "  local bores = { }\n  for line in S:gmatch('[^!.?]+')\
    \ do\n    local word = line:match('(%w+)')\n    if word == 'I' then\n      bores[#bores+1]\
    \ = line\n    end\n  end\n  return bores\nend", "    if S == nil then return nil\
    \ end\n    if string.sub(S,1,1) == \"I\" then\n        return 1\n    else\n  \
    \      return 0\n    end\nend", "  local p,r=0,0\n  while true do\n    local p1,p2=string.find(S,\"\
    %?+\",p)\n    if not p1 then\n      p1,p2=string.find(S,\"%.+\",p)\n      if not\
    \ p1 then\n        p1,p2=string.find(S,\"!+\",p)\n        if not p1 then break\
    \ end\n      end\n    end\n    if string.find(string.sub(S,p,p1-1),\"^%s*I\")\
    \ then r=r+1 end\n    p=p2+1\n  end\n  return r\nend", "  return S:sub(1,1) ==\
    \ \"I\"\nend", "   return S:sub(1,1) == \"I\"\nend", "   S = S:gsub('%[.+%]',\
    \ '')  -- ignore text in [...]\n   return #S:gsub('[^Ii][^.]*%.', '')\nend", " \
    \   local start = S:find(\"^I\", 1, true)\n    if start == 1 then\n        return\
    \ true\n    end\n    return false\nend", "    return S:sub(1,1) == \"I\"\nend",
  "   return S:match(\"^I%s\") ~= nil\nend", "    local len = #S\n    if len > 0 and\
    \ S:sub(1,1) == 'I' then\n        return true\n    end\n    return false\nend",
  "  return S:match(\"^I\") and true or false\nend", "   return S:sub(1, 1) == \"\
    I\"\nend", "  -- TODO\nend", "  -- return true if a sentence is boring\n  local\
    \ S = string.lower(S)\n  return string.sub(S, 1, 1) == \"i\"\nend", "    S = string.gsub(S,\
    \ \"%s+\", \" \")\n    local _, count = string.gsub(S, \"I \", \"\")\n    return\
    \ count\nend", "  -- Complete this function.\nend", "  return S:match('^I')\n\
    end", "    return S:sub(1,1) == \"I\"\nend", "  for word in S:gmatch(\"%S+\")\
    \ do\n    if word == \"I\" then return true end\n  end\n  return false\nend",
  "  if S:find(\"I\") == 1 then\n    return true\n  else\n    return false\n  end\n\
    end", "    return S:match(\"^I\") and true or false\nend", "   return\n      (string.find(S,\
    \ \"^I\") == 1)\nend", "   if (S:find(\"^I\")) then\n      return true\n   else\n\
    \      return false\n   end\nend", "    if string.sub(S, 1, 2) == \"I \" then\n\
    \        return true\n    else\n        return false\n    end\nend", "   local\
    \ words = {}\n   string.gsub(S, \"[^%s]+\", function(x) words[#words+1] = x end)\n\
    \   if words[1] == \"I\" then\n      return 1\n   else\n      return 0\n   end\n\
    end", "  return (string.match(S, \"^I\") == \"I\")\nend", "  local count = 0\n\
    \  for m in (S..\".\"):gmatch(\"[^.!?]*[.!?]\") do\n    if m:match(\"^%s*I%s\"\
    ) then\n      count = count + 1\n    end\n  end\n  return count\nend", "  return\
    \ S:sub(1, 1) == \"I\"\nend", "    local i, p = 1, 0\n    local is_bored = false\n\
    \    repeat\n        local s, e = string.find(S, \"[.?!]\", i)\n        if s ~=\
    \ nil then\n            is_bored = string.find(string.sub(S, p, s), \"^I\") ~=\
    \ nil\n            i = e + 1\n            p = e + 2\n        end\n    until is_bored\
    \ or s == nil\n    return is_bored\nend", "  return S:match('^I')\nend", "  --\
    \ - \"I am awesome\" -> 1\n  -- - \"I am the very model of a modern major general\"\
    \ -> 2\n  -- - \"This is not a boreing sentence\" -> 0\n  -- - \"The quick brown\
    \ fox jumps over the lazy dog.\" -> 0\n  -- - \"I am. I am. I am.\" -> 3\n  local\
    \ count = 0\n  local start = 1\n  while true do\n    local i, j = string.find(S,\
    \ \"I\", start)\n    if not i then\n      break\n    end\n    local k = string.find(S,\
    \ \"[!.?]\", j + 1)\n    if not k then\n      break\n    end\n    count = count\
    \ + 1\n    start = k + 1\n  end\n  return count\nend\nassert(is_bored(\"I am awesome\"\
    ) == 1)\nassert(is_bored(\"I am the very model of a modern major general\") ==\
    \ 2)\nassert(is_bored(\"This is not a boreing sentence\") == 0)\nassert(is_bored(\"\
    The quick brown fox jumps over the lazy dog.\") == 0)\nassert(is_bored(\"I am.\
    \ I am. I am.\") == 3)", "  return string.sub(S, 1, 1) == \"I\"\nend", "   return\
    \ S:sub(1,1) == \"I\"\nend", "  if S:find(\"I \") == 1 then\n    return true\n\
    \  end\n  return false\nend", "   return (S:match(\"^I%s\"))\nend", "    return\
    \ (S:sub(1,1) == \"I\")\nend", "    -- TODO\nend\nassert( is_bored(\"I hate\"\
    ) == 1 )\nassert( is_bored(\"I like coding\") == 1 )\nassert( is_bored(\"I! hate!\
    \ coding!\") == 1 )\nassert( is_bored(\"I like to code in Lua.\") == 1 )\nassert(\
    \ is_bored(\"You like to code in Lua.\") == 0 )\nassert( is_bored(\"I like to\
    \ code in Lua. But I hate to code in Python.\") == 1 )\nassert( is_bored(\"I like\
    \ to code in Lua. But I hate to code in Python. I like to code in C.\") == 2 )\n\
    assert( is_bored(\"I like to code in Lua. But I hate to code in Python. I like\
    \ to code in C. I like to code in Java.\") == 3 )", "    if #S==0 then return\
    \ false end\n    if S[1]=='I' then return true end\n    if S[1]==' ' then return\
    \ is_bored(S:sub(2)) end\n    return false\nend", "  if S == \"I\" then\n    return\
    \ true\n  else\n    return false\n  end\nend", "    return match(S, \"^I\")\n\
    end", "   return S:sub(1, 1) == \"I\"\nend", "  local s,e = S:find(\"^I \")\n\
    \  return (s and e)\nend", "    local state = 'outside'\n    local count = 0\n\
    \    for i=1,#S do\n        local c = S:sub(i,i)\n        if state == 'outside'\
    \ then\n            if c == 'I' then\n                state = 'inside'\n     \
    \       end\n        else\n            assert(state == 'inside')\n           \
    \ if c == '.' or c == '?' or c == '!' then\n                state = 'outside'\n\
    \                count = count + 1\n            end\n        end\n    end\n  \
    \  return count\nend", "  return string.match(S, \"^I\") ~= nil\nend", "    local\
    \ is_bored = false\n    local ignore_next = false\n    local count = 0\n    for\
    \ word in S:gmatch(\"%w+\") do\n        if ignore_next then\n            ignore_next\
    \ = false\n        elseif word == \"I\" and not is_bored then\n            is_bored\
    \ = true\n        elseif word == \".\" or word == \"?\" or word == \"!\" then\n\
    \            is_bored = false\n            ignore_next = true\n        elseif\
    \ is_bored then\n            count = count + 1\n        end\n    end\n    return\
    \ count\nend", "  return string.match(S, \"^I%s\")\nend", "  return S:match \"\
    ^I\" ~= nil\nend", "   local n = 0\n   for _, w in ipairs(S:split('[!.?]')) do\n\
    \      local first = w:match('^%s*I%s')\n      if first then\n         n = n +\
    \ 1\n      end\n   end\n   return n\nend", "    return S:match(\"^%s*I\") ~= nil\n\
    end", "    local boredoms = 0\n    local n = #S\n    local i = 1\n    local state\
    \ = 0\n    while i <= n do\n        if state == 0 then\n            -- In 'word'\
    \ state.\n            if S:sub(i, i) == ' ' then\n                -- Skip spaces.\n\
    \                i = i + 1\n            elseif S:sub(i, i) == 'I' then\n     \
    \           -- Possible boredom!\n                state = 1\n                i\
    \ = i + 1\n            else\n                -- Not a boredom.\n             \
    \   state = 2\n            end\n        elseif state == 1 then\n            --\
    \ After 'I' state.\n            if S:sub(i, i) == ' ' then\n                --\
    \ Skip spaces.\n                i = i + 1\n            elseif S:sub(i, i) == '.'\
    \ or S:sub(i, i) == '?' or S:sub(i, i) == '!' then\n                -- Boredom!\n\
    \                boredoms = boredoms + 1\n                state = 0\n        \
    \        i = i + 1\n            else\n                -- Not a boredom.\n    \
    \            state = 2\n            end\n        elseif state == 2 then\n    \
    \        -- In 'word' state.\n            if S:sub(i, i) == ' ' then\n       \
    \         -- Skip spaces.\n                i = i + 1\n            elseif S:sub(i,\
    \ i) == '.' or S:sub(i, i) == '?' or S:sub(i, i) == '!' then\n               \
    \ -- Not a boredom.\n                state = 0\n                i = i + 1\n  \
    \          else\n                -- Skip this word.\n                while i <=\
    \ n and S:sub(i, i) ~= ' ' and S:sub(i, i) ~= '.' and S:sub(i, i) ~= '?' and S:sub(i,\
    \ i) ~= '!' do\n                    i = i + 1\n                end\n         \
    \   end\n        end\n    end\n    return boredoms\nend", "    local i = 1\n \
    \   while S:find(\"I\", i) ~= nil do\n        i = S:find(\"I\", i) + 1\n     \
    \   if string.find(\"!?.\", S:sub(i, i)) ~= nil then\n            return true\n\
    \        end\n    end\n    return false\nend", "    return S:match('^I ') or S:match('^I$')\n\
    end", "    S = S:lower()\n    local i = S:find(\"i\")\n    if i == 1 then\n  \
    \      return true\n    end\n    return false\nend", "  if not S:match(\"^I\"\
    ) then return false end\n  local prev = ' '\n  for i = 1, #S do\n    local c =\
    \ S:sub(i, i)\n    if prev == ' ' and (c == '.' or c == '?' or c == '!') then\n\
    \      return true\n    end\n    prev = c\n  end\n  return false\nend", "   local\
    \ first_word = S:match(\"%S+\")\n   return first_word == \"I\"\nend", "    for\
    \ i=1, #S do\n        local c = S:sub(i,i)\n        if c == 'I' then\n       \
    \     return true\n        elseif c == '.' or c == '?' or c == '!' then\n    \
    \        return false\n        end\n    end\n    return false\nend", "  if S:sub(1,1)\
    \ == \"I\" then\n    return true\n  else\n    return false\n  end\nend", "   \
    \ return string.sub(S, 1, 1) == \"I\"\nend", "    local count = 0\n    local i\
    \ = 1\n    while true do\n        local s, e = S:find(\"%bI%b\", i)\n        if\
    \ not s then break end\n        local inner = S:sub(s + 1, e - 1)\n        local\
    \ b = true\n        for word in inner:gmatch(\"%S+\") do\n            if word:sub(1,\
    \ 1) ~= \"I\" then\n                b = false\n                break\n       \
    \     end\n        end\n        if b then count = count + 1 end\n        i = e\
    \ + 1\n    end\n    return count\nend", "   return string.find(S, \"^I.*\")\n\
    end", "    return S:sub(1, 1) == \"I\"\nend", "   local dot, qm, ex, bored = 0,\
    \ 0, 0, 0\n   for x in S:gmatch(\"%S+\") do\n      if x == \"I\" then\n      \
    \   bored = bored + 1\n      elseif x == \"?\" then\n         qm = qm + 1\n  \
    \    elseif x == \"!\" then\n         ex = ex + 1\n      elseif x == \".\" then\n\
    \         dot = dot + 1\n      end\n   end\n   assert(dot == qm and dot == ex)\n\
    \   return bored\nend", "   return S:sub(1,1) == \"I\"\nend", "   return string.sub(S,1,1)\
    \ == \"I\"\nend", "    return string.sub(S,1,1) == \"I\"\nend", "    local ch\
    \ = string.sub(S, 1, 1)\n    if ch == \"I\" then\n        return true\n    else\n\
    \        return false\n    end\nend", "   return S:sub(1,2) == \"I \"\nend", " \
    \   return S:sub(1, 1) == \"I\"\nend", "  -- Split the given sentence into words.\n\
    \  local words = S:split('%s+')\n  -- The first word of a boredom is 'I'.\n  if\
    \ words[1] == 'I' then\n    -- A boredom is a sentence starting with 'I' and also\
    \ ending with '.',\n    -- '?' or '!'.\n    if S:match('^I[%w%s]+[%.%?!]$') then\n\
    \      return true\n    end\n  end\n  return false\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
