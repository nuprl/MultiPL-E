name: HumanEval_129_minPath
language: lua
prompt: "-- Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n-- each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- You have\
  \ to find the minimum path of length k in the grid. You can start\n-- from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n-- in other words,\
  \ you can go to cells which share an edge with you current\n-- cell.\n-- Please\
  \ note that a path of length k means visiting exactly k cells (not\n-- necessarily\
  \ distinct).\n-- You CANNOT go off the grid.\n-- A path A (of length k) is considered\
  \ less than a path B (of length k) if\n-- after making the ordered lists of the\
  \ values on the cells that A and B go\n-- through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n-- than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n-- such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n-- lst_A[j] = lst_B[j].\n-- It is guaranteed that the answer\
  \ is unique.\n-- Return an ordered list of the values on the cells that the minimum\
  \ path go through.\nlocal function minPath(grid, k)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = minPath\n\
  \    lu.assertEquals(candidate({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3), {1, 2, 1})\n\
  \    lu.assertEquals(candidate({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1), {1})\n   \
  \ lu.assertEquals(candidate({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14,\
  \ 15, 16}}, 4), {1, 2, 1, 2})\n    lu.assertEquals(candidate({{6, 4, 13, 10}, {5,\
  \ 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7), {1, 10, 1, 10, 1, 10, 1})\n  \
  \  lu.assertEquals(candidate({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3,\
  \ 10, 11, 16}}, 5), {1, 7, 1, 7, 1})\n    lu.assertEquals(candidate({{11, 8, 7,\
  \ 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9), {1, 6, 1, 6, 1, 6, 1,\
  \ 6, 1})\n    lu.assertEquals(candidate({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16,\
  \ 14, 4}, {11, 8, 7, 2}}, 12), {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6})\n    lu.assertEquals(candidate({{2,\
  \ 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8), {1, 3, 1, 3, 1, 3, 1, 3})\n    lu.assertEquals(candidate({{6,\
  \ 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8), {1, 5, 1, 5, 1, 5, 1, 5})\n    lu.assertEquals(candidate({{1,\
  \ 2}, {3, 4}}, 10), {1, 2, 1, 2, 1, 2, 1, 2, 1, 2})\n    lu.assertEquals(candidate({{1,\
  \ 3}, {3, 2}}, 10), {1, 3, 1, 3, 1, 3, 1, 3, 1, 3})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal function go(i, j, rest, visited, result)\n\t\tif rest == 0\
    \ then\n\t\t\tresult[#result + 1] = grid[i][j]\n\t\t\treturn result\n\t\tend\n\
    \t\tvisited[i][j] = true\n\t\tlocal lst = {[0] = result}\n\t\tif i > 1 and not\
    \ visited[i - 1][j] then\n\t\t\tlst[#lst + 1] = go(i - 1, j, rest - 1, visited,\
    \ lst[0])\n\t\tend\n\t\tif i < #grid and not visited[i + 1][j] then\n\t\t\tlst[#lst\
    \ + 1] = go(i + 1, j, rest - 1, visited, lst[0])\n\t\tend\n\t\tif j > 1 and not\
    \ visited[i][j - 1] then\n\t\t\tlst[#lst + 1] = go(i, j - 1, rest - 1, visited,\
    \ lst[0])\n\t\tend\n\t\tif j < #grid and not visited[i][j + 1] then\n\t\t\tlst[#lst\
    \ + 1] = go(i, j + 1, rest - 1, visited, lst[0])\n\t\tend\n\t\tvisited[i][j] =\
    \ false\n\t\ttable.sort(lst, function(a, b)\n\t\t\tfor i = 1, #a do\n\t\t\t\t\
    if a[i] < b[i] then\n\t\t\t\t\treturn true\n\t\t\t\telseif a[i] > b[i] then\n\t\
    \t\t\t\treturn false\n\t\t\t\tend\n\t\t\tend\n\t\t\treturn false\n\t\tend)\n\t\
    \treturn lst[1]\n\tend\n\tlocal visited = {}\n\tfor i = 1, #grid do\n\t\tvisited[i]\
    \ = {}\n\tend\n\treturn go(1, 1, k, visited, {})\nend", "  assert(#grid >= 2)\n\
    \  assert(#grid[1] == #grid)\n  assert(k >= 1)\n  assert(k <= #grid * #grid)\n\
    \  local function less(t1, t2)\n    for i = 1, #t1 do\n      if t1[i] < t2[i]\
    \ then\n        return true\n      elseif t1[i] > t2[i] then\n        return false\n\
    \      end\n    end\n    return false\n  end\n  local function solve(i, j, k,\
    \ ans)\n    if k == 0 then\n      local tmp = {grid[i][j]}\n      if not ans or\
    \ less(tmp, ans) then\n        ans = tmp\n      end\n      return ans\n    end\n\
    \    if i > 1 then\n      ans = solve(i - 1, j, k - 1, ans)\n    end\n    if i\
    \ < #grid then\n      ans = solve(i + 1, j, k - 1, ans)\n    end\n    if j > 1\
    \ then\n      ans = solve(i, j - 1, k - 1, ans)\n    end\n    if j < #grid then\n\
    \      ans = solve(i, j + 1, k - 1, ans)\n    end\n    return ans\n  end\n  local\
    \ ans\n  for i = 1, #grid do\n    for j = 1, #grid do\n      ans = solve(i, j,\
    \ k, ans)\n    end\n  end\n  return ans\nend", "  local r, c = #grid, #grid[1]\n\
    \  local tbl = {}\n  local function dfs(i, j, v)\n    if not tbl[i] then tbl[i]\
    \ = {} end\n    if tbl[i][j] then return false end\n    if i < 1 or i > r or j\
    \ < 1 or j > c then return false end\n    if k == 0 then return true end\n   \
    \ if grid[i][j] < v then return false end\n    local ret = false\n    tbl[i][j]\
    \ = true\n    if i > 1 then ret = dfs(i - 1, j, grid[i][j]) end\n    if not ret\
    \ and i < r then ret = dfs(i + 1, j, grid[i][j]) end\n    if not ret and j > 1\
    \ then ret = dfs(i, j - 1, grid[i][j]) end\n    if not ret and j < c then ret\
    \ = dfs(i, j + 1, grid[i][j]) end\n    tbl[i][j] = nil\n    if ret then ret =\
    \ {} ret[#ret + 1] = grid[i][j] end\n    return ret\n  end\n  local ans\n  for\
    \ i = 1, r do\n    for j = 1, c do\n      local ret = dfs(i, j, 0)\n      if ret\
    \ then\n        if not ans then ans = ret\n        else\n          for n = 1,\
    \ #ret do\n            if ret[n] ~= ans[n] then\n              if ret[n] < ans[n]\
    \ then ans = ret end\n              break\n            end\n          end\n  \
    \      end\n      end\n    end\n  end\n  return ans\nend", "  local function compare(a,\
    \ b)\n    for i = 1, #a do\n      if a[i] < b[i] then\n        return true\n \
    \     elseif a[i] > b[i] then\n        return false\n      end\n    end\n    return\
    \ false\n  end\n  local n = #grid\n  local visited = {}\n  local min_path = {}\n\
    \  local min_path_sum = n * n + 1\n  local function dfs(i, j, path, path_sum)\n\
    \    visited[i][j] = true\n    path[#path + 1] = grid[i][j]\n    path_sum = path_sum\
    \ + grid[i][j]\n    if #path == k then\n      if path_sum < min_path_sum then\n\
    \        min_path_sum = path_sum\n        min_path = path\n      elseif path_sum\
    \ == min_path_sum then\n        if compare(path, min_path) then\n          min_path\
    \ = path\n        end\n      end\n    else\n      for _, [dir_i, dir_j] in ipairs({{-1,\
    \ 0}, {1, 0}, {0, -1}, {0, 1}}) do\n        local next_i, next_j = i + dir_i,\
    \ j + dir_j\n        if next_i >= 1 and next_i <= n and next_j >= 1 and next_j\
    \ <= n\n           and not visited[next_i][next_j] then\n          dfs(next_i,\
    \ next_j, path, path_sum)\n        end\n      end\n    end\n    visited[i][j]\
    \ = false\n    path[#path] = nil\n  end\n  for i = 1, n do\n    visited[i] = {}\n\
    \  end\n  for i = 1, n do\n    for j = 1, n do\n      dfs(i, j, {}, 0)\n    end\n\
    \  end\n  return min_path\nend", "\tlocal n = #grid\n\tlocal dist = {}\n\tlocal\
    \ heap = {}\n\tlocal heapIdx = {}\n\tlocal function heapify(v)\n\t\tlocal idx\
    \ = heapIdx[v]\n\t\twhile true do\n\t\t\tlocal minIdx = idx\n\t\t\tlocal minVal\
    \ = heap[idx]\n\t\t\tlocal val = heap[idx * 2]\n\t\t\tif val and dist[minVal]\
    \ > dist[val] then\n\t\t\t\tminIdx = idx * 2\n\t\t\t\tminVal = val\n\t\t\tend\n\
    \t\t\tif idx * 2 + 1 <= #heap then\n\t\t\t\tval = heap[idx * 2 + 1]\n\t\t\t\t\
    if dist[minVal] > dist[val] then\n\t\t\t\t\tminIdx = idx * 2 + 1\n\t\t\t\t\tminVal\
    \ = val\n\t\t\t\tend\n\t\t\tend\n\t\t\tif minIdx == idx then\n\t\t\t\tbreak\n\t\
    \t\tend\n\t\t\theap[idx], heap[minIdx] = heap[minIdx], heap[idx]\n\t\t\theapIdx[heap[idx]]\
    \ = idx\n\t\t\theapIdx[heap[minIdx]] = minIdx\n\t\t\tidx = minIdx\n\t\tend\n\t\
    end\n\tfor i = 1, n do\n\t\tdist[i] = {}\n\t\tfor j = 1, n do\n\t\t\tdist[i][j]\
    \ = k * n * n\n\t\tend\n\tend\n\tdist[1][1] = grid[1][1]\n\tfor i = 1, n do\n\t\
    \theap[i] = {i, 1}\n\t\theapIdx[{i, 1}] = i\n\tend\n\tfor i = 1, n do\n\t\tfor\
    \ j = 2, n do\n\t\t\tdist[i][j] = dist[i][j - 1] + grid[i][j]\n\t\t\theap[(i -\
    \ 1) * n + j] = {i, j}\n\t\t\theap", "  local n = #grid\n  local S = {}\n  local\
    \ Q = {}\n  local q = {}\n  local function key(v)\n    return (v[1] - 1) * n +\
    \ v[2]\n  end\n  for i = 1, n do\n    for j = 1, n do\n      Q[key{i, j}] = true\n\
    \    end\n  end\n  local function neighbors(v)\n    local x, y = v[1], v[2]\n\
    \    local list = {}\n    if x > 1 then\n      list[#list + 1] = {x - 1, y}\n\
    \    end\n    if x < n then\n      list[#list + 1] = {x + 1, y}\n    end\n   \
    \ if y > 1 then\n      list[#list + 1] = {x, y - 1}\n    end\n    if y < n then\n\
    \      list[#list + 1] = {x, y + 1}\n    end\n    return list\n  end\n  local\
    \ function update(v, d)\n    local s = S[key(v)]\n    if s == nil or d < s then\n\
    \      s = d\n      S[key(v)] = s\n      local list = neighbors(v)\n      for\
    \ _, u in ipairs(list) do\n        if Q[key(u)] then\n          q[#q + 1] = u\n\
    \          Q[key(u)] = false\n        end\n      end\n    end\n  end\n  for i\
    \ = 1, n do\n    for j = 1, n do\n      local v = {i, j}\n      update(v, 0)\n\
    \      while #q > 0 do\n        local u = q[1]\n        q[1] = q[#q]\n       \
    \ q[#q] = nil\n        local d = S[key(u)] + 1\n        if d < k then\n      \
    \    update(u, d)\n        end\n      end\n    end\n  end\n  local m = math.maxinteger\n\
    \  local v\n  for i = 1, n do\n    for j = 1, n do\n      local d = S[key{i, j}]\n\
    \      if d ~=", "  -- TODO: Implement.\nend", "\t-- body\nend", "  local row_count\
    \ = #grid\n  local col_count = #grid[1]\n  local function explore(row, col, path,\
    \ cost)\n    local path = path or {}\n    local cost = cost or 0\n    local row_cost\
    \ = cost + math.abs(grid[row][col] - grid[row][col - 1])\n    local col_cost =\
    \ cost + math.abs(grid[row][col] - grid[row - 1][col])\n    table.insert(path,\
    \ grid[row][col])\n    local new_row = row + 1\n    local new_col = col + 1\n\
    \    if (row == row_count) then\n      for i = 1, k - row_count do\n        table.insert(path,\
    \ grid[row][new_col])\n        new_col = new_col + 1\n      end\n      return\
    \ path\n    end\n    if (col == col_count) then\n      for i = 1, k - col_count\
    \ do\n        table.insert(path, grid[new_row][col])\n        new_row = new_row\
    \ + 1\n      end\n      return path\n    end\n    local path1, path2\n    if (row_cost\
    \ <= col_cost) then\n      path1 = explore(row, new_col, path, row_cost)\n   \
    \ end\n    if (col_cost <= row_cost) then\n      path2 = explore(new_row, col,\
    \ path, col_cost)\n    end\n    if (path1 and path2) then\n      local less =\
    \ {}\n      for i = 1, k do\n        if (path1[i] < path2[i]) then\n         \
    \ less = path1\n          break\n        elseif (path1[i] > path2[i]) then\n \
    \         less = path2\n          break\n        end\n      end\n      return\
    \ less\n    elseif (path1) then\n      return path1\n    elseif (path2) then\n\
    \      return path2\n    end\n  end\n  for row = 1, row_count do\n    for col\
    \ = 1, col_count do\n      return explore(row, col)\n    end\n  end\nend", " \
    \ local function less_than(a, b)\n    for i = 1, k do\n      if a[i] < b[i] then\n\
    \        return true\n      elseif a[i] > b[i] then\n        return false\n  \
    \    end\n    end\n    return false\n  end\n  local n = #grid\n  local res = {}\n\
    \  for i = 1, k do\n    res[i] = grid[1][1]\n  end\n  local dx = {0, 1, 0, -1}\n\
    \  local dy = {1, 0, -1, 0}\n  local function dfs(x, y, cur_len, cur_path)\n \
    \   if cur_len == k then\n      if less_than(cur_path, res) then\n        res\
    \ = cur_path\n      end\n      return\n    end\n    for i = 1, 4 do\n      local\
    \ new_x = x + dx[i]\n      local new_y = y + dy[i]\n      if new_x >= 1 and new_x\
    \ <= n and new_y >= 1 and new_y <= n then\n        cur_path[cur_len + 1] = grid[new_x][new_y]\n\
    \        dfs(new_x, new_y, cur_len + 1, cur_path)\n      end\n    end\n  end\n\
    \  dfs(1, 1, 1, {grid[1][1]})\n  return res\nend", "  local w, h = #grid[1], #grid\n\
    \  local memo = {}\n  local function dfs(i, j, cnt, cur)\n    if cnt == k then\n\
    \      return cur\n    end\n    if not memo[i] then\n      memo[i] = {}\n    end\n\
    \    if memo[i][j] then\n      return\n    end\n    memo[i][j] = true\n    cur[#cur\
    \ + 1] = grid[i][j]\n    local t = {}\n    if i > 1 then\n      t[#t + 1] = dfs(i\
    \ - 1, j, cnt + 1, cur)\n    end\n    if i < h then\n      t[#t + 1] = dfs(i +\
    \ 1, j, cnt + 1, cur)\n    end\n    if j > 1 then\n      t[#t + 1] = dfs(i, j\
    \ - 1, cnt + 1, cur)\n    end\n    if j < w then\n      t[#t + 1] = dfs(i, j +\
    \ 1, cnt + 1, cur)\n    end\n    local min_path = nil\n    for _, path in ipairs(t)\
    \ do\n      if not min_path or compare(path, min_path) < 0 then\n        min_path\
    \ = path\n      end\n    end\n    memo[i][j] = nil\n    cur[#cur] = nil\n    return\
    \ min_path\n  end\n  local min_path = nil\n  for i = 1, h do\n    for j = 1, w\
    \ do\n      local path = dfs(i, j, 1, {})\n      if not min_path or compare(path,\
    \ min_path) < 0 then\n        min_path = path\n      end\n    end\n  end\n  return\
    \ min_path\nend", "    local N = #grid\n    assert(k >= 2 and k <= N * N)\n  \
    \  local function minPathAux(grid, k, i, j, m, vis)\n        if k == 1 then\n\
    \            local old = m[{i, j}]\n            m[{i, j}] = math.min(m[{i, j}],\
    \ grid[i][j])\n            return old ~= m[{i, j}]\n        end\n        if vis[{i,\
    \ j}] == 1 then\n            return false\n        end\n        local old = m[{i,\
    \ j}]\n        m[{i, j}] = math.min(m[{i, j}], grid[i][j])\n        vis[{i, j}]\
    \ = 1\n        local updated = false\n        if i > 1 then\n            updated\
    \ = minPathAux(grid, k - 1, i - 1, j, m, vis) or updated\n        end\n      \
    \  if i < N then\n            updated = minPathAux(grid, k - 1, i + 1, j, m, vis)\
    \ or updated\n        end\n        if j > 1 then\n            updated = minPathAux(grid,\
    \ k - 1, i, j - 1, m, vis) or updated\n        end\n        if j < N then\n  \
    \          updated = minPathAux(grid, k - 1, i, j + 1, m, vis) or updated\n  \
    \      end\n        if updated then\n            m[{i, j}] = math.min(m[{i, j}],\
    \ grid[i][j])\n        end\n        vis[{i, j}] = 0\n        return old ~= m[{i,\
    \ j}]\n    end\n    local m = torch.ones(N, N) * math.huge\n    local vis = torch.zeros(N,\
    \ N)\n    for i = 1, N do\n        for j = 1, N do\n            minPathAux(grid,\
    \ k, i, j, m, vis)\n        end\n    end\n    local vals = {}\n    for i = 1,\
    \ N do\n        for j = 1, N do\n            vals[#vals + 1]", "    local n =\
    \ #grid\n    assert(n >= 2 and k > 0 and k <= n * n)\n    local visited = {}\n\
    \    for i = 1, n do\n        local row = {}\n        for j = 1, n do\n      \
    \      row[j] = false\n        end\n        visited[i] = row\n    end\n    local\
    \ function find_min_path(i, j, k, path)\n        if k == 0 then\n            return\
    \ path\n        end\n        local min_path\n        if i > 1 and not visited[i\
    \ - 1][j] then\n            visited[i - 1][j] = true\n            local new_path\
    \ = find_min_path(i - 1, j, k - 1, path .. grid[i - 1][j])\n            if not\
    \ min_path or new_path < min_path then\n                min_path = new_path\n\
    \            end\n            visited[i - 1][j] = false\n        end\n       \
    \ if i < n and not visited[i + 1][j] then\n            visited[i + 1][j] = true\n\
    \            local new_path = find_min_path(i + 1, j, k - 1, path .. grid[i +\
    \ 1][j])\n            if not min_path or new_path < min_path then\n          \
    \      min_path = new_path\n            end\n            visited[i + 1][j] = false\n\
    \        end\n        if j > 1 and not visited[i][j - 1] then\n            visited[i][j\
    \ - 1] = true\n            local new_path = find_min_path(i, j - 1, k - 1, path\
    \ .. grid[i][j - 1])\n            if not min_path or new_path < min_path then\n\
    \                min_path = new_path\n            end\n            visited[i][j\
    \ - 1] = false\n        end\n        if j < n and not visited[i][j + 1] then\n\
    \            visited[i][j + 1] = true\n            local new_path = find_min_path(i,\
    \ j + 1, k - 1, path .. grid[i][j + 1])\n            if not min_path or new_path\
    \ < min_path then\n                min_", "    if not grid or #grid == 0 or #grid[1]\
    \ == 0 or k <= 0 then\n        return {}\n    end\n    local n = #grid\n    local\
    \ m = #grid[1]\n    if n == 1 then\n        return grid[1]\n    end\n    local\
    \ t = {}\n    for i = 1, n do\n        t[i] = {}\n        for j = 1, m do\n  \
    \          t[i][j] = {grid[i][j]}\n        end\n    end\n    for l = 2, k do\n\
    \        local tt = {}\n        for i = 1, n do\n            tt[i] = {}\n    \
    \        for j = 1, m do\n                local c = grid[i][j]\n             \
    \   local min = {c}\n                local min_v = c\n                local res\
    \ = false\n                if i > 1 then\n                    if t[i - 1][j][1]\
    \ < min_v then\n                        min = {t[i - 1][j][1], c}\n          \
    \              min_v = t[i - 1][j][1]\n                        res = true\n  \
    \                  elseif t[i - 1][j][1] == min_v then\n                     \
    \   local tt = table.copy(t[i - 1][j])\n                        table.insert(tt,\
    \ c)\n                        if tt < min then\n                            min\
    \ = tt\n                            res = true\n                        end\n\
    \                    end\n                end\n                if j > 1 then\n\
    \                    if t[i][j - 1][1] < min_v then\n                        min\
    \ = {t[i][j - 1][1], c}\n                        min_v = t[i][j - 1][1]\n    \
    \                    res = true\n                    elseif t[i][j - 1][1] ==\
    \ min_v then\n                        local tt = table.copy(t[i][j - 1])\n   \
    \                     table.insert(tt, c)\n                        if tt < min\
    \ then\n                            min = tt\n                            res\
    \ = true\n                        end\n                    end\n             \
    \   end\n                if i < n then\n                    if t[i + 1][j][1]\
    \ < min_v then\n                        min = {t[i + 1][j][", "\tlocal n = #grid\n\
    \tlocal min_val = {[0] = {[0] = 0}}\n\tlocal min_path = {[0] = {[0] = {{x = 1,\
    \ y = 1}}}}\n\tfor i = 1, k do\n\t\tmin_val[i] = {}\n\t\tmin_path[i] = {}\n\t\t\
    for j = 1, n do\n\t\t\tmin_val[i][j] = {}\n\t\t\tmin_path[i][j] = {}\n\t\t\tfor\
    \ l = 1, n do\n\t\t\t\tmin_val[i][j][l] = math.huge\n\t\t\t\tmin_path[i][j][l]\
    \ = {}\n\t\t\tend\n\t\tend\n\tend\n\tfor i = 1, k do\n\t\tfor j = 1, n do\n\t\t\
    \tfor l = 1, n do\n\t\t\t\tfor x = -1, 1 do\n\t\t\t\t\tfor y = -1, 1 do\n\t\t\t\
    \t\t\tif i == 1 and x ~= 0 and y ~= 0 then\n\t\t\t\t\t\t\tgoto continue\n\t\t\t\
    \t\t\tend\n\t\t\t\t\t\tlocal ii = i - 1\n\t\t\t\t\t\tlocal jj = j + x\n\t\t\t\t\
    \t\tlocal ll = l + y\n\t\t\t\t\t\tif ii >= 0 and jj >= 1 and jj <= n and ll >=\
    \ 1 and ll <= n then\n\t\t\t\t\t\t\tlocal new_val = min_val[ii][jj][ll] + grid[j][l]\n\
    \t\t\t\t\t\t\tif new_val < min_val[i][j][l] then\n\t\t\t\t\t\t\t\tmin_val[i][j][l]\
    \ = new_val\n\t\t\t\t\t\t\t\tmin_path[i][j][l] = {}\n\t\t\t\t\t\t\t\tfor _, p\
    \ in ipairs(min_path[ii][jj][ll]) do\n\t\t\t\t\t\t\t\t\ttable.insert(min_path[i][j][l],\
    \ p)\n\t\t\t\t\t\t\t\tend\n", "  -- Write your code here\nend", "    local n =\
    \ #grid\n    local best, best_sum, best_sum_lst = math.huge, math.huge, {}\n \
    \   local get_neighbors, get_sum, get_sum_lst, dfs\n    get_neighbors = function(x,\
    \ y)\n        local res = {}\n        if x - 1 >= 1 then table.insert(res, {x\
    \ - 1, y}) end\n        if x + 1 <= n then table.insert(res, {x + 1, y}) end\n\
    \        if y - 1 >= 1 then table.insert(res, {x, y - 1}) end\n        if y +\
    \ 1 <= n then table.insert(res, {x, y + 1}) end\n        return res\n    end\n\
    \    get_sum = function(lst)\n        local sum = 0\n        for _, v in ipairs(lst)\
    \ do\n            sum = sum + v\n        end\n        return sum\n    end\n  \
    \  get_sum_lst = function(nodes)\n        local res = {}\n        for _, node\
    \ in ipairs(nodes) do\n            table.insert(res, grid[node[1]][node[2]])\n\
    \        end\n        return res\n    end\n    dfs = function(node, path)\n  \
    \      local path_lst = get_sum_lst(path)\n        local path_sum = get_sum(path_lst)\n\
    \        local node_x, node_y = node[1], node[2]\n        if path_sum < best_sum\
    \ then\n            best_sum = path_sum\n            best_sum_lst = path_lst\n\
    \        elseif path_sum == best_sum then\n            local path_lst_str = table.concat(path_lst,\
    \ ',')\n            local best_sum_lst_str = table.concat(best_sum_lst, ',')\n\
    \            if path_lst_str < best_sum_lst_str then\n                best_sum_lst\
    \ = path_lst\n            end\n        end\n        if #path == k then return\
    \ end\n        for _, nb in ipairs(get_neighbors(node_x,", "  local n = #grid\n\
    \  local dp = {}\n  for i = 1, n do\n    dp[i] = {}\n    for j = 1, n do\n   \
    \   dp[i][j] = {}\n    end\n  end\n  local function cost(path)\n    local res\
    \ = 0\n    for i = 1, n do\n      for j = 1, n do\n        if path[i][j] then\n\
    \          res = res + 1\n        end\n      end\n    end\n    return res\n  end\n\
    \  local function minPath(i, j, path)\n    if path[i][j] then\n      return path[i][j]\n\
    \    end\n    local res = {}\n    if i > 1 then\n      local path1 = minPath(i\
    \ - 1, j, path)\n      if cost(path1) < cost(res) then\n        res = path1\n\
    \      end\n    end\n    if i < n then\n      local path2 = minPath(i + 1, j,\
    \ path)\n      if cost(path2) < cost(res) then\n        res = path2\n      end\n\
    \    end\n    if j > 1 then\n      local path3 = minPath(i, j - 1, path)\n   \
    \   if cost(path3) < cost(res) then\n        res = path3\n      end\n    end\n\
    \    if j < n then\n      local path4 = minPath(i, j + 1, path)\n      if cost(path4)\
    \ < cost(res) then\n        res = path4\n      end\n    end\n    local path5 =\
    \ {}\n    for i = 1, n do\n      path5[i] = {}\n      for j = 1, n do\n      \
    \  path5[i][j] = res[i][j]\n      end\n    end\n    path5[i][j] = true\n    return\
    \ path5\n  end\n  local function lt(path1, path2)\n    for i = 1, n do\n     \
    \ for j = 1, n do\n        if path1[i][j] ~= path2[i][j] then\n          return\
    \ path1[i][j]\n        end\n      end\n    end\n    return", "    error('Not Implemented')\n\
    end", "  local n = #grid\n  local lookup = {}\n  local function dfs(i, j, k, path)\n\
    \    if k == 0 then\n      lookup[path] = true\n      return\n    end\n    if\
    \ i > 1 then\n      dfs(i - 1, j, k - 1, string.format('%s,%d', path, grid[i -\
    \ 1][j]))\n    end\n    if i < n then\n      dfs(i + 1, j, k - 1, string.format('%s,%d',\
    \ path, grid[i + 1][j]))\n    end\n    if j > 1 then\n      dfs(i, j - 1, k -\
    \ 1, string.format('%s,%d', path, grid[i][j - 1]))\n    end\n    if j < n then\n\
    \      dfs(i, j + 1, k - 1, string.format('%s,%d', path, grid[i][j + 1]))\n  \
    \  end\n  end\n  for i = 1, n do\n    for j = 1, n do\n      dfs(i, j, k, tostring(grid[i][j]))\n\
    \    end\n  end\n  local min_k = nil\n  for k, _ in pairs(lookup) do\n    if not\
    \ min_k or k < min_k then\n      min_k = k\n    end\n  end\n  return min_k:split(',')\n\
    end", "    local function helper(grid, k, i, j, acc, memo)\n        local acc\
    \ = acc .. ' ' .. grid[i][j]\n        local key = acc\n        if i > 1 then\n\
    \            key = key .. ' ' .. (i - 1) .. ' ' .. j\n        end\n        if\
    \ i < #grid then\n            key = key .. ' ' .. (i + 1) .. ' ' .. j\n      \
    \  end\n        if j > 1 then\n            key = key .. ' ' .. i .. ' ' .. (j\
    \ - 1)\n        end\n        if j < #grid then\n            key = key .. ' ' ..\
    \ i .. ' ' .. (j + 1)\n        end\n        if memo[key] then\n            return\
    \ memo[key]\n        end\n        if #acc >= k then\n            memo[key] = acc\n\
    \            return acc\n        end\n        local arr = {}\n        if i > 1\
    \ then\n            arr[#arr + 1] = helper(grid, k, i - 1, j, acc, memo)\n   \
    \     end\n        if i < #grid then\n            arr[#arr + 1] = helper(grid,\
    \ k, i + 1, j, acc, memo)\n        end\n        if j > 1 then\n            arr[#arr\
    \ + 1] = helper(grid, k, i, j - 1, acc, memo)\n        end\n        if j < #grid\
    \ then\n            arr[#arr + 1] = helper(grid, k, i, j + 1, acc, memo)\n   \
    \     end\n        table.sort(arr)\n        memo[key] = arr[1]\n        return\
    \ arr[1]\n    end\n    local res = {}\n    for i = 1, #grid do\n        for j\
    \ = 1, #grid do\n            res[#res + 1] = helper(grid, k, i, j, '', {})\n \
    \       end\n    end\n    table.sort(res)\n    return res[1]\nend", "  local dp\
    \ = {}\n  local function dfs(r, c, k)\n    if r < 1 or r > #grid or c < 1 or c\
    \ > #grid[1] then\n      return nil\n    end\n    if k == 0 then\n      return\
    \ {grid[r][c]}\n    end\n    local key = r * #grid[1] + c .. \"_\" .. k\n    if\
    \ dp[key] then\n      return dp[key]\n    end\n    local paths = {}\n    for _,\
    \ d in ipairs({\n      {-1, 0},\n      {1, 0},\n      {0, -1},\n      {0, 1},\n\
    \    }) do\n      local path = dfs(r + d[1], c + d[2], k - 1)\n      if path then\n\
    \        table.insert(path, grid[r][c])\n        paths[#paths + 1] = path\n  \
    \    end\n    end\n    if not next(paths) then\n      return nil\n    end\n  \
    \  table.sort(paths, function(a, b)\n      for i = 1, k + 1 do\n        if a[i]\
    \ ~= b[i] then\n          return a[i] < b[i]\n        end\n      end\n      return\
    \ false\n    end)\n    return dp[key] or paths[1]\n  end\n  for i = 1, #grid do\n\
    \    for j = 1, #grid[1] do\n      local path = dfs(i, j, k)\n      if path then\n\
    \        return path\n      end\n    end\n  end\nend", "    local ans = {}\n \
    \   local graph = {}\n    local edges = {}\n    local function dfs(path, visit,\
    \ cur, remain)\n        if remain == 0 then\n            if ans[1] == nil or ans[1]\
    \ > path[1] then\n                ans = path\n            end\n            return\n\
    \        end\n        local arr = graph[cur]\n        for _, v in ipairs(arr)\
    \ do\n            if visit[v] == nil then\n                visit[v] = true\n \
    \               path[#path + 1] = grid[v[1]][v[2]]\n                dfs(path,\
    \ visit, v, remain - 1)\n                visit[v] = nil\n                path[#path]\
    \ = nil\n            end\n        end\n    end\n    for i = 1, #grid do\n    \
    \    for j = 1, #grid[i] do\n            local v = {i, j}\n            local adj\
    \ = {}\n            if i + 1 <= #grid then\n                adj[#adj + 1] = {i\
    \ + 1, j}\n            end\n            if i - 1 >= 1 then\n                adj[#adj\
    \ + 1] = {i - 1, j}\n            end\n            if j + 1 <= #grid[i] then\n\
    \                adj[#adj + 1] = {i, j + 1}\n            end\n            if j\
    \ - 1 >= 1 then\n                adj[#adj + 1] = {i, j - 1}\n            end\n\
    \            graph[v] = adj\n            edges[#edges + 1] = v\n        end\n\
    \    end\n    for _, v in ipairs(edges) do\n        dfs({grid[v[1]][v[2]]}, {v},\
    \ v, k - 1)\n    end\n    return ans\nend", "    local n = #grid\n    local dp\
    \ = {}\n    for i = 1, n do\n        dp[i] = {}\n        for j = 1, n do\n   \
    \         dp[i][j] = {}\n        end\n    end\n    for i = 1, n do\n        for\
    \ j = 1, n do\n            if i == 1 and j == 1 then\n                dp[i][j][0]\
    \ = grid[i][j]\n            else\n                local prev_val = 0\n       \
    \         if i > 1 then\n                    prev_val = math.max(prev_val, dp[i\
    \ - 1][j][k - 1])\n                end\n                if j > 1 then\n      \
    \              prev_val = math.max(prev_val, dp[i][j - 1][k - 1])\n          \
    \      end\n                dp[i][j][k] = prev_val + grid[i][j]\n            end\n\
    \        end\n    end\n    local res = {}\n    local i, j = n, n\n    for _ =\
    \ 1, k do\n        res[#res + 1] = grid[i][j]\n        if dp[i - 1][j][k - 1]\
    \ > dp[i][j - 1][k - 1] then\n            i = i - 1\n        else\n          \
    \  j = j - 1\n        end\n    end\n    return res\nend", "  local n = #grid\n\
    \  assert(n >= 2 and n <= 1000)\n  for i = 1, n do\n    assert(#grid[i] == n)\n\
    \    for j = 1, n do\n      assert(grid[i][j] >= 1 and grid[i][j] <= n * n)\n\
    \    end\n  end\n  assert(k >= 1 and k <= n * n)\n  -- NOTE:\n  --   The return\
    \ value must be an array of the values of the cells that the\n  --   minimum path\
    \ go through.\n  --   Therefore, if the return value is {4, 4, 4, 4}, it means\
    \ that the\n  --   minimum path goes through the same cell 4 times (which is obviously\
    \ not\n  --   possible). \n  return {}\nend", "    local n = #grid\n    local\
    \ low, high = 1, math.huge\n    local open = {}\n    local closed = {}\n    local\
    \ function h(v)\n        local r, c = v / n, v % n\n        return math.abs(r\
    \ - 1) + math.abs(c - 1)\n    end\n    local function g(v)\n        local r, c\
    \ = v / n, v % n\n        return math.abs(r - 1) + math.abs(c - 1)\n    end\n\
    \    local function f(v)\n        return g(v) + h(v)\n    end\n    local function\
    \ key(v)\n        return f(v)\n    end\n    local function neighbours(v)\n   \
    \     local r, c = v / n, v % n\n        local res = {}\n        local dir = {\
    \ {-1, 0}, {1, 0}, {0, -1}, {0, 1} }\n        for _, v in ipairs(dir) do\n   \
    \         local rr, cc = r + v[1], c + v[2]\n            if rr > 0 and rr <= n\
    \ and cc > 0 and cc <= n then\n                table.insert(res, rr * n + cc)\n\
    \            end\n        end\n        return res\n    end\n    local function\
    \ addToOpen(v)\n        local k = key(v)\n        open[k] = open[k] or {}\n  \
    \      local found = false\n        for _, vv in ipairs(open[k]) do\n        \
    \    if vv == v then\n                found = true\n                break\n  \
    \          end\n        end\n        if not found then\n            table.insert(open[k],\
    \ v)\n        end\n    end\n    local function removeFromOpen(v)\n        local\
    \ k = key(v)\n        local res = nil\n        for i, vv in ipairs(open[k]) do\n\
    \            if vv == v then\n                res = table.remove(open[k], i)\n\
    \                break\n            end\n        end\n        return res\n   \
    \ end\n    local function addToClosed(v)\n        closed[v] = true\n    end\n\
    \    local function removeFromClosed(v", "  local N = #grid\n  local function\
    \ compare(a, b)\n    for i = 1, #a do\n      if a[i] < b[i] then\n        return\
    \ true\n      elseif a[i] > b[i] then\n        return false\n      end\n    end\n\
    \    return false\n  end\n  local heap = Heap.new(compare)\n  local visited =\
    \ {}\n  local dx = {0, 1, 0, -1}\n  local dy = {1, 0, -1, 0}\n  local function\
    \ push(x, y, lst)\n    local mask = (x * N + y) * N + 1\n    if not visited[mask]\
    \ then\n      visited[mask] = true\n      Heap.push(heap, {x, y, lst})\n    end\n\
    \  end\n  push(0, 0, {grid[1][1]})\n  while not Heap.empty(heap) do\n    local\
    \ v = Heap.pop(heap)\n    local x, y, lst = v[1], v[2], v[3]\n    if #lst == k\
    \ then\n      return lst\n    end\n    for i = 1, 4 do\n      local nx, ny = x\
    \ + dx[i], y + dy[i]\n      if nx >= 1 and nx <= N and ny >= 1 and ny <= N then\n\
    \        push(nx, ny, {table.unpack(lst), grid[nx][ny]})\n      end\n    end\n\
    \  end\nend", end, "    error \"TODO\"\nend", "    assert(#grid > 0)\n    local\
    \ n = #grid\n    local mask = grid.mask\n    local function valid(r, c)\n    \
    \    return 0 <= r and r < n and 0 <= c and c < n and mask[r][c]\n    end\n  \
    \  local function path(r, c, k)\n        if k == 0 then\n            return {{}}\n\
    \        end\n        local res = {}\n        for _, offset in ipairs({{-1, 0},\
    \ {1, 0}, {0, -1}, {0, 1}}) do\n            local r1, c1 = r + offset[1], c +\
    \ offset[2]\n            if valid(r1, c1) then\n                for _, path1 in\
    \ ipairs(path(r1, c1, k - 1)) do\n                    res[#res + 1] = {grid[r][c]}\n\
    \                    for _, val in ipairs(path1) do\n                        res[#res][#res[#res]\
    \ + 1] = val\n                    end\n                end\n            end\n\
    \        end\n        return res\n    end\n    local paths = {}\n    for r = 0,\
    \ n - 1 do\n        for c = 0, n - 1 do\n            if valid(r, c) then\n   \
    \             for _, path in ipairs(path(r, c, k - 1)) do\n                  \
    \  paths[#paths + 1] = {grid[r][c]}\n                    for _, val in ipairs(path)\
    \ do\n                        paths[#paths][#paths[#paths] + 1] = val\n      \
    \              end\n                end\n            end\n        end\n    end\n\
    \    table.sort(paths, function(a, b)\n        for i = 1, k do\n            if\
    \ a[i] < b[i] then\n                return true\n            elseif a[i] > b[i]\
    \ then\n                return false\n            end\n        end\n        return\
    \ false\n    end)\n    return paths[1]\nend", "\tlocal N = #grid\n\tlocal function\
    \ getNeighbors(x, y)\n\t\tlocal result = {}\n\t\tif x > 1 then\n\t\t\ttable.insert(result,\
    \ { x - 1, y })\n\t\tend\n\t\tif x < N then\n\t\t\ttable.insert(result, { x +\
    \ 1, y })\n\t\tend\n\t\tif y > 1 then\n\t\t\ttable.insert(result, { x, y - 1 })\n\
    \t\tend\n\t\tif y < N then\n\t\t\ttable.insert(result, { x, y + 1 })\n\t\tend\n\
    \t\treturn result\n\tend\n\tlocal function getValue(x, y)\n\t\treturn grid[x][y]\n\
    \tend\n\tlocal dp = {}\n\tfor x = 1, N do\n\t\tdp[x] = {}\n\t\tfor y = 1, N do\n\
    \t\t\tdp[x][y] = { grid[x][y] }\n\t\tend\n\tend\n\tfor i = 2, k do\n\t\tlocal\
    \ nextDp = {}\n\t\tfor x = 1, N do\n\t\t\tnextDp[x] = {}\n\t\t\tfor y = 1, N do\n\
    \t\t\t\tlocal neighbors = getNeighbors(x, y)\n\t\t\t\tlocal curr = { getValue(x,\
    \ y) }\n\t\t\t\tlocal minCandidate = curr\n\t\t\t\tfor _, n in ipairs(neighbors)\
    \ do\n\t\t\t\t\tlocal candidate = dp[n[1]][n[2]]\n\t\t\t\t\ttable.insert(candidate,\
    \ getValue(x, y))\n\t\t\t\t\tif #candidate <= i then\n\t\t\t\t\t\tlocal j = 1\n\
    \t\t\t\t\t\twhile j <= i and candidate[j] == minCandidate[j] do\n\t\t\t\t\t\t\t\
    j = j + 1\n\t\t\t\t\t\tend\n\t\t\t\t\t\tif j > i or candidate[j] < minCandidate[j]\
    \ then\n\t\t\t\t\t\t\tminCandidate = candidate\n\t\t\t\t\t\tend\n\t\t\t\t\tend",
  "    local N = #grid\n    local kth_path = {}\n    -- The following is only intended\
    \ for testing purposes.\n    -- These are the test cases. Please do not edit the\
    \ test cases.\n    assert(k > 0)\n    assert(N > 1)\n    for i = 1, N do\n   \
    \     for j = 1, N do\n            assert(grid[i][j] > 0)\n            assert(grid[i][j]\
    \ <= N * N)\n        end\n    end\n    -- Please write the solution in the space\
    \ below.\n    -- Please note that the input is passed in the parameter named grid.\n\
    \    -- Also, you CANNOT change the grid, otherwise the test cases WILL fail.\n\
    \    -- Please, DO NOT use global variables.\n    -- Please read the comments\
    \ above.\n    -- Your solution must be in this file and you have to submit this\
    \ file only.\n    -- Good luck!\n    --[[\n    grid = {\n        {1, 10, 13, 14},\n\
    \        {6, 2, 9, 15},\n        {5, 7, 3, 12},\n        {4, 8, 11, 16}\n    }\n\
    \    k = 7\n    --]]\n    --\n    -- DO NOT CHANGE THE CODE ABOVE THIS LINE\n\
    \    --", "    -- Write your code here\n    print(k)\n    return {}\nend", " \
    \ return {}\nend", "    local N = #grid\n    local p = {1, 2, 3, 4}\n    for i\
    \ = 1, k do\n        local pq = {}\n        for _, dir in ipairs(p) do\n     \
    \       local x, y = p[dir]\n            local nx, ny = x + dx[dir], y + dy[dir]\n\
    \            if nx > 0 and nx <= N and ny > 0 and ny <= N then\n             \
    \   tinsert(pq, {dir, nx, ny})\n            end\n        end\n        sort(pq,\
    \ function(a, b)\n            return grid[a[2]][a[3]] < grid[b[2]][b[3]]\n   \
    \     end)\n        p = {unpack(pq[1])}\n    end\n    return p\nend", "    --\
    \ Write your code here\n    -- paramter grid is a table of size N * N\n    --\
    \ parameter k is a positive integer\n    -- return an ordered list of the values\n\
    end", "  --return {1, 2, 3, 4, 5, 6, 7, 8, 9}\n  local n = #grid\n  local dist\
    \ = {[0] = {[0] = 0}}\n  local dp = {}\n  for i = 1, n do\n    dist[i] = {[0]\
    \ = 0}\n    dp[i] = {}\n    for j = 1, n do\n      dist[i][j] = math.min(dist[i\
    \ - 1][j], dist[i][j - 1]) + grid[i][j]\n      dp[i][j] = {}\n    end\n  end\n\
    \  local cost = dist[n][n]\n  if cost > k then\n    return {}\n  end\n  local\
    \ path = {}\n  local append = table.insert\n  local go = function(grid, k, i,\
    \ j, out)\n    if i > n or j > n then\n      return\n    end\n    if k > 0 then\n\
    \      if i > 0 and j > 0 then\n        if dist[i - 1][j] < dist[i][j - 1] then\n\
    \          go(grid, k - 1, i - 1, j, out)\n        else\n          go(grid, k\
    \ - 1, i, j - 1, out)\n        end\n      elseif i > 0 then\n        go(grid,\
    \ k - 1, i - 1, j, out)\n      elseif j > 0 then\n        go(grid, k - 1, i, j\
    \ - 1, out)\n      end\n    end\n    append(out, grid[i][j])\n  end\n  go(grid,\
    \ k, n, n, path)\n  return path\nend", "    if k < 2 then\n        return grid[1][1]\n\
    \    end\n    local n = #grid\n    local M = n * n\n    local dp = {}\n    for\
    \ i = 1, M do\n        dp[i] = math.huge\n    end\n    local prev = {}\n    local\
    \ start = 1\n    while start <= M do\n        local min_val = math.huge\n    \
    \    local min_ind = -1\n        for i = 1, M do\n            if grid[i] < min_val\
    \ then\n                min_val = grid[i]\n                min_ind = i\n     \
    \       end\n        end\n        grid[min_ind] = math.huge\n        for i = start,\
    \ start + n - 1 do\n            if i <= M then\n                local x = min_ind\n\
    \                local y = i\n                if min_ind < i then\n          \
    \          x = i\n                    y = min_ind\n                end\n     \
    \           local val = math.min(dp[y], dp[x]) + 1\n                if dp[i] >\
    \ val then\n                    dp[i] = val\n                    prev[i] = x\n\
    \                end\n            end\n        end\n        start = start + n\n\
    \    end\n    local result = {}\n    local path = {}\n    local r = k\n    while\
    \ r > 0 do\n        local x = r\n        local y = prev[r]\n        if y < r then\n\
    \            x = prev[r]\n            y = r\n        end\n        result[#result\
    \ + 1] = math.min(x, y)\n        path[#path + 1] = math.max(x, y)\n        r =\
    \ r - dp[r]\n    end\n    local ind = 0\n    for i = #path, 1, -1 do\n       \
    \ ind = ind + 1\n        result[ind] = path[i]\n    end\n    return result\nend",
  "  local n = #grid\n  local m = {}\n  for i = 1, n do\n    for j = 1, n do\n   \
    \   m[grid[i][j]] = {i, j}\n    end\n  end\n  local dirs = {{-1, 0}, {1, 0}, {0,\
    \ -1}, {0, 1}}\n  local function dfs(i, j, k, path)\n    if k == 0 then\n    \
    \  return path\n    end\n    local min_path\n    for _, dir in ipairs(dirs) do\n\
    \      local ii, jj = i + dir[1], j + dir[2]\n      if ii >= 1 and ii <= n and\
    \ jj >= 1 and jj <= n then\n        local p = dfs(ii, jj, k - 1, path .. grid[ii][jj])\n\
    \        if not min_path or p < min_path then\n          min_path = p\n      \
    \  end\n      end\n    end\n    return min_path\n  end\n  local path = dfs(m[1][1],\
    \ m[1][2], k - 1, \"1\")\n  for i = 2, n * n do\n    local p = dfs(m[i][1], m[i][2],\
    \ k - 1, i)\n    if p < path then\n      path = p\n    end\n  end\n  return path\n\
    end", "  local r, c = #grid, #grid[1]\n  local visited = {}\n  local function\
    \ dfs(cr, cc, cl, cv)\n    if cl == k then\n      return {grid[cr][cc]}\n    end\n\
    \    local nv = cv + grid[cr][cc]\n    if visited[cr][cc][cl][nv] then\n     \
    \ return nil\n    end\n    visited[cr][cc][cl][nv] = true\n    local nr, nc, nl\n\
    \    local res\n    local pv\n    if cr > 1 then\n      nr, nc, nl = cr - 1, cc,\
    \ cl + 1\n      res = dfs(nr, nc, nl, nv)\n      if res then\n        table.insert(res,\
    \ 1, grid[cr][cc])\n        return res\n      end\n    end\n    if cr < r then\n\
    \      nr, nc, nl = cr + 1, cc, cl + 1\n      res = dfs(nr, nc, nl, nv)\n    \
    \  if res then\n        table.insert(res, 1, grid[cr][cc])\n        return res\n\
    \      end\n    end\n    if cc > 1 then\n      nr, nc, nl = cr, cc - 1, cl + 1\n\
    \      res = dfs(nr, nc, nl, nv)\n      if res then\n        table.insert(res,\
    \ 1, grid[cr][cc])\n        return res\n      end\n    end\n    if cc < c then\n\
    \      nr, nc, nl = cr, cc + 1, cl + 1\n      res = dfs(nr, nc, nl, nv)\n    \
    \  if res then\n        table.insert(res, 1, grid[cr][cc])\n        return res\n\
    \      end\n    end\n    return nil\n  end\n  for i = 1, r do\n    visited[i]\
    \ = {}\n    for j = 1, c do\n      visited[i][j] = {}\n      for l = 1, k do\n\
    \        visited[i][j][l] = {}\n      end\n    end\n  end\n  for i = 1, r", " \
    \   -- your code here\nend", "    local n = #grid\n    local dp = {}\n    local\
    \ val\n    local min\n    for i = 1, n do\n        dp[i] = {}\n        for j =\
    \ 1, n do\n            dp[i][j] = {}\n            for t = 1, k do\n          \
    \      dp[i][j][t] = {val = math.huge}\n            end\n        end\n    end\n\
    \    for i = 1, n do\n        for j = 1, n do\n            dp[i][j][1].val = grid[i][j]\n\
    \            dp[i][j][1].seq = {grid[i][j]}\n        end\n    end\n    for t =\
    \ 2, k do\n        for i = 1, n do\n            for j = 1, n do\n            \
    \    if i > 1 then\n                    min = dp[i - 1][j][t - 1]\n          \
    \          if min.val > grid[i][j] then\n                        min = {val =\
    \ grid[i][j], seq = {grid[i][j]}}\n                    elseif min.val == grid[i][j]\
    \ then\n                        table.insert(min.seq, grid[i][j])\n          \
    \          end\n                    if lexLess(min, dp[i][j][t]) then\n      \
    \                  dp[i][j][t] = min\n                    end\n              \
    \  end\n                if i < n then\n                    min = dp[i + 1][j][t\
    \ - 1]\n                    if min.val > grid[i][j] then\n                   \
    \     min = {val = grid[i][j], seq = {grid[i][j]}}\n                    elseif\
    \ min.val == grid[i][j] then\n                        table.insert(min.seq, grid[i][j])\n\
    \                    end\n                    if lexLess(min, dp[i][j][t]) then\n\
    \                        dp[i][j][t] = min\n                    end\n        \
    \        end\n                if j > 1 then\n                    min = dp[i][j\
    \ - 1][t - 1]\n                    if min.val > grid[i][j] then\n            \
    \            min = {val = grid[i][j], seq = {grid[i][j]}}", "    -- grid is a\
    \ 2D array of integers\n    -- k is a positive integer\n    -- return a list of\
    \ integers\n    -- each value of grid is in range [1, #grid * #grid]\n    -- and\
    \ appears exactly once\n    -- it is guaranteed that there is exactly one minimum\
    \ path\n    local N = #grid\n    local fullSet = {}\n    for i = 1, N * N do\n\
    \        fullSet[i] = i\n    end\n    local function smallest(t)\n        local\
    \ smallest = t[1]\n        for i = 2, #t do\n            if t[i] < smallest then\n\
    \                smallest = t[i]\n            end\n        end\n        return\
    \ smallest\n    end\n    local function remove_element(t, e)\n        local i\
    \ = 1\n        while i <= #t do\n            if t[i] == e then\n             \
    \   table.remove(t, i)\n            else\n                i = i + 1\n        \
    \    end\n        end\n    end\n    local function setDiff(a, b)\n        local\
    \ t = {}\n        for _, e in ipairs(a) do\n            t[e] = true\n        end\n\
    \        for _, e in ipairs(b) do\n            t[e] = nil\n        end\n     \
    \   local r = {}\n        for e, _ in pairs(t) do\n            table.insert(r,\
    \ e)\n        end\n        return r\n    end\n    local function isEmpty(t)\n\
    \        return next(t) == nil\n    end\n    local function emptySet()\n     \
    \   return {}\n    end\n    local function insertSet(t, v)\n        t[v] = true\n\
    \    end\n    local function makeSet(e)\n        local t = {}\n        t[e] =\
    \ true\n        return t\n    end\n    local function setUnion(a, b)\n       \
    \ local t = {}\n        for e, _ in pairs(a) do\n            t[e] = true\n   \
    \     end\n        for e, _ in pairs(b) do\n            t[e] = true\n        end\n\
    \        return t\n    end\n    local function setIntersect(a, b)\n        local\
    \ t = {}\n        for e, _ in pairs", "\tlocal n = #grid\n\tlocal order_grid =\
    \ {}\n\tlocal order_grid_row = {}\n\tfor i = 1, n do\n\t\tfor j = 1, n do\n\t\t\
    \torder_grid_row[j] = {value = grid[i][j], i = i, j = j}\n\t\tend\n\t\ttable.sort(order_grid_row,\
    \ function(lhs, rhs) return lhs.value < rhs.value end)\n\t\torder_grid[i] = order_grid_row\n\
    \tend\n\tlocal adj_list = {}\n\tfor i = 1, n do\n\t\tfor j = 1, n do\n\t\t\tadj_list[i][j]\
    \ = {}\n\t\t\tif i ~= 1 then\n\t\t\t\tadj_list[i][j][order_grid[i - 1][j]] = true\n\
    \t\t\tend\n\t\t\tif i ~= n then\n\t\t\t\tadj_list[i][j][order_grid[i + 1][j]]\
    \ = true\n\t\t\tend\n\t\t\tif j ~= 1 then\n\t\t\t\tadj_list[i][j][order_grid[i][j\
    \ - 1]] = true\n\t\t\tend\n\t\t\tif j ~= n then\n\t\t\t\tadj_list[i][j][order_grid[i][j\
    \ + 1]] = true\n\t\t\tend\n\t\tend\n\tend\n\t-- shortest path from cell (i, j)\n\
    \tlocal paths = {}\n\tfor i = 1, n do\n\t\tpaths[i] = {}\n\t\tfor j = 1, n do\n\
    \t\t\tpaths[i][j] = {}\n\t\tend\n\tend\n\tfor i = 1, n do\n\t\tfor j = 1, n do\n\
    \t\t\tlocal visited = {}\n\t\t\tlocal pq = {}\n\t\t\tlocal dist = {}\n\t\t\tfor\
    \ idx = 1, n do\n\t\t\t\tvisited[idx] = {}\n\t\t\t\tdist[idx] = {}\n\t\t\t\tfor\
    \ jdx = 1, n do\n\t\t\t\t\tvisited[idx][jdx", '  local n = #grid', "    local\
    \ minPath = {}\n    for r = 1, #grid do\n        for c = 1, #grid[r] do\n    \
    \        local moves = {{r, c}}\n            local path = {grid[r][c]}\n     \
    \       local dfs\n            dfs = function(k)\n                if k == 0 then\n\
    \                    if #minPath == 0 or minPath > path then\n               \
    \         minPath = {unpack(path)}\n                    end\n                \
    \    return\n                end\n                local n = #moves\n         \
    \       for i = 1, n do\n                    local move = moves[i]\n         \
    \           local nr, nc = move[1], move[2]\n                    if nr > 1 then\n\
    \                        moves[n + 1] = {nr - 1, nc}\n                       \
    \ path[k] = grid[nr - 1][nc]\n                        dfs(k - 1)\n           \
    \             moves[n + 1] = nil\n                        path[k] = nil\n    \
    \                end\n                    if nr < #grid then\n               \
    \         moves[n + 1] = {nr + 1, nc}\n                        path[k] = grid[nr\
    \ + 1][nc]\n                        dfs(k - 1)\n                        moves[n\
    \ + 1] = nil\n                        path[k] = nil\n                    end\n\
    \                    if nc > 1 then\n                        moves[n + 1] = {nr,\
    \ nc - 1}\n                        path[k] = grid[nr][nc - 1]\n              \
    \          dfs(k - 1)\n                        moves[n + 1] = nil\n          \
    \              path[k] = nil\n                    end\n                    if\
    \ nc < #grid[nr] then\n                        moves[n + 1] = {nr, nc + 1}\n \
    \                       path[k] = grid[nr][nc + 1]\n                        dfs(k\
    \ - 1)\n                        moves[n + 1] = nil\n                        path[k]\
    \ = nil\n                    end\n                end\n            end\n     \
    \       dfs(k)\n        end\n    end\n    return minPath\nend", "    -- Write\
    \ your code here\n    local n = #grid\n    local visited = {}\n    for i = 1,\
    \ n do\n        visited[i] = {}\n        for j = 1, n do\n            visited[i][j]\
    \ = false\n        end\n    end\n    local function _minPath(i, j, sum, path)\n\
    \        if i < 1 or i > n or j < 1 or j > n or visited[i][j] then\n         \
    \   return nil\n        end\n        visited[i][j] = true\n        path[#path\
    \ + 1] = grid[i][j]\n        sum = sum + grid[i][j]\n        if sum > k then\n\
    \            visited[i][j] = false\n            path[#path] = nil\n          \
    \  return nil\n        end\n        if sum == k then\n            local result\
    \ = {}\n            for _, v in ipairs(path) do\n                result[#result\
    \ + 1] = v\n            end\n            visited[i][j] = false\n            path[#path]\
    \ = nil\n            return result\n        end\n        local result = _minPath(i\
    \ + 1, j, sum, path)\n        if result then\n            return result\n    \
    \    end\n        result = _minPath(i - 1, j, sum, path)\n        if result then\n\
    \            return result\n        end\n        result = _minPath(i, j + 1, sum,\
    \ path)\n        if result then\n            return result\n        end\n    \
    \    result = _minPath(i, j - 1, sum, path)\n        if result then\n        \
    \    return result\n        end\n        visited[i][j] = false\n        path[#path]\
    \ = nil\n        return nil\n    end\n    for i = 1, n do\n        for j = 1,\
    \ n do\n            local result = _minPath(i, j, 0, {})\n            if result\
    \ then\n                return result\n            end\n        end\n    end\n\
    end", "    local N = #grid\n    local visited = {}\n    local function dfs(cr,\
    \ cc, k)\n        if k == 0 then\n            return {grid[cr][cc]}\n        end\n\
    \        local key = cr * N + cc\n        if visited[key] then\n            return\
    \ visited[key]\n        end\n        local minPath\n        if cr > 1 then\n \
    \           local up = dfs(cr - 1, cc, k - 1)\n            if not minPath or less(up,\
    \ minPath) then\n                minPath = up\n            end\n        end\n\
    \        if cr < N then\n            local down = dfs(cr + 1, cc, k - 1)\n   \
    \         if not minPath or less(down, minPath) then\n                minPath\
    \ = down\n            end\n        end\n        if cc > 1 then\n            local\
    \ left = dfs(cr, cc - 1, k - 1)\n            if not minPath or less(left, minPath)\
    \ then\n                minPath = left\n            end\n        end\n       \
    \ if cc < N then\n            local right = dfs(cr, cc + 1, k - 1)\n         \
    \   if not minPath or less(right, minPath) then\n                minPath = right\n\
    \            end\n        end\n        local ret = {grid[cr][cc]}\n        for\
    \ _, v in ipairs(minPath) do\n            table.insert(ret, v)\n        end\n\
    \        visited[key] = ret\n        return ret\n    end\n    local cr, cc\n \
    \   for r = 1, N do\n        for c = 1, N do\n            if grid[r][c] == 1 then\n\
    \                cr, cc = r, c\n                break\n            end\n     \
    \   end\n    end\n    return dfs(cr, cc, k)\nend", "  local N = #grid\n  local\
    \ function is_in_grid(r, c)\n    return (r >= 1 and r <= N and c >= 1 and c <=\
    \ N)\n  end\n  local function clone(t)\n    local ans = {}\n    for _, v in ipairs(t)\
    \ do\n      ans[#ans + 1] = v\n    end\n    return ans\n  end\n  local function\
    \ lexico_less(u, v)\n    for i = 1, #u do\n      if u[i] < v[i] then\n       \
    \ return true\n      elseif u[i] > v[i] then\n        return false\n      end\n\
    \    end\n    return false\n  end\n  local function dfs(x, y, k, p)\n    if is_in_grid(x,\
    \ y) and k > 0 then\n      p[#p + 1] = grid[x][y]\n      for d = 0, 3 do\n   \
    \     local nx, ny = x + dx[d], y + dy[d]\n        if is_in_grid(nx, ny) then\n\
    \          local path = clone(p)\n          if dfs(nx, ny, k - 1, path) then\n\
    \            if lexico_less(path, p) then\n              p = path\n          \
    \  end\n          end\n        end\n      end\n      return true\n    end\n  \
    \  return false\n  end\n  local dx, dy = {-1, 0, 1, 0}, {0, 1, 0, -1}\n  local\
    \ ans = {}\n  for i = 1, N do\n    for j = 1, N do\n      local p = {grid[i][j]}\n\
    \      dfs(i, j, k - 1, p)\n      if #ans == 0 then\n        ans = p\n      elseif\
    \ lexico_less(p, ans) then\n        ans = p\n      end\n    end\n  end\n  return\
    \ ans\nend", "  return nil\nend", "    local N = #grid\n    local inf = 1000000\n\
    \    local min_paths = {}\n    for i = 1, N do\n        min_paths[i] = {}\n  \
    \      for j = 1, N do\n            min_paths[i][j] = inf\n        end\n    end\n\
    \    min_paths[1][1] = grid[1][1]\n    for i = 1, N do\n        for j = 1, N do\n\
    \            if i > 1 then\n                min_paths[i][j] = math.min(min_paths[i][j],\
    \ min_paths[i - 1][j] + grid[i][j])\n            end\n            if j > 1 then\n\
    \                min_paths[i][j] = math.min(min_paths[i][j], min_paths[i][j -\
    \ 1] + grid[i][j])\n            end\n        end\n    end\n    if min_paths[N][N]\
    \ > k then\n        return {}\n    end\n    local res = {}\n    local i, j = N,\
    \ N\n    while i > 1 or j > 1 do\n        table.insert(res, 1, grid[i][j])\n \
    \       if i > 1 and j > 1 then\n            if min_paths[i - 1][j] < min_paths[i][j\
    \ - 1] then\n                i = i - 1\n            else\n                j =\
    \ j - 1\n            end\n        elseif i > 1 then\n            i = i - 1\n \
    \       else\n            j = j - 1\n        end\n    end\n    table.insert(res,\
    \ 1, grid[1][1])\n    return res\nend", '  local n = #grid', "  --your code here\n\
    end", "  local n = #grid\n  local visited = {}\n  local function dfs(i, j, k)\n\
    \    if k < 0 then\n      return\n    end\n    if i < 1 or i > n or j < 1 or j\
    \ > n then\n      return\n    end\n    if visited[i] == nil then\n      visited[i]\
    \ = {}\n    end\n    if visited[i][j] == nil then\n      visited[i][j] = k\n \
    \   elseif visited[i][j] < k then\n      return\n    end\n    local min = grid[i][j]\n\
    \    local min_list = {grid[i][j]}\n    local list = {grid[i][j]}\n    local function\
    \ update(ni, nj, k)\n      local ret = dfs(ni, nj, k)\n      if ret then\n   \
    \     if ret[1] < min then\n          min = ret[1]\n          min_list = ret\n\
    \        end\n      end\n    end\n    update(i - 1, j, k - 1)\n    update(i +\
    \ 1, j, k - 1)\n    update(i, j - 1, k - 1)\n    update(i, j + 1, k - 1)\n   \
    \ return min_list\n  end\n  return dfs(1, 1, k)\nend", "    local function dfs(i,\
    \ j, k, visited, res)\n        if k == 0 then\n            return true\n     \
    \   end\n        local n = #grid\n        for _, v in ipairs({{-1, 0}, {1, 0},\
    \ {0, -1}, {0, 1}}) do\n            local ni, nj = i + v[1], j + v[2]\n      \
    \      if ni >= 1 and ni <= n and nj >= 1 and nj <= n\n                and not\
    \ visited[ni][nj] then\n                visited[ni][nj] = true\n             \
    \   res[#res + 1] = grid[ni][nj]\n                if dfs(ni, nj, k - 1, visited,\
    \ res) then\n                    return true\n                end\n          \
    \      visited[ni][nj] = false\n                res[#res] = nil\n            end\n\
    \        end\n        return false\n    end\n    local n = #grid\n    local visited\
    \ = {}\n    for i = 1, n do\n        visited[i] = {}\n    end\n    local res =\
    \ {}\n    for i = 1, n do\n        for j = 1, n do\n            visited[i][j]\
    \ = true\n            res[1] = grid[i][j]\n            if dfs(i, j, k - 1, visited,\
    \ res) then\n                return res\n            end\n            visited[i][j]\
    \ = false\n        end\n    end\nend", "    -- please implement the function\n\
    end", "  local n = #grid\n  local best_path\n  local A = {}\n  local function\
    \ go(r, c, path)\n    if #path == k then\n      if best_path == nil or path <\
    \ best_path then\n        best_path = path\n      end\n      return\n    end\n\
    \    if best_path ~= nil and path >= best_path then\n      return\n    end\n \
    \   table.insert(path, grid[r][c])\n    if r > 1 then\n      table.insert(A, {r\
    \ - 1, c})\n    end\n    if r < n then\n      table.insert(A, {r + 1, c})\n  \
    \  end\n    if c > 1 then\n      table.insert(A, {r, c - 1})\n    end\n    if\
    \ c < n then\n      table.insert(A, {r, c + 1})\n    end\n    for _, t in ipairs(A)\
    \ do\n      local x, y = t[1], t[2]\n      go(x, y, copy(path))\n    end\n   \
    \ A = {}\n  end\n  for i = 1, n do\n    for j = 1, n do\n      go(i, j, {})\n\
    \    end\n  end\n  return best_path\nend", "  local n = #grid\n  local adj_list\
    \ = {}\n  for i = 1, n do\n    adj_list[i] = {}\n    for j = 1, n do\n      adj_list[i][j]\
    \ = {}\n      if i > 1 then adj_list[i][j][#adj_list[i][j] + 1] = {i - 1, j} end\n\
    \      if i < n then adj_list[i][j][#adj_list[i][j] + 1] = {i + 1, j} end\n  \
    \    if j > 1 then adj_list[i][j][#adj_list[i][j] + 1] = {i, j - 1} end\n    \
    \  if j < n then adj_list[i][j][#adj_list[i][j] + 1] = {i, j + 1} end\n    end\n\
    \  end\n  local dist, prev = {}, {}\n  for i = 1, n do\n    dist[i] = {}\n   \
    \ prev[i] = {}\n    for j = 1, n do\n      dist[i][j] = math.huge\n      prev[i][j]\
    \ = nil\n    end\n  end\n  local pq = {}\n  local function dijkstra()\n    for\
    \ i = 1, n do\n      for j = 1, n do\n        dist[i][j] = math.huge\n       \
    \ prev[i][j] = nil\n      end\n    end\n    dist[1][1] = 0\n    pq = {}\n    table.insert(pq,\
    \ {1, 1})\n    while #pq > 0 do\n      local ui, uj = table.unpack(table.remove(pq,\
    \ 1))\n      for _, e in ipairs(adj_list[ui][uj]) do\n        local vi, vj = table.unpack(e)\n\
    \        local new_dist = dist[ui][uj] + grid[vi][vj]\n        if new_dist < dist[vi][vj]\
    \ then\n          dist[vi][vj] = new_dist\n          prev[vi][vj] = {ui, uj}\n\
    \          table.insert(pq, {vi,", "    local dir = {{0, 1}, {0, -1}, {1, 0},\
    \ {-1, 0}}\n    local n = #grid\n    local m = {}\n    for i = 1, n do\n     \
    \   m[i] = {}\n        for j = 1, n do\n            m[i][j] = grid[i][j]\n   \
    \     end\n    end\n    local function cmp(a, b)\n        if a.len == b.len then\n\
    \            return a.l < b.l\n        end\n        return a.len < b.len\n   \
    \ end\n    local function bfs(x, y)\n        local pq = {head = 0, tail = -1}\n\
    \        local function push(e)\n            local i = pq.tail + 1\n         \
    \   pq.tail = i\n            while i > pq.head do\n                local j = math.floor((i\
    \ - 1) / 2)\n                if cmp(pq[j], e) then\n                    break\n\
    \                end\n                pq[i] = pq[j]\n                i = j\n \
    \           end\n            pq[i] = e\n        end\n        local function pop()\n\
    \            local n = pq[pq.head]\n            pq[pq.head] = pq[pq.tail]\n  \
    \          pq.tail = pq.tail - 1\n            local i = pq.head\n            while\
    \ i * 2 <= pq.tail do\n                local j = i * 2\n                if j <\
    \ pq.tail and cmp(pq[j + 1], pq[j]) then\n                    j = j + 1\n    \
    \            end\n                if cmp(pq[i], pq[j]) then\n                \
    \    break\n                end\n                pq[i], pq[j] = pq[j], pq[i]\n\
    \                i = j\n            end\n            return n\n        end\n \
    \       push({x = x, y = y, len = 0, l = tostring(m[x][y])})\n        local v\
    \ = {}\n        for i = 1, n do\n            v[i] = {}\n            for j = 1,\
    \ n do\n                v[i][j", "    local n = #grid\n    local visited = {}\n\
    \    local minimum\n    local function dfs(v, path)\n        if path and #path\
    \ == k then\n            if not minimum or path < minimum then\n             \
    \   minimum = path\n            end\n            return\n        end\n       \
    \ if visited[v] then\n            return\n        end\n        local x, y = v\
    \ % n, math.floor(v / n)\n        local path = path or {}\n        table.insert(path,\
    \ grid[y + 1][x + 1])\n        visited[v] = true\n        if x > 0 then\n    \
    \        dfs(v - 1, copy(path))\n        end\n        if x < n - 1 then\n    \
    \        dfs(v + 1, copy(path))\n        end\n        if y > 0 then\n        \
    \    dfs(v - n, copy(path))\n        end\n        if y < n - 1 then\n        \
    \    dfs(v + n, copy(path))\n        end\n        visited[v] = nil\n    end\n\
    \    for i = 0, n * n - 1 do\n        dfs(i)\n    end\n    return minimum\nend",
  '    local n = #grid', "    local n = #grid\n    local path = {}\n    for i = 1,\
    \ k do\n        table.insert(path, grid[1][1])\n    end\n    return path\nend",
  "    if not grid or not k then\n        return nil\n    end\n    if k == 0 then\n\
    \        return {}\n    end\n    local res = {}\n    for i = 1, k do\n       \
    \ res[i] = -1\n    end\n    local kk = k + 1\n    local m = #grid\n    local n\
    \ = #grid[1]\n    local map = {}\n    for i = 1, m do\n        for j = 1, n do\n\
    \            map[grid[i][j]] = { i, j }\n        end\n    end\n    local dp =\
    \ {}\n    for i = 1, k do\n        dp[i] = {}\n        for j = 1, m do\n     \
    \       dp[i][j] = {}\n            for l = 1, n do\n                dp[i][j][l]\
    \ = { -1, -1 }\n            end\n        end\n    end\n    local function compare(a,\
    \ b)\n        if not a or not b then\n            return false\n        end\n\
    \        if a[1] < b[1] then\n            return true\n        elseif a[1] > b[1]\
    \ then\n            return false\n        else\n            return a[2] < b[2]\n\
    \        end\n    end\n    local function update(i, j, l, n)\n        if compare(dp[i][j][l],\
    \ n) then\n            dp[i][j][l] = n\n        end\n    end\n    for i = 1, k\
    \ do\n        for j = 1, m do\n            for l = 1, n do\n                local\
    \ last = map[i]\n                if i == 1 then\n                    local m =\
    \ { j, l }\n                    update(i, j, l, m)\n                else\n   \
    \                 local jj = last[1]\n                    local ll = last[2]\n\
    \                    if jj == j then\n                        if ll + 1 <= n then\n\
    \                            local m = { dp[i - 1][j][ll + 1][1], dp[i - 1][j][ll\
    \ + 1][2] }\n                            m[1] = m[1] + 1\n                   \
    \         update(i, j, l, m)\n", "    local n = #grid\n    local set = {}\n  \
    \  local dp = {}\n    for i = 1, n do\n        dp[i] = {}\n        for j = 1,\
    \ n do\n            dp[i][j] = {}\n        end\n    end\n    local dx = { -1,\
    \ 0, 1, 0 }\n    local dy = { 0, 1, 0, -1 }\n    local min = math.min\n    local\
    \ idx = math.maxinteger\n    for i = 1, n do\n        for j = 1, n do\n      \
    \      for x = 1, k do\n                dp[i][j][x] = math.maxinteger\n      \
    \      end\n        end\n    end\n    for i = 1, n do\n        for j = 1, n do\n\
    \            set[grid[i][j]] = { i, j }\n        end\n    end\n    for i = 1,\
    \ n do\n        for j = 1, n do\n            dp[i][j][1] = grid[i][j]\n      \
    \  end\n    end\n    for i = 1, n do\n        for j = 1, n do\n            for\
    \ x = 2, k do\n                for dir = 1, 4 do\n                    local newX\
    \ = i + dx[dir]\n                    local newY = j + dy[dir]\n              \
    \      if newX >= 1 and newX <= n and newY >= 1 and newY <= n then\n         \
    \               dp[i][j][x] = min(dp[i][j][x], dp[newX][newY][x - 1] + grid[i][j])\n\
    \                    end\n                end\n            end\n        end\n\
    \    end\n    local ans = math.maxinteger\n    for i = 1, n do\n        for j\
    \ = 1, n do\n            ans = min(ans, dp[i][j][k])\n        end\n    end\n \
    \   local t = {}\n    for i = 1, k do\n        t[i] = set[ans][1]\n        ans\
    \ = ans - grid[set[ans][1]][set[ans][2]]\n        set[ans] = set[ans][2]\n   \
    \ end\n    return t\nend", "  local function nextPosition(p, dir)\n    if dir\
    \ == 0 then\n      p.x = p.x + 1\n    elseif dir == 1 then\n      p.y = p.y +\
    \ 1\n    elseif dir == 2 then\n      p.x = p.x - 1\n    elseif dir == 3 then\n\
    \      p.y = p.y - 1\n    end\n  end\n  local function less(a, b)\n    local function\
    \ value(p)\n      return grid[p.y][p.x]\n    end\n    for i = 1, k do\n      if\
    \ value(a[i]) < value(b[i]) then\n        return true\n      elseif value(a[i])\
    \ > value(b[i]) then\n        return false\n      end\n    end\n    return false\n\
    \  end\n  local n = #grid\n  local finalPositions = {}\n  local finalPositionsNum\
    \ = 0\n  local finalValues = {}\n  local minPathIndex = nil\n  local function\
    \ dfs(position, step, path)\n    if step == k then\n      finalPositionsNum =\
    \ finalPositionsNum + 1\n      finalPositions[finalPositionsNum] = {}\n      finalValues[finalPositionsNum]\
    \ = {}\n      for i = 1, k do\n        finalPositions[finalPositionsNum][i] =\
    \ path[i]\n        finalValues[finalPositionsNum][i] = grid[path[i].y][path[i].x]\n\
    \      end\n      if minPathIndex == nil or less(finalValues[finalPositionsNum],\
    \ finalValues[minPathIndex]) then\n        minPathIndex = finalPositionsNum\n\
    \      end\n      return\n    end\n    for dir = 0, 3 do\n      local nextPosition\
    \ = { x = position.x, y = position.y }\n      nextPosition(nextPosition, dir)\n\
    \      if nextPosition.x >= 1 and nextPosition.x <= n and nextPosition.y >= 1\
    \ and nextPosition.y <= n then\n        path[step + 1] = nextPosition\n      \
    \  dfs(nextPosition, step + 1, path)\n      end\n    end\n  end\n  for i = 1,\
    \ n do\n    for j = 1, n do", "\tlocal N = #grid\n\t-- build the adjacency matrix\n\
    \tlocal adj = {}\n\tfor r=1,N do\n\t\tadj[r] = {}\n\t\tfor c=1,N do\n\t\t\tadj[r][c]\
    \ = {}\n\t\t\tif r > 1 then\n\t\t\t\tadj[r][c][grid[r-1][c]] = true\n\t\t\tend\n\
    \t\t\tif r < N then\n\t\t\t\tadj[r][c][grid[r+1][c]] = true\n\t\t\tend\n\t\t\t\
    if c > 1 then\n\t\t\t\tadj[r][c][grid[r][c-1]] = true\n\t\t\tend\n\t\t\tif c <\
    \ N then\n\t\t\t\tadj[r][c][grid[r][c+1]] = true\n\t\t\tend\n\t\tend\n\tend\n\t\
    -- get the next possible min value\n\tlocal function getNextMin(matrix, startRow,\
    \ startCol, \n\t\t\t\t\t\t\t\tlastVal, k, path, visited)\n\t\tif k == 0 then\n\
    \t\t\treturn path\n\t\tend\n\t\tlocal minVal = -1\n\t\tlocal minPath\n\t\tlocal\
    \ nextMinPath\n\t\tfor nextVal,_ in pairs(adj[startRow][startCol]) do\n\t\t\t\
    if nextVal > lastVal and nextVal < minVal or minVal == -1 then\n\t\t\t\tminVal\
    \ = nextVal\n\t\t\tend\n\t\tend\n\t\tfor r=1,N do\n\t\t\tfor c=1,N do\n\t\t\t\t\
    if matrix[r][c] == minVal and not visited[r][c] then\n\t\t\t\t\tvisited[r][c]\
    \ = true\n\t\t\t\t\tnextMinPath = getNextMin(matrix, r, c, minVal, \n\t\t\t\t\t\
    \t\t\t\t\t\t\tk-1, {minVal, unpack(path)}, visited)\n\t\t\t\t\tif nextMinPath\
    \ and \n\t\t\t\t\t\t(not minPath or minPath > nextMinPath) then\n\t\t\t\t\t\t\
    minPath =", "    local m, n = #grid, #grid[1]\n    local t = {}\n    for i = 1,\
    \ m do\n        t[i] = {}\n        for j = 1, n do\n            t[i][j] = {[1]\
    \ = {i, j}}\n        end\n    end\n    for i = 1, k - 1 do\n        for j = 1,\
    \ m do\n            for l = 1, n do\n                local cnt, val, pos = 0,\
    \ 1, nil\n                for _, p in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}})\
    \ do\n                    local a, b = j + p[1], l + p[2]\n                  \
    \  if a >= 1 and a <= m and b >= 1 and b <= n then\n                        cnt\
    \ = cnt + 1\n                        local tt = grid[a][b]\n                 \
    \       if tt < val then\n                            val, pos = tt, {a, b}\n\
    \                        end\n                    end\n                end\n \
    \               if val == 1 then\n                    table.insert(t[j][l], 1,\
    \ pos)\n                else\n                    local idx = (val - 1) % cnt\
    \ + 1\n                    local a, b = 0, 0\n                    local c = 1\n\
    \                    for _, p in ipairs({{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) do\n\
    \                        a, b = j + p[1], l + p[2]\n                        if\
    \ a >= 1 and a <= m and b >= 1 and b <= n then\n                            if\
    \ c == idx then\n                                break\n                     \
    \       end\n                            c = c + 1\n                        end\n\
    \                    end\n                    table.insert(t[j][l], 1, {a, b})\n\
    \                end\n            end\n        end\n    end\n    local min = math.huge\n\
    \    local res = {}\n    for i = 1, m do\n        for j = 1, n do\n          \
    \  local tt = grid[i][j]\n            local ans = {tt}\n            for _, v in\
    \ ipairs(t[i][j]) do\n                tt = grid[v[1]", "  local n = #grid\n  local\
    \ m = k\n  for i = 1, n do\n    for j = 1, n do\n      if grid[i][j] == 1 then\n\
    \        m = k + 1\n        break\n      end\n    end\n  end\n  local dp = {}\n\
    \  local vis = {}\n  local ret = {}\n  local function set(a, b, c, x)\n    if\
    \ not dp[a] then\n      dp[a] = {}\n    end\n    if not dp[a][b] then\n      dp[a][b]\
    \ = {}\n    end\n    dp[a][b][c] = x\n  end\n  local function get(a, b, c)\n \
    \   if not dp[a] then\n      return\n    end\n    if not dp[a][b] then\n     \
    \ return\n    end\n    return dp[a][b][c]\n  end\n  local function get_vis(a,\
    \ b, c)\n    if not vis[a] then\n      return\n    end\n    if not vis[a][b] then\n\
    \      return\n    end\n    return vis[a][b][c]\n  end\n  local function set_vis(a,\
    \ b, c, x)\n    if not vis[a] then\n      vis[a] = {}\n    end\n    if not vis[a][b]\
    \ then\n      vis[a][b] = {}\n    end\n    vis[a][b][c] = x\n  end\n  local path\
    \ = {}\n  local function solve(x, y, z)\n    if z < 0 then\n      return\n   \
    \ end\n    local v = get(x, y, z)\n    if v then\n      return v\n    end\n  \
    \  local dfs = function(x, y, z)\n      if x == 1 and y == 1 and z == m - 1 then\n\
    \        return true\n      end\n      if x > 1 and not get_vis(x - 1, y, z) then\n\
    \        set_vis(x - 1, y, z, true)\n        path[z + 1] = grid[x - 1][y]\n  \
    \      if dfs(x - 1", "    local function _minPath(grid, i, j, k, visited)\n \
    \       if (k == 0) then\n            return {grid[i][j]}\n        end\n     \
    \   visited[i][j] = true\n        local minPath = {}\n        local n, m = #grid,\
    \ #grid[1]\n        local dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n        for\
    \ _, dir in ipairs(dirs) do\n            local ni, nj = i + dir[1], j + dir[2]\n\
    \            if (ni >= 1 and ni <= n and nj >= 1 and nj <= m and not visited[ni][nj])\
    \ then\n                local path = _minPath(grid, ni, nj, k - 1, visited)\n\
    \                path[#path + 1] = grid[i][j]\n                if (#minPath ==\
    \ 0 or lexicographicallyLess(path, minPath)) then\n                    minPath\
    \ = path\n                end\n            end\n        end\n        visited[i][j]\
    \ = false\n        return minPath\n    end\n    local n, m = #grid, #grid[1]\n\
    \    local visited = {}\n    for i = 1, n do\n        visited[i] = {}\n    end\n\
    \    local res = {}\n    for i = 1, n do\n        for j = 1, m do\n          \
    \  local path = _minPath(grid, i, j, k, visited)\n            if (#res == 0 or\
    \ lexicographicallyLess(path, res)) then\n                res = path\n       \
    \     end\n        end\n    end\n    return res\nend", "    local n = #grid\n\
    \    local function isValid(x, y)\n        return 1 <= x and x <= n and 1 <= y\
    \ and y <= n\n    end\n    local function calcKey(path)\n        local res = 0\n\
    \        for i = 1, #path do\n            res = res * n * n + grid[path[i][1]][path[i][2]]\n\
    \        end\n        return res\n    end\n    local function pushToQ(q, path)\n\
    \        local key = calcKey(path)\n        if not q[key] then\n            q[key]\
    \ = path\n            table.insert(queue, path)\n        end\n    end\n    local\
    \ queue = {}\n    local q = {}\n    for i = 1, n do\n        for j = 1, n do\n\
    \            pushToQ(q, {{i, j}})\n        end\n    end\n    for i = 2, k do\n\
    \        local size = #queue\n        for j = 1, size do\n            local path\
    \ = queue[j]\n            local x, y = path[#path][1], path[#path][2]\n      \
    \      for _, dir in ipairs({{1, 0}, {-1, 0}, {0, 1}, {0, -1}}) do\n         \
    \       local xx, yy = x + dir[1], y + dir[2]\n                if isValid(xx,\
    \ yy) then\n                    local newPath = {}\n                    for i\
    \ = 1, #path do\n                        table.insert(newPath, path[i])\n    \
    \                end\n                    table.insert(newPath, {xx, yy})\n  \
    \                  pushToQ(q, newPath)\n                end\n            end\n\
    \        end\n        queue = {}\n    end\n    local res = queue[1]\n    for i\
    \ = 2, #queue do\n        if calcKey(queue[i]) < calcKey(res) then\n         \
    \   res = queue[i]\n        end\n    end\n    local res2 = {}\n    for i = 1,\
    \ #res do\n        table.insert(res2, grid[res[i][1]][res[i][2]])\n    end\n \
    \   return res2\nend", "    return nil\nend", "    local n = #grid\n    local\
    \ memo = {}\n    local function dfs(i, j, k)\n        if k == 0 then\n       \
    \     return {grid[i][j]}\n        end\n        local idx = i * n + j\n      \
    \  if not memo[idx] then\n            memo[idx] = {}\n        end\n        if\
    \ memo[idx][k] then\n            return memo[idx][k]\n        end\n        local\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}\n        local ans = nil\n        for\
    \ _, d in ipairs(dir) do\n            local x, y = i + d[1], j + d[2]\n      \
    \      if x >= 1 and x <= n and y >= 1 and y <= n then\n                local\
    \ lst = dfs(x, y, k - 1)\n                if not ans or lst[1] < ans[1] then\n\
    \                    ans = {grid[i][j]}\n                    for _, v in ipairs(lst)\
    \ do\n                        table.insert(ans, v)\n                    end\n\
    \                end\n            end\n        end\n        memo[idx][k] = ans\n\
    \        return ans\n    end\n    local ans = nil\n    for i = 1, n do\n     \
    \   for j = 1, n do\n            local lst = dfs(i, j, k)\n            if not\
    \ ans or lst[1] < ans[1] then\n                ans = lst\n            end\n  \
    \      end\n    end\n    return ans\nend", "    local n = #grid\n    local s =\
    \ grid[1][1]\n    if k == 1 then\n        return {s}\n    end\n    local function\
    \ isValid(i, j)\n        return i >= 1 and i <= n and j >= 1 and j <= n\n    end\n\
    \    local function findMin(x, y, step, cur_sum, cur_path)\n        local ret\n\
    \        local v = grid[x][y]\n        step = step + 1\n        cur_sum = cur_sum\
    \ + v\n        if step == k then\n            cur_path[#cur_path + 1] = v\n  \
    \          return cur_path\n        end\n        cur_path[#cur_path + 1] = v\n\
    \        for i = x - 1, x + 1 do\n            for j = y - 1, y + 1 do\n      \
    \          if i ~= x or j ~= y then\n                    if isValid(i, j) then\n\
    \                        local l = findMin(i, j, step, cur_sum, cur_path)\n  \
    \                      if l then\n                            if not ret then\n\
    \                                ret = l\n                            else\n \
    \                               for i = 1, #l do\n                           \
    \         if l[i] < ret[i] then\n                                        ret =\
    \ l\n                                        break\n                         \
    \           elseif l[i] > ret[i] then\n                                      \
    \  break\n                                    end\n                          \
    \      end\n                            end\n                        end\n   \
    \                 end\n                end\n            end\n        end\n   \
    \     return ret\n    end\n    return findMin(1, 1, 0, 0, {})\nend", "    -- Write\
    \ your code here\n    local n = #grid\n    local a = {}\n    for i = 1, n do\n\
    \        a[i] = {}\n        for j = 1, n do\n            a[i][j] = {}\n      \
    \  end\n    end\n    for j = 1, n do\n        a[1][j][1] = {grid[1][j]}\n    end\n\
    \    for i = 2, n do\n        for j = 1, n do\n            local min = {}\n  \
    \          for m = 1, n do\n                for l = 1, k - 1 do\n            \
    \        if a[i - 1][m][l] then\n                        local t = copyTable(a[i\
    \ - 1][m][l])\n                        table.insert(t, grid[i][j])\n         \
    \               if not min[1] or cmpTable(t, min[1]) then\n                  \
    \          min = {t}\n                        elseif cmpTable(t, min[1]) == 0\
    \ then\n                            table.insert(min, t)\n                   \
    \     end\n                    end\n                end\n            end\n   \
    \         a[i][j] = min\n        end\n    end\n    local min = {}\n    for i =\
    \ 1, n do\n        if a[n][i][k] then\n            if not min[1] or cmpTable(a[n][i][k][1],\
    \ min[1]) then\n                min = a[n][i][k]\n            elseif cmpTable(a[n][i][k][1],\
    \ min[1]) == 0 then\n                for j = 1, #a[n][i][k] do\n             \
    \       table.insert(min, a[n][i][k][j])\n                end\n            end\n\
    \        end\n    end\n    return min[1]\nend", "    local gx, gy = #grid, #grid[1]\n\
    \    local function dijkstra(path_)\n        local queue = {0}\n        local\
    \ done = {}\n        local visited = { {0, 0} }\n        local dist = {}\n   \
    \     for x = 0, gx - 1 do\n            dist[x] = {}\n            for y = 0, gy\
    \ - 1 do\n                dist[x][y] = math.huge\n            end\n        end\n\
    \        dist[0][0] = 0\n        local function insert_pos(...)\n            local\
    \ n = select('#', ...)\n            for i = 1, n do\n                local pos\
    \ = select(i, ...)\n                local x, y = pos[1], pos[2]\n            \
    \    local value = grid[x][y]\n                if not done[value] then\n     \
    \               local dist_ = dist[x][y]\n                    local pos_ = #visited\
    \ + 1\n                    visited[pos_] = pos\n                    while pos_\
    \ > 1 and dist_ < dist[visited[pos_ - 1][1]][visited[pos_ - 1][2]] do\n      \
    \                  visited[pos_] = visited[pos_ - 1]\n                       \
    \ visited[pos_ - 1] = pos\n                        pos_ = pos_ - 1\n         \
    \           end\n                    if pos_ == 1 then\n                     \
    \   queue[#queue + 1] = value\n                    end\n                end\n\
    \            end\n        end\n        for i = 1, #path_ do\n            local\
    \ x, y = path_[i][1], path_[i][2]\n            dist[x][y] = 0\n            done[grid[x][y]]\
    \ = true\n            insert_pos({x - 1, y}, {x + 1, y}, {x, y - 1}, {x, y + 1})\n\
    \        end\n        while #queue > 0 do\n            local value = table.remove(queue,\
    \ 1)\n            local pos = visited[1]\n            table.remove(visited, 1)\n\
    \            local x, y = pos[1], pos[2]\n            local dist_ = dist[x][y]\n\
    \            dist[x][y] = math.huge\n            if x > 0 and dist_ + 1 <", " \
    \   local n = #grid\n    local memo = {}\n    local function dfs(r, c, k)\n  \
    \      if r < 1 or r > n or c < 1 or c > n then\n            return nil\n    \
    \    end\n        if k == 0 then\n            return {}\n        end\n       \
    \ local key = r * 10000 + c * 100 + k\n        if memo[key] then\n           \
    \ return memo[key]\n        end\n        local best = nil\n        local directions\
    \ = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n        for _, v in ipairs(directions)\
    \ do\n            local next = dfs(r + v[1], c + v[2], k - 1)\n            if\
    \ next then\n                table.insert(next, 1, grid[r][c])\n             \
    \   if not best or #best > #next then\n                    best = next\n     \
    \           elseif #best == #next then\n                    for i = 1, #best do\n\
    \                        if best[i] ~= next[i] then\n                        \
    \    if best[i] < next[i] then\n                                break\n      \
    \                      end\n                            best = next\n        \
    \                    break\n                        end\n                    end\n\
    \                end\n            end\n        end\n        memo[key] = best\n\
    \        return best\n    end\n    for i = 1, n do\n        for j = 1, n do\n\
    \            local res = dfs(i, j, k)\n            if res then\n             \
    \   return res\n            end\n        end\n    end\nend", "  local n = #grid\n\
    \  local visited = {}\n  for i = 1, n do\n    visited[i] = {}\n    for j = 1,\
    \ n do\n      visited[i][j] = {[grid[i][j]] = 1}\n    end\n  end\n  local function\
    \ getNext(i, j)\n    local next = {}\n    if i > 1 then table.insert(next, {i\
    \ - 1, j}) end\n    if i < n then table.insert(next, {i + 1, j}) end\n    if j\
    \ > 1 then table.insert(next, {i, j - 1}) end\n    if j < n then table.insert(next,\
    \ {i, j + 1}) end\n    return next\n  end\n  for _ = 1, k - 1 do\n    local nextVisited\
    \ = {}\n    for i = 1, n do\n      nextVisited[i] = {}\n      for j = 1, n do\n\
    \        nextVisited[i][j] = {}\n        for nextI, nextJ in pairs(getNext(i,\
    \ j)) do\n          for nextVal, _ in pairs(visited[nextI][nextJ]) do\n      \
    \      nextVisited[i][j][nextVal] = 1\n          end\n        end\n      end\n\
    \    end\n    visited = nextVisited\n  end\n  local min = {grid[1][1]}\n  for\
    \ i = 1, n do\n    for j = 1, n do\n      local c = {grid[i][j]}\n      for val,\
    \ _ in pairs(visited[i][j]) do\n        table.insert(c, val)\n      end\n    \
    \  table.sort(c)\n      if less(c, min) then min = c end\n    end\n  end\n  return\
    \ min\nend", "    --[[\n    cell = {\n        value = number,\n        path_len\
    \ = number,\n        prev = cell,\n    }\n    ]]\n    local min_path = nil\n \
    \   local visited = {}\n    local queue = {}\n    local N = #grid\n    for i =\
    \ 1, N do\n        visited[i] = {}\n        for j = 1, N do\n            local\
    \ new_cell = {\n                value = grid[i][j],\n                path_len\
    \ = 0,\n                prev = nil,\n            }\n            visited[i][j]\
    \ = new_cell\n            queue[#queue + 1] = new_cell\n        end\n    end\n\
    \    while #queue > 0 do\n        local q = queue[1]\n        table.remove(queue,\
    \ 1)\n        local i, j = q.value % N, (q.value - q.value % N) / N + 1\n    \
    \    local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = visited[i - 1][j]\n        end\n        if i < N then\n            neighbors[#neighbors\
    \ + 1] = visited[i + 1][j]\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = visited[i][j - 1]\n        end\n        if j < N then\n            neighbors[#neighbors\
    \ + 1] = visited[i][j + 1]\n        end\n        for _, n in ipairs(neighbors)\
    \ do\n            if q.path_len + 1 < n.path_len then\n                n.path_len\
    \ = q.path_len + 1\n                n.prev = q\n            end\n        end\n\
    \    end\n    for i = 1, N do\n        for j = 1, N do\n            local n =\
    \ visited[i][j]\n            if n.path_len == k then\n                if min_path\
    \ == nil then\n                    min_path = n\n                else\n      \
    \              local lst_new = {}\n                    while n ~= nil do\n   \
    \                     lst_new[#lst_new + 1] = n.value\n                      \
    \  n = n.prev\n                    end\n                    local lst_min =",
  "    error(\"Not Implemented\")\nend", "  -- TODO: implement the solution\nend",
  "    local N = #grid\n    local minPaths = { { grid[1][1] } }\n    local visited\
    \ = { [1] = { [1] = true } }\n    local directions = { { -1, 0 }, { 1, 0 }, {\
    \ 0, -1 }, { 0, 1 } }\n    while true do\n        local currPaths = minPaths\n\
    \        minPaths = {}\n        for i = 1, #currPaths do\n            local path\
    \ = currPaths[i]\n            if #path == k then\n                return path\n\
    \            end\n            local x, y = path[#path], path[#path - 1]\n    \
    \        for _, d in ipairs(directions) do\n                local newX, newY =\
    \ x + d[1], y + d[2]\n                if newX >= 1 and newX <= N and newY >= 1\
    \ and newY <= N and not visited[newX][newY] then\n                    local newPath\
    \ = { table.unpack(path) }\n                    table.insert(newPath, grid[newX][newY])\n\
    \                    table.insert(minPaths, newPath)\n                    visited[newX]\
    \ = visited[newX] or {}\n                    visited[newX][newY] = true\n    \
    \            end\n            end\n        end\n    end\nend", "\t-- Write your\
    \ code here\nend", "  if not k or k < 1 then\n    return {}\n  end\n  local a\
    \ = {}\n  local max_value = #grid * #grid\n  for _, row in ipairs(grid) do\n \
    \   for _, cell in ipairs(row) do\n      assert(cell >= 1 and cell <= max_value)\n\
    \      a[cell] = true\n    end\n  end\n  if k > max_value then\n    return {}\n\
    \  end\n  if k == 1 then\n    return {{}}\n  end\n  if k == max_value then\n \
    \   return grid\n  end\n  local N = #grid\n  local dirs = { {-1, 0}, {1, 0}, {0,\
    \ -1}, {0, 1} }\n  local function in_range(i, j)\n    return i >= 1 and i <= N\
    \ and j >= 1 and j <= N\n  end\n  local function get_value(i, j)\n    return grid[i][j]\n\
    \  end\n  local function get_neighbors(i, j)\n    local neighbors = {}\n    for\
    \ _, dir in ipairs(dirs) do\n      local ii, jj = i + dir[1], j + dir[2]\n   \
    \   if in_range(ii, jj) then\n        table.insert(neighbors, {ii, jj})\n    \
    \  end\n    end\n    return neighbors\n  end\n  local function less(p1, p2)\n\
    \    if #p1 < #p2 then\n      return true\n    end\n    if #p1 > #p2 then\n  \
    \    return false\n    end\n    for i = 1, #p1 do\n      if p1[i] < p2[i] then\n\
    \        return true\n      end\n      if p1[i] > p2[i] then\n        return false\n\
    \      end\n    end\n    return false\n  end\n  local cache = {}\n  local function\
    \ dfs(i, j, len, path)\n    if not path then\n      path = {}\n    end\n    if\
    \ len == 0 then\n      return path\n    end\n    if len == 1 then\n      table.insert(path,\
    \ get_value(i, j))\n", "    local N = #grid\n    local memo = {}\n    local function\
    \ dfs(i, j, k)\n        if k == 0 then\n            return {[0] = grid[i][j]}\n\
    \        end\n        local key = string.format('%d,%d,%d', i, j, k)\n       \
    \ if memo[key] then\n            return memo[key]\n        end\n        local\
    \ up, down, left, right = {}, {}, {}, {}\n        if i > 1 then\n            up\
    \ = dfs(i - 1, j, k - 1)\n        end\n        if i < N then\n            down\
    \ = dfs(i + 1, j, k - 1)\n        end\n        if j > 1 then\n            left\
    \ = dfs(i, j - 1, k - 1)\n        end\n        if j < N then\n            right\
    \ = dfs(i, j + 1, k - 1)\n        end\n        local lst = {}\n        for _,\
    \ l in ipairs({up, down, left, right}) do\n            if #l > 0 then\n      \
    \          lst[#lst + 1] = l\n            end\n        end\n        table.sort(lst,\
    \ function(lhs, rhs)\n            for i = 1, k do\n                if lhs[i] <\
    \ rhs[i] then\n                    return true\n                elseif lhs[i]\
    \ > rhs[i] then\n                    return false\n                end\n     \
    \       end\n            return false\n        end)\n        local res = lst[1]\n\
    \        res[#res + 1] = grid[i][j]\n        memo[key] = res\n        return res\n\
    \    end\n    local res = {}\n    for i = 1, N do\n        for j = 1, N do\n \
    \           local lst = dfs(i, j, k)\n            if #res == 0 or (#lst > 0 and\
    \ table.concat(lst) < table.concat(res)) then\n                res = lst\n   \
    \         end\n        end\n    end\n    return res\nend", "  -- write your code\
    \ here\n  local n = #grid\n  local minPaths = {}\n  for i = 1, n do\n    for j\
    \ = 1, n do\n      local path = {grid[i][j]}\n      table.insert(minPaths, path)\n\
    \    end\n  end\n  for m = 2, k do\n    local nextMinPaths = {}\n    for _, path\
    \ in ipairs(minPaths) do\n      local cur_row, cur_col = path[#path], path[#path]\n\
    \      local nextPaths = {{}, {}, {}, {}}\n      if cur_row > 1 then\n       \
    \ table.insert(nextPaths[1], grid[cur_row - 1][cur_col])\n      end\n      if\
    \ cur_row < n then\n        table.insert(nextPaths[2], grid[cur_row + 1][cur_col])\n\
    \      end\n      if cur_col > 1 then\n        table.insert(nextPaths[3], grid[cur_row][cur_col\
    \ - 1])\n      end\n      if cur_col < n then\n        table.insert(nextPaths[4],\
    \ grid[cur_row][cur_col + 1])\n      end\n      for _, arr in ipairs(nextPaths)\
    \ do\n        if #arr > 0 then\n          local newPath = arr\n          for _,\
    \ value in ipairs(path) do\n            table.insert(newPath, value)\n       \
    \   end\n          table.insert(nextMinPaths, newPath)\n        end\n      end\n\
    \    end\n    minPaths = nextMinPaths\n  end\n  local minPath = minPaths[1]\n\
    \  for _, path in ipairs(minPaths) do\n    if lexicographicallyLess(path, minPath)\
    \ then\n      minPath = path\n    end\n  end\n  return minPath\nend", "\t-- print(#grid,\
    \ k)\n\t-- for _, r in ipairs(grid) do\n\t-- \tprint(table.concat(r, \" \"))\n\
    \t-- end\n\tlocal n = #grid\n\tassert(n >= 2 and n == #grid[1])\n\tassert(k >=\
    \ 1 and k <= n*n)\n\tlocal uniq\n\tfor x, _ in pairs(grid) do\n\t\tuniq = (uniq\
    \ or {})[grid[x]] = true\n\tend\n\tassert(uniq == nil or next(uniq) == nil)\n\t\
    assert(k ~= 1)\n\tlocal start_x, start_y\n\tfor x = 1, n do\n\t\tfor y = 1, n\
    \ do\n\t\t\tstart_x, start_y = x, y\n\t\t\tbreak\n\t\tend\n\t\tif start_x then\n\
    \t\t\tbreak\n\t\tend\n\tend\n\tlocal min_path\n\tlocal function visit(x, y, path,\
    \ k, cur_min)\n\t\tif k == 0 then\n\t\t\tif not min_path or path < min_path then\n\
    \t\t\t\tmin_path = path\n\t\t\tend\n\t\t\treturn\n\t\tend\n\t\tif cur_min then\n\
    \t\t\tfor i = 1, #cur_min do\n\t\t\t\tif cur_min[i] < path[i] then\n\t\t\t\t\t\
    return\n\t\t\t\telseif cur_min[i] > path[i] then\n\t\t\t\t\tbreak\n\t\t\t\tend\n\
    \t\t\tend\n\t\tend\n\t\tk = k - 1\n\t\tlocal old_val = grid[x][y]\n\t\tgrid[x][y]\
    \ = true\n\t\ttable.insert(path, old_val)\n\t\tlocal min_path_len = #min_path\n\
    \t\tif x > 1 and grid[x-1][y] ~= true then\n\t\t\tvisit(x-1, y, path, k, min_path)\n\
    \t\tend\n\t\tif #min_path ~= min_path_len then\n\t\t\tcur_min = min_path\n\t",
  "  -- Write your code here\nend", "  local n = #grid\n  assert(n >= 2 and k > 0\
    \ and k <= n * n)\n  local dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n  local\
    \ function valid(i, j)\n    return i >= 1 and i <= n and j >= 1 and j <= n\n \
    \ end\n  local function get_val(i, j)\n    return grid[i][j]\n  end\n  local i,\
    \ j, v = 1, 1, 0\n  local path = {}\n  for t = 1, k do\n    v = get_val(i, j)\n\
    \    table.insert(path, v)\n    local next_i, next_j, min_val = i, j, math.huge\n\
    \    for _, dir in ipairs(dirs) do\n      local i1, j1 = i + dir[1], j + dir[2]\n\
    \      if valid(i1, j1) then\n        local val = get_val(i1, j1)\n        if\
    \ val < min_val then\n          min_val = val\n          next_i, next_j = i1,\
    \ j1\n        end\n      end\n    end\n    i, j = next_i, next_j\n  end\n  return\
    \ path\nend", "    local n = #grid\n    local dist = {}\n    for i = 1, n do\n\
    \        dist[i] = {}\n        for j = 1, n do\n            dist[i][j] = math.huge\n\
    \        end\n    end\n    local q = Queue.new()\n    local r = {}\n    for i\
    \ = 1, n do\n        r[i] = {}\n        for j = 1, n do\n            r[i][j] =\
    \ {}\n        end\n    end\n    local ds = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}\n\
    \    local function inbounds(x, y)\n        return x >= 1 and x <= n and y >=\
    \ 1 and y <= n\n    end\n    local function gval(x, y)\n        return grid[x][y]\n\
    \    end\n    for i = 1, n do\n        for j = 1, n do\n            local val\
    \ = gval(i, j)\n            for d = 1, 4 do\n                local x, y = i +\
    \ ds[d][1], j + ds[d][2]\n                if inbounds(x, y) and val < gval(x,\
    \ y) then\n                    r[i][j][#r[i][j] + 1] = {x, y}\n              \
    \  end\n            end\n        end\n    end\n    local function lex_lt(x, y)\n\
    \        for i = 1, k do\n            if x[i] ~= y[i] then\n                return\
    \ x[i] < y[i]\n            end\n        end\n        return false\n    end\n \
    \   local function relax(x, y, v)\n        local cur = dist[x][y]\n        if\
    \ cur <= v then\n            return\n        end\n        dist[x][y] = v\n   \
    \     q:push_back({x, y})\n    end\n    local res = {}\n    for i = 1, k do\n\
    \        res[i] = math.huge\n    end\n    relax(1, 1, {gval(1, 1)})\n    while\
    \ not q:empty() do\n        local x, y = q:pop_front()\n        local", "    return\
    \ nil\nend", "  local size = #grid\n  local visited = {}\n  for i = 1, size do\n\
    \    visited[i] = {}\n    for j = 1, size do\n      visited[i][j] = false\n  \
    \  end\n  end\n  local function get(x, y)\n    if x < 1 or x > size or y < 1 or\
    \ y > size then\n      return 0\n    end\n    return grid[x][y]\n  end\n  local\
    \ function getCells(k)\n    local cells = {}\n    for i = 1, size do\n      for\
    \ j = 1, size do\n        cells[#cells + 1] = { i, j }\n      end\n    end\n \
    \   for i = 1, k do\n      for j = i + 1, #cells do\n        local a, b = cells[i],\
    \ cells[j]\n        local x1, y1 = a[1], a[2]\n        local x2, y2 = b[1], b[2]\n\
    \        local v1, v2 = get(x1, y1), get(x2, y2)\n        if v1 > v2 then\n  \
    \        cells[i], cells[j] = b, a\n        elseif v1 == v2 then\n          local\
    \ d1, d2 = 0, 0\n          if visited[x1 - 1][y1] then\n            d1 = d1 +\
    \ 1\n          end\n          if visited[x1 + 1][y1] then\n            d1 = d1\
    \ + 1\n          end\n          if visited[x1][y1 - 1] then\n            d1 =\
    \ d1 + 1\n          end\n          if visited[x1][y1 + 1] then\n            d1\
    \ = d1 + 1\n          end\n          if visited[x2 - 1][y2] then\n           \
    \ d2 = d2 + 1\n          end\n          if visited[x2 + 1][y2] then\n        \
    \    d2 = d2 + 1\n          end\n          if visited[x2][y2 - 1] then\n     \
    \       d2 = d2 + 1\n          end\n          if visited[x2][y2 + 1] then\n  \
    \          d2 = d2 + 1\n          end\n          if d1 >", "    local n = #grid\n\
    \    assert(n >= 2)\n    local function minPathRec(x, y, k)\n        if k == 0\
    \ then\n            return { grid[x][y] }\n        end\n        local minPath,\
    \ minVal = nil, math.huge\n        local function minValUpdate(path)\n       \
    \     local val = 0\n            for i = 1, #path do\n                val = val\
    \ * n * n + path[i]\n            end\n            if val < minVal then\n     \
    \           minPath, minVal = path, val\n            end\n        end\n      \
    \  if x > 1 then\n            minValUpdate(minPathRec(x - 1, y, k - 1))\n    \
    \    end\n        if x < n then\n            minValUpdate(minPathRec(x + 1, y,\
    \ k - 1))\n        end\n        if y > 1 then\n            minValUpdate(minPathRec(x,\
    \ y - 1, k - 1))\n        end\n        if y < n then\n            minValUpdate(minPathRec(x,\
    \ y + 1, k - 1))\n        end\n        return minPath\n    end\n    local path\
    \ = minPathRec(1, 1, k)\n    for x = 1, n do\n        for y = 1, n do\n      \
    \      if x ~= 1 or y ~= 1 then\n                local path2 = minPathRec(x, y,\
    \ k)\n                local val, val2 = 0, 0\n                for i = 1, #path\
    \ do\n                    val = val * n * n + path[i]\n                end\n \
    \               for i = 1, #path2 do\n                    val2 = val2 * n * n\
    \ + path2[i]\n                end\n                if val2 < val then\n      \
    \              path = path2\n                end\n            end\n        end\n\
    \    end\n    return path\nend", "    local size = #grid\n    local min_val =\
    \ math.huge\n    local min_path = {}\n    local function dfs(path, i, j, acc)\n\
    \        local val = grid[i][j]\n        table.insert(path, val)\n        acc\
    \ = acc + val\n        if acc > min_val then\n            table.remove(path)\n\
    \            return\n        end\n        if k == #path then\n            if acc\
    \ < min_val then\n                min_val = acc\n                min_path = {table.unpack(path)}\n\
    \            elseif acc == min_val then\n                for i = 1, k do\n   \
    \                 if path[i] < min_path[i] then\n                        min_path\
    \ = {table.unpack(path)}\n                        break\n                    elseif\
    \ path[i] > min_path[i] then\n                        break\n                \
    \    end\n                end\n            end\n            table.remove(path)\n\
    \            return\n        end\n        if i > 1 then\n            dfs(path,\
    \ i - 1, j, acc)\n        end\n        if i < size then\n            dfs(path,\
    \ i + 1, j, acc)\n        end\n        if j > 1 then\n            dfs(path, i,\
    \ j - 1, acc)\n        end\n        if j < size then\n            dfs(path, i,\
    \ j + 1, acc)\n        end\n        table.remove(path)\n    end\n    for i = 1,\
    \ size do\n        for j = 1, size do\n            dfs({}, i, j, 0)\n        end\n\
    \    end\n    return min_path\nend", "    return {}\nend", "    if not grid or\
    \ not grid[1] or #grid < 2 or k < 1 then\n        return {}\n    end\n    -- It\
    \ is guaranteed that the answer is unique.\n    local n = #grid\n    local m =\
    \ {}\n    for i = 1, n do\n        m[i] = {}\n        for j = 1, n do\n      \
    \      m[i][j] = true\n        end\n    end\n    for i = 1, n do\n        for\
    \ j = 1, n do\n            m[i][j] = not m[i][j]\n        end\n    end\n    return\
    \ {}\nend", "  -- collect all the cells with value j and set the neighbor flag\
    \ in them\n  local cells = {}\n  for j = 1, #grid * #grid do\n    cells[j] = {}\n\
    \  end\n  for i = 1, #grid do\n    for j = 1, #grid do\n      local cell = {i\
    \ = i, j = j, value = grid[i][j]}\n      cell.neighbors = {\n        up = i >\
    \ 1 and {i = i - 1, j = j, value = grid[i - 1][j]} or nil,\n        down = i <\
    \ #grid and {i = i + 1, j = j, value = grid[i + 1][j]} or nil,\n        left =\
    \ j > 1 and {i = i, j = j - 1, value = grid[i][j - 1]} or nil,\n        right\
    \ = j < #grid and {i = i, j = j + 1, value = grid[i][j + 1]} or nil,\n      }\n\
    \      cells[cell.value][#cells[cell.value] + 1] = cell\n    end\n  end\n  --\
    \ perform dfs and check if the path is the shortest one\n  local shortest = {}\n\
    \  local function dfs(i, j, visited, k, path)\n    -- check if the path is the\
    \ shortest one\n    if k == 0 then\n      local lexicographically = false\n  \
    \    for i = 1, #path do\n        if path[i] < shortest[i] then\n          lexicographically\
    \ = true\n          break\n        elseif path[i] > shortest[i] then\n       \
    \   break\n        end\n      end\n      if lexicographically then\n        for\
    \ i = 1, #path do\n          shortest[i] = path[i]\n        end\n      end\n \
    \     return\n    end\n    -- visit all the neighboring cells\n    for di = -1,\
    \ 1 do\n      for dj = -1, 1 do\n        if di * di + dj * dj == 1 then\n    \
    \      local pi, pj = i + di, j + dj\n          if pi > 0 and pi <= #grid and\
    \ pj > 0 and pj <= #grid then\n            local neighbor = grid[pi][pj]\n   \
    \         if not", "\tk = tonumber(k)\n\t-- see\n\t--  https://www.youtube.com/watch?v=JZBQLXgSGfs&t=1s\n\
    \t--  https://www.youtube.com/watch?v=XKu_SEDAykw\n\tlocal n = #grid\n\tlocal\
    \ g = {}\n\tfor i = 1, n do\n\t\tg[i] = {}\n\t\tfor j = 1, n do\n\t\t\tg[i][j]\
    \ = tonumber(grid[i][j])\n\t\tend\n\tend\n\tlocal v = {}\n\tfor i = 1, n do\n\t\
    \tv[i] = {}\n\t\tfor j = 1, n do\n\t\t\tv[i][j] = {}\n\t\tend\n\tend\n\tlocal\
    \ dirs = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} }\n\tlocal function is_valid(i, j)\n\
    \t\treturn i >= 1 and i <= n and j >= 1 and j <= n\n\tend\n\tlocal function go(i,\
    \ j, k)\n\t\tif v[i][j][k] then\n\t\t\treturn v[i][j][k]\n\t\tend\n\t\tif k ==\
    \ 1 then\n\t\t\tv[i][j][k] = {g[i][j]}\n\t\t\treturn v[i][j][k]\n\t\tend\n\t\t\
    local res = nil\n\t\tfor _, dir in ipairs(dirs) do\n\t\t\tlocal x, y = i + dir[1],\
    \ j + dir[2]\n\t\t\tif is_valid(x, y) then\n\t\t\t\tlocal path = go(x, y, k -\
    \ 1)\n\t\t\t\tif not res or path[1] < res[1] then\n\t\t\t\t\tres = path\n\t\t\t\
    \tend\n\t\t\tend\n\t\tend\n\t\tv[i][j][k] = { g[i][j] }\n\t\tfor i = 1, #res do\n\
    \t\t\tv[i][j][k][i + 1] = res[i]\n\t\tend\n", "    local n = #grid\n    local\
    \ scores = {}\n    for r, row in ipairs(grid) do\n        scores[r] = {}\n   \
    \     for c, val in ipairs(row) do\n            scores[r][c] = {val, 0}\n    \
    \    end\n    end\n    local function isOutside(r, c)\n        return r < 1 or\
    \ r > n or c < 1 or c > n\n    end\n    local function compare(s1, s2)\n     \
    \   if s1[2] ~= s2[2] then\n            return s1[2] < s2[2]\n        end\n  \
    \      return s1[1] < s2[1]\n    end\n    local function dfs(r, c, val, d, k)\n\
    \        if isOutside(r, c) or d > k then\n            return\n        end\n \
    \       if d == k then\n            scores[r][c] = {val, d}\n            return\n\
    \        end\n        for dr = -1, 1 do\n            for dc = -1, 1 do\n     \
    \           if not (dr == 0 and dc == 0) then\n                    dfs(r + dr,\
    \ c + dc, val + grid[r + dr][c + dc], d + 1, k)\n                end\n       \
    \     end\n        end\n    end\n    for r = 1, n do\n        for c = 1, n do\n\
    \            dfs(r, c, grid[r][c], 1, k)\n        end\n    end\n    local minVal\
    \ = nil\n    for r = 1, n do\n        for c = 1, n do\n            if not minVal\
    \ or compare(scores[r][c], minVal) then\n                minVal = scores[r][c]\n\
    \            end\n        end\n    end\n    return minVal\nend", "  local M =\
    \ #grid\n  local N = #grid[1]\n  local ans = {}\n  local best = {}\n  local visited\
    \ = {}\n  local cur = {}\n  local function bfs(x, y)\n    local l = { { x, y }\
    \ }\n    local l2 = {}\n    local f = {}\n    f[x] = {}\n    f[x][y] = true\n\
    \    for i = 1, k do\n      for j = 1, #l do\n        local x, y = l[j][1], l[j][2]\n\
    \        cur[#cur + 1] = grid[x][y]\n        if grid[x][y] == i then\n       \
    \   visited[x] = visited[x] or {}\n          visited[x][y] = true\n        end\n\
    \        if i == k then\n          if not best[1] or best < cur then\n       \
    \     best = {}\n            for _, v in ipairs(cur) do\n              best[#best\
    \ + 1] = v\n            end\n          end\n        else\n          if x + 1 <=\
    \ M and not f[x + 1] then\n            f[x + 1] = {}\n            f[x + 1][y]\
    \ = true\n            l2[#l2 + 1] = { x + 1, y }\n          end\n          if\
    \ x - 1 >= 1 and not f[x - 1] then\n            f[x - 1] = {}\n            f[x\
    \ - 1][y] = true\n            l2[#l2 + 1] = { x - 1, y }\n          end\n    \
    \      if y + 1 <= N and not f[x][y + 1] then\n            f[x][y + 1] = true\n\
    \            l2[#l2 + 1] = { x, y + 1 }\n          end\n          if y - 1 >=\
    \ 1 and not f[x][y - 1] then\n            f[x][y - 1] = true\n            l2[#l2\
    \ + 1] = { x, y - 1 }\n          end\n        end\n      end\n      l = l2\n \
    \     l2 = {}\n    end\n    for i = 1, #cur do\n      cur[i] = nil", "  local\
    \ N = #grid\n  local h = {}\n  local init = false\n  local dp = {}\n  for i =\
    \ 1, N do\n    dp[i] = {}\n    for j = 1, N do\n      dp[i][j] = -1\n    end\n\
    \  end\n  local function key(i, j, k)\n    return i * N * N + j * N + k\n  end\n\
    \  local function dfs(i, j, k)\n    local kk = key(i, j, k)\n    if h[kk] then\n\
    \      return h[kk]\n    end\n    if k == 0 then\n      h[kk] = {}\n      return\
    \ h[kk]\n    end\n    if not init then\n      dp[1][1] = grid[1][1]\n      init\
    \ = true\n    end\n    if dp[i][j] ~= -1 then\n      if dp[i][j] > k then\n  \
    \      h[kk] = {}\n        return h[kk]\n      end\n    end\n    local ans = {}\n\
    \    if i - 1 >= 1 then\n      local tmp = dfs(i - 1, j, k - 1)\n      for _,\
    \ v in ipairs(tmp) do\n        if v < grid[i][j] then\n          table.insert(ans,\
    \ v)\n        end\n      end\n    end\n    if j - 1 >= 1 then\n      local tmp\
    \ = dfs(i, j - 1, k - 1)\n      for _, v in ipairs(tmp) do\n        if v < grid[i][j]\
    \ then\n          table.insert(ans, v)\n        end\n      end\n    end\n    table.insert(ans,\
    \ grid[i][j])\n    table.sort(ans)\n    h[kk] = ans\n    dp[i][j] = #ans\n   \
    \ return ans\n  end\n  local ans = dfs(N, N, k)\n  local anss = {}\n  for _, v\
    \ in ipairs(ans) do\n    if v == grid[N][N] then\n      table.insert(anss, v)\n\
    \    end\n  end\n  return", "    local gridSize = #grid\n    local cellToIndex\
    \ = {}\n    local indexToCell = {}\n    local i = 1\n    for row = 1, gridSize\
    \ do\n        for col = 1, gridSize do\n            cellToIndex[row .. ':' ..\
    \ col] = i\n            indexToCell[i] = {row, col}\n            i = i + 1\n \
    \       end\n    end\n    local edges = {}\n    for i = 1, gridSize * gridSize\
    \ do\n        edges[i] = {}\n    end\n    for i = 1, gridSize * gridSize do\n\
    \        local row, col = indexToCell[i][1], indexToCell[i][2]\n        if row\
    \ > 1 then\n            edges[i][cellToIndex[row - 1 .. ':' .. col]] = 1\n   \
    \     end\n        if row < gridSize then\n            edges[i][cellToIndex[row\
    \ + 1 .. ':' .. col]] = 1\n        end\n        if col > 1 then\n            edges[i][cellToIndex[row\
    \ .. ':' .. col - 1]] = 1\n        end\n        if col < gridSize then\n     \
    \       edges[i][cellToIndex[row .. ':' .. col + 1]] = 1\n        end\n    end\n\
    \    local function getIncomingEdges(index)\n        local incomingEdges = {}\n\
    \        for i = 1, gridSize * gridSize do\n            if edges[i][index] then\n\
    \                incomingEdges[#incomingEdges + 1] = i\n            end\n    \
    \    end\n        return incomingEdges\n    end\n    local function getOutgoingEdges(index)\n\
    \        local outgoingEdges = {}\n        for i = 1, gridSize * gridSize do\n\
    \            if edges[index][i] then\n                outgoingEdges[#outgoingEdges\
    \ + 1] = i\n            end\n        end\n        return outgoingEdges\n    end\n\
    \    local function leastLexicographicPath(paths)\n        local pathsByValue\
    \ = {}\n        for i = 1, #paths do\n            local path = paths[i]\n    \
    \        local value = grid[indexToCell[path[#path]][1]][indexToCell[path[#path]][2]]\n\
    \            if not", "  local N = #grid\n  assert(N >= 2 and k >= 1 and k <=\
    \ N * N, 'invalid parameter')\n  local path = {}\n  for i = 1, k do\n    local\
    \ min_v, min_i, min_j = math.huge\n    for i = 1, N do\n      for j = 1, N do\n\
    \        if grid[i][j] < min_v then\n          min_v, min_i, min_j = grid[i][j],\
    \ i, j\n        end\n      end\n    end\n    table.insert(path, min_v)\n    grid[min_i][min_j]\
    \ = math.huge\n  end\n  return path\nend", "    local path_grid = {}\n    local\
    \ f = function(i, j, path)\n        local min_path = nil\n        for i = 1, #grid\
    \ do\n            for j = 1, #grid[i] do\n                if grid[i][j] == true\
    \ then\n                    local current_path = f(i, j, {grid[i][j]})\n     \
    \               if not min_path or current_path < min_path then\n            \
    \            min_path = current_path\n                    end\n              \
    \  end\n            end\n        end\n        return min_path\n    end\n    return\
    \ f(1, 1, {})\nend", "  return {}\nend", "    return {}\nend", '    local n =
    #grid', "    local m, n = #grid, #grid[1]\n    local sum = 0\n    for i = 1, m\
    \ do\n        for j = 1, n do\n            sum = sum + grid[i][j]\n        end\n\
    \    end\n    local sum_pairs = {}\n    for i = 1, m do\n        for j = 1, n\
    \ do\n            sum_pairs[#sum_pairs + 1] = {grid[i][j], i, j}\n        end\n\
    \    end\n    table.sort(sum_pairs, function(a, b) return a[1] < b[1] end)\n \
    \   local path = {}\n    local path_value_sum = 0\n    for i = 1, k do\n     \
    \   path[i] = {sum_pairs[i][2], sum_pairs[i][3]}\n        path_value_sum = path_value_sum\
    \ + sum_pairs[i][1]\n    end\n    local res = {}\n    while true do\n        local\
    \ curr_path_value_sum = 0\n        for i = 1, k do\n            curr_path_value_sum\
    \ = curr_path_value_sum + grid[path[i][1]][path[i][2]]\n        end\n        if\
    \ curr_path_value_sum == sum then\n            break\n        end\n        local\
    \ w = 1\n        while w <= k do\n            local x, y = path[w][1], path[w][2]\n\
    \            local next_x, next_y = x, y\n            if w == 1 then\n       \
    \         if x < m and grid[x + 1][y] < grid[x][y] then\n                    next_x\
    \ = x + 1\n                elseif y < n and grid[x][y + 1] < grid[x][y] then\n\
    \                    next_y = y + 1\n                elseif x > 1 and grid[x -\
    \ 1][y] < grid[x][y] then\n                    next_x = x - 1\n              \
    \  elseif y > 1 and grid[x][y - 1] < grid[x][y] then\n                    next_y\
    \ = y - 1\n                end\n            else\n                local t_x, t",
  "    local m, n = #grid, #grid[1]\n    local minv, minp = math.huge, {}\n    local\
    \ kk = k + 1\n    local p = {}\n    local function dfs(i, j, d, v)\n        if\
    \ i >= 1 and i <= m and j >= 1 and j <= n and not p[i * kk + j] then\n       \
    \     v = v + grid[i][j]\n            p[i * kk + j] = true\n            if d ==\
    \ k then\n                if v < minv then\n                    minv = v\n   \
    \                 minp = {}\n                    for i = 1, k do\n           \
    \             minp[i] = grid[p[i * kk]][p[i * kk + 1]]\n                    end\n\
    \                end\n            else\n                dfs(i - 1, j, d + 1, v)\n\
    \                dfs(i + 1, j, d + 1, v)\n                dfs(i, j - 1, d + 1,\
    \ v)\n                dfs(i, j + 1, d + 1, v)\n            end\n            p[i\
    \ * kk + j] = nil\n        end\n    end\n    for i = 1, m do\n        for j =\
    \ 1, n do\n            dfs(i, j, 1, 0)\n        end\n    end\n    return minp\n\
    end", "    local n = #grid\n    local mem = {}\n    local function go(x, y, path)\n\
    \        if x < 1 or x > n or y < 1 or y > n then\n            return nil\n  \
    \      end\n        local key = string.format('%d:%d:%d', x, y, k)\n        if\
    \ mem[key] then\n            return mem[key]\n        end\n        local value\
    \ = grid[x][y]\n        local path_v = path .. value\n        if k == 1 then\n\
    \            mem[key] = path_v\n            return path_v\n        end\n     \
    \   local min = nil\n        local path_new = path_v .. ':'\n        local v\n\
    \        v = go(x - 1, y, path_new)\n        if v and (not min or v < min) then\n\
    \            min = v\n        end\n        v = go(x + 1, y, path_new)\n      \
    \  if v and (not min or v < min) then\n            min = v\n        end\n    \
    \    v = go(x, y - 1, path_new)\n        if v and (not min or v < min) then\n\
    \            min = v\n        end\n        v = go(x, y + 1, path_new)\n      \
    \  if v and (not min or v < min) then\n            min = v\n        end\n    \
    \    mem[key] = min\n        return min\n    end\n    local path = go(1, 1, '')\n\
    \    local result = {}\n    for value in string.gmatch(path, '([^:]+)') do\n \
    \       table.insert(result, tonumber(value))\n    end\n    return result\nend",
  "    local n = #grid\n    local q = {}\n    local flag = {}\n    local cur = {}\n\
    \    local start = 1\n    local dst = {}\n    local function dfs(x, y, len, sum)\n\
    \        if x > n or y > n or x < 1 or y < 1 then\n            return\n      \
    \  end\n        if len == k then\n            if not dst[sum] then\n         \
    \       dst[sum] = {grid[x][y]}\n            else\n                table.insert(dst[sum],\
    \ grid[x][y])\n            end\n            return\n        end\n        if not\
    \ flag[x][y] then\n            flag[x][y] = true\n            dfs(x, y + 1, len\
    \ + 1, sum + grid[x][y])\n            dfs(x, y - 1, len + 1, sum + grid[x][y])\n\
    \            dfs(x + 1, y, len + 1, sum + grid[x][y])\n            dfs(x - 1,\
    \ y, len + 1, sum + grid[x][y])\n            flag[x][y] = false\n        end\n\
    \    end\n    for i = 1, n do\n        flag[i] = {}\n    end\n    for i = 1, n\
    \ do\n        for j = 1, n do\n            dfs(i, j, 1, grid[i][j])\n        end\n\
    \    end\n    local res = {}\n    for k, v in pairs(dst) do\n        if not res[1]\
    \ then\n            res = v\n        else\n            if #v < #res then\n   \
    \             res = v\n            elseif #v == #res then\n                for\
    \ i = 1, #v do\n                    if v[i] < res[i] then\n                  \
    \      res = v\n                        break\n                    elseif v[i]\
    \ > res[i] then\n                        break\n                    end\n    \
    \            end\n            end\n        end\n    end\n    return res\nend",
  end, "    local n = #grid\n    local heap = pq.new()\n    heap:push({ idx = 1, val\
    \ = grid[1][1] }, 0)\n    local max_dist = k - 1\n    local visited = {}\n   \
    \ local dist = {}\n    local prev = {}\n    while not heap:empty() do\n      \
    \  local cur = heap:pop()\n        if cur.idx == n * n then\n            local\
    \ path = {}\n            local u = cur.idx\n            while u ~= 1 do\n    \
    \            path[#path + 1] = grid[1 + (u - 1) // n][1 + (u - 1) % n]\n     \
    \           u = prev[u]\n            end\n            path[#path + 1] = grid[1][1]\n\
    \            return table.reverse(path)\n        end\n        local row = 1 +\
    \ (cur.idx - 1) // n\n        local col = 1 + (cur.idx - 1) % n\n        for _,\
    \ nb in ipairs({{row - 1, col}, {row + 1, col}, {row, col - 1}, {row, col + 1}})\
    \ do\n            local nb_row, nb_col = nb[1], nb[2]\n            if nb_row >=\
    \ 1 and nb_row <= n and nb_col >= 1 and nb_col <= n then\n                local\
    \ nb_idx = 1 + (nb_row - 1) * n + (nb_col - 1)\n                if not visited[nb_idx]\
    \ then\n                    local nb_dist = dist[cur.idx] + 1\n              \
    \      if nb_dist <= max_dist then\n                        visited[nb_idx] =\
    \ true\n                        dist[nb_idx] = nb_dist\n                     \
    \   prev[nb_idx] = cur.idx\n                        heap:push({ idx = nb_idx,\
    \ val = grid[nb_row][nb_col] }, grid[nb_row][nb_col])\n                    end\n\
    \                end\n            end\n        end\n    end\n    return {}\nend",
  "    error('not implemented')\nend", "    local M = #grid\n    local N = #grid[1]\n\
    \    local visited = {}\n    local all_paths = {}\n    local function dfs(x, y,\
    \ path)\n        if visited[x] and visited[x][y] then\n            return\n  \
    \      end\n        if x < 1 or x > M or y < 1 or y > N then\n            return\n\
    \        end\n        if #path == k then\n            local min_path = path\n\
    \            local min_path_value = tonumber(path:gsub('%D', ''))\n          \
    \  for _, p in ipairs(all_paths) do\n                local p_value = tonumber(p:gsub('%D',\
    \ ''))\n                if p_value < min_path_value then\n                   \
    \ min_path = p\n                    min_path_value = p_value\n               \
    \ end\n            end\n            all_paths[#all_paths + 1] = min_path\n   \
    \         return\n        end\n        path = path .. grid[x][y]\n        visited[x]\
    \ = visited[x] or {}\n        visited[x][y] = true\n        dfs(x - 1, y, path)\n\
    \        dfs(x + 1, y, path)\n        dfs(x, y - 1, path)\n        dfs(x, y +\
    \ 1, path)\n        visited[x][y] = false\n    end\n    for i = 1, M do\n    \
    \    for j = 1, N do\n            dfs(i, j, '')\n        end\n    end\n    return\
    \ all_paths[1]\nend", "    local N = #grid\n    local function getCost(i, j)\n\
    \        return k - i + j - 1, grid[i][j]\n    end\n    local function heuristic(i,\
    \ j)\n        local cx, cy = (N + 1) / 2, (N + 1) / 2\n        return math.abs(i\
    \ - cx) + math.abs(j - cy)\n    end\n    local function getNeighbours(i, j)\n\
    \        local ns = {}\n        if i > 1 then\n            ns[#ns + 1] = {i -\
    \ 1, j}\n        end\n        if i < N then\n            ns[#ns + 1] = {i + 1,\
    \ j}\n        end\n        if j > 1 then\n            ns[#ns + 1] = {i, j - 1}\n\
    \        end\n        if j < N then\n            ns[#ns + 1] = {i, j + 1}\n  \
    \      end\n        return ns\n    end\n    local minPath\n    local minCost =\
    \ 0\n    local openList = { {getCost(1, 1), 1, 1} }\n    local visited = {}\n\
    \    local heur = 0\n    while #openList > 0 do\n        local i, j = openList[1][2],\
    \ openList[1][3]\n        table.remove(openList, 1)\n        if visited[i] and\
    \ visited[i][j] then\n            goto continue\n        end\n        visited[i]\
    \ = visited[i] or {}\n        visited[i][j] = true\n        local path = {grid[i][j]}\n\
    \        local cost = getCost(i, j)\n        heur = heur + 1\n        if cost\
    \ == minCost then\n            if #minPath > #path then\n                minPath\
    \ = path\n            elseif #minPath == #path then\n                local cmp\
    \ = 0\n                for _, v in ipairs(minPath) do\n                    if\
    \ v < path[cmp + 1] then\n                        break\n                    elseif\
    \ v > path[cmp + 1] then\n                        minPath = path\n           \
    \             break\n                    end\n                    cmp = cmp +\
    \ 1\n                end\n            end\n        elseif cost < minCost then",
  "\tif not grid or #grid == 0 or k <= 0 then\n\t\treturn {}\n\tend\n\tlocal len =\
    \ #grid\n\tlocal dp = {}\n\tlocal prev = {}\n\tlocal n = 1\n\tfor i = 1, len do\n\
    \t\tdp[i] = {}\n\t\tprev[i] = {}\n\t\tfor j = 1, len do\n\t\t\tdp[i][j] = {}\n\
    \t\t\tprev[i][j] = {}\n\t\t\tfor m = 1, k do\n\t\t\t\tdp[i][j][m] = math.huge\n\
    \t\t\t\tprev[i][j][m] = {}\n\t\t\tend\n\t\tend\n\tend\n\tdp[1][1][1] = grid[1][1]\n\
    \tprev[1][1][1] = {i = 0, j = 0}\n\twhile n <= k do\n\t\tfor i = 1, len do\n\t\
    \t\tfor j = 1, len do\n\t\t\t\tif i + 1 <= len then\n\t\t\t\t\tif dp[i + 1][j][n]\
    \ > dp[i][j][n - 1] + grid[i + 1][j] then\n\t\t\t\t\t\tdp[i + 1][j][n] = dp[i][j][n\
    \ - 1] + grid[i + 1][j]\n\t\t\t\t\t\tprev[i + 1][j][n] = {i = i, j = j}\n\t\t\t\
    \t\tend\n\t\t\t\tend\n\t\t\t\tif j + 1 <= len then\n\t\t\t\t\tif dp[i][j + 1][n]\
    \ > dp[i][j][n - 1] + grid[i][j + 1] then\n\t\t\t\t\t\tdp[i][j + 1][n] = dp[i][j][n\
    \ - 1] + grid[i][j + 1]\n\t\t\t\t\t\tprev[i][j + 1][n] = {i = i, j = j}\n\t\t\t\
    \t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tn = n + 1\n\tend\n\t", "    local\
    \ n = #grid\n    assert(n >= 2 and n <= 100)\n    assert(k > 0 and k <= n * n)\n\
    \    local seen = {}\n    local table_insert = table.insert\n    local heap =\
    \ { { grid[1][1], { 1, 1 }, 1 } }\n    local heap_pop = heap.pop\n    local heap_push\
    \ = heap.push\n    local function compare(a, b)\n        for i = 1, a[3] do\n\
    \            if a[1][i] < b[1][i] then\n                return true\n        \
    \    elseif a[1][i] > b[1][i] then\n                return false\n           \
    \ end\n        end\n        return false\n    end\n    while true do\n       \
    \ local best = heap_pop(heap, compare)\n        local path, p, len = best[1],\
    \ best[2], best[3]\n        if len == k then\n            return path\n      \
    \  end\n        local x, y = p[1], p[2]\n        seen[x] = seen[x] or {}\n   \
    \     seen[x][y] = true\n        local function push(x, y)\n            if x >=\
    \ 1 and x <= n and y >= 1 and y <= n and not seen[x][y] then\n               \
    \ local next_path = {}\n                for i = 1, len do\n                  \
    \  next_path[i] = path[i]\n                end\n                next_path[len\
    \ + 1] = grid[x][y]\n                heap_push(heap, { next_path, { x, y }, len\
    \ + 1 })\n            end\n        end\n        push(x - 1, y)\n        push(x\
    \ + 1, y)\n        push(x, y - 1)\n        push(x, y + 1)\n    end\nend", "  local\
    \ path = {}\n  local lst = {}\n  for i = 1, k do\n    path[i] = {}\n    for j\
    \ = 1, k do\n      path[i][j] = {-1, -1}\n    end\n  end\n  for i = 1, k do\n\
    \    path[1][i][1] = 1\n    path[1][i][2] = i\n    path[i][1][1] = i\n    path[i][1][2]\
    \ = 1\n  end\n  for i = 2, k do\n    for j = 2, k do\n      local a = grid[path[i-1][j][1]][path[i-1][j][2]]\n\
    \      local b = grid[path[i][j-1][1]][path[i][j-1][2]]\n      if a < b then\n\
    \        path[i][j][1] = path[i-1][j][1]\n        path[i][j][2] = path[i-1][j][2]\n\
    \      elseif a > b then\n        path[i][j][1] = path[i][j-1][1]\n        path[i][j][2]\
    \ = path[i][j-1][2]\n      else\n        path[i][j][1] = path[i-1][j][1]\n   \
    \     path[i][j][2] = path[i-1][j][2]\n      end\n    end\n  end\n  local x =\
    \ k\n  local y = k\n  lst[k] = grid[x][y]\n  for i = k-1, 1, -1 do\n    if path[i][y][1]\
    \ == x then\n      y = y - 1\n    else\n      x = x - 1\n    end\n    lst[i] =\
    \ grid[x][y]\n  end\n  return lst\nend", "  --return {1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9}\n  -- your code here\n  local N = #grid\n  local mask = {}\n  for i = 1,\
    \ N do\n    local row = {}\n    for j = 1, N do\n      row[j] = -1\n    end\n\
    \    mask[i] = row\n  end\n  --print(N)\n  --print(grid[1][1])\n  --print(mask[1][1])\n\
    \  local function get_mask(grid, mask, k)\n    local function min_path(grid, mask,\
    \ k, x, y)\n      local N = #grid\n      if mask[x][y] == -1 then\n        if\
    \ k == 1 then\n          mask[x][y] = grid[x][y]\n        else\n          local\
    \ t = {}\n          local up = true\n          local down = true\n          local\
    \ left = true\n          local right = true\n          if x == 1 then\n      \
    \      up = false\n          end\n          if x == N then\n            down =\
    \ false\n          end\n          if y == 1 then\n            left = false\n \
    \         end\n          if y == N then\n            right = false\n         \
    \ end\n          if up then\n            table.insert(t, min_path(grid, mask,\
    \ k - 1, x - 1, y))\n          end\n          if down then\n            table.insert(t,\
    \ min_path(grid, mask, k - 1, x + 1, y))\n          end\n          if left then\n\
    \            table.insert(t, min_path(grid, mask, k - 1, x, y - 1))\n        \
    \  end\n          if right then\n            table.insert(t, min_path(grid, mask,\
    \ k - 1, x, y + 1))\n          end\n          table.sort(t)\n          --print(#t)\n\
    \          local min_path = {}\n          local n = #t\n          for i = 1, n\
    \ do\n            local m = #t[i]\n            for j = 1, m do\n             \
    \ table.insert(min_path, t[i][j])\n            end\n          end\n          table.insert(min_path,",
  "\tlocal function isInBound(i, j)\n\t\treturn 1 <= i and i <= #grid and 1 <= j and\
    \ j <= #grid[1]\n\tend\n\tlocal function isLegalMove(i, j, last)\n\t\treturn isInBound(i,\
    \ j) and (i - last[1] == 0 or j - last[2] == 0)\n\tend\n\tlocal function findMinPath(i,\
    \ j, k, last, path)\n\t\tif k == 0 then\n\t\t\treturn path\n\t\tend\n\t\tlocal\
    \ moves = { {i - 1, j}, {i + 1, j}, {i, j - 1}, {i, j + 1} }\n\t\tlocal minPath,\
    \ minMove\n\t\tfor _, m in ipairs(moves) do\n\t\t\tif isLegalMove(m[1], m[2],\
    \ last) then\n\t\t\t\tpath[#path + 1] = grid[m[1]][m[2]]\n\t\t\t\tlocal p = findMinPath(m[1],\
    \ m[2], k - 1, m, path)\n\t\t\t\tif not minPath or p < minPath then\n\t\t\t\t\t\
    minPath = p\n\t\t\t\t\tminMove = m\n\t\t\t\tend\n\t\t\t\tpath[#path] = nil\n\t\
    \t\tend\n\t\tend\n\t\treturn minPath, minMove\n\tend\n\tlocal path = { grid[1][1]\
    \ }\n\tlocal p, last = findMinPath(1, 1, k - 1, {1, 1}, path)\n\tlocal moves =\
    \ { {last[1] - 1, last[2]}, {last[1] + 1, last[2]}, {last[1], last[2] - 1}, {last[1],\
    \ last[2] + 1} }\n\tfor _, m in ipairs(moves) do\n\t\tif isLegalMove(m[1], m[2],\
    \ last) then\n\t\t\tpath[#path + 1] = grid[m[1]][m[2]]\n\t\t\tlocal t = findMinPath(m[1],\
    \ m[2], k - 1, m, path)\n\t\t", "    local function get_min_path(grid, node)\n\
    \        local path = {}\n        local set = {}\n        set[node] = true\n \
    \       while k > 0 do\n            local min_value, min_node = math.huge, nil\n\
    \            for _, neighbor in ipairs(node.neighbors) do\n                if\
    \ set[neighbor] then\n                    goto continue\n                end\n\
    \                if neighbor.value < min_value then\n                    min_value,\
    \ min_node = neighbor.value, neighbor\n                end\n            end\n\
    \            ::continue::\n            if min_node == nil then\n             \
    \   return path\n            end\n            table.insert(path, min_node.value)\n\
    \            node = min_node\n            set[node] = true\n            k = k\
    \ - 1\n        end\n        return path\n    end\n    -- make a graph from the\
    \ grid\n    local nodes = {}\n    for i = 1, #grid do\n        for j = 1, #grid[i]\
    \ do\n            local node = {\n                value = grid[i][j],\n      \
    \          neighbors = {},\n            }\n            local neighbors = {{i-1,\
    \ j}, {i+1, j}, {i, j-1}, {i, j+1}}\n            for _, neighbor in ipairs(neighbors)\
    \ do\n                local x, y = neighbor[1], neighbor[2]\n                if\
    \ x >= 1 and x <= #grid and y >= 1 and y <= #grid[i] then\n                  \
    \  table.insert(node.neighbors, nodes[(x-1)*#grid+y])\n                end\n \
    \           end\n            nodes[(i-1)*#grid+j] = node\n        end\n    end\n\
    \    -- find the minimum path\n    local min_path, min_value = {}, math.huge\n\
    \    for _, node in ipairs(nodes) do\n        local path = get_min_path(grid,\
    \ node)\n        local value = 0\n        for i = 1, #path do\n            value\
    \ = value * 10 + path[i]\n        end\n        if value < min_value then\n   \
    \         min_path, min_value = path, value\n        end\n    end\n    return\
    \ min_path\nend\n", "    local M = #grid\n    local path = {}\n    local minPath\
    \ = {}\n    local minSum = math.huge\n    local function dfs(row, col, sum, length)\n\
    \        local v = grid[row][col]\n        sum = sum + v\n        if length ==\
    \ k then\n            if sum < minSum then\n                minSum = sum\n   \
    \             for i = 1, #path do\n                    minPath[i] = path[i]\n\
    \                end\n            end\n            return\n        end\n     \
    \   if length > k then\n            return\n        end\n        local nextPath\
    \ = {}\n        for i = 1, length do\n            nextPath[i] = path[i]\n    \
    \    end\n        path = nextPath\n        path[length + 1] = v\n        if row\
    \ > 1 then\n            dfs(row - 1, col, sum, length + 1)\n        end\n    \
    \    if row < M then\n            dfs(row + 1, col, sum, length + 1)\n       \
    \ end\n        if col > 1 then\n            dfs(row, col - 1, sum, length + 1)\n\
    \        end\n        if col < M then\n            dfs(row, col + 1, sum, length\
    \ + 1)\n        end\n    end\n    for i = 1, M do\n        for j = 1, M do\n \
    \           dfs(i, j, 0, 0)\n        end\n    end\n    return minPath\nend", " \
    \ local n = #grid\n  local path = {}\n  local cost = {}\n  local visited = {}\n\
    \  local directions = { {0, -1}, {0, 1}, {-1, 0}, {1, 0} }\n  local function totalCost(r,\
    \ c)\n    local res = 0\n    for i = 1, #visited do\n      res = res + cost[visited[i][1]][visited[i][2]]\n\
    \    end\n    return res + cost[r][c]\n  end\n  local function dfs(r, c, k)\n\
    \    if k == 0 then\n      return totalCost(r, c)\n    end\n    local cur = cost[r][c]\n\
    \    cost[r][c] = math.huge\n    local min = math.huge\n    for _, dir in ipairs(directions)\
    \ do\n      local r2, c2 = r + dir[1], c + dir[2]\n      if r2 >= 1 and r2 <=\
    \ n and c2 >= 1 and c2 <= n then\n        local res = dfs(r2, c2, k - 1)\n   \
    \     if res < min then\n          min = res\n          path[k] = {r2, c2}\n \
    \       end\n      end\n    end\n    cost[r][c] = cur\n    return min\n  end\n\
    \  for i = 1, n do\n    cost[i] = {}\n    for j = 1, n do\n      cost[i][j] =\
    \ grid[i][j]\n    end\n  end\n  visited[1] = {1, 1}\n  local res = dfs(1, 1, k\
    \ - 1)\n  for i = 1, k do\n    visited[i + 1] = path[i]\n  end\n  local res =\
    \ {}\n  for i = 1, #visited do\n    res[i] = grid[visited[i][1]][visited[i][2]]\n\
    \  end\n  return res\nend", "  -- TODO\nend", "\tlocal n = #grid\n\tif n == 1\
    \ then\n\t\treturn grid[1][1]\n\tend\n\tlocal function push(x, y, acc)\n\t\tlocal\
    \ val = grid[x][y]\n\t\tlocal t = {x = x, y = y, acc = acc, val = val}\n\t\theap:push(t)\n\
    \tend\n\tlocal function isvalid(x, y)\n\t\treturn x >= 1 and x <= n and y >= 1\
    \ and y <= n\n\tend\n\tpush(1, 1, {})\n\tlocal p\n\twhile heap:size() > 0 do\n\
    \t\tp = heap:pop()\n\t\tif #p.acc + 1 == k then\n\t\t\tbreak\n\t\tend\n\t\tif\
    \ isvalid(p.x + 1, p.y) then\n\t\t\tpush(p.x + 1, p.y, p.acc)\n\t\tend\n\t\tif\
    \ isvalid(p.x - 1, p.y) then\n\t\t\tpush(p.x - 1, p.y, p.acc)\n\t\tend\n\t\tif\
    \ isvalid(p.x, p.y + 1) then\n\t\t\tpush(p.x, p.y + 1, p.acc)\n\t\tend\n\t\tif\
    \ isvalid(p.x, p.y - 1) then\n\t\t\tpush(p.x, p.y - 1, p.acc)\n\t\tend\n\tend\n\
    \tlocal res = {}\n\tfor i = 1, #p.acc do\n\t\tres[i] = p.acc[i]\n\tend\n\tres[#res\
    \ + 1] = p.val\n\treturn res\nend", "    local answer = {}\n    return answer\n\
    end", "    local m, n = #grid, #grid[1]\n    local function visit(x, y, k)\n \
    \       if k == 0 then\n            return {grid[x][y]}\n        end\n       \
    \ local res = nil\n        if x > 1 then\n            local new = visit(x - 1,\
    \ y, k - 1)\n            if res == nil or less(new, res) then\n              \
    \  res = new\n            end\n        end\n        if x < m then\n          \
    \  local new = visit(x + 1, y, k - 1)\n            if res == nil or less(new,\
    \ res) then\n                res = new\n            end\n        end\n       \
    \ if y > 1 then\n            local new = visit(x, y - 1, k - 1)\n            if\
    \ res == nil or less(new, res) then\n                res = new\n            end\n\
    \        end\n        if y < n then\n            local new = visit(x, y + 1, k\
    \ - 1)\n            if res == nil or less(new, res) then\n                res\
    \ = new\n            end\n        end\n        table.insert(res, 1, grid[x][y])\n\
    \        return res\n    end\n    local res = visit(1, 1, k)\n    for i = 1, m\
    \ do\n        for j = 1, n do\n            local new = visit(i, j, k)\n      \
    \      if less(new, res) then\n                res = new\n            end\n  \
    \      end\n    end\n    return res\nend", "\t-- \nend", "    local n = #grid\n\
    \    local function dfs(r, c, k, visited)\n        if k == 0 then\n          \
    \  return {grid[r][c]}\n        end\n        visited[r * n + c] = true\n     \
    \   local a, b, c, d = {}, {}, {}, {}\n        if r > 1 and not visited[(r - 1)\
    \ * n + c] then\n            a = dfs(r - 1, c, k - 1, visited)\n        end\n\
    \        if r < n and not visited[(r + 1) * n + c] then\n            b = dfs(r\
    \ + 1, c, k - 1, visited)\n        end\n        if c > 1 and not visited[r * n\
    \ + c - 1] then\n            c = dfs(r, c - 1, k - 1, visited)\n        end\n\
    \        if c < n and not visited[r * n + c + 1] then\n            d = dfs(r,\
    \ c + 1, k - 1, visited)\n        end\n        visited[r * n + c] = nil\n    \
    \    local res = {grid[r][c]}\n        if a[1] and (not b[1] or a[1] < b[1]) and\
    \ (not c[1] or a[1] < c[1]) and (not d[1] or a[1] < d[1]) then\n            for\
    \ i = 1, #a do\n                res[#res + 1] = a[i]\n            end\n      \
    \  elseif b[1] and (not c[1] or b[1] < c[1]) and (not d[1] or b[1] < d[1]) then\n\
    \            for i = 1, #b do\n                res[#res + 1] = b[i]\n        \
    \    end\n        elseif c[1] and (not d[1] or c[1] < d[1]) then\n           \
    \ for i = 1, #c do\n                res[#res + 1] = c[i]\n            end\n  \
    \      elseif d[1] then\n            for i = 1, #d do\n                res[#res\
    \ + 1] = d[i]\n            end\n        end", "  local n = #grid\n  local min_path\
    \ = {}\n  local cost_map = {}\n  local cost_map_helper = {}\n  local function\
    \ get_cost(i, j)\n    if cost_map[i] == nil then\n      cost_map[i] = {}\n   \
    \ end\n    if cost_map[i][j] == nil then\n      cost_map[i][j] = {}\n    end\n\
    \    if cost_map[i][j][k] ~= nil then\n      return cost_map[i][j][k]\n    end\n\
    \    if k == 1 then\n      return grid[i][j]\n    end\n    local min_cost = math.huge\n\
    \    local function helper(i, j, k)\n      if cost_map_helper[i] == nil then\n\
    \        cost_map_helper[i] = {}\n      end\n      if cost_map_helper[i][j] ==\
    \ nil then\n        cost_map_helper[i][j] = {}\n      end\n      if cost_map_helper[i][j][k]\
    \ ~= nil then\n        return cost_map_helper[i][j][k]\n      end\n      if k\
    \ == 1 then\n        cost_map_helper[i][j][k] = grid[i][j]\n        return cost_map_helper[i][j][k]\n\
    \      end\n      local min_helper = math.huge\n      if i > 1 then\n        min_helper\
    \ = math.min(min_helper, helper(i - 1, j, k - 1))\n      end\n      if i < n then\n\
    \        min_helper = math.min(min_helper, helper(i + 1, j, k - 1))\n      end\n\
    \      if j > 1 then\n        min_helper = math.min(min_helper, helper(i, j -\
    \ 1, k - 1))\n      end\n      if j < n then\n        min_helper = math.min(min_helper,\
    \ helper(i, j + 1, k - 1))\n      end\n      cost_map_helper[i][j][k] = min_helper\n\
    \     ", "  return nil\nend", "    local count = 1\n    local paths = {}\n   \
    \ local vistied = {}\n    local function dfs(i, j, path)\n        if count >=\
    \ k then\n            paths[1] = paths[1] or path\n            if path < paths[1]\
    \ then\n                paths[1] = path\n            end\n            return\n\
    \        end\n        count = count + 1\n        local path = path .. grid[i][j]\n\
    \        vistied[i] = vistied[i] or {}\n        vistied[i][j] = true\n       \
    \ if i < #grid then\n            if not vistied[i + 1] or not vistied[i + 1][j]\
    \ then\n                dfs(i + 1, j, path)\n            end\n        end\n  \
    \      if i > 1 then\n            if not vistied[i - 1] or not vistied[i - 1][j]\
    \ then\n                dfs(i - 1, j, path)\n            end\n        end\n  \
    \      if j < #grid then\n            if not vistied[i] or not vistied[i][j +\
    \ 1] then\n                dfs(i, j + 1, path)\n            end\n        end\n\
    \        if j > 1 then\n            if not vistied[i] or not vistied[i][j - 1]\
    \ then\n                dfs(i, j - 1, path)\n            end\n        end\n  \
    \      count = count - 1\n        vistied[i][j] = false\n    end\n    local n\
    \ = #grid\n    for i = 1, n do\n        for j = 1, n do\n            if not vistied[i]\
    \ or not vistied[i][j] then\n                dfs(i, j, '')\n            end\n\
    \        end\n    end\n    return paths[1]\nend", "  local len = #grid\n  local\
    \ values = {}\n  for i = 1, len do\n    for j = 1, len do\n      local v = grid[i][j]\n\
    \      values[v] = { x = i, y = j }\n    end\n  end\n  local function is_in_grid(x,\
    \ y)\n    return x >= 1 and x <= len and y >= 1 and y <= len\n  end\n  local directions\
    \ = {\n    { 0, 1 },\n    { 1, 0 },\n    { 0, -1 },\n    { -1, 0 },\n  }\n  local\
    \ function dfs(x, y, k, curr_path)\n    if k == 0 then\n      return curr_path\n\
    \    end\n    local curr_val = grid[x][y]\n    curr_path[curr_val] = true\n  \
    \  local min_path\n    for _, d in ipairs(directions) do\n      local nx, ny =\
    \ x + d[1], y + d[2]\n      if is_in_grid(nx, ny) then\n        local nval = grid[nx][ny]\n\
    \        if not curr_path[nval] then\n          local p = dfs(nx, ny, k - 1, curr_path)\n\
    \          if not min_path or p < min_path then\n            min_path = p\n  \
    \        end\n        end\n      end\n    end\n    curr_path[curr_val] = nil\n\
    \    return min_path\n  end\n  local start_value = 1\n  local min_path = dfs(values[start_value].x,\
    \ values[start_value].y, k, {})\n  local result = {}\n  for i = 1, len * len do\n\
    \    if min_path[i] then\n      table.insert(result, i)\n    end\n  end\n  return\
    \ result\nend", "  -- Write your code here\n  -- To print results to the standard\
    \ output you can use print\n  -- Example:\n  -- print(\"Hello world!\")\nend\n\
    minPath({\n  {1,2,3},\n  {4,5,6},\n  {7,8,9}\n}, 5)\nprint(\"Expected result is\
    \ [1, 2, 4, 5, 8]\")\nprint(\"------------------------------\")\nminPath({\n \
    \ {8,9,9,1},\n  {7,5,4,4},\n  {4,4,7,4},\n  {8,9,9,1}\n}, 4)\nprint(\"Expected\
    \ result is [8, 5, 4, 7]\")\nprint(\"------------------------------\")\nminPath({\n\
    \  {1,1,1,1},\n  {1,1,1,1},\n  {1,1,1,1},\n  {1,1,1,1}\n}, 5)\nprint(\"Expected\
    \ result is [1, 1, 1, 1, 1]\")\nprint(\"------------------------------\")\nminPath({\n\
    \  {1,1,1,1},\n  {1,1,1,1},\n  {1,1,1,1},\n  {1,1,1,1}\n}, 4)\nprint(\"Expected\
    \ result is [1, 1, 1, 1]\")\nprint(\"------------------------------\")\nminPath({\n\
    \  {9,9,9,9},\n  {9,1,1,9},\n  {9,1,1,9},\n  {9,9,9,9}\n}, 4)\nprint(\"Expected\
    \ result is [9, 1, 1, 9]\")\nprint(\"------------------------------\")\nminPath({\n\
    \  {8,4,4,4},\n  {4,4,4,4},\n  {4,4,4,4},\n  {8,4,4,4}\n}, 5)\nprint(\"Expected\
    \ result is [8, 4, 4, 4, 8]\")\nprint(\"------------------------------\")\nminPath({\n\
    \  {1,1,1,1},\n  {2,2,2,2},\n  {3,3,3,3", "    -- write your code here\nend",
  "    local N = #grid\n    local dp = {}\n    local r, c\n    for r = 1, N do\n \
    \       dp[r] = {}\n        for c = 1, N do\n            dp[r][c] = {}\n     \
    \   end\n    end\n    for r = 1, N do\n        for c = 1, N do\n            if\
    \ (r == 1) and (c == 1) then\n                dp[r][c][1] = grid[r][c]\n     \
    \       elseif (r == 1) then\n                dp[r][c][1] = dp[r][c - 1][1] +\
    \ grid[r][c]\n            elseif (c == 1) then\n                dp[r][c][1] =\
    \ dp[r - 1][c][1] + grid[r][c]\n            else\n                local min1 =\
    \ dp[r - 1][c][1]\n                local min2 = dp[r][c - 1][1]\n            \
    \    if min1 < min2 then\n                    dp[r][c][1] = min1 + grid[r][c]\n\
    \                else\n                    dp[r][c][1] = min2 + grid[r][c]\n \
    \               end\n            end\n        end\n    end\n    for n = 2, k do\n\
    \        for r = 1, N do\n            for c = 1, N do\n                local min1,\
    \ min2, min3\n                if (r == 1) and (c == 1) then\n                \
    \    min1 = 2 * dp[r][c][1] - grid[r][c]\n                    min2 = 2 * dp[r][c][1]\
    \ - grid[r][c]\n                    min3 = 2 * dp[r][c][1] - grid[r][c]\n    \
    \            elseif (r == 1) then\n                    min1 = dp[r][c - 1][n -\
    \ 1] + grid[r][c]\n                    min2 = dp[r][c - 1][n] + grid[r][c]\n \
    \                   min3 = 2 * dp[r][c][1] - grid[r][c]\n                elseif\
    \ (c == 1) then\n", "    local n = #grid\n    local function inc(x, y)\n     \
    \   local r = x < n and grid[x + 1][y] or x\n        local d = y < n and grid[x][y\
    \ + 1] or y\n        local rd = x < n and y < n and grid[x + 1][y + 1] or grid[x][y]\n\
    \        return r, d, rd\n    end\n    local cache = {}\n    local function dfs(x,\
    \ y, k)\n        if k == 0 then\n            return grid[x][y]\n        end\n\
    \        local key = string.format('%d,%d,%d', x, y, k)\n        if cache[key]\
    \ then\n            return cache[key]\n        end\n        local r, d, rd = inc(x,\
    \ y)\n        local m = math.min(dfs(x, y, k - 1), dfs(r, y, k - 1), dfs(x, d,\
    \ k - 1), dfs(rd, rd, k - 1))\n        cache[key] = m\n        return m\n    end\n\
    \    local function bfs(x, y, k)\n        local index = 0\n        local queue\
    \ = {}\n        local visited = {}\n        local key = string.format('%d,%d,%d',\
    \ x, y, k)\n        visited[key] = true\n        queue[index] = {\n          \
    \  x = x,\n            y = y,\n            k = k,\n            count = grid[x][y],\n\
    \        }\n        while index >= 0 do\n            local top = queue[index]\n\
    \            index = index - 1\n            local r, d, rd = inc(top.x, top.y)\n\
    \            if not visited[string.format('%d,%d,%d', r, top.y, top.k - 1)] then\n\
    \                visited[string.format('%d,%d,%d', r, top.y, top.k - 1)] = true\n\
    \                index = index + 1\n                queue[index] = {\n       \
    \             x = r,\n                    y = top.y,\n                    k =\
    \ top.k - 1,\n                   ", "  -- your code here\nend", "\tlocal n = #grid\n\
    \tlocal memo = {}\n\t\n\t-- The tricky part of this problem is the fact that a\
    \ path A (of length k)\n\t-- is considered less than a path B (of length k) if\
    \ after making the\n\t-- ordered lists of the values on the cells that A and B\
    \ go through\n\t-- (let's call them lst_A and lst_B), lst_A is lexicographically\
    \ less\n\t-- than lst_B, in other words, there exist an integer index i (1 <=\
    \ i <= k)\n\t-- such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n\
    \t-- lst_A[j] = lst_B[j].\n\t-- Once we know the value of the min path until a\
    \ cell of row i, column j\n\t-- with length h, we can try to improve it only with\
    \ the paths that contain\n\t-- that cell, since the rest of the paths are larger\
    \ than that one.\n\tlocal function helper(i, j, h)\n\t\tlocal key = i * n * k\
    \ + j * k + h\n\t\tif memo[key] then\n\t\t\treturn memo[key]\n\t\tend\n\t\tif\
    \ h == 1 then\n\t\t\tlocal res = {grid[i][j]}\n\t\t\tmemo[key] = res\n\t\t\treturn\
    \ res\n\t\tend\n\t\tlocal res = {}\n\t\tif i > 1 then\n\t\t\tlocal res1 = helper(i\
    \ - 1, j, h - 1)\n\t\t\tif #res == 0 or res1[#res1] < res[#res] then\n\t\t\t\t\
    res = res1\n\t\t\tend\n\t\tend\n\t\tif i < n then\n\t\t\tlocal res1 = helper(i\
    \ + 1, j, h - 1)\n\t\t\tif #res == 0 or res1[#res1] < res[#res] then\n\t\t\t\t\
    res = res1\n\t\t\tend\n\t\tend\n\t\tif j > 1 then\n\t\t\tlocal res1 = helper(i,\
    \ j - 1, h - 1)\n\t\t\tif #res == 0", "\tif #grid == 0 then\n\t\treturn {}\n\t\
    end\n\t\n\tlocal N = #grid\n\t\n\tlocal function f(cell, k)\n\t\tlocal i, j =\
    \ cell[1], cell[2]\n\t\tlocal paths = {}\n\t\t\n\t\tif k == 1 then\n\t\t\treturn\
    \ {grid[i][j]}\n\t\tend\n\t\t\n\t\tif i - 1 >= 1 then\n\t\t\ttable.insert(paths,\
    \ f({i - 1, j}, k - 1))\n\t\tend\n\t\t\n\t\tif i + 1 <= N then\n\t\t\ttable.insert(paths,\
    \ f({i + 1, j}, k - 1))\n\t\tend\n\t\t\n\t\tif j - 1 >= 1 then\n\t\t\ttable.insert(paths,\
    \ f({i, j - 1}, k - 1))\n\t\tend\n\t\t\n\t\tif j + 1 <= N then\n\t\t\ttable.insert(paths,\
    \ f({i, j + 1}, k - 1))\n\t\tend\n\t\t\n\t\tif #paths == 0 then\n\t\t\treturn\
    \ {}\n\t\tend\n\t\t\n\t\tlocal min = paths[1]\n\t\t\n\t\tfor i = 2, #paths do\n\
    \t\t\tlocal path = paths[i]\n\t\t\t\n\t\t\tif path < min then\n\t\t\t\tmin = path\n\
    \t\t\tend\n\t\tend\n\t\t\n\t\ttable.insert(min, 1, grid[i][j])\n\t\t\n\t\treturn\
    \ min\n\tend\n\t\n\tlocal min\n\t\n\tfor i = 1, N do\n\t\tfor j = 1, N do\n\t\t\
    \tlocal path = f({i, j}, k)\n\t\t\t\n\t\t\tif path ~= nil and (min == nil or path\
    \ < min) then\n\t\t\t\tmin = path\n\t\t\tend\n\t\tend\n\tend\n\t\n\treturn min\n\
    end", "    if k < 1 then\n        return {}\n    end\n    local minPath = {}\n\
    \    local minPathLen = math.huge\n    local function visit(visited, path, len,\
    \ i, j)\n        if i < 1 or i > #grid or j < 1 or j > #grid or visited[i][j]\
    \ then\n            return\n        end\n        path[#path + 1] = grid[i][j]\n\
    \        if len == k then\n            if #path < minPathLen then\n          \
    \      minPath = table.copy(path)\n                minPathLen = #path\n      \
    \      elseif #path == minPathLen then\n                for i = 1, #path do\n\
    \                    if path[i] < minPath[i] then\n                        minPath\
    \ = table.copy(path)\n                        break\n                    elseif\
    \ path[i] > minPath[i] then\n                        break\n                 \
    \   end\n                end\n            end\n        else\n            visited[i][j]\
    \ = true\n            visit(visited, path, len + 1, i - 1, j)\n            visit(visited,\
    \ path, len + 1, i + 1, j)\n            visit(visited, path, len + 1, i, j - 1)\n\
    \            visit(visited, path, len + 1, i, j + 1)\n            visited[i][j]\
    \ = false\n        end\n        path[#path] = nil\n    end\n    local visited\
    \ = {}\n    for i = 1, #grid do\n        visited[i] = {}\n    end\n    for i =\
    \ 1, #grid do\n        for j = 1, #grid do\n            visit(visited, {}, 1,\
    \ i, j)\n        end\n    end\n    return minPath\nend", "    local gridSize =\
    \ #grid\n    local answer = {}\n    local gridMax = gridSize * gridSize\n    local\
    \ minPathFinder = {}\n    local minPathHelper = {}\n    local visited = {}\n \
    \   for i = 1, gridSize do\n        visited[i] = {}\n        for j = 1, gridSize\
    \ do\n            visited[i][j] = false\n        end\n    end\n    local function\
    \ dfs(cell, pathLength, pathValues)\n        table.insert(pathValues, grid[cell[1]][cell[2]])\n\
    \        visited[cell[1]][cell[2]] = true\n        if pathLength < k then\n  \
    \          local neighbors = minPathHelper.neighbors(cell)\n            for i\
    \ = 1, #neighbors do\n                if not visited[neighbors[i][1]][neighbors[i][2]]\
    \ then\n                    minPathFinder(neighbors[i], pathLength + 1, pathValues)\n\
    \                end\n            end\n        else\n            answer = minPathHelper.minPath(answer,\
    \ pathValues)\n        end\n        table.remove(pathValues)\n        visited[cell[1]][cell[2]]\
    \ = false\n    end\n    for i = 1, gridSize do\n        for j = 1, gridSize do\n\
    \            dfs({i, j}, 1, {})\n        end\n    end\n    return answer\nend",
  "  n = #grid\n  assert(k >= 2)\n  assert(n >= 2)\n  assert(k <= n * n)\n  local\
    \ cache = {}\n  local function dfs(x, y, k)\n    if k == 1 then\n      return\
    \ { grid[x][y] }\n    end\n    local key = x * n + y + (k - 1) * n * n\n    if\
    \ cache[key] then\n      return cache[key]\n    end\n    local ret = {}\n    local\
    \ paths = {}\n    if x > 1 then\n      local path = dfs(x - 1, y, k - 1)\n   \
    \   ret[#ret + 1] = path\n      paths[#paths + 1] = path\n    end\n    if x <\
    \ n then\n      local path = dfs(x + 1, y, k - 1)\n      ret[#ret + 1] = path\n\
    \      paths[#paths + 1] = path\n    end\n    if y > 1 then\n      local path\
    \ = dfs(x, y - 1, k - 1)\n      ret[#ret + 1] = path\n      paths[#paths + 1]\
    \ = path\n    end\n    if y < n then\n      local path = dfs(x, y + 1, k - 1)\n\
    \      ret[#ret + 1] = path\n      paths[#paths + 1] = path\n    end\n    local\
    \ min = paths[1]\n    for i = 2, #paths do\n      local path = paths[i]\n    \
    \  if lexicoLess(path, min) then\n        min = path\n      end\n    end\n   \
    \ min[#min + 1] = grid[x][y]\n    cache[key] = min\n    return min\n  end\n  local\
    \ min = {}\n  for i = 1, n do\n    for j = 1, n do\n      local path = dfs(i,\
    \ j, k)\n      if not min or lexicoLess(path, min) then\n        min = path\n\
    \      end\n    end\n  end\n  return min\nend", "    local n = #grid\n    local\
    \ f = {}\n    local pair = {first = 0, second = 0}\n    local function set(x,\
    \ y, k, p)\n        local key = x * n + y\n        f[key] = f[key] or {}\n   \
    \     if not f[key][k] or f[key][k].first > p.first or\n            (f[key][k].first\
    \ == p.first and f[key][k].second > p.second) then\n            f[key][k] = p\n\
    \        end\n    end\n    local function get(x, y, k)\n        local key = x\
    \ * n + y\n        return f[key] and f[key][k] or nil\n    end\n    for i = 0,\
    \ n - 1 do\n        for j = 0, n - 1 do\n            pair.first = grid[i + 1][j\
    \ + 1]\n            pair.second = grid[i + 1][j + 1]\n            set(i, j, 1,\
    \ pair)\n        end\n    end\n    for i = 2, k do\n        for j = 0, n - 1 do\n\
    \            for l = 0, n - 1 do\n                local key = j * n + l\n    \
    \            local p = get(j, l, i)\n                if not p then\n         \
    \           p = {first = math.maxinteger, second = math.maxinteger}\n        \
    \        end\n                local p1 = get(j - 1, l, i - 1)\n              \
    \  if p1 and p1.first < p.first or\n                    (p1.first == p.first and\
    \ p1.second < p.second) then\n                    p.first = p1.first\n       \
    \             p.second = p1.second\n                end\n                local\
    \ p2 = get(j + 1, l, i - 1)\n                if p2 and p2.first < p.first or\n\
    \                    (p2.first == p.first and p2.second < p.second) then\n   \
    \                 p.first = p2.first\n                    p.second = p2.second\n\
    \                end\n                local p3 = get(j, l - 1, i - 1)\n      \
    \          if p3 and p3.first < p", "  local n = #grid\n  local function dist(i,\
    \ j)\n    return abs(i - j)\n  end\n  local function one_path(i, j, l)\n    local\
    \ state = {}\n    local ans = {}\n    local visited = {}\n    local q = Queue()\n\
    \    q:push({i, j, 0})\n    visited[i] = {}\n    visited[i][j] = true\n    while\
    \ not q:empty() do\n      local t = q:pop()\n      if state[t[1]] == nil then\n\
    \        state[t[1]] = {}\n      end\n      state[t[1]][t[2]] = t[3]\n      if\
    \ t[3] > k then\n        break\n      end\n      if t[3] == k then\n        table.insert(ans,\
    \ grid[t[1]][t[2]])\n      end\n      for _, v in ipairs(neighbors(t[1], t[2],\
    \ n)) do\n        if not visited[v[1]] or not visited[v[1]][v[2]] then\n     \
    \     visited[v[1]] = visited[v[1]] or {}\n          visited[v[1]][v[2]] = true\n\
    \          q:push({v[1], v[2], t[3] + 1})\n        end\n      end\n    end\n \
    \   return state, ans\n  end\n  local state = {}\n  local ans = {}\n  for i =\
    \ 1, n do\n    state[i] = {}\n    ans[i] = {}\n    for j = 1, n do\n      state[i][j],\
    \ ans[i][j] = one_path(i, j, k)\n    end\n  end\n  local function compare(a, b)\n\
    \    local f = function(x, y)\n      if x[1] == y[1] then\n        return x[2]\
    \ < y[2]\n      end\n      return x[1] < y[1]\n    end\n    table.sort(a, f)\n\
    \    table.sort(b, f)\n    for i = 1, #a do\n      if a[i][3] ~= b", "  if k <=\
    \ 0 then\n    return {}, k\n  end\n  if k == 1 then\n    return {grid[1][1]},\
    \ k\n  end\n  local n = #grid\n  local val, tbl = grid[1][1], {}\n  local function\
    \ dfs(i, j, k)\n    if k == 0 then\n      table.insert(tbl, val)\n      return\n\
    \    end\n    if i == n and j == n then\n      return\n    end\n    if i < n then\n\
    \      val = val * 10 + grid[i + 1][j]\n      dfs(i + 1, j, k - 1)\n      val\
    \ = math.floor(val / 10)\n    end\n    if j < n then\n      val = val * 10 + grid[i][j\
    \ + 1]\n      dfs(i, j + 1, k - 1)\n      val = math.floor(val / 10)\n    end\n\
    \  end\n  dfs(1, 1, k - 1)\n  table.sort(tbl)\n  return tbl, k\nend", "    local\
    \ rowLen = #grid\n    local colLen = #grid[1]\n    if rowLen == 1 and colLen ==\
    \ 1 then\n        return grid[1][1]\n    end\n    local dist = {}\n    local que\
    \ = {}\n    local visited = {}\n    local size = 0\n    local cost = 0\n    local\
    \ push = table.insert\n    local pop = table.remove\n    local function hash(r,\
    \ c)\n        return r * colLen + c\n    end\n    local function getVal(r, c)\n\
    \        return grid[r][c]\n    end\n    local function add(r, c, val)\n     \
    \   if not visited[hash(r, c)] then\n            local d = math.abs(val - getVal(r,\
    \ c))\n            push(que, {r, c, d})\n            dist[hash(r, c)] = d\n  \
    \          visited[hash(r, c)] = true\n            size = size + 1\n        end\n\
    \    end\n    for r = 1, rowLen do\n        for c = 1, colLen do\n           \
    \ add(r, c, cost)\n        end\n    end\n    local function remove()\n       \
    \ local minD = math.huge\n        local minI = 0\n        for i = 1, size do\n\
    \            local item = que[i]\n            if dist[hash(item[1], item[2])]\
    \ < minD then\n                minD = dist[hash(item[1], item[2])]\n         \
    \       minI = i\n            end\n        end\n        local minItem = pop(que,\
    \ minI)\n        size = size - 1\n        visited[hash(minItem[1], minItem[2])]\
    \ = false\n        return minItem\n    end\n    local i = 1\n    local res = {}\n\
    \    while i <= k do\n        local item = remove()\n        local r = item[1]\n\
    \        local c = item[2]\n        cost = cost + item[3]\n        res[i] = getVal(r,\
    \ c)\n        if r > 1 then\n            add(r - 1, c, cost)\n        end\n  \
    \      if r < rowLen then\n            add(r + 1, c, cost)\n", "    local m, n\
    \ = #grid, #grid[1]\n    local memo = {}\n    local function dfs(x, y, path)\n\
    \        if x < 1 or x > m or y < 1 or y > n then\n            return false\n\
    \        end\n        if #path >= k then\n            if not memo[path] then\n\
    \                memo[path] = true\n                return true\n            end\n\
    \            return false\n        end\n        if dfs(x - 1, y, path .. grid[x][y])\
    \ or dfs(x + 1, y, path .. grid[x][y])\n                or dfs(x, y - 1, path\
    \ .. grid[x][y]) or dfs(x, y + 1, path .. grid[x][y]) then\n            return\
    \ true\n        end\n        return false\n    end\n    local res\n    for i =\
    \ 1, m do\n        for j = 1, n do\n            if dfs(i, j, \"\") then\n    \
    \            return memo\n            end\n        end\n    end\n    return res\n\
    end", "  local function isInGrid(r, c)\n    return r >= 1 and r <= #grid and c\
    \ >= 1 and c <= #grid[1]\n  end\n  local function dfs(r, c, visited, path)\n \
    \   if #path == k then\n      return path\n    end\n    local minPath = nil\n\
    \    for _, dir in ipairs({{0, 1}, {0, -1}, {1, 0}, {-1, 0}}) do\n      local\
    \ x, y = r + dir[1], c + dir[2]\n      if isInGrid(x, y) and not visited[x][y]\
    \ then\n        local nextPath = dfs(x, y, visited, {table.unpack(path), grid[x][y]})\n\
    \        if nextPath then\n          if not minPath or #nextPath < #minPath then\n\
    \            minPath = nextPath\n          end\n        end\n      end\n    end\n\
    \    return minPath\n  end\n  local minPath = nil\n  for r = 1, #grid do\n   \
    \ for c = 1, #grid[1] do\n      local visited = {}\n      for i = 1, #grid do\n\
    \        visited[i] = {}\n      end\n      local path = dfs(r, c, visited, {grid[r][c]})\n\
    \      if path then\n        if not minPath or #path < #minPath then\n       \
    \   minPath = path\n        end\n      end\n    end\n  end\n  return minPath\n\
    end", "    local minPath, minVal = {}, nil\n    local function dfs(x, y, path,\
    \ val)\n        if x < 1 or x > #grid or y < 1 or y > #grid or\n             \
    \   grid[x][y] == 0 or path[grid[x][y]] then\n            return\n        end\n\
    \        path[grid[x][y]] = true\n        val = val + grid[x][y]\n        if #path\
    \ == k then\n            if minVal == nil or val < minVal then\n             \
    \   minVal = val\n                minPath = {}\n                for i = 1, k do\n\
    \                    minPath[i] = grid[x][y]\n                end\n          \
    \  elseif val == minVal then\n                for i = 1, k do\n              \
    \      if minPath[i] < grid[x][y] then\n                        break\n      \
    \              elseif minPath[i] > grid[x][y] then\n                        minVal\
    \ = val\n                        minPath = {}\n                        for j =\
    \ 1, k do\n                            minPath[j] = grid[x][y]\n             \
    \           end\n                        break\n                    end\n    \
    \            end\n            end\n        else\n            dfs(x + 1, y, path,\
    \ val)\n            dfs(x - 1, y, path, val)\n            dfs(x, y + 1, path,\
    \ val)\n            dfs(x, y - 1, path, val)\n        end\n        path[grid[x][y]]\
    \ = nil\n    end\n    for i = 1, #grid do\n        for j = 1, #grid do\n     \
    \       dfs(i, j, {}, 0)\n        end\n    end\n    return minPath\nend", "  local\
    \ n = #grid\n  local function v(x, y)\n    return grid[x][y]\n  end\n  local function\
    \ valid(x, y)\n    return 1 <= x and x <= n and 1 <= y and y <= n\n  end\n  local\
    \ function add(x, y)\n    if not valid(x, y) then\n      return false\n    end\n\
    \    if not paths[x] then\n      paths[x] = {}\n    end\n    if not paths[x][y]\
    \ then\n      paths[x][y] = {}\n    end\n    return true\n  end\n  local p = n\
    \ * n + 1\n  local function key(x, y)\n    return x * p + y\n  end\n  local path\
    \ = {}\n  local paths = {}\n  local t = {[0] = {0}}\n  local visited = {}\n  local\
    \ m = 2^31\n  local function dfs(i, x, y, v)\n    if i == k then\n      if v <\
    \ m then\n        m = v\n        for j = 1, k do\n          path[j] = paths[i][key(x,\
    \ y)][j]\n        end\n      end\n      return\n    end\n    for _, d in ipairs({{1,\
    \ 0}, {-1, 0}, {0, 1}, {0, -1}}) do\n      local nx, ny = x + d[1], y + d[2]\n\
    \      if add(nx, ny) then\n        if paths[i][key(x, y)] then\n          local\
    \ l = {}\n          for j = 1, #paths[i][key(x, y)] do\n            l[j] = paths[i][key(x,\
    \ y)][j]\n          end\n          l[#l + 1] = v(nx, ny)\n          paths[i +\
    \ 1][key(nx, ny)] = l\n        else\n          paths[i + 1][key(nx, ny)] = {v(nx,\
    \ ny)}\n        end\n        if not visited[key(nx, ny)] then\n          visited[key(nx,\
    \ ny)] = true\n", "\t-- Constraints:\n\t-- n = #grid, k >= 2, k <= n * n\n\t--\
    \ grid[i][j] is an integer in [1, n * n] for all i, j (1 <= i, j <= n)\n\t-- All\
    \ integers in [1, n * n] appear exactly once in grid\n\tlocal n = #grid\n\tassert(k\
    \ >= 2 and k <= n * n)\n\tfor _, row in ipairs(grid) do\n\t\tassert(#row == n)\n\
    \t\tlocal hs = {}\n\t\tfor _, x in ipairs(row) do\n\t\t\ths[x] = true\n\t\tend\n\
    \t\tfor x = 1, n * n do\n\t\t\tassert(hs[x])\n\t\tend\n\tend\n\tlocal dirs = {\
    \ {0, 1}, {1, 0}, {0, -1}, {-1, 0} }\n\tlocal dfs\n\tlocal function is_valid(x,\
    \ y)\n\t\treturn x >= 1 and x <= n and y >= 1 and y <= n\n\tend\n\tlocal function\
    \ get_neighbors(x, y)\n\t\tlocal res = {}\n\t\tfor _, dir in ipairs(dirs) do\n\
    \t\t\tlocal x1, y1 = x + dir[1], y + dir[2]\n\t\t\tif is_valid(x1, y1) then\n\t\
    \t\t\ttable.insert(res, {x1, y1})\n\t\t\tend\n\t\tend\n\t\treturn res\n\tend\n\
    \tdfs = function(x, y, visited, path, min_path)\n\t\tvisited[x] = visited[x] or\
    \ {}\n\t\tvisited[x][y] = true\n\t\tpath[k] = grid[x][y]\n\t\tif k == 1 then\n\
    \t\t\tif min_path == nil then\n\t\t\t\tmin_path = {}\n\t\t\t\tfor i = 1, k do\n\
    \t\t\t\t\tmin_path[i] = path[i]\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tfor i = 1, k\
    \ do\n\t\t\t\t\tif", "    local m, n = #grid, #grid[1]\n    local function next_val(val)\n\
    \        return val % n + 1, math.floor(val / n) + 1\n    end\n    local function\
    \ prev_val(val)\n        return val - 1\n    end\n    local function pos(x, y)\n\
    \        return (y - 1) * n + x\n    end\n    local function index(x, y)\n   \
    \     return y * n + x\n    end\n    local function eval(path)\n        local\
    \ p = 1\n        local t = {}\n        while path > 0 do\n            if path\
    \ % 2 == 1 then\n                local i = math.floor(p / 2)\n               \
    \ t[i] = grid[t[i] or i]\n            end\n            path = math.floor(path\
    \ / 2)\n            p = p + 1\n        end\n        return t\n    end\n    local\
    \ function compare(path_a, path_b)\n        local t_a, t_b = eval(path_a), eval(path_b)\n\
    \        for i = 1, k do\n            if t_a[i] ~= t_b[i] then\n             \
    \   return t_a[i] < t_b[i]\n            end\n        end\n        return false\n\
    \    end\n    local function is_valid(prev, cur)\n        local px, py = next_val(prev)\n\
    \        local cx, cy = next_val(cur)\n        return (math.abs(px - cx) + math.abs(py\
    \ - cy)) == 1\n    end\n    local function bfs(start)\n        local seen = {}\n\
    \        local q = {start}\n        local path = {}\n        local dist = 0\n\
    \        while #q > 0 do\n            local next_q = {}\n            for _, p\
    \ in ipairs(q) do\n                local cx, cy = next_val(p)\n              \
    \  if seen[p] == nil then\n                    seen[p] = true\n              \
    \      if path[p] == nil then\n                        path[p] = 0\n         \
    \           end\n                    path[p] = path[p] + 1\n                 \
    \   if path[p] == k then\n                        return p\n                 \
    \  ", "  -- Write your code here\n  local min = {\n    value = math.huge\n  }\n\
    \  local function helper(grid, r, c, k, acc)\n    local value = grid[r][c]\n \
    \   acc[#acc + 1] = value\n    if r < 1 or r > #grid or c < 1 or c > #grid[1]\
    \ then\n      return\n    end\n    if k == 1 then\n      if value < min.value\
    \ then\n        min.value = value\n        min.path = acc\n      end\n      return\n\
    \    end\n    helper(grid, r - 1, c, k - 1, acc)\n    helper(grid, r + 1, c, k\
    \ - 1, acc)\n    helper(grid, r, c - 1, k - 1, acc)\n    helper(grid, r, c + 1,\
    \ k - 1, acc)\n  end\n  for r = 1, #grid do\n    for c = 1, #grid[1] do\n    \
    \  helper(grid, r, c, k, {})\n    end\n  end\n  return min.path\nend", "    local\
    \ N = #grid\n    local visited = {}\n    local function dfs(x, y, v)\n       \
    \ visited[x * N + y] = v\n        local m = {}\n        if x > 1 and not visited[(x\
    \ - 1) * N + y] then\n            local p = dfs(x - 1, y, v + grid[x - 1][y])\n\
    \            m[#m + 1] = p\n        end\n        if x < N and not visited[(x +\
    \ 1) * N + y] then\n            local p = dfs(x + 1, y, v + grid[x + 1][y])\n\
    \            m[#m + 1] = p\n        end\n        if y > 1 and not visited[x *\
    \ N + y - 1] then\n            local p = dfs(x, y - 1, v + grid[x][y - 1])\n \
    \           m[#m + 1] = p\n        end\n        if y < N and not visited[x * N\
    \ + y + 1] then\n            local p = dfs(x, y + 1, v + grid[x][y + 1])\n   \
    \         m[#m + 1] = p\n        end\n        local min\n        local minI\n\
    \        for i = 1, #m do\n            if not min or m[i][1] < min then\n    \
    \            min = m[i][1]\n                minI = i\n            end\n      \
    \  end\n        return minI and m[minI] or {v}\n    end\n    local paths = {}\n\
    \    for i = 1, N do\n        for j = 1, N do\n            visited = {}\n    \
    \        paths[#paths + 1] = dfs(i, j, grid[i][j])\n        end\n    end\n   \
    \ local min\n    local minI\n    for i = 1, #paths do\n        if not min or paths[i][1]\
    \ < min then\n            min = paths[i][1]\n            minI = i\n        end\n\
    \    end\n    return paths[minI]\nend", "    local visited = {}\n    local N =\
    \ #grid\n    local d = {}\n    for i = 1, N do\n        d[i] = {}\n        for\
    \ j = 1, N do\n            d[i][j] = {}\n        end\n    end\n    for i = 1,\
    \ N do\n        for j = 1, N do\n            for k = 1, N * N do\n           \
    \     d[i][j][k] = -1\n            end\n        end\n    end\n    local function\
    \ dfs(x, y, k)\n        if k == 0 then\n            return {}\n        end\n \
    \       if k == 1 then\n            return {grid[x][y]}\n        end\n       \
    \ local key = x .. \",\" .. y .. \",\" .. k\n        if visited[key] then\n  \
    \          return nil\n        end\n        visited[key] = true\n        local\
    \ dx = {-1, 0, 1, 0}\n        local dy = {0, 1, 0, -1}\n        local ans = nil\n\
    \        for i = 1, 4 do\n            local tx = x + dx[i]\n            local\
    \ ty = y + dy[i]\n            if tx >= 1 and tx <= N and ty >= 1 and ty <= N then\n\
    \                local new_ans = d[tx][ty][k - 1]\n                if new_ans\
    \ == -1 then\n                    new_ans = dfs(tx, ty, k - 1)\n             \
    \       d[tx][ty][k - 1] = new_ans\n                end\n                if new_ans\
    \ then\n                    if not ans then\n                        ans = new_ans\n\
    \                    else\n                        local x = 1\n             \
    \           while x <= #ans and x <= #new_ans do\n                           \
    \ if ans[x] ~= new_ans[x] then\n                                break\n      \
    \                      end\n                            x = x + 1\n          \
    \              end\n                        if x <= #ans and x <= #new_ans then\n\
    \                            if ans[x] < new_ans[x] then\n                   \
    \             ans = new_ans\n                            end\n               \
    \         elseif x > #ans then\n                            ans = new_ans\n  \
    \                      end\n                    end\n                end\n   \
    \         end\n        end\n        table.insert(ans, 1,", "  local sz = #grid\n\
    \  local dp = {}\n  for i = 1, sz do\n    dp[i] = {}\n    for j = 1, sz do\n \
    \     dp[i][j] = {}\n    end\n  end\n  local res = {}\n  for i = 1, sz do\n  \
    \  for j = 1, sz do\n      if i == 1 and j == 1 then\n        dp[i][j][1] = {grid[i][j]}\n\
    \      else\n        local cur = grid[i][j]\n        local possible = {}\n   \
    \     local tmp = {}\n        if i > 1 then\n          for p = 1, k - 1 do\n \
    \           tmp[p] = dp[i - 1][j][p]\n          end\n          table.insert(tmp,\
    \ cur)\n          for p = 1, k do\n            table.insert(possible, tmp[p])\n\
    \          end\n        end\n        if j > 1 then\n          for p = 1, k - 1\
    \ do\n            tmp[p] = dp[i][j - 1][p]\n          end\n          table.insert(tmp,\
    \ cur)\n          for p = 1, k do\n            if possible[p] == nil then\n  \
    \            table.insert(possible, tmp[p])\n            else\n              possible[p]\
    \ = math.min(possible[p], tmp[p])\n            end\n          end\n        end\n\
    \        for p = 1, k do\n          dp[i][j][p] = possible[p]\n        end\n \
    \     end\n    end\n  end\n  for i = 1, k do\n    table.insert(res, dp[sz][sz][i])\n\
    \  end\n  return res\nend", "  local n = #grid\n  local min\n  local pos\n  local\
    \ function dfs(x, y, path, visited)\n    if #path == k then\n      if not min\
    \ or path < min then\n        min = path\n      end\n      return\n    end\n \
    \   if x > 1 and not visited[pos(x - 1, y)] then\n      visited[pos(x - 1, y)]\
    \ = true\n      dfs(x - 1, y, path .. grid[x - 1][y], visited)\n      visited[pos(x\
    \ - 1, y)] = nil\n    end\n    if x < n and not visited[pos(x + 1, y)] then\n\
    \      visited[pos(x + 1, y)] = true\n      dfs(x + 1, y, path .. grid[x + 1][y],\
    \ visited)\n      visited[pos(x + 1, y)] = nil\n    end\n    if y > 1 and not\
    \ visited[pos(x, y - 1)] then\n      visited[pos(x, y - 1)] = true\n      dfs(x,\
    \ y - 1, path .. grid[x][y - 1], visited)\n      visited[pos(x, y - 1)] = nil\n\
    \    end\n    if y < n and not visited[pos(x, y + 1)] then\n      visited[pos(x,\
    \ y + 1)] = true\n      dfs(x, y + 1, path .. grid[x][y + 1], visited)\n     \
    \ visited[pos(x, y + 1)] = nil\n    end\n  end\n  pos = function(x, y)\n    return\
    \ x * n + y\n  end\n  for i = 1, n do\n    for j = 1, n do\n      local visited\
    \ = {}\n      visited[pos(i, j)] = true\n      dfs(i, j, tostring(grid[i][j]),\
    \ visited)\n    end\n  end\n  return min\nend", "    local n = #grid\n    local\
    \ r, c = 0, 0\n    for r = 1, n do\n        for c = 1, n do\n            if grid[r][c]\
    \ == 1 then\n                goto break2\n            end\n        end\n    end\n\
    \    ::break2::\n    local start = (r - 1) * n + c\n    local edges = {{1, 0},\
    \ {-1, 0}, {0, 1}, {0, -1}}\n    local keys = {}\n    local edges_map = {}\n \
    \   local function get_key(r, c)\n        if keys[r] and keys[r][c] then\n   \
    \         return keys[r][c]\n        end\n        keys[r] = keys[r] or {}\n  \
    \      local key = (r - 1) * n + c\n        keys[r][c] = key\n        return key\n\
    \    end\n    local function get_edge(r, c)\n        local key = get_key(r, c)\n\
    \        if edges_map[key] then\n            return edges_map[key]\n        end\n\
    \        local new_edges = {}\n        for _, edge in ipairs(edges) do\n     \
    \       local r1, c1 = r + edge[1], c + edge[2]\n            if r1 >= 1 and r1\
    \ <= n and c1 >= 1 and c1 <= n then\n                table.insert(new_edges, get_key(r1,\
    \ c1))\n            end\n        end\n        edges_map[key] = new_edges\n   \
    \     return new_edges\n    end\n    local adj_list = {}\n    for r = 1, n do\n\
    \        for c = 1, n do\n            local key = get_key(r, c)\n            adj_list[key]\
    \ = adj_list[key] or {}\n            for _, edge in ipairs(get_edge(r, c)) do\n\
    \                table.insert(adj_list[key], edge)\n            end\n        end\n\
    \    end\n    local visited = {}\n    local function dfs(start, path, level)\n\
    \        if level == k then\n            return path\n        end\n        local\
    \ min_path\n        local function less_", "\tif k <= 0 then\n\t\treturn {}\n\t\
    end\n\tlocal n = #grid\n\tif n == 0 then\n\t\treturn {}\n\tend\n\tlocal r = {}\n\
    \tfor i = 1, n do\n\t\tlocal row = {}\n\t\tfor j = 1, n do\n\t\t\ttable.insert(row,\
    \ {\n\t\t\t\tgrid[i][j],\n\t\t\t\t{ { { i, j } } }\n\t\t\t})\n\t\tend\n\t\ttable.insert(r,\
    \ row)\n\tend\n\tlocal step = 1\n\twhile step < k do\n\t\tfor i = 1, n do\n\t\t\
    \tfor j = 1, n do\n\t\t\t\tlocal val, paths = r[i][j][1], r[i][j][2]\n\t\t\t\t\
    if i > 1 then\n\t\t\t\t\tfor _, path in ipairs(paths) do\n\t\t\t\t\t\tlocal m,\
    \ p = r[i - 1][j][1], r[i - 1][j][2]\n\t\t\t\t\t\tif val > m then\n\t\t\t\t\t\t\
    \tfor _, path2 in ipairs(p) do\n\t\t\t\t\t\t\t\ttable.insert(path2, { i, j })\n\
    \t\t\t\t\t\t\t\ttable.insert(paths, path2)\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\telseif\
    \ val == m then\n\t\t\t\t\t\t\tfor _, path2 in ipairs(p) do\n\t\t\t\t\t\t\t\t\
    local path3 = {}\n\t\t\t\t\t\t\t\tfor _, coor in ipairs(path2) do\n\t\t\t\t\t\t\
    \t\t\ttable.insert(path3, coor)\n\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\ttable.insert(path3,\
    \ { i, j })\n\t\t\t\t\t\t\t\ttable.insert(paths, path3)\n\t\t\t\t\t\t\tend\n\t\
    \t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif i < n then\n\t\t\t", " \
    \   local N = #grid\n    local min = {}\n    local visited = {}\n    local order\
    \ = { { 1, 0 }, { 0, 1 }, { -1, 0 }, { 0, -1 } }\n    local function helper(x,\
    \ y, path, len)\n        if len == k then\n            if not min[1] then\n  \
    \              min = path\n            else\n                for i = 1, k do\n\
    \                    if path[i] < min[i] then\n                        min = path\n\
    \                        break\n                    elseif path[i] > min[i] then\n\
    \                        break\n                    end\n                end\n\
    \            end\n            return\n        end\n        for _, v in ipairs(order)\
    \ do\n            local new_x, new_y = x + v[1], y + v[2]\n            if 1 <=\
    \ new_x and new_x <= N and 1 <= new_y and new_y <= N and\n                not\
    \ visited[new_x][new_y] then\n                visited[new_x][new_y] = true\n \
    \               table.insert(path, grid[new_x][new_y])\n                helper(new_x,\
    \ new_y, path, len + 1)\n                table.remove(path)\n                visited[new_x][new_y]\
    \ = false\n            end\n        end\n    end\n    for i = 1, N do\n      \
    \  visited[i] = {}\n    end\n    for i = 1, N do\n        for j = 1, N do\n  \
    \          visited[i][j] = true\n            helper(i, j, { grid[i][j] }, 1)\n\
    \            visited[i][j] = false\n        end\n    end\n    return min\nend",
  "    local function get_min_path(grid, n, k, r, c, visited, path)\n        if not\
    \ visited[r] then\n            visited[r] = {}\n        end\n        if visited[r][c]\
    \ then\n            return nil\n        end\n        visited[r][c] = true\n  \
    \      table.insert(path, grid[r][c])\n        if k == 1 then\n            return\
    \ path\n        end\n        for i, _ in ipairs({{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}}) do\n            local dr, dc = _[1], _[2]\n            local next_r, next_c\
    \ = r + dr, c + dc\n            if next_r >= 1 and next_r <= n and next_c >= 1\
    \ and next_c <= n then\n                local p = get_min_path(grid, n, k - 1,\
    \ next_r, next_c, visited, path)\n                if p then\n                \
    \    return p\n                end\n            end\n        end\n        visited[r][c]\
    \ = false\n        table.remove(path)\n        return nil\n    end\n    local\
    \ n = #grid\n    local path = {}\n    local visited = {}\n    local min_path =\
    \ get_min_path(grid, n, k, 1, 1, visited, path)\n    return min_path\nend", " \
    \   -- return an ordered list of the values on the cells that the minimum path\
    \ go through\n    local n = #grid\n    assert(n >= 2)\n    assert(k >= n * n)\n\
    \    local r, c, v = 1, 1, grid[1][1]\n    local res = {v}\n    local function\
    \ pr(r, c)\n        if r > n or r < 1 or c > n or c < 1 then\n            return\
    \ n * n + 1\n        end\n        return grid[r][c]\n    end\n    while #res <\
    \ k do\n        local r1, c1, v1 = r, c, n * n + 1\n        if r1 < n and pr(r1\
    \ + 1, c1) < v1 then\n            r1, c1, v1 = r1 + 1, c1, pr(r1 + 1, c1)\n  \
    \      end\n        if r1 > 1 and pr(r1 - 1, c1) < v1 then\n            r1, c1,\
    \ v1 = r1 - 1, c1, pr(r1 - 1, c1)\n        end\n        if c1 < n and pr(r1, c1\
    \ + 1) < v1 then\n            r1, c1, v1 = r1, c1 + 1, pr(r1, c1 + 1)\n      \
    \  end\n        if c1 > 1 and pr(r1, c1 - 1) < v1 then\n            r1, c1, v1\
    \ = r1, c1 - 1, pr(r1, c1 - 1)\n        end\n        r, c, v = r1, c1, v1\n  \
    \      res[#res + 1] = v\n    end\n    return res\nend", "    local N = #grid\n\
    \    local visited = {}\n    for i = 1, N do\n        visited[i] = {}\n      \
    \  for j = 1, N do\n            visited[i][j] = {}\n        end\n    end\n   \
    \ local function dfs(i, j, cnt, path)\n        if cnt == k then\n            return\
    \ true, path\n        end\n        local flag = false\n        local cpath = path\n\
    \        local dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}\n        for _, dir in\
    \ ipairs(dirs) do\n            local ni, nj = i + dir[1], j + dir[2]\n       \
    \     if (1 <= ni and ni <= N and 1 <= nj and nj <= N) and\n                (not\
    \ visited[ni][nj][cnt + 1]) then\n                path = path .. ' ' .. grid[ni][nj]\n\
    \                visited[ni][nj][cnt + 1] = true\n                flag, cpath\
    \ = dfs(ni, nj, cnt + 1, path)\n                if flag then\n               \
    \     return true, cpath\n                end\n                path = path:sub(1,\
    \ -3)\n            end\n        end\n        return false, cpath\n    end\n  \
    \  local res\n    for i = 1, N do\n        for j = 1, N do\n            visited[i][j][1]\
    \ = true\n            local flag, cres = dfs(i, j, 1, grid[i][j])\n          \
    \  if flag then\n                if not res then\n                    res = cres\n\
    \                else\n                    local lres = res:split(' ')\n     \
    \               local lcres = cres:split(' ')\n                    for i = 1,\
    \ k do\n                        if lres[i] < lcres[i] then\n                 \
    \           break\n                        elseif lres[i] > lcres[i] then\n  \
    \                          res = cres\n                            break\n   \
    \                     end\n                    end\n                end\n    \
    \        end\n        end\n    end\n    local lres = res:split(' ')\n    local\
    \ lst = {}\n    for i = 1, k do\n        lst[", "    return nil\nend", "    local\
    \ path = {}\n    local height = #grid\n    for i = 1, k do\n        path[i] =\
    \ grid[1][1]\n    end\n    return path\nend", "  -- Write your code here\nend",
  "    -- Check for errors\n    assert(type(grid) == \"table\" and type(k) == \"number\"\
    , \"minPath: arguments must be a 2D grid and a positive integer\")\n    assert(#grid\
    \ >= 2 and #grid[1] >= 2 and k >= 1, \"minPath: grid dimensions must be at least\
    \ 2x2 and k must be positive\")\n    assert(k <= #grid * #grid[1], \"minPath:\
    \ k must be less than or equal to the number of cells\")\n    local s_grid = {}\n\
    \    local s_grid_map = {}\n    local count = 0\n    for i, row in ipairs(grid)\
    \ do\n        assert(#row == #grid[1], \"minPath: grid is not a square\")\n  \
    \      s_grid[i] = {}\n        for j, cell in ipairs(row) do\n            assert(type(cell)\
    \ == \"number\", \"minPath: all grid cells must be positive integers\")\n    \
    \        assert(cell >= 1 and cell <= #grid * #grid[1], \"minPath: all grid cells\
    \ must be in the range [1, N*N]\")\n            count = count + 1\n          \
    \  s_grid[i][j] = {\n                value = cell,\n                pos = {i,\
    \ j},\n                rank = count,\n                used = false\n         \
    \   }\n            s_grid_map[cell] = s_grid[i][j]\n        end\n    end\n   \
    \ assert(count == #grid * #grid[1], \"minPath: number of unique grid cells must\
    \ be N*N\")\n    -- Find the first cell\n    local prev_cell\n    for i, row in\
    \ ipairs(s_grid) do\n        for j, cell in ipairs(row) do\n            if cell.value\
    \ == 1 then\n                prev_cell = cell\n                prev_cell.used\
    \ = true\n                break\n            end\n        end\n    end\n    --\
    \ Iterate over k-1 cells\n    local path = {prev_cell.value}\n    for i = 2, k\
    \ do\n        local neighbors = get_neighbors(s_grid, prev_cell.pos)\n       \
    \ local next_cell = select_next_cell(s_grid_map, prev_cell", "  local n = #grid\n\
    \  local dist = {}\n  local dp = {}\n  local N = n * n\n  for i = 1, n do\n  \
    \  dist[i] = {}\n    dp[i] = {}\n    for j = 1, n do\n      dist[i][j] = {}\n\
    \      dp[i][j] = {}\n      for v = 1, N do\n        dist[i][j][v] = math.huge\n\
    \        dp[i][j][v] = {}\n      end\n    end\n  end\n  dist[1][1][grid[1][1]]\
    \ = 0\n  local dx = { 0, 0, 1, -1 }\n  local dy = { 1, -1, 0, 0 }\n  local que\
    \ = { { 1, 1, grid[1][1] } }\n  local head = 1\n  local tail = 1\n  while head\
    \ <= tail do\n    local x, y, v = unpack(que[head])\n    head = head + 1\n   \
    \ for i = 1, 4 do\n      local nx = x + dx[i]\n      local ny = y + dy[i]\n  \
    \    if nx >= 1 and nx <= n and ny >= 1 and ny <= n then\n        local nv = v\
    \ + grid[nx][ny]\n        if dist[nx][ny][nv] > dist[x][y][v] + 1 then\n     \
    \     dist[nx][ny][nv] = dist[x][y][v] + 1\n          dp[nx][ny][nv] = dp[x][y][v]\n\
    \          table.insert(dp[nx][ny][nv], grid[nx][ny])\n          tail = tail +\
    \ 1\n          que[tail] = { nx, ny, nv }\n        elseif dist[nx][ny][nv] ==\
    \ dist[x][y][v] + 1 then\n          local cur = dp[nx][ny][nv]\n          local\
    \ next = dp[x][y][v]\n          table.insert(next, grid[nx][ny])\n          for\
    \ i = 1, #cur do\n            if cur[i] ~= next[i", "  return {}\nend", "    local\
    \ visited = {}\n    for i = 1, #grid do\n        visited[i] = {}\n        for\
    \ j = 1, #grid[i] do\n            visited[i][j] = false\n        end\n    end\n\
    \    local function dfs(x, y, k, lst)\n        if k < 0 then\n            return\
    \ nil\n        end\n        visited[x][y] = true\n        lst[#lst + 1] = grid[x][y]\n\
    \        if k == 0 then\n            return lst\n        end\n        local d\
    \ = 0\n        local candidates = {}\n        for i = 1, 4 do\n            local\
    \ x1, y1 = x + dx[i], y + dy[i]\n            if x1 >= 1 and x1 <= #grid and y1\
    \ >= 1 and y1 <= #grid[x1] and not visited[x1][y1] then\n                d = d\
    \ + 1\n                candidates[d] = {x1, y1}\n            end\n        end\n\
    \        local min = nil\n        for i = 1, d do\n            local x1, y1 =\
    \ candidates[i][1], candidates[i][2]\n            local tmp = dfs(x1, y1, k -\
    \ 1, {})\n            if tmp then\n                if not min or less(tmp, min)\
    \ then\n                    min = tmp\n                end\n            end\n\
    \        end\n        visited[x][y] = false\n        if min then\n           \
    \ return min\n        end\n        lst[#lst] = nil\n        return nil\n    end\n\
    \    local ans = nil\n    for i = 1, #grid do\n        for j = 1, #grid[i] do\n\
    \            local tmp = dfs(i, j, k, {})\n            if tmp then\n         \
    \       if not ans or less(tmp, ans) then\n                    ans = tmp\n   \
    \             end\n            end\n        end\n    end\n    return ans\nend",
  "    local n = #grid\n    if k == 1 then\n        return grid[1][1]\n    end\n \
    \   -- sort all the possible paths\n    local all = {}\n    local function dfs(x,\
    \ y, cnt, pre)\n        if cnt == 0 then\n            table.insert(all, pre)\n\
    \            return\n        end\n        for _, v in ipairs({{1, 0}, {-1, 0},\
    \ {0, 1}, {0, -1}}) do\n            local xx, yy = x + v[1], y + v[2]\n      \
    \      if xx >= 1 and xx <= n and yy >= 1 and yy <= n then\n                dfs(xx,\
    \ yy, cnt - 1, pre .. grid[xx][yy])\n            end\n        end\n    end\n \
    \   dfs(1, 1, k - 1, grid[1][1])\n    table.sort(all)\n    return all[1]\nend",
  "  local n = #grid\n  local val = {}\n  for i = 1, n do\n    for j = 1, n do\n \
    \     table.insert(val, grid[i][j])\n    end\n  end\n  table.sort(val)\n  local\
    \ function at(i, j)\n    return grid[i][j]\n  end\n  local function valid(i, j)\n\
    \    return i >= 1 and i <= n and j >= 1 and j <= n\n  end\n  local steps = {\
    \ { at(1, 1) } }\n  local memo = {}\n  local dx = { -1, 0, 1, 0 }\n  local dy\
    \ = { 0, 1, 0, -1 }\n  local function nextSteps(step)\n    local nextSteps = {}\n\
    \    for i = 1, #step do\n      local x, y = 0, 0\n      for j = 1, n do\n   \
    \     for l = 1, n do\n          if at(j, l) == step[i] then\n            x, y\
    \ = j, l\n            break\n          end\n        end\n      end\n      for\
    \ j = 1, 4 do\n        local nx, ny = x + dx[j], y + dy[j]\n        if valid(nx,\
    \ ny) then\n          local newStep = table.clone(step)\n          table.insert(newStep,\
    \ at(nx, ny))\n          table.insert(nextSteps, newStep)\n        end\n     \
    \ end\n    end\n    return nextSteps\n  end\n  for i = 2, k do\n    local newSteps\
    \ = {}\n    for j = 1, #steps do\n      local nexts = nextSteps(steps[j])\n  \
    \    for l = 1, #nexts do\n        local next = nexts[l]\n        table.sort(next)\n\
    \        if not memo[next] then\n          memo[next] = true\n          table.insert(newSteps,\
    \ next)\n        end\n      end\n    end\n    steps = newSteps\n  end\n  table.sort(steps,\
    \ function(a, b)\n    for i = 1, k do\n      if a[i] < b[i] then\n", "  local\
    \ M = #grid\n  local max = M * M\n  local min = max + 1\n  local minPath = { min\
    \ }\n  local paths = {}\n  for i = 1, M do\n    for j = 1, M do\n      local visited\
    \ = {}\n      local path = {}\n      local function helper(i, j, idx)\n      \
    \  if visited[i] == nil then\n          visited[i] = {}\n        end\n       \
    \ if visited[i][j] == nil then\n          visited[i][j] = true\n          path[idx]\
    \ = grid[i][j]\n          if idx == k then\n            local total = 0\n    \
    \        for _, v in ipairs(path) do\n              total = total * max + v\n\
    \            end\n            paths[total] = path\n            if total < min\
    \ then\n              min = total\n              minPath = path\n            end\n\
    \          else\n            if i > 1 then\n              helper(i - 1, j, idx\
    \ + 1)\n            end\n            if i < M then\n              helper(i + 1,\
    \ j, idx + 1)\n            end\n            if j > 1 then\n              helper(i,\
    \ j - 1, idx + 1)\n            end\n            if j < M then\n              helper(i,\
    \ j + 1, idx + 1)\n            end\n          end\n          path[idx] = nil\n\
    \          visited[i][j] = nil\n        end\n      end\n      helper(i, j, 1)\n\
    \    end\n  end\n  return minPath\nend", "    local size = #grid\n    local rows\
    \ = {}\n    for i = 1, size do\n        rows[i] = {}\n        for j = 1, size\
    \ do\n            rows[i][j] = {}\n        end\n    end\n    local ans = {}\n\
    \    local l = {}\n    local e = {}\n    rows[1][1][grid[1][1]] = 0\n    table.insert(l,\
    \ {1, 1, grid[1][1]})\n    while l[1] do\n        local x, y, val = table.unpack(table.remove(l,\
    \ 1))\n        if x == size and y == size then\n            local cur = {val}\n\
    \            table.insert(e, cur)\n            ans = cur\n            break\n\
    \        end\n        if x > 1 then\n            local nval = grid[x - 1][y]\n\
    \            local visited = rows[x - 1][y][nval]\n            if visited then\n\
    \                if val < nval and not visited then\n                    table.insert(l,\
    \ {x - 1, y, nval})\n                    rows[x - 1][y][nval] = false\n      \
    \          end\n            else\n                table.insert(l, {x - 1, y, nval})\n\
    \                rows[x - 1][y][nval] = false\n            end\n        end\n\
    \        if x < size then\n            local nval = grid[x + 1][y]\n         \
    \   local visited = rows[x + 1][y][nval]\n            if visited then\n      \
    \          if val < nval and not visited then\n                    table.insert(l,\
    \ {x + 1, y, nval})\n                    rows[x + 1][y][nval] = false\n      \
    \          end\n            else\n                table.insert(l, {x + 1, y, nval})\n\
    \                rows[x + 1][y][nval] = false\n            end\n        end\n\
    \        if y > 1 then\n            local nval = grid[x][y - 1]\n            local\
    \ visited = rows[x][y - 1][nval]\n            if visited then\n              \
    \  if val < nval and not visited then\n                    table.insert(l, {x,\
    \ y - 1, nval})", "  local N = #grid\n  local seen = {}\n  local dfs\n  local\
    \ function lex(p, q)\n    for i = 1, #p do\n      if p[i] < q[i] then\n      \
    \  return true\n      elseif p[i] > q[i] then\n        return false\n      end\n\
    \    end\n    return false\n  end\n  dfs = function(r, c, k, path)\n    if k ==\
    \ 0 then\n      if seen[path] then\n        if lex(path, seen[path]) then\n  \
    \        seen[path] = nil\n        end\n      else\n        seen[path] = path\n\
    \      end\n      return\n    end\n    local rs = {r - 1, r, r + 1}\n    local\
    \ cs = {c - 1, c, c + 1}\n    for _, r1 in ipairs(rs) do\n      for _, c1 in ipairs(cs)\
    \ do\n        if r1 >= 1 and r1 <= N and c1 >= 1 and c1 <= N then\n          dfs(r1,\
    \ c1, k - 1, path .. grid[r1][c1])\n        end\n      end\n    end\n  end\n \
    \ dfs(1, 1, k, grid[1][1])\n  for _, v in pairs(seen) do\n    return v\n  end\n\
    end", "    local n = #grid\n    local v = {}\n    for i = 1, n do\n        v[i]\
    \ = {}\n        for j = 1, n do\n            v[i][j] = 0\n        end\n    end\n\
    \    local function recur(x, y, num)\n        if v[x][y] ~= 0 then\n         \
    \   return num > v[x][y]\n        end\n        v[x][y] = num\n        if num ==\
    \ k then\n            return true\n        end\n        for dx = -1, 1 do\n  \
    \          for dy = -1, 1 do\n                if math.abs(dx) + math.abs(dy) ==\
    \ 1 then\n                    local nx = x + dx\n                    local ny\
    \ = y + dy\n                    if nx >= 1 and nx <= n and ny >= 1 and ny <= n\
    \ and\n                       recur(nx, ny, num + 1) then\n                  \
    \      return true\n                    end\n                end\n           \
    \ end\n        end\n        return false\n    end\n    local function dfs(x, y)\n\
    \        if not v[x][y] then\n            v[x][y] = true\n            for dx =\
    \ -1, 1 do\n                for dy = -1, 1 do\n                    if math.abs(dx)\
    \ + math.abs(dy) == 1 then\n                        local nx = x + dx\n      \
    \                  local ny = y + dy\n                        if nx >= 1 and nx\
    \ <= n and ny >= 1 and ny <= n and\n                           not v[nx][ny] then\n\
    \                            dfs(nx, ny)\n                        end\n      \
    \              end\n                end\n            end\n        end\n    end\n\
    \    for i = 1, n do\n        for j = 1, n do\n            if v[i][j] == 0 then\n\
    \                dfs(i, j)\n            end\n        end\n    end\n    for i =\
    \ 1, n do\n        for j = 1, n do\n            if not v[i][j] then\n        \
    \        return {}\n            end\n        end\n    end\n    for i = 1, n do\n\
    \        for j = 1, n do\n            if recur(i, j, 1)", "    local N = #grid\n\
    \    local visited = {}\n    local function dfs(i, j, path)\n        if i < 1\
    \ or i > N or j < 1 or j > N or k == 0 then\n            return false\n      \
    \  end\n        if visited[i][j] then\n            return false\n        end\n\
    \        visited[i][j] = true\n        table.insert(path, grid[i][j])\n      \
    \  if k == 1 then\n            return true\n        end\n        if dfs(i + 1,\
    \ j, path) or dfs(i - 1, j, path) or dfs(i, j + 1, path) or dfs(i, j - 1, path)\
    \ then\n            return true\n        end\n        table.remove(path)\n   \
    \     visited[i][j] = false\n        return false\n    end\n    for i = 1, N do\n\
    \        visited[i] = {}\n    end\n    local path = {}\n    for i = 1, N do\n\
    \        for j = 1, N do\n            if dfs(i, j, path) then\n              \
    \  return path\n            end\n        end\n    end\nend", "  local n = #grid\n\
    \  local function dfs(i, j, k, cur)\n    if k == 0 then\n      return {grid[i][j]}\n\
    \    end\n    local min = nil\n    local path = nil\n    local tmp = nil\n   \
    \ if i > 1 then\n      tmp = table.concat(dfs(i - 1, j, k - 1, cur))\n      if\
    \ not min or tmp < min then\n        min = tmp\n        path = {grid[i][j]}\n\
    \      end\n    end\n    if i < n then\n      tmp = table.concat(dfs(i + 1, j,\
    \ k - 1, cur))\n      if not min or tmp < min then\n        min = tmp\n      \
    \  path = {grid[i][j]}\n      end\n    end\n    if j > 1 then\n      tmp = table.concat(dfs(i,\
    \ j - 1, k - 1, cur))\n      if not min or tmp < min then\n        min = tmp\n\
    \        path = {grid[i][j]}\n      end\n    end\n    if j < n then\n      tmp\
    \ = table.concat(dfs(i, j + 1, k - 1, cur))\n      if not min or tmp < min then\n\
    \        min = tmp\n        path = {grid[i][j]}\n      end\n    end\n    return\
    \ path\n  end\n  local res = nil\n  for i = 1, n do\n    for j = 1, n do\n   \
    \   local tmp = table.concat(dfs(i, j, k, {}))\n      if not res or tmp < res\
    \ then\n        res = tmp\n      end\n    end\n  end\n  local out = {}\n  for\
    \ i = 1, k do\n    table.insert(out, tonumber(res:sub(i, i)))\n  end\n  return\
    \ out\nend", "    local N = #grid\n    local t = {}\n    local minPath = {}\n\
    \    local minSum = math.huge\n    local function backtracking(i, j, sum, path)\n\
    \        if i < 1 or i > N or j < 1 or j > N or k < 0 then\n            return\n\
    \        end\n        local sum = sum + grid[i][j]\n        if sum > minSum then\n\
    \            return\n        end\n        if k == 0 then\n            if sum <\
    \ minSum then\n                minSum = sum\n                minPath = {unpack(path)}\n\
    \            elseif sum == minSum then\n                local lst_A = {unpack(path)}\n\
    \                local lst_B = {unpack(minPath)}\n                if #lst_A ~=\
    \ #lst_B then\n                    return\n                end\n             \
    \   for i, v in ipairs(lst_A) do\n                    if v < lst_B[i] then\n \
    \                       minPath = {unpack(path)}\n                        break\n\
    \                    elseif v > lst_B[i] then\n                        break\n\
    \                    end\n                end\n            end\n            return\n\
    \        end\n        table.insert(path, grid[i][j])\n        backtracking(i +\
    \ 1, j, sum, path)\n        backtracking(i - 1, j, sum, path)\n        backtracking(i,\
    \ j + 1, sum, path)\n        backtracking(i, j - 1, sum, path)\n        table.remove(path)\n\
    \    end\n    for i = 1, N do\n        for j = 1, N do\n            backtracking(i,\
    \ j, 0, {})\n        end\n    end\n    return minPath\nend", "  -- return the\
    \ list of values of the cells in the minimum path\n  local grid, k = { { 2, 9,\
    \ 4 }, { 7, 1, 8 }, { 6, 3, 5 } }, 10\n  local hash, w = {}, { { 0, 1 }, { 0,\
    \ -1 }, { 1, 0 }, { -1, 0 } }\n  local r, c, d, t = #grid, #grid[1], {}, {}\n\
    \  for i = 1, r do\n    hash[i] = {}\n    for j = 1, c do\n      hash[i][j] =\
    \ 0\n    end\n  end\n  local function dfs(x, y, step, list)\n    if step == k\
    \ + 1 then\n      table.insert(d, list)\n      return\n    end\n    for i = 1,\
    \ 4 do\n      local tx, ty = x + w[i][1], y + w[i][2]\n      if tx >= 1 and tx\
    \ <= r and ty >= 1 and ty <= c and hash[tx][ty] == 0 then\n        hash[tx][ty]\
    \ = 1\n        local v = {}\n        for j = 1, #list do v[j] = list[j] end\n\
    \        table.insert(v, grid[tx][ty])\n        dfs(tx, ty, step + 1, v)\n   \
    \     hash[tx][ty] = 0\n      end\n    end\n  end\n  for i = 1, r do\n    for\
    \ j = 1, c do\n      hash[i][j] = 1\n      dfs(i, j, 1, { grid[i][j] })\n    \
    \  hash[i][j] = 0\n    end\n  end\n  local v = d[1]\n  for i = 2, #d do\n    if\
    \ d[i] < v then v = d[i] end\n  end\n  return v\nend", "\tgrid = grid:split(',')\n\
    \tlocal n = #grid\n\tlocal vals = {}\n\tfor i = 1, n * n do\n\t\tvals[#vals +\
    \ 1] = i\n\tend\n\ttable.sort(vals)\n\tlocal gridVals = {}\n\tfor i = 1, n do\n\
    \t\tgridVals[i] = {}\n\t\tfor j = 1, n do\n\t\t\tgridVals[i][j] = tonumber(grid[(i\
    \ - 1) * n + j])\n\t\tend\n\tend\n\tlocal memo = {}\n\tlocal function dfs(i, j,\
    \ curPath)\n\t\tif memo[i] and memo[i][j] then\n\t\t\treturn memo[i][j]\n\t\t\
    end\n\t\tlocal path = {}\n\t\tfor _, v in ipairs(curPath) do\n\t\t\tpath[#path\
    \ + 1] = v\n\t\tend\n\t\tpath[#path + 1] = gridVals[i][j]\n\t\tif #path == k then\n\
    \t\t\tlocal ret = {}\n\t\t\tfor _, v in ipairs(path) do\n\t\t\t\tret[#ret + 1]\
    \ = v\n\t\t\tend\n\t\t\tif not memo[i] then\n\t\t\t\tmemo[i] = {}\n\t\t\tend\n\
    \t\t\tmemo[i][j] = ret\n\t\t\treturn ret\n\t\tend\n\t\tlocal minList = {}\n\t\t\
    for _, v in ipairs(vals) do\n\t\t\tminList[#minList + 1] = v\n\t\tend\n\t\tif\
    \ i > 1 then\n\t\t\tlocal nextList = dfs(i - 1, j, path)\n\t\t\tif nextList then\n\
    \t\t\t\tlocal min = minList\n\t\t\t\tlocal next = nextList\n\t\t\t\tfor i = 1,\
    \ k do\n\t\t\t\t\tif min[i] < next[i] then\n\t\t\t\t\t\tbreak\n\t\t\t\t\telseif\
    \ min[i] > next[i] then\n\t\t\t\t\t\tmin = next\n\t\t\t\t\t\tbreak\n", "  if #grid\
    \ == 0 or #grid[1] == 0 then\n    return {}\n  end\n  local w, h = #grid[1], #grid\n\
    \  local function get(x, y)\n    if x < 1 or x > w or y < 1 or y > h then\n  \
    \    return nil\n    end\n    return grid[y][x]\n  end\n  local function dfs(x,\
    \ y, k, state)\n    if k == 0 then\n      state.value = get(x, y)\n      return\
    \ true\n    end\n    local minValue = nil\n    local minPath = nil\n    for _,\
    \ v in ipairs({ {x - 1, y}, {x + 1, y}, {x, y - 1}, {x, y + 1} }) do\n      local\
    \ cellValue = get(v[1], v[2])\n      if cellValue then\n        if not minValue\
    \ or cellValue < minValue then\n          local ok = dfs(v[1], v[2], k - 1, state)\n\
    \          if ok then\n            minValue = cellValue\n            minPath =\
    \ state.path\n          end\n        end\n      end\n    end\n    if minValue\
    \ then\n      state.value = minValue\n      state.path = minPath\n      return\
    \ true\n    end\n    return false\n  end\n  local state = { value = 0, path =\
    \ {} }\n  local result = {}\n  for y = 1, h do\n    for x = 1, w do\n      local\
    \ ok = dfs(x, y, k, state)\n      if ok then\n        if #result == 0 then\n \
    \         result = state.path\n        else\n          for i = 1, #result do\n\
    \            if result[i] ~= state.path[i] then\n              result = result[i]\
    \ < state.path[i] and result or state.path\n              break\n            end\n\
    \          end\n        end\n      end\n    end\n  end\n  return result\nend",
  "    local N = #grid\n    assert(N >= 2 and k > 0 and k <= N * N)\n    -- Min path\
    \ from (row, col) with length k.\n    local memo = {}\n    for row = 1, N do\n\
    \        memo[row] = {}\n        for col = 1, N do\n            memo[row][col]\
    \ = {}\n        end\n    end\n    local function solve(row, col, length)\n   \
    \     if length == 1 then\n            return {grid[row][col]}\n        end\n\
    \        if length < 1 or row < 1 or row > N or col < 1 or col > N then\n    \
    \        return nil\n        end\n        if memo[row][col][length] then\n   \
    \         return memo[row][col][length]\n        end\n        local ans = nil\n\
    \        local first = grid[row][col]\n        local l1 = solve(row + 1, col,\
    \ length - 1)\n        if l1 and (not ans or l1 < ans) then\n            ans =\
    \ l1\n        end\n        local l2 = solve(row - 1, col, length - 1)\n      \
    \  if l2 and (not ans or l2 < ans) then\n            ans = l2\n        end\n \
    \       local l3 = solve(row, col + 1, length - 1)\n        if l3 and (not ans\
    \ or l3 < ans) then\n            ans = l3\n        end\n        local l4 = solve(row,\
    \ col - 1, length - 1)\n        if l4 and (not ans or l4 < ans) then\n       \
    \     ans = l4\n        end\n        if ans then\n            table.insert(ans,\
    \ 1, first)\n        end\n        memo[row][col][length] = ans\n        return\
    \ ans\n    end\n    local ans = nil\n    for row = 1, N do\n        for col =\
    \ 1, N do\n            local path = solve(row, col, k)\n            if path and\
    \ (not ans or path < ans) then\n                ans = path\n            end\n\
    \        end\n    end\n    return ans\nend", end, "\tlocal N = #grid\n\tlocal\
    \ DP = { {[0] = {0}} }\n\tfor i = 1, N do\n\t\tDP[i] = { {0} }\n\t\tfor j = 1,\
    \ N do\n\t\t\tDP[i][j] = { {0} }\n\t\tend\n\tend\n\tfor step = 1, k do\n\t\tlocal\
    \ tmp = { {0} }\n\t\tfor i = 1, N do\n\t\t\ttmp[i] = { {0} }\n\t\t\tfor j = 1,\
    \ N do\n\t\t\t\ttmp[i][j] = { {0} }\n\t\t\tend\n\t\tend\n\t\tfor i = 1, N do\n\
    \t\t\tfor j = 1, N do\n\t\t\t\ttmp[i][j] = DP[i][j]\n\t\t\t\tif i > 1 then\n\t\
    \t\t\t\tlocal t = DP[i - 1][j]\n\t\t\t\t\tif t[#t][1] < tmp[i][j][#tmp[i][j]][1]\
    \ then\n\t\t\t\t\t\ttmp[i][j] = {}\n\t\t\t\t\t\tfor _, pair in ipairs(t) do\n\t\
    \t\t\t\t\t\ttmp[i][j][#tmp[i][j] + 1] = { pair[1], pair[2] }\n\t\t\t\t\t\tend\n\
    \t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif j > 1 then\n\t\t\t\t\tlocal t = DP[i][j\
    \ - 1]\n\t\t\t\t\tif t[#t][1] < tmp[i][j][#tmp[i][j]][1] then\n\t\t\t\t\t\ttmp[i][j]\
    \ = {}\n\t\t\t\t\t\tfor _, pair in ipairs(t) do\n\t\t\t\t\t\t\ttmp[i][j][#tmp[i][j]\
    \ + 1] = { pair[1], pair[2] }\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\
    \t\t\tif i < N then\n\t\t\t\t\tlocal t =", "  local N = #grid\n  -- dp[i][j][l][m]\
    \ means the minimum path of length l, starting at cell (i, j), \n  -- the first\
    \ m elements of that path are already added to the ordered list.\n  local dp =\
    \ {}\n  for i = 1, N do\n    dp[i] = {}\n    for j = 1, N do\n      dp[i][j] =\
    \ {}\n      for l = 1, k do\n        dp[i][j][l] = {}\n        for m = 1, l do\n\
    \          dp[i][j][l][m] = {}\n        end\n      end\n    end\n  end\n  -- initialize\
    \ base case\n  for i = 1, N do\n    for j = 1, N do\n      dp[i][j][1][1] = {grid[i][j]}\n\
    \    end\n  end\n  -- initialize boundary\n  for i = 1, N do\n    for j = 1, N\
    \ do\n      for l = 2, k do\n        local tmp = {}\n        if i - 1 >= 1 then\n\
    \          local dp_val = dp[i - 1][j][l - 1][l - 1]\n          if #dp_val > 0\
    \ then\n            table.insert(tmp, dp_val)\n          end\n        end\n  \
    \      if i + 1 <= N then\n          local dp_val = dp[i + 1][j][l - 1][l - 1]\n\
    \          if #dp_val > 0 then\n            table.insert(tmp, dp_val)\n      \
    \    end\n        end\n        if j - 1 >= 1 then\n          local dp_val = dp[i][j\
    \ - 1][l - 1][l - 1]\n          if #dp_val > 0 then\n            table.insert(tmp,\
    \ dp_val)\n          end\n        end\n        if j + 1 <= N then\n          local\
    \ dp_val = dp[i][j + 1][l - 1][l - 1]\n          if #dp_val > 0 then\n       \
    \     table.insert(tmp, dp_val)\n          end\n        end\n        table.sort(tmp,\
    \ function(a,", "\treturn {}\nend", "    if k <= 0 then\n        return {}\n \
    \   end\n    assert(#grid == #grid[1], \"grid must be a square grid\")\n    assert(k\
    \ <= #grid * #grid[1], \"path cannot exceed number of cells\")\n    local N =\
    \ #grid\n    local grid_to_index, index_to_grid = {}, {}\n    for i, row in ipairs(grid)\
    \ do\n        for j, v in ipairs(row) do\n            local index = (i - 1) *\
    \ N + j\n            grid_to_index[i][j] = index\n            index_to_grid[index]\
    \ = { i, j }\n        end\n    end\n    local function get_neighbors(i, j)\n \
    \       local neighbors = {}\n        if i > 1 then\n            neighbors[#neighbors\
    \ + 1] = { i - 1, j }\n        end\n        if i < N then\n            neighbors[#neighbors\
    \ + 1] = { i + 1, j }\n        end\n        if j > 1 then\n            neighbors[#neighbors\
    \ + 1] = { i, j - 1 }\n        end\n        if j < N then\n            neighbors[#neighbors\
    \ + 1] = { i, j + 1 }\n        end\n        return neighbors\n    end\n    local\
    \ function sum(t)\n        local s = 0\n        for _, v in ipairs(t) do\n   \
    \         s = s + v\n        end\n        return s\n    end\n    local function\
    \ less_than(a, b)\n        for i = 1, k do\n            if a[i] ~= b[i] then\n\
    \                return a[i] < b[i]\n            end\n        end\n        return\
    \ false\n    end\n    local function bfs(s, e)\n        local visited = {}\n \
    \       local queue = {}\n        local paths = {}\n        local nodes = {}\n\
    \        local i, j = unpack(index_to_grid[s])\n        local path = { grid[i][j]\
    \ }\n        local node = { i, j }\n        visited[i][j] = true\n        table.insert(queue,\
    \ path)\n        table.insert(nodes, node)\n", "    local n = #grid\n    assert(n\
    \ >= 2)\n    assert(k >= n * n)\n    for i = 1, n do\n        assert(#grid[i]\
    \ == n)\n        local t = {}\n        for j = 1, n do\n            local v =\
    \ grid[i][j]\n            assert(v >= 1 and v <= n * n)\n            t[v] = true\n\
    \        end\n        for j = 1, n * n do\n            assert(t[j])\n        end\n\
    \    end\n    -- TODO: your code here\nend", "  local w, h = #grid[1], #grid\n\
    \  local minPath = {}\n  local seen = {}\n  local q = List.new()\n  local function\
    \ push(i, j, path)\n    if not seen[i] then seen[i] = {} end\n    if not seen[i][j]\
    \ then\n      seen[i][j] = true\n      local val = grid[i][j]\n      List.pushright(q,\
    \ {i, j, {val, path}})\n    end\n  end\n  push(1, 1, {})\n  local function pop()\n\
    \    local res = List.popleft(q)\n    return res[1], res[2], res[3]\n  end\n \
    \ while #q > 0 do\n    local i, j, path = pop()\n    if #path == k then\n    \
    \  minPath = path\n      break\n    end\n    if i > 1 then push(i - 1, j, path)\
    \ end\n    if i < h then push(i + 1, j, path) end\n    if j > 1 then push(i, j\
    \ - 1, path) end\n    if j < w then push(i, j + 1, path) end\n  end\n  return\
    \ minPath\nend", "    if k <= 0 then\n        return {}\n    end\n    local n\
    \ = #grid\n    local minPath = {}\n    local backtrackPath = {}\n    for i = 1,\
    \ n do\n        backtrackPath[i] = {}\n        for j = 1, n do\n            backtrackPath[i][j]\
    \ = {}\n        end\n    end\n    -- initialize minPath\n    minPath[0] = {}\n\
    \    for i = 1, n do\n        minPath[0][i] = {}\n        for j = 1, n do\n  \
    \          minPath[0][i][j] = {}\n        end\n    end\n    -- initialize minPath\
    \ with distance 1\n    for i = 1, n do\n        minPath[1][i][i] = {grid[i][i]}\n\
    \    end\n    for i = 1, n do\n        for j = 1, n do\n            if i ~= j\
    \ then\n                local minVal\n                local minValRow\n      \
    \          local minValCol\n                local minValBacktrackRow\n       \
    \         local minValBacktrackCol\n                -- from i, j-1\n         \
    \       if j - 1 >= 1 then\n                    local val = grid[i][j]\n     \
    \               local candVal = minPath[1][i][j - 1][1]\n                    if\
    \ candVal == nil or candVal > val then\n                        minVal = val\n\
    \                        minValRow = i\n                        minValCol = j\n\
    \                        minValBacktrackRow = i\n                        minValBacktrackCol\
    \ = j - 1\n                    end\n                end\n                -- from\
    \ i-1, j\n                if i - 1 >= 1 then\n                    local val =\
    \ grid[i][j]\n                    local candVal = minPath[1][i - 1][j][1]\n  \
    \                  if candVal == nil or candVal > val then\n                 \
    \       minVal = val\n                        minValRow = i\n                \
    \        minValCol = j\n                        minValBacktrackRow = i - 1\n \
    \                       minValBacktrackCol = j\n                    end\n    \
    \            end\n                -- from i, j+1\n                if j + 1 <=\
    \ n then\n                    local val = grid[i][j]\n                    local\
    \ candVal = minPath[1][i][j + 1][1]\n                    if candVal ==", "  --\
    \ make a data structure for each cell in the grid, to keep track of\n  -- whether\
    \ we've visited it, and its relative position to the other cells.\n  -- assumes\
    \ grid is square.\n  local cells = {}\n  for i = 1, #grid do\n    cells[i] = {}\n\
    \    for j = 1, #grid[i] do\n      cells[i][j] = {\n        visited = false,\n\
    \        value = grid[i][j],\n        neighbors = {},\n      }\n    end\n  end\n\
    \  -- now that cells are set up, set up the neighbors\n  for i = 1, #cells do\n\
    \    for j = 1, #cells[i] do\n      -- top\n      if i > 1 then\n        cells[i][j].neighbors[#cells[i][j].neighbors\
    \ + 1] = cells[i - 1][j]\n      end\n      -- bottom\n      if i < #cells then\n\
    \        cells[i][j].neighbors[#cells[i][j].neighbors + 1] = cells[i + 1][j]\n\
    \      end\n      -- left\n      if j > 1 then\n        cells[i][j].neighbors[#cells[i][j].neighbors\
    \ + 1] = cells[i][j - 1]\n      end\n      -- right\n      if j < #cells[i] then\n\
    \        cells[i][j].neighbors[#cells[i][j].neighbors + 1] = cells[i][j + 1]\n\
    \      end\n    end\n  end\n  -- now cells are all set up, it's time to recurse\
    \ through the grid and\n  -- find the minimum path\n  local minLst = {}\n  for\
    \ i = 1, #cells do\n    for j = 1, #cells[i] do\n      local path = {}\n     \
    \ local cell = cells[i][j]\n      if #cell.neighbors == 0 then\n        -- this\
    \ cell is at the edge of the grid, it can't be part of a path\n        -- of length\
    \ k.\n        goto next_cell\n      end\n      -- start with the initial cell\n\
    \      path[#path + 1] = cell\n      local lst = min", "    local m, n = #grid,\
    \ #grid[1]\n    if k == 1 then\n        return {grid[1][1]}\n    end\n    local\
    \ matrix, minK = {}, {}\n    for i = 1, m do\n        matrix[i] = {}\n       \
    \ for j = 1, n do\n            matrix[i][j] = {}\n        end\n    end\n    matrix[1][1][1]\
    \ = grid[1][1]\n    for j = 2, n do\n        matrix[1][j][1] = matrix[1][j - 1][1]\
    \ + grid[1][j]\n    end\n    for i = 2, m do\n        matrix[i][1][1] = matrix[i\
    \ - 1][1][1] + grid[i][1]\n    end\n    for i = 2, m do\n        for j = 2, n\
    \ do\n            local val = grid[i][j]\n            for key, lst in pairs(matrix[i\
    \ - 1][j]) do\n                local up = lst[#lst] + val\n                local\
    \ newLst = {}\n                for _, val in ipairs(lst) do\n                \
    \    table.insert(newLst, val)\n                end\n                table.insert(newLst,\
    \ val)\n                if not matrix[i][j][key + 1] or matrix[i][j][key + 1][1]\
    \ > up then\n                    matrix[i][j][key + 1] = newLst\n            \
    \    end\n            end\n            for key, lst in pairs(matrix[i][j - 1])\
    \ do\n                local left = lst[#lst] + val\n                local newLst\
    \ = {}\n                for _, val in ipairs(lst) do\n                    table.insert(newLst,\
    \ val)\n                end\n                table.insert(newLst, val)\n     \
    \           if not matrix[i][j][key + 1] or matrix[i][j][key + 1][1] > left then\n\
    \                    matrix[i][j][key + 1] = newLst\n                end\n   \
    \         end\n        end\n    end\n    for i = 1, m do\n        for j = 1, n\
    \ do\n            for key", "    return minPath_iterative(grid, k)\nend", "  --\
    \ Write your code here\n  -- To print results to the standard output you can use\
    \ print\n  -- Example:\n  --   print(\"Hello world!\")\nend", "    local n = #grid\n\
    \    if k < 1 or k > n * n then\n        return nil\n    end\n    local function\
    \ get_val(x, y)\n        if x < 1 or x > n or y < 1 or y > n then\n          \
    \  return 1\n        end\n        return grid[x][y]\n    end\n    local function\
    \ cmp(a, b)\n        for i = 1, k do\n            if a[i] ~= b[i] then\n     \
    \           return a[i] < b[i]\n            end\n        end\n        return false\n\
    \    end\n    local seen = {}\n    local q = {{{0, 0}, {}, 0}}\n    while #q >\
    \ 0 do\n        local node = table.remove(q, 1)\n        local u, path, steps\
    \ = node[1], node[2], node[3]\n        if steps == k then\n            return\
    \ path\n        end\n        local ux, uy = u[1], u[2]\n        local key = ux\
    \ * n + uy\n        if not seen[key] then\n            seen[key] = true\n    \
    \        local val = get_val(ux, uy)\n            path[#path + 1] = val\n    \
    \        local ds = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}\n            for _, d in\
    \ ipairs(ds) do\n                local vx, vy = ux + d[1], uy + d[2]\n       \
    \         if vx >= 1 and vx <= n and vy >= 1 and vy <= n then\n              \
    \      local v = {vx, vy}\n                    local w = {v, {}, steps + 1}\n\
    \                    local i = 1\n                    while i <= #q and cmp(q[i],\
    \ w) do\n                        i = i + 1\n                    end\n        \
    \            table.insert(q, i, w)\n                end\n            end\n   \
    \     end\n    end\n    return nil\nend", "  error(\"Not implemented yet\")\n\
    end", "    local n = #grid\n    assert(n >= 2)\n    assert(k >= 1)\n    assert(k\
    \ <= n * n)\n    local p = 0\n    local r = 0\n    local c = 0\n    local function\
    \ add(v)\n        assert(v >= 1)\n        assert(v <= n * n)\n        if p >=\
    \ k then\n            return\n        end\n        p = p + 1\n        r = r *\
    \ n * n + v\n        c = c * n * n + v\n    end\n    add(grid[1][1])\n    local\
    \ dr = {1, 0, -1, 0}\n    local dc = {0, 1, 0, -1}\n    while p < k do\n     \
    \   local minv = math.huge\n        local minr = nil\n        local minc = nil\n\
    \        for i = 1, 4 do\n            local tr = 1 + dr[i]\n            local\
    \ tc = 1 + dc[i]\n            if tr >= 1 and tr <= n and tc >= 1 and tc <= n then\n\
    \                local v = grid[tr][tc]\n                if v < minv then\n  \
    \                  minv = v\n                    minr = tr\n                 \
    \   minc = tc\n                end\n            end\n        end\n        assert(minr\
    \ ~= nil)\n        add(grid[minr][minc])\n    end\n    local a = {}\n    while\
    \ r > 0 do\n        local v = r % (n * n)\n        r = (r - v) / (n * n)\n   \
    \     table.insert(a, 1, v)\n    end\n    return a\nend", "  error(\"Not implemented\"\
    )\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
