name: HumanEval_43_pairs_sum_to_zero
language: lua
prompt: "-- pairs_sum_to_zero takes a list of integers as an input.\n-- it returns\
  \ True if there are two distinct elements in the list that\n-- sum to zero, and\
  \ False otherwise.\nlocal function pairs_sum_to_zero(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = pairs_sum_to_zero\n\
  \    lu.assertEquals(candidate({1, 3, 5, 0}), false)\n    lu.assertEquals(candidate({1,\
  \ 3, -2, 1}), false)\n    lu.assertEquals(candidate({1, 2, 3, 7}), false)\n    lu.assertEquals(candidate({2,\
  \ 4, -5, 3, 5, 7}), true)\n    lu.assertEquals(candidate({1}), false)\n    lu.assertEquals(candidate({-3,\
  \ 9, -1, 3, 2, 30}), true)\n    lu.assertEquals(candidate({-3, 9, -1, 3, 2, 31}),\
  \ true)\n    lu.assertEquals(candidate({-3, 9, -1, 4, 2, 30}), false)\n    lu.assertEquals(candidate({-3,\
  \ 9, -1, 4, 2, 31}), false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local positive_elements = {}\n    local negative_elements = {}\n\
    \    for _, v in ipairs(l) do\n        if v < 0 then\n            table.insert(negative_elements,\
    \ v)\n        elseif v > 0 then\n            table.insert(positive_elements, v)\n\
    \        else\n            return true\n        end\n    end\n    for _, e in\
    \ ipairs(positive_elements) do\n        for _, f in ipairs(negative_elements)\
    \ do\n            if e + f == 0 then\n                return true\n          \
    \  end\n        end\n    end\n    return false\nend", "  for _,x in ipairs(l)\
    \ do\n    for _,y in ipairs(l) do\n      if x ~= y and x + y == 0 then\n     \
    \   return true\n      end\n    end\n  end\n  return false\nend", "\tlocal tbl\
    \ = {}\n\tfor _, x in ipairs(l) do\n\t\ttbl[x] = true\n\tend\n\tfor _, x in ipairs(l)\
    \ do\n\t\tif tbl[-x] then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\n\
    end", "\tfor i, x in ipairs(l) do\n\t\tfor j, y in ipairs(l) do\n\t\t\tif i ~=\
    \ j and x + y == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ false\nend", "  local sum = 0\n  for _, value in ipairs(l) do\n    sum = sum\
    \ + value\n  end\n  if sum == 0 then\n    return true\n  else\n    return false\n\
    \  end\nend", "\tif #l < 2 then\n\t\treturn false\n\tend\n\t\n\tlocal zero_set\
    \ = Set {}\n\t\n\tfor i = 1, #l do\n\t\tif zero_set[-l[i]] then\n\t\t\treturn\
    \ true\n\t\tend\n\t\tzero_set[l[i]] = true\n\tend\n\t\n\treturn false\nend", " \
    \   for i, x in ipairs(l) do\n        for j, y in ipairs(l) do\n            if\
    \ i ~= j and x + y == 0 then\n                return true\n            end\n \
    \       end\n    end\n    return false\nend", "  -- your code here\n  local x\
    \ = {}\n  local y = {}\n  local a = 1\n  local b = 1\n  while l[a] do\n    x[a]\
    \ = l[a]\n    a = a + 1\n  end\n  while l[b] do\n    y[b] = l[b]\n    b = b +\
    \ 1\n  end\n  for i = 1, #x do\n    for j = 1, #y do\n      if x[i] + y[j] ==\
    \ 0 then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "    for _, v in ipairs(l) do\n        for _, w in ipairs(l) do\n            if\
    \ v ~= w and v + w == 0 then\n                return true\n            end\n \
    \       end\n    end\n    return false\nend", "\tlocal complement = {}\n\tfor\
    \ _, v in ipairs(l) do\n\t\tif (complement[v] == true) then\n\t\t\treturn true\n\
    \t\tend\n\t\tcomplement[-v] = true\n\tend\n\treturn false\nend", "    local hash\
    \ = {}\n    for i = 1, #l do\n        local num = l[i]\n        if hash[-num]\
    \ then\n            return true\n        end\n        hash[num] = true\n    end\n\
    \    return false\nend", "\t-- check that the list is not empty\n\tif #l > 0 then\n\
    \t\t-- sort the list\n\t\ttable.sort(l)\n\t\t-- count the number of elements that\
    \ are equal to zero\n\t\tlocal count = 0\n\t\tlocal last = l[1]\n\t\tfor i = 1,\
    \ #l do\n\t\t\tif l[i] == 0 then\n\t\t\t\tcount = count + 1\n\t\t\tend\n\t\t\t\
    if l[i] ~= last then\n\t\t\t\tlast = l[i]\n\t\t\t\t-- if there are two distinct\
    \ elements that sum to zero then return True\n\t\t\t\tif l[i] == -l[i-1] then\n\
    \t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t-- check for repeated\
    \ zero elements\n\t\tif count > 1 then\n\t\t\treturn true\n\t\tend\n\tend\n\t\
    -- if no elements sum to zero then return False\n\treturn false\nend", "    local\
    \ seen = {}\n    for i = 1, #l do\n        local x = l[i]\n        if seen[-x]\
    \ then\n            return true\n        end\n        seen[x] = true\n    end\n\
    \    return false\nend", "    for i, v in ipairs(l) do\n        for k, v in ipairs(l)\
    \ do\n            if (i ~= k) and (v + l[k] == 0) then\n                return\
    \ true\n            end\n        end\n    end\n    return false\nend", "\ttable.sort(l)\n\
    \t-- this is a helper function --\n\tlocal function pairs_sum_to_zero_search(l,start)\n\
    \t\tif l[start] > 0 then return false end\n\t\tlocal neg_i = #l - start\n\t\t\
    while l[neg_i] >= 0 do\n\t\t\tif l[start] + l[neg_i] == 0 then return true end\n\
    \t\t\tneg_i = neg_i - 1\n\t\tend\n\t\tif start < #l then\n\t\t\treturn pairs_sum_to_zero_search(l,start+1)\n\
    \t\telse\n\t\t\treturn false\n\t\tend\n\tend\n\t-- main function --\n\treturn\
    \ pairs_sum_to_zero_search(l,1)\nend", "    for i = 1,#l do\n        for j = i+1,#l\
    \ do\n            if l[i] + l[j] == 0 then\n                return true\n    \
    \        end\n        end\n    end\n    return false\nend", "  if (l == nil) then\n\
    \    return false\n  end\n  local map = {}\n  for i, v in ipairs(l) do\n    map[v]\
    \ = i\n  end\n  for _, v in ipairs(l) do\n    if (map[-v] ~= nil) then\n     \
    \ return true\n    end\n  end\n  return false\nend", "    local zero = 0\n   \
    \ local e = false\n    for i = 1, #l do\n        local num = l[i]\n        if\
    \ num == zero then\n            e = true\n        end\n        local index = find_key(l,\
    \ 0 - num)\n        if index ~= nil and index ~= i then\n            return true\n\
    \        end\n    end\n    return e\nend", "    local integers = Set(l)\n    for\
    \ i = 1, #l do\n        local sum = -l[i]\n        if integers[sum] then\n   \
    \         return true\n        end\n    end\n    return false\nend", "    local\
    \ l_pairs = n_sum_lists(2, l)\n    for _, v in ipairs(l_pairs) do\n        if\
    \ not l_contains_duplicates(v) and l_sum(v) == 0 then\n            return true\n\
    \        end\n    end\n    return false\nend", "\tlocal d = {}\n\tfor _,k in ipairs(l)\
    \ do\n\t\td[k] = true\n\tend\n\tfor _,k in ipairs(l) do\n\t\tif d[-k] then\n\t\
    \t\treturn true\n\t\tend\n\tend\n\treturn false\nend", "  -- your code here\n\
    \  local exist_hash = {}\n  for _, value in ipairs(l) do\n    if exist_hash[-value]\
    \ then\n      return true\n    end\n    exist_hash[value] = true\n  end\n  return\
    \ false\nend", "\tlocal t = {}\n\tfor i, v in ipairs(l) do\n\t\tif t[-v] then\n\
    \t\t\treturn true\n\t\tend\n\t\tt[v] = true\n\tend\n\treturn false\nend", "  \
    \  for _, x in ipairs(l) do\n        for _, y in ipairs(l) do\n            if\
    \ x ~= y and x + y == 0 then\n                return true\n            end\n \
    \       end\n    end\n    return false\nend", "  for i, x in ipairs(l) do\n  \
    \  for j, y in ipairs(l) do\n      if x == -y and i ~= j then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "    local hash_tbl =\
    \ {}\n    for _, v in ipairs(l) do\n        if hash_tbl[v] ~= nil then\n     \
    \       return true\n        end\n        hash_tbl[-v] = true\n    end\n    return\
    \ false\nend", "  local i = 1\n  while i <= #l do\n    local j = i + 1\n    while\
    \ j <= #l do\n      if l[i] + l[j] == 0 then\n        return true\n      end\n\
    \      j = j + 1\n    end\n    i = i + 1\n  end\n  return false\nend", "  if #l\
    \ < 2 then\n    return false\n  end\n  local first_element = l[1]\n  table.remove(l,\
    \ 1)\n  local found = pairs_sum_to_zero(l)\n  table.insert(l, 1, first_element)\n\
    \  if found then\n    return true\n  end\n  for i, v in ipairs(l) do\n    if first_element\
    \ + v == 0 then\n      return true\n    end\n  end\n  return false\nend", "  local\
    \ zs = {}\n  for i = 1, #l do\n    local num = l[i]\n    if zs[num] then\n   \
    \   return true\n    end\n    zs[-num] = true\n  end\n  return false\nend", " \
    \   for _, n in ipairs(l) do\n        if hash[-n] then\n            return true\n\
    \        end\n    end\n    return false\nend", "  local i = 1\n  while i <= #l\
    \ - 1 do\n    local j = i + 1\n    while j <= #l do\n      if l[i] + l[j] == 0\
    \ then\n        return true\n      end\n      j = j + 1\n    end\n    i = i +\
    \ 1\n  end\n  return false\nend", "  for i = 1, #l do\n    for j = i + 1, #l do\n\
    \      if l[i] + l[j] == 0 then\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  -- process the list in pairs, check each pair for a\
    \ sum of zero.\n  for i = 1, #l - 1 do\n    for j = i + 1, #l do\n      if l[i]\
    \ + l[j] == 0 then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  for i = 1, #l do\n    for j = i + 1, #l do\n      if l[i] + l[j] == 0\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "    local t = {}\n    for _,v in ipairs(l) do\n        if t[-v] then\n        \
    \    return true\n        end\n        t[v] = true\n    end\n    return false\n\
    end", "    -- find a list of all possible pairs from the input list.\n    local\
    \ pairs = {}\n    for i = 1, #l do\n        for j = i + 1, #l do\n           \
    \ table.insert(pairs, {l[i], l[j]})\n        end\n    end", '  local s = {}',
  "    local map = {}\n    for _, v in ipairs(l) do\n        if map[v] ~= nil then\n\
    \            return true\n        end\n        map[-v] = true\n    end\n    return\
    \ false\nend", "  local function summable(val, list)\n    for _, other in ipairs(list)\
    \ do\n      if val + other == 0 then\n        return true\n      end\n    end\n\
    \    return false\n  end", "    local found_zero = false\n    local set = {}\n\
    \    for _, i in ipairs(l) do\n        if set[i] then\n            set[i] = nil\n\
    \            found_zero = true\n        else\n            set[-i] = true\n   \
    \     end\n    end\n    return found_zero\nend", "  for _, i in ipairs(l) do\n\
    \    for _, j in ipairs(l) do\n      if i + j == 0 and i ~= j then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "  local hashtbl = {}\n\
    \  for k,v in pairs(l) do\n    if hashtbl[v] then\n      return true\n    else\n\
    \      hashtbl[v] = true\n    end\n  end\n  for k,v in pairs(l) do\n    if hashtbl[-v]\
    \ then\n      return true\n    end\n  end\n  return false\nend", "\tlocal seen\
    \ = {}\n\tfor i, x in ipairs(l) do\n\t\tlocal y = 0 - x\n\t\tif seen[y] then\n\
    \t\t\treturn true\n\t\tend\n\t\tseen[x] = true\n\tend\n\treturn false\nend", " \
    \ local hash = {}\n  for _,i in ipairs(l) do\n    if hash[i] then\n      return\
    \ true\n    end\n    hash[i] = true\n  end\n  return false\nend", "    -- if the\
    \ list has no element, it has no pair that sums to zero\n    if #l == 0 then\n\
    \        return false\n    end", "    local pairs = {}\n    for _, a in ipairs(l)\
    \ do\n        for _, b in ipairs(l) do\n            if a ~= b and a + b == 0 then\n\
    \                if pairs[a] == nil then\n                    pairs[a] = {}\n\
    \                end\n                pairs[a][b] = true\n            end\n  \
    \      end\n    end\n    return next(pairs) ~= nil\nend", "    -- TODO: implement\
    \ this function.\n    -- See the dummy implementation below.\n    return true\n\
    end", "\tlocal table = {}\n\tlocal result = false\n\tfor key, value in pairs(l)\
    \ do\n\t\tif table[value] then\n\t\t\tresult = true\n\t\t\tbreak\n\t\telse\n\t\
    \t\ttable[-value] = true\n\t\tend\n\tend\n\treturn result\nend", "\tlocal zero\
    \ = {}\n\tfor _, v in ipairs(l) do\n\t\tif zero[v] then\n\t\t\treturn true\n\t\
    \tend\n\t\tzero[-v] = true\n\tend\n\treturn false\nend", "\tlocal function table_contains(t,\
    \ value)\n\t\tfor _, v in ipairs(t) do\n\t\t\tif v == value then\n\t\t\t\treturn\
    \ true\n\t\t\tend\n\t\tend\n\t\treturn false\n\tend", "  for _, item in ipairs(l)\
    \ do\n    for _, item2 in ipairs(l) do\n      if item + item2 == 0 and item ~=\
    \ item2 then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  local found = false\n  for i, v in ipairs(l) do\n    if found == true\
    \ then\n      break\n    end\n    for j, w in ipairs(l) do\n      if i ~= j and\
    \ v + w == 0 then\n        found = true\n        break\n      end\n    end\n \
    \ end\n  return found\nend", "    for _,v in ipairs(l) do\n        if binary_search(-v,\
    \ l) then\n            return true\n        end\n    end\n    return false\nend",
  "  if (not is_list(l)) then\n    error(\"The input must be a list!\")\n  end\n \
    \ -- TODO: replace {} with an explicit definition of which functions to call\n\
    \  -- in what order (including arguments to each function).\n  return {}\nend",
  "    local sum_to_zero = false\n    local seen = {}\n    for _, i in ipairs(l) do\n\
    \        if seen[i] then\n            sum_to_zero = true\n            break\n\
    \        end\n        seen[-i] = true\n    end\n    return sum_to_zero\nend",
  "    local cache = {}\n    for i,v in ipairs(l) do\n        if cache[v] then\n \
    \           return true\n        else\n            cache[-v] = true\n        end\n\
    \    end\n    return false\nend", "  for _, a in ipairs(l) do\n    for _, b in\
    \ ipairs(l) do\n      if a + b == 0 and a ~= b then\n        return true\n   \
    \   end\n    end\n  end\n  return false\nend", "\tif #l > 1 then\n\t\tfor i =\
    \ 1, #l do\n\t\t\tfor j = i + 1, #l do\n\t\t\t\tif l[i] + l[j] == 0 then\n\t\t\
    \t\t\treturn true\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend",
  "    local mt = {}\n    for _, v in ipairs(l) do\n        mt[v] = true\n    end\n\
    \    for _, v in ipairs(l) do\n        if mt[-v] then\n            return true\n\
    \        end\n    end\n    return false\nend", "\tlocal memo = {}\n\tfor _, v\
    \ in ipairs(l) do\n\t\tif not memo[v] then\n\t\t\tmemo[v] = 0\n\t\tend\n\t\tmemo[v]\
    \ = memo[v] + 1\n\tend\n\tfor _, v in ipairs(l) do\n\t\tif v ~= 0 and memo[-v]\
    \ then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend", "    for _, a\
    \ in ipairs(l) do\n        for _, b in ipairs(l) do\n            if a ~= b and\
    \ a + b == 0 then\n                return true\n            end\n        end\n\
    \    end\n    return false\nend", "\tfor _, x in ipairs(l) do\n\t\tfor _, y in\
    \ ipairs(l) do\n\t\t\tif x + y == 0 and x ~= y then\n\t\t\t\treturn true\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn false\nend", "    local iter = _.iter(l)\n   \
    \ local a = iter()\n    local b = iter()\n    while a ~= nil and b ~= nil do\n\
    \        if a == -b then\n            return true\n        end\n        a = iter()\n\
    \        b = iter()\n    end\n    return false\nend", "  local seen = {}\n  for\
    \ _,v in ipairs(l) do\n    seen[v] = true\n  end\n  for _,v in ipairs(l) do\n\
    \    if seen[-v] then\n      return true\n    end\n  end\n  return false\nend",
  "  local b = table.create(table.length(l), 0)\n  for _, x in ipairs(l) do\n    if\
    \ b[-x] then\n      return true\n    end\n    b[x] = true\n  end\n  return false\n\
    end", "    -- first we check if the list has at least two elements\n    if #l\
    \ < 2 then\n        return false\n    end", "\t-- Create a new list with the distinct\
    \ elements in the original list\n\tlocal unique = distinct(l)\n\t-- Create a new\
    \ list with the negative version of each element in the\n\t-- unique list\n\t\
    local negatives = map(unique, function(element) return -element end)\n\t-- Return\
    \ true if the intersection of the unique list and its negative\n\t-- list is not\
    \ empty\n\treturn not null(intersect(unique, negatives))\nend", "  for _, y in\
    \ ipairs(l) do\n    for _, x in ipairs(l) do\n      if y + x == 0 and x ~= y then\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "  for\
    \ i, x in ipairs(l) do\n    for j, y in ipairs(l) do\n      if x + y == 0 and\
    \ i ~= j then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "\tlocal match = false\n\tfor i = 1, #l do\n\t\tfor j = i + 1, #l do\n\t\
    \t\tif l[i] + l[j] == 0 then\n\t\t\t\tmatch = true\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn match\nend", "    local map = {}\n    for _, v in ipairs(l) do\n    \
    \    if map[v] ~= nil then\n            return true\n        end\n        map[-v]\
    \ = v\n    end\n    return false\nend", "  local set = new_set(0)\n  for _,x in\
    \ ipairs(l) do\n    if set:contains(-x) then\n      return true\n    end\n   \
    \ set:add(x)\n  end\n  return false\nend", "    for i = 1, #l do\n        for\
    \ j = i + 1, #l do\n            if l[i] + l[j] == 0 then\n                return\
    \ true\n            end\n        end\n    end\n    return false\nend", "  local\
    \ s = {}\n  for i = 1, #l do\n    local x = l[i]\n    if s[-x] ~= nil then\n \
    \     return true\n    end\n    s[x] = true\n  end\n  return false\nend", "  \
    \  -- The number of elements in the list\n    local n = #l\n    -- Let's sort\
    \ the list first. This will make our job easier.\n    table.sort(l)\n    -- Now\
    \ we just need to iterate through the list, and for each element\n    -- search\
    \ for -x in the rest of the list. This can be done with a binary\n    -- search.\
    \ We take advantage of the fact that the list is sorted.\n    for i = 1, n - 1\
    \ do\n        -- Search for -x in the sublist starting at l[i + 1]\n        local\
    \ x = l[i]\n        local found = binary_search(l, i + 1, n, -x)\n        if found\
    \ then\n            return true\n        end\n    end\n    return false\nend",
  "  if (#l < 2) then\n    return false\n  end\n  local a, b = next(l), next(l, 2)\n\
    \  if (a == nil or b == nil) then\n    return false\n  end\n  for i = 1, #l -\
    \ 1 do\n    for j = i + 1, #l do\n      if (l[i] + l[j] == 0) then\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "  local t = {}\n  for\
    \ i, v in ipairs(l) do\n    if t[-v] then\n      return true\n    end\n    t[v]\
    \ = true\n  end\n  return false\nend", "    -- hint: this is a good place to use\
    \ the lookup table you\n    -- created in the previous problem.\n    --\n    --\
    \ NOTE: the local function 'tablecontains' is pre-defined here.\n    -- If you\
    \ need to use it, uncomment its definition at the top of\n    -- this file.\n\
    \    return false\nend", "\tl = copy(l)\n\tlocal i, j\n\tfor i = 1, #l do\n\t\t\
    for j = i + 1, #l do\n\t\t\tif l[i] + l[j] == 0 then\n\t\t\t\treturn true\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn false\nend", "    local function pairs_sum_to_zero_helper(l,num_pairs)\n\
    \        if num_pairs == 1 then\n            for _,e in ipairs(l) do\n       \
    \         if e == 0 then\n                    return true\n                end\n\
    \            end\n            return false\n        else\n            if pairs_sum_to_zero_helper(l,num_pairs-1)\
    \ then\n                return true\n            else\n                local new_l\
    \ = {}\n                for _,e in ipairs(l) do\n                    table.insert(new_l,e-num_pairs)\n\
    \                end\n                return pairs_sum_to_zero_helper(new_l,num_pairs-1)\n\
    \            end\n        end\n    end\n    local function pairs_sum_to_zero_helper_2(l,num_pairs)\n\
    \        if num_pairs == 1 then\n            for _,e in ipairs(l) do\n       \
    \         if e == 0 then\n                    return true\n                end\n\
    \            end\n            return false\n        else\n            if pairs_sum_to_zero_helper_2(l,num_pairs-1)\
    \ then\n                return true\n            else\n                local new_l\
    \ = {}\n                for _,e in ipairs(l) do\n                    table.insert(new_l,e+num_pairs)\n\
    \                end\n                return pairs_sum_to_zero_helper_2(new_l,num_pairs-1)\n\
    \            end\n        end\n    end\n    return pairs_sum_to_zero_helper(l,#l)\
    \ or pairs_sum_to_zero_helper_2(l,#l)\nend", "\tlocal m = {}", "\tlocal set =\
    \ {}\n\tfor _, elem in ipairs(l) do\n\t\tif set[-elem] then\n\t\t\treturn true\n\
    \t\tend\n\t\tset[elem] = true\n\tend\n\treturn false\nend", "  local map = {}\n\
    \  for _, v in ipairs(l) do\n    map[v] = true\n  end\n  for _, v in ipairs(l)\
    \ do\n    if map[-v] then\n      return true\n    end\n  end\n  return false\n\
    end", "\tlocal seen = {}\n\tfor i = 1, #l do\n\t\tif seen[l[i]] then\n\t\t\treturn\
    \ true\n\t\tend\n\t\tseen[-l[i]] = true\n\tend\n\treturn false\nend", "    local\
    \ seen = {}\n    for _, x in ipairs(l) do\n        if x == 0 or seen[-x] then\n\
    \            return true\n        end\n        seen[x] = true\n    end\n    return\
    \ false\nend", "\tlocal i = 1;\n\twhile i <= #l do\n\t\tlocal x = l[i];\n\t\t\
    local j = i + 1;\n\t\twhile j <= #l do\n\t\t\tlocal y = l[j];\n\t\t\tif x + y\
    \ == 0 then\n\t\t\t\treturn true;\n\t\t\tend\n\t\t\tj = j + 1;\n\t\tend\n\t\t\
    i = i + 1;\n\tend\n\treturn false;\nend", "\tfor i = 1, #l - 1 do\n\t\tfor j =\
    \ i + 1, #l do\n\t\t\tif l[i] + l[j] == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn false\nend", "  local lookup = {}\n  for _, v in ipairs(l)\
    \ do\n    if lookup[-v] then\n      return true\n    end\n    lookup[v] = true\n\
    \  end\n  return false\nend", "    local dict = {}\n    for _, v in ipairs(l)\
    \ do\n        if dict[-v] then\n            return true\n        end\n       \
    \ dict[v] = true\n    end\n    return false\nend", "    local myset = {}\n   \
    \ for _, v in ipairs(l) do\n        myset[v] = (myset[v] or 0) + 1\n    end\n\
    \    for _, v in ipairs(l) do\n        if myset[-v] then\n            if v ~=\
    \ 0 or myset[v] > 1 then\n                return true\n            end\n     \
    \   end\n    end\n    return false\nend", "    local seen = {}\n    for _, v in\
    \ ipairs(l) do\n        if v == 0 then\n            return true\n        end\n\
    \        if seen[-v] then\n            return true\n        end\n        seen[v]\
    \ = true\n    end\n    return false\nend", "    local m = {}\n    for _, v in\
    \ ipairs(l) do\n        m[v] = true\n    end\n    for _, v in ipairs(l) do\n \
    \       if m[-v] then\n            return true\n        end\n    end\n    return\
    \ false\nend", "  for i, v in ipairs(l) do\n    for j, w in ipairs(l) do\n   \
    \   if (i ~= j) and (v + w == 0) then\n        return true\n      end\n    end\n\
    \  end\n  return false\nend", "    local dict = {}\n    for _, x in ipairs(l)\
    \ do\n        dict[x] = (dict[x] or 0) + 1\n    end\n    for _, x in ipairs(l)\
    \ do\n        if dict[-x] and dict[-x] > 0 then\n            if x ~= 0 or dict[-x]\
    \ > 1 then\n                return true\n            end\n        end\n    end\n\
    \    return false\nend", "\t-- We implement this function using the merge-sort\
    \ algorithm.\n\t-- We first sort the list, then we iterate over it, keeping a\
    \ pointer\n\t-- to the next element to be tested.\n\t-- When two elements sum\
    \ to zero, we return true.\n\t-- If we reach the end of the list and no elements\
    \ sum to zero,\n\t-- we return false.\n\tlocal function merge(left, right)\n\t\
    \tlocal sorted = {}\n\t\tlocal i, j = 1, 1\n\t\twhile i <= #left and j <= #right\
    \ do\n\t\t\tif left[i] < right[j] then\n\t\t\t\tsorted[#sorted + 1] = left[i]\n\
    \t\t\t\ti = i + 1\n\t\t\telse\n\t\t\t\tsorted[#sorted + 1] = right[j]\n\t\t\t\t\
    j = j + 1\n\t\t\tend\n\t\tend\n\t\twhile i <= #left do\n\t\t\tsorted[#sorted +\
    \ 1] = left[i]\n\t\t\ti = i + 1\n\t\tend\n\t\twhile j <= #right do\n\t\t\tsorted[#sorted\
    \ + 1] = right[j]\n\t\t\tj = j + 1\n\t\tend\n\t\treturn sorted\n\tend\n\tlocal\
    \ function merge_sort(l)\n\t\tif #l <= 1 then\n\t\t\treturn l\n\t\tend\n\t\tlocal\
    \ mid = math.floor(#l / 2)\n\t\tlocal left = merge_sort(l[1][mid])\n\t\tlocal\
    \ right = merge_sort(l[mid + 1][#l])\n\t\treturn merge(left, right)\n\tend\n\t\
    l = merge_sort(l)\n\tlocal i = 1\n\twhile i < #l do\n\t\tif l[i] + l[i + 1] ==\
    \ 0 then\n\t\t\treturn true\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn false\nend",
  "    local function test_pair(a, b)\n        return a + b == 0\n    end\n    return\
    \ any_pair(test_pair, l)\nend", "  local t = {}\n  for i = 1, #l do\n    if t[-l[i]]\
    \ then\n      return true\n    end\n    t[l[i]] = true\n  end\n  return false\n\
    end", "  for i = 1, #l do\n    for j = i + 1, #l do\n      if l[i] + l[j] == 0\
    \ then\n        return true\n      end\n    end\n  end\n  return false\nend",
  "  local seen = {}\n  for _, el in ipairs(l) do\n    if seen[el] then\n      return\
    \ true\n    end\n    seen[-el] = true\n  end\n  return false\nend", "  -- store\
    \ the length of the list\n  local len = #l\n  -- sort the list\n  table.sort(l)\n\
    \  -- search for a pair whose sum is zero.\n  for i=1, len-1 do\n    for j=i+1,\
    \ len do\n      if l[i] + l[j] == 0 then\n        return true\n      end\n   \
    \ end\n  end\n  return false\nend", "  local t = {}\n  for i,n in ipairs(l) do\n\
    \    local tn = t[n]\n    if tn ~= nil then\n      return tn < i, i, tn\n    end\n\
    \    t[-n] = i\n  end\n  return false\nend", "  local set = Set.new(l)\n  for\
    \ i,x in ipairs(l) do\n    if set[-x] then\n      return true\n    end\n  end\n\
    \  return false\nend", "\tlocal set = Set(l)\n\tfor _,v in ipairs(l) do\n\t\t\
    if set[-v] then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend", "  \
    \  local mem = {}\n    for _, v in ipairs(l) do\n        mem[v] = true\n    end\n\
    \    for _, v in ipairs(l) do\n        if mem[-v] then\n            return true\n\
    \        end\n    end\n    return false\nend", "    local i = 1\n    local j =\
    \ 2\n    while i < #l do\n        while j <= #l do\n            if l[i] + l[j]\
    \ == 0 then\n                return true\n            end\n            j = j +\
    \ 1\n        end\n        i = i + 1\n        j = i + 1\n    end\n    return false\n\
    end", "\tlocal i = 1\n\tlocal j = 1\n\tlocal m = 1\n\tlocal n = 1\n\t\n\twhile\
    \ i <= #l do\n\t\tj = i + 1\n\t\twhile j <= #l do\n\t\t\tif l[i] + l[j] == 0 then\n\
    \t\t\t\tm = i\n\t\t\t\tn = j\n\t\t\t\treturn true, m, n\n\t\t\tend\n\t\t\tj =\
    \ j + 1\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn false\nend", "  -- sort the list\n\
    \  local l_sorted = table.sort(l)\n  -- for each element in the list, try to find\
    \ its negative\n  for i = 1, #l_sorted do\n    if binary_search(l_sorted, -l_sorted[i])\
    \ then\n      return true\n    end\n  end\n  return false\nend", "    local pairs\
    \ = {}\n    local found_pair = false\n    for i = 1, #l do\n        if pairs[-l[i]]\
    \ ~= nil then\n            found_pair = true\n            break\n        end\n\
    \        pairs[l[i]] = true\n    end\n    return found_pair\nend", "  local z_set\
    \ = {}\n  for key, value in pairs(l) do\n    if z_set[value] then\n      return\
    \ true\n    end\n    z_set[-value] = true\n  end\n  return false\nend", "  --\
    \ fill in here\n  return false\nend", "  for _, v in ipairs(l) do\n    for _,\
    \ w in ipairs(l) do\n      if v ~= w and v + w == 0 then\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "  local val = {}\n  for _,v\
    \ in ipairs(l) do\n    if val[-v] then\n      return true\n    end\n    val[v]\
    \ = true\n  end\n  return false\nend", "\tlocal numbers = {}\n\tlocal found =\
    \ false\n\tfor i = 1, #l do\n\t\tif numbers[l[i]] then\n\t\t\tfound = true\n\t\
    \t\tbreak\n\t\telse\n\t\t\tnumbers[-l[i]] = true\n\t\tend\n\tend\n\treturn found\n\
    end", "  -- check to see if l is a table. If not, return false\n  if type(l) ~=\
    \ \"table\" then\n    return false\n  end", "    local seen = {}\n    for _, x\
    \ in ipairs(l) do\n        local y = -x\n        if seen[y] then\n           \
    \ return true\n        end\n        seen[x] = true\n    end\n    return false\n\
    end", "    local dict = {}\n    for _, v in ipairs(l) do\n        if dict[-v]\
    \ then\n            return true\n        end\n        dict[v] = true\n    end\n\
    \    return false\nend", "  local store = {}\n  for i = 1, #l do\n    if store[l[i]]\
    \ then\n      return true\n    else\n      store[-l[i]] = true\n    end\n  end\n\
    \  return false\nend", "  for _, v in ipairs(l) do\n    for _, w in ipairs(l)\
    \ do\n      if v + w == 0 and v ~= w then\n        return true\n      end\n  \
    \  end\n  end\n  return false\nend", "    local seen = {}\n    for _, x in ipairs(l)\
    \ do\n        if seen[-x] then\n            return true\n        end\n       \
    \ seen[x] = true\n    end\n    return false\nend", "    local dict = {}\n    for\
    \ _, v in ipairs(l) do\n        if dict[v] then\n            return true\n   \
    \     end\n        dict[-v] = true\n    end\n    return false\nend", "    local\
    \ m = {}\n    for i, v in ipairs(l) do\n        if m[-v] then\n            return\
    \ true\n        end\n        m[v] = true\n    end\n    return false\nend", " \
    \   for i = 1, #l do\n        for j = i + 1, #l do\n            if l[i] + l[j]\
    \ == 0 then\n                return true\n            end\n        end\n    end\n\
    \    return false\nend", '  local zeros = {}', "    local m = {}\n    for _, v\
    \ in ipairs(l) do\n        m[v] = (m[v] or 0) + 1\n    end\n    for _, v in ipairs(l)\
    \ do\n        if m[-v] then\n            if m[-v] > 1 or v ~= -v then\n      \
    \          return true\n            end\n        end\n    end\n    return false\n\
    end", "  local s = Set.new()\n  for _, v in ipairs(l) do\n    if s:is_member(-v)\
    \ then\n      return true\n    end\n    s:insert(v)\n  end\n  return false\nend",
  "\tlocal lengths = {}\n\tlocal pairs = {}\n\tlocal sum = 0\n\t\n\tfor i = 1, #l\
    \ do\n\t\tlocal v = l[i]\n\t\tif lengths[v] then\n\t\t\tlengths[v] = lengths[v]\
    \ + 1\n\t\telse\n\t\t\tlengths[v] = 1\n\t\tend\n\t\tpairs[#pairs + 1] = v\n\t\t\
    sum = sum + v\n\tend\n\t\n\tif sum == 0 then\n\t\treturn true\n\tend\n\t\n\t--\
    \ the sum is odd and can't be split into two evenly\n\tif sum % 2 == 1 then\n\t\
    \treturn false\n\tend\n\t\n\tfor i = 1, #pairs do\n\t\tlocal v = pairs[i]\n\t\t\
    if v == 0 then\n\t\t\t-- if a 0 exists, it can be paired with itself\n\t\t\tif\
    \ lengths[v] > 1 then\n\t\t\t\treturn true\n\t\t\tend\n\t\telse\n\t\t\tlocal opposite\
    \ = -v\n\t\t\tif lengths[opposite] then\n\t\t\t\treturn true\n\t\t\tend\n\t\t\
    end\n\tend\n\t\n\treturn false\nend", "  local i = 1\n  local j = #l\n  local\
    \ l_i = l[i]\n  local l_j = l[j]\n  local k = l_i + l_j\n  while not (i == j)\
    \ do\n    if k == 0 then\n      return true\n    elseif k > 0 then\n      j =\
    \ j - 1\n      l_j = l[j]\n      k = l_i + l_j\n    elseif k < 0 then\n      i\
    \ = i + 1\n      l_i = l[i]\n      k = l_i + l_j\n    end\n  end\n  return false\n\
    end", "    for k, v in pairs(l) do\n        if l[-v] then\n            return\
    \ true\n        end\n    end\n    return false\nend", "    local len = #l\n  \
    \  local i = 1\n    local j = len\n    local sum\n    while (i < j) do\n     \
    \   sum = l[i] + l[j]\n        if (sum == 0) then\n            return true\n \
    \       elseif (sum < 0) then\n            i = i + 1\n        else\n         \
    \   j = j - 1\n        end\n    end\n    return false\nend", "    -- add your\
    \ code here\n    return false\nend", "\t-- Detect duplicates\n\tlocal duplicates\
    \ = {}\n\tfor _,x in ipairs(l) do\n\t\tif duplicates[x] then\n\t\t\treturn true\n\
    \t\tend\n\t\tduplicates[x] = true\n\tend", "\tlocal n = #l\n\tif n < 2 then\n\t\
    \treturn false\n\tend\n\tfor i = 1, n do\n\t\tfor j = i + 1, n do\n\t\t\tif l[i]\
    \ + l[j] == 0 then\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\n\
    end", "  local t = {}\n  for _, n in ipairs(l) do\n    t[n] = true\n  end\n  for\
    \ _, n in ipairs(l) do\n    if t[-n] then\n      return true\n    end\n  end\n\
    \  return false\nend", "    local dict = {};\n    for _, v in ipairs(l) do\n \
    \       if dict[-v] then\n            return true;\n        end\n        dict[v]\
    \ = true;\n    end\n    return false;\nend", "    local t = {}\n    for i, n in\
    \ ipairs(l) do\n        if t[n] then\n            return true\n        else\n\
    \            t[-n] = true\n        end\n    end\n    return false\nend", "   \
    \ local i = 1\n    while i <= #l do\n        local j = i + 1\n        while j\
    \ <= #l do\n            if l[i] + l[j] == 0 then\n                return true\n\
    \            end\n            j = j + 1\n        end\n        i = i + 1\n    end\n\
    \    return false\nend", "    -- add your code here\n    -- should be a one-liner,\
    \ =)\n    return false\nend", "  local bucket = {}\n  for i,x in ipairs(l) do\n\
    \    local n = -x\n    if bucket[n] ~= nil then\n      return true\n    end\n\
    \    bucket[x] = true\n  end\n  return false\nend", "    -- For each pair of elements\
    \ x and y in l, check whether\n    -- they sum to zero.\n    for x_idx = 1, #l\
    \ do\n        for y_idx = x_idx + 1, #l do\n            local x = l[x_idx]\n \
    \           local y = l[y_idx]\n            -- If the elements sum to zero, return\
    \ True.\n            if x + y == 0 then\n                return true\n       \
    \     end\n        end\n    end\n    -- If no elements sum to zero, return False.\n\
    \    return false\nend", "  local values = {}\n  for i, v in ipairs(l) do\n  \
    \  if values[-v] then\n      return true\n    end\n    values[v] = true\n  end\n\
    \  return false\nend", "\tlocal freq = {}\n\tfor i = 1, #l do\n\t\tif l[i] ~=\
    \ 0 then\n\t\t\tfreq[l[i]] = freq[l[i]] and freq[l[i]] + 1 or 1\n\t\tend\n\tend\n\
    \tlocal seen = {}\n\tfor i = 1, #l do\n\t\tif freq[l[i]] and freq[-l[i]] then\n\
    \t\t\tif l[i] ~= -l[i] or freq[l[i]] > 1 then\n\t\t\t\treturn true\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn false\nend", "  -- create a hash table to store values\
    \ encountered in the list\n  local hash = {}\n  for k, v in ipairs(l) do\n   \
    \ if hash[v] then\n      return true\n    end\n    hash[-v] = true\n  end\n  return\
    \ false\nend", "  local found = false\n  local ints = {}\n  for _, i in ipairs(l)\
    \ do\n    if ints[i] then\n      return true\n    end\n    ints[-i] = true\n \
    \ end\n  return false\nend", "\tlocal hash = {}\n\tfor i = 1, #l do\n\t\tif hash[l[i]]\
    \ then\n\t\t\treturn true\n\t\tend\n\t\thash[-l[i]] = true\n\tend\n\treturn false\n\
    end", '    local len = #l', "  if not l then return false end\n  -- take 2 elements\
    \ from l, call them a and b\n  -- if a + b = 0 then return true\n  -- else return\
    \ false\n  --local b = table.remove(l, 1)\n  --for _, a in ipairs(l) do\n  --\
    \  if a + b == 0 then return true end\n  --end\n  --return false\n  for _, b in\
    \ ipairs(l) do\n    for _, a in ipairs(l) do\n      if a + b == 0 then return\
    \ true end\n    end\n  end\n  return false\nend", "    for i, x in ipairs(l) do\n\
    \        for j, y in ipairs(l) do\n            if (i ~= j) and (x + y == 0) then\n\
    \                return true\n            end\n        end\n    end\n    return\
    \ false\nend", "\tlocal sets = make_sets(l)\n\tfor _, n in ipairs(l) do\n\t\t\
    if sets[-n] ~= nil then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend",
  "  local seen = {}\n  for _, x in ipairs(l) do\n    if seen[-x] then\n      return\
    \ true\n    end\n    seen[x] = true\n  end\n  return false\nend", "    -- A lookup\
    \ table to store whether or not a value has been seen\n    -- already.\n    local\
    \ zero_found = {}\n    for _, v in ipairs(l) do\n        -- if we've seen the\
    \ opposite of the current value,\n        -- then we have found a pair summing\
    \ to zero.\n        if zero_found[-v] then\n            return true\n        end\n\
    \        -- otherwise, set the value to true (it has been seen).\n        zero_found[v]\
    \ = true\n    end\n    -- if we haven't found a pair summing to zero yet, we never\
    \ will.\n    return false\nend", "  for i = 1, #l do\n    for j = i + 1, #l do\n\
    \      if l[i] + l[j] == 0 then\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "    return pairs_sum_to_n(l, 0)\nend", "  local n = #l\n\
    \  for i=1,n-1 do\n    for j=i+1,n do\n      if l[i] + l[j] == 0 then\n      \
    \  return true\n      end\n    end\n  end\n  return false\nend", "  local mem\
    \ = {}\n  for _, n in ipairs(l) do\n    if mem[-n] then\n      return true\n \
    \   end\n    mem[n] = true\n  end\n  return false\nend", "  for _,v in ipairs(l)\
    \ do\n    if v == 0 then\n      return true\n    end\n  end\n  -- we keep a table\
    \ of all known elements, and we iterate through the\n  -- list with two indices,\
    \ to detect pairs of elements that sum to\n  -- zero.\n  local known = {}\n  for\
    \ i,_ in ipairs(l) do\n    for j=i+1,#l do\n      local v = l[i] + l[j]\n    \
    \  if known[v] == true then\n        return true\n      end\n      known[-v] =\
    \ true\n    end\n  end\n  return false\nend", "    -- we're trying to find a pair\
    \ of numbers that add to zero. we can do this\n    -- by sorting the list and\
    \ then moving two pointers inwards from the ends\n    -- of the list.\n    table.sort(l)\n\
    \    local i = 1\n    local j = #l\n    while i < j do\n        if l[i] + l[j]\
    \ == 0 then\n            return true\n        elseif l[i] + l[j] < 0 then\n  \
    \          i = i + 1\n        else\n            j = j - 1\n        end\n    end\n\
    \    return false\nend", "    local function helper(i, l, table)\n        -- BASECASE:\
    \ no more elements left\n        if i == #l then\n            return false\n \
    \       end\n        local x = l[i]\n        if table[-x] then\n            return\
    \ true\n        end\n        table[x] = true\n        return helper(i+1, l, table)\n\
    \    end\n    return helper(1, l, {})\nend", "\t-- Write your code here\n    for\
    \ i=1,#l do\n        for j=i+1,#l do\n            if l[i]+l[j]==0 then\n     \
    \           return true\n            end\n        end\n    end\n    return false\n\
    end", "  local zero = {}\n  for _, a in ipairs(l) do\n    if zero[-a] then\n \
    \     return true\n    end\n    zero[a] = true\n  end\n  return false\nend", " \
    \   local set = HashSet.new(set_hash, set_equals)\n    for _, val in ipairs(l)\
    \ do\n        if set.contains(set, -val) then\n            return true\n     \
    \   end\n        set.add(set, val)\n    end\n    return false\nend", "    local\
    \ function helper(l, s)\n        if l == nil then\n            return s == {}\n\
    \        else\n            local x = table.remove(l, 1)\n            local s_copy\
    \ = copy(s)\n            s_copy[x] = true\n            if s_copy[-x] then\n  \
    \              return true\n            else\n                return helper(l,\
    \ s_copy)\n            end\n        end\n    end\n    return helper(l, {})\nend",
  "  local elems = {}\n  for _,v in ipairs(l) do\n    elems[v] = (elems[v] or 0) +\
    \ 1\n  end\n  for _,v in ipairs(l) do\n    if v ~= 0 and elems[-v] then\n    \
    \  return true\n    end\n  end\n  return false\nend", "  local d = {}\n  for _,\
    \ v in ipairs(l) do\n    if d[-v] then\n      return true\n    end\n    d[v] =\
    \ true\n  end\n  return false\nend", "\tlocal sum_to_zero = false\n\tfor i, v\
    \ in ipairs(l) do\n\t\tif (pairs_sum_to_zero_rec(l, i, v)) then\n\t\t\tsum_to_zero\
    \ = true\n\t\t\tbreak\n\t\tend\n\tend\n\treturn sum_to_zero\nend", '  local last
    = #l', "  local s = sum(l)\n  return s == 0\nend", "  local isZero = {}\n  for\
    \ _, v in ipairs(l) do\n    if isZero[-v] then\n      return true\n    end\n \
    \   isZero[v] = true\n  end\n  return false\nend", "  local map = {}\n  for _,\
    \ v in ipairs(l) do\n    map[v] = (map[v] or 0) + 1\n  end\n  for _, v in ipairs(l)\
    \ do\n    if map[-v] then\n      return true\n    end\n  end\n  return false\n\
    end", "    local zero = {}\n    for _,i in ipairs(l) do\n        if zero[i] then\n\
    \            return true\n        end\n        zero[-i] = true\n    end\n    return\
    \ false\nend", "  local i = 1\n  while i <= #l do\n    local j = i + 1\n    while\
    \ j <= #l do\n      if l[i] + l[j] == 0 then\n        return true\n      end\n\
    \      j = j + 1\n    end\n    i = i + 1\n  end\n  return false\nend", "  local\
    \ ht = {}\n  for i = 1, #l do\n    local x = l[i]\n    if ht[x] then\n      return\
    \ true\n    end\n    ht[-x] = true\n  end\n  return false\nend", "    local i\
    \ = 1\n    local j = 1\n    for i = 1, #l do\n        for j = 1, #l do\n     \
    \       if l[i] + l[j] == 0 and i ~= j then\n                return true\n   \
    \         end\n        end\n    end\n    return false\nend", "    local i,j\n\
    \    for i=1,#l do\n        for j=i+1,#l do\n            if l[i] + l[j] == 0 then\n\
    \                return true\n            end\n        end\n    end\n    return\
    \ false\nend", "  for i = 1, #l do\n    for j = i + 1, #l do\n      if l[i] +\
    \ l[j] == 0 then\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  local pairs = {}\n  for i, v in ipairs(l) do\n    if pairs[v] ~= nil\
    \ then\n      return true\n    end\n    pairs[-v] = true\n  end\n  return false\n\
    end", "  if l.n == 1 then\n    return false\n  end\n  if l.n == 2 then\n    return\
    \ l[1] + l[2] == 0\n  end\n  local i, j\n  for i = 1, l.n do\n    for j = i +\
    \ 1, l.n do\n      if l[i] + l[j] == 0 then\n        return true\n      end\n\
    \    end\n  end\n  return false\nend", "  local hash = {}\n  for _, v in ipairs(l)\
    \ do\n    if hash[v] then\n      return true\n    end\n    hash[-v] = true\n \
    \ end\n  return false\nend", "    local l_length = #l\n    if l_length < 2 then\n\
    \        return false\n    end\n    local zero_present = false\n    for i=1,l_length\
    \ do\n        if l[i] == 0 then\n            zero_present = true\n        end\n\
    \    end\n    if zero_present then\n        return true\n    end\n    for i=1,l_length\
    \ do\n        for j=i+1,l_length do\n            if l[i] + l[j] == 0 then\n  \
    \              return true\n            end\n        end\n    end\n    return\
    \ false\nend", "  local i,j\n  for i = 1, #l do\n    for j = i+1, #l do\n    \
    \  if l[i] + l[j] == 0 then\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "\tlocal t = table.make(l, true)\n\tfor _,n in ipairs(l)\
    \ do\n\t\tif t[-n] then\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend",
  "    local elements = {}\n    for _, i in ipairs(l) do\n        if elements[-i]\
    \ then\n            return true\n        end\n        elements[i] = true\n   \
    \ end\n    return false\nend", "    for i = 1, #l - 1 do\n        for j = i +\
    \ 1, #l do\n            if l[i] + l[j] == 0 then\n                return true\n\
    \            end\n        end\n    end\n    return false\nend", "    local n =\
    \ #l\n    local hash = {}\n    for i = 1, n do\n        local d = l[i]\n     \
    \   if hash[-d] then\n            return true\n        end\n        hash[d] =\
    \ true\n    end\n    return false\nend", "  for i = 1, #l do\n    for j = i +\
    \ 1, #l do\n      if l[i] + l[j] == 0 then\n        return true\n      end\n \
    \   end\n  end\n  return false\nend", "    local l1 = {}\n    for i, v in ipairs(l)\
    \ do\n        local l2 = {}\n        for i, v in ipairs(l) do\n            if\
    \ v ~= -l1[i] then\n                l2[i] = -v\n            end\n        end\n\
    \        l1 = l2\n    end\n    return l1\nend", "  local table = create_hash_table(l)\n\
    \  for _, x in ipairs(l) do\n    if table[x] then\n      return true\n    end\n\
    \  end\n  return false\nend", "    local h = {}\n    for _, x in ipairs(l) do\n\
    \        if h[-x] then\n            return true\n        end\n        h[x] = true\n\
    \    end\n    return false\nend", "    for i = 1, #l - 1 do\n        for j = i\
    \ + 1, #l do\n            if l[i] + l[j] == 0 then\n                return true\n\
    \            end\n        end\n    end\n    return false\nend", "    local z =\
    \ 0\n    local t = {}\n    for i, v in ipairs(l) do\n        t[v] = i\n    end\n\
    \    for i, v in ipairs(l) do\n        if t[-v] ~= nil and t[-v] ~= i then\n \
    \           return true\n        end\n    end\n    return false\nend", "    local\
    \ t = {}\n    for _, el in ipairs(l) do\n        if t[-el] then\n            return\
    \ true\n        end\n        t[el] = true\n    end\n    return false\nend", " \
    \   local hash_set = {}\n    for _, i in ipairs(l) do\n        if hash_set[-i]\
    \ then\n            return true\n        end\n        hash_set[i] = true\n   \
    \ end\n    return false\nend", "\tlocal found = {}\n\tlocal n = #l\n\tfor i =\
    \ 1, n do\n\t\tfor j = i + 1, n do\n\t\t\tlocal k = l[i] + l[j]\n\t\t\tif found[k]\
    \ then\n\t\t\t\treturn true\n\t\t\tend\n\t\t\tfound[k] = true\n\t\tend\n\tend\n\
    \treturn false\nend", "  local d = {}\n  for i, x in ipairs(l) do\n    if d[x]\
    \ ~= nil then\n      return true\n    end\n    d[-x] = true\n  end\n  return false\n\
    end", "  local negatives = {}\n  local positives = {}\n  for _, v in ipairs(l)\
    \ do\n    if v < 0 then\n      negatives[v] = true\n    elseif v > 0 then\n  \
    \    positives[v] = true\n    else\n      return true\n    end\n  end\n  for v\
    \ in pairs(negatives) do\n    if positives[-v] then\n      return true\n    end\n\
    \  end\n  return false\nend", "  local m = {}\n  for i = 1, #l do\n    if m[-l[i]]\
    \ then\n      return true\n    end\n    m[l[i]] = true\n  end\n  return false\n\
    end", "    local n = {}\n    for _, x in ipairs(l) do\n        if x == 0 then\n\
    \            return true\n        end\n        if n[-x] == true then\n       \
    \     return true\n        end\n        n[x] = true\n    end\n    return false\n\
    end", "  -- your code here\n  for k, v in pairs(l) do\n      for i, j in pairs(l)\
    \ do\n          if (k ~= i) and (v + j == 0) then\n              return true\n\
    \          end\n      end\n  end\n  return false\nend", "  local h = {}\n  for\
    \ _, v in ipairs(l) do\n    h[v] = true\n  end\n  for _, v in ipairs(l) do\n \
    \   if h[-v] then\n      return true\n    end\n  end\n  return false\nend", "\t\
    local copy = list.copy(l)\n\tlocal zeros = 0\n\tfor _, v in ipairs(copy) do\n\t\
    \tif v == 0 then\n\t\t\tzeros = zeros + 1\n\t\tend\n\tend\n\tif zeros >= 2 then\n\
    \t\treturn true\n\tend\n\t\n\ttable.sort(copy)\n\t\n\tlocal i = 1\n\tlocal j =\
    \ #copy\n\twhile i < j do\n\t\tlocal total = copy[i] + copy[j]\n\t\tif total ==\
    \ 0 then\n\t\t\treturn true\n\t\telseif total < 0 then\n\t\t\ti = i + 1\n\t\t\
    else\n\t\t\tj = j - 1\n\t\tend\n\tend\n\t\n\treturn false\nend", "  -- first sort\
    \ the table of integers\n  table.sort(l)\n  -- then, iterate through the table,\
    \ checking if the inverse of the integer\n  -- can be found using binary search.\n\
    \  for i = 1, #l do\n    local reverse = -l[i]\n    if binary_search(l, reverse)\
    \ then\n      return true\n    end\n  end\n  return false\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
