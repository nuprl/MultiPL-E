name: HumanEval_127_intersection
language: lua
prompt: "-- You are given two intervals,\n-- where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n-- The given intervals are closed\
  \ which means that the interval (start, end)\n-- includes both start and end.\n\
  -- For each given interval, it is assumed that its start is less or equal its end.\n\
  -- Your task is to determine whether the length of intersection of these two \n\
  -- intervals is a prime number.\n-- Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n-- which its length is 1, which not a prime number.\n--\
  \ If the length of the intersection is a prime number, return \"YES\",\n-- otherwise,\
  \ return \"NO\".\n-- If the two intervals don't intersect, return \"NO\".\n-- [input/output]\
  \ samples:\nlocal function intersection(interval1, interval2)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersection\n\
  \    lu.assertEquals(candidate({1, 2}, {2, 3}), 'NO')\n    lu.assertEquals(candidate({-1,\
  \ 1}, {0, 4}), 'NO')\n    lu.assertEquals(candidate({-3, -1}, {-5, 5}), 'YES')\n\
  \    lu.assertEquals(candidate({-2, 2}, {-4, 0}), 'YES')\n    lu.assertEquals(candidate({-11,\
  \ 2}, {-1, -1}), 'NO')\n    lu.assertEquals(candidate({1, 2}, {3, 5}), 'NO')\n \
  \   lu.assertEquals(candidate({1, 2}, {1, 2}), 'NO')\n    lu.assertEquals(candidate({-2,\
  \ -2}, {-3, -2}), 'NO')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local res = {}\n  for i = interval1[1], interval1[2] do\n    for\
    \ j = interval2[1], interval2[2] do\n      if i == j then\n        table.insert(res,\
    \ i)\n      end\n    end\n  end\n  if #res == 0 then\n    return \"NO\"\n  end\n\
    \  if #res == 1 then\n    return \"YES\"\n  end\n  for i = 2, #res / 2 do\n  \
    \  if #res % i == 0 then\n      return \"NO\"\n    end\n  end\n  return \"YES\"\
    \nend", "  local a1, a2 = interval1[1], interval1[2]\n  local b1, b2 = interval2[1],\
    \ interval2[2]\n  local a3, a4 = math.max(a1, b1), math.min(a2, b2)\n  local b3,\
    \ b4 = math.min(a1, b1), math.max(a2, b2)\n  local l = math.max(a3, b3) - math.min(a4,\
    \ b4)\n  local c = 0\n  for i = 2, l do\n    if l % i == 0 then\n      c = c +\
    \ 1\n    end\n  end\n  if l == -1 then\n    return \"NO\"\n  elseif c == 0 then\n\
    \    return \"YES\"\n  else\n    return \"NO\"\n  end\nend\nprint(intersection({1,\
    \ 2}, {2, 4})) -- \"NO\"\nprint(intersection({1, 2}, {1, 4})) -- \"YES\"\nprint(intersection({2,\
    \ 3}, {1, 4})) -- \"YES\"\nprint(intersection({1, 2}, {3, 4})) -- \"NO\"\nprint(intersection({1,\
    \ 2}, {4, 5})) -- \"NO\"\nprint(intersection({1, 2}, {4, 4})) -- \"NO\"\nprint(intersection({1,\
    \ 2}, {3, 3})) -- \"NO\"\nprint(intersection({1, 2}, {2, 2})) -- \"YES\"\nprint(intersection({1,\
    \ 2}, {2, 3})) -- \"YES\"", "  local start_of_intersection = math.max(interval1[1],\
    \ interval2[1])\n  local end_of_intersection = math.min(interval1[2], interval2[2])\n\
    \  if start_of_intersection > end_of_intersection then return \"NO\" end\n  local\
    \ interval_length = end_of_intersection - start_of_intersection + 1\n  if interval_length\
    \ < 2 then return \"NO\" end\n  for i = 2, math.floor(math.sqrt(interval_length))\
    \ do\n    if interval_length % i == 0 then return \"NO\" end\n  end\n  return\
    \ \"YES\"\nend", "\tlocal start, end = interval1[1], interval1[2]\n\tlocal start2,\
    \ end2 = interval2[1], interval2[2]\n\tif start2 < start then\n\t\tstart, end\
    \ = start2, end2\n\t\tstart2, end2 = start, end\n\tend\n\tif start2 <= end then\n\
    \t\tif start2 <= end and end <= end2 then\n\t\t\treturn start2, end\n\t\telse\n\
    \t\t\treturn start2, end2\n\t\tend\n\tend\n\treturn false\nend", "    local start1,\
    \ end1 = interval1[1], interval1[2]\n    local start2, end2 = interval2[1], interval2[2]\n\
    \    local start, end\n    if start1 <= start2 then\n        start = start2\n\
    \    else\n        start = start1\n    end\n    if end1 <= end2 then\n       \
    \ endd = end1\n    else\n        endd = end2\n    end\n    if start > endd then\n\
    \        return \"NO\"\n    end\n    local count = endd - start + 1\n    if count\
    \ < 2 then\n        return \"NO\"\n    end\n    local res = \"YES\"\n    for i\
    \ = 2, count - 1 do\n        if count % i == 0 then\n            res = \"NO\"\n\
    \            break\n        end\n    end\n    return res\nend", "    if interval1[1]\
    \ > interval2[2] or interval2[1] > interval1[2] then\n        return \"NO\"\n\
    \    end\n    local start = math.max(interval1[1], interval2[1])\n    local finish\
    \ = math.min(interval1[2], interval2[2])\n    local len = finish - start + 1\n\
    \    local isPrime = true\n    for i = 2, len - 1 do\n        if len % i == 0\
    \ then\n            isPrime = false\n            break\n        end\n    end\n\
    \    if isPrime then\n        return \"YES\"\n    else\n        return \"NO\"\n\
    \    end\nend", "  local common = {}\n  local bigger, smaller = interval1, interval2\n\
    \  if interval1[1] > interval2[1] then\n    bigger, smaller = interval2, interval1\n\
    \  end\n  for i = bigger[1], bigger[2] do\n    for j = smaller[1], smaller[2]\
    \ do\n      if i == j then\n        table.insert(common, i)\n      end\n    end\n\
    \  end\n  return common\nend", "  local start1, end1 = interval1[1], interval1[2]\n\
    \  local start2, end2 = interval2[1], interval2[2]\n  local start, end = math.max(start1,\
    \ start2), math.min(end1, end2)\n  if start <= end then\n    local len = end -\
    \ start + 1\n    local sq = math.sqrt(len)\n    for i = 2, sq do\n      if len\
    \ % i == 0 then\n        return \"NO\"\n      end\n    end\n    return \"YES\"\
    \n  end\n  return \"NO\"\nend\nassert(intersection({0, 2}, {1, 4}) == \"YES\"\
    )\nassert(intersection({1, 3}, {2, 4}) == \"NO\")\nassert(intersection({0, 1},\
    \ {0, 1}) == \"YES\")\nassert(intersection({0, 0}, {1, 2}) == \"NO\")\nassert(intersection({1,\
    \ 2}, {0, 0}) == \"NO\")\nassert(intersection({0, 3}, {1, 2}) == \"YES\")\nassert(intersection({0,\
    \ 1}, {2, 3}) == \"NO\")\nassert(intersection({2, 2}, {2, 2}) == \"YES\")\nassert(intersection({0,\
    \ 0}, {0, 0}) == \"YES\")\nassert(intersection({0, 0}, {1, 1}) == \"NO\")\nassert(intersection({1,\
    \ 1}, {0, 0}) == \"NO\")\nassert(intersection({1, 1}, {1, 1}) == \"YES\")\nassert(intersection({0,\
    \ 4}, {1, 3}) == \"YES\")\nassert(intersection({1, 3}, {0, 4}) == \"YES\")\nassert(intersection({2,\
    \ 3}, {0, 4}) == \"YES\")\nassert(intersection({0, 4}, {2, 3}) == \"YES\")\nassert(intersection({0,\
    \ 1}, {0, 2}) == \"NO\")\nassert(intersection({0, 2}, {0, 1}) == \"NO\")\nassert(intersection({0,\
    \ 1}, {0, 2}) == \"NO\")\nassert(intersection({0, 2},", "  local max = math.max(interval1[1],\
    \ interval2[1])\n  local min = math.min(interval1[2], interval2[2])\n  if min\
    \ >= max then\n    return max, min\n  end\n  return nil\nend", "  local sortedIntervals\
    \ = { interval1, interval2 }\n  table.sort(sortedIntervals, function(a, b) return\
    \ a[1] < b[1] end)\n  local i1 = sortedIntervals[1]\n  local i2 = sortedIntervals[2]\n\
    \  local maxStart = math.max(i1[1], i2[1])\n  local minEnd = math.min(i1[2], i2[2])\n\
    \  if maxStart > minEnd then\n    return \"NO\"\n  end\n  local range = minEnd\
    \ - maxStart + 1\n  local result = \"NO\"\n  if range == 1 then\n    result =\
    \ \"YES\"\n  else\n    for i = 2, math.sqrt(range) do\n      if range % i == 0\
    \ then\n        break\n      end\n      if i == math.sqrt(range) then\n      \
    \  result = \"YES\"\n      end\n    end\n  end\n  return result\nend", "  local\
    \ x1,y1,x2,y2,result\n  x1,y1 = interval1[1],interval1[2]\n  x2,y2 = interval2[1],interval2[2]\n\
    \  result = (x1 <= x2 and x2 <= y1 and y1 <= y2) or\n           (x2 <= x1 and\
    \ x1 <= y2 and y2 <= y1)\n  return result and y1 - x2 + 1 or nil\nend", "  local\
    \ result = {}\n  if interval1[1] <= interval2[1] then\n    result[1] = interval2[1]\n\
    \  else\n    result[1] = interval1[1]\n  end\n  if interval1[2] >= interval2[2]\
    \ then\n    result[2] = interval2[2]\n  else\n    result[2] = interval1[2]\n \
    \ end\n  return result\nend", "    local result = \"NO\"\n    local range = {}\n\
    \    local start, stop = 0, 0\n    -- find start/stop\n    if interval1[1] <=\
    \ interval2[1] then\n        start = interval2[1]\n    else\n        start = interval1[1]\n\
    \    end\n    if interval1[2] <= interval2[2] then\n        stop = interval1[2]\n\
    \    else\n        stop = interval2[2]\n    end\n    -- check for intersection\n\
    \    if start <= stop then\n        result = \"YES\"\n        for i = start, stop\
    \ do\n            table.insert(range, i)\n        end\n        -- check if prime\n\
    \        for i = 1, #range do\n            local isPrime = true\n            local\
    \ step = 2\n            if range[i] == 1 then\n                isPrime = false\n\
    \            else\n                while step < range[i] do\n                \
    \    if range[i] % step == 0 then\n                        isPrime = false\n \
    \                       break\n                    end\n                    step\
    \ = step + 1\n                end\n            end\n            if isPrime then\n\
    \                result = \"NO\"\n                break\n            end\n   \
    \     end\n    end\n    return result\nend", "    local a, b = interval1[1], interval1[2]\n\
    \    local c, d = interval2[1], interval2[2]\n    local start, end = 0, 0\n  \
    \  if a < c then\n        start = c\n    else\n        start = a\n    end\n  \
    \  if b < d then\n        end = b\n    else\n        end = d\n    end\n    if\
    \ start > end then\n        return 'NO'\n    end\n    local len = end - start\
    \ + 1\n    if (len == 1) or (len == 4) or (len == 6) or (len == 8) or (len ==\
    \ 9) or (len == 10) then\n        return 'NO'\n    end\n    return 'YES'\nend",
  "    local x1, y1 = unpack(interval1)\n    local x2, y2 = unpack(interval2)\n  \
    \  if x1 > y2 or x2 > y1 then return \"NO\" end\n    local start = math.max(x1,\
    \ x2)\n    local end_ = math.min(y1, y2)\n    local count = end_ - start + 1\n\
    \    return count == 1 and \"NO\" or (is_prime(count) and \"YES\" or \"NO\")\n\
    end", "  local a, b = interval1[1], interval1[2]\n  local c, d = interval2[1],\
    \ interval2[2]\n  local start, end = math.max(a, c), math.min(b, d)\n  local len\
    \ = end - start + 1\n  return len > 0 and isPrime(len) and \"YES\" or \"NO\"\n\
    end", "  local start = math.max(interval1[1], interval2[1])\n  local stop = math.min(interval1[2],\
    \ interval2[2])\n  if stop < start then\n    return \"NO\"\n  end\n  if stop -\
    \ start == 1 then\n    return \"YES\"\n  end\n  for i = 2, math.floor(math.sqrt(stop\
    \ - start)) do\n    if (stop - start) % i == 0 then\n      return \"NO\"\n   \
    \ end\n  end\n  return \"YES\"\nend\nfor _, sample in ipairs({\n  {\n    {-5,\
    \ -2},\n    {-4, 1}\n  },\n  {\n    {-3, 4},\n    {-2, 3}\n  },\n  {\n    {1,\
    \ 4},\n    {3, 5}\n  },\n  {\n    {1, 7},\n    {4, 10}\n  },\n  {\n    {2, 3},\n\
    \    {2, 4}\n  },\n  {\n    {2, 3},\n    {3, 4}\n  },\n  {\n    {1, 4},\n    {3,\
    \ 5}\n  },\n  {\n    {2, 3},\n    {1, 4}\n  },\n  {\n    {1, 7},\n    {5, 8}\n\
    \  },\n  {\n    {3, 6},\n    {4, 5}\n  },\n  {\n    {1, 7},\n    {4, 10}\n  },\n\
    \  {\n    {1, 4},\n    {2, 5}\n  },\n  {\n    {1, 4},\n    {3, 5}\n  },\n  {\n\
    \    {3, 8},\n    {5, 6}\n  },\n  {\n    {1, 7},\n    {4, 10}\n  },\n  {\n   \
    \ {2, 3},\n    {1, 4}\n  },\n  {\n    {2, 3},\n    {2, 4}\n  },\n  {\n    {1,\
    \ 7},\n    {4, 10}\n  },\n  {\n    {1, 7},", "  local intersection = {}\n  local\
    \ min = math.max(interval1[1], interval2[1])\n  local max = math.min(interval1[2],\
    \ interval2[2])\n  if min <= max then\n    local length = max - min + 1\n    if\
    \ is_prime(length) then\n      return \"YES\"\n    else\n      return \"NO\"\n\
    \    end\n  else\n    return \"NO\"\n  end\nend", "    local s1, e1 = interval1[1],\
    \ interval1[2]\n    local s2, e2 = interval2[1], interval2[2]\n    local s, e\n\
    \    if s1 < s2 then\n        s = s2\n    else\n        s = s1\n    end\n    if\
    \ e1 < e2 then\n        e = e1\n    else\n        e = e2\n    end\n    if s >\
    \ e then\n        return \"NO\"\n    end\n    local c = e - s + 1\n    if c ==\
    \ 2 then\n        return \"YES\"\n    end\n    for i = 2, c - 1 do\n        if\
    \ c % i == 0 then\n            return \"NO\"\n        end\n    end\n    return\
    \ \"YES\"\nend", "    local start = math.max(interval1[1], interval2[1])\n   \
    \ local end_ = math.min(interval1[2], interval2[2])\n    local length = end_ -\
    \ start + 1\n    if length < 0 then return \"NO\" end\n    if length == 1 then\
    \ return \"YES\" end\n    for i = 2, math.sqrt(length) do\n        if length %\
    \ i == 0 then return \"NO\" end\n    end\n    return \"YES\"\nend", "    --print(interval1[1],\
    \ interval1[2], interval2[1], interval2[2])\n    if (interval1[1] > interval2[2]\
    \ or interval2[1] > interval1[2]) then\n        return \"NO\"\n    end\n    local\
    \ start = math.max(interval1[1], interval2[1])\n    local end_ = math.min(interval1[2],\
    \ interval2[2])\n    local diff = end_ - start + 1\n    local is_prime = true\n\
    \    for i = 2, math.floor(math.sqrt(diff)) do\n        if (diff % i == 0) then\n\
    \            is_prime = false\n            break\n        end\n    end\n    if\
    \ (is_prime) then\n        return \"YES\"\n    else\n        return \"NO\"\n \
    \   end\nend", "  if interval1[1] > interval2[2] or interval2[1] > interval1[2]\
    \ then\n    return 'NO'\n  end\n  local a, b, c, d = interval1[1], interval1[2],\
    \ interval2[1], interval2[2]\n  local start = math.max(a, c)\n  local finish =\
    \ math.min(b, d)\n  local len = finish - start + 1\n  local isPrime = true\n \
    \ for i = 2, len - 1 do\n    if len % i == 0 then\n      isPrime = false\n   \
    \   break\n    end\n  end\n  return isPrime and 'YES' or 'NO'\nend", "  local\
    \ i1s, i1e = interval1[1], interval1[2]\n  local i2s, i2e = interval2[1], interval2[2]\n\
    \  if i1e < i2s or i2e < i1s then\n    return \"NO\"\n  end\n  local start = math.max(i1s,\
    \ i2s)\n  local finish = math.min(i1e, i2e)\n  local leng = finish - start + 1\n\
    \  if leng <= 1 then\n    return \"NO\"\n  end\n  for i = 2, leng - 1 do\n   \
    \ if leng % i == 0 then\n      return \"NO\"\n    end\n  end\n  return \"YES\"\
    \nend", "    local rst = {}\n    for i = interval1[1], interval1[2] do\n     \
    \   for j = interval2[1], interval2[2] do\n            if i == j then\n      \
    \          table.insert(rst, i)\n            end\n        end\n    end\n    return\
    \ rst\nend", "    local start = math.max(interval1[1], interval2[1])\n    local\
    \ end_ = math.min(interval1[2], interval2[2])\n    if start > end_ then\n    \
    \    return \"NO\"\n    end\n    local cnt = 0\n    for i = start, end_ do\n \
    \       cnt = cnt + 1\n    end\n    for j = 2, cnt do\n        if cnt % j == 0\
    \ then\n            return \"NO\"\n        end\n    end\n    return \"YES\"\n\
    end\nprint(intersection({1, 3}, {2, 4})) -- \"NO\"\nprint(intersection({1, 2},\
    \ {2, 4})) -- \"YES\"\nprint(intersection({2, 2}, {2, 4})) -- \"YES\"\nprint(intersection({2,\
    \ 2}, {3, 4})) -- \"NO\"\nprint(intersection({1, 4}, {1, 4})) -- \"YES\"\nprint(intersection({1,\
    \ 4}, {1, 5})) -- \"YES\"\nprint(intersection({1, 4}, {2, 5})) -- \"YES\"\nprint(intersection({1,\
    \ 4}, {2, 3})) -- \"YES\"\nprint(intersection({1, 4}, {2, 2})) -- \"YES\"\nprint(intersection({1,\
    \ 4}, {1, 1})) -- \"YES\"\nprint(intersection({1, 4}, {3, 3})) -- \"YES\"\nprint(intersection({3,\
    \ 3}, {1, 4})) -- \"YES\"\nprint(intersection({1, 4}, {1, 2})) -- \"YES\"\nprint(intersection({1,\
    \ 3}, {1, 2})) -- \"NO\"\nprint(intersection({1, 4}, {5, 5})) -- \"NO\"\nprint(intersection({1,\
    \ 4}, {5, 6})) -- \"NO\"\nprint(intersection({1, 4}, {5, 4})) -- \"NO\"\nprint(intersection({4,\
    \ 4}, {5, 4})) -- \"NO\"\nprint(intersection({5, 4}, {4, 4})) -- \"NO\"\nprint(intersection",
  "    local result = {}\n    result.start = math.max(interval1.start, interval2.start)\n\
    \    result.end = math.min(interval1.end, interval2.end)\n    return result\n\
    end", "    local start, finish = 0, 0\n    if interval1[1] >= interval2[1] then\n\
    \        start = interval1[1]\n    else\n        start = interval2[1]\n    end\n\
    \    if interval1[2] <= interval2[2] then\n        finish = interval1[2]\n   \
    \ else\n        finish = interval2[2]\n    end\n    if start > finish then\n \
    \       return \"NO\"\n    end\n    local numbers = {}\n    for i = start, finish\
    \ do\n        table.insert(numbers, i)\n    end\n    local count = 0\n    for\
    \ k, v in pairs(numbers) do\n        count = count + 1\n    end\n    if count\
    \ == 2 then\n        return \"YES\"\n    end\n    local prime = true\n    for\
    \ i = 2, count-1 do\n        if count % i == 0 then\n            prime = false\n\
    \            break\n        end\n    end\n    if prime then\n        return \"\
    YES\"\n    else\n        return \"NO\"\n    end\nend", "  local start1, end1 =\
    \ unpack(interval1)\n  local start2, end2 = unpack(interval2)\n  if start1 > end2\
    \ or start2 > end1 then return \"NO\" end\n  local start = math.max(start1, start2)\n\
    \  local end_ = math.min(end1, end2)\n  local len = end_ - start + 1\n  return\
    \ (len > 1 and (len % 2 == 0 or len % 3 == 0 or len % 5 == 0 or len % 7 == 0))\
    \ and \"NO\" or \"YES\"\nend", "\tlocal maxStart = math.max(interval1[1], interval2[1])\n\
    \tlocal minEnd = math.min(interval1[2], interval2[2])\n\tlocal len = minEnd -\
    \ maxStart + 1\n\tif len < 1 then\n\t\treturn \"NO\"\n\tend\n\tfor d = 2, math.sqrt(len)\
    \ do\n\t\tif len % d == 0 then\n\t\t\treturn \"NO\"\n\t\tend\n\tend\n\treturn\
    \ \"YES\"\nend", "  local length_intersect = math.min(interval1[2], interval2[2])\
    \ - math.max(interval1[1], interval2[1])\n  if length_intersect <= 0 then\n  \
    \  return \"NO\"\n  end\n  for i = 2, length_intersect - 1 do\n    if length_intersect\
    \ % i == 0 then\n      return \"NO\"\n    end\n  end\n  return \"YES\"\nend",
  "    local s1, e1 = interval1[1], interval1[2]\n    local s2, e2 = interval2[1],\
    \ interval2[2]\n    local inters = {}\n    if s1 <= s2 and e1 >= s2 then\n   \
    \     inters[1] = s2\n    end\n    if s2 <= s1 and e2 >= s1 then\n        inters[1]\
    \ = s1\n    end\n    if s1 <= e2 and e1 >= e2 then\n        inters[2] = e2\n \
    \   end\n    if s2 <= e1 and e2 >= e1 then\n        inters[2] = e1\n    end\n\
    \    local length = 0\n    if inters[1] and inters[2] then\n        length = inters[2]\
    \ - inters[1] + 1\n    end\n    return length == 0 and \"NO\" or (length == 1\
    \ and \"NO\" or \"YES\")\nend", "  local x, y = interval1[1], interval1[2]\n \
    \ local a, b = interval2[1], interval2[2]\n  local start, finish = math.max(x,\
    \ a), math.min(y, b)\n  local len = finish - start + 1\n  if start > finish then\
    \ return 'NO' end\n  if len <= 1 then return 'NO' end\n  if #'2 3 5 7' == 0 then\
    \ return 'YES' end\n  if string.find('2 3 5 7', len) then return 'YES' end\n \
    \ return 'NO'\nend", "  if interval1[1] > interval2[2] or interval2[1] > interval1[2]\
    \ then return 'NO' end\n  if interval1[1] > interval2[1] then interval1, interval2\
    \ = interval2, interval1 end\n  local l = interval2[1] - interval1[2]\n  local\
    \ int = 0 - l\n  if l < 0 then int = interval2[2] - interval1[1] end\n  if int\
    \ < 2 then return 'NO' end\n  for i = 2, int do\n    if int % i == 0 then return\
    \ 'NO' end\n  end\n  return 'YES'\nend", "\tif interval1[1] > interval2[2] or\
    \ interval2[1] > interval1[2] then\n\t\treturn 'NO'\n\tend\n\tlocal start = math.max(interval1[1],\
    \ interval2[1])\n\tlocal end_ = math.min(interval1[2], interval2[2])\n\tlocal\
    \ length = end_ - start + 1\n\tfor i = 2, length - 1 do\n\t\tif length % i ==\
    \ 0 then\n\t\t\treturn 'NO'\n\t\tend\n\tend\n\treturn 'YES'\nend", "    local\
    \ begin, stop = table.unpack(interval1)\n    local begin2, stop2 = table.unpack(interval2)\n\
    \    local common_intervals = {}\n    if begin <= begin2 and begin2 <= stop then\n\
    \        common_intervals[#common_intervals + 1] = {begin, begin2 - 1}\n    end\n\
    \    if begin2 <= begin and begin <= stop2 then\n        common_intervals[#common_intervals\
    \ + 1] = {begin2, begin - 1}\n    end\n    if begin2 <= stop and stop <= stop2\
    \ then\n        common_intervals[#common_intervals + 1] = {stop, stop2}\n    end\n\
    \    if begin <= stop2 and stop2 <= stop then\n        common_intervals[#common_intervals\
    \ + 1] = {stop2, stop}\n    end\n    if #common_intervals > 0 then\n        local\
    \ intervals = {}\n        for _, interval in ipairs(common_intervals) do\n   \
    \         local begin, stop = table.unpack(interval)\n            if begin <=\
    \ stop then\n                intervals[#intervals + 1] = interval\n          \
    \  end\n        end\n        if #intervals > 0 then\n            local begin,\
    \ stop = table.unpack(intervals[1])\n            for i = 2, #intervals do\n  \
    \              local begin2, stop2 = table.unpack(intervals[i])\n            \
    \    if begin2 < begin then\n                    begin = begin2\n            \
    \    end\n                if stop2 > stop then\n                    stop = stop2\n\
    \                end\n            end\n            local len = stop - begin +\
    \ 1\n            if len == 1 then\n                return \"NO\"\n           \
    \ end\n            for i = 2, len - 1 do\n                if len % i == 0 then\n\
    \                    return \"NO\"\n                end\n            end\n   \
    \         return \"YES\"\n        end\n    end\n    return \"NO\"\nend", "  local\
    \ ix = {max = math.min(interval1[2], interval2[2]),\n          min = math.max(interval1[1],\
    \ interval2[1])}\n  if ix.min <= ix.max then\n    local length = ix.max - ix.min\
    \ + 1\n    if length > 1 then\n      for i = 2, math.floor(math.sqrt(length))\
    \ do\n        if length % i == 0 then\n          return 'NO'\n        end\n  \
    \    end\n      return 'YES'\n    end\n    return 'NO'\n  end\n  return 'NO'\n\
    end", "\tlocal start1, end1 = interval1[1], interval1[2]\n\tlocal start2, end2\
    \ = interval2[1], interval2[2]\n\tif start1 <= start2 and end1 >= start2 then\n\
    \t\treturn {start2, math.min(end1, end2)}\n\telseif start2 <= start1 and end2\
    \ >= start1 then\n\t\treturn {start1, math.min(end1, end2)}\n\tend\n\treturn {}\n\
    end", "\tlocal start = math.max(interval1[1], interval2[1])\n\tlocal end1 = math.min(interval1[2],\
    \ interval2[2])\n\tlocal diff = end1 - start + 1\n\tlocal prime, i = true, 2\n\
    \twhile i < diff do\n\t\tif diff % i == 0 then prime = false end\n\t\ti = i +\
    \ 1\n\tend\n\tif diff == 0 then return \"NO\" end\n\tif prime then return \"YES\"\
    \ else return \"NO\" end\nend", "  local start = math.max(interval1[1], interval2[1])\n\
    \  local endd = math.min(interval1[2], interval2[2])\n  if endd < start then\n\
    \    return \"NO\"\n  end\n  return isPrime(endd - start + 1) and \"YES\" or \"\
    NO\"\nend", "  local a, b = table.unpack(interval1)\n  local c, d = table.unpack(interval2)\n\
    \  if a > d or b < c then return \"NO\" end\n  if c < a then a = c end\n  if d\
    \ > b then b = d end\n  for i = 2, a do\n    if b % i == 0 then return \"NO\"\
    \ end\n  end\n  return \"YES\"\nend", "    local start, stop = nil, nil\n    if\
    \ interval1[1] <= interval2[1] then\n        start = interval2[1]\n    else\n\
    \        start = interval1[1]\n    end\n    if interval1[2] <= interval2[2] then\n\
    \        stop = interval1[2]\n    else\n        stop = interval2[2]\n    end\n\
    \    if start > stop then\n        return \"NO\"\n    end\n    local arr = {}\n\
    \    for i = start, stop do\n        arr[#arr + 1] = i\n    end\n    local table_is_prime\
    \ = {}\n    for i = 1, #arr do\n        table_is_prime[i] = true\n    end\n  \
    \  for i = 2, math.floor(math.sqrt(#arr)) do\n        if table_is_prime[i] then\n\
    \            for j = 2, math.floor(#arr / i) do\n                table_is_prime[i\
    \ * j] = false\n            end\n        end\n    end\n    local is_prime = true\n\
    \    for i = 1, #arr do\n        if table_is_prime[i] then\n            is_prime\
    \ = false\n            break\n        end\n    end\n    if is_prime then\n   \
    \     return \"YES\"\n    else\n        return \"NO\"\n    end\nend", "    local\
    \ x1, x2 = interval1[1], interval1[2]\n    local y1, y2 = interval2[1], interval2[2]\n\
    \    local min_1, max_1 = math.min(x1, x2), math.max(x1, x2)\n    local min_2,\
    \ max_2 = math.min(y1, y2), math.max(y1, y2)\n    local min, max = math.max(min_1,\
    \ min_2), math.min(max_1, max_2)\n    if max >= min then\n        local length\
    \ = max - min + 1\n        if length == 1 then\n            return 'NO'\n    \
    \    end\n        local is_prime = true\n        for i = 2, math.sqrt(length)\
    \ do\n            if length % i == 0 then\n                is_prime = false\n\
    \                break\n            end\n        end\n        if is_prime then\n\
    \            return 'YES'\n        end\n    end\n    return 'NO'\nend", "    local\
    \ start = math.max(interval1[1], interval2[1])\n    local end_ = math.min(interval1[2],\
    \ interval2[2])\n    if start > end_ then\n        return \"NO\"\n    end\n  \
    \  local length = end_ - start + 1\n    for i = 2, math.sqrt(length) do\n    \
    \    if length % i == 0 then\n            return \"NO\"\n        end\n    end\n\
    \    return \"YES\"\nend", "  local i1 = interval1[1]\n  local i2 = interval1[2]\n\
    \  local j1 = interval2[1]\n  local j2 = interval2[2]\n  if i1 < j1 then\n   \
    \ i1, i2, j1, j2 = j1, j2, i1, i2\n  end\n  local k1 = math.max(i1, j1)\n  local\
    \ k2 = math.min(i2, j2)\n  if k1 <= k2 then\n    return {k1, k2}\n  end\n  return\
    \ nil\nend", "\tlocal inter = {start = math.max(interval1[1], interval2[1]), end\
    \ = math.min(interval1[2], interval2[2])}\n\tlocal len = inter.end - inter.start\
    \ + 1\n\tfor i = 2, math.sqrt(len) do\n\t\tif len % i == 0 then\n\t\t\treturn\
    \ \"NO\"\n\t\tend\n\tend\n\treturn \"YES\"\nend\nassert(intersection({1, 3}, {2,\
    \ 4}) == \"NO\")\nassert(intersection({1, 2}, {1, 2}) == \"YES\")\nassert(intersection({1,\
    \ 5}, {3, 7}) == \"NO\")\nassert(intersection({3, 17}, {9, 21}) == \"YES\")\n\
    assert(intersection({1, 23}, {17, 29}) == \"NO\")\nassert(intersection({2, 3},\
    \ {4, 7}) == \"NO\")\nassert(intersection({5, 11}, {7, 19}) == \"YES\")\nassert(intersection({13,\
    \ 19}, {17, 29}) == \"YES\")\nassert(intersection({2, 3}, {1, 4}) == \"NO\")\n\
    assert(intersection({23, 29}, {17, 23}) == \"YES\")", "    local from, to = math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])\n    if from >= to then\
    \ return \"NO\" end\n    local function prime(x)\n        for i = 2, math.floor(math.sqrt(x))\
    \ do\n            if x % i == 0 then return false end\n        end\n        return\
    \ true\n    end\n    return (prime(to - from + 1) and \"YES\") or \"NO\"\nend",
  "  if interval1[1] <= interval2[1] then\n    if interval1[2] >= interval2[1] then\n\
    \      if interval1[2] <= interval2[2] then\n        return {interval2[1], interval1[2]}\n\
    \      else\n        return {interval2[1], interval2[2]}\n      end\n    else\n\
    \      return false\n    end\n  else\n    if interval2[2] >= interval1[1] then\n\
    \      if interval2[2] <= interval1[2] then\n        return {interval1[1], interval2[2]}\n\
    \      else\n        return {interval1[1], interval1[2]}\n      end\n    else\n\
    \      return false\n    end\n  end\nend", "  local start, end;\n  start = math.max(interval1[1],\
    \ interval2[1]);\n  end = math.min(interval1[2], interval2[2]);\n  if start >\
    \ end then\n    return \"NO\";\n  end\n  local len = end - start + 1;\n  if len\
    \ < 2 then\n    return \"YES\";\n  end\n  for i = 2, len - 1 do\n    if len %\
    \ i == 0 then\n      return \"NO\";\n    end\n  end\n  return \"YES\";\nend\n\
    return {\n  intersection = intersection,\n  explanation = function()\n    print(\"\
    You are given two intervals, where each interval is a pair of integers.\\nFor\
    \ example, interval = (start, end) = (1, 2).\\nThe given intervals are closed\
    \ which means that the interval (start, end) includes both start and end.\\nFor\
    \ each given interval, it is assumed that its start is less or equal its end.\\\
    nYour task is to determine whether the length of intersection of these two intervals\
    \ is a prime number.\\nExample, the intersection of the intervals (1, 3), (2,\
    \ 4) is (2, 3) which its length is 1, which not a prime number.\\nIf the length\
    \ of the intersection is a prime number, return \\\"YES\\\", otherwise, return\
    \ \\\"NO\\\".\\nIf the two intervals don't intersect, return \\\"NO\\\".\")\n\
    \  end\n}", "    local a, b = interval1[1], interval1[2]\n    local c, d = interval2[1],\
    \ interval2[2]\n    local ans = \"NO\"\n    if a <= c and c <= b and b <= d then\n\
    \        ans = (c - a + 1) % 2 == 0 and \"NO\" or \"YES\"\n    elseif c <= a and\
    \ a <= d and d <= b then\n        ans = (d - a + 1) % 2 == 0 and \"NO\" or \"\
    YES\"\n    elseif a <= c and d <= b then\n        ans = (d - c + 1) % 2 == 0 and\
    \ \"NO\" or \"YES\"\n    elseif c <= a and b <= d then\n        ans = (b - a +\
    \ 1) % 2 == 0 and \"NO\" or \"YES\"\n    end\n    return ans\nend", "    local\
    \ start1, end1 = interval1[1], interval1[2]\n    local start2, end2 = interval2[1],\
    \ interval2[2]\n    local min_end = math.min(end1, end2)\n    local max_start\
    \ = math.max(start1, start2)\n    local len = min_end - max_start + 1\n    if\
    \ len < 1 then\n        return \"NO\"\n    end\n    local half = math.floor(len\
    \ / 2)\n    for i = 2, half do\n        if len % i == 0 then\n            return\
    \ \"NO\"\n        end\n    end\n    return \"YES\"\nend", "    if not(interval1[1]\
    \ <= interval2[2] and interval2[1] <= interval1[2]) then return \"NO\" end\n \
    \   local start, finish = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\n    local len = finish - start + 1\n    if len == 1 then return\
    \ \"NO\" end\n    for i = 2, len - 1 do\n        if len % i == 0 then return \"\
    NO\" end\n    end\n    return \"YES\"\nend", "  local a, b = interval1[1], interval1[2]\n\
    \  local c, d = interval2[1], interval2[2]\n  local start, end = math.max(a, c),\
    \ math.min(b, d)\n  if start > end then\n    return false\n  end\n  local num_primes\
    \ = 0\n  for i = start, end do\n    if is_prime(i) then\n      num_primes = num_primes\
    \ + 1\n    end\n  end\n  return is_prime(num_primes)\nend", "  local function\
    \ gcd(a, b)\n    while a ~= b do\n      if a > b then\n        a = a - b\n   \
    \   else\n        b = b - a\n      end\n    end\n    return a\n  end\n  local\
    \ function is_prime(n)\n    if n == 2 then\n      return true\n    end\n    for\
    \ i = 2, n - 1 do\n      if n % i == 0 then\n        return false\n      end\n\
    \    end\n    return true\n  end\n  local a, b = interval1[1], interval1[2]\n\
    \  local c, d = interval2[1], interval2[2]\n  if a > c then\n    c, d, a, b =\
    \ a, b, c, d\n  end\n  if d < a or b < c then\n    return \"NO\"\n  end\n  if\
    \ a < c then\n    a = c\n  end\n  if b > d then\n    b = d\n  end\n  local d1\
    \ = b - a + 1\n  if d1 == 1 then\n    return \"NO\"\n  end\n  if is_prime(d1)\
    \ then\n    return \"YES\"\n  end\n  return \"NO\"\nend", "  local start, end\n\
    \  start = math.max(interval1[1], interval2[1])\n  endd = math.min(interval1[2],\
    \ interval2[2])\n  if endd < start then return \"NO\" end\n  local len = endd\
    \ - start + 1\n  for i = 2, len - 1 do\n    if len % i == 0 then return \"NO\"\
    \ end\n  end\n  return \"YES\"\nend", "\tlocal intersec = {}\n\tfor i = interval1[1],\
    \ interval1[2] do\n\t\tif interval2[1] <= i and i <= interval2[2] then\n\t\t\t\
    table.insert(intersec, i)\n\t\tend\n\tend\n\treturn intersec\nend", "\tif interval1[1]\
    \ > interval2[2] or interval2[1] > interval1[2] then\n\t\treturn \"NO\"\n\tend\n\
    \tlocal inter = {math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])}\n\tlocal x = inter[2] - inter[1] + 1\n\tlocal prime = false\n\
    \tif x == 1 then\n\t\tprime = true\n\telse\n\t\tfor i = 2, x - 1 do\n\t\t\tif\
    \ x % i == 0 then\n\t\t\t\tprime = false\n\t\t\t\tbreak\n\t\t\telse\n\t\t\t\t\
    prime = true\n\t\t\tend\n\t\tend\n\tend\n\tif prime then\n\t\treturn \"YES\"\n\
    \telse\n\t\treturn \"NO\"\n\tend\nend", "    local left, right = max(interval1[1],\
    \ interval2[1]), min(interval1[2], interval2[2])\n    if left > right then return\
    \ \"NO\" end\n    if isPrime(right - left + 1) then return \"YES\" else return\
    \ \"NO\" end\nend", "    if interval1[1] > interval2[2] or interval2[1] > interval1[2]\
    \ then\n        return \"NO\"\n    end\n    local start = math.max(interval1[1],\
    \ interval2[1])\n    local finish = math.min(interval1[2], interval2[2])\n   \
    \ local length = finish - start + 1\n    for i = 2, math.floor(math.sqrt(length))\
    \ do\n        if length % i == 0 then\n            return \"NO\"\n        end\n\
    \    end\n    return \"YES\"\nend", "    -- return the intersection of interval1\
    \ and interval2\n    local s = math.max(interval1[1], interval2[1])\n    local\
    \ e = math.min(interval1[2], interval2[2])\n    if s <= e then\n        return\
    \ {s, e}\n    end\n    return nil\nend", "  local x1,y1 = interval1[1], interval1[2]\n\
    \  local x2,y2 = interval2[1], interval2[2]\n  local num = math.min(y1,y2) - math.max(x1,x2)\
    \ + 1\n  local prime = num > 0 and num > 1 and num % 2 == 1\n  return prime and\
    \ num ~= 5 and num ~= 7 and num ~= 11\nend", "    -- check intersection\n    if\
    \ interval1[1] > interval2[2] or interval2[1] > interval1[2] then\n        return\
    \ \"NO\"\n    end\n    -- calculate interval length\n    local length1 = interval1[2]\
    \ - interval1[1] + 1\n    local length2 = interval2[2] - interval2[1] + 1\n  \
    \  -- check length of intersection\n    if length1 == 1 or length2 == 1 then\n\
    \        return \"YES\"\n    end\n    -- calculate intersection length\n    local\
    \ length = 0\n    if interval1[1] > interval2[1] then\n        length = interval1[2]\
    \ - interval1[1] + 1 - (interval1[1] - interval2[1])\n    else\n        length\
    \ = interval2[2] - interval2[1] + 1 - (interval2[1] - interval1[1])\n    end\n\
    \    -- check if length is prime\n    for i = 2, length - 1 do\n        if length\
    \ % i == 0 then\n            return \"NO\"\n        end\n    end\n    return \"\
    YES\"\nend", "  local newStart = math.max(interval1[1], interval2[1])\n  local\
    \ newEnd = math.min(interval1[2], interval2[2])\n  if newStart > newEnd then return\
    \ \"NO\" end\n  if isPrime(newEnd - newStart + 1) then return \"YES\" end\n  return\
    \ \"NO\"\nend", "    local a, b = interval1[1], interval1[2]\n    local c, d =\
    \ interval2[1], interval2[2]\n    local start, finish = math.max(a, c), math.min(b,\
    \ d)\n    if finish < start then return \"NO\" end\n    if math.floor(math.sqrt(finish\
    \ - start)) < 2 then return \"YES\" end\n    return \"NO\"\nend", "    -- input:\
    \ intervals\n    -- output: YES/NO\n    local intersection = {math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])}\n    if intersection[1]\
    \ > intersection[2] then\n        return \"NO\"\n    end\n    for k = 2, math.sqrt(intersection[2]\
    \ - intersection[1]) do\n        if (intersection[2] - intersection[1]) % k ==\
    \ 0 then\n            return \"NO\"\n        end\n    end\n    return \"YES\"\n\
    end", "\tlocal start, finish = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\n\tif finish < start then return 'NO' end\n\treturn isPrime(finish\
    \ - start + 1) and 'YES' or 'NO'\nend", "    local a, b = interval1[1], interval1[2]\n\
    \    local c, d = interval2[1], interval2[2]\n    if a > d or c > b then\n   \
    \     return \"NO\"\n    end\n    local length = math.min(b, d) - math.max(a,\
    \ c) + 1\n    if length <= 0 then\n        return \"NO\"\n    end\n    local i\
    \ = 2\n    while i * i <= length do\n        if length % i == 0 then\n       \
    \     return \"NO\"\n        end\n        i = i + 1\n    end\n    return \"YES\"\
    \nend", "    local a, b = interval1[1], interval1[2]\n    local c, d = interval2[1],\
    \ interval2[2]\n    local x, y\n    if c > b or a > d then\n        return \"\
    NO\"\n    else\n        x = math.max(a, c)\n        y = math.min(b, d)\n    end\n\
    \    local len = y - x + 1\n    local prime = function(x)\n        if x <= 1 then\n\
    \            return false\n        end\n        for i = 2, math.floor(math.sqrt(x))\
    \ do\n            if x % i == 0 then\n                return false\n         \
    \   end\n        end\n        return true\n    end\n    if prime(len) then\n \
    \       return \"YES\"\n    else\n        return \"NO\"\n    end\nend", "  local\
    \ intersection = { math.max(interval1[1], interval2[1]),\n                   \
    \      math.min(interval1[2], interval2[2]) }\n  if intersection[1] > intersection[2]\
    \ then\n    return nil\n  end\n  local function is_prime(n)\n    for i = 2, math.sqrt(n)\
    \ do\n      if n % i == 0 then\n        return false\n      end\n    end\n   \
    \ return true\n  end\n  return is_prime(intersection[2] - intersection[1] + 1)\
    \ and \"YES\" or \"NO\"\nend", "    local start, end_ = math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])\n    if start > end_ then\
    \ return \"NO\" end\n    local length = end_ - start + 1\n    if length == 1 then\
    \ return \"NO\" end\n    for i = 2, math.floor(math.sqrt(length)) do\n       \
    \ if length % i == 0 then return \"NO\" end\n    end\n    return \"YES\"\nend",
  "  local a1, a2 = interval1[1], interval1[2]\n  local b1, b2 = interval2[1], interval2[2]\n\
    \  local x1, x2 = math.max(a1, b1), math.min(a2, b2)\n  if x1 > x2 then return\
    \ 'NO' end\n  local t = {'YES', 'NO'}\n  return t[x2 - x1 + 1 > 1 and x2 - x1\
    \ + 1 > 2 and x2 - x1 + 1 % 2 == 0]\nend", "  local start, finish = table.unpack(interval1)\n\
    \  local start1, finish1 = table.unpack(interval2)\n  local start, finish = math.max(start,\
    \ start1), math.min(finish, finish1)\n  if start <= finish then\n    local len\
    \ = finish - start + 1\n    if len <= 1 then return \"NO\" end\n    local primes\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97}\n    for _, v in ipairs(primes) do\n      if v == len then\
    \ return \"YES\" end\n    end\n    return \"NO\"\n  end\n  return \"NO\"\nend\n\
    assert(intersection({1, 3}, {2, 4}) == \"NO\")\nassert(intersection({0, 5}, {4,\
    \ 7}) == \"YES\")\nassert(intersection({1, 4}, {4, 5}) == \"NO\")\nassert(intersection({0,\
    \ 10}, {0, 10}) == \"YES\")\nassert(intersection({2, 3}, {1, 4}) == \"YES\")\n\
    assert(intersection({5, 6}, {3, 4}) == \"NO\")\nassert(intersection({1, 3}, {2,\
    \ 3}) == \"YES\")\nassert(intersection({3, 4}, {3, 5}) == \"NO\")", "    local\
    \ x1, y1 = interval1[1], interval1[2]\n    local x2, y2 = interval2[1], interval2[2]\n\
    \    if x1 > y2 or x2 > y1 then\n        return \"NO\"\n    end\n    local min_x\
    \ = math.max(x1, x2)\n    local max_y = math.min(y1, y2)\n    local len = max_y\
    \ - min_x + 1\n    if len < 2 then\n        return \"NO\"\n    end\n    local\
    \ k = 1\n    for i = 2, len do\n        if len % i == 0 then\n            k =\
    \ i\n            break\n        end\n    end\n    if k == 1 then\n        return\
    \ \"YES\"\n    else\n        return \"NO\"\n    end\nend", "  local start1, end1\
    \ = interval1[1], interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n\
    \  if start1 > end2 or start2 > end1 then\n    return \"NO\"\n  end\n  local len\
    \ = math.min(end1, end2) - math.max(start1, start2) + 1\n  local sqrt_len = math.sqrt(len)\n\
    \  for i = 2, sqrt_len do\n    if len % i == 0 then\n      return \"NO\"\n   \
    \ end\n  end\n  return \"YES\"\nend", "  local start = math.max(interval1[1],\
    \ interval2[1])\n  local finish = math.min(interval1[2], interval2[2])\n  local\
    \ length = finish - start + 1\n  if length < 1 then return \"NO\" end\n  if length\
    \ == 1 then return \"YES\" end\n  for i = 2, math.sqrt(length) do\n    if length\
    \ % i == 0 then return \"NO\" end\n  end\n  return \"YES\"\nend", "    -- check\
    \ if two intervals intersect\n    if interval1[1] > interval2[2] or interval2[1]\
    \ > interval1[2] then\n        return \"NO\"\n    end\n    -- calculate the intersection\n\
    \    local start = math.max(interval1[1], interval2[1])\n    local end_ = math.min(interval1[2],\
    \ interval2[2])\n    local interval = {start, end_}\n    -- check if the intersection\
    \ is a prime number\n    local primes = {1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    local is_prime\
    \ = false\n    for i = 1, #primes do\n        if interval[2] - interval[1] ==\
    \ primes[i] then\n            is_prime = true\n            break\n        end\n\
    \    end\n    if is_prime then\n        return \"YES\"\n    else\n        return\
    \ \"NO\"\n    end\nend", "    local start = math.max(interval1[1], interval2[1])\n\
    \    local stop = math.min(interval1[2], interval2[2])\n    if start > stop then\
    \ return \"NO\" end\n    local len = stop - start + 1\n    local n = math.floor(math.sqrt(len))\n\
    \    for i = 2, n do\n        if len % i == 0 then return \"NO\" end\n    end\n\
    \    return \"YES\"\nend", "    local _begin = math.max(interval1[1], interval2[1])\n\
    \    local _end = math.min(interval1[2], interval2[2])\n    if _begin > _end then\
    \ return \"NO\" end\n    if _begin == _end then return \"YES\" end\n    for i\
    \ = 2, _end do\n        if _begin % i == 0 then return \"NO\" end\n    end\n \
    \   return \"YES\"\nend", "    local function is_prime(n)\n        if n <= 3 then\n\
    \            return true\n        end\n        for i = 2, n - 1 do\n         \
    \   if n % i == 0 then\n                return false\n            end\n      \
    \  end\n        return true\n    end\n    local x, y = interval1[1], interval1[2]\n\
    \    local u, v = interval2[1], interval2[2]\n    local a, b\n    if x <= u and\
    \ u <= y then\n        a = u\n    elseif u <= x and x <= v then\n        a = x\n\
    \    else\n        return 'NO'\n    end\n    if x <= v and v <= y then\n     \
    \   b = v\n    elseif u <= y and y <= v then\n        b = y\n    else\n      \
    \  return 'NO'\n    end\n    if a == b then\n        return 'YES'\n    end\n \
    \   return is_prime(b - a + 1) and 'YES' or 'NO'\nend", "  local intersect = {math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])}\n  local length = math.max(0,\
    \ intersect[2] - intersect[1] + 1)\n  local primes = {2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n  for\
    \ _, prime in ipairs(primes) do\n    if prime == length then\n      return \"\
    YES\"\n    end\n  end\n  return \"NO\"\nend", "    if interval1[1] > interval2[2]\
    \ or interval2[1] > interval1[2] then\n        return 'NO'\n    end\n    local\
    \ max_start = math.max(interval1[1], interval2[1])\n    local min_end = math.min(interval1[2],\
    \ interval2[2])\n    local len = min_end - max_start + 1\n    for i = 2, math.sqrt(len)\
    \ do\n        if len % i == 0 then\n            return 'NO'\n        end\n   \
    \ end\n    return 'YES'\nend", "    local a, b = interval1[1], interval1[2]\n\
    \    local c, d = interval2[1], interval2[2]\n    local p, q = math.max(a, c),\
    \ math.min(b, d)\n    if p > q then\n        return \"NO\"\n    end\n    local\
    \ len = q - p + 1\n    for i = 2, math.floor(math.sqrt(len)) do\n        if len\
    \ % i == 0 then\n            return \"NO\"\n        end\n    end\n    return \"\
    YES\"\nend", "  local min1, max1 = table.unpack(interval1)\n  local min2, max2\
    \ = table.unpack(interval2)\n  if max1 < min2 or max2 < min1 then\n    return\
    \ \"NO\"\n  end\n  local min, max = math.max(min1, min2), math.min(max1, max2)\n\
    \  local len = max - min + 1\n  if len <= 2 then\n    return \"NO\"\n  end\n \
    \ for i = 2, math.floor(math.sqrt(len)) do\n    if len % i == 0 then\n      return\
    \ \"NO\"\n    end\n  end\n  return \"YES\"\nend", "  local x1, y1 = interval1[1],\
    \ interval1[2]\n  local x2, y2 = interval2[1], interval2[2]\n  local x, y = math.max(x1,\
    \ x2), math.min(y1, y2)\n  local range = y - x + 1\n  return range <= 0 and \"\
    NO\" or range % 2 == 0 and \"NO\" or range % 3 == 0 and \"NO\" or \"YES\"\nend",
  "  local ans = 0\n  for i = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2]) do\n    ans = ans + 1\n  end\n  if ans == 0 then\n    return \"\
    NO\"\n  elseif ans == 1 then\n    return \"NO\"\n  elseif ans == 2 then\n    return\
    \ \"YES\"\n  elseif ans % 2 == 0 then\n    return \"NO\"\n  else\n    for i =\
    \ 3, math.sqrt(ans) do\n      if ans % i == 0 then\n        return \"NO\"\n  \
    \    end\n    end\n    return \"YES\"\n  end\nend", "  local lower = math.max(interval1[1],\
    \ interval2[1])\n  local upper = math.min(interval1[2], interval2[2])\n  if upper\
    \ >= lower then\n    return upper - lower + 1\n  else\n    return 0\n  end\nend",
  "  local start, finish = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\n  if start > finish then return 'NO' end\n  local length = finish\
    \ - start + 1\n  return (length == 2 or length == 3 or length == 5 or length ==\
    \ 7) and 'YES' or 'NO'\nend", "    local max_start = math.max(interval1[1], interval2[1])\n\
    \    local min_end = math.min(interval1[2], interval2[2])\n    local prime = {2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97}\n    if max_start >= min_end then\n        return \"NO\"\n \
    \   end\n    for i = 1, #prime do\n        if prime[i] == min_end - max_start\
    \ + 1 then\n            return \"YES\"\n        end\n    end\n    return \"NO\"\
    \nend\nprint(intersection({1, 3}, {2, 4}))", "\tlocal a, b = interval1[1], interval1[2]\n\
    \tlocal c, d = interval2[1], interval2[2]\n\tif d < a or b < c then return 'NO'\
    \ end\n\tlocal lo, hi = math.max(a, c), math.min(b, d)\n\tif lo == hi then return\
    \ 'NO' end\n\tlocal len = hi - lo + 1\n\tif len == 1 then return 'NO' end\n\t\
    if len == 2 then return 'YES' end\n\tfor i = 2, math.sqrt(len) do\n\t\tif len\
    \ % i == 0 then return 'NO' end\n\tend\n\treturn 'YES'\nend", "    local max =\
    \ math.max(interval1[1], interval2[1])\n    local min = math.min(interval1[2],\
    \ interval2[2])\n    if max > min then\n        return \"NO\"\n    end\n    local\
    \ difference = min - max + 1\n    if difference == 1 then\n        return \"NO\"\
    \n    end\n    local r = math.sqrt(difference)\n    for i = 2, r do\n        if\
    \ difference % i == 0 then\n            return \"NO\"\n        end\n    end\n\
    \    return \"YES\"\nend", "  if interval1[1] > interval2[2] or interval2[1] >\
    \ interval1[2] then return 'NO' end\n  local start = math.max(interval1[1], interval2[1])\n\
    \  local stop = math.min(interval1[2], interval2[2])\n  if start > stop then return\
    \ 'NO' end\n  local length = stop - start + 1\n  if isPrime(length) then return\
    \ 'YES' else return 'NO' end\nend", "\tlocal x1,y1 = interval1[1], interval1[2]\n\
    \tlocal x2,y2 = interval2[1], interval2[2]\n\tlocal a,b = x1, y1\n\tif x2 > x1\
    \ then a = x2 end\n\tif y2 < y1 then b = y2 end\n\tif a < b then\n\t\tlocal function\
    \ is_prime(n)\n\t\t\tif n <= 1 then return false end\n\t\t\tif n == 2 then return\
    \ true end\n\t\t\tif n%2 == 0 then return false end\n\t\t\tlocal div = 3\n\t\t\
    \twhile div*div <= n do\n\t\t\t\tif n%div == 0 then return false end\n\t\t\t\t\
    div = div + 2\n\t\t\tend\n\t\t\treturn true\n\t\tend\n\t\treturn is_prime(b-a+1)\
    \ and \"YES\" or \"NO\"\n\tend\n\treturn \"NO\"\nend", "    local function gcd(a,\
    \ b)\n        if b == 0 then return a end\n        return gcd(b, a % b)\n    end\n\
    \    local function isPrime(n)\n        if n < 2 then return false end\n     \
    \   for i = 2, math.sqrt(n) do\n            if n % i == 0 then return false end\n\
    \        end\n        return true\n    end\n    local start = math.max(interval1[1],\
    \ interval2[1])\n    local finish = math.min(interval1[2], interval2[2])\n   \
    \ if start > finish then return \"NO\" end\n    local len = finish - start + 1\n\
    \    if len == 1 then return \"YES\" end\n    local g = gcd(len, len - 1)\n  \
    \  if isPrime(g) then return \"YES\" end\n    return \"NO\"\nend\nreturn {\n \
    \   intersection = intersection\n}", "  local res = {\"NO\"}\n  local inters =\
    \ {}\n  if interval1[1] > interval2[1] then\n    inters[1] = interval1[1]\n  else\n\
    \    inters[1] = interval2[1]\n  end\n  if interval1[2] < interval2[2] then\n\
    \    inters[2] = interval1[2]\n  else\n    inters[2] = interval2[2]\n  end\n \
    \ if inters[1] <= inters[2] then\n    local res2 = \"YES\"\n    for i = 2, inters[2]\
    \ - inters[1] do\n      if (inters[2] - inters[1]) % i == 0 then\n        res2\
    \ = \"NO\"\n        break\n      end\n    end\n    res = {res2}\n  end\n  return\
    \ unpack(res)\nend", "  if interval1[1] > interval2[2] or interval2[1] > interval1[2]\
    \ then\n    return \"NO\"\n  end\n  if interval1[1] <= interval2[1] then\n   \
    \ local x = interval2[1]\n    if interval1[2] >= interval2[2] then\n      local\
    \ y = interval2[2]\n      return isPrime(y - x + 1) and \"YES\" or \"NO\"\n  \
    \  else\n      local y = interval1[2]\n      return isPrime(y - x + 1) and \"\
    YES\" or \"NO\"\n    end\n  else\n    local x = interval1[1]\n    if interval1[2]\
    \ >= interval2[2] then\n      local y = interval2[2]\n      return isPrime(y -\
    \ x + 1) and \"YES\" or \"NO\"\n    else\n      local y = interval1[2]\n     \
    \ return isPrime(y - x + 1) and \"YES\" or \"NO\"\n    end\n  end\nend", "   \
    \ local s1, e1 = interval1[1], interval1[2]\n    local s2, e2 = interval2[1],\
    \ interval2[2]\n    if e1 < s2 or e2 < s1 then return 'NO' end\n    local start\
    \ = math.max(s1, s2)\n    local finish = math.min(e1, e2)\n    return (finish\
    \ - start) % 2 == 0 and 'NO' or 'YES'\nend", "    local start = math.max(interval1[1],\
    \ interval2[1])\n    local finish = math.min(interval1[2], interval2[2])\n   \
    \ if start > finish then\n        return \"NO\"\n    end\n    local length = finish\
    \ - start + 1\n    for i = 2, math.sqrt(length) do\n        if length % i == 0\
    \ then\n            return \"NO\"\n        end\n    end\n    return \"YES\"\n\
    end", "\tlocal a1, a2 = interval1[1], interval1[2]\n\tlocal b1, b2 = interval2[1],\
    \ interval2[2]\n\tlocal x1, x2 = math.max(a1, b1), math.min(a2, b2)\n\tif x1 >\
    \ x2 then return \"NO\" end", "    local start, fin = math.max(interval1[1], interval2[1]),\
    \ math.min(interval1[2], interval2[2])\n    if start <= fin then\n        local\
    \ len = fin - start + 1\n        return not((2 == len) or (0 == len % 2)) and\
    \ (math.floor(math.sqrt(len)) * math.floor(math.sqrt(len)) ~= len)\n    end\n\
    \    return false\nend", "  local start1, end1 = unpack(interval1)\n  local start2,\
    \ end2 = unpack(interval2)\n  if end1 < start2 or end2 < start1 then\n    return\
    \ \"NO\"\n  end\n  local start = math.max(start1, start2)\n  local fin = math.min(end1,\
    \ end2)\n  local len = fin - start + 1\n  if len == 1 then\n    return \"NO\"\n\
    \  end\n  for i = 2, math.sqrt(len) do\n    if len % i == 0 then\n      return\
    \ \"NO\"\n    end\n  end\n  return \"YES\"\nend", "    local res = {}\n    if\
    \ #interval1 == 2 and #interval2 == 2 then\n        if interval1[1] > interval2[1]\
    \ then\n            res[1] = interval1[1]\n        else\n            res[1] =\
    \ interval2[1]\n        end\n        if interval1[2] < interval2[2] then\n   \
    \         res[2] = interval1[2]\n        else\n            res[2] = interval2[2]\n\
    \        end\n        if res[1] > res[2] then\n            return \"NO\"\n   \
    \     end\n        if isPrime(res[2] - res[1] + 1) then\n            return \"\
    YES\"\n        else\n            return \"NO\"\n        end\n    else\n      \
    \  return \"NO\"\n    end\nend", "    local x1, y1 = unpack(interval1)\n    local\
    \ x2, y2 = unpack(interval2)\n    if y1 < x2 or y2 < x1 then\n        return \"\
    NO\"\n    end\n    local v1 = math.min(y1, y2)\n    local v2 = math.max(x1, x2)\n\
    \    local l = v1 - v2 + 1\n    return l <= 1 and \"NO\" or l ~= 2 and \"YES\"\
    \ or x1 == 2 and \"YES\" or \"NO\"\nend", "    local start, _ = math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])\n    local end_, _ = math.min(interval1[2],\
    \ interval2[2]), math.max(interval1[1], interval2[1])\n    if start <= end_ then\n\
    \        local length = end_ - start + 1\n        if length == 1 then\n      \
    \      return \"NO\"\n        end\n        for i = 2, math.sqrt(length) do\n \
    \           if length % i == 0 then\n                return \"NO\"\n         \
    \   end\n        end\n        return \"YES\"\n    end\n    return \"NO\"\nend",
  "    local start = math.max(interval1[1], interval2[1])\n    local finish = math.min(interval1[2],\
    \ interval2[2])\n    local result = \"NO\"\n    if start <= finish then\n    \
    \    result = \"YES\"\n        for i = 2, math.floor(math.sqrt(finish - start))\
    \ do\n            if (finish - start) % i == 0 then\n                result =\
    \ \"NO\"\n                break\n            end\n        end\n    end\n    return\
    \ result\nend\nprint(intersection({1,3}, {2,4})) -- \"NO\"\nprint(intersection({1,3},\
    \ {2,6})) -- \"YES\"\nprint(intersection({1,3}, {2,7})) -- \"NO\"\nprint(intersection({1,3},\
    \ {3,6})) -- \"YES\"\nprint(intersection({1,3}, {2,2})) -- \"YES\"\nprint(intersection({1,4},\
    \ {4,4})) -- \"YES\"\nprint(intersection({1,4}, {4,6})) -- \"YES\"\nprint(intersection({2,4},\
    \ {4,4})) -- \"YES\"\nprint(intersection({1,4}, {5,5})) -- \"NO\"\nprint(intersection({2,4},\
    \ {5,5})) -- \"NO\"\nprint(intersection({2,4}, {1,1})) -- \"NO\"\nprint(intersection({3,6},\
    \ {3,3})) -- \"YES\"\nprint(intersection({1,6}, {1,1})) -- \"YES\"\nprint(intersection({1,4},\
    \ {4,4})) -- \"YES\"\nprint(intersection({1,4}, {4,4})) -- \"YES\"\nprint(intersection({3,9},\
    \ {5,7})) -- \"YES\"\nprint(intersection({1,8}, {2,6})) -- \"YES\"\nprint(intersection({1,1},\
    \ {1,1})) -- \"YES\"\nprint(intersection({1,6}, {1,1})) -- \"YES\"\nprint(intersection({2,6",
  "  local start1, end1 = interval1[1], interval1[2]\n  local start2, end2 = interval2[1],\
    \ interval2[2]\n  local s = math.max(start1, start2)\n  local e = math.min(end1,\
    \ end2)\n  if s > e then return 'NO' end\n  if s == e then return 'YES' end\n\
    \  local length = e - s + 1\n  local primes = { [2] = true, [3] = true, [5] =\
    \ true, [7] = true, [11] = true, [13] = true, [17] = true, [19] = true, [23] =\
    \ true, [29] = true, [31] = true, [37] = true, [41] = true, [43] = true, [47]\
    \ = true, [53] = true, [59] = true, [61] = true, [67] = true, [71] = true, [73]\
    \ = true, [79] = true, [83] = true, [89] = true, [97] = true }\n  return primes[length]\
    \ and 'YES' or 'NO'\nend", "  if (interval1[1] > interval2[2] or interval2[1]\
    \ > interval1[2]) then\n    return \"NO\"\n  end\n  local start = math.max(interval1[1],\
    \ interval2[1])\n  local finish = math.min(interval1[2], interval2[2])\n  if (start\
    \ > finish) then\n    return \"NO\"\n  end\n  if (isPrime(finish - start + 1))\
    \ then\n    return \"YES\"\n  end\n  return \"NO\"\nend", "\tlocal res = \"\"\n\
    \tlocal low = math.max(interval1[1], interval2[1])\n\tlocal high = math.min(interval1[2],\
    \ interval2[2])\n\tif low > high then\n\t\tres = \"NO\"\n\telse\n\t\tlocal primes\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97}\n\t\tlocal count = 0\n\t\tfor i = low, high do\n\t\t\tif\
    \ primes[i] then\n\t\t\t\tcount = count + 1\n\t\t\tend\n\t\tend\n\t\tif count\
    \ ~= 0 then\n\t\t\tres = \"YES\"\n\t\telse\n\t\t\tres = \"NO\"\n\t\tend\n\tend\n\
    \treturn res\nend", "\tlocal start = math.max(interval1[1], interval2[1])\n\t\
    local finish = math.min(interval1[2], interval2[2])\n\tif finish < start then\n\
    \t\treturn \"NO\"\n\tend\n\treturn isPrime(finish - start + 1) and \"YES\" or\
    \ \"NO\"\nend", "  local start1, end1 = interval1[1], interval1[2]\n  local start2,\
    \ end2 = interval2[1], interval2[2]\n  local intersectionStart = math.max(start1,\
    \ start2)\n  local intersectionEnd = math.min(end1, end2)\n  if intersectionStart\
    \ <= intersectionEnd then\n    return {intersectionStart, intersectionEnd}\n \
    \ else\n    return nil\n  end\nend", "    local start1, end1 = unpack(interval1)\n\
    \    local start2, end2 = unpack(interval2)\n    if start1 > end2 or start2 >\
    \ end1 then\n        return \"NO\"\n    end\n    local start = math.max(start1,\
    \ start2)\n    local finish = math.min(end1, end2)\n    local result = \"NO\"\n\
    \    if finish - start > 1 then\n        local primes = {2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n  \
    \      for _, v in ipairs(primes) do\n            if finish - start == v then\n\
    \                result = \"YES\"\n                break\n            end\n  \
    \      end\n    end\n    return result\nend", "  local min_start = math.max(interval1[1],\
    \ interval2[1])\n  local max_end = math.min(interval1[2], interval2[2])\n  local\
    \ res = false\n  if min_start <= max_end then\n    local len = max_end - min_start\
    \ + 1\n    local sqrt = math.sqrt(len)\n    for i = 2, sqrt do\n      if len %\
    \ i == 0 then\n        res = false\n        break\n      else\n        res = true\n\
    \      end\n    end\n  end\n  return res and \"YES\" or \"NO\"\nend", "    local\
    \ function isPrime(n)\n        if n < 2 then return false end\n        for i =\
    \ 2, math.floor(math.sqrt(n)) do\n            if n % i == 0 then return false\
    \ end\n        end\n        return true\n    end\n    local a, b = interval1[1],\
    \ interval1[2]\n    local c, d = interval2[1], interval2[2]\n    if a > d or c\
    \ > b then return \"NO\" end\n    local i = math.max(a, c)\n    local j = math.min(b,\
    \ d)\n    if i == j then return \"NO\" end\n    return isPrime(j - i + 1) and\
    \ \"YES\" or \"NO\"\nend", "  local start, stop = math.max(interval1[1], interval2[1]),\
    \ math.min(interval1[2], interval2[2])\n  if start <= stop then\n    local length\
    \ = stop - start + 1\n    return length > 1 and \"YES\" or \"NO\"\n  end\n  return\
    \ \"NO\"\nend", "  local start, end\n  if interval1[1] < interval2[1] then\n \
    \   start = interval2[1]\n  else\n    start = interval1[1]\n  end\n  if interval1[2]\
    \ < interval2[2] then\n    end_ = interval1[2]\n  else\n    end_ = interval2[2]\n\
    \  end\n  if start > end_ then\n    return \"NO\"\n  end\n  local len = end_ -\
    \ start + 1\n  if len < 3 then\n    return \"YES\"\n  end\n  if len % 2 == 0 then\n\
    \    return \"NO\"\n  end\n  for i = 3, math.floor(math.sqrt(len)) do\n    if\
    \ len % i == 0 then\n      return \"NO\"\n    end\n  end\n  return \"YES\"\nend",
  "\tlocal start = math.max(interval1[1], interval2[1])\n\tlocal finish = math.min(interval1[2],\
    \ interval2[2])\n\tif start > finish then\n\t\treturn 0\n\tend\n\treturn finish\
    \ - start + 1\nend", "\tlocal i1, i2 = interval1, interval2\n\tif i1[1] > i2[1]\
    \ then i1, i2 = i2, i1 end\n\tif i1[2] < i2[1] then return \"NO\" end\n\tif i1[2]\
    \ == i2[1] then return \"NO\" end\n\tif i1[2] >= i2[2] then return prime(i2[2]\
    \ - i2[1]) end\n\treturn prime(i1[2] - i2[1])\nend", "    local i1s, i1e = interval1[1],\
    \ interval1[2]\n    local i2s, i2e = interval2[1], interval2[2]\n    if i1e <\
    \ i2s or i2e < i1s then\n        return \"NO\"\n    end\n    local range = {}\n\
    \    for i = i1s, i1e do\n        range[i] = true\n    end\n    for i = i2s, i2e\
    \ do\n        range[i] = true\n    end\n    local len = 0\n    for i in pairs(range)\
    \ do\n        len = len + 1\n    end\n    local divs = {}\n    for i = 2, len\
    \ do\n        if len % i == 0 then\n            divs[i] = true\n        end\n\
    \    end\n    if divs[2] then\n        return \"NO\"\n    end\n    for i in pairs(divs)\
    \ do\n        return \"NO\"\n    end\n    return \"YES\"\nend", "  local start1,\
    \ end1 = unpack(interval1)\n  local start2, end2 = unpack(interval2)\n  local\
    \ start = math.max(start1, start2)\n  local stop = math.min(end1, end2)\n  if\
    \ start <= stop then\n    local len = stop - start + 1\n    if len > 1 then\n\
    \      local ans = true\n      for i = 2, len do\n        if len % i == 0 then\n\
    \          ans = false\n          break\n        end\n      end\n      return\
    \ ans and \"YES\" or \"NO\"\n    end\n  end\n  return \"NO\"\nend", "  local function\
    \ isPrime(num)\n    local primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    for _, v in ipairs(primes)\
    \ do\n      if num == v then\n        return true\n      end\n    end\n    return\
    \ false\n  end\n  local start = math.max(interval1[1], interval2[1])\n  local\
    \ finish = math.min(interval1[2], interval2[2])\n  local len = finish - start\
    \ + 1\n  if start > finish then\n    return \"NO\"\n  end\n  if isPrime(len) then\n\
    \    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "    local start1,\
    \ end1 = interval1[1], interval1[2]\n    local start2, end2 = interval2[1], interval2[2]\n\
    \    local start, end = math.max(start1, start2), math.min(end1, end2)\n    local\
    \ len = end - start + 1\n    if len < 1 then\n        return \"NO\"\n    end\n\
    \    if len == 1 then\n        return \"YES\"\n    end\n    for i = 2, math.sqrt(len)\
    \ do\n        if len % i == 0 then\n            return \"NO\"\n        end\n \
    \   end\n    return \"YES\"\nend", "  --find the smallest start value\n  local\
    \ start = math.max(interval1[1], interval2[1])\n  --find the largest end value\n\
    \  local end = math.min(interval1[2], interval2[2])\n  --check if start is the\
    \ same as end, if so, return NO\n  if start == end then\n    return \"NO\"\n \
    \ end\n  --check to see if the difference is prime\n  return (isPrime(end - start))\
    \ and \"YES\" or \"NO\"\nend", "    local start1, end1 = interval1[1], interval1[2]\n\
    \    local start2, end2 = interval2[1], interval2[2]\n    local points = {}\n\
    \    for _, point in ipairs({start1, end1, start2, end2}) do\n        if not points[point]\
    \ then\n            points[point] = true\n        end\n    end\n    local pointsAsArray\
    \ = {}\n    for point, _ in pairs(points) do\n        table.insert(pointsAsArray,\
    \ point)\n    end\n    table.sort(pointsAsArray)\n    local prevPoint, nextPoint\n\
    \    for i, point in ipairs(pointsAsArray) do\n        if i == 1 then\n      \
    \      prevPoint = point\n        elseif i == #pointsAsArray then\n          \
    \  nextPoint = point\n        else\n            local start, end = prevPoint,\
    \ point\n            if start2 <= start and end2 >= end then\n               \
    \ local length = end - start\n                if length > 1 then\n           \
    \         for i = 2, length do\n                        if length % i == 0 then\n\
    \                            return \"NO\"\n                        end\n    \
    \                end\n                    return \"YES\"\n                else\n\
    \                    return \"NO\"\n                end\n            end\n   \
    \         prevPoint = point\n        end\n    end\n    return \"NO\"\nend", " \
    \ local start, end = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\n  if start > end then return \"NO\" end\n  local len = end -\
    \ start + 1\n  for i = 2, math.floor(math.sqrt(len)) do\n    if len % i == 0 then\
    \ return \"NO\" end\n  end\n  return \"YES\"\nend", "  local arr = {start = math.max(interval1.start,\
    \ interval2.start), end = math.min(interval1.end, interval2.end)}\n  if arr.start\
    \ > arr.end then\n    return 'NO'\n  end\n  return isPrime(arr.end - arr.start\
    \ + 1) and 'YES' or 'NO'\nend", "  local s,e = math.max(interval1[1], interval2[1]),\
    \ math.min(interval1[2], interval2[2])\n  if s > e then return \"NO\" end\n  return\
    \ (e-s == 1) and \"YES\" or \"NO\"\nend", "    local function start(interval)\n\
    \        return interval[1]\n    end\n    local function endd(interval)\n    \
    \    return interval[2]\n    end\n    local interStart = math.max(start(interval1),\
    \ start(interval2))\n    local interEnd = math.min(endd(interval1), endd(interval2))\n\
    \    if interStart > interEnd then\n        return \"NO\"\n    end\n    local\
    \ interLen = interEnd - interStart + 1\n    if interLen == 1 then\n        return\
    \ \"NO\"\n    end\n    for i = 2, interLen - 1 do\n        if interLen % i ==\
    \ 0 then\n            return \"NO\"\n        end\n    end\n    return \"YES\"\n\
    end", "    local int1 = {start = interval1[1], end = interval1[2]}\n    local\
    \ int2 = {start = interval2[1], end = interval2[2]}\n    local a = {}\n    local\
    \ b = {}\n    if int1.start < int2.start then\n        a.start = int2.start\n\
    \        a.end = int1.end\n        b.start = int1.start\n        b.end = int2.end\n\
    \    else\n        a.start = int1.start\n        a.end = int2.end\n        b.start\
    \ = int2.start\n        b.end = int1.end\n    end\n    if a.start > a.end then\n\
    \        return \"NO\"\n    end\n    local val = a.end - a.start + 1\n    for\
    \ i = 2, val do\n        if val % i == 0 then\n            return \"NO\"\n   \
    \     end\n    end\n    return \"YES\"\nend", "    local a, b = interval1[1],\
    \ interval1[2]\n    local c, d = interval2[1], interval2[2]\n    local p, q =\
    \ math.max(a, c), math.min(b, d)\n    if p > q then return 'NO' end\n    return\
    \ not (q - p) % 2 and 'YES' or 'NO'\nend", "    local interval3 = {}\n    if interval1[1]\
    \ <= interval2[1] then\n        interval3[1] = interval2[1]\n    else\n      \
    \  interval3[1] = interval1[1]\n    end\n    if interval1[2] >= interval2[2] then\n\
    \        interval3[2] = interval2[2]\n    else\n        interval3[2] = interval1[2]\n\
    \    end\n    if interval3[1] > interval3[2] then\n        return \"NO\"\n   \
    \ end\n    local len = math.abs(interval3[1] - interval3[2])\n    if len <= 1\
    \ then\n        return \"NO\"\n    end\n    local  c = 0\n    for i = 2, len do\n\
    \        if len % i == 0 then\n            c = c + 1\n        end\n    end\n \
    \   if c == 0 then\n        return \"YES\"\n    else\n        return \"NO\"\n\
    \    end\nend", "    --[[ \n        The length of the intersection can be determined\
    \ by \n        the minimum of interval1[2] and interval2[2] minus\n        the\
    \ maximum of interval1[1] and interval2[1]. \n        If the length is less than\
    \ 0 then the intervals do not intersect.\n    ]]--\n    local length = math.min(interval1[2],\
    \ interval2[2]) - math.max(interval1[1], interval2[1])\n    if length < 0 then\n\
    \        return \"NO\"\n    end\n    --[[\n        Check if length is a prime\
    \ number.\n        If a number has a factor between 2 and length^0.5 then it is\
    \ not prime.\n    ]]--\n    for i = 2, math.floor(math.sqrt(length)) do\n    \
    \    if length % i == 0 then\n            return \"NO\"\n        end\n    end\n\
    \    return \"YES\"\nend", "    local start = math.max(interval1[1], interval2[1])\n\
    \    local end_ = math.min(interval1[2], interval2[2])\n    local length = end_\
    \ - start + 1\n    if length <= 0 then\n        return 'NO'\n    end\n    if length\
    \ == 1 then\n        return 'YES'\n    end\n    if length % 2 == 0 then\n    \
    \    return 'NO'\n    end\n    for i = 3, math.floor(math.sqrt(length)) do\n \
    \       if length % i == 0 then\n            return 'NO'\n        end\n    end\n\
    \    return 'YES'\nend", "  if (math.max(interval1[1], interval2[1]) > math.min(interval1[2],\
    \ interval2[2])) then\n    return \"NO\"\n  end\n  local l = math.min(interval1[2],\
    \ interval2[2]) - math.max(interval1[1], interval2[1]) + 1\n  if (l == 1) then\n\
    \    return \"NO\"\n  end\n  local prim = true\n  for i = 2, l - 1 do\n    if\
    \ (l % i == 0) then\n      prim = false\n      break\n    end\n  end\n  if (prim)\
    \ then\n    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "    if interval1[1]\
    \ > interval2[2] or interval2[1] > interval1[2] then\n        return false\n \
    \   end\n    local max_start = math.max(interval1[1], interval2[1])\n    local\
    \ min_end = math.min(interval1[2], interval2[2])\n    local result = min_end -\
    \ max_start + 1\n    if result == 1 then\n        return false\n    end\n    if\
    \ result < 5 then\n        return true\n    end\n    if result % 2 == 0 or result\
    \ % 3 == 0 then\n        return false\n    end\n    local i = 5\n    while i *\
    \ i <= result do\n        if result % i == 0 or result % (i + 2) == 0 then\n \
    \           return false\n        end\n        i = i + 6\n    end\n    return\
    \ true\nend", "\tlocal max1, min1 = math.max(interval1[1], interval2[1]), math.min(interval1[2],\
    \ interval2[2])\n\tif min1 < max1 then\n\t\treturn 'NO'\n\tend\n\tlocal interval\
    \ = {min1, max1}\n\tlocal len = interval[2] - interval[1] + 1\n\tif len < 2 then\n\
    \t\treturn 'NO'\n\tend\n\tlocal isPrime = true\n\tfor i = 2, math.sqrt(len) do\n\
    \t\tif len % i == 0 then\n\t\t\tisPrime = false\n\t\t\tbreak\n\t\tend\n\tend\n\
    \treturn isPrime and 'YES' or 'NO'\nend", "    local x1, y1 = interval1[1], interval1[2]\n\
    \    local x2, y2 = interval2[1], interval2[2]\n    local a, b\n    if x1 <= x2\
    \ then\n        a = x2\n    else\n        a = x1\n    end\n    if y1 <= y2 then\n\
    \        b = y1\n    else\n        b = y2\n    end\n    if a <= b then\n     \
    \   return {a, b}\n    else\n        return nil\n    end\nend", "  if interval1[1]\
    \ > interval2[2] or interval2[1] > interval1[2] then\n    return \"NO\"\n  end\n\
    \  local start = math.max(interval1[1], interval2[1])\n  local stop = math.min(interval1[2],\
    \ interval2[2])\n  local len = stop - start + 1\n  if len == 1 then\n    return\
    \ \"NO\"\n  end\n  for i = 2, math.sqrt(len) do\n    if len % i == 0 then\n  \
    \    return \"NO\"\n    end\n  end\n  return \"YES\"\nend", "    if interval1[1]\
    \ <= interval2[2] and interval2[1] <= interval1[2] then\n        local intersection\
    \ = {interval1[1], interval1[2]}\n        if interval1[1] < interval2[1] then\n\
    \            intersection[1] = interval2[1]\n        end\n        if interval1[2]\
    \ > interval2[2] then\n            intersection[2] = interval2[2]\n        end\n\
    \        local num = intersection[2] - intersection[1] + 1\n        if num <=\
    \ 1 then\n            return \"NO\"\n        end\n        for i = 2, math.sqrt(num)\
    \ do\n            if num % i == 0 then\n                return \"NO\"\n      \
    \      end\n        end\n        return \"YES\"\n    end\n    return \"NO\"\n\
    end", "    local start = math.max(interval1[1], interval2[1])\n    local end_\
    \ = math.min(interval1[2], interval2[2])\n    if start > end_ then return \"NO\"\
    \ end\n    local len = end_ - start + 1\n    if len <= 1 then return \"NO\" end\n\
    \    if len <= 3 then return \"YES\" end\n    if len % 2 == 0 then return \"NO\"\
    \ end\n    for i = 3, math.sqrt(len), 2 do\n        if len % i == 0 then return\
    \ \"NO\" end\n    end\n    return \"YES\"\nend", "  local start = math.max(interval1[1],\
    \ interval2[1])\n  local finish = math.min(interval1[2], interval2[2])\n  if start\
    \ > finish then return 'NO' end\n  return (function(n)\n    local isPrime = false\n\
    \    for i = 2, n - 1 do\n      if n % i == 0 then return 'NO' end\n    end\n\
    \    return 'YES'\n  end)(finish - start + 1)\nend", "    local t = {}\n    t[#t+1]\
    \ = interval1[1]\n    t[#t+1] = interval1[2]\n    t[#t+1] = interval2[1]\n   \
    \ t[#t+1] = interval2[2]\n    table.sort(t)\n    if t[2] >= t[3] then\n      \
    \  local len = t[3] - t[2] + 1\n        local prime = true\n        for i = 2,\
    \ math.sqrt(len) do\n            if len % i == 0 then\n                prime =\
    \ false\n                break\n            end\n        end\n        if prime\
    \ then\n            return \"YES\"\n        else\n            return \"NO\"\n\
    \        end\n    else\n        return \"NO\"\n    end\nend", "  local start1,\
    \ end1 = interval1[1], interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n\
    \  local start, end = math.max(start1, start2), math.min(end1, end2)\n  if start\
    \ > end then return \"NO\" end\n  return start <= end and isPrime(end - start\
    \ + 1) and \"YES\" or \"NO\"\nend", "  local i, j = interval1[1], interval2[1]\n\
    \  local k, l = interval1[2], interval2[2]\n  if i > k then i, k = k, i end\n\
    \  if j > l then j, l = l, j end\n  if k < j or l < i then return \"NO\" end\n\
    \  local c = (j <= i and k <= l) and (k - i + 1) or (l - j + 1)\n  local primes\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97}\n  for _, p in ipairs(primes) do\n    if p == c then return\
    \ \"YES\" end\n  end\n  return \"NO\"\nend", "\tlocal x, y = interval1[1], interval1[2]\n\
    \tlocal x1, y1 = interval2[1], interval2[2]\n\tlocal a, b = math.max(x, x1), math.min(y,\
    \ y1)\n\tif a <= b then\n\t\tlocal length = b - a + 1\n\t\tlocal primes = {2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97}\n\t\tfor _, n in ipairs(primes) do\n\t\t\tif n == length then\n\
    \t\t\t\treturn \"YES\"\n\t\t\tend\n\t\tend\n\t\treturn \"NO\"\n\tend\n\treturn\
    \ \"NO\"\nend", "    local i1 = interval1[1]\n    local i2 = interval1[2]\n  \
    \  local j1 = interval2[1]\n    local j2 = interval2[2]\n    if (j1 > i2) or (j2\
    \ < i1) then\n        return \"NO\"\n    end\n    local start = math.max(i1, j1)\n\
    \    local stop = math.min(i2, j2)\n    local diff = stop - start + 1\n    if\
    \ diff == 1 then\n        return \"NO\"\n    end\n    local isPrime = true\n \
    \   for i = 2, math.floor(math.sqrt(diff)) do\n        if diff % i == 0 then\n\
    \            isPrime = false\n            break\n        end\n    end\n    if\
    \ isPrime then\n        return \"YES\"\n    else\n        return \"NO\"\n    end\n\
    end", "    local start = math.max(interval1[1], interval2[1])\n    local finish\
    \ = math.min(interval1[2], interval2[2])\n    if start <= finish then\n      \
    \  local interval = finish - start + 1\n        local is_prime = true\n      \
    \  for i = 2, interval-1 do\n            if interval % i == 0 then\n         \
    \       is_prime = false\n                break\n            end\n        end\n\
    \        if is_prime then\n            return \"YES\"\n        else\n        \
    \    return \"NO\"\n        end\n    else\n        return \"NO\"\n    end\nend",
  "  --local start, end = 0, 0\n  local start, end = math.max(interval1[1], interval2[1]),\
    \ math.min(interval1[2], interval2[2])\n  if start > end then return \"NO\" end\n\
    \  if start == end then return is_prime(start) and \"YES\" or \"NO\" end\n  local\
    \ result = 0\n  for i = start, end do\n    result = result + 1\n  end\n  return\
    \ is_prime(result) and \"YES\" or \"NO\"\nend", "    local a, b = interval1[1],\
    \ interval1[2]\n    local c, d = interval2[1], interval2[2]\n    local start,\
    \ finish = 0, 0\n    if b < c or d < a then\n        return \"NO\"\n    else\n\
    \        start = math.max(a, c)\n        finish = math.min(b, d)\n    end\n  \
    \  local intersec = finish - start + 1\n    if isPrime(intersec) then\n      \
    \  return \"YES\"\n    else\n        return \"NO\"\n    end\nend", "  local x1,\
    \ y1 = interval1[1], interval1[2]\n  local x2, y2 = interval2[1], interval2[2]\n\
    \  if y1 < x2 or y2 < x1 then\n    return \"NO\"\n  end\n  local l = math.min(y1,\
    \ y2) - math.max(x1, x2) + 1\n  return l % 2 == 0 and \"NO\" or \"YES\"\nend",
  "    local rangeStart = math.max(interval1[1], interval2[1])\n    local rangeEnd\
    \ = math.min(interval1[2], interval2[2])\n    if rangeStart > rangeEnd then\n\
    \        return \"NO\"\n    end\n    local primes = {2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}\n    local\
    \ rangeSize = rangeEnd - rangeStart + 1\n    for _, n in ipairs(primes) do\n \
    \       if n == rangeSize then\n            return \"YES\"\n        end\n    end\n\
    \    return \"NO\"\nend", "    --print('interval1',interval1[1],interval1[2],'interval2',interval2[1],interval2[2])\n\
    \    local min1 = math.min(interval1[1],interval1[2])\n    local max1 = math.max(interval1[1],interval1[2])\n\
    \    local min2 = math.min(interval2[1],interval2[2])\n    local max2 = math.max(interval2[1],interval2[2])\n\
    \    if (max1<min2) or (max2<min1) then return 'NO' end\n    local p1 = min1\n\
    \    local p2 = max1\n    if min2>min1 then p1 = min2 end\n    if max2<max1 then\
    \ p2 = max2 end\n    --print('p1',p1,'p2',p2)\n    local length = p2-p1+1\n  \
    \  if length<2 then return 'NO' end\n    for i=2,math.floor(math.sqrt(length))\
    \ do\n        if length%i==0 then return 'NO' end\n    end\n    return 'YES'\n\
    end", "\tlocal start = math.max(interval1[1], interval2[1])\n\tlocal stop = math.min(interval1[2],\
    \ interval2[2])\n\tif start >= stop then return \"NO\" end\n\tlocal sieve = {1,1}\n\
    \tfor i = 2,stop do\n\t\tsieve[i] = 0\n\tend\n\tfor i = 2,stop do\n\t\tif sieve[i]\
    \ == 0 then\n\t\t\tfor j = i + i,stop,i do\n\t\t\t\tsieve[j] = 1\n\t\t\tend\n\t\
    \tend\n\tend\n\tfor i = start,stop do\n\t\tif sieve[i] == 0 then\n\t\t\treturn\
    \ \"YES\"\n\t\tend\n\tend\n\treturn \"NO\"\nend", "  local start = math.max(interval1[1],\
    \ interval2[1])\n  local end = math.min(interval1[2], interval2[2])\n  if start\
    \ > end then return \"NO\" end\n  local l = end - start + 1\n  local pl = {2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97}\n  for _, p in ipairs(pl) do\n    if l == p then return \"YES\"\
    \ end\n  end\n  return \"NO\"\nend", "    local x1, y1 = interval1[1], interval1[2]\n\
    \    local x2, y2 = interval2[1], interval2[2]\n    local start, stop = math.max(x1,\
    \ x2), math.min(y1, y2)\n    if stop < start then\n        return \"NO\"\n   \
    \ end\n    local len = stop - start + 1\n    if len < 2 then\n        return \"\
    YES\"\n    end\n    for i = 2, math.sqrt(len) do\n        if len % i == 0 then\n\
    \            return \"NO\"\n        end\n    end\n    return \"YES\"\nend", " \
    \ local result = { }\n  if interval1[1] <= interval2[1] then\n    result[1] =\
    \ interval2[1]\n  else\n    result[1] = interval1[1]\n  end\n  if interval1[2]\
    \ <= interval2[2] then\n    result[2] = interval1[2]\n  else\n    result[2] =\
    \ interval2[2]\n  end\n  return result\nend", "  local start = math.max(interval1[1],\
    \ interval2[1])\n  local endd = math.min(interval1[2], interval2[2])\n  if start\
    \ > endd then return 'NO' end\n  local n = endd - start + 1\n  for i = 2, math.sqrt(n)\
    \ do\n    if n % i == 0 then return 'NO' end\n  end\n  return 'YES'\nend", " \
    \   local start = math.max(interval1[1], interval2[1])\n    local stop = math.min(interval1[2],\
    \ interval2[2])\n    if start <= stop then\n        local length = stop - start\
    \ + 1\n        local primes = {}\n        local cnt = 1\n        local n = 1\n\
    \        while n <= length do\n            if cnt == 1 then\n                table.insert(primes,\
    \ n)\n            else\n                local i = 1\n                while i <=\
    \ #primes do\n                    if n % primes[i] == 0 then\n               \
    \         break\n                    end\n                    i = i + 1\n    \
    \            end\n                if i > #primes then\n                    table.insert(primes,\
    \ n)\n                end\n            end\n            n = n + 1\n          \
    \  cnt = cnt + 1\n        end\n        if #primes > 0 then\n            for i\
    \ = 1, #primes do\n                if primes[i] == length then\n             \
    \       return \"YES\"\n                end\n            end\n        end\n  \
    \      return \"NO\"\n    end\n    return \"NO\"\nend", "  local function gcd(x,\
    \ y)\n    if x < y then x, y = y, x end\n    while y > 0 do\n      x, y = y, x\
    \ % y\n    end\n    return x\n  end\n  local function is_prime(n)\n    if n <=\
    \ 1 then return false end\n    if n <= 3 then return true end\n    if n % 2 ==\
    \ 0 or n % 3 == 0 then return false end\n    local i = 5\n    while i * i <= n\
    \ do\n      if n % i == 0 or n % (i + 2) == 0 then return false end\n      i =\
    \ i + 6\n    end\n    return true\n  end\n  local s1, e1 = table.unpack(interval1)\n\
    \  local s2, e2 = table.unpack(interval2)\n  local a = gcd(e1 - s1 + 1, e2 - s2\
    \ + 1)\n  local b = gcd(e1 - s1 + 1, s2 - e1)\n  local c = gcd(e1 - s1 + 1, s1\
    \ - e2)\n  local d = gcd(e2 - s2 + 1, s2 - e1)\n  local e = gcd(e2 - s2 + 1, s1\
    \ - e2)\n  local f = gcd(s2 - e1, s1 - e2)\n  local x, y = math.min(a, b, c, d,\
    \ e, f), math.max(a, b, c, d, e, f)\n  if x < y then return 'NO' end\n  return\
    \ is_prime(x) and 'YES' or 'NO'\nend\nassert(intersection({1, 3}, {2, 4}) == 'NO')\n\
    assert(intersection({1, 3}, {2, 3}) == 'YES')\nassert(intersection({1, 1}, {1,\
    \ 1}) == 'YES')\nassert(intersection({1, 1}, {2, 2}) == 'NO')\nassert(intersection({1,\
    \ 1}, {2, 3}) == 'NO')\nassert(intersection({1, 2}, {3, 4}) == 'NO')\nassert(inter",
  "    local x, y = math.max(interval1[1], interval2[1]), math.min(interval1[2], interval2[2])\n\
    \    if x <= y then\n        local is_prime = true\n        for d = 2, math.sqrt(y\
    \ - x) do\n            if (y - x) % d == 0 then\n                is_prime = false\n\
    \                break\n            end\n        end\n        return is_prime\
    \ and \"YES\" or \"NO\"\n    else\n        return \"NO\"\n    end\nend", "  --\
    \ a = less than, or equal to.\n  -- b = greater than, or equal to.\n  local a,\
    \ b = interval1[1], interval1[2]\n  local c, d = interval2[1], interval2[2]\n\
    \  local start, finish\n  if a <= c and b >= c then\n    start = c\n  elseif a\
    \ <= d and b >= d then\n    start = d\n  elseif c <= a and d >= a then\n    start\
    \ = a\n  elseif c <= b and d >= b then\n    start = b\n  else\n    return \"NO\"\
    \n  end\n  if a <= c and b >= c then\n    finish = b\n  elseif a <= d and b >=\
    \ d then\n    finish = d\n  elseif c <= a and d >= a then\n    finish = a\n  elseif\
    \ c <= b and d >= b then\n    finish = b\n  else\n    return \"NO\"\n  end\n \
    \ local function check(n)\n    if n < 2 then\n      return false\n    end\n  \
    \  for i = 2, math.floor(math.sqrt(n)) do\n      if n % i == 0 then\n        return\
    \ false\n      end\n    end\n    return true\n  end\n  return finish - start +\
    \ 1 > 1 and check(finish - start + 1) and \"YES\" or \"NO\"\nend", "    local\
    \ s1, e1 = interval1[1], interval1[2]\n    local s2, e2 = interval2[1], interval2[2]\n\
    \    if s1 > e2 or s2 > e1 then return \"NO\" end", "    local a, b = interval1[1],\
    \ interval1[2]\n    local c, d = interval2[1], interval2[2]\n    if a > b then\
    \ a, b = b, a end\n    if c > d then c, d = d, c end\n    local m, n = a - c,\
    \ b - d\n    if m <= 0 and n >= 0 then\n        if b - a < 2 then return 'NO'\
    \ end\n        return {b - a}\n    elseif m >= 0 and n <= 0 then\n        if d\
    \ - c < 2 then return 'NO' end\n        return {d - c}\n    elseif m > 0 and n\
    \ < 0 then\n        return {b - c, d - a}\n    else\n        return 'NO'\n   \
    \ end\nend", "    local x, y = interval1[1], interval1[2]\n    local m, n = interval2[1],\
    \ interval2[2]\n    if x > n or m > y then return \"NO\" end\n    if m > x then\
    \ x = m end\n    if n < y then y = n end\n    local length = y - x + 1\n    if\
    \ length < 2 then return \"NO\" end\n    for i = 2, math.sqrt(length) do\n   \
    \     if length % i == 0 then return \"NO\" end\n    end\n    return \"YES\"\n\
    end", "  local a, b = interval1[1], interval1[2]\n  local c, d = interval2[1],\
    \ interval2[2]\n  if a > b then a, b = b, a end\n  if c > d then c, d = d, c end\n\
    \  if b < c or d < a then return \"NO\" end\n  local e, f = math.max(a, c), math.min(b,\
    \ d)\n  local i = f - e + 1\n  if i < 2 then return \"NO\" end\n  if i == 2 then\
    \ return \"YES\" end\n  for j = 2, math.floor(math.sqrt(i)) do\n    if i % j ==\
    \ 0 then return \"NO\" end\n  end\n  return \"YES\"\nend", "  local function isPrime(n)\n\
    \    for i = 2, math.floor(math.sqrt(n)) do\n      if n % i == 0 then\n      \
    \  return false\n      end\n    end\n    return true\n  end\n  local function\
    \ gcd(a, b)\n    while b ~= 0 do\n      a, b = b, a % b\n    end\n    return a\n\
    \  end\n  local function intersectionLength(start1, end1, start2, end2)\n    local\
    \ maxStart = math.max(start1, start2)\n    local minEnd = math.min(end1, end2)\n\
    \    if maxStart <= minEnd then\n      return minEnd - maxStart + 1\n    else\n\
    \      return 0\n    end\n  end\n  local i1Start, i1End = table.unpack(interval1)\n\
    \  local i2Start, i2End = table.unpack(interval2)\n  local intersectionLength\
    \ = intersectionLength(i1Start, i1End, i2Start, i2End)\n  if intersectionLength\
    \ == 0 then\n    return \"NO\"\n  else\n    return isPrime(intersectionLength)\
    \ and \"YES\" or \"NO\"\n  end\nend", "    local a1, a2 = interval1[1], interval1[2]\n\
    \    local b1, b2 = interval2[1], interval2[2]\n    local first = math.max(a1,\
    \ b1)\n    local last = math.min(a2, b2)\n    if first > last then return \"NO\"\
    \ end\n    if first == last then return \"YES\" end\n    return math.isprime(last\
    \ - first + 1) and \"YES\" or \"NO\"\nend", "\tlocal result = {start = 0, end\
    \ = 0}\n\tresult.start = math.max(interval1.start, interval2.start)\n\tresult.end\
    \ = math.min(interval1.end, interval2.end)\n\treturn result\nend", "    local\
    \ interval = {}\n    interval.start = math.max(interval1.start, interval2.start)\n\
    \    interval.end = math.min(interval1.end, interval2.end)\n    if interval.start\
    \ > interval.end then\n        return \"NO\"\n    end\n    local len = interval.end\
    \ - interval.start + 1\n    for i = 2, math.sqrt(len) do\n        if len % i ==\
    \ 0 then\n            return \"NO\"\n        end\n    end\n    return \"YES\"\n\
    end\nprint(intersection({start = 1, end = 3}, {start = 2, end = 4}))\nprint(intersection({start\
    \ = 1, end = 10}, {start = 8, end = 12}))\nprint(intersection({start = -10, end\
    \ = 10}, {start = -100, end = 100}))", "  local start,finish = interval1[1],interval1[2]\n\
    \  if start > interval2[1] then\n    start = interval2[1]\n  end\n  if finish\
    \ < interval2[2] then\n    finish = interval2[2]\n  end\n  if start > finish then\n\
    \    return false\n  end\n  return start,finish\nend", "  --[[\n  (1, 3), (2,\
    \ 4) => (2, 3) => NO\n  (1, 2), (3, 4) => (0, 0) => NO\n  (1, 6), (2, 3) => (2,\
    \ 3) => YES\n  (2, 3), (2, 4) => (2, 3) => YES\n  (1, 2), (4, 5) => (0, 0) =>\
    \ NO\n  (1, 2), (1, 4) => (1, 2) => YES\n  (2, 3), (3, 4) => (0, 0) => NO\n  (1,\
    \ 2), (1, 2) => (1, 2) => YES\n  (2, 3), (1, 2) => (0, 0) => NO\n  (1, 2), (4,\
    \ 5) => (0, 0) => NO\n  (1, 3), (2, 3) => (2, 3) => YES\n  (1, 3), (1, 4) => (1,\
    \ 3) => YES\n  (3, 4), (1, 2) => (0, 0) => NO\n  (1, 2), (1, 2) => (1, 2) => YES\n\
    \  (2, 3), (2, 3) => (2, 3) => YES\n  (1, 2), (4, 5) => (0, 0) => NO\n  (1, 2),\
    \ (1, 2) => (1, 2) => YES\n  (1, 2), (1, 2) => (1, 2) => YES\n  (2, 3), (3, 4)\
    \ => (0, 0) => NO\n  (1, 2), (1, 2) => (1, 2) => YES\n  (3, 4), (1, 2) => (0,\
    \ 0) => NO\n  (1, 2), (4, 5) => (0, 0) => NO\n  (1, 2), (4, 5) => (0, 0) => NO\n\
    \  (1, 2), (4, 5) => (0, 0) => NO\n  (1, 2), (4, 5) => (0, 0) => NO\n  (1, 2),\
    \ (", "  local a, b = interval1[1], interval1[2]\n  local c, d = interval2[1],\
    \ interval2[2]\n  if a > b then a, b = b, a end\n  if c > d then c, d = d, c end\n\
    \  if a > d or c > b then return \"NO\" end\n  local v = math.min(b, d) - math.max(a,\
    \ c) + 1\n  if v < 2 then return \"NO\" end\n  local result = \"NO\"\n  for i\
    \ = 2, math.sqrt(v) do\n    if v % i == 0 then return result end\n  end\n  return\
    \ \"YES\"\nend", "\tlocal function isPrime(n)\n\t\tfor i = 2, n - 1 do\n\t\t\t\
    if n % i == 0 then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\t\treturn true\n\
    \tend\n\tlocal start1, end1 = table.unpack(interval1)\n\tlocal start2, end2 =\
    \ table.unpack(interval2)\n\tlocal start = math.max(start1, start2)\n\tlocal finish\
    \ = math.min(end1, end2)\n\tlocal length = math.max(0, finish - start + 1)\n\t\
    if length == 0 then\n\t\treturn \"NO\"\n\telse\n\t\treturn isPrime(length) and\
    \ \"YES\" or \"NO\"\n\tend\nend\nassert(intersection({1, 3}, {2, 4}) == \"NO\"\
    )\nassert(intersection({5, 5}, {5, 5}) == \"YES\")\nassert(intersection({1, 3},\
    \ {3, 4}) == \"NO\")\nassert(intersection({5, 6}, {6, 8}) == \"NO\")\nassert(intersection({3,\
    \ 5}, {1, 8}) == \"YES\")\nassert(intersection({3, 8}, {3, 8}) == \"YES\")\nassert(intersection({2,\
    \ 3}, {1, 1}) == \"NO\")\nassert(intersection({1, 10}, {3, 7}) == \"YES\")\nassert(intersection({1,\
    \ 10}, {3, 11}) == \"NO\")\nassert(intersection({1, 2}, {1, 2}) == \"YES\")\n\
    assert(intersection({1, 2}, {1, 5}) == \"YES\")\nassert(intersection({5, 7}, {4,\
    \ 4}) == \"NO\")\nassert(intersection({4, 5}, {5, 7}) == \"YES\")\nassert(intersection({5,\
    \ 6}, {6, 8}) == \"NO\")\nassert(intersection({5, 6}, {3, 6}) == \"YES\")\nassert(intersection({1,\
    \ 5}, {5, 9}) == \"YES\")\nassert(intersection({5, 6}, {4, 8}) == \"YES\")\nassert(intersection({4,\
    \ 5}, {", "    local function len(interval)\n        return interval[2] - interval[1]\
    \ + 1\n    end\n    local function is_prime(number)\n        if number <= 1 then\
    \ return false end\n        if number == 2 then return true end\n        if number\
    \ % 2 == 0 then return false end\n        for i = 3, math.sqrt(number), 2 do\n\
    \            if number % i == 0 then return false end\n        end\n        return\
    \ true\n    end\n    local a1, b1 = interval1[1], interval1[2]\n    local a2,\
    \ b2 = interval2[1], interval2[2]\n    if a1 > b1 then a1, b1 = b1, a1 end\n \
    \   if a2 > b2 then a2, b2 = b2, a2 end\n    if a1 > b2 or a2 > b1 then return\
    \ \"NO\" end\n    local c1, c2 = math.max(a1, a2), math.min(b1, b2)\n    local\
    \ interval = {c1, c2}\n    if is_prime(len(interval)) then return \"YES\" else\
    \ return \"NO\" end\nend", "    local start1, end1 = interval1[1], interval1[2]\n\
    \    local start2, end2 = interval2[1], interval2[2]\n    local start3, end3 =\
    \ math.max(start1, start2), math.min(end1, end2)\n    local length = end3 - start3\
    \ + 1\n    if start3 > end3 then\n        return \"NO\"\n    elseif start3 <=\
    \ end3 then\n        if length <= 2 then\n            return \"NO\"\n        else\n\
    \            for i = 2, math.floor(math.sqrt(length)) do\n                if length\
    \ % i == 0 then\n                    return \"NO\"\n                end\n    \
    \        end\n            return \"YES\"\n        end\n    end\nend", "    local\
    \ s1, e1 = interval1[1], interval1[2]\n    local s2, e2 = interval2[1], interval2[2]\n\
    \    if e1 < s2 or e2 < s1 then return 'NO' end\n    local start = math.max(s1,\
    \ s2)\n    local finish = math.min(e1, e2)\n    local length = finish - start\
    \ + 1\n    if length <= 1 then return 'NO' end\n    for i = 2, math.sqrt(length)\
    \ do\n        if length % i == 0 then return 'NO' end\n    end\n    return 'YES'\n\
    end", "    local t1 = interval1[1]\n    local t2 = interval1[2]\n    local t3\
    \ = interval2[1]\n    local t4 = interval2[2]\n    if t2 < t3 or t1 > t4 then\n\
    \        return false\n    end\n    local a = math.max(t1, t3)\n    local b =\
    \ math.min(t2, t4)\n    local c = b - a + 1\n    if c < 2 then\n        return\
    \ false\n    end\n    for i = 2, math.sqrt(c) do\n        if c % i == 0 then\n\
    \            return false\n        end\n    end\n    return true\nend", "  local\
    \ a, b = interval1[1], interval1[2]\n  local c, d = interval2[1], interval2[2]\n\
    \  local x, y = math.max(a, c), math.min(b, d)\n  if x <= y then\n    local is_prime\
    \ = function(n)\n      if n <= 1 then return false end\n      for i = 2, math.sqrt(n)\
    \ do\n        if n % i == 0 then return false end\n      end\n      return true\n\
    \    end\n    return is_prime(y - x + 1) and \"YES\" or \"NO\"\n  end\n  return\
    \ \"NO\"\nend", "    local inter = {}\n    for k, v in pairs(interval1) do\n \
    \       if interval2[k] and interval2[k] == v then\n            inter[k] = v\n\
    \        end\n    end\n    if next(inter) then\n        return inter\n    end\n\
    end", "    local a1, a2 = interval1[1], interval1[2]\n    local b1, b2 = interval2[1],\
    \ interval2[2]\n    local mn, mx = math.max(a1, b1), math.min(a2, b2)\n    if\
    \ mn <= mx then\n        local n = mx - mn + 1\n        local r = math.sqrt(n)\n\
    \        for i = 2, r do\n            if n % i == 0 then\n                return\
    \ \"NO\"\n            end\n        end\n        return \"YES\"\n    end\n    return\
    \ \"NO\"\nend", "  local start = math.max(interval1[1], interval2[1])\n  local\
    \ finish = math.min(interval1[2], interval2[2])\n  local len = finish - start\
    \ + 1\n  if len < 0 then return \"NO\" end\n  if len == 1 then return \"YES\"\
    \ end\n  for i = 2, math.floor(math.sqrt(len)) do\n    if len % i == 0 then return\
    \ \"NO\" end\n  end\n  return \"YES\"\nend", "  local lower, upper\n  if interval1[1]\
    \ > interval2[1] then\n    lower = interval1[1]\n  else\n    lower = interval2[1]\n\
    \  end\n  if interval1[2] < interval2[2] then\n    upper = interval1[2]\n  else\n\
    \    upper = interval2[2]\n  end\n  if lower > upper then\n    return \"NO\"\n\
    \  end\n  local function isPrime(n)\n    if n == 1 then\n      return false\n\
    \    end\n    for i = 2, math.sqrt(n) do\n      if n % i == 0 then\n        return\
    \ false\n      end\n    end\n    return true\n  end\n  if isPrime(upper - lower\
    \ + 1) then\n    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "  if\
    \ interval1[1] > interval2[2] or interval2[1] > interval1[2] then\n    return\
    \ \"NO\"\n  end\n  local start = math.max(interval1[1], interval2[1])\n  local\
    \ finish = math.min(interval1[2], interval2[2])\n  local len = finish - start\
    \ + 1\n  local is_prime = true\n  for i = 2, math.floor(math.sqrt(len)) do\n \
    \   if len % i == 0 then\n      is_prime = false\n      break\n    end\n  end\n\
    \  if is_prime and len > 1 then\n    return \"YES\"\n  else\n    return \"NO\"\
    \n  end\nend", "  local rng1, rng2 = {}, {}\n  for i = interval1[1], interval1[2]\
    \ do rng1[i] = i end\n  for i = interval2[1], interval2[2] do rng2[i] = i end\n\
    \  local _intersect = function(t1, t2)\n    local result = {}\n    for k, v in\
    \ pairs(t1) do\n      if t2[k] then\n        result[k] = k\n      end\n    end\n\
    \    return result\n  end\n  local intersect = _intersect(rng1, rng2)\n  if next(intersect)\
    \ == nil then return \"NO\" end\n  local len = 0\n  for _ in pairs(intersect)\
    \ do len = len + 1 end\n  local fc = 2\n  while fc * fc <= len do\n    if len\
    \ % fc == 0 then return \"NO\" end\n    fc = fc + 1\n  end\n  return \"YES\"\n\
    end\n  -- \"NO\", \"(1, 3), (2, 4)\"\n  -- \"YES\", \"(1, 3), (3, 4)\"\n  -- \"\
    NO\", \"(1, 3), (2, 4)\"\n  -- \"NO\", \"(1, 2), (3, 4)\"\n  -- \"NO\", \"(1,\
    \ 2), (1, 1)\"\n  -- \"NO\", \"(1, 2), (2, 3)\"\n  -- \"NO\", \"(1, 2), (1, 4)\"\
    \n  -- \"NO\", \"(1, 2), (3, 4)\"\n  -- \"NO\", \"(1, 2), (2, 4)\"\n  -- \"NO\"\
    , \"(1, 2), (1, 3)\"\n  -- \"NO\", \"(1, 2), (2, 4)\"\n  -- \"NO\", \"(1, 2),\
    \ (1, 3)\"\n  -- \"NO\", \"(1, 2), (2, 3)\"\n  -- \"NO\", \"(1, 2), (1, 4)\"\n\
    \  -- \"NO\", \"(1, 2), (1, 3)\"\n  -- \"NO\", \"(1, 2), (2, 4)\"\n  -- \"NO\"\
    , \"(1, 2), (1, 3)\"\n  --", "    if interval1[1] > interval2[2] or interval2[1]\
    \ > interval1[2] then\n        return 'NO'\n    end\n    local start = math.max(interval1[1],\
    \ interval2[1])\n    local end_ = math.min(interval1[2], interval2[2])\n    local\
    \ length = end_ - start + 1\n    for i = 2, math.sqrt(length) do\n        if length\
    \ % i == 0 then\n            return 'NO'\n        end\n    end\n    return 'YES'\n\
    end", "  local a, b = interval1[1], interval1[2]\n  local c, d = interval2[1],\
    \ interval2[2]\n  if a > b then a, b = b, a end\n  if c > d then c, d = d, c end\n\
    \  if b < c or d < a then return \"NO\" end\n  if b == c or d == a then return\
    \ \"NO\" end\n  if b > d then b = d end\n  if a < c then a = c end\n  local len\
    \ = b - a + 1\n  if len < 2 then return \"NO\" end\n  for i = 2, math.sqrt(len)\
    \ do\n    if len % i == 0 then return \"NO\" end\n  end\n  return \"YES\"\nend",
  "    local x1, y1 = interval1[1], interval1[2]\n    local x2, y2 = interval2[1],\
    \ interval2[2]\n    local x = math.max(x1, x2)\n    local y = math.min(y1, y2)\n\
    \    if x <= y then\n        if not is_prime(y - x + 1) then\n            return\
    \ \"NO\"\n        end\n        return \"YES\"\n    end\n    return \"NO\"\nend",
  "  local start = math.max(interval1[1], interval2[1])\n  local ender = math.min(interval1[2],\
    \ interval2[2])\n  local n = ender - start + 1\n  if n > 0 then\n    return n\
    \ > 1 and n % 2 == 1 and n % 3 ~= 0 and n % 5 ~= 0 and n % 7 ~= 0 and \"YES\"\
    \ or \"NO\"\n  end\n  return \"NO\"\nend", "  if interval1[1] <= interval2[1]\
    \ then\n    local start = interval2[1]\n    local end   = interval1[2] < interval2[2]\
    \ and interval1[2] or interval2[2]\n    return {start, end}\n  else\n    local\
    \ start = interval1[1]\n    local end   = interval1[2] < interval2[2] and interval1[2]\
    \ or interval2[2]\n    return {start, end}\n  end\nend", "  local s, e = interval1[1],\
    \ interval1[2]\n  local s2, e2 = interval2[1], interval2[2]\n  if (s > e2) or\
    \ (s2 > e) then\n    return \"NO\"\n  end\n  s = math.max(s, s2)\n  e = math.min(e,\
    \ e2)\n  return is_prime(e - s + 1) and \"YES\" or \"NO\"\nend", "    local length\
    \ = math.abs(interval1[1] - interval2[1]) + 1\n    return length == 1 and \"NO\"\
    \ or (length == 2 and \"YES\" or \"NO\")\nend", "    local min = math.max(interval1[1],\
    \ interval2[1])\n    local max = math.min(interval1[2], interval2[2])\n    local\
    \ range = max - min + 1\n    if range > 0 then\n        for i = 2, math.floor(math.sqrt(range))\
    \ do\n            if range % i == 0 then\n                return \"NO\"\n    \
    \        end\n        end\n        return \"YES\"\n    end\n    return \"NO\"\n\
    end", "    local beg1, end1 = interval1[1], interval1[2]\n    local beg2, end2\
    \ = interval2[1], interval2[2]\n    local beg, end", "    local function is_prime(n)\n\
    \        if n == 1 then return false end\n        if n == 2 then return true end\n\
    \        if n % 2 == 0 then return false end\n        for i = 3, math.sqrt(n),\
    \ 2 do\n            if n % i == 0 then return false end\n        end\n       \
    \ return true\n    end\n    local function intersect(start1, end1, start2, end2)\n\
    \        return math.max(start1, start2), math.min(end1, end2)\n    end\n    local\
    \ function diff(start, end)\n        return end - start + 1\n    end\n    local\
    \ start1, end1 = unpack(interval1)\n    local start2, end2 = unpack(interval2)\n\
    \    local intersect_start, intersect_end = intersect(start1, end1, start2, end2)\n\
    \    if intersect_start > intersect_end then return \"NO\" end\n    return is_prime(diff(intersect_start,\
    \ intersect_end)) and \"YES\" or \"NO\"\nend", "    local A, B = interval1[1],\
    \ interval1[2]\n    local C, D = interval2[1], interval2[2]\n    if A > C then\n\
    \        A, B, C, D = C, D, A, B\n    end\n    local S = math.max(A, C)\n    local\
    \ E = math.min(B, D)\n    if S > E then\n        return \"NO\"\n    end\n    return\
    \ isPrime(E - S + 1) and \"YES\" or \"NO\"\nend", "    local sorted_intervals\
    \ = {}\n    table.insert(sorted_intervals, interval1)\n    table.insert(sorted_intervals,\
    \ interval2)\n    table.sort(sorted_intervals, function(a, b)\n        return\
    \ a[1] < b[1]\n    end)\n    local start = math.max(sorted_intervals[1][1], sorted_intervals[2][1])\n\
    \    local endd = math.min(sorted_intervals[1][2], sorted_intervals[2][2])\n \
    \   if start <= endd then\n        local result = endd - start + 1\n        if\
    \ result == 1 then\n            return \"NO\"\n        end\n        for i = 2,\
    \ math.floor(math.sqrt(result)) do\n            if result % i == 0 then\n    \
    \            return \"NO\"\n            end\n        end\n        return \"YES\"\
    \n    else\n        return \"NO\"\n    end\nend", "    local x, y = math.max(interval1[1],\
    \ interval2[1]), math.min(interval1[2], interval2[2])\n    local count = (x <=\
    \ y) and (y - x + 1) or 0\n    return count == 1 and 'NO' or (count == 2 and 'YES'\
    \ or (count > 2 and (count % 2 == 0 and 'NO' or (count % 3 == 0 and 'NO' or 'YES'))\
    \ or 'NO'))\nend", "  if interval1[1] > interval2[2] or interval2[1] > interval1[2]\
    \ then return \"NO\" end\n  local i1 = interval1[1]\n  local i2 = interval1[2]\n\
    \  local i3 = interval2[1]\n  local i4 = interval2[2]\n  local i = 0\n  if i1\
    \ < i3 then i = i3 else i = i1 end\n  local j = 0\n  if i2 < i4 then j = i2 else\
    \ j = i4 end\n  local max = math.abs(j - i) + 1\n  local primes = {2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97}\n  for k,v in ipairs(primes) do\n    if v == max then return \"YES\"\
    \ end\n  end\n  return \"NO\"\nend", "    local start_pos, end_pos = nil, nil\n\
    \    if interval1[1] <= interval2[1] then\n        start_pos = interval2[1]\n\
    \    else\n        start_pos = interval1[1]\n    end\n    if interval1[2] <= interval2[2]\
    \ then\n        end_pos = interval1[2]\n    else\n        end_pos = interval2[2]\n\
    \    end\n    if start_pos > end_pos then\n        return {false, \"NO\"}\n  \
    \  end\n    local len = end_pos - start_pos + 1\n    if len < 2 then\n       \
    \ return {false, \"NO\"}\n    end\n    local ok = true\n    for i = 2, len - 1\
    \ do\n        if len % i == 0 then\n            ok = false\n            break\n\
    \        end\n    end\n    if ok then\n        return {true, \"YES\"}\n    else\n\
    \        return {false, \"NO\"}\n    end\nend", "\tlocal L = {}\n\tfor n = 1,\
    \ #interval1 do\n\t\tL[#L + 1] = interval1[n]\n\tend\n\tfor n = 1, #interval2\
    \ do\n\t\tL[#L + 1] = interval2[n]\n\tend\n\ttable.sort(L)\n\treturn L[2], L[3]\n\
    end", "  local result = \"\"\n  local list = {}\n  local start1, end1 = interval1[1],\
    \ interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n  local start,\
    \ end\n  if start1 <= start2 then\n    start = start2\n  else\n    start = start1\n\
    \  end\n  if end1 >= end2 then\n    end = end2\n  else\n    end = end1\n  end\n\
    \  for i = start, end do\n    table.insert(list, i)\n  end\n  if #list > 0 then\n\
    \    for i = 2, #list do\n      if list[i] % list[1] == 0 then\n        result\
    \ = \"NO\"\n        break\n      else\n        result = \"YES\"\n      end\n \
    \   end\n  else\n    result = \"NO\"\n  end\n  return result\nend", "    local\
    \ x = interval1[1] > interval2[1] and interval1[1] or interval2[1]\n    local\
    \ y = interval1[2] < interval2[2] and interval1[2] or interval2[2]\n    local\
    \ len = y - x + 1\n    if len < 1 then\n        return \"NO\"\n    end\n    if\
    \ len == 1 then\n        return \"YES\"\n    end\n    local endx = math.sqrt(len)\n\
    \    for i = 2, endx do\n        if len % i == 0 then\n            return \"NO\"\
    \n        end\n    end\n    return \"YES\"\nend", "  local start1, end1 = interval1[1],\
    \ interval1[2]\n  local start2, end2 = interval2[1], interval2[2]\n  if (start1\
    \ > end2) or (start2 > end1) then\n    return 'NO'\n  end\n  local interval =\
    \ {start1, end1}\n  local prime = true\n  if start2 > start1 then\n    interval[1]\
    \ = start2\n  end\n  if end2 < end1 then\n    interval[2] = end2\n  end\n  local\
    \ len = interval[2] - interval[1] + 1\n  for d = 2, math.floor(math.sqrt(len))\
    \ do\n    if len % d == 0 then\n      prime = false\n      break\n    end\n  end\n\
    \  return prime and 'YES' or 'NO'\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
