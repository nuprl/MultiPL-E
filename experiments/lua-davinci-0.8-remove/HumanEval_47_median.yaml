name: HumanEval_47_median
language: lua
prompt: "-- Return median of elements in the list l.\nlocal function median(l)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = median\n\
  \    lu.assertEquals(candidate({3, 1, 2, 4, 5}), 3)\n    lu.assertEquals(candidate({-10,\
  \ 4, 6, 1000, 10, 20}), 8.0)\n    lu.assertEquals(candidate({5}), 5)\n    lu.assertEquals(candidate({6,\
  \ 5}), 5.5)\n    lu.assertEquals(candidate({8, 1, 3, 9, 9, 2, 7}), 7)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    table.sort(l)\n    if #l % 2 == 0 then\n        return (l[#l/2]\
    \ + l[#l/2+1]) / 2\n    else\n        return l[math.ceil(#l/2)]\n    end\nend",
  "  if #l < 1 then return 0 end\n  table.sort(l)\n  if #l %2 == 0 then return (l[#l/2]\
    \ + l[#l/2+1]) / 2 end\n  return l[math.ceil(#l/2)]\nend", "\tif l.count < 1 then\n\
    \t\treturn nil\n\tend\n\tlocal n = l.count\n\tlocal n2 = floor(n/2)\n\tlocal n21\
    \ = n2 + 1\n\tif n % 2 == 0 then\n\t\treturn (l[n2] + l[n21]) / 2\n\telse\n\t\t\
    return l[n21]\n\tend\nend", "  local c = {}\n  for i,v in ipairs(l) do\n    if\
    \ type(v) == \"number\" then\n      c[#c+1] = v\n    end\n  end\n  table.sort(c)\n\
    \  return c[math.ceil(#c/2)]\nend", "    local x = median_selec(l, 1, #l)\n  \
    \  if #l % 2 == 0 then\n        return (x + median_selec(l, 1, #l - 1)) / 2\n\
    \    else\n        return x\n    end\nend", "    local n = #l\n    if n == 0 then\n\
    \        return nil\n    elseif n % 2 == 0 then\n        return (l[n/2] + l[n/2+1])\
    \ / 2\n    else\n        return l[(n+1)/2]\n    end\nend", "  if #l == 0 then\
    \ return 0 end\n  table.sort(l)\n  local half = math.floor(#l / 2)\n  if #l %\
    \ 2 == 0 then\n    return (l[half] + l[half + 1]) / 2\n  else\n    return l[half\
    \ + 1]\n  end\nend", "\tlocal tmp = {}\n\tfor _, v in ipairs(l) do\n\t\ttmp[#tmp+1]\
    \ = v\n\tend\n\ttable.sort(tmp)\n\tlocal n = #tmp\n\tif math.fmod(n, 2) == 0 then\n\
    \t\treturn (tmp[n/2] + tmp[n/2+1]) / 2\n\telse\n\t\treturn tmp[math.ceil(n/2)]\n\
    \tend\nend", "\tlocal n = #l\n\tif n == 0 then\n\t\treturn 0\n\tend\n\ttable.sort(l)\n\
    \tif n % 2 == 0 then\n\t\treturn (l[n/2] + l[n/2+1]) / 2\n\telse\n\t\treturn l[math.ceil(n/2)]\n\
    \tend\nend", "    local n = #l\n    if n == 0 then\n        return 0\n    end\n\
    \    local l2 = {}\n    for i = 1, n do\n        l2[i] = l[i]\n    end\n    table.sort(l2)\n\
    \    local m = math.floor(n / 2)\n    if n % 2 == 0 then\n        return (l2[m]\
    \ + l2[m + 1]) / 2\n    else\n        return l2[m + 1]\n    end\nend", "  local\
    \ m = {}\n  for _,v in ipairs(l) do\n    m[#m+1] = v\n  end\n  table.sort(m)\n\
    \  local i = #m/2\n  if math.floor(i) == i then\n    return (m[i] + m[i+1])/2\n\
    \  else\n    return m[math.ceil(i)]\n  end\nend", "  if #l == 0 then return 0\
    \ end\n  local ll = clone(l)\n  table.sort(ll)\n  if #ll % 2 == 0 then\n    return\
    \ (ll[#ll/2] + ll[#ll/2+1]) / 2\n  else\n    return ll[math.ceil(#ll/2)]\n  end\n\
    end", "\tlocal med = 0\n\tlocal n = table.getn(l)\n\tlocal k = math.floor(n/2)\n\
    \ttable.sort(l)\n\tif n%2 == 0 then\n\t\tmed = (l[k] + l[k+1])/2\n\telse\n\t\t\
    med = l[k+1]\n\tend\n\treturn med\nend", "  if type(l) ~= 'table' then\n    error('Input\
    \ must be a table.')\n  end\n  local temp={}\n  for _,v in ipairs(l) do\n    table.insert(temp,\
    \ v)\n  end\n  table.sort(temp)\n  if math.fmod(#temp,2) == 0 then\n    return\
    \ (temp[#temp/2] + temp[(#temp/2)+1]) / 2\n  else\n    return temp[math.ceil(#temp/2)]\n\
    \  end\nend", "\tlocal m = #l\n\tlocal i = 1\n\twhile m > 1 do\n\t\tlocal s =\
    \ i + m - 1\n\t\tlocal t = {}\n\t\tfor j = i, s do\n\t\t\tt[#t + 1] = l[j]\n\t\
    \tend\n\t\ttable.sort(t)\n\t\tif m % 2 == 0 then\n\t\t\treturn 0.5 * (t[m / 2]\
    \ + t[m / 2 + 1])\n\t\telse\n\t\t\treturn t[(m + 1) / 2]\n\t\tend\n\tend\n\treturn\
    \ l[1]\nend", "    local n = #l\n    if n == 0 then\n        return 0\n    end\n\
    \    table.sort(l)\n    if n % 2 == 0 then\n        return (l[n/2] + l[n/2+1])\
    \ / 2\n    else\n        return l[math.ceil(n/2)]\n    end\nend", "\tif #l ==\
    \ 0 then\n\t\treturn 0\n\tend\n\tif #l == 1 then\n\t\treturn l[1]\n\tend\n\ttable.sort(l)\n\
    \tif #l % 2 == 0 then\n\t\treturn (l[#l/2] + l[#l/2+1]) / 2\n\telse\n\t\treturn\
    \ l[math.ceil(#l/2)]\n\tend\nend", "  sort(l)\n  local n = #l\n  if n == 0 then\
    \ return 0, 0 end\n  if n % 2 == 0 then\n    return (l[n/2] + l[n/2+1]) / 2, n\n\
    \  else\n    return l[(n+1)/2], n\n  end\nend", "\ttable.sort(l)\n\tlocal mid\
    \ = math.floor(#l / 2)\n\tif math.fmod(#l, 2) == 0 then\n\t\treturn (l[mid] +\
    \ l[mid + 1]) / 2\n\telse\n\t\treturn l[mid + 1]\n\tend\nend", "    local temp={}\n\
    \    for _,v in ipairs(l) do\n        table.insert(temp,v)\n    end\n    table.sort(temp)\n\
    \    if math.fmod(#temp,2)==0 then\n        return (temp[#temp/2]+temp[(#temp/2)+1])/2\n\
    \    else\n        return temp[math.ceil(#temp/2)]\n    end\nend", "\ttable.sort(l)\n\
    \tlocal half = math.floor(#l / 2)\n\tif #l % 2 == 0 then\n\t\treturn (l[half]\
    \ + l[half + 1]) / 2\n\telse\n\t\treturn l[half + 1]\n\tend\nend", "  local n\
    \ = #l\n  if n == 0 then\n    return nil\n  elseif n == 1 then\n    return l[1]\n\
    \  else\n    local m\n    if n % 2 == 0 then\n      -- Median is the mean of the\
    \ two middle values\n      m = (l[n/2] + l[n/2+1]) / 2\n    else\n      -- Median\
    \ is the middle value\n      m = l[math.ceil(n/2)]\n    end\n    return m\n  end\n\
    end", "  local half = #l / 2\n  local is_even = half == math.floor(half)\n  if\
    \ is_even then\n    return (l[half] + l[half + 1]) / 2\n  else\n    return l[math.ceil(half)]\n\
    \  end\nend", "\tif #l == 0 then\n\t\treturn 0\n\tend\n\ttable.sort(l)\n\tif #l\
    \ % 2 == 0 then\n\t\treturn (l[#l/2] + l[#l/2+1]) / 2, l[#l/2], l[#l/2+1]\n\t\
    else\n\t\treturn l[math.ceil(#l/2)]\n\tend\nend", "    sort(l)\n    if #l % 2\
    \ == 0 then return (l[#l/2] + l[#l/2+1]) / 2 end\n    return l[math.ceil(#l/2)]\n\
    end", "  local l_len = #l\n  assert(l_len > 0)\n  local l_sorted = torch.Tensor(l):sort()\n\
    \  if l_len % 2 == 0 then\n    return 0.5 * (l_sorted[l_len / 2] + l_sorted[l_len\
    \ / 2 + 1])\n  else\n    return l_sorted[(l_len + 1) / 2]\n  end\nend", "  local\
    \ tmp = {}\n  for _, v in ipairs(l) do\n    tmp[#tmp+1] = v\n  end\n  table.sort(tmp)\n\
    \  if #tmp %2 == 0 then\n    return (tmp[#tmp/2] + tmp[(#tmp/2)+1]) / 2\n  else\n\
    \    return tmp[math.ceil(#tmp/2)]\n  end\nend", "  if #l == 0 then return nil\
    \ end\n  local m, s = 0, 0\n  for _, v in ipairs(l) do\n    m = m + v\n    s =\
    \ s + v * v\n  end\n  local r, mr = nil, -1\n  for _, v in ipairs(l) do\n    local\
    \ rr = math.abs(m - v)\n    if not r or rr < mr then\n      r, mr = v, rr\n  \
    \  end\n  end\n  return r\nend", "    local m = (numelems(l) + 1) / 2\n    local\
    \ i = 1\n    local v = l[1]\n    while i < m do\n        i = i + 1\n        v\
    \ = median_pair(v, l[i])\n    end\n    return v\nend", "\tif #l == 0 then\n\t\t\
    return nil\n\tend\n\ttable.sort(l)\n\tif #l % 2 == 0 then\n\t\treturn (l[#l/2]\
    \ + l[#l/2+1]) / 2\n\telse\n\t\treturn l[math.ceil(#l/2)]\n\tend\nend", "    local\
    \ count = #l\n    if count == 0 then\n        return 0\n    end\n    table.sort(l)\n\
    \    if count % 2 == 0 then\n        return (l[count / 2] + l[count / 2 + 1])\
    \ / 2\n    else\n        return l[math.ceil(count / 2)]\n    end\nend", "\tlocal\
    \ tmp = {}\n\tfor _, v in ipairs(l) do\n\t\ttmp[#tmp+1] = v\n\tend\n\ttable.sort(tmp)\n\
    \treturn tmp[math.ceil(#tmp/2)]\nend", "    local tmp = {}\n    for _, v in ipairs(l)\
    \ do\n        table.insert(tmp, v)\n    end\n    table.sort(tmp)\n    if #tmp\
    \ % 2 == 0 then\n        return (tmp[#tmp / 2] + tmp[#tmp / 2 + 1]) / 2\n    else\n\
    \        return tmp[math.ceil(#tmp / 2)]\n    end\nend", "\tlocal tmp = {}\n\t\
    for k, v in pairs(l) do\n\t\ttmp[k] = v\n\tend\n\ttable.sort(tmp)\n\tif #tmp %\
    \ 2 == 0 then\n\t\treturn (tmp[#tmp / 2] + tmp[#tmp / 2 + 1]) / 2\n\telse\n\t\t\
    return tmp[math.ceil(#tmp / 2)]\n\tend\nend", "  local m = #l\n  if m < 1 then\
    \ return 0 end\n  if m == 1 then return l[1] end\n  local s = table.sort(l)\n\
    \  if m % 2 == 0 then\n    return (l[m/2] + l[m/2+1]) / 2\n  else\n    return\
    \ l[math.ceil(m/2)]\n  end\nend", "\ttable.sort(l)\n\tlocal n = #l\n\tif n ==\
    \ 0 then\n\t\treturn nil\n\telseif n % 2 == 0 then\n\t\treturn (l[n/2] + l[n/2+1])\
    \ / 2\n\telse\n\t\treturn l[math.ceil(n/2)]\n\tend\nend", "    -- Sort the list.\n\
    \    local l = merge_sort(l)\n    -- Compute median.\n    local len = #l\n   \
    \ local m   = l[math.floor(len/2)]\n    if len % 2 == 0 then\n        m = m +\
    \ l[math.floor(len/2 + 1)]\n        m = m / 2\n    end\n    return m\nend", " \
    \ local s = table.sort(l)\n  if math.fmod(#l, 2) == 0 then\n    -- even number\
    \ of elements\n    return (l[#l/2] + l[#l/2+1]) / 2\n  else\n    -- odd number\
    \ of elements\n    return l[math.ceil(#l/2)]\n  end\nend", "    table.sort(l)\n\
    \    return l[#l/2]\nend", "\tif #l == 0 then\n\t\treturn 0\n\tend\n\tlocal sorted\
    \ = CopyTable(l)\n\ttable.sort(sorted)\n\tif #sorted % 2 == 0 then\n\t\treturn\
    \ (sorted[#sorted / 2] + sorted[#sorted / 2 + 1]) / 2\n\telse\n\t\treturn sorted[math.ceil(#sorted\
    \ / 2)]\n\tend\nend", "\tlocal i = 1\n\tlocal m = math.floor(#l/2)\n\twhile m\
    \ > 0 do\n\t\tlocal k, pos = math.min(l)\n\t\tm = m - 1\n\t\tl[pos] = math.huge\n\
    \t\ti = i + 1\n\tend\n\treturn k\nend", "  local count = 0\n  local nums = {}\n\
    \  for _,v in pairs(l) do\n    count = count + 1\n    nums[count] = v\n  end\n\
    \  if count == 0 then\n    return 0\n  end\n  table.sort(nums)\n  local middle\
    \ = math.floor(count/2)\n  if count % 2 == 0 then\n    return (nums[middle] +\
    \ nums[middle+1]) / 2\n  else\n    return nums[middle+1]\n  end\nend", "\tlocal\
    \ lsorted = {}\n\tfor k,v in pairs(l) do lsorted[k] = v end\n\ttable.sort(lsorted)\n\
    \tlocal n = #lsorted\n\tif n%2 == 0 then\n\t\tlocal a = lsorted[n/2]\n\t\tlocal\
    \ b = lsorted[n/2+1]\n\t\tif a and b then\n\t\t\treturn (a+b)/2\n\t\telse\n\t\t\
    \treturn nil\n\t\tend\n\telse\n\t\treturn lsorted[(n+1)/2]\n\tend\nend", "\tlocal\
    \ m = #l/2\n\tif math.floor(m) == m then\n\t\treturn (l[m] + l[m+1])/2\n\telse\n\
    \t\treturn l[math.ceil(m)]\n\tend\nend", "    local lst = list.sort(l)\n    if\
    \ #lst % 2 == 0 then\n        return (lst[#lst/2] + lst[#lst/2+1]) / 2\n    else\n\
    \        return lst[math.ceil(#lst/2)]\n    end\nend", "  local xl = copy(l)\n\
    \  local n = #xl\n  local result = nil\n  if n == 0 then\n    return nil\n  elseif\
    \ n == 1 then\n    return xl[1]\n  else\n    -- select mid element (m)\n    --\
    \ Note, that this is not the same as mean(l) and, thus, the median is not\n  \
    \  -- the same as the mean of the median.\n    local m = (n - 1) / 2\n    if m\
    \ == math.floor(m) then\n      -- even number of elements, hence there are two\
    \ medians\n      result = mean(xl, { m, m + 1 })\n    else\n      -- odd number\
    \ of elements, there is a single median\n      result = xl[math.floor(m + 1)]\n\
    \    end\n  end\n  return result\nend", "\tlocal m = #l\n\tif m == 0 then return\
    \ 0,0 end\n\ttable.sort(l)\n\tif m % 2 == 0 then\n\t\treturn (l[m/2] + l[m/2+1])\
    \ / 2, m\n\telse\n\t\treturn l[math.ceil(m/2)], m\n\tend\nend", "\tlocal count\
    \ = 0\n\tlocal sum = 0\n\tfor i, v in ipairs(l) do\n\t\tcount = count + 1\n\t\t\
    sum = sum + v\n\tend\n\treturn sum / count\nend", "  local t = clone(l)\n  table.sort(t)\n\
    \  return t[math.ceil(#t/2)]\nend", "    local n = #l\n    local d = n % 2\n \
    \   -- If n is odd, return middle number\n    if d == 1 then\n        return l[math.ceil(n/2)]\n\
    \    -- If n is even, return average of middle two numbers\n    else\n       \
    \ return (l[n/2] + l[n/2+1])/2\n    end\nend", "\ttable.sort(l)\n\tlocal n = #l\n\
    \tif n % 2 == 0 then\n\t\treturn (l[n/2] + l[n/2+1]) / 2\n\telse\n\t\treturn l[math.ceil(n/2)]\n\
    \tend\nend", "\tsort(l)\n\tlocal m = length(l)\n\tif m%2 == 0 then\n\t\treturn\
    \ (l[m/2] + l[m/2+1])/2\n\telse\n\t\treturn l[(m+1)/2]\n\tend\nend", "  local\
    \ temp={}\n  for _,v in ipairs(l) do\n    table.insert(temp,v)\n  end\n  table.sort(temp)\n\
    \  -- If there is an even number of elements, return mean of the two elements\
    \ in the middle\n  if math.fmod(#temp,2)==0 then\n    return (temp[#temp/2] +\
    \ temp[(#temp/2)+1]) / 2\n  else\n    return temp[math.ceil(#temp/2)]\n  end\n\
    end", "\tif #l == 0 then\n\t\treturn 0\n\tend\n\ttable.sort(l)\n\tlocal m\n\t\
    if #l % 2 == 0 then\n\t\tm = (#l / 2) + 1\n\telse\n\t\tm = math.ceil(#l / 2)\n\
    \tend\n\treturn l[m]\nend", "    local p = {}\n    for k, v in pairs(l) do\n \
    \       p[#p+1] = v\n    end\n    table.sort(p)\n    return p[math.ceil(#p/2)]\n\
    end", "    assert(type(l) == \"table\", \"invalid argument\")\n    assert(#l >\
    \ 0, \"table must not be empty\")\n    table.sort(l)\n    if #l % 2 == 0 then\n\
    \        return (l[#l / 2] + l[#l / 2 + 1]) / 2, l[#l / 2], l[#l / 2 + 1]\n  \
    \  else\n        return l[math.ceil(#l / 2)]\n    end\nend", "  -- First, sort\
    \ list l.\n  local sorted = {}\n  for i, v in ipairs(l) do\n    table.insert(sorted,\
    \ v)\n  end\n  table.sort(sorted)", "\tif #l == 0 then\n\t\treturn 0\n\tend\n\t\
    local t = table.copy(l)\n\ttable.sort(t)\n\tlocal n = #t\n\tif n % 2 == 0 then\n\
    \t\treturn (t[n/2] + t[n/2+1]) / 2\n\telse\n\t\treturn t[math.ceil(n/2)]\n\tend\n\
    end", "    -- First we need to sort the table...\n    table.sort(l)\n    -- The\
    \ median is the middle number of the array:\n    if (#l % 2 == 0) then\n     \
    \   -- Return the average of the middle two elements if there are an even number\
    \ of elements.\n        return (l[#l/2] + l[#l/2+1]) / 2\n    else\n        --\
    \ Else, return the middle element.\n        return l[math.ceil(#l/2)]\n    end\n\
    end", "    if type(l) ~= 'table' then\n        return nil\n    end\n    local\
    \ tmp = {}\n    for _, v in ipairs(l) do\n        table.insert(tmp, v)\n    end\n\
    \    table.sort(tmp)\n    if #tmp % 2 == 0 then\n        return (tmp[#tmp / 2]\
    \ + tmp[(#tmp / 2) + 1]) / 2\n    end\n    return tmp[math.ceil(#tmp / 2)]\nend",
  "    local sorted = {}\n    for _, v in ipairs(l) do table.insert(sorted, v) end\n\
    \    table.sort(sorted)\n    local n = #sorted\n    if n % 2 == 0 then\n     \
    \   return (sorted[n/2] + sorted[n/2+1]) / 2\n    else\n        return sorted[math.ceil(n/2)]\n\
    \    end\nend", "    if l == nil or #l == 0 then\n        return 0\n    end\n\
    \    local t = {}\n    for _,v in pairs(l) do\n        table.insert(t, v)\n  \
    \  end\n    table.sort(t)\n    local m = #t\n    if m % 2 == 0 then\n        return\
    \ (t[m/2] + t[m/2+1]) / 2\n    else\n        return t[(m+1)/2]\n    end\nend",
  "\tlocal l_len = #l\n\tlocal half = (l_len - 1) / 2\n\tlocal sorted = sort(l)\n\t\
    if l_len % 2 == 0 then\n\t\treturn (sorted[half] + sorted[half + 1]) / 2\n\telse\n\
    \t\treturn sorted[half + 1]\n\tend\nend", "  local sorted = {}\n  for n in pairs(l)\
    \ do\n    table.insert(sorted, n)\n  end\n  table.sort(sorted)\n  if #sorted %\
    \ 2 == 0 then\n    return (sorted[#sorted/2] + sorted[#sorted/2+1]) / 2\n  else\n\
    \    return sorted[math.ceil(#sorted/2)]\n  end\nend", "  table.sort(l)\n  if\
    \ #l % 2 == 0 then\n    return (l[#l/2] + l[#l/2+1]) / 2\n  else\n    return l[math.ceil(#l/2)]\n\
    \  end\nend", "  local median = nil\n  local len = #l\n  if len == 0 then\n  \
    \  return nil\n  elseif len == 1 then\n    return l[1]\n  elseif len == 2 then\n\
    \    return (l[1] + l[2]) / 2\n  else\n    table.sort(l)\n    if len % 2 == 0\
    \ then\n      median = (l[len / 2] + l[len / 2 + 1]) / 2\n    else\n      median\
    \ = l[(len + 1) / 2]\n    end\n  end\n  return median\nend", "\tlocal count =\
    \ 0\n\tlocal t = {}\n\tfor k, v in pairs(l) do\n\t\ttable.insert(t, v)\n\t\tcount\
    \ = count + 1\n\tend\n\ttable.sort(t)\n\treturn t[math.ceil(count / 2)]\nend",
  "    local sorted = {}\n    for i,v in ipairs(l) do\n        sorted[i] = v\n   \
    \ end\n    table.sort(sorted)\n    local half = #sorted / 2\n    if half == math.floor(half)\
    \ then\n        return (sorted[half] + sorted[half+1]) / 2\n    else\n       \
    \ return sorted[math.ceil(half)]\n    end\nend", "\tif #l == 0 then\n\t\treturn\
    \ 0\n\tend\n\tif #l == 1 then\n\t\treturn l[1]\n\tend\n\ttable.sort(l)\n\tlocal\
    \ n = #l\n\tif n % 2 == 0 then\n\t\treturn (l[n/2] + l[n/2+1]) / 2\n\telse\n\t\
    \treturn l[(n+1)/2]\n\tend\nend", "\tlocal function less(x, y)\n\t\treturn x <\
    \ y\n\tend\n\tlocal function greater(x, y)\n\t\treturn x > y\n\tend\n\tlocal function\
    \ leq(x, y)\n\t\treturn x <= y\n\tend\n\tlocal function geq(x, y)\n\t\treturn\
    \ x >= y\n\tend\n\tlocal function partition(l, l_start, l_end, pivot_idx, comp)\n\
    \t\tl[pivot_idx], l[l_end] = l[l_end], l[pivot_idx]\n\t\tlocal store_idx = l_start\n\
    \t\tfor i = l_start, l_end - 1 do\n\t\t\tif comp(l[i], l[l_end]) then\n\t\t\t\t\
    l[i], l[store_idx] = l[store_idx], l[i]\n\t\t\t\tstore_idx = store_idx + 1\n\t\
    \t\tend\n\t\tend\n\t\tl[store_idx], l[l_end] = l[l_end], l[store_idx]\n\t\treturn\
    \ store_idx\n\tend\n\tlocal function _median(l, l_start, l_end, comp)\n\t\tif\
    \ l_start < l_end then\n\t\t\tlocal pivot_idx = math.random(l_start, l_end)\n\t\
    \t\tpivot_idx = partition(l, l_start, l_end, pivot_idx, comp)\n\t\t\tif pivot_idx\
    \ == #l / 2 then\n\t\t\t\treturn l[pivot_idx]\n\t\t\telseif pivot_idx > #l / 2\
    \ then\n\t\t\t\treturn _median(l, l_start, pivot_idx - 1, comp)\n\t\t\telse\n\t\
    \t\t\treturn _median(l, pivot_idx + 1, l_end, comp)\n\t\t\tend\n\t\tend\n\tend\n\
    \tlocal copy = {}\n\tfor _, v in ipairs(l) do\n\t\ttable.insert(copy, v)\n\tend\n\
    \tif #copy % 2", "    table.sort(l)\n    local n = #l\n    if n == 0 then\n  \
    \      return nil\n    elseif n % 2 == 0 then\n        return (l[n/2] + l[n/2+1])\
    \ / 2\n    else\n        return l[math.ceil(n/2)]\n    end\nend", "\tif not l\
    \ then return nil end\n\tlocal sl = {}\n\tfor _,v in ipairs(l) do\n\t\ttable.insert(sl,v)\n\
    \tend\n\ttable.sort(sl)\n\tlocal middle = math.floor(#sl/2)\n\tif #sl % 2 == 0\
    \ then\n\t\treturn (sl[middle] + sl[middle+1]) / 2\n\telse\n\t\treturn sl[middle+1]\n\
    \tend\nend", "\tlocal m = #l * 0.5\n\tlocal r = #l % 2\n\tif r == 0 then\n\t\t\
    return (l[m] + l[m + 1]) * 0.5\n\telse\n\t\treturn l[math.ceil(m)]\n\tend\nend",
  "  -- sort the table.\n  table.sort(l)\n  local mid = math.floor(#l / 2)\n  return\
    \ l[mid + 1]\nend", "  -- table.sort is not a generic function, so we have to\
    \ make a local copy.\n  local ls = {}\n  for _,v in ipairs(l) do ls[#ls+1] = v\
    \ end\n  table.sort(ls)\n  if #ls % 2 == 0 then\n    return (ls[#ls/2] + ls[#ls/2+1])\
    \ / 2\n  else\n    return ls[math.ceil(#ls/2)]\n  end\nend", "\ttable.sort(l)\n\
    \tlocal len = #l\n\tif len % 2 == 0 then\n\t\tlocal v1 = l[len/2]\n\t\tlocal v2\
    \ = l[len/2+1]\n\t\treturn (v1+v2)/2\n\telse\n\t\treturn l[math.ceil(len/2)]\n\
    \tend\nend", "  if #l == 0 then return nil end\n  local t = { table.unpack(l)\
    \ }\n  table.sort(t)\n  if #t % 2 == 0 then\n    return (t[#t / 2] + t[#t / 2\
    \ + 1]) / 2\n  else\n    return t[math.ceil(#t / 2)]\n  end\nend", "\tlocal m\
    \ = #l\n\tlocal l = copy(l)\n\ttable.sort(l)\n\tif m % 2 == 0 then\n\t\treturn\
    \ (l[m/2] + l[m/2+1]) / 2\n\telse\n\t\treturn l[math.ceil(m/2)]\n\tend\nend",
  "\tl = copy(l)\n\ttable.sort(l)\n\tif #l % 2 == 0 then\n\t\treturn (l[#l/2] + l[#l/2+1])\
    \ / 2, l[#l/2], l[#l/2+1]\n\telse\n\t\treturn l[math.ceil(#l/2)], l[math.ceil(#l/2)]\n\
    \tend\nend", "\ttable.sort(l)\n\tlocal m = math.floor(#l / 2)\n\tif #l % 2 ==\
    \ 0 then\n\t\treturn (l[m] + l[m + 1]) / 2\n\telse\n\t\treturn l[m + 1]\n\tend\n\
    end", "  local x, y, c = 0, 0, 0\n  for _, v in ipairs(l) do\n    x = x + v\n\
    \    y = y + v^2\n    c = c + 1\n  end\n  x = x / c\n  y = y / c\n  return x,\
    \ y - x^2\nend", "    local h = {}\n    for _, v in ipairs(l) do\n        h[v]\
    \ = (h[v] or 0) + 1\n    end\n    local m = {}\n    for k, v in pairs(h) do\n\
    \        for i = 1, v do\n            table.insert(m, k)\n        end\n    end\n\
    \    table.sort(m)\n    local mid = #m % 2 == 0 and (#m // 2) or (#m // 2 + 1)\n\
    \    return m[mid]\nend", "  local t = copy(l)\n  table.sort(t)\n  return t[math.ceil(#t/2)]\n\
    end", "  table.sort(l)\n  local n = #l\n  if n % 2 == 0 then\n    return (l[n/2]\
    \ + l[n/2+1]) / 2\n  else\n    return l[math.ceil(n/2)]\n  end\nend", "  local\
    \ function median_imp(l,n)\n    local m = math.floor(n/2)\n    if n%2 == 0 then\n\
    \      return (l[m] + l[m+1])/2\n    else\n      return l[m+1]\n    end\n  end\n\
    \  table.sort(l)\n  return median_imp(l,#l)\nend", "  local tbl = {}\n  for i\
    \ = 1, #l do\n    tbl[i] = l[i]\n  end\n  table.sort(tbl)\n  if #tbl % 2 == 0\
    \ then\n    return (tbl[#tbl / 2] + tbl[#tbl / 2 + 1]) / 2\n  else\n    return\
    \ tbl[math.ceil(#tbl / 2)]\n  end\nend", "    local m = {}\n    for k,v in pairs(l)\
    \ do\n        m[k] = v\n    end\n    local n = #m\n    table.sort(m)\n    if n\
    \ % 2 == 0 then\n        return (m[n/2] + m[n/2+1]) / 2\n    else\n        return\
    \ m[math.ceil(n/2)]\n    end\nend", "    if l == nil or type(l) ~= \"table\" then\n\
    \        return nil\n    end\n    local count = #l\n    if count == 0 then\n \
    \       return nil\n    end\n    local sorted = copy(l)\n    table.sort(sorted)\n\
    \    if count % 2 == 0 then\n        -- even number of elements.\n        return\
    \ (sorted[count / 2] + sorted[count / 2 + 1]) / 2\n    else\n        -- odd number\
    \ of elements.\n        return sorted[(count + 1) / 2]\n    end\nend", "\tlocal\
    \ n = #l\n\tif n == 0 then\n\t\treturn nil\n\tend\n\ttable.sort(l)\n\treturn l[math.ceil(n/2)]\n\
    end", "\tlocal lc = {}\n\tfor i,v in ipairs(l) do\n\t\tlc[i] = v\n\tend\n\ttable.sort(lc)\n\
    \tif #lc % 2 == 0 then\n\t\treturn (lc[#lc/2] + lc[#lc/2+1]) / 2\n\telse\n\t\t\
    return lc[math.ceil(#lc/2)]\n\tend\nend", "  local temp={}\n  for _,v in ipairs(l)\
    \ do\n    table.insert(temp,v)\n  end\n  table.sort(temp)\n  -- If #temp is odd,\
    \ return middle element\n  if math.fmod(#temp,2)==1 then\n    return temp[math.ceil(#temp/2)]\n\
    \  -- Else, return mean of middle two elements\n  else\n    return (temp[#temp/2]\
    \ + temp[(#temp/2)+1]) / 2\n  end\nend", "  local count = #l\n  if count == 0\
    \ then\n    return nil\n  end\n  table.sort(l)\n  if count % 2 == 0 then\n   \
    \ return (l[count/2] + l[count/2+1]) / 2\n  else\n    return l[math.ceil(count/2)]\n\
    \  end\nend", "    local n = #l\n    if n == 0 then\n        return nil\n    elseif\
    \ n == 1 then\n        return l[1]\n    else\n        table.sort(l)\n        if\
    \ n % 2 == 0 then\n            return (l[n/2] + l[n/2+1]) / 2\n        else\n\
    \            return l[(n+1)/2]\n        end\n    end\nend", "\tlocal list = {}\n\
    \tfor _,v in pairs(l) do\n\t\tlist[#list+1] = v\n\tend\n\tsort(list)\n\tlocal\
    \ mid = #list/2\n\treturn (list[math.floor(mid)] + list[math.ceil(mid)])/2\nend",
  "\tlocal n = #l\n\tlocal m = n // 2 + 1\n\tfor i = 1, m do\n\t\tlocal min = i\n\t\
    \tfor j = i + 1, n do\n\t\t\tif l[j] < l[min] then\n\t\t\t\tmin = j\n\t\t\tend\n\
    \t\tend\n\t\tl[i], l[min] = l[min], l[i]\n\tend\n\treturn (n % 2 == 0) and ((l[m\
    \ - 1] + l[m]) * 0.5) or l[m]\nend", "    -- Sort the list\n    table.sort(l)\n\
    \    -- Get the middle value\n    local mid = math.floor(#l / 2)\n    -- Return\
    \ it\n    return l[mid]\nend", "    local temp={}\n    for _,v in ipairs(l) do\n\
    \        table.insert(temp,v)\n    end\n    table.sort(temp)\n    if #temp%2==1\
    \ then\n        return temp[math.ceil(#temp/2)]\n    else\n        return (temp[#temp/2]+temp[#temp/2+1])/2\n\
    \    end\nend", "    local s, m = {}, nil\n    for i, v in ipairs(l) do\n    \
    \    s[i] = v\n    end\n    table.sort(s)\n    m = s[math.ceil(#s / 2)]\n    return\
    \ m\nend", "  -- Sort l in increasing order.\n  table.sort(l)\n  local m = #l\n\
    \  -- Middle number.\n  if m%2 == 1 then\n    return l[m//2+1]\n  -- Average of\
    \ middle two numbers.\n  else\n    return (l[m//2] + l[m//2+1])/2\n  end\nend",
  "    table.sort(l)\n    local middle = math.floor(#l / 2)\n    if #l % 2 == 0 then\n\
    \        return (l[middle] + l[middle + 1]) / 2\n    else\n        return l[middle\
    \ + 1]\n    end\nend", "\tlocal temp={}\n\tfor _,v in ipairs(l) do\n\t\ttable.insert(temp,v)\n\
    \tend\n\ttable.sort(temp)\n\tif math.fmod(#temp,2)==0 then\n\t\treturn (temp[#temp/2]+temp[(#temp/2)+1])/2\n\
    \telse\n\t\treturn temp[math.ceil(#temp/2)]\n\tend\nend", "\tlocal m = #l\n\t\
    if m == 0 then return 0 end\n\tif m == 1 then return l[1] end\n\t\n\tlocal median\
    \ = m%2 == 0 and (l[m/2] + l[m/2+1])/2 or l[math.ceil(m/2)]\n\treturn median\n\
    end", "    local tmp = {}\n    for _, v in ipairs(l) do\n        table.insert(tmp,\
    \ v)\n    end\n    table.sort(tmp)\n    if #tmp % 2 == 0 then\n        return\
    \ (tmp[#tmp / 2] + tmp[#tmp / 2 + 1]) / 2\n    else\n        return tmp[math.ceil(#tmp\
    \ / 2)]\n    end\nend", "    local m, t = {}, {}\n    for _, v in ipairs(l) do\
    \ t[v] = (t[v] or 0) + 1 end\n    for n, c in pairs(t) do\n        for i = 1,\
    \ c do m[#m+1] = n end\n    end\n    table.sort(m)\n    return m[math.ceil(#m/2)]\n\
    end", "  -- Sort list.\n  table.sort(l)\n  -- Return median.\n  if #l % 2 == 0\
    \ then\n    return (l[#l/2] + l[#l/2+1]) / 2\n  else\n    return l[math.ceil(#l/2)]\n\
    \  end\nend", "  assert(l, \"median called with nil\")\n  assert(type(l) == \"\
    table\", \"median called with non-table\")\n  local copy = { }\n  for _, v in\
    \ pairs(l) do\n    copy[#copy+1] = v\n  end\n  table.sort(copy)\n  if #copy %2\
    \ == 1 then\n    return copy[math.ceil(#copy/2)]\n  else\n    return (copy[#copy/2]\
    \ + copy[#copy/2+1]) / 2\n  end\nend", "\tif type(l) ~= 'table' then return nil\
    \ end\n\tlocal temp={}\n\tfor _,v in ipairs(l) do\n\t\ttable.insert(temp, v)\n\
    \tend\n\ttable.sort(temp)\n\tif math.fmod(#temp,2) == 0 then\n\t\treturn (temp[#temp/2]\
    \ + temp[(#temp/2)+1]) / 2\n\telse\n\t\treturn temp[math.ceil(#temp/2)]\n\tend\n\
    end", "\ttable.sort(l)\n\tlocal n = #l\n\tif n % 2 == 0 then\n\t\treturn (l[n/2]\
    \ + l[n/2+1]) / 2\n\telse\n\t\treturn l[math.ceil(n/2)]\n\tend\nend", "\t-- If\
    \ the list has no contents, return 0\n\tif #l == 0 then return 0 end\n\t\n\t--\
    \ Sort the list by ascending value\n\ttable.sort(l)\n\t\n\t-- If the list has\
    \ an odd number of elements, return the middle element.\n\tif #l % 2 == 1 then\
    \ return l[math.ceil(#l/2)] end\n\t\n\t-- Return the average of the two middle\
    \ elements.\n\treturn (l[#l/2] + l[#l/2+1]) / 2\nend", "\tlocal v = {}\n\tfor\
    \ i = 1, #l do\n\t\tv[i] = l[i]\n\tend\n\ttable.sort(v)\n\tlocal n = #v\n\tif\
    \ n % 2 == 0 then\n\t\treturn (v[n / 2] + v[n / 2 + 1]) / 2\n\telse\n\t\treturn\
    \ v[math.ceil(n / 2)]\n\tend\nend", "    table.sort(l)\n    if (#l % 2 == 0) then\n\
    \        return (l[#l/2] + l[#l/2+1]) / 2, #l/2, (#l/2)+1\n    else\n        return\
    \ l[math.ceil(#l/2)], math.ceil(#l/2)\n    end\nend", "\tlocal s = sort(l)\n\t\
    local m = s[math.floor(#s/2)]\n\treturn m\nend", "\tlocal c=0\n\tfor _,_ in pairs(l)\
    \ do c=c+1 end\n\tif c==0 then return 0 end\n\tif c==1 then return l[1] end\n\t\
    local ll = {}\n\tfor k,v in pairs(l) do\n\t\ttable.insert(ll,{key=k,value=v})\n\
    \tend\n\ttable.sort(ll, function(a,b) return a.value<b.value end)\n\tlocal half\
    \ = math.floor(c/2)\n\tif c%2==0 then\n\t\treturn math.floor((ll[half].value+ll[half+1].value)/2)\n\
    \telse\n\t\treturn ll[half+1].value\n\tend\nend", "\tlocal temp={}\n\tlocal count=0\n\
    \tfor index, value in pairs(l) do\n\t\ttemp[count]=value\n\t\tcount=count+1\n\t\
    end\n\ttable.sort(temp)\n\tif count%2==0 then\n\t\treturn (temp[count/2-1]+temp[count/2])/2\n\
    \telse\n\t\treturn temp[(count+1)/2-1]\n\tend\nend", "  local temp={}\n  for _,v\
    \ in ipairs(l) do\n    table.insert(temp,v)\n  end\n  table.sort(temp)\n  if #temp%2==1\
    \ then\n    return temp[(#temp+1)/2]\n  else\n    return (temp[#temp/2]+temp[#temp/2+1])/2\n\
    \  end\nend", "    if #l < 1 then\n        return nil\n    end\n    table.sort(l)\n\
    \    if #l % 2 == 0 then\n        return (l[#l / 2] + l[#l / 2 + 1]) / 2\n   \
    \ else\n        return l[math.ceil(#l / 2)]\n    end\nend", "    local lsize =\
    \ #l\n    if lsize == 0 then\n        return 0\n    end\n    table.sort(l)\n \
    \   if lsize % 2 == 0 then\n        return (l[lsize/2] + l[lsize/2+1]) / 2\n \
    \   else\n        return l[math.ceil(lsize/2)]\n    end\nend", "\tif #l == 0 then\n\
    \t\treturn 0\n\tend\n\tif #l % 2 == 0 then\n\t\treturn (l[#l/2] + l[#l/2+1]) /\
    \ 2\n\telse\n\t\treturn l[math.ceil(#l/2)]\n\tend\nend", "    assert(#l > 0)\n\
    \    local m = #l\n    local vals = {}\n    for i = 1, m do\n        table.insert(vals,\
    \ l[i])\n    end\n    table.sort(vals)\n    local mid = m % 2 == 0 and m / 2 or\
    \ (m - 1) / 2 + 1\n    return vals[mid]\nend", "  local temp={}\n  for _,v in\
    \ ipairs(l) do\n    table.insert(temp,v)\n  end\n  table.sort(temp)\n  --if #temp%2==1\
    \ then\n  --  return temp[math.ceil(#temp/2)]\n  --end\n  --return (temp[#temp/2]+temp[(#temp/2)+1])/2\n\
    \  return temp[math.ceil(#temp/2)]\nend", "    local count = #l\n    if count\
    \ == 0 then\n        return nil\n    end\n    if count == 1 then\n        return\
    \ l[1]\n    end\n    table.sort(l)\n    if count % 2 == 0 then\n        return\
    \ (l[count / 2] + l[count / 2 + 1]) / 2\n    else\n        return l[(count + 1)\
    \ / 2]\n    end\nend", "  local l_len = #l\n  local m\n  if l_len == 0 then\n\
    \    m = 0\n  elseif l_len == 1 then\n    m = l[1]\n  else\n    local l_half =\
    \ l_len / 2\n    if l_len % 2 == 0 then\n      m = (l[l_half] + l[l_half + 1])\
    \ / 2\n    else\n      m = l[math.ceil(l_half)]\n    end\n  end\n  return m\n\
    end", "\tlocal t = {}\n\tfor k,v in pairs(l) do\n\t\tt[#t+1] = v\n\tend\n\ttable.sort(t)\n\
    \tif #t%2 == 0 then\n\t\treturn (t[#t/2] + t[#t/2+1]) / 2\n\telse\n\t\treturn\
    \ t[math.ceil(#t/2)]\n\tend\nend", "  local sorted = {}\n  for n in pairs(l) do\n\
    \    table.insert(sorted, n)\n  end\n  table.sort(sorted)\n  if #sorted % 2 ==\
    \ 0 then\n    return (sorted[#sorted/2] + sorted[#sorted/2+1]) / 2\n  else\n \
    \   return sorted[math.ceil(#sorted/2)]\n  end\nend", "    if #l == 0 then\n \
    \       return nil\n    end\n    table.sort(l)\n    if #l % 2 == 0 then\n    \
    \    return (l[#l / 2] + l[#l / 2 + 1]) / 2\n    else\n        return l[math.ceil(#l\
    \ / 2)]\n    end\nend", "\tlocal f = function(x,y) return x < y end\n\tlocal xs\
    \ = fcopy(l)\n\ttable.sort(xs, f)\n\tlocal n = #xs\n\tif n % 2 == 0 then\n\t\t\
    local m1 = n / 2\n\t\tlocal m2 = m1 + 1\n\t\treturn (xs[m1] + xs[m2]) / 2\n\t\
    else\n\t\tlocal m = math.floor(n / 2) + 1\n\t\treturn xs[m]\n\tend\nend", "  if\
    \ type(l) ~= 'table' then\n    return nil, 'parameter is not a table'\n  end\n\
    \  local count = #l\n  if count == 0 then\n    return nil, 'table is empty'\n\
    \  end\n  table.sort(l)\n  if count % 2 == 0 then\n    -- even\n    return (l[count/2]\
    \ + l[count/2+1]) / 2\n  else\n    -- odd\n    return l[math.ceil(count/2)]\n\
    \  end\nend", "  local tmp = {}\n  for _, v in ipairs(l) do\n    table.insert(tmp,\
    \ v)\n  end\n  table.sort(tmp)\n  local median\n  if #tmp % 2 == 0 then\n    median\
    \ = (tmp[#tmp/2] + tmp[#tmp/2+1]) / 2\n  else\n    median = tmp[math.ceil(#tmp/2)]\n\
    \  end\n  return median\nend", "    assert(#l>0)\n    local s = table.sort(l)\n\
    \    local n = #l\n    local mid = math.floor(n/2)\n    local m = nil\n    if\
    \ n%2 == 0 then\n        m = (l[mid]+l[mid+1])/2\n    else\n        m = l[mid+1]\n\
    \    end\n    return m\nend", "  local temp={}\n  for _,v in ipairs(l) do\n  \
    \  table.insert(temp,v)\n  end\n  table.sort(temp)\n  -- If #temp is odd, return\
    \ middle element\n  if math.fmod(#temp,2)==1 then\n    return temp[math.ceil(#temp/2)]\n\
    \  -- Else, return mean of middle two elements\n  else\n    return (temp[#temp/2]\
    \ + temp[(#temp/2)+1]) / 2\n  end\nend", "    local temp={}\n    for _,v in ipairs(l)\
    \ do\n        table.insert(temp, v)\n    end\n    table.sort(temp)\n    -- If\
    \ #temp is odd, returning temp[#temp/2] is right.\n    -- Using math.ceil() to\
    \ avoid occasional long decimal numbers.\n    return temp[math.ceil(#temp/2)]\n\
    end", "  table.sort(l)\n  local half = math.floor(#l / 2)\n  if #l % 2 == 0 then\n\
    \    return (l[half] + l[half + 1]) / 2\n  else\n    return l[half + 1]\n  end\n\
    end", "\tif not l then return nil end\n\tsort(l)\n\tlocal len = #l\n\tif len %\
    \ 2 == 0 then\n\t\treturn (l[len/2] + l[len/2+1]) / 2, len\n\telse\n\t\treturn\
    \ l[(len+1)/2], len\n\tend\nend", "    table.sort(l)\n    local n = #l\n    if\
    \ n % 2 == 0 then\n        return (l[n/2] + l[n/2+1]) / 2\n    else\n        return\
    \ l[math.ceil(n/2)]\n    end\nend", "    table.sort(l)\n    return l[math.ceil(#l/2)]\n\
    end", "  if not istable(l) then return nil end\n  local count = 0\n  for _, _\
    \ in pairs(l) do count = count + 1 end\n  if count == 0 then return nil end\n\
    \  local n = math.floor(count / 2)\n  local k = nil\n  for key, _ in pairs(l)\
    \ do\n    if k == n then return key end\n    k = (k or 0) + 1\n  end\n  return\
    \ nil\nend", "    if #l == 0 then\n        return nil\n    end\n    table.sort(l)\n\
    \    if #l % 2 == 0 then\n        return (l[#l / 2] + l[#l / 2 + 1]) / 2\n   \
    \ else\n        return l[math.ceil(#l / 2)]\n    end\nend", "  local count = #l\n\
    \  local median = 0\n  if count % 2 == 0 then\n    median = (l[count/2] + l[count/2+1])\
    \ / 2\n  else\n    median = l[(count+1)/2]\n  end\n  return median\nend", "  if\
    \ #l == 0 then return nil end\n  table.sort(l)\n  local n = #l\n  local m = math.floor(n\
    \ / 2)\n  if n % 2 == 0 then\n    return (l[m] + l[m + 1]) / 2\n  else\n    return\
    \ l[m + 1]\n  end\nend", "  local lcpy = l\n  table.sort(lcpy)\n  return (lcpy[#lcpy\
    \ / 2] + lcpy[(#lcpy / 2) + 1]) / 2\nend", "\tlocal len = #l\n\tif len < 1 then\n\
    \t\treturn nil\n\tend\n\tl = sorted(l)\n\tif len % 2 == 0 then\n\t\treturn (l[len/2]\
    \ + l[len/2+1]) / 2\n\telse\n\t\treturn l[(len+1)/2]\n\tend\nend", "    if #l\
    \ == 0 then\n        return nil\n    end\n    local lsort = {}\n    for _,v in\
    \ ipairs(l) do\n        table.insert(lsort, v)\n    end\n    table.sort(lsort)\n\
    \    if #lsort % 2 == 0 then\n        return (lsort[#lsort/2] + lsort[#lsort/2+1])\
    \ / 2\n    else\n        return lsort[math.ceil(#lsort/2)]\n    end\nend", " \
    \   local i = (floor(#l / 2))\n    if #l % 2 == 0 then\n        return floor((l[i]\
    \ + l[i + 1]) / 2)\n    else\n        return l[i + 1]\n    end\nend", "    table.sort(l)\n\
    \    local h = math.floor(#l / 2)\n    if #l % 2 == 0 then\n        return (l[h]\
    \ + l[h + 1]) / 2\n    else\n        return l[h + 1]\n    end\nend", "  local\
    \ temp={}\n  for _,v in ipairs(l) do\n    table.insert(temp,v)\n  end\n  table.sort(temp)\n\
    \  -- If #temp is odd, return middle element\n  if math.fmod(#temp,2)==1 then\n\
    \    return temp[math.ceil(#temp/2)]\n  -- Else, return mean of middle two elements\n\
    \  else\n    return (temp[#temp/2] + temp[(#temp/2)+1]) / 2\n  end\nend", "\t\
    local sorted = sorted_keys(l)\n\tlocal mid = math.floor(#sorted / 2)\n\treturn\
    \ sorted[mid]\nend", "    local n = #l\n    if n % 2 == 0 then\n        return\
    \ (l[n/2] + l[n/2+1]) / 2\n    else\n        return l[math.ceil(n/2)]\n    end\n\
    end", "    local temp={}\n    for _,v in ipairs(l) do\n        table.insert(temp,v)\n\
    \    end\n    table.sort(temp)\n    if math.fmod(#temp,2)==0 then\n        return\
    \ (temp[#temp/2]+temp[(#temp/2)+1])/2\n    else\n        return temp[math.ceil(#temp/2)]\n\
    \    end\nend", "    local copy = { }\n    for _, v in ipairs(l) do\n        copy[#copy+1]\
    \ = v\n    end\n    table.sort(copy)\n    local mid = #copy / 2\n    if #copy\
    \ % 2 == 0 then\n        return (copy[mid] + copy[mid+1]) / 2\n    else\n    \
    \    return copy[math.ceil(mid)]\n    end\nend", "    local m = 0\n    local n\
    \ = 0\n    local sum = 0\n    local i = 1\n    while i <= #l do\n        local\
    \ v = l[i]\n        if v ~= nil then\n            n = n + 1\n            sum =\
    \ sum + v\n            m = sum / n\n        end\n        i = i + 1\n    end\n\
    \    return m\nend", "\tlocal v = {}\n\tfor _, val in ipairs(l) do\n\t\tv[#v+1]\
    \ = val\n\tend\n\ttable.sort(v)\n\tlocal n = #v\n\tif n == 0 then\n\t\treturn\
    \ 0\n\telseif n % 2 == 0 then\n\t\treturn (v[n/2] + v[n/2+1]) / 2\n\telse\n\t\t\
    return v[(n+1)/2]\n\tend\nend", "\ttable.sort(l)\n\tlocal n = #l\n\tlocal m =\
    \ l[math.floor(n/2)]\n\tif n % 2 == 0 then\n\t\tm = (m + l[math.floor(n/2) + 1])\
    \ / 2\n\tend\n\treturn m\nend", "\tlocal t = l\n\ttable.sort(t)\n\tif #t % 2 ==\
    \ 0 then\n\t\treturn (t[#t/2] + t[#t/2+1]) / 2\n\telse\n\t\treturn t[math.ceil(#t/2)]\n\
    \tend\nend", "  local sl = {}\n  for _,v in ipairs(l) do\n    table.insert(sl,\
    \ v)\n  end\n  table.sort(sl)\n  if #sl %2 == 0 then\n    return (sl[(#sl/2)]\
    \ + sl[(#sl/2)+1]) / 2\n  else\n    return sl[math.ceil(#sl/2)]\n  end\nend",
  "  table.sort(l)\n  local n = #l\n  if n == 0 then\n    return nil\n  elseif n %\
    \ 2 == 0 then\n    return (l[n/2] + l[n/2+1]) / 2\n  else\n    return l[math.ceil(n/2)]\n\
    \  end\nend", "  if #l == 0 then return 0 end\n  local f = (0.5*(#l-1)) % 1\n\
    \  local i = math.floor(0.5*(#l-1))\n  if f == 0 then\n    return l[i+1]\n  else\n\
    \    return (1-f)*l[i+1] + f*l[i+2]\n  end\nend", "    local max = 0\n    local\
    \ min = math.huge\n    local sum = 0\n    for _,v in ipairs(l) do\n        max\
    \ = math.max(max, v)\n        min = math.min(min, v)\n        sum = sum + v\n\
    \    end\n    return (max + min) / 2, sum / #l\nend", "  assert(l ~= nil)\n  assert(type(l)\
    \ == \"table\")\n  assert(#l > 0)\n  assert(#l <= MAX_ROUNDS)\n  table.sort(l)\n\
    \  return l[#l / 2]\nend", "  if #l == 0 then return 0 end\n  table.sort(l)\n\
    \  if #l %2 == 0 then return (l[#l/2] + l[#l/2+1]) / 2 end\n  return l[math.ceil(#l/2)]\n\
    end", "  local sorted = {}\n  for i, e in ipairs(l) do\n    sorted[i] = e\n  end\n\
    \  table.sort(sorted)\n  if #sorted%2 == 0 then\n    return (sorted[#sorted/2]\
    \ + sorted[#sorted/2+1])/2\n  else\n    return sorted[(#sorted+1)/2]\n  end\n\
    end", "\tif #l < 1 then return nil end\n\ttable.sort(l)\n\tif #l %2 == 0 then\
    \ return (l[#l/2] + l[#l/2+1]) / 2 end\n\treturn l[math.ceil(#l/2)]\nend", "\t\
    -- sort l\n\tlocal l2 = {}\n\tfor i, v in ipairs(l) do\n\t\tl2[i] = v\n\tend\n\
    \ttable.sort(l2)\n\t\n\t-- get median\n\tlocal n = #l2\n\tlocal idx\n\tif n %\
    \ 2 == 0 then\n\t\t-- even number of elements\n\t\tidx = n / 2\n\t\treturn (l2[idx]\
    \ + l2[idx + 1]) / 2\n\telse\n\t\t-- odd number of elements\n\t\tidx = (n + 1)\
    \ / 2\n\t\treturn l2[idx]\n\tend\nend", "    local m = list.copy(l)\n    table.sort(m)\n\
    \    return m[math.ceil(#m/2)]\nend", "  table.sort(l)\n  local n = #l\n  if n\
    \ % 2 == 0 then\n    return (l[n/2] + l[n/2+1]) / 2\n  else\n    return l[math.ceil(n/2)]\n\
    \  end\nend", "\tif type(l) ~= 'table' then return l end\n\ttable.sort(l)\n\t\
    if #l %2 == 0 then return (l[#l/2] + l[#l/2+1]) / 2 end\n\treturn l[math.ceil(#l/2)]\n\
    end", "  -- Sort the table in place.\n  table.sort(l)\n  -- Calculate median.\n\
    \  local mid = #l % 2 == 0 and (#l / 2) or ((#l + 1) / 2)\n  -- Return the middle\
    \ element.\n  return l[mid]\nend", "\tlocal llen = #l\n\tif llen == 0 then\n\t\
    \treturn\n\tend\n\tsort(l)\n\tlocal half = llen % 2 == 0 and llen / 2 + 1 or (llen\
    \ + 1) / 2\n\treturn (l[half] + l[half - 1]) / 2\nend", "\tif type(l) ~= 'table'\
    \ then return l end\n\ttable.sort(l)\n\tif #l %2 == 0 then return (l[#l/2] + l[#l/2+1])\
    \ / 2 end\n\treturn l[math.ceil(#l/2)]\nend", "\tlocal lsort = sort(l)\n\tlocal\
    \ len = #lsort\n\tif len == 0 then\n\t\treturn nil\n\telseif len % 2 == 0 then\n\
    \t\treturn (lsort[len/2] + lsort[len/2+1]) / 2\n\telse\n\t\treturn lsort[(len+1)/2]\n\
    \tend\nend", "  local vals = {}\n  for _, v in ipairs(l) do\n    vals[#vals+1]\
    \ = v\n  end\n  table.sort(vals)\n  local len = #vals\n  if len % 2 == 0 then\n\
    \    return (vals[len/2] + vals[len/2+1]) / 2\n  else\n    return vals[(len+1)/2]\n\
    \  end\nend", "\tlocal half_len = (num_elements(l) + 1) / 2", "  local n = #l\n\
    \  if n == 0 then\n    return nil\n  elseif n % 2 == 0 then\n    return (l[n/2]\
    \ + l[n/2+1]) / 2\n  else\n    return l[math.ceil(n/2)]\n  end\nend", "  local\
    \ sorted = {}\n  for n in pairs(l) do table.insert(sorted, n) end\n  table.sort(sorted)\n\
    \  if #sorted %2 == 0 then\n    return (sorted[#sorted/2] + sorted[#sorted/2+1])\
    \ / 2\n  else\n    return sorted[math.ceil(#sorted/2)]\n  end\nend", "  --local\
    \ sorted = clone(l)\n  --table.sort(sorted)\n  --return sorted[math.ceil(#l/2)]\n\
    \  return select(2, gmean(l))\nend", "    local n = #l\n    if n == 0 then\n \
    \       return nil\n    elseif n % 2 == 0 then\n        return (l[n/2] + l[n/2+1])\
    \ / 2\n    else\n        return l[math.ceil(n/2)]\n    end\nend", "  if not l\
    \ then return nil end\n  local n = #l\n  if n == 0 then return nil end\n  if n\
    \ == 1 then return l[1] end\n  table.sort(l)\n  local m = n / 2\n  if n % 2 ==\
    \ 0 then\n    return (l[m] + l[m+1]) / 2\n  else\n    return l[math.ceil(m)]\n\
    \  end\nend", "  local tmp = {}\n  for _, v in ipairs(l) do\n    tmp[#tmp+1] =\
    \ v\n  end\n  table.sort(tmp)\n  if #tmp %2 == 0 then\n    return (tmp[#tmp/2]\
    \ + tmp[(#tmp/2)+1]) / 2\n  else\n    return tmp[math.ceil(#tmp/2)]\n  end\nend",
  "    local temp={}\n    for _,v in ipairs(l) do\n        table.insert(temp,v)\n\
    \    end\n    table.sort(temp)\n    -- If #temp is odd, return middle element\n\
    \    if #temp%2==1 then\n        return temp[math.ceil(#temp/2)]\n    -- Else,\
    \ return mean of middle two elements\n    else\n        return (temp[#temp/2]\
    \ + temp[(#temp/2)+1]) / 2\n    end\nend", "  local t = {}\n  for k, v in pairs(l)\
    \ do\n    t[#t+1] = v\n  end\n  table.sort(t)\n  if #t % 2 == 0 then\n    return\
    \ (t[#t/2] + t[#t/2+1]) / 2\n  else\n    return t[math.ceil(#t/2)]\n  end\nend",
  "    if type(l) ~= 'table' then\n        return l\n    end\n    local temp={}\n\
    \    for _,v in ipairs(l) do\n        table.insert(temp,v)\n    end\n    table.sort(temp)\n\
    \    -- If #temp is odd, return middle element\n    if math.fmod(#temp,2) == 1\
    \ then\n        return temp[math.ceil(#temp/2)]\n    -- If #temp is even, return\
    \ mean of middle elements\n    else\n        return (temp[#temp/2] + temp[(#temp/2)+1])\
    \ / 2\n    end\nend", "\tif type(l) ~= 'table' then return l end\n\tif #l == 0\
    \ then return 0 end\n\tlocal l2 = {}\n\tfor _, v in ipairs(l) do\n\t\tif type(v)\
    \ == 'number' then\n\t\t\ttable.insert(l2, v)\n\t\tend\n\tend\n\ttable.sort(l2)\n\
    \tlocal n = #l2\n\tlocal m = math.ceil(n / 2)\n\treturn l2[m]\nend", "\tlocal\
    \ temp={}\n\tfor _,v in ipairs(l) do\n\t\ttable.insert(temp,v)\n\tend\n\ttable.sort(temp)\n\
    \tif #temp%2==1 then\n\t\treturn temp[math.ceil(#temp/2)]\n\telse\n\t\treturn\
    \ (temp[#temp/2]+temp[#temp/2+1])/2\n\tend\nend", "  local len = #l\n  if len\
    \ == 0 then\n    return 0\n  end\n  local srt = {}\n  for _, v in ipairs(l) do\n\
    \    srt[#srt + 1] = v\n  end\n  table.sort(srt)\n  if len % 2 == 0 then\n   \
    \ return (srt[len / 2] + srt[len / 2 + 1]) / 2\n  else\n    return srt[(len +\
    \ 1) / 2]\n  end\nend", "    -- Sort list by ascending order.\n    table.sort(l)\n\
    \    -- Return median.\n    return l[(#l + 1) / 2]\nend", "    if #l==0 then return\
    \ nil end\n    local sorted=sort(l)\n    local n=#sorted\n    if n%2==0 then\n\
    \        return (sorted[n/2]+sorted[n/2+1])/2\n    else\n        return sorted[(n+1)/2]\n\
    \    end\nend", "\tif l == nil or #l == 0 then\n\t\treturn nil\n\tend\n\tlocal\
    \ half, rem = math.modf(#l / 2)\n\tif rem == 0 then\n\t\treturn (l[half] + l[half\
    \ + 1]) / 2\n\telse\n\t\treturn l[half + 1]\n\tend\nend", "  local l_count = #l\n\
    \  table.sort(l)\n  if l_count % 2 == 0 then\n    return (l[l_count/2] + l[l_count/2+1])\
    \ / 2\n  else\n    return l[math.ceil(l_count/2)]\n  end\nend", "  local t = l\n\
    \  local n = #t\n  if n == 0 then return nil end\n  table.sort(t)\n  if n%2 ==\
    \ 0 then return (t[n/2] + t[n/2+1])/2 end\n  return t[math.ceil(n/2)]\nend", " \
    \ if type(l) ~= 'table' then error('Input must be a table.') end\n  local temp={}\n\
    \  for _,v in ipairs(l) do\n    table.insert(temp, v)\n  end\n  table.sort(temp)\n\
    \  if math.fmod(#temp,2) == 0 then\n    return (temp[#temp/2] + temp[(#temp/2)+1])\
    \ / 2\n  else\n    return temp[math.ceil(#temp/2)]\n  end\nend", "    local m\
    \ = table.getn(l) / 2\n    table.sort(l)\n    if table.getn(l) % 2 == 0 then\n\
    \        return (l[m] + l[m + 1]) / 2\n    else\n        return l[m + 1]\n   \
    \ end\nend", "\ttable.sort(l)\n\tlocal med = #l / 2\n\tlocal li = l[med + 1] or\
    \ 0\n\tlocal hi = l[med + 2] or 0\n\treturn (li + hi) / 2\nend", "    local count\
    \ = #l\n    local median = (count % 2 == 0) and l[count / 2] or l[(count + 1)\
    \ / 2]\n    return median\nend", "    if #l == 0 then\n        return nil\n  \
    \  end\n    table.sort(l)\n    if #l % 2 == 0 then\n        return (l[#l / 2]\
    \ + l[#l / 2 + 1]) / 2\n    else\n        return l[math.ceil(#l / 2)]\n    end\n\
    end", "    local middle = math.floor(#l / 2) + 1\n    local els = {}\n    for\
    \ i = 1, #l do\n        els[i] = l[i].error\n    end\n    table.sort(els)\n  \
    \  return els[middle]\nend", "\ttable.sort(l)\n\tlocal n = #l\n\tlocal m = n %\
    \ 2\n\tif m == 0 then\n\t\treturn (l[n/2] + l[n/2+1]) / 2\n\telse\n\t\treturn\
    \ l[(n+1)/2]\n\tend\nend", "\tlocal m = (0+#l)%2\n\ttable.sort(l)\n\treturn l[(#l-m)/2+1+m]\n\
    end", "    if #l == 0 then\n        return nil\n    end\n    if #l == 1 then\n\
    \        return l[1]\n    end\n    table.sort(l)\n    local half = math.floor(#l\
    \ / 2)\n    if #l % 2 == 0 then\n        return (l[half] + l[half + 1]) / 2\n\
    \    else\n        return l[half + 1]\n    end\nend", "    local m = (1 + #l)\
    \ / 2\n    return #l % 2 == 0 and (l[m] + l[m + 1]) / 2 or l[m]\nend", "  local\
    \ length = #l\n  if length == 0 then\n    return 0\n  end\n  local sorted = table.sort(l)\n\
    \  if length % 2 == 0 then\n    return (sorted[length / 2] + sorted[length / 2\
    \ + 1]) / 2\n  else\n    return sorted[(length + 1) / 2]\n  end\nend", "\ttable.sort(l)\n\
    \tlocal n = #l\n\tif n == 0 then\n\t\treturn 0\n\telseif n % 2 == 0 then\n\t\t\
    return (l[n/2] + l[n/2+1]) / 2\n\telse\n\t\treturn l[math.ceil(n/2)]\n\tend\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
