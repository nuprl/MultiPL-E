name: HumanEval_72_will_it_fly
language: lua
prompt: "-- Write a function that returns True if the object q will fly, and False\
  \ otherwise.\n-- The object q will fly if it's balanced (it is a palindromic list)\
  \ and the sum of its elements is less than or equal the maximum possible weight\
  \ w.\n-- Example:\n-- >>> will_it_fly([1, 2], 5) \n-- False \n-- # 1+2 is less than\
  \ the maximum possible weight, but it's unbalanced.\n-- # it's balanced, but 3+2+3\
  \ is more than the maximum possible weight.\n-- # 3+2+3 is less than the maximum\
  \ possible weight, and it's balanced.\n-- # 3 is less than the maximum possible\
  \ weight, and it's balanced.\nlocal function will_it_fly(q, w)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = will_it_fly\n\
  \    lu.assertEquals(candidate({3, 2, 3}, 9), true)\n    lu.assertEquals(candidate({1,\
  \ 2}, 5), false)\n    lu.assertEquals(candidate({3}, 5), true)\n    lu.assertEquals(candidate({3,\
  \ 2, 3}, 1), false)\n    lu.assertEquals(candidate({1, 2, 3}, 6), false)\n    lu.assertEquals(candidate({5},\
  \ 5), true)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  return false\nend", "    return (is_balanced(q) and sum(q) <= w)\n\
    end", "    local sum = 0\n    local i = 1\n    local j = #q\n    while i <= j\
    \ do\n        if q[i] ~= q[j] then\n            return false\n        end\n  \
    \      sum = sum + q[i]\n        i = i + 1\n        j = j - 1\n    end\n    return\
    \ sum <= w\nend", "  -- your code here\n  if is_balanced(q) and sum(q) <= w then\n\
    \    return true\n  else\n    return false\n  end\nend", "  local q_reversed =\
    \ {}\n  local q_sum = 0\n  for i=1, #q do\n    q_reversed[i] = q[#q - i + 1]\n\
    \    q_sum = q_sum + q[i]\n  end\n  if q_sum > w then\n    return false\n  end\n\
    \  for i=1, #q do\n    if q[i] ~= q_reversed[i] then\n      return false\n   \
    \ end\n  end\n  return true\nend", "  -- Hint: if q is balanced and its sum is\
    \ smaller than w, it will fly. \n  --       You have already written a function\
    \ to check if it's balanced (palindrome)\n  --       and a function to compute\
    \ the sum of a list.\n  --       You should use them, or rewrite them!\n  -- ...\n\
    end", "\tif(is_palindrome(q) and get_sum(q) <= w) then\n\t\treturn true\n\telse\n\
    \t\treturn false\n\tend\nend", "  local tmp = {}\n  for i = 1, #q do\n    table.insert(tmp,\
    \ q[i])\n  end\n  local sum = 0\n  local balanced = false\n  for i = 1, #tmp do\n\
    \    sum = sum + tmp[i]\n    if sum > w then\n      return false\n    end\n  \
    \  if i > 1 and q[i] == q[#q] then\n      local tmp_i = q[i]\n      table.remove(q,\
    \ i)\n      table.remove(q, #q)\n      balanced = is_palindrome(q)\n      table.insert(q,\
    \ i, tmp_i)\n      table.insert(q, #q + 1, tmp_i)\n    end\n  end\n  return sum\
    \ <= w and balanced\nend", "    return is_palindrome(q) and sum(q) <= w\nend",
  "    return is_balanced(q) and sum(q) <= w\nend", "    local s = 0;\n    for i =\
    \ 1, #q do\n        s = s + q[i];\n    end\n    return s <= w and true or false;\n\
    end", "\tif not is_balanced(q) then return false end\n\tlocal sum = 0\n\tfor i,\
    \ el in ipairs(q) do\n\t\tsum = sum + el\n\tend\n\treturn sum <= w\nend", "  \
    \ local function is_balanced(q)\n      local is_b\n      if #q == 0 then is_b\
    \ = true\n      elseif #q == 1 then is_b = true\n      elseif #q == 2 then is_b\
    \ = q[1] == q[2]\n      else is_b = (q[1] == q[#q]) and is_balanced(sub(q, 2,\
    \ #q-1))\n      end\n      return is_b\n   end\n   local function sum(q)\n   \
    \   local s = 0\n      for i=1,#q do s = s + q[i] end\n      return s\n   end\n\
    \   return (is_balanced(q) and (sum(q) <= w)) and true or false\nend", "  return\
    \ (math.floor(w) == w) and (math.abs(w) <= math.abs(sum(q))) and is_balanced(q)\n\
    end", "  local function ssum(q)\n    local function aux(q, acc)\n      if q ==\
    \ nil then\n        return acc\n      else\n        return aux(q.next, acc + q.info)\n\
    \      end\n    end\n    return aux(q, 0)\n  end\n  local function palindrome(q)\n\
    \    local function aux(q, acc)\n      if q == nil then\n        return acc\n\
    \      else\n        aux(q.next, {info = q.info, next = acc})\n      end\n   \
    \ end\n    return acc == nil\n  end\n  return ssum(q) <= w and palindrome(q)\n\
    end", "  if (q == nil) then return false end\n  local s = 0\n  for i = 1, #q do\
    \ s = s + q[i] end\n  if (s > w) then return false end\n  local j = #q\n  for\
    \ i = 1, #q do\n    if (q[i] ~= q[j]) then return false end\n    j = j - 1\n \
    \ end\n  return true\nend", "    local p = q\n    for i = 1, #q do\n        p[i]\
    \ = q[#q - i + 1]\n    end\n    local result = false\n    local sum = 0\n    for\
    \ i = 1, #q do\n        sum = sum + q[i]\n        if sum <= w then\n         \
    \   result = true\n        end\n    end\n    for i = 1, #q do\n        if p[i]\
    \ ~= q[i] then\n            result = false\n        end\n    end\n    return result\n\
    end\nprint(will_it_fly({3, 2, 3}, 6))", "  \n  -- is balanced\n  local function\
    \ is_balanced(q)\n    local len = #q\n    for i = 1, len/2 do\n      if q[i] ~=\
    \ q[len-i+1] then\n        return false\n      end\n    end\n    return true\n\
    \  end\n  \n  -- sum elements\n  local function sum_elements(q)\n    local total\
    \ = 0\n    for _, item in ipairs(q) do\n      total = total + item\n    end\n\
    \    return total\n  end\n  \n  if is_balanced(q) and sum_elements(q) <= w then\n\
    \    return true\n  else\n    return false\n  end\nend", "\tlocal function sum(l)\n\
    \t\tlocal res = 0\n\t\tfor _, v in ipairs(l) do\n\t\t\tres = res + v\n\t\tend\n\
    \t\treturn res\n\tend\n\tlocal function reverse(l)\n\t\tlocal res = {}\n\t\tfor\
    \ i = #l, 1, -1 do\n\t\t\tres[#res + 1] = l[i]\n\t\tend\n\t\treturn res\n\tend\n\
    \tlocal function is_palindrome(l)\n\t\treturn l == reverse(l)\n\tend\n\treturn\
    \ is_palindrome(q) and sum(q) <= w\nend\nassert(not will_it_fly({1, 2}, 5))\n\
    assert(not will_it_fly({3, 2, 3}, 5))\nassert(will_it_fly({3, 2, 3}, 8))\nassert(will_it_fly({3},\
    \ 5))", "\tlocal s = 0\n\tlocal l = table.getn(q)\n\tlocal r = math.ceil(l/2)\n\
    \tfor i = 1, r do\n\t\ts = s + q[i]\n\t\tif q[i] ~= q[l - i + 1] then\n\t\t\t\
    return false\n\t\tend\n\tend\n\treturn s <= w\nend", "  return (is_balanced(q)\
    \ and sum(q) <= w)\nend", "\tlocal s = 0\n\tlocal n = #q\n\tfor i = 1, n do\n\t\
    \ts = s + q[i]\n\t\tif s > w then\n\t\t\treturn false\n\t\tend\n\tend\n\tfor i\
    \ = 1, n do\n\t\tif q[i] ~= q[n-i+1] then\n\t\t\treturn false\n\t\tend\n\tend\n\
    \treturn true\nend", "    local list, weight = 0, 0\n    for k,v in pairs(q) do\n\
    \        list = list .. tostring(v)\n        weight = weight + v\n    end\n  \
    \  local str = tostring(list)\n    local reverse = str:reverse()\n    if str ==\
    \ reverse and weight <= w then\n        return true\n    else\n        return\
    \ false\n    end\nend", "\tlocal sum = 0\n\tlocal is_balanced = true\n\tlocal\
    \ l = #q\n\tfor i = 1, l do\n\t\tsum = sum + q[i]\n\t\tif q[i] ~= q[l - i + 1]\
    \ then\n\t\t\tis_balanced = false\n\t\tend\n\tend\n\treturn is_balanced and sum\
    \ <= w\nend", "    local sum = 0\n    for i = 1, #q do\n        sum = sum + q[i]\n\
    \    end\n    if sum <= w then\n        return true\n    else\n        return\
    \ false\n    end\nend", "    return is_balanced(q) and sum(q) <= w\nend", "  \
    \  if type(q) ~= \"table\" then return false end\n    if #q <= 1 then return true\
    \ end\n    local s = 0\n    for _, v in ipairs(q) do\n        s = s + v\n    end\n\
    \    if s > w then return false end\n    local i, j = 1, #q\n    while i < j do\n\
    \        if q[i] ~= q[j] then return false end\n        i = i + 1\n        j =\
    \ j - 1\n    end\n    return true\nend", "    local sum = 0\n    for i = 1, #q\
    \ do\n        sum = sum + q[i]\n    end\n    if sum <= w then\n        for i =\
    \ 1, #q do\n            if q[i] ~= q[#q - i + 1] then\n                return\
    \ false\n            end\n        end\n        return true\n    end\n    return\
    \ false\nend", "    local res = 0\n    for i = 1, #q do\n        res = res + q[i]\n\
    \    end\n    if res <= w then\n        return true\n    else\n        return\
    \ false\n    end\nend", "  local sum = 0\n  for _, v in ipairs(q) do\n    sum\
    \ = sum + v\n  end\n  if sum > w then\n    return false\n  end\n  for i=1, #q/2\
    \ do\n    if q[i] ~= q[#q-i+1] then\n      return false\n    end\n  end\n  return\
    \ true\nend", "  local sum = 0\n  for i,v in ipairs(q) do\n    sum = sum + v\n\
    \  end\n  return (sum <= w) and isPalindrome(q)\nend", "  return is_palindrome(q)\
    \ and sum(q) <= w\nend", "    local sum = 0\n    for i, j in ipairs(q) do\n  \
    \      sum = sum + j\n    end\n    if sum <= w then\n        if #q ~= 0 then\n\
    \            if tonumber(table.concat(q)) == tonumber(table.concat(reverse(q)))\
    \ then\n                return true\n            else\n                return\
    \ false\n            end\n        else\n            return false\n        end\n\
    \    else\n        return false\n    end\nend", "    if type(q) ~= \"table\" then\n\
    \        return false\n    end\n    local total = 0\n    for i = 1, #q do\n  \
    \      total = total + q[i]\n    end\n    if total > w then\n        return false\n\
    \    end\n    if #q % 2 == 0 then\n        return false\n    end\n    local last\
    \ = #q\n    for i = 1, math.floor(#q / 2) do\n        if q[i] ~= q[last] then\n\
    \            return false\n        end\n        last = last - 1\n    end\n   \
    \ return true\nend", "\tif type(q) ~= \"table\" then return end\n\t-- hmm, I think\
    \ that's wrong. I guess it has to be a list of numbers\n\tif type(w) ~= \"number\"\
    \ then return end\n\t-- check q is balanced\n\tlocal q_rev = {}\n\tfor i = #q,\
    \ 1, -1 do\n\t\tq_rev[#q_rev+1] = q[i]\n\tend\n\tlocal sum = 0\n\tfor i = 1, #q\
    \ do\n\t\tif q[i] ~= q_rev[i] then return false end\n\t\tsum = sum + q[i]\n\t\
    end\n\treturn sum <= w\nend", "    -- Function to check if the list is palindromic\n\
    \    local function isPalindrome(q)\n        -- In order to recognize a palindrome,\
    \ we can just check\n        -- if the first element of the list is equal to the\
    \ last one,\n        -- the second is equal to the penultimate and so on.\n  \
    \      local len = #q\n        for i = 1, len/2 do\n            if q[i] ~= q[len-i+1]\
    \ then\n                return false\n            end\n        end\n        return\
    \ true\n    end", "\tlocal sum = 0\n\tfor i = 1, #q do\n\t\tsum = sum + q[i]\n\
    \tend\n\tif sum <= w then\n\t\tfor i = 1, #q / 2 do\n\t\t\tif q[i] ~= q[#q - i\
    \ + 1] then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\t\treturn true\n\tend\n\
    \treturn false\nend", "\tlocal s = 0\n\tfor _, v in ipairs(q) do\n\t\ts = s +\
    \ v\n\tend\n\treturn s <= w and is_palindrome(q)\nend", "  return (w >= sum_list(q))\
    \ and (is_palindrome(q))\nend", "\tlocal sum = 0\n\tlocal palindrome = true\n\t\
    for i, v in ipairs(q) do\n\t\tif palindrome and (q[i] ~= q[#q-i+1]) then\n\t\t\
    \tpalindrome = false\n\t\tend\n\t\tsum = sum + v\n\tend\n\treturn palindrome and\
    \ (sum <= w)\nend", "    -- Count total weight.\n    local total = 0\n    for\
    \ _, p in ipairs(q) do\n        total = total + p\n    end\n    -- Check if the\
    \ list is balanced and if the total weight is less than w.\n    return total <=\
    \ w and is_palindrome(q)\nend", "   return check_balanced(q) and check_weight(q,\
    \ w)\nend", "\treturn is_balanced(q) and sum(q) <= w\nend", "    if type(q) ~=\
    \ \"table\" then return false end\n    if not is_palindrome(q) then return false\
    \ end\n    if not is_consecutive(q) then return false end\n    if not is_ascending(q)\
    \ then return false end\n    if not is_descending(q) then return false end\n \
    \   if q[1] ~= 1 then return false end\n    local sum = 0\n    for i = 1, #q do\n\
    \        sum = sum + q[i]\n    end\n    if sum > w then return false end\n   \
    \ return true\nend", "  -- return nil\nend", "    local sum = 0\n    for i = 1,\
    \ #q do\n        sum = sum + q[i]\n    end\n    local half = math.floor(#q / 2)\n\
    \    local lst = {}\n    for i = 1, half do\n        lst[i] = q[i]\n    end\n\
    \    local a = #q\n    local b = half\n    if #q % 2 == 1 then\n        a = a\
    \ - 1\n    end\n    while a > half do\n        if lst[b] ~= q[a] then\n      \
    \      return false\n        end\n        a = a - 1\n        b = b - 1\n    end\n\
    \    if sum <= w then\n        return true\n    end\n    return false\nend", " \
    \   local sum = 0\n    for i, e in ipairs(q) do\n        sum = sum + e\n    end\n\
    \    if sum > w then\n        return false\n    end\n    local reversed = {}\n\
    \    for i, e in ipairs(q) do\n        reversed[#q - i + 1] = e\n    end\n   \
    \ for i, e in ipairs(q) do\n        if q[i] ~= reversed[i] then\n            return\
    \ false\n        end\n    end\n    return true\nend", "\tlocal sum = 0\n\tfor\
    \ i = 1, #q do\n\t\tsum = sum + q[i]\n\tend\n\tlocal is_balanced = sum <= w\n\t\
    local is_palindromic = true\n\tfor i = 1, #q do\n\t\tif q[i] ~= q[#q - i + 1]\
    \ then\n\t\t\tis_palindromic = false\n\t\t\tbreak\n\t\tend\n\tend\n\treturn is_balanced\
    \ and is_palindromic\nend", "  return #q > 0 and sum(q) <= w and is_palindrome(q)\n\
    end", "\tlocal sum = 0\n\tfor i = 1, #q do\n\t\tsum = sum + q[i]\n\tend\n\tif\
    \ not is_palindrome(q) or sum > w then\n\t\treturn false\n\telse\n\t\treturn true\n\
    \tend\nend", "\tlocal sum = 0\n\tlocal is_balanced = true\n\tlocal head, tail\
    \ = 1, #q\n\twhile head <= tail do\n\t\tsum = sum + q[head] + q[tail]\n\t\tif\
    \ q[head] ~= q[tail] then\n\t\t\tis_balanced = false\n\t\tend\n\t\thead = head\
    \ + 1\n\t\ttail = tail - 1\n\tend\n\treturn is_balanced and sum <= w\nend", " \
    \   local p = table.remove(q)\n    local sum = 0\n    for i, n in ipairs(q) do\n\
    \        sum = sum + n\n    end\n    if sum <= w and p == nil then\n        return\
    \ true\n    elseif sum <= w and q[#q] == p then\n        table.remove(q)\n   \
    \     return will_it_fly(q, w)\n    else\n        return false\n    end\nend",
  "    local s = 0\n    for _, v in ipairs(q) do\n        s = s + v\n    end\n   \
    \ if s > w then\n        return false\n    end\n    local h = math.floor(#q /\
    \ 2)\n    for i = 1, h do\n        if q[i] ~= q[#q - i + 1] then\n           \
    \ return false\n        end\n    end\n    return true\nend", "    local total\
    \ = 0\n    local result = true\n    if #q > 0 then\n        total = q[1]\n   \
    \     if #q > 1 then\n            if q[1] ~= q[#q] then\n                result\
    \ = false\n            else\n                for i=2, #q do\n                \
    \    total = total + q[i]\n                    if q[i] ~= q[#q+1-i] then\n   \
    \                     result = false\n                        break\n        \
    \            end\n                end\n            end\n        end\n    end\n\
    \    if total > w then\n        result = false\n    end\n    return result\nend",
  "\t-- check whether it's balanced\n\tlocal n = #q\n\tfor i = 1, n/2 do\n\t\tif q[i]\
    \ ~= q[n-i+1] then\n\t\t\treturn false\n\t\tend\n\tend\n\t\n\t-- check whether\
    \ it's lighter than the maximum weight\n\tlocal sum = 0\n\tfor i = 1, n do\n\t\
    \tsum = sum + q[i]\n\tend\n\tif sum > w then\n\t\treturn false\n\tend\n\t\n\t\
    return true\nend", "  return \nend", "\treturn (sum(q) <= w) and is_balanced(q)\n\
    end", "    local qr = rtl(q)\n    if not is_palindrome(q) then\n        return\
    \ false\n    end\n    return sum(q) <= w\nend", "    if #q > w then\n        return\
    \ false\n    end\n    for i=1, #q do\n        local left = 0\n        local right\
    \ = 0\n        for j=1, i do\n            left = left + q[j]\n        end\n  \
    \      for j=#q, #q-i+1, -1 do\n            right = right + q[j]\n        end\n\
    \        if left == right then\n            if left <= w then\n              \
    \  return true\n            end\n        end\n    end\n    return false\nend",
  "    local sum = 0\n    for _, el in ipairs(q) do\n        sum = sum + el\n    end\n\
    \    if sum > w then\n        return false\n    end\n    for i = 1, #q / 2 do\n\
    \        if q[i] ~= q[#q - i + 1] then\n            return false\n        end\n\
    \    end\n    return true\nend", "  local qs = check_palindrome(q)\n  local sum\
    \ = 0\n  for i = 1, #q do\n    sum = sum + q[i]\n  end\n  if qs and sum <= w then\n\
    \    return true\n  else\n    return false\n  end\nend", "\tif #q < 2 then return\
    \ true end\n\treturn will_it_fly(q[2], w) and w >= table.unpack(q)\nend", "  \
    \  local sum = 0;\n    local queue = {};\n    for i, v in ipairs(q) do\n     \
    \   sum = sum + v;\n        queue[i] = v;\n    end\n    if sum > w then\n    \
    \    return false;\n    end\n    local n = #queue;\n    if n <= 1 then\n     \
    \   return true;\n    end\n    local begin = 1;\n    local finish = n;\n    while\
    \ begin < finish do\n        if queue[begin] ~= queue[finish] then\n         \
    \   return false;\n        end\n        begin = begin + 1;\n        finish = finish\
    \ - 1;\n    end\n    return true;\nend", "  local sum = 0\n  local reverse = {}\n\
    \  local list = {}\n  local str = \"\"\n  local i = 1\n  local j = 1\n  while\
    \ i <= #q do\n    table.insert(list, q[i])\n    i = i + 1\n  end\n  while j <=\
    \ #q do\n    table.insert(reverse, q[#q - j + 1])\n    j = j + 1\n  end\n  for\
    \ i, v in ipairs(list) do\n    sum = sum + v\n  end\n  for i, v in ipairs(list)\
    \ do\n    str = str .. \" \" .. v\n  end\n  if sum <= w and str == table.concat(reverse,\
    \ \" \") then\n    return true\n  else\n    return false\n  end\nend", "    local\
    \ sum = 0\n    local q1 = {}\n    local q2 = {}\n    for _, x in ipairs(q) do\n\
    \        sum = sum + x\n        q1[#q1+1] = x\n        q2[#q2+1] = x\n    end\n\
    \    if (sum > w) then\n        return false\n    end\n    table.sort(q1)\n  \
    \  table.sort(q2, function(a, b) return a > b end)\n    for k, v in ipairs(q1)\
    \ do\n        if (q1[k] ~= q2[k]) then\n            return false\n        end\n\
    \    end\n    return true\nend", "  if sum(q) <= w and is_palindrome(q) then\n\
    \    return true\n  else\n    return false\n  end\nend", "  local balanced = true\n\
    \  local weight = 0\n  local max_weight = w\n  local n = #q\n  if #q == 0 then\n\
    \    return true\n  end\n  for i = 1, n/2 do\n    if (q[i] ~= q[n - i + 1]) then\n\
    \      balanced = false\n    end\n    weight = weight + q[i] + q[n - i + 1]\n\
    \  end\n  if n % 2 == 1 then\n    weight = weight + q[(n + 1)/2]\n  end\n  return\
    \ balanced and weight <= max_weight\nend", "  local l = #q\n  local sum = 0\n\
    \  for i = 1, l / 2 do\n    sum = sum + q[i]\n    if not q[i] == q[l - i + 1]\
    \ then\n      return false\n    end\n  end\n  if l % 2 == 1 then\n    sum = sum\
    \ + q[(l + 1) / 2]\n  end\n  return sum <= w\nend", "    -- YOUR CODE HERE\nend",
  "  if is_palindrome(q) and sum(q) <= w then\n    return true\n  else\n    return\
    \ false\n  end\nend", "\t-- sum of elements of list\n\tlocal sum = 0\n\tfor _,\
    \ v in ipairs(q) do\n\t\tsum = sum + v\n\tend\n\t-- check palindrome\n\tfor i\
    \ = 1, #q / 2 do\n\t\tif q[i] ~= q[#q - i + 1] then\n\t\t\treturn false\n\t\t\
    end\n\tend\n\t-- check sum\n\tif sum <= w then\n\t\treturn true\n\telse\n\t\t\
    return false\n\tend\nend", "  local weight = 0\n  for i, v in ipairs(q) do\n \
    \   weight = weight + v\n  end\n  if weight <= w then\n    return true\n  else\n\
    \    return false\n  end\nend", "  local sum = 0\n  local balanced = true\n  local\
    \ i = 1\n  local j = #q\n  while (i <= j) do\n    if q[i] ~= q[j] then\n     \
    \ balanced = false\n      break\n    end\n    sum = sum + q[i]\n    i = i + 1\n\
    \    j = j - 1\n  end\n  return sum <= w and balanced\nend", "\tlocal len, s =\
    \ 1, 0\n\twhile q[len] do\n\t\ts = s + q[len]\n\t\tlen = len + 1\n\tend\n\tif\
    \ s > w then return false end\n\tlocal i, j = 1, len\n\twhile i < j do\n\t\tif\
    \ q[i] ~= q[j] then return false end\n\t\ti = i + 1\n\t\tj = j - 1\n\tend\n\t\
    return true\nend", "  local sum = function(a, b) return a + b end\n  if is_palindrome(q)\
    \ and w >=  foldr(sum, 0, q) then\n    return true\n  else\n    return false\n\
    \  end\nend", "\tlocal balanced = false\n\tlocal sum = 0\n\t\n\tfor i = 1, #q\
    \ / 2 do\n\t\tif q[i] == q[#q - i + 1] then \n\t\t\tbalanced = true\n\t\telse\n\
    \t\t\tbalanced = false\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\tfor _, v in ipairs(q)\
    \ do\n\t\tsum = sum + v\n\tend\n\t\n\tif balanced and sum <= w then\n\t\treturn\
    \ true\n\telse\n\t\treturn false\n\tend\nend", "\treturn is_palindrome(q) and\
    \ is_balanced(q, w)\nend", "\tif q == nil then\n\t\treturn true\n\tend\n\tif not\
    \ is_palindrome(q) then\n\t\treturn false\n\tend\n\t\n\tlocal total_weight = 0\n\
    \tfor _,v in ipairs(q) do\n\t\ttotal_weight = total_weight + v\n\tend\n\tif total_weight\
    \ > w then\n\t\treturn false\n\tend\n\treturn true\nend", "  -- variables\n  local\
    \ acc = 0\n  local qLen = table.getn(q)\n  -- body\n  if qLen > 1 then\n    if\
    \ qLen % 2 == 0 then\n      for i = 1, qLen/2 do\n        acc = acc + q[i]\n \
    \     end\n      for i = qLen/2 + 1, qLen do\n        acc = acc - q[i]\n     \
    \ end\n    else\n      for i = 1, math.floor(qLen/2) do\n        acc = acc + q[i]\n\
    \      end\n      for i = math.floor(qLen/2) + 2, qLen do\n        acc = acc -\
    \ q[i]\n      end\n    end\n  end\n  return acc <= w\nend", "  local sum = 0\n\
    \  local state = true\n  for i = 1, #q do\n    if q[i] ~= q[#q-i+1] then\n   \
    \   state = false\n    end\n    sum = sum + q[i]\n  end\n  if state and sum <=\
    \ w then\n    return true\n  else\n    return false\n  end\nend", "\t-- Test if\
    \ the object is a palindrome.\n\tif not is_palindrome(q) then\n\t\treturn false\n\
    \tend\n\t-- Test if the object's total weight is less than the maximum possible\
    \ weight.\n\tlocal weight = 0\n\tfor _, v in ipairs(q) do\n\t\tweight = weight\
    \ + v\n\tend\n\tif weight > w then\n\t\treturn false\n\tend\n\treturn true\nend",
  "    return is_balanced(q) and sum(q) <= w\nend", "    local s, f = 0, true\n  \
    \  for i = 1, #q do\n        s = s + q[i]\n        if q[i] ~= q[#q - i + 1] then\n\
    \            f = false\n        end\n    end\n    return f and s <= w\nend", " \
    \  if #q == 0 then return false end\n   local sum, half = 0, math.floor(#q / 2)\n\
    \   for i = 1, half do\n      if q[i] ~= q[#q - i + 1] then return false end\n\
    \      sum = sum + q[i]\n   end\n   if #q % 2 == 1 then sum = sum + q[half + 1]\
    \ end\n   return sum <= w\nend", "\tlocal sum = 0\n\tlocal ok = true\n\tfor i\
    \ = 1, #q / 2 do\n\t\tif q[i] ~= q[#q - i + 1] then\n\t\t\tok = false\n\t\t\t\
    break\n\t\tend\n\t\tsum = sum + q[i]\n\tend\n\treturn ok and sum <= w\nend", " \
    \ local i = 1\n  local j = #q\n  local weight = 0\n  while i <= j do\n    if q[i]\
    \ ~= q[j] then\n      return false\n    end\n    weight = weight + q[i]\n    i\
    \ = i + 1\n    j = j - 1\n  end\n  return weight <= w\nend", "  local sum = 0\n\
    \  for i = 1, #q do\n    sum = sum + q[i]\n  end\n  local flag = true\n  for i\
    \ = 1, #q / 2 do\n    if q[i] ~= q[#q - i + 1] then\n      flag = false\n    \
    \  break\n    end\n  end\n  return sum <= w and flag\nend", "\tlocal sum = 0\n\
    \tlocal len = #q\n\tfor i=1, len do\n\t\tsum = sum + q[i]\n\tend\n\tif sum > w\
    \ then\n\t\treturn false\n\tend\n\tlocal i = 1\n\tlocal j = len\n\twhile (i <=\
    \ j) do\n\t\tif q[i] ~= q[j] then\n\t\t\treturn false\n\t\tend\n\t\ti = i + 1\n\
    \t\tj = j - 1\n\tend\n\treturn true\nend", "  local len = #q\n  local sum = 0\n\
    \  for i = 1, math.floor(len / 2) do\n    if q[i] ~= q[len - i + 1] then\n   \
    \   return false\n    end\n    sum = sum + q[i]\n  end\n  if len % 2 == 1 then\n\
    \    sum = sum + q[math.floor(len / 2) + 1]\n  end\n  return sum <= w\nend", " \
    \ -- code here\nend", "    local is_palindrome = function (q)\n        for i=1,math.floor(#q/2)\
    \ do\n            if q[i] ~= q[#q-i+1] then\n                return false\n  \
    \          end\n        end\n        return true\n    end\n    local sum = function\
    \ (q)\n        local s = 0\n        for _,v in ipairs(q) do\n            s = s\
    \ + v\n        end\n        return s\n    end\n    return is_palindrome(q) and\
    \ sum(q) <= w\nend", "    local reversedQ = table.reverse(q)\n    local sum =\
    \ 0\n    for i = 1, #q do\n        sum = sum + q[i]\n    end\n    if sum > w then\n\
    \        return false\n    elseif sum <= w then\n        for i = 1, #q do\n  \
    \          if q[i] ~= reversedQ[i] then\n                return false\n      \
    \      end\n        end\n        return true\n    end\nend\nassert(will_it_fly({3,\
    \ 2, 3}, 5) == false)\nassert(will_it_fly({1, 2, 3}, 5) == false)\nassert(will_it_fly({3,\
    \ 2, 3}, 6) == true)\nassert(will_it_fly({1}, 1) == true)\nassert(will_it_fly({11,\
    \ 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\
    \ 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\
    \ 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\
    \ 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\
    \ 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\
    \ 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\
    \ 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\
    \ 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\
    \ 11, 11, 11, 11, 11, 11, 11, 11, 11", "    return true\nend", "\t-- stub\nend",
  "  if #q == 0 then return true end\n  local p1, p2 = 1, #q\n  while q[p1] == q[p2]\
    \ and p1 < p2 do\n    p1 = p1 + 1\n    p2 = p2 - 1\n  end\n  if p1 >= p2 then\
    \ return sum(q) <= w end\n  return false\nend", "    if is_balanced(q) then\n\
    \        if sum(q) <= w then\n            return true\n        end\n    end\n\
    \    return false\nend", "  local s = table.reduce(q, function(a, b) return a\
    \ + b end)\n  local f = palindrome(q)\n  return f and s <= w\nend", "   return\
    \ (is_balanced(q) and sum(q) <= w)\nend", "  local f = true\n  local sum = 0\n\
    \  for i=1, #q do\n    sum = sum + q[i]\n    if i <= #q/2 then\n      if q[i]\
    \ ~= q[#q-i+1] then\n        f = false\n      end\n    end\n  end\n  if sum >\
    \ w then\n    f = false\n  end\n  return f\nend", "\tlocal m,d = 0, #q\n\tfor\
    \ i=1,d/2 do\n\t\tm = m + q[i] + q[d-i+1]\n\tend\n\tif d%2 ~= 0 then m = m + q[(d+1)/2]\
    \ end\n\treturn m <= w\nend", "\treturn w >= sum(q) and is_palindrome(q)\nend",
  "\tif (type(q) ~= \"table\") then\n\t\treturn false\n\tend\n\t\n\tlocal q_clone\
    \ = clone(q)\n\tlocal q_rev_clone = clone(q)\n\tlocal q_rev = reverse(q_rev_clone)\n\
    \tlocal q_sum = sum(q_clone)\n\t\n\tif (q_sum > w) then\n\t\treturn false\n\t\
    end\n\t\n\tif (is_equal(q, q_rev)) then\n\t\treturn true\n\tend\n\t\n\treturn\
    \ false\nend", "  -- your code here\nend", '  local sum = 0;', "    return ((#q\
    \ == 0) or\n            ((q[1] == q[#q]) and\n             will_it_fly(list.slice(q,\
    \ 2, #q - 1), w))\n            ) and\n           (list.sum(q) <= w)\nend", " \
    \   local balanced = false\n    local sum = 0\n    for k, v in ipairs(q) do\n\
    \        sum = sum + v\n    end\n    if q[1] == q[#q] then\n        local new_q\
    \ = {}\n        for i=2, #q-1 do\n            table.insert(new_q, q[i])\n    \
    \    end\n        q = new_q\n        balanced = true\n    end\n    if sum <= w\
    \ and balanced then\n        return true\n    else\n        return false\n   \
    \ end\nend", "    if is_balanced(q) and sum(q) <= w then\n        return true\n\
    \    else\n        return false\n    end\nend", "\tlocal reverse = {}\n\tlocal\
    \ total = 0\n\tfor i = 1, #q do\n\t\ttotal = total + q[i]\n\t\treverse[#q-i+1]\
    \ = q[i]\n\tend\n\tif total > w then\n\t\treturn false\n\tend\n\tfor i = 1, #q\
    \ do\n\t\tif q[i] ~= reverse[i] then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn\
    \ true\nend", "  local sum = 0\n  for i = 1, #q do\n    sum = sum + q[i]\n  end\n\
    \  if sum <= w then\n    local left = 1\n    local right = #q\n    while left\
    \ < right do\n      if q[left] ~= q[right] then\n        return false\n      end\n\
    \      left = left + 1\n      right = right - 1\n    end\n    return true\n  end\n\
    \  return false\nend", "  -- Write your code here\n  local total = 0;\n  local\
    \ palindrome = true;\n  for i=1,#q do\n    if q[i] ~= q[#q - i + 1] then\n   \
    \   palindrome = false;\n    end\n    total = total + q[i];\n  end\n  return total\
    \ <= w and palindrome;\nend", "  local sum = 0\n  for _,v in ipairs(q) do\n  \
    \  sum = sum + v\n  end\n  if sum > w then\n    return false\n  end\n  for i=1,\
    \ #q//2 do\n    if q[i] ~= q[#q-i+1] then\n      return false\n    end\n  end\n\
    \  return true\nend", "  if sum(q) > w then return false end\n  for i = 1, #q\
    \ do\n    if q[i] ~= q[#q - i + 1] then return false end\n  end\n  return true\n\
    end", "\tlocal len = #q\n\tlocal i = 1\n\tlocal j = len\n\tlocal sum = 0\n\twhile\
    \ i <= j do\n\t\tif q[i] ~= q[j] then\n\t\t\treturn false\n\t\tend\n\t\tsum =\
    \ sum + q[i]\n\t\ti = i + 1\n\t\tj = j - 1\n\tend\n\treturn sum <= w\nend", "\t\
    local sum = 0\n\tfor _, v in ipairs(q) do\n\t\tsum = sum + v\n\tend\n\tif sum\
    \ > w then return false end\n\tfor i = 1, #q/2 do\n\t\tif q[i] ~= q[#q - i + 1]\
    \ then return false end\n\tend\n\treturn true\nend", "    local n = #q\n    local\
    \ i = 1\n    local j = n\n    local s = 0\n    while i < j do\n        if q[i]\
    \ == q[j] then\n            s = s + q[i] + q[j]\n            i = i + 1\n     \
    \       j = j - 1\n        else\n            break\n        end\n    end\n   \
    \ if i == j then\n        s = s + q[i]\n    end\n    return s <= w\nend\nprint(will_it_fly({1,\
    \ 2}, 5)) \nprint(will_it_fly({3, 2, 3}, 5)) \nprint(will_it_fly({3, 2, 3}, 10))\
    \ \nprint(will_it_fly({3}, 5)) ", "  return is_palindrome(q) and (sum(q) <= w)\n\
    end", "  -- \u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u0443\u0435\u043C\
    \ \u0432 \u0441\u0442\u0440\u043E\u043A\u0443, \u043F\u0440\u0438 \u043F\u043E\
    \u043C\u043E\u0449\u0438 \u043C\u0435\u0442\u043E\u0434\u0430 gsub \u0437\u0430\
    \u043C\u0435\u043D\u044F\u0435\u043C \u0432\u0441\u0435 \u044D\u043B\u0435\u043C\
    \u0435\u043D\u0442\u044B \u0441\u043F\u0438\u0441\u043A\u0430 \u043D\u0430 \u043F\
    \u0443\u0441\u0442\u043E\u0435 \u043C\u0435\u0441\u0442\u043E\n  -- \u0438 \u043F\
    \u0440\u0438 \u043F\u043E\u043C\u043E\u0449\u0438 \u043C\u0435\u0442\u043E\u0434\
    \u0430 \u0441\u0442\u0440\u043E\u043A\u0438 reverse \u043F\u0435\u0440\u0435\u0432\
    \u043E\u0440\u0430\u0447\u0438\u0432\u0430\u0435\u043C \u0441\u0442\u0440\u043E\
    \u043A\u0443, \u0437\u0430\u0442\u0435\u043C \u043E\u0431\u0440\u0430\u0442\u043D\
    \u043E \u0432 \u0442\u0430\u0431\u043B\u0438\u0446\u0443\n  -- \u0414\u0430\u043B\
    \u0435\u0435 \u0441\u0440\u0430\u0432\u043D\u0438\u0432\u0430\u0435\u043C \u0442\
    \u0430\u0431\u043B\u0438\u0446\u044B \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\
    \u044E \u0444\u0443\u043D\u043A\u0446\u0438\u0438 \u0442\u0430\u0431\u043B\u0438\
    \u0446\u044B equal, \u0447\u0442\u043E\u0431\u044B \u0432\u044B\u044F\u0441\u043D\
    \u0438\u0442\u044C \u043F\u0430\u043B\u0438\u043D\u0434\u0440\u043E\u043C \u043B\
    \u0438 \u044D\u0442\u043E\n  local function ispalindrome(q)\n    return (string.gsub(q,\
    \ '', '') == string.reverse(string.gsub(q, '', '')))\n  end\n  -- \u0421 \u043F\
    \u043E\u043C\u043E\u0449\u044C\u044E \u0444\u0443\u043D\u043A\u0446\u0438\u0438\
    \ reduce \u043F\u043E\u043B\u0443\u0447\u0430\u0435\u043C \u0441\u0443\u043C\u043C\
    \u0443 \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432\n  local function\
    \ sum(q)\n    return reduce(q, function(a, b) return a + b end)\n  end\n  -- \u0421\
    \ \u043F\u043E\u043C\u043E\u0449\u044C\u044E \u0444\u0443\u043D\u043A\u0446\u0438\
    \u0438 map \u0437\u0430\u043F\u0438\u0441\u044B\u0432\u0430\u0435\u043C \u043D\
    \u043E\u0432\u0443\u044E \u0442\u0430\u0431\u043B\u0438\u0446\u0443 \u0432 \u043A\
    \u043E\u0442\u043E\u0440\u043E\u0439 \u043A\u0430\u0436\u0434\u044B\u0439 \u044D\
    \u043B\u0435\u043C\u0435\u043D\u0442 \u043F\u043E\u043B\u0443\u0447\u0430\u0435\
    \u0442 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0435\u0434\u0438\u043D\
    \u0438", "  local function calc_weight(acc, q)\n    if #q == 0 then return acc\
    \ end\n    local x = table.remove(q, 1)\n    local xs = calc_weight(acc + x, q)\n\
    \    table.insert(q, 1, x)\n    return xs\n  end\n  local function is_balanced(q)\n\
    \    if #q == 0 then return true end\n    local x = table.remove(q, 1)\n    local\
    \ xs = is_balanced(q)\n    table.insert(q, 1, x)\n    return xs\n  end\n  return\
    \ is_balanced(q) and calc_weight(0, q) <= w\nend", "\tlocal sum = 0\n\tfor i =\
    \ 1, #q do\n\t\tsum = sum + q[i]\n\tend\n\treturn sum <= w and is_balanced(q)\n\
    end", "    -- Your code goes here!\nend", "    local function is_palindrome(q)\n\
    \        local function reverse(q)\n            local new_q = {}\n           \
    \ for i=#q,1,-1 do\n                table.insert(new_q, q[i])\n            end\n\
    \            return new_q\n        end\n        return q == reverse(q)\n    end\n\
    \    local function sum(q)\n        local total = 0\n        for _,val in ipairs(q)\
    \ do\n            total = total + val\n        end\n        return total\n   \
    \ end\n    return is_palindrome(q) and sum(q) <= w\nend", "    local tot = 0\n\
    \    for i = 1, #q do\n        tot = tot + q[i]\n    end\n    return is_palindrome(q)\
    \ and tot <= w\nend\nprint(will_it_fly({1, 2}, 5)) \nprint(will_it_fly({1, 2,\
    \ 3, 2, 3}, 5)) \nprint(will_it_fly({1, 2, 3, 2, 3}, 10)) \nprint(will_it_fly({1,\
    \ 2, 3}, 5)) ", "   local function is_balanced(q)\n      if #q < 2 then return\
    \ true end\n      local i = 1\n      local j = #q\n      while i < j do\n    \
    \     if q[i] ~= q[j] then return false end\n         i = i + 1\n         j =\
    \ j - 1\n      end\n      return true\n   end\n   local function sum(q)\n    \
    \  local sum = 0\n      for i = 1, #q do\n         sum = sum + q[i]\n      end\n\
    \      return sum\n   end\n   return sum(q) <= w and is_balanced(q)\nend", " \
    \   local qw = 0\n    local p = 1\n    for i, v in ipairs(q) do\n        qw =\
    \ qw + v\n        if qw > w then\n            return false\n        end\n    \
    \    if q[i] ~= q[#q - i + 1] then\n            p = 0\n        end\n    end\n\
    \    return p > 0\nend", "  if table.maxn(q) == 0 then return false end\n  local\
    \ s = 0\n  for _, v in ipairs(q) do\n    s = s + v\n  end\n  return s <= w and\
    \ s == q[1] + q[table.maxn(q)] and will_it_fly(table.remove(q, 1), table.remove(q,\
    \ table.maxn(q)), w)\nend", "    return ((balance(q) and sum(q) <= w) and true\
    \ or false)\nend", "    local wifsum = 0\n    for i, v in ipairs(q) do\n     \
    \   wifsum = wifsum + v\n    end\n    if wifsum <= w then\n        return true\n\
    \    else\n        return false\n    end\nend", "  -- code here\nend", "  local\
    \ qw = 0\n  local rq = {}\n  for _, x in ipairs(q) do\n    qw = qw + x\n    table.insert(rq,\
    \ 1, x)\n  end\n  return qw <= w and table.concat(q, \"\") == table.concat(rq,\
    \ \"\")\nend\nprint(will_it_fly({1, 2}, 5))\nprint(will_it_fly({1, 2, 3, 2, 3},\
    \ 7))\nprint(will_it_fly({1, 2, 3, 2, 3}, 15))\nprint(will_it_fly({1, 2, 3}, 15))",
  "  for i=1, #q, 1 do\n    if q[i] > w then\n      return false\n    end\n  end\n\
    \  local sum = 0\n  for i=1, #q, 1 do\n    sum = sum + q[i]\n  end\n  if sum >\
    \ w then\n    return false\n  end\n  local temp = q\n  reverse(temp)\n  for i=1,\
    \ #q, 1 do\n    if q[i] ~= temp[i] then\n      return false\n    end\n  end\n\
    \  return true\nend", "  if( #q < 2 ) then return true end\n  local n = {}\n \
    \ for i = 1, #q do\n    n[i] = q[#q - i + 1]\n  end\n  if( equal(q, n) and sum(q)\
    \ <= w ) then\n    return true\n  else\n    return false\n  end\nend", "  -- TODO:\
    \ use the functions defined above\nend", "  local w_ = 0\n  for _,v in ipairs(q)\
    \ do\n    w_ = w_ + v\n  end\n  if w_ > w then\n    return false\n  end\n  local\
    \ n = #q\n  for i = 1, n do\n    if q[i] ~= q[n-i+1] then\n      return false\n\
    \    end\n  end\n  return true\nend", "\tlocal total = 0\n\tfor i = 1, #q do\n\
    \t\ttotal = total + q[i]\n\tend\n\tlocal balanced = false\n\tfor i = 1, #q do\n\
    \t\tif (q[i] == q[#q - i + 1]) then\n\t\t\tbalanced = true\n\t\telse\n\t\t\tbalanced\
    \ = false\n\t\t\tbreak\n\t\tend\n\tend\n\tif (total <= w and balanced) then\n\t\
    \treturn true\n\telse\n\t\treturn false\n\tend\nend", "  local s = sum(q)\n  return\
    \ (s <= w) and is_balanced(q)\nend", "\tlocal array = {}\n\tlocal palindromic\
    \ = true\n\tfor k, v in pairs(q) do\n\t\tif palindromic then\n\t\t\tif array[#q-k+1]\
    \ == v then\n\t\t\t\tarray[k] = v\n\t\t\telse\n\t\t\t\tpalindromic = false\n\t\
    \t\tend\n\t\tend\n\tend\n\tlocal sum = 0\n\tfor k, v in pairs(q) do\n\t\tsum =\
    \ sum + v\n\tend\n\treturn palindromic and sum <= w\nend", "    local weight =\
    \ 0\n    for _, item in ipairs(q) do\n        weight = weight + item\n    end\n\
    \    if weight > w then\n        return false\n    end\n    local i = 1\n    local\
    \ j = #q\n    while i < j do\n        if q[i] ~= q[j] then\n            return\
    \ false\n        end\n        i = i + 1\n        j = j - 1\n    end\n    return\
    \ true\nend", "    if #q > 0 then\n        if is_balanced(q) and sum(q) <= w then\n\
    \            return true\n        else\n            return false\n        end\n\
    \    else\n        return false\n    end\nend", "    if q[1] + q[#q] > w then\n\
    \        return false\n    end\n    for i = 1, #q - 1 do\n        if q[i] ~= q[#q\
    \ - i + 1] then\n            return false\n        end\n    end\n    return true\n\
    end", "  return false\nend", "\treturn is_balanced(q) and sum(q) <= w\nend", " \
    \ local sum = 0\n  for i = 1, #q do\n    sum = sum + q[i]\n  end\n  if sum <=\
    \ w then\n    for i = 1, #q/2 do\n      if q[i] ~= q[#q+1-i] then\n        return\
    \ false\n      end\n    end\n    return true\n  end\n  return false\nend", " \
    \ local is_balanced = function(q)\n    return q[1] == q[#q]\n  end\n  local weight\
    \ = function(q)\n    local result = 0\n    for i = 1, #q do\n      result = result\
    \ + q[i]\n    end\n    return result\n  end\n  return weight(q) <= w and is_balanced(q)\n\
    end", "  -- set up initial variables\n  local sum = 0\n  local balanced = true\n\
    \  -- iterate through the list, summing the elements\n  for i = 1, #q do\n   \
    \ sum = sum + q[i]\n  end\n  -- iterate from the start of the list to the halfway\
    \ point, comparing the elements\n  for i = 1, #q/2 do\n    if q[i] ~= q[#q - i\
    \ + 1] then\n      balanced = false\n    end\n  end\n  -- return true if both\
    \ conditions are met, false otherwise\n  if balanced and sum <= w then\n    return\
    \ true\n  else\n    return false\n  end\nend", "    -- check that the queue is\
    \ balanced\n    local qhead = table.remove(q, 1)\n    if #q == 0 then\n      \
    \  table.insert(q, qhead)\n        return false\n    end\n    local qtail = table.remove(q)\n\
    \    if qhead ~= qtail then\n        table.insert(q, qtail)\n        table.insert(q,\
    \ 1, qhead)\n        return false\n    end\n    return will_it_fly(q, w)\nend",
  "  local sum = 0;\n  local stack = {};\n  for i = 1, #q do\n    local a = q[i];\n\
    \    stack[#stack + 1] = a;\n    sum = sum + a;\n    if(sum > w) then\n      return\
    \ false;\n    end\n  end\n  local stackLen = #stack;\n  for i = 1, #q do\n   \
    \ local a = q[i];\n    local b = stack[stackLen];\n    if(a ~= b) then\n     \
    \ return false;\n    end\n    stackLen = stackLen - 1;\n  end\n  return true;\n\
    end", "  local s = 0\n  for _,v in ipairs(q) do\n    s = s + v\n  end\n  if s\
    \ > w then return false end\n  local n = #q\n  for i = 1, n do\n    if q[i] ~=\
    \ q[n-i+1] then return false end\n  end\n  return true\nend", "\tif #q < 2 then\n\
    \t\treturn true\n\tend\n\tif list_sum(q) > w then\n\t\treturn false\n\tend\n\t\
    local a = list_head(q)\n\tlocal b = list_last(q)\n\tlocal c = list_tail(q)\n\t\
    local d = list_init(q)\n\treturn a == b and will_it_fly(c, w) and will_it_fly(d,\
    \ w)\nend", "  local qsum = table.sum(q)\n  return qsum <= w and table.is_palindrome(q)\n\
    end", "  -- your code here\n  -- local sum_num = 0\n  -- for i,v in ipairs(q)\
    \ do\n  --   sum_num = sum_num + v\n  -- end\n  -- if is_balanced(q) and sum_num\
    \ <= w then\n  --   return true\n  -- else\n  --   return false\n  -- end\n  if\
    \ is_balanced(q) and sum(q) <= w then\n    return true\n  else\n    return false\n\
    \  end\nend", "   local sum = 0\n   local len = #q\n   local i = 1\n   while i\
    \ <= len do\n      sum = sum + q[i]\n      i = i + 1\n   end\n   if sum > w then\
    \ return false end\n   local j = 1\n   while j <= math.floor(len/2) do\n     \
    \ if q[j] ~= q[len-j+1] then return false end\n      j = j + 1\n   end\n   return\
    \ true\nend", "    if #q == 0 then\n        return true\n    end\n    -- TODO\
    \ add your code here\n    local s = 0\n    local rev = {}\n    local s = 0\n \
    \   local is_fly = true\n    for i = 1, #q do\n        s = s + q[i]\n        rev[i]\
    \ = q[#q - i + 1]\n    end\n    for i = 1, #q do\n        if q[i] ~= rev[i] then\n\
    \            is_fly = false\n            break\n        end\n    end\n    if s\
    \ <= w and is_fly then\n        return true\n    else\n        return false\n\
    \    end\nend", "    return is_palindrome(q) and sum(q) <= w\nend", "  local sum\
    \ = 0\n  local balanced = true\n  local i = 1\n  while i <= #q do\n    sum = sum\
    \ + q[i]\n    if q[i] ~= q[#q - i + 1] then\n      balanced = false\n    end\n\
    \    i = i + 1\n  end\n  return sum <= w and balanced\nend", "  local tmp = {}\n\
    \  for i,v in ipairs(q) do\n    tmp[#tmp+1] = v\n  end\n  if tmp[1] ~= tmp[#tmp]\
    \ then\n    return false\n  end\n  for i = 1, #tmp - 1 do\n    if tmp[i] ~= tmp[#tmp-i+1]\
    \ then\n      return false\n    end\n  end\n  local sum = 0\n  for i,v in ipairs(q)\
    \ do\n    sum = sum + v\n  end\n  if sum <= w then\n    return true\n  else\n\
    \    return false\n  end\nend", "    -- check if the input is a palindrome\n \
    \   if not is_palindrome(q) then\n        return false\n    end\n    -- check\
    \ if it is not over the maximum weight\n    if sum(q) > w then\n        return\
    \ false\n    end\n    return true\nend", "    local wt = 0\n    local balanced\
    \ = true\n    for i = 1, #q do\n        wt = wt + q[i]\n        if q[i] ~= q[#q\
    \ - i + 1] then\n            balanced = false\n        end\n    end\n    return\
    \ balanced and wt <= w\nend", "  return  ((#q)%2==0) and ((sum(q)+q[1])<=w)\n\
    end", "    if #q == 0 then return true end\n    local head, tail = 0, #q - 1\n\
    \    for i = 0, math.floor(#q / 2) do\n        if q[i] ~= q[#q - i] then return\
    \ false end\n        head = head + q[i]\n        tail = tail - q[i]\n    end\n\
    \    return head + tail <= w\nend", "  local sum = 0\n  local list = {}\n  for\
    \ _, i in ipairs(q) do \n    table.insert(list, i)\n    sum = sum + i\n  end\n\
    \  if (sum <= w) and (euler.is_palindrome(list)) then \n    return true\n  else\n\
    \    return false\n  end\nend", "    -- TODO: add your code here\n    return true\n\
    end", '    if #q == 0 then return false end', "    return is_balanced(q) and w\
    \ >= sum(q)\nend", "   local n = 0\n   for i = 1, #q do\n      n = n + q[i]\n\
    \   end\n   if n > w then\n      return false\n   end\n   for i = 1, #q do\n \
    \     if q[i] ~= q[#q - i + 1] then\n         return false\n      end\n   end\n\
    \   return true\nend", "    local t = table.concat(q) \n    return not(t:reverse()\
    \ == t) and table.sum(q) <= w \nend", "  return w >= sum(q) and is_palindrome(q)\n\
    end", "  return \nend", "  if is_balanced(q) and get_sum(q) <= w then\n    return\
    \ true\n  else\n    return false\n  end\nend", "  local balanced = is_balanced(q)\n\
    \  local sum = sum_list(q)\n  return balanced and sum <= w\nend", "  local function\
    \ palindromic_list(l)\n    return l == reverse(l)\n  end\n  return palindromic_list(q)\
    \ and sum(q) <= w\nend", "   if #q == 0 then\n      return true\n   end\n   local\
    \ q_rev = reverse(q)\n   local q_str = \"\"\n   local q_rev_str = \"\"\n   for\
    \ i = 1, #q do\n      q_str = q_str .. q[i]\n      q_rev_str = q_rev_str .. q_rev[i]\n\
    \   end\n   if q_str == q_rev_str then\n      local sum = 0\n      for i = 1,\
    \ #q do\n         sum = sum + q[i]\n      end\n      if sum <= w then\n      \
    \   return true\n      else\n         return false\n      end\n   else\n     \
    \ return false\n   end\nend", "  return true\nend", "    local sum = 0\n    local\
    \ len = #q\n    local is_equal = true\n    for i=1, math.floor(len/2) do\n   \
    \     if q[i] ~= q[len-i+1] then\n            is_equal = false\n            break\n\
    \        end\n        sum = sum + q[i]\n    end\n    if len % 2 == 1 then\n  \
    \      sum = sum + q[math.floor(len/2+1)]\n    end\n    return sum <= w and is_equal\n\
    end", "    if (sum(q) <= w) and is_balanced(q) then\n        return true\n   \
    \ else\n        return false\n    end\nend", "   local sum = 0\n   for _, v in\
    \ ipairs(q) do\n      sum = sum + v\n   end\n   return sum <= w and is_palindrome(q)\n\
    end\nprint(will_it_fly({1, 2}, 5))\nprint(will_it_fly({1, 2, 3, 2, 3}, 5))\nprint(will_it_fly({1,\
    \ 2, 3, 2, 3}, 10))\nprint(will_it_fly({1, 2, 3}, 5))", "  local len = #q\n  local\
    \ sum = 0\n  local i = 1\n  while i <= len do\n    sum = sum + q[i]\n    i = i\
    \ + 1\n  end\n  if sum > w then\n    return false\n  end\n  local isBalanced =\
    \ true\n  local j = 1\n  while j <= len/2 do\n    if q[j] ~= q[len-j+1] then\n\
    \      isBalanced = false\n      break\n    end\n    j = j + 1\n  end\n  return\
    \ isBalanced\nend", "    if #q == 0 then\n        return false\n    end\n    local\
    \ balanced = true\n    local m = math.floor(#q / 2)\n    for i = 1, m do\n   \
    \     if q[i] ~= q[#q - i + 1] then\n            balanced = false\n          \
    \  break\n        end\n    end\n    local sum = 0\n    for i = 1, #q do\n    \
    \    sum = sum + q[i]\n    end\n    return balanced and sum <= w\nend", "    --\
    \ write your code here\nend", "  local function balanced(t)\n    return t[1] ==\
    \ t[#t] and (#t == 1 or balanced({unpack(t, 2, #t-1)}))\n  end\n  return balanced(q)\
    \ and sum(q) <= w\nend", "    if math.fmod(#q, 2) == 0 then\n        return false\n\
    \    end\n    local mid = math.ceil(#q / 2)\n    local left = q[1]\n    local\
    \ right = q[#q]\n    for i = 2, mid do\n        left = left + q[i]\n        right\
    \ = right + q[#q - i + 1]\n    end\n    if left == right and left <= w then\n\
    \        return true\n    end\n    return false\nend", "\tif #q == 0 then\n\t\t\
    return true\n\tend\n\tif sum(q) > w then\n\t\treturn false\n\tend\n\tif sum(q)\
    \ <= w then\n\t\tlocal newQ = copyQ(q)\n\t\tlocal head = table.remove(newQ, 1)\n\
    \t\tlocal tail = table.remove(newQ, #newQ)\n\t\tif head == tail then\n\t\t\treturn\
    \ will_it_fly(newQ, w)\n\t\telse\n\t\t\treturn false\n\t\tend\n\tend\nend", " \
    \   local sum = 0\n    for i = 1, #q do\n        sum = sum + q[i]\n    end\n \
    \   if (sum <= w) and (sum % 2 == 0) then\n        return true\n    else\n   \
    \     return false\n    end\nend", "    local i, j = 1, #q\n    local sum = 0\n\
    \    while i <= j do\n        if q[i] ~= q[j] then\n            return false\n\
    \        end\n        sum = sum + q[i] + q[j]\n        i = i + 1\n        j =\
    \ j - 1\n    end\n    return sum <= w\nend", "    local p = is_palindrome(q)\n\
    \    local sum = sum(q)\n    if p == true and sum <= w then\n        return true\n\
    \    else\n        return false\n    end\nend", "    return (sum(q) <= w) and\
    \ is_balanced(q)\nend", "    local q_size = #q\n    local total = 0\n    local\
    \ i = 1\n    while i <= q_size do\n        if q[i] ~= q[q_size] then\n       \
    \     return false\n        end\n        total = total + q[i]\n        if total\
    \ > w then\n            return false\n        end\n        i = i + 1\n       \
    \ q_size = q_size - 1\n    end\n    return true\nend", "  return (sum(q) <= w)\
    \ and (is_palindrome(q))\nend", "    -- todo\nend", "    local sum = 0\n    for\
    \ i = 1, #q do\n        sum = sum + q[i]\n    end\n    if sum <= w then\n    \
    \    return is_palindrome(q)\n    end\n    return false\nend", "   return (is_palindrome(q)\
    \ and sum(q) <= w)\nend", "  local balanced = is_palindrome(q)\n  local sum =\
    \ get_sum(q)\n  local result = sum <= w and balanced", "    return is_balanced(q)\
    \ and sum(q) <= w\nend", "  local s = 0\n  local n = 0\n  local m = 0\n  for i,\
    \ t in ipairs(q) do\n    s = s + t\n    n = n + 1\n    if t > m then\n      m\
    \ = t\n    end\n  end\n  return s <= w and (n == 1 or n == 2 * math.floor(n /\
    \ 2) and s == 2 * math.floor(s / 2)) and m < math.floor(s / 2)\nend", "  if #q\
    \ ~= q[1] then return false end\n  if #q == 0 then return true end\n  local sum\
    \ = 0\n  for _, v in ipairs(q) do\n    sum = sum + v\n  end\n  return sum <= w\
    \ and will_it_fly(q[2], w)\nend", "    local sum = 0\n    local result = true\n\
    \    for i = 1, #q do\n        sum = sum + q[i]\n        if result and (q[i] ~=\
    \ q[#q-i+1]) then\n            result = false\n        end\n    end\n    if sum\
    \ > w then\n        result = false\n    end\n    return result\nend", "  local\
    \ palindrome_q = is_palindrome(q)\n  local sum_q = sum(q)\n  return palindrome_q\
    \ and sum_q <= w\nend", "    return w >= sum(q) and is_palindrome(q)\nend", " \
    \   -- Implement the function here.\nend", "\tif #q == 0 then\n\t\treturn true\n\
    \tend\n\treturn math.abs(q[1] - q[#q]) <= 1 and will_it_fly(R(q), w)\nend", " \
    \ local sum = 0\n  for i,v in ipairs(q) do\n    sum = sum + v\n  end\n  return\
    \ palindrome(q) and sum <= w\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
