name: HumanEval_70_strange_sort_list
language: lua
prompt: "-- Given list of integers, return list in strange order.\n-- Strange sorting,\
  \ is when you start with the minimum value,\n-- then maximum of the remaining integers,\
  \ then minimum and so on.\nlocal function strange_sort_list(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = strange_sort_list\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4}), {1, 4, 2, 3})\n    lu.assertEquals(candidate({5,\
  \ 6, 7, 8, 9}), {5, 9, 6, 8, 7})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5}),\
  \ {1, 5, 2, 4, 3})\n    lu.assertEquals(candidate({5, 6, 7, 8, 9, 1}), {1, 9, 5,\
  \ 8, 6, 7})\n    lu.assertEquals(candidate({5, 5, 5, 5}), {5, 5, 5, 5})\n    lu.assertEquals(candidate({}),\
  \ {})\n    lu.assertEquals(candidate({1, 2, 3, 4, 5, 6, 7, 8}), {1, 8, 2, 7, 3,\
  \ 6, 4, 5})\n    lu.assertEquals(candidate({0, 2, 2, 2, 5, 5, -5, -5}), {-5, 5,\
  \ -5, 5, 0, 2, 2, 2})\n    lu.assertEquals(candidate({111111}), {111111})\nend\n\
  \nos.exit(lu.LuaUnit.run())"
completions: ["  local min_ind, min_val = math.min(table.unpack(lst))\n  local max_ind,\
    \ max_val = math.max(table.unpack(lst))\n  local out = {min_val, max_val}\n  table.remove(lst,\
    \ min_ind)\n  table.remove(lst, max_ind - 1)\n  while #lst > 0 do\n    min_ind,\
    \ min_val = math.min(table.unpack(lst))\n    max_ind, max_val = math.max(table.unpack(lst))\n\
    \    out[#out + 1] = min_val\n    out[#out + 1] = max_val\n    table.remove(lst,\
    \ min_ind)\n    table.remove(lst, max_ind - 1)\n  end\n  return out\nend", "\t\
    local min_number = min(lst)\n\tlocal max_number = max(lst)\n\tlocal odd_or_even\
    \ = true\n\tlocal result = {}\n\twhile #lst > 0 do\n\t\tif odd_or_even then\n\t\
    \t\tlocal number = min(lst)\n\t\t\tresult[#result + 1] = number\n\t\t\tdelete_from_list(lst,\
    \ number)\n\t\telse\n\t\t\tlocal number = max(lst)\n\t\t\tresult[#result + 1]\
    \ = number\n\t\t\tdelete_from_list(lst, number)\n\t\tend\n\t\todd_or_even = not\
    \ odd_or_even\n\tend\n\treturn result\nend", "  lst = table.pack(table.unpack(lst))\n\
    \  local N = #lst\n  local sorted = {}\n  for i = 1, N do\n    local end_ind =\
    \ #lst\n    local mini, maxi = 1, end_ind\n    for j = 1, end_ind do\n      if\
    \ lst[j] < lst[mini] then\n        mini = j\n      end\n      if lst[j] > lst[maxi]\
    \ then\n        maxi = j\n      end\n    end\n    table.insert(sorted, table.remove(lst,\
    \ mini))\n    if mini == maxi then\n      if end_ind == 1 then\n        break\n\
    \      end\n      table.insert(sorted, table.remove(lst, mini))\n      break\n\
    \    end\n    table.insert(sorted, table.remove(lst, maxi))\n  end\n  return sorted\n\
    end", "  -- sort list in ascending order\n  table.sort(lst)\n  -- initialize resulting\
    \ list\n  local result = {}\n  -- set initial idx to 1\n  local idx = 1\n  --\
    \ until the list becomes empty\n  while #lst > 0 do\n    -- get idx of the maximum\
    \ value\n    local max_idx = #lst\n    -- and append it to the result list\n \
    \   result[idx] = lst[max_idx]\n    -- remove maximum value from the list\n  \
    \  table.remove(lst, max_idx)\n    -- if there is still anything left in the list\n\
    \    if #lst > 0 then\n      -- get idx of the minimum value\n      local min_idx\
    \ = 1\n      -- and append it to the result list\n      result[idx + 1] = lst[min_idx]\n\
    \      -- remove minimum value from the list\n      table.remove(lst, min_idx)\n\
    \    end\n    -- increment idx by 2\n    idx = idx + 2\n  end\n  -- return resulting\
    \ list\n  return result\nend", "  local n, odd, even = #lst, {}, {}\n  for i =\
    \ 1, n do\n    if i % 2 == 0 then\n      table.insert(even, lst[i])\n    else\n\
    \      table.insert(odd, lst[i])\n    end\n  end\n  table.sort(odd)\n  table.sort(even,\
    \ function(a, b) return a > b end)\n  local res = {}\n  for i = 1, n do\n    if\
    \ i % 2 == 0 then\n      table.insert(res, even[i / 2])\n    else\n      table.insert(res,\
    \ odd[(i + 1) / 2])\n    end\n  end\n  return res\nend", "  local sorted_list\
    \ = {}\n  local ascending = true\n  for _, v in ipairs(lst) do\n    table.insert(sorted_list,\
    \ v)\n  end\n  table.sort(sorted_list)\n  local ret_list = {}\n  while #sorted_list\
    \ > 0 do\n    local value\n    if ascending then\n      value = table.remove(sorted_list,\
    \ 1)\n    else\n      value = table.remove(sorted_list)\n    end\n    table.insert(ret_list,\
    \ value)\n    ascending = not ascending\n  end\n  return ret_list\nend", "  --\
    \ Insert all elements into a set, so we can easily\n  -- access min and max values.\n\
    \  local set = {}\n  for _, v in ipairs(lst) do\n    set[v] = true\n  end", " \
    \ -- Sort list in ascending order.\n  table.sort(lst)\n  -- Initialize minimum\
    \ and maximum index.\n  local min_index = 1\n  local max_index = #lst\n  -- Initialize\
    \ result.\n  local res = {}\n  -- Initialize minimum and maximum to first elements.\n\
    \  res[1] = lst[min_index]\n  res[2] = lst[max_index]\n  -- Initialize index to\
    \ start pushing data in.\n  local index = 3\n  -- Iterate while minimum index\
    \ is less than maximum index.\n  while min_index < max_index do\n    -- Push minimum\
    \ of list to result.\n    res[index] = lst[min_index]\n    -- Increment index\
    \ by 1.\n    index = index + 1\n    -- Push maximum of list to result.\n    res[index]\
    \ = lst[max_index]\n    -- Increment index by 1.\n    index = index + 1\n    --\
    \ Increment minimum index by 1.\n    min_index = min_index + 1\n    -- Decrement\
    \ maximum index by 1.\n    max_index = max_index - 1\n  end\n  -- Return result.\n\
    \  return res\nend", "   if #lst == 0 then\n      return lst\n   end\n   local\
    \ idx = 1\n   local min = lst[idx]\n   for k, v in ipairs(lst) do\n      if v\
    \ < min then\n         min = v\n         idx = k\n      end\n   end\n   table.remove(lst,\
    \ idx)\n   idx = 1\n   local max = lst[idx]\n   for k, v in ipairs(lst) do\n \
    \     if v > max then\n         max = v\n         idx = k\n      end\n   end\n\
    \   table.remove(lst, idx)\n   return {min, max} .. strange_sort_list(lst)\nend",
  "  local lst_len = #lst\n  local result = {}\n  table.sort(lst)\n  for i = 1, lst_len,\
    \ 2 do\n    table.insert(result, lst[i])\n    if i + 1 <= lst_len then\n     \
    \ table.insert(result, lst[lst_len - i + 1])\n    end\n  end\n  return result\n\
    end", "  table.sort(lst)\n  local front, back = {}, {}\n  for i, x in ipairs(lst)\
    \ do\n    if i % 2 == 1 then\n      table.insert(front, x)\n    else\n      table.insert(back,\
    \ 1, x)\n    end\n  end\n  return front\nend", "  -- 1. Find maximum and minimum.\n\
    \  local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n  -- 2. Find\
    \ remaining values, between the maximum and minimum.\n  local remaining = {}\n\
    \  for _, v in ipairs(lst) do\n    if v ~= min and v ~= max then\n      table.insert(remaining,\
    \ v)\n    end\n  end\n  -- 3. Sort remaining values.\n  table.sort(remaining)\n\
    \  -- 4. Construct the sorted list.\n  local out = { min }\n  local asc = true\n\
    \  while #remaining > 0 do\n    if asc then\n      table.insert(out, table.remove(remaining))\n\
    \    else\n      table.insert(out, 1, table.remove(remaining))\n    end\n    asc\
    \ = not asc\n  end\n  table.insert(out, max)\n  return out\nend", "    -- verify\
    \ input\n    assert(is_list(lst), \"strange_sort_list() received invalid parameter\"\
    )\n    assert(#lst > 0, \"input list cannot be empty\")", "  local strange_lst\
    \ = {}\n  while #lst > 0 do\n    table.insert(strange_lst, table.remove(lst, index_min(lst)))\n\
    \    if #lst > 0 then\n      table.insert(strange_lst, table.remove(lst, index_max(lst)))\n\
    \    end\n  end\n  return strange_lst\nend", "    lst = clone(lst)\n    table.sort(lst)\n\
    \    local lst2 = {}\n    local top = #lst\n    local f, b = 1, top\n    while\
    \ f <= top do\n        lst2[f] = lst[f]\n        f = f + 1\n        if f <= top\
    \ then\n            lst2[f] = lst[b]\n            b = b - 1\n            f = f\
    \ + 1\n        end\n    end\n    return lst2\nend", "   local odd = { }\n   local\
    \ even = { }\n   for _, x in ipairs(lst) do\n      if x % 2 == 0 then\n      \
    \   table.insert(even, x)\n      else\n         table.insert(odd, x)\n      end\n\
    \   end\n   table.sort(odd)\n   table.sort(even)\n   for i = 1, math.max(#odd,\
    \ #even) do\n      table.insert(lst, i, even[i])\n      table.insert(lst, i +\
    \ 1, odd[i])\n   end\n   return lst\nend", "   local res = {}\n   local lst_len\
    \ = #lst\n   local min = math.min\n   local max = math.max\n   local min_index\
    \ = 1\n   local max_index = 1\n   for _ = 1, lst_len do\n      if (lst_len - #res)\
    \ % 2 == 1 then\n         local min_val = min(table.unpack(lst))\n         min_index\
    \ = list.find(lst, min_val)\n         table.insert(res, min_val)\n         table.remove(lst,\
    \ min_index)\n      else\n         local max_val = max(table.unpack(lst))\n  \
    \       max_index = list.find(lst, max_val)\n         table.insert(res, max_val)\n\
    \         table.remove(lst, max_index)\n      end\n   end\n   return res\nend",
  "    local half = #lst // 2\n    for i = 1, half do\n        lst[i], lst[#lst -\
    \ i + 1] = lst[#lst - i + 1], lst[i]\n    end\n    return lst\nend", "\tlocal\
    \ function _strange_sort_list(lst, res)\n\t\tif #lst == 0 then\n\t\t\treturn res\n\
    \t\tend\n\t\tif #lst == 1 then\n\t\t\treturn {lst[1]}\n\t\tend\n\t\tlocal cur\
    \ = {}\n\t\tif #lst % 2 == 0 then\n\t\t\tcur = {lst[1], lst[#lst]}\n\t\telse\n\
    \t\t\tcur = {lst[1]}\n\t\tend\n\t\tres = _strange_sort_list(lst, res)\n\t\treturn\
    \ _strange_sort_list(lst, table.move(cur, 1, #cur, #res+1, res))\n\tend\n\treturn\
    \ _strange_sort_list(lst, {})\nend", "    local sorted_lst = {}\n    local num_lst\
    \ = {}\n    local num_lst_len = #lst\n    local idx_min = 1\n    local idx_max\
    \ = num_lst_len\n    local count = 1\n    for i, num in ipairs(lst) do\n     \
    \   num_lst[i] = num\n    end\n    while idx_min <= idx_max do\n        if count\
    \ % 2 == 1 then\n            sorted_lst[count] = num_lst[idx_min]\n          \
    \  idx_min = idx_min + 1\n        else\n            sorted_lst[count] = num_lst[idx_max]\n\
    \            idx_max = idx_max - 1\n        end\n        count = count + 1\n \
    \   end\n    return sorted_lst\nend", "  -- Insert your code here\nend", "  local\
    \ half = math.floor(#lst / 2)\n  local first, second = {}, {}\n  for i, v in ipairs(lst)\
    \ do\n    if i <= half then\n      table.insert(first, v)\n    else\n      table.insert(second,\
    \ v)\n    end\n  end\n  table.sort(first)\n  table.sort(second, function(a, b)\
    \ return a > b end)\n  local i, j = 1, 1\n  local res = {}\n  while i <= #first\
    \ or j <= #second do\n    if i <= #first then\n      table.insert(res, first[i])\n\
    \      i = i + 1\n    end\n    if j <= #second then\n      table.insert(res, second[j])\n\
    \      j = j + 1\n    end\n  end\n  return res\nend", "  local tbl = {}\n  for\
    \ i, v in ipairs(lst) do\n    tbl[i] = v\n  end\n  for i = 1, #tbl - 1 do\n  \
    \  local a, b\n    if (i % 2 == 1) then\n      a, b = math.min(unpack(tbl)), math.max(unpack(tbl))\n\
    \    else\n      a, b = math.max(unpack(tbl)), math.min(unpack(tbl))\n    end\n\
    \    tbl[i], tbl[i + 1] = a, b\n  end\n  return tbl\nend", "    local function\
    \ sort_fun(a, b)\n        local min, max = math.min(a, b), math.max(a, b)\n  \
    \      return (min == a and max == b) or (min == b and max == a)\n    end\n  \
    \  table.sort(lst, sort_fun)\n    return lst\nend", "\tlocal min, max, min_next,\
    \ max_next = lst[1], lst[1], lst[1], lst[1]\n\tlocal function helper(lst, res)\n\
    \t\tif (#lst == 0) then return res end\n\t\t-- Find minimum and maximum, ignore\
    \ if already in res.\n\t\tfor i, n in ipairs(lst) do\n\t\t\tif (n == min or n\
    \ == max) then goto continue end\n\t\t\tif (n < min) then min = n end\n\t\t\t\
    if (n > max) then max = n end\n\t\t\t::continue::\n\t\tend\n\t\t-- Add next value.\n\
    \t\tif (res[#res] == min) then min_next = min end\n\t\tif (res[#res] == max) then\
    \ max_next = max end\n\t\tif (min_next < max_next) then\n\t\t\ttable.insert(res,\
    \ min_next)\n\t\t\tmin_next = max\n\t\telse\n\t\t\ttable.insert(res, max_next)\n\
    \t\t\tmax_next = min\n\t\tend\n\t\t-- Remove added value from lst.\n\t\tfor i,\
    \ n in ipairs(lst) do\n\t\t\tif (n == res[#res]) then\n\t\t\t\ttable.remove(lst,\
    \ i)\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\treturn helper(lst, res)\n\tend\n\t\
    return helper(lst, {lst[1]})\nend", "\tlocal result = {}\n\tlocal sort_lst = {}\n\
    \tfor k,v in pairs(lst) do\n\t\ttable.insert(sort_lst, v)\n\tend\n\ttable.sort(sort_lst)\n\
    \tlocal i = 1\n\tlocal j = #sort_lst\n\twhile i <= j do\n\t\ttable.insert(result,\
    \ sort_lst[i])\n\t\tif i < j then\n\t\t\ttable.insert(result, sort_lst[j])\n\t\
    \tend\n\t\ti = i + 1\n\t\tj = j - 1\n\tend\n\treturn result\nend", "   return\
    \ fun.iter(lst):enumerate():group_by(\n      function(i, x)\n         return math.floor((i\
    \ - 1) / 2) % 2 == 0\n      end):values():map(\n      function(lst)\n        \
    \ if lst[1][1] % 2 == 0 then\n            return fun.iter(lst):map(\n        \
    \       function(t)\n                  return t[2]\n               end):sort():reverse():unpack()\n\
    \         else\n            return fun.iter(lst):map(\n               function(t)\n\
    \                  return t[2]\n               end):sort():unpack()\n        \
    \ end\n      end):concat():totable()\nend", "  -- Since we will be shifting items\
    \ in and out of the list\n  -- it is more convenient to use a queue, which is\
    \ a FIFO data structure.\n  local q = queue:new()\n  for i = 1, #lst do\n    q:enqueue(lst[i])\n\
    \  end\n  -- The sorted list is stored in a stack, which is a LIFO data structure.\n\
    \  local stack = {}\n  -- Iterate until the queue is empty.\n  while not q:is_empty()\
    \ do\n    -- Get the minimum item.\n    local min = q:dequeue()\n    -- Iterate\
    \ through the remaining items in the queue,\n    -- and find the maximum.\n  \
    \  local max = min\n    for i = 1, q:size() do\n      local item = q:dequeue()\n\
    \      if item > max then\n        max = item\n      end\n      q:enqueue(item)\n\
    \    end\n    -- Push the maximum item in the stack.\n    stack:push(max)\n  \
    \  -- Push the minimum item in the stack.\n    stack:push(min)\n    -- Remove\
    \ the maximum item from the queue.\n    while not q:is_empty() do\n      local\
    \ item = q:dequeue()\n      if item ~= max then\n        q:enqueue(item)\n   \
    \   end\n    end\n  end\n  -- Return the stack as an array.\n  return stack:to_array()\n\
    end", "    if #lst < 2 then\n        return lst\n    end\n    local min_val, min_ind\
    \ = math.min(unpack(lst))\n    local max_val, max_ind = math.max(unpack(lst))\n\
    \    return {min_val, max_val} .. strange_sort_list(lst[1:min_ind] + lst[min_ind\
    \ + 1:max_ind] + lst[max_ind + 1:])\nend", "  local min_val, max_val = lst[1],\
    \ lst[1]\n  for i=2, #lst do\n    if lst[i] < min_val then min_val = lst[i] end\n\
    \    if lst[i] > max_val then max_val = lst[i] end\n  end\n  local use_min = true\n\
    \  local result = {}\n  while min_val <= max_val do\n    if use_min then\n   \
    \   result[#result+1] = min_val\n      min_val = min_val + 1\n    else\n     \
    \ result[#result+1] = max_val\n      max_val = max_val - 1\n    end\n    use_min\
    \ = not use_min\n  end\n  return result\nend", "    local res = {}\n    local\
    \ sorted = {}\n    table.sort(lst)\n    local j = 1\n    while #lst > 0 do\n \
    \       if j % 2 == 1 then\n            local elem = table.remove(lst, 1)\n  \
    \          table.insert(res, elem)\n        else\n            local elem = table.remove(lst)\n\
    \            table.insert(res, elem)\n        end\n        j = j + 1\n    end\n\
    \    return res\nend", "  -- Insert your code here.\n  local ans = {}\n  local\
    \ tmp = {}\n  local len = #lst\n  local sort_lst = {}\n  for i = 1, len do\n \
    \   tmp[i] = lst[i]\n  end\n  while len > 0 do\n    local min = math.min(unpack(tmp))\n\
    \    local max = math.max(unpack(tmp))\n    local min_ind = 1\n    local max_ind\
    \ = 1\n    for i = 1, len do\n      if tmp[i] == min then\n        min_ind = i\n\
    \      end\n      if tmp[i] == max then\n        max_ind = i\n      end\n    end\n\
    \    table.insert(ans, min)\n    table.insert(ans, max)\n    table.remove(tmp,\
    \ min_ind)\n    table.remove(tmp, max_ind - 1)\n    len = len - 2\n  end\n  return\
    \ ans\nend", "\tlocal function f(min)\n\t\tif min >= lst:max() then\n\t\t\treturn\
    \ {}\n\t\tend\n\t\tlocal max = lst:filter(function(x) return x > min end):max()\n\
    \t\treturn table.concat({\n\t\t\tmin,\n\t\t\tmax,\n\t\t\tf(max + 1)\n\t\t})\n\t\
    end\n\treturn f(lst:min())\nend", '   table.sort(lst)', "  local sort_table =\
    \ {}\n  for i, value in ipairs(lst) do\n    table.insert(sort_table, {value =\
    \ value, index = i})\n  end\n  table.sort(sort_table, function(a, b) return a.value\
    \ < b.value end)\n  local lst = {}\n  local current_index = 1\n  local i = 1\n\
    \  while current_index <= #sort_table do\n    lst[i] = sort_table[current_index].value\n\
    \    i = i + 1\n    if current_index ~= #sort_table then\n      lst[i] = sort_table[#sort_table].value\n\
    \      i = i + 1\n    end\n    current_index = current_index + 1\n    table.remove(sort_table,\
    \ #sort_table)\n  end\n  return lst\nend", "    local results = {}\n    local\
    \ counter = 0\n    local start = 0\n    local end_at = #lst\n    while start <=\
    \ end_at do\n        local min_index = start\n        local max_index = start\n\
    \        for i = start, end_at do\n            if lst[i] < lst[min_index] then\n\
    \                min_index = i\n            end\n            if lst[i] > lst[max_index]\
    \ then\n                max_index = i\n            end\n        end\n        if\
    \ counter % 2 == 0 then\n            table.insert(results, lst[min_index])\n \
    \           start = min_index + 1\n        else\n            table.insert(results,\
    \ lst[max_index])\n            start = max_index + 1\n        end\n        counter\
    \ = counter + 1\n    end\n    return results\nend", "\tlocal idx, sz = 1, #lst\n\
    \tlocal sorted = {}\n\twhile idx <= sz do\n\t\tlocal min, max = lst[1], 1\n\t\t\
    local min_idx, max_idx = 1, 1\n\t\tfor i = 2, sz do\n\t\t\tif lst[i] < min then\n\
    \t\t\t\tmin = lst[i]\n\t\t\t\tmin_idx = i\n\t\t\tend\n\t\t\tif lst[i] > max then\n\
    \t\t\t\tmax = lst[i]\n\t\t\t\tmax_idx = i\n\t\t\tend\n\t\tend\n\t\ttable.insert(sorted,\
    \ min)\n\t\ttable.remove(lst, min_idx)\n\t\ttable.insert(sorted, max)\n\t\ttable.remove(lst,\
    \ max_idx)\n\t\tidx = idx + 2\n\tend\n\treturn sorted\nend", "    local temp =\
    \ {}\n    local min = math.min(table.unpack(lst))\n    local max = math.max(table.unpack(lst))\n\
    \    while min <= max do\n        temp[#temp + 1] = min\n        temp[#temp +\
    \ 1] = max\n        min = min + 1\n        max = max - 1\n    end\n    return\
    \ temp\nend", "  local odd_list = {}\n  local even_list = {}\n  local out_list\
    \ = {}\n  for i,v in ipairs(lst) do\n    if i % 2 == 0 then\n      even_list[#even_list+1]\
    \ = v\n    else\n      odd_list[#odd_list+1] = v\n    end\n  end\n  table.sort(odd_list)\n\
    \  table.sort(even_list)\n  for i=1,#odd_list do\n    out_list[#out_list+1] =\
    \ odd_list[i]\n    out_list[#out_list+1] = even_list[i]\n  end\n  return out_list\n\
    end", "\tlocal result = {}\n\tlocal i = 0\n\twhile #lst > 0 do\n\t\tlocal min,\
    \ min_index = math.min(unpack(lst))\n\t\ttable.insert(result, min)\n\t\ttable.remove(lst,\
    \ min_index)\n\t\ti = i + 1\n\t\tlocal max, max_index = math.max(unpack(lst))\n\
    \t\ttable.insert(result, max)\n\t\ttable.remove(lst, max_index)\n\t\ti = i + 1\n\
    \tend\n\treturn result\nend", '  table.sort(lst)', "    local res = {}\n    local\
    \ min, max = min_max(lst)\n    local len = #lst\n    if len == 1 then\n      \
    \  return lst\n    end\n    local i = 1\n    while len > 0 do\n        local m\
    \ = (i % 2) == 1 and min or max\n        table.insert(res, m)\n        if m ==\
    \ min then\n            min = min_max(lst, min).max\n        else\n          \
    \  max = min_max(lst, max).min\n        end\n        i = i + 1\n        len =\
    \ len - 1\n    end\n    return res\nend", "   local sorted_lst = {}\n   local\
    \ sorted_len = 0\n   local unsorted_lst = {}\n   local unsorted_len = 0\n   local\
    \ unsorted_max = -math.huge\n   local unsorted_min = math.huge\n   local unsorted_max_pos\
    \ = 0\n   local unsorted_min_pos = 0\n   local i = 1\n   local lst_len = #lst\n\
    \   while true do\n      -- Get the minimum and maximum values.\n      if unsorted_len\
    \ == 0 then\n         unsorted_min = math.huge\n         unsorted_max = -math.huge\n\
    \         unsorted_min_pos = 0\n         unsorted_max_pos = 0\n         for i=1,lst_len\
    \ do\n            if lst[i] ~= nil then\n               if lst[i] < unsorted_min\
    \ then\n                  unsorted_min = lst[i]\n                  unsorted_min_pos\
    \ = i\n               end\n               if lst[i] > unsorted_max then\n    \
    \              unsorted_max = lst[i]\n                  unsorted_max_pos = i\n\
    \               end\n            end\n         end\n      end\n      if unsorted_len\
    \ == 0 then\n         sorted_len = sorted_len + 1\n         sorted_lst[sorted_len]\
    \ = unsorted_min\n         lst[unsorted_min_pos] = nil\n         unsorted_len\
    \ = unsorted_len + 1\n         unsorted_lst[unsorted_len] = unsorted_max\n   \
    \      lst[unsorted_max_pos] = nil\n      else\n         sorted_len = sorted_len\
    \ + 1\n         sorted_lst[sorted_len] = unsorted_max\n         unsorted_lst[unsorted_max_pos]\
    \ = nil\n         unsorted_len = unsorted_len - 1\n         if unsorted_len >\
    \ 0 then\n            sorted_len = sorted_len + 1\n            sorted_lst[sorted_len]\
    \ = unsorted_min\n            unsorted_lst[unsorted_min_pos] = nil\n         \
    \   unsorted_len = unsorted_len - 1\n         end\n      end\n      if unsorted",
  "    local res = {}\n    local incr, end_at = true, #lst\n    while #res < end_at\
    \ do\n        local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \        table.insert(res, min)\n        if incr then\n            table.insert(res,\
    \ max)\n        else\n            table.insert(res, 1, max)\n        end\n   \
    \     incr = not incr\n        table.remove_value(lst, min)\n        table.remove_value(lst,\
    \ max)\n    end\n    return res\nend", "  local n = #lst\n  local _, st = table.sort(lst)\n\
    \  local res = {}\n  local asc = true\n  local i = 1\n  while n > 0 do\n    res[i]\
    \ = asc and lst[1] or lst[n]\n    if asc then\n      table.remove(lst, 1)\n  \
    \  else\n      table.remove(lst, n)\n    end\n    n = n - 1\n    i = i + 1\n \
    \   asc = not asc\n  end\n  return res\nend", "    local n = 0\n    for _ in pairs(lst)\
    \ do\n        n = n + 1\n    end\n    local ret = {}\n    for i = 1, n do\n  \
    \      ret[i] = math.min(unpack(lst))\n        local min = ret[i]\n        for\
    \ j = 1, n do\n            if lst[j] == min then\n                lst[j] = math.max(unpack(lst))\n\
    \            end\n        end\n    end\n    return ret\nend", "  local nlst =\
    \ {}\n  local n = 1\n  while n <= #lst do\n    local min_int, min_pos = lst[1],\
    \ 1\n    local max_int, max_pos = lst[1], 1\n    for i = 2, #lst do\n      if\
    \ lst[i] < min_int then\n        min_int, min_pos = lst[i], i\n      end\n   \
    \   if lst[i] > max_int then\n        max_int, max_pos = lst[i], i\n      end\n\
    \    end\n    nlst[n] = min_int\n    nlst[n + 1] = max_int\n    table.remove(lst,\
    \ min_pos)\n    table.remove(lst, max_pos - 1)\n    n = n + 2\n  end\n  return\
    \ nlst\nend", "  -- write your code here\nend", "    -- TODO implement this function\n\
    end", "  if #lst == 0 then return {} end\n  local result = {}\n  local min, max,\
    \ min_ind, max_ind\n  local ind = 1\n  while ind <= #lst do\n    -- get the minimum\
    \ and maximum values\n    if not min then\n      min = max = lst[ind]\n      min_ind\
    \ = max_ind = ind\n    else\n      if lst[ind] < min then\n        min = lst[ind]\n\
    \        min_ind = ind\n      elseif lst[ind] > max then\n        max = lst[ind]\n\
    \        max_ind = ind\n      end\n    end\n    ind = ind + 1\n  end\n  -- get\
    \ the first element from the result\n  if min_ind < max_ind then\n    table.insert(result,\
    \ min)\n    table.remove(lst, min_ind)\n  else\n    table.insert(result, max)\n\
    \    table.remove(lst, max_ind)\n  end\n  -- get the rest\n  for _, v in ipairs(strange_sort_list(lst))\
    \ do\n    table.insert(result, v)\n  end\n  return result\nend", "    local temp\
    \ = lst\n    local sorted = {}\n    while (#temp > 0) do\n        table.insert(sorted,\
    \ table.remove(temp, 1))\n        if (#temp > 0) then\n            table.insert(sorted,\
    \ table.remove(temp, #temp))\n        end\n    end\n    return sorted\nend", " \
    \  local result = {}\n   local asc_sort = true\n   while #lst > 0 do\n      local\
    \ c = asc_sort and 1 or -1\n      local f = asc_sort and table.remove(lst, 1)\
    \ or table.remove(lst)\n      local i = asc_sort and 1 or #lst + 1\n      local\
    \ max = lst[i]\n      for j,v in ipairs(lst) do\n         if c * v > c * max then\n\
    \            max = v\n            i = j\n         end\n      end\n      result[#result\
    \ + 1] = max\n      table.remove(lst, i)\n      asc_sort = not asc_sort\n   end\n\
    \   return result\nend", "    local acc = {n = 0}\n    local len = #lst\n    local\
    \ sorted = false\n    local start = 1\n    local step = 1\n    local add = function(v)\
    \ acc[#acc + 1] = v end\n    local smallest_value = function(start, step)\n  \
    \      local n = #lst\n        local i = start\n        local ret = i\n      \
    \  while i <= n do\n            if lst[i] < lst[ret] then\n                ret\
    \ = i\n            end\n            i = i + step\n        end\n        return\
    \ ret\n    end\n    while not sorted do\n        sorted = true\n        local\
    \ i = smallest_value(start, step)\n        while i ~= start do\n            add(lst[i])\n\
    \            sorted = false\n            i = smallest_value(i + step, step)\n\
    \        end\n        add(lst[start])\n        if start == 1 then\n          \
    \  start = len\n            step = -1\n        else\n            start = 1\n \
    \           step = 1\n        end\n    end\n    return acc\nend", "  local MIN_INDEX\
    \ = 1\n  local MIN_VALUE = lst[MIN_INDEX]\n  local MAX_INDEX = #lst\n  local MAX_VALUE\
    \ = lst[MAX_INDEX]\n  local STRANGE_SORTED_LIST = {}\n  local STRANGE_COUNTER\
    \ = 1\n  local INDEX_TRACKER = 1\n  local IS_NEED_MAX_VALUE = true\n  for i=1,#lst\
    \ do\n    if IS_NEED_MAX_VALUE then\n      local current_max_value = lst[INDEX_TRACKER]\n\
    \      local current_max_index = INDEX_TRACKER\n      for i=INDEX_TRACKER,#lst\
    \ do\n        if lst[i] > current_max_value then\n          current_max_value\
    \ = lst[i]\n          current_max_index = i\n        end\n      end\n      STRANGE_SORTED_LIST[STRANGE_COUNTER]\
    \ = current_max_value\n      STRANGE_COUNTER = STRANGE_COUNTER + 1\n      INDEX_TRACKER\
    \ = current_max_index + 1\n      IS_NEED_MAX_VALUE = false\n    else\n      local\
    \ current_min_value = lst[INDEX_TRACKER]\n      local current_min_index = INDEX_TRACKER\n\
    \      for i=INDEX_TRACKER,#lst do\n        if lst[i] < current_min_value then\n\
    \          current_min_value = lst[i]\n          current_min_index = i\n     \
    \   end\n      end\n      STRANGE_SORTED_LIST[STRANGE_COUNTER] = current_min_value\n\
    \      STRANGE_COUNTER = STRANGE_COUNTER + 1\n      INDEX_TRACKER = current_min_index\
    \ + 1\n      IS_NEED_MAX_VALUE = true\n    end\n  end\n  return STRANGE_SORTED_LIST\n\
    end", "   assert_table(lst)\n   local odd, even = {}, {}\n   for i,v in ipairs(lst)\
    \ do\n      if i % 2 == 0 then\n         even[#even+1] = v\n      else\n     \
    \    odd[#odd+1] = v\n      end\n   end\n   table.sort(odd)\n   table.sort(even)\n\
    \   local res = {}\n   for i=1,#odd do\n      res[#res+1] = odd[i]\n      res[#res+1]\
    \ = even[i]\n   end\n   if #odd < #even then\n      res[#res+1] = even[#even]\n\
    \   end\n   return res\nend", "  if not lst or #lst == 0 then return {} end\n\
    \  local n = #lst\n  if n == 1 then return lst end\n  local sorted = {}\n  local\
    \ left = {}\n  local first = 0\n  local last = 0\n  for i = 1, n, 2 do\n    first\
    \ = math.min(unpack(lst))\n    last = math.max(unpack(lst))\n    if i == n then\
    \ last = first end\n    table.insert(sorted, first)\n    table.insert(sorted,\
    \ last)\n    left = table_diff(lst, {first, last})\n    lst = left\n  end\n  return\
    \ sorted\nend", "  local min = math.min(unpack(lst))\n  local max = math.max(unpack(lst))\n\
    \  local t = {}\n  local order = 1\n  local i = 1\n  local is_even = false\n \
    \ while true do\n    local j = i\n    if order == 1 then\n      while true do\n\
    \        if lst[j] == min then\n          t[#t + 1] = min\n          table.remove(lst,\
    \ j)\n          break\n        end\n        j = j + 1\n      end\n      min =\
    \ math.min(unpack(lst))\n      if min == max then\n        t[#t + 1] = max\n \
    \       break\n      end\n      max = math.max(unpack(lst))\n      order = 2\n\
    \    else\n      while true do\n        if lst[j] == max then\n          t[#t\
    \ + 1] = max\n          table.remove(lst, j)\n          break\n        end\n \
    \       j = j + 1\n      end\n      max = math.max(unpack(lst))\n      if max\
    \ == min then\n        t[#t + 1] = min\n        break\n      end\n      min =\
    \ math.min(unpack(lst))\n      order = 1\n    end\n    is_even = not is_even\n\
    \    i = i + 1\n  end\n  return t\nend", "  local odd_list = {}\n  local even_list\
    \ = {}\n  local odd_list_len = 0\n  local even_list_len = 0\n  local is_odd =\
    \ true\n  local sorted_list = {}\n  local sorted_list_len = 0", "  -- your code\
    \ here\n  local sorted_lst = {}\n  -- iterate through list and find the min.\n\
    \  local min_val = math.min(unpack(lst))\n  table.insert(sorted_lst, min_val)\n\
    \  table.remove(lst, min_val)\n  -- iterate through list and find the max.\n \
    \ local max_val = math.max(unpack(lst))\n  table.insert(sorted_lst, max_val)\n\
    \  table.remove(lst, max_val)\n  \n  -- keep doing this until both the lists are\
    \ not empty.\n  return sorted_lst\nend", "   local l_max = lst[#lst]\n   local\
    \ l_min = lst[1]\n   local i_min = 1\n   local i_max = #lst\n   local i = 1\n\
    \   local res = {}\n   local k = 1\n   local flag = true", "\tlocal min_val, max_val\
    \ = lst[1], lst[1]\n\tfor i = 2, #lst do\n\t\tif lst[i] < min_val then\n\t\t\t\
    min_val = lst[i]\n\t\telseif lst[i] > max_val then\n\t\t\tmax_val = lst[i]\n\t\
    \tend\n\tend\n\t\n\tlocal min_list, max_list = {min_val}, {max_val}\n\tfor i =\
    \ 1, #lst do\n\t\tif lst[i] ~= min_val and lst[i] ~= max_val then\n\t\t\ttable.insert(min_list,\
    \ lst[i])\n\t\t\ttable.insert(max_list, lst[i])\n\t\tend\n\tend\n\t\n\tmin_list\
    \ = {table.unpack(min_list)}\n\tmax_list = {table.unpack(max_list)}\n\t\n\tif\
    \ #min_list == 1 then\n\t\treturn {table.unpack(max_list)}\n\telseif #max_list\
    \ == 1 then\n\t\treturn {table.unpack(min_list)}\n\tend\n\t\n\tlocal min_strange_sort_list\
    \ = strange_sort_list(min_list)\n\tlocal max_strange_sort_list = strange_sort_list(max_list)\n\
    \t\n\tlocal strange_sort_list = {}\n\tfor i = 1, #min_strange_sort_list do\n\t\
    \ttable.insert(strange_sort_list, min_strange_sort_list[i])\n\t\ttable.insert(strange_sort_list,\
    \ max_strange_sort_list[i])\n\tend\n\t\n\treturn strange_sort_list\nend", "  \
    \  lst = List.to_sequence(lst)\n    local ascending = not(List.head(lst) > List.last(lst))\n\
    \    local sort_func = ascending and List.sort or List.sort_rev\n    lst = sort_func(lst)\n\
    \    local res = {}\n    while #lst > 0 do\n        local head = table.remove(lst,\
    \ 1)\n        table.insert(res, head)\n        local last = table.remove(lst)\n\
    \        if last then\n            table.insert(res, last)\n        end\n    end\n\
    \    return res\nend", "    local min, max = math.min, math.max\n    local len\
    \ = #lst\n    local res = {}\n    while len > 0 do\n        local curr_min = min(unpack(lst))\n\
    \        table.insert(res, curr_min)\n        lst[index_of(lst, curr_min)] = max(unpack(lst))\n\
    \        local curr_max = max(unpack(lst))\n        table.insert(res, curr_max)\n\
    \        lst[index_of(lst, curr_max)] = curr_min\n        len = len - 2\n    end\n\
    \    return res\nend", "  -- Your code here.\nend", "\tlocal comparator = function(a,\
    \ b)\n\t\treturn a[1] < b[1]\n\tend\n\tlocal indexed_lst = List.mapi(function(index,\
    \ value)\n\t\treturn {value, index}\n\tend, lst)\n\tList.sort(comparator, indexed_lst)\n\
    \tlocal new_lst = {}\n\tlocal i = 1\n\twhile #indexed_lst > 0 do\n\t\tlocal n\
    \ = #indexed_lst\n\t\tnew_lst[i] = List.remove(n, indexed_lst)[1]\n\t\ti = i +\
    \ 1\n\t\tnew_lst[i] = List.remove(1, indexed_lst)[1]\n\t\ti = i + 1\n\tend\n\t\
    return new_lst\nend", "  local function helper(lst, acc)\n    if #lst == 0 then\n\
    \      return acc\n    end\n    local min = lst[1]\n    local max = lst[1]\n \
    \   local min_index = 1\n    local max_index = 1\n    for i, v in ipairs(lst)\
    \ do\n      if v < min then\n        min = v\n        min_index = i\n      end\n\
    \      if v > max then\n        max = v\n        max_index = i\n      end\n  \
    \  end\n    if min_index < max_index then\n      table.insert(acc, min)\n    \
    \  table.insert(acc, max)\n    else\n      table.insert(acc, max)\n      table.insert(acc,\
    \ min)\n    end\n    table.remove(lst, min_index)\n    table.remove(lst, max_index\
    \ - 1)\n    return helper(lst, acc)\n  end\n  return helper(lst, {})\nend", " \
    \   local result = {}\n    local first_half = {}\n    local second_half = {}\n\
    \    local first = true\n    local function merge(first_half, second_half)\n \
    \       local result = {}\n        local i = 1\n        local j = 1\n        while\
    \ (i <= #first_half and j <= #second_half) do\n            if first then\n   \
    \             result[#result + 1] = first_half[i]\n                i = i + 1\n\
    \            else\n                result[#result + 1] = second_half[j]\n    \
    \            j = j + 1\n            end\n            first = not first\n     \
    \   end\n        while (i <= #first_half) do\n            result[#result + 1]\
    \ = first_half[i]\n            i = i + 1\n        end\n        while (j <= #second_half)\
    \ do\n            result[#result + 1] = second_half[j]\n            j = j + 1\n\
    \        end\n        return result\n    end\n    if (#lst <= 1) then\n      \
    \  return lst\n    else\n        first_half = strange_sort_list(fun.slice(lst,\
    \ 1, #lst/2))\n        second_half = strange_sort_list(fun.slice(lst, #lst/2 +\
    \ 1, #lst))\n        return merge(first_half, second_half)\n    end\nend", " \
    \   local result = {}\n    local function add(v)\n        result[#result + 1]\
    \ = v\n    end\n    local function process(l)\n        local min_v, min_i = l[1],\
    \ 1\n        local max_v, max_i = l[1], 1\n        for i, v in ipairs(l) do\n\
    \            if v < min_v then\n                min_v, min_i = v, i\n        \
    \    end\n            if v > max_v then\n                max_v, max_i = v, i\n\
    \            end\n        end\n        add(min_v)\n        add(max_v)\n      \
    \  table.remove(l, max_i)\n        table.remove(l, min_i)\n        return l\n\
    \    end\n    while true do\n        lst = process(lst)\n        if #lst == 0\
    \ then\n            break\n        end\n    end\n    return result\nend", "  --\
    \ TODO: Implement me\nend", "  local n = #lst\n  if n == 0 then return {} end\n\
    \  local res = {}\n  local dir = 1\n  local i = 1\n  while i <= n do\n    if dir\
    \ == 1 then\n      local min = lst[1]\n      local j = 1\n      for k = 2, n do\n\
    \        if lst[k] < min then\n          min = lst[k]\n          j = k\n     \
    \   end\n      end\n      res[i] = min\n      table.remove(lst, j)\n      n =\
    \ n - 1\n    else\n      local max = lst[1]\n      local j = 1\n      for k =\
    \ 2, n do\n        if lst[k] > max then\n          max = lst[k]\n          j =\
    \ k\n        end\n      end\n      res[i] = max\n      table.remove(lst, j)\n\
    \      n = n - 1\n    end\n    dir = -dir\n    i = i + 1\n  end\n  return res\n\
    end", "    assert(type(lst) == \"table\")\n    local tbl = {}\n    local count\
    \ = #lst\n    for i = 1, count do\n        if i % 2 == 1 then\n            table.insert(tbl,\
    \ 1, table.remove(lst, 1))\n        else\n            table.insert(tbl, 1, table.remove(lst,\
    \ #lst))\n        end\n    end\n    return tbl\nend", "  if #lst <= 1 then\n \
    \   return lst\n  end\n  local to_sort = List.clone(lst)\n  local result = {}\n\
    \  while #to_sort > 0 do\n    local min = math.min(table.unpack(to_sort))\n  \
    \  local max = math.max(table.unpack(to_sort))\n    table.insert(result, min)\n\
    \    table.insert(result, max)\n    to_sort = List.difference(to_sort, {min, max})\n\
    \  end\n  return result\nend", "    local tmp_lst = lst\n    local res_lst = {}\n\
    \    local min = lst[1]\n    local max = lst[1]\n    local min_count = 0\n   \
    \ local max_count = 0\n    local count = 0\n    local index = 0\n    while #lst\
    \ > count do\n        index = 1\n        min = lst[1]\n        max = lst[1]\n\
    \        for i = 1, #lst do\n            if lst[i] < min then\n              \
    \  min = lst[i]\n                index = i\n            end\n            if lst[i]\
    \ > max then\n                max = lst[i]\n            end\n        end\n   \
    \     if min_count % 2 == 0 then\n            table.insert(res_lst, min)\n   \
    \         min_count = min_count + 1\n        else\n            table.insert(res_lst,\
    \ max)\n            max_count = max_count + 1\n        end\n        table.remove(lst,\
    \ index)\n        count = count + 1\n    end\n    return res_lst\nend", "  local\
    \ result = {}\n  local function add_value(val)\n    local insertion_point = 0\n\
    \    while insertion_point < #result and result[insertion_point] < val do\n  \
    \    insertion_point = insertion_point + 1\n    end\n    table.insert(result,\
    \ insertion_point, val)\n  end\n  table.sort(lst)\n  for i = 1, #lst do\n    if\
    \ i % 2 == 1 then\n      add_value(lst[i])\n    else\n      add_value(lst[#lst\
    \ - i + 1])\n    end\n  end\n  return result\nend", "  local min = math.min(unpack(lst))\n\
    \  local max = math.max(unpack(lst))\n  local sorted = {}\n  while true do\n \
    \   table.insert(sorted, min)\n    local min_idx = nil\n    for i, v in ipairs(lst)\
    \ do\n      if v == min then\n        min_idx = i\n        break\n      end\n\
    \    end\n    table.remove(lst, min_idx)\n    if #lst == 0 then break end\n  \
    \  table.insert(sorted, max)\n    local max_idx = nil\n    for i, v in ipairs(lst)\
    \ do\n      if v == max then\n        max_idx = i\n        break\n      end\n\
    \    end\n    table.remove(lst, max_idx)\n    if #lst == 0 then break end\n  \
    \  min = math.min(unpack(lst))\n    max = math.max(unpack(lst))\n  end\n  return\
    \ sorted\nend", "  local min, max, res = math.min(unpack(lst)), math.max(unpack(lst)),\
    \ {}\n  while #lst > 0 do\n    table.insert(res, min)\n    table.remove(lst, table.index_of(lst,\
    \ min))\n    if #lst > 0 then\n      table.insert(res, max)\n      table.remove(lst,\
    \ table.index_of(lst, max))\n    end\n  end\n  return res\nend", "\tlocal len,\
    \ idx_min, idx_max = #lst, 1, #lst\n\tlocal lst_sorted = {lst[idx_min]}", "  local\
    \ sorted = {}\n  local n = #lst\n  local min_idx = 1\n  local max_idx = 1\n  local\
    \ asc_first = true\n  for _=1,n do\n    local idx = (asc_first and min_idx) or\
    \ max_idx\n    asc_first = not asc_first\n    table.insert(sorted, lst[idx])\n\
    \    lst[idx] = nil\n    -- find new maximum or minimum.\n    if idx == min_idx\
    \ then\n      min_idx = 1\n      max_idx = 1\n      for i,v in ipairs(lst) do\n\
    \        if v < lst[min_idx] then\n          min_idx = i\n        end\n      \
    \  if v > lst[max_idx] then\n          max_idx = i\n        end\n      end\n \
    \   else\n      max_idx = 1\n      for i,v in ipairs(lst) do\n        if v > lst[max_idx]\
    \ then\n          max_idx = i\n        end\n      end\n    end\n  end\n  return\
    \ sorted\nend", "  -- TODO\nend", "    lst = list(lst)\n    local res = {}\n \
    \   local min, max = min_max(lst)\n    table.insert(res, min)\n    lst:remove(min)\n\
    \    while not lst:is_empty() do\n        local a, b = min_max(lst)\n        table.insert(res,\
    \ b)\n        lst:remove(b)\n        if not lst:is_empty() then\n            table.insert(res,\
    \ a)\n            lst:remove(a)\n        end\n    end\n    return res\nend", "\t\
    local out = {}\n\tlocal i = 1\n\twhile #lst > 0 do\n\t\ttable.insert(out, i, table.remove(lst,\
    \ 1))\n\t\tif #lst > 0 then\n\t\t\ttable.insert(out, i, table.remove(lst))\n\t\
    \tend\n\t\ti = i + 1\n\tend\n\treturn out\nend", "    local min_ind, max_ind\n\
    \    local res = {}\n    local i\n    local function next_ind(arr, ind)\n    \
    \    ind = ind + 1\n        if ind > #arr then ind = 1 end\n        return ind\n\
    \    end\n    for i = 1, #lst do\n        if not min_ind then\n            min_ind\
    \ = i\n        elseif not max_ind then\n            if lst[i] > lst[min_ind] then\n\
    \                max_ind = i\n            elseif lst[i] < lst[min_ind] then\n\
    \                max_ind = min_ind\n                min_ind = i\n            end\n\
    \        else\n            if lst[i] > lst[max_ind] then\n                res[#res\
    \ + 1] = lst[max_ind]\n                max_ind = i\n            elseif lst[i]\
    \ < lst[min_ind] then\n                res[#res + 1] = lst[min_ind]\n        \
    \        min_ind = i\n            else\n                res[#res + 1] = lst[i]\n\
    \            end\n        end\n    end\n    min_ind = next_ind(lst, min_ind)\n\
    \    max_ind = next_ind(lst, max_ind)\n    for i = 1, #lst - 2 do\n        if\
    \ i % 2 == 1 then\n            res[#res + 1] = lst[min_ind]\n            min_ind\
    \ = next_ind(lst, min_ind)\n        else\n            res[#res + 1] = lst[max_ind]\n\
    \            max_ind = next_ind(lst, max_ind)\n        end\n    end\n    return\
    \ res\nend", "    local odd_lst = {}\n    local even_lst = {}\n    local res =\
    \ {}\n    local function odd_or_even(number)\n        if number % 2 == 0 then\n\
    \            table.insert(even_lst, number)\n        else\n            table.insert(odd_lst,\
    \ number)\n        end\n    end\n    for _, v in ipairs(lst) do\n        odd_or_even(v)\n\
    \    end\n    table.sort(odd_lst)\n    table.sort(even_lst)\n    -- Build result\
    \ list\n    while #odd_lst ~= 0 and #even_lst ~= 0 do\n        table.insert(res,\
    \ odd_lst[1])\n        table.insert(res, even_lst[#even_lst])\n        table.remove(odd_lst,\
    \ 1)\n        table.remove(even_lst, #even_lst)\n    end\n    if #odd_lst ~= 0\
    \ then\n        for _, v in ipairs(odd_lst) do\n            table.insert(res,\
    \ v)\n        end\n    elseif #even_lst ~= 0 then\n        for _, v in ipairs(even_lst)\
    \ do\n            table.insert(res, v)\n        end\n    end\n    return res\n\
    end", "  local function compare_func(a, b)\n    if a == nil then return true end\n\
    \    if b == nil then return false end\n    return (a < b)\n  end\n  local function\
    \ pop_func(lst)\n    local res\n    if compare_func(lst[1], lst[#lst]) then\n\
    \      res = table.remove(lst, 1)\n    else\n      res = table.remove(lst, #lst)\n\
    \    end\n    return res\n  end\n  local res = {}\n  table.sort(lst, compare_func)\n\
    \  for i=1, #lst do\n    res[i] = pop_func(lst)\n  end\n  return res\nend", " \
    \ local ret = {}\n  while #lst > 0 do\n    local min = math.min(unpack(lst))\n\
    \    table.insert(ret, min)\n    table.remove(lst, table.index_of(lst, min))\n\
    \    if #lst > 0 then\n      local max = math.max(unpack(lst))\n      table.insert(ret,\
    \ max)\n      table.remove(lst, table.index_of(lst, max))\n    end\n  end\n  return\
    \ ret\nend", "    local res = {}\n    local new_list = copy_list(lst)\n    while\
    \ #new_list > 0 do\n        local min_i = 1\n        local max_i = 1\n       \
    \ for i, num in ipairs(new_list) do\n            if num < new_list[min_i] then\n\
    \                min_i = i\n            end\n            if num > new_list[max_i]\
    \ then\n                max_i = i\n            end\n        end\n        table.insert(res,\
    \ new_list[min_i])\n        table.remove(new_list, min_i)\n        if #new_list\
    \ == 0 then\n            break\n        end\n        table.insert(res, new_list[max_i])\n\
    \        table.remove(new_list, max_i)\n    end\n    return res\nend", "  local\
    \ sorted_list = {}\n  local min, max\n  local flag = true\n  while (table.getn(lst)\
    \ > 0) do\n    if flag then\n      min = math.min(unpack(lst))\n      table.insert(sorted_list,\
    \ min)\n      for k, v in pairs(lst) do\n        if v == min then\n          table.remove(lst,\
    \ k)\n          break\n        end\n      end\n    else\n      max = math.max(unpack(lst))\n\
    \      table.insert(sorted_list, max)\n      for k, v in pairs(lst) do\n     \
    \   if v == max then\n          table.remove(lst, k)\n          break\n      \
    \  end\n      end\n    end\n    flag = not flag\n  end\n  return sorted_list\n\
    end", "    local sorted = {}\n    local remaining = {}\n    for _, v in ipairs(lst)\
    \ do\n        table.insert(remaining, v)\n    end\n    while #remaining > 0 do\n\
    \        local min_val = math.min(unpack(remaining))\n        table.insert(sorted,\
    \ min_val)\n        table.remove(remaining, _.index_of(remaining, min_val))\n\
    \        if #remaining > 0 then\n            local max_val = math.max(unpack(remaining))\n\
    \            table.insert(sorted, max_val)\n            table.remove(remaining,\
    \ _.index_of(remaining, max_val))\n        end\n    end\n    return sorted\nend",
  "  local out = {};\n  local remaining = lst;\n  while #remaining > 0 do\n    table.insert(out,\
    \ get_min(remaining));\n    table.insert(out, get_max(remaining));\n    remaining\
    \ = remove_x(get_min(remaining), remaining);\n    remaining = remove_x(get_max(remaining),\
    \ remaining);\n  end\n  return out;\nend", "   local o = {}\n   while #lst > 0\
    \ do\n      local min, max = min_max(lst)\n      lst[min], lst[max] = lst[max],\
    \ lst[min]\n      table.insert(o, table.remove(lst, min))\n      table.insert(o,\
    \ table.remove(lst, max-1))\n   end\n   return o\nend", "\tlocal n = #lst\n\t\
    assert(n > 0)\n\tlocal pos = 1\n\tlocal ret = {}\n\tlocal function get()\n\t\t\
    if pos == 1 then\n\t\t\tlocal idx = 2\n\t\t\tlocal min = lst[1]\n\t\t\twhile idx\
    \ <= n do\n\t\t\t\tif lst[idx] < min then\n\t\t\t\t\tmin = lst[idx]\n\t\t\t\t\
    end\n\t\t\t\tidx = idx + 1\n\t\t\tend\n\t\t\tpos = 2\n\t\t\treturn min\n\t\telse\n\
    \t\t\tlocal idx = 1\n\t\t\tlocal max = lst[1]\n\t\t\twhile idx <= n do\n\t\t\t\
    \tif lst[idx] > max then\n\t\t\t\t\tmax = lst[idx]\n\t\t\t\tend\n\t\t\t\tidx =\
    \ idx + 1\n\t\t\tend\n\t\t\tpos = 1\n\t\t\treturn max\n\t\tend\n\tend\n\tlocal\
    \ idx = 1\n\twhile idx <= n do\n\t\tret[idx] = get()\n\t\tidx = idx + 1\n\tend\n\
    \treturn ret\nend", "   if not lst or #lst == 0 then return {} end\n   if #lst\
    \ == 1 then return lst end\n   table.sort(lst)\n   local res = {}\n   local i\
    \ = 1\n   local j = #lst\n   local dir = 1\n   while i < j do\n      if dir ==\
    \ 1 then\n         table.insert(res, lst[i])\n         i = i + 1\n      else\n\
    \         table.insert(res, lst[j])\n         j = j - 1\n      end\n      dir\
    \ = -dir\n   end\n   if i == j then\n      table.insert(res, lst[i])\n   end\n\
    \   return res\nend", "    if not lst or #lst < 2 then\n        return lst\n \
    \   end\n    table.sort(lst)\n    local result = {}\n    local is_first = true\n\
    \    local to_search = lst\n    local min_max = #lst % 2 == 0 and 1 or 2\n   \
    \ while to_search and #to_search > 0 do\n        if is_first then\n          \
    \  result[#result + 1] = to_search[1]\n            table.remove(to_search, 1)\n\
    \        else\n            result[#result + 1] = to_search[#to_search]\n     \
    \       table.remove(to_search, #to_search)\n        end\n        is_first = not\
    \ is_first\n    end\n    return result\nend", "\tlocal min_idx = lst:argmin(1)[1]\n\
    \tlocal max_idx = lst:argmax(1)[1]\n\tlocal result = lst:clone()\n\tresult[1]\
    \ = lst[min_idx]\n\tresult[2] = lst[max_idx]\n\tlocal is_min = false\n\tlocal\
    \ idx = 1\n\tfor i = 3, lst:size(1) do\n\t\tif is_min then\n\t\t\tidx = result:argmin(1)[1]\n\
    \t\telse\n\t\t\tidx = result:argmax(1)[1]\n\t\tend\n\t\tis_min = not is_min\n\t\
    \tresult[i] = lst[idx]\n\tend\n\treturn result\nend", "  local res = {}\n  while\
    \ #lst > 0 do\n    table.insert(res, math.min(unpack(lst)))\n    table.remove(lst,\
    \ table.index_of(lst, math.min(unpack(lst))))\n    if #lst == 0 then break end\n\
    \    table.insert(res, math.max(unpack(lst)))\n    table.remove(lst, table.index_of(lst,\
    \ math.max(unpack(lst))))\n  end\n  return res\nend", "    local function helper(lst,sorted)\n\
    \        local min = nil\n        local max = nil\n        local min_idx = nil\n\
    \        local max_idx = nil\n        for i,v in ipairs(lst) do\n            if\
    \ not min or v < min then\n                min = v\n                min_idx =\
    \ i\n            end\n            if not max or v > max then\n               \
    \ max = v\n                max_idx = i\n            end\n        end\n       \
    \ if min_idx then\n            table.insert(sorted,min)\n            table.remove(lst,min_idx)\n\
    \        end\n        if max_idx then\n            table.insert(sorted,max)\n\
    \            table.remove(lst,max_idx)\n        end\n        if #lst > 0 then\n\
    \            return helper(lst,sorted)\n        else\n            return sorted\n\
    \        end\n    end\n    return helper(lst,{})\nend", "    local min, max =\
    \ min_max(lst)\n    local i, j = 1, #lst", "    local new_lst = { }\n    local\
    \ len = #lst\n    local sort_lst = List.sort(lst)\n    local idx = 1\n    local\
    \ pos = 1\n    while idx <= len do\n        if idx % 2 == 1 then\n           \
    \ new_lst[idx] = sort_lst[pos]\n            pos = pos + 1\n        else\n    \
    \        new_lst[idx] = sort_lst[len - pos + 1]\n        end\n        idx = idx\
    \ + 1\n    end\n    return new_lst\nend", "  -- Just sort them in the right order.\n\
    \  local function aux(lst, acc)\n    if #lst == 0 then\n      return acc\n   \
    \ else\n      return aux(lst_slice(lst, 2, nil), acc .. lst[1])\n    end\n  end\n\
    \  local res = aux(lst, \"\")\n  return lst_map(function(c) return tonumber(c)\
    \ end, str_split(res, \"\"))\nend", "  local temp = lst\n  local min_val = temp[1]\n\
    \  local min_ind = 1\n  local i = 2\n  local res = {}\n  -- get minimum from list\n\
    \  while i <= #temp do\n    if temp[i] < min_val then\n      min_val = temp[i]\n\
    \      min_ind = i\n    end\n    i = i + 1\n  end\n  res[#res + 1] = min_val\n\
    \  -- remove minimum from list\n  table.remove(temp, min_ind)\n  -- get maximum\
    \ from list\n  i = 1\n  local max_val = temp[1]\n  local max_ind = 1\n  while\
    \ i <= #temp do\n    if temp[i] > max_val then\n      max_val = temp[i]\n    \
    \  max_ind = i\n    end\n    i = i + 1\n  end\n  res[#res + 1] = max_val\n  --\
    \ remove maximum from list\n  table.remove(temp, max_ind)\n  -- if list is not\
    \ empty, call this function again, otherwise return result\n  if #temp > 0 then\n\
    \    return strange_sort_list(temp)\n  else\n    return res\n  end\nend", "  local\
    \ l1, l2 = {}, {}\n  for i, n in ipairs(lst) do\n    if i % 2 == 1 then\n    \
    \  table.insert(l1, n)\n    else\n      table.insert(l2, n)\n    end\n  end\n\
    \  local s = {}\n  while #l1 > 0 and #l2 > 0 do\n    table.insert(s, table.remove(l1,\
    \ 1))\n    table.insert(s, table.remove(l2, 1))\n  end\n  if #l1 > 0 then\n  \
    \  for _, n in ipairs(l1) do\n      table.insert(s, n)\n    end\n  elseif #l2\
    \ > 0 then\n    for _, n in ipairs(l2) do\n      table.insert(s, n)\n    end\n\
    \  end\n  return s\nend", "    local min = math.min(unpack(lst))\n    local max\
    \ = math.max(unpack(lst))\n    local re = {min}\n    while min < max do\n    \
    \    local larger = 0\n        for i,v in ipairs(lst) do\n            if v > min\
    \ and v > larger then\n                larger = v\n            end\n        end\n\
    \        table.insert(re, larger)\n        min = larger\n    end\n    return re\n\
    end", "  local len = list.len(lst)\n  local min = function(a, b) return a < b\
    \ end\n  local max = function(a, b) return a > b end\n  local op = min\n  local\
    \ r = {}\n  for i = 1, len do\n    r[i] = list.foldl1(op, lst)\n    table.remove(lst,\
    \ list.index_of(lst, r[i]))\n    op = op == min and max or min\n  end\n  return\
    \ r\nend", "    local min = math.min(unpack(lst))\n    local lst_copy = utils.copy_table(lst)\n\
    \    local res = {min}\n    table.remove(lst_copy, min)\n    while #lst_copy >\
    \ 0 do\n        local max = math.max(unpack(lst_copy))\n        table.insert(res,\
    \ max)\n        table.remove(lst_copy, max)\n        if #lst_copy > 0 then\n \
    \           local min = math.min(unpack(lst_copy))\n            table.insert(res,\
    \ min)\n            table.remove(lst_copy, min)\n        end\n    end\n    return\
    \ res\nend", "    local result = {}\n    local max_value\n    local min_value\n\
    \    local min_index\n    local max_index\n    local left_list\n    local right_list\n\
    \    while #lst > 0 do\n        min_value = lst[1]\n        max_value = lst[1]\n\
    \        min_index = 1\n        max_index = 1\n        for i = 1, #lst do\n  \
    \          if lst[i] < min_value then\n                min_value = lst[i]\n  \
    \              min_index = i\n            end\n            if lst[i] > max_value\
    \ then\n                max_value = lst[i]\n                max_index = i\n  \
    \          end\n        end\n        if #result % 2 == 0 then\n            table.insert(result,\
    \ min_value)\n        else\n            table.insert(result, max_value)\n    \
    \    end\n        table.remove(lst, min_index)\n        table.remove(lst, max_index)\n\
    \    end\n    return result\nend", "    local _min, _max = math.min, math.max\n\
    \    local _floor, _ceil = math.floor, math.ceil\n    local _max_val, _min_val\
    \ = _max(unpack(lst)), _min(unpack(lst))\n    local _curr_min, _curr_max = _min_val,\
    \ _max_val\n    local _result, _first = {_min_val}, true\n    for _, _val in ipairs(lst)\
    \ do\n        if _val ~= _min_val and _val ~= _max_val then\n            if _first\
    \ then\n                _first = false\n                _result[#_result + 1]\
    \ = _val\n            else\n                _result[#_result + 1] = _val\n   \
    \             _first = true\n            end\n        end\n    end\n    if not\
    \ _first then\n        _result[#_result + 1] = _max_val\n    end\n    return _result\n\
    end", "    local a_lst = {}\n    for i = 1, #lst do\n        a_lst[i] = lst[i]\n\
    \    end\n    local b_lst = {}\n    while #a_lst > 0 do\n        local m_idx =\
    \ 1\n        local m_val = a_lst[1]\n        for i = 2, #a_lst do\n          \
    \  if a_lst[i] < m_val then\n                m_idx = i\n                m_val\
    \ = a_lst[i]\n            end\n        end\n        b_lst[#b_lst + 1] = m_val\n\
    \        table.remove(a_lst, m_idx)\n        if #a_lst == 0 then\n           \
    \ break\n        end\n        local m_idx = 1\n        local m_val = a_lst[1]\n\
    \        for i = 2, #a_lst do\n            if a_lst[i] > m_val then\n        \
    \        m_idx = i\n                m_val = a_lst[i]\n            end\n      \
    \  end\n        b_lst[#b_lst + 1] = m_val\n        table.remove(a_lst, m_idx)\n\
    \    end\n    return b_lst\nend", "    local len = #lst\n    local res = { }\n\
    \    local min_val, max_val = min(lst), max(lst)\n    for i = 1, len do\n    \
    \    if i % 2 == 1 then\n            table.insert(res, min_val)\n            min_val\
    \ = min(lst, min_val)\n        else\n            table.insert(res, max_val)\n\
    \            max_val = max(lst, max_val)\n        end\n    end\n    return res\n\
    end", "  --sort list, then take first and last, then second and second-last, etc.\n\
    \  local lst = table.sort(lst)\n  local res = {}\n  for i=1,math.floor(#lst/2)\
    \ do\n    table.insert(res, lst[i])\n    table.insert(res, lst[#lst-i+1])\n  end\n\
    \  return res\nend", "  if not lst then return nil end\n  local sorted = {table.remove(lst,1)}\n\
    \  local size = #lst\n  for i = 1, size do\n    table.insert(sorted,1,table.remove(lst))\n\
    \    table.insert(sorted,table.remove(lst))\n  end\n  return sorted\nend", "\t\
    local min, max, min_ind, max_ind, a, b, c, d\n\tlocal result = {}\n\tif #lst %\
    \ 2 == 0 then\n\t\tresult[1] = math.min(unpack(lst))\n\t\tfor i = 2, #lst do\n\
    \t\t\ta, b = math.min(unpack(lst)), math.max(unpack(lst))\n\t\t\tmin_ind, max_ind\
    \ = 0, 0\n\t\t\tfor ind, val in ipairs(lst) do\n\t\t\t\tif val == a then\n\t\t\
    \t\t\tmin_ind = ind\n\t\t\t\tend\n\t\t\t\tif val == b then\n\t\t\t\t\tmax_ind\
    \ = ind\n\t\t\t\tend\n\t\t\tend\n\t\t\tif i % 2 == 0 then\n\t\t\t\tresult[i] =\
    \ lst[min_ind]\n\t\t\t\ttable.remove(lst, min_ind)\n\t\t\telse\n\t\t\t\tresult[i]\
    \ = lst[max_ind]\n\t\t\t\ttable.remove(lst, max_ind)\n\t\t\tend\n\t\tend\n\telse\n\
    \t\tresult[1] = math.max(unpack(lst))\n\t\tfor i = 2, #lst do\n\t\t\ta, b = math.min(unpack(lst)),\
    \ math.max(unpack(lst))\n\t\t\tmin_ind, max_ind = 0, 0\n\t\t\tfor ind, val in\
    \ ipairs(lst) do\n\t\t\t\tif val == a then\n\t\t\t\t\tmin_ind = ind\n\t\t\t\t\
    end\n\t\t\t\tif val == b then\n\t\t\t\t\tmax_ind = ind\n\t\t\t\tend\n\t\t\tend\n\
    \t\t\tif i % 2 == 0 then\n\t\t\t\tresult[i] = lst[min_ind]\n\t\t\t\ttable.remove(lst,\
    \ min_ind)\n\t\t\telse\n\t\t\t\tresult[i] = lst[max_ind]\n\t\t\t\ttable.remove(lst,\
    \ max_ind)\n", "    local min, max = min_and_max(lst)\n    local result = {}\n\
    \    local mode = 'min'\n    while #lst > 0 do\n        local el\n        if mode\
    \ == 'min' then\n            el = min\n            mode = 'max'\n        else\n\
    \            el = max\n            mode = 'min'\n        end\n        table.insert(result,\
    \ el)\n        delete_value(lst, el)\n        min, max = min_and_max(lst)\n  \
    \  end\n    return result\nend", "  table.sort(lst)\n  local tmp = {}\n  local\
    \ n = math.floor(#lst / 2)\n  for i = 1, n do\n    tmp[#tmp + 1] = lst[#lst -\
    \ i + 1]\n    tmp[#tmp + 1] = lst[i]\n  end\n  if (#lst % 2) == 1 then\n    tmp[#tmp\
    \ + 1] = lst[n + 1]\n  end\n  return tmp\nend", "    local s = {}\n    table.sort(lst)\n\
    \    local i = 1\n    while #lst > 0 do\n        s[i] = table.remove(lst, 1)\n\
    \        if #lst > 0 then\n            s[i + 1] = table.remove(lst)\n        end\n\
    \        i = i + 2\n    end\n    return s\nend", "    local function rec(lst)\n\
    \        if #lst == 0 then\n            return lst\n        end\n        local\
    \ l, r = lst[1], lst[#lst]\n        local m = math.min(l, r)\n        local M\
    \ = math.max(l, r)\n        lst[1], lst[#lst] = m, M\n        return {m, rec(lst)}\n\
    \    end\n    return rec(lst)\nend", "  --...\nend", "\t-- take each element from\
    \ the list and place in a new list\n\t-- in order of lowest to highest\n\tlocal\
    \ ordered_lst = {}\n\tlocal i\n\tfor i=1,#lst do\n\t\tlocal minimum = math.min(unpack(lst))\n\
    \t\tordered_lst[#ordered_lst+1] = minimum\n\t\t--print(minimum)\n\t\ttable.remove(lst,index_of(lst,minimum))\n\
    \tend\n\t-- take new ordered list and form into strange sorted list\n\tlocal strange_lst\
    \ = {}\n\tlocal ordered_i = 1\n\tlocal reverse_i = #ordered_lst\n\twhile ordered_i\
    \ <= #ordered_lst do\n\t\t--print(reverse_i)\n\t\tstrange_lst[#strange_lst+1]\
    \ = ordered_lst[ordered_i]\n\t\tif ordered_i ~= reverse_i then\n\t\t\tstrange_lst[#strange_lst+1]\
    \ = ordered_lst[reverse_i]\n\t\tend\n\t\tordered_i = ordered_i + 1\n\t\treverse_i\
    \ = reverse_i - 1\n\tend\n\treturn strange_lst\nend", "  table.sort(lst)\n  local\
    \ res = {}\n  local head, tail = 1, #lst\n  while head <= tail do\n    table.insert(res,\
    \ lst[head])\n    head = head + 1\n    if head <= tail then\n      table.insert(res,\
    \ lst[tail])\n      tail = tail - 1\n    end\n  end\n  return res\nend", "\t--\
    \ The strange sort.\n\tlocal function strange_sort(lst, res)\n\t\t-- Fetch minimum\
    \ value.\n\t\tlocal min = math.min(unpack(lst))\n\t\t-- Fetch maximum value.\n\
    \t\tlocal max = math.max(unpack(lst))\n\t\t-- Remove minimum value.\n\t\tremove_value(lst,\
    \ min)\n\t\t-- Remove maximum value.\n\t\tremove_value(lst, max)\n\t\t-- Add to\
    \ result.\n\t\ttable.insert(res, min)\n\t\ttable.insert(res, max)\n\t\t-- Perform\
    \ recursion, if there are more values to sort.\n\t\tif #lst > 0 then\n\t\t\treturn\
    \ strange_sort(lst, res)\n\t\telse\n\t\t\treturn res\n\t\tend\n\tend\n\t-- Output\
    \ sorted list.\n\treturn strange_sort(lst, {})\nend", "    -- first sort list\
    \ normally\n    lst = table.sort(lst)\n    local new_lst = {}\n    -- now iterate\
    \ through list and add value to new list\n    -- based on whether it's the first\
    \ or second value\n    for i = 1, #lst do\n        if i % 2 == 1 then\n      \
    \      -- we're dealing with odd numbers\n            new_lst[#new_lst + 1] =\
    \ lst[i]\n        else\n            -- we're dealing with even numbers\n     \
    \       new_lst[#new_lst + 1] = lst[#lst - i + 1]\n        end\n    end\n    return\
    \ new_lst\nend", "  local set = {}\n  local result = {}\n  local x, y\n  for _,\
    \ v in ipairs(lst) do\n    table.insert(set, v)\n  end\n  table.sort(set)\n  while\
    \ #set > 0 do\n    x = table.remove(set, 1)\n    table.insert(result, x)\n   \
    \ if #set > 0 then\n      y = table.remove(set, #set)\n      table.insert(result,\
    \ y)\n    end\n  end\n  return result\nend", "  local n = #lst\n  local idx =\
    \ {}\n  for i = 1, n do\n    idx[i] = i\n  end\n  local res = {}\n  for i = 1,\
    \ n do\n    local m = math.min(unpack(lst))\n    table.insert(res, m)\n    local\
    \ i1 = table.index(lst, m)\n    table.remove(lst, i1)\n    table.remove(idx, i1)\n\
    \    local m = math.max(unpack(lst))\n    table.insert(res, m)\n    local i2 =\
    \ table.index(lst, m)\n    table.remove(lst, i2)\n    table.remove(idx, i2)\n\
    \  end\n  return res\nend", "    local minimum = math.min(table.unpack(lst))\n\
    \    local maximum = math.max(table.unpack(lst))\n    local result = {}\n    local\
    \ i = 1\n    while #lst > 0 do\n        local pos = 1\n        if i % 2 == 0 then\n\
    \            pos = #lst\n        end\n        result[#result + 1] = lst[pos]\n\
    \        table.remove(lst, pos)\n        i = i + 1\n    end\n    return result\n\
    end", "    local values = {}\n    local results = {}\n    for _, v in ipairs(lst)\
    \ do table.insert(values, v) end\n    table.sort(values)\n    local max_index\
    \ = #values\n    local min_index = 1\n    for i = 1, #values do\n        if i\
    \ % 2 == 1 then\n            table.insert(results, values[min_index])\n      \
    \      min_index = min_index + 1\n        else\n            table.insert(results,\
    \ values[max_index])\n            max_index = max_index - 1\n        end\n   \
    \ end\n    return results\nend", "    table.sort(lst)\n    local res, cnt = {},\
    \ #lst\n    while cnt > 0 do\n        if cnt % 2 == 0 then\n            res[#res\
    \ + 1] = table.remove(lst, 1)\n        else\n            res[#res + 1] = table.remove(lst)\n\
    \        end\n        cnt = cnt - 1\n    end\n    return res\nend", "\tlocal res,\
    \ alst, blst = {}, {}, {}\n\tlocal llst = list.copy(lst)\n\t-- We start by removing\
    \ the minimum value\n\tlocal min = list.min(llst)\n\tlist.remove_value(llst, min)\n\
    \ttable.insert(res, min)\n\t-- We continue with minimum/maximum values until we\n\
    \t-- reach the end of the list.\n\twhile #llst > 0 do\n\t\tlocal max = list.max(llst)\n\
    \t\tlist.remove_value(llst, max)\n\t\ttable.insert(res, max)\n\t\tlocal min =\
    \ list.min(llst)\n\t\tlist.remove_value(llst, min)\n\t\ttable.insert(res, min)\n\
    \tend\n\treturn res\nend", "  local function _strange_sort_list(lst, result)\n\
    \    if #lst == 0 then\n      return result\n    end\n    local min_val, min_idx\
    \ = table.min(lst)\n    table.remove(lst, min_idx)\n    table.insert(result, min_val)\n\
    \    local max_val, max_idx = table.max(lst)\n    table.remove(lst, max_idx)\n\
    \    table.insert(result, max_val)\n    return _strange_sort_list(lst, result)\n\
    \  end\n  return _strange_sort_list(lst, {})\nend", "    if #lst < 2 then\n  \
    \      return lst\n    end\n    local lst_len = #lst\n    local min_n = min(lst)\n\
    \    local max_n = max(lst)\n    local rv = {min_n}\n    table.remove(lst, index_of(lst,\
    \ min_n))\n    while #lst > 0 do\n        local tmp_val = lst[1]\n        local\
    \ idx = 2\n        while idx <= #lst do\n            if abs(tmp_val - min_n) >\
    \ abs(lst[idx] - min_n) then\n                tmp_val = lst[idx]\n           \
    \ end\n            idx = idx + 1\n        end\n        table.remove(lst, index_of(lst,\
    \ tmp_val))\n        table.insert(rv, tmp_val)\n        min_n = tmp_val\n    end\n\
    \    return rv\nend", "  return nil\nend", "    local lst_min, lst_max = {}, {}\n\
    \    for _, el in ipairs(lst) do\n        if el > 0 then\n            table.insert(lst_max,\
    \ el)\n        else\n            table.insert(lst_min, el)\n        end\n    end\n\
    \    table.sort(lst_min)\n    table.sort(lst_max, function(a, b) return a > b\
    \ end)\n    local i, j = 1, 1\n    local res = {}\n    while i <= #lst_min and\
    \ j <= #lst_max do\n        table.insert(res, lst_min[i])\n        table.insert(res,\
    \ lst_max[j])\n        i = i + 1\n        j = j + 1\n    end\n    while i <= #lst_min\
    \ do\n        table.insert(res, lst_min[i])\n        i = i + 1\n    end\n    while\
    \ j <= #lst_max do\n        table.insert(res, lst_max[j])\n        j = j + 1\n\
    \    end\n    return res\nend", "\tlocal result = {}\n\tlocal sorted = {}\n\t\
    for i = 1, #lst do\n\t\ttable.insert(sorted, lst[i])\n\tend\n\ttable.sort(sorted)\n\
    \tlocal ascending = true\n\tlocal i = 1\n\twhile #sorted > 0 do\n\t\tif ascending\
    \ then\n\t\t\tresult[i] = table.remove(sorted, 1)\n\t\telse\n\t\t\tresult[i] =\
    \ table.remove(sorted)\n\t\tend\n\t\tascending = not ascending\n\t\ti = i + 1\n\
    \tend\n\treturn result\nend", "  local lst = sll.list_to_list(lst)\n  local l,\
    \ i = {}, 1\n  while lst do\n    local mn, mx = sll.min_max(lst)\n    if i % 2\
    \ == 1 then\n      l[i], lst = mn, sll.remove(lst, mn)\n    else\n      l[i],\
    \ lst = mx, sll.remove(lst, mx)\n    end\n    i = i + 1\n  end\n  return l\nend",
  "    local new_lst = {}\n    while lst[1] do\n        local min, max = table.remove(lst,\
    \ 1), table.remove(lst, 1)\n        if not max then\n            table.insert(new_lst,\
    \ min)\n        else\n            table.insert(new_lst, min)\n            table.insert(new_lst,\
    \ max)\n        end\n    end\n    return new_lst\nend", "  local min_val, max_val,\
    \ result = math.min(unpack(lst)), math.max(unpack(lst)), {}\n  for _, v in ipairs(lst)\
    \ do\n    if v == min_val then\n      result[#result + 1] = v\n    elseif v ==\
    \ max_val then\n      result[#result + 1] = v\n    end\n  end\n  for _, v in ipairs(lst)\
    \ do\n    if v ~= min_val and v ~= max_val then\n      result[#result + 1] = v\n\
    \    end\n  end\n  return result\nend", "    local head, tail, result = lst[1],\
    \ {unpack(lst, 2)}, {}\n    while #tail > 0 do\n        local min, min_idx = math.min(unpack(tail))\n\
    \        local max, max_idx = math.max(unpack(tail))\n        table.insert(result,\
    \ head)\n        if head == min then\n            table.insert(result, max)\n\
    \            table.remove(tail, max_idx)\n        else\n            table.insert(result,\
    \ min)\n            table.remove(tail, min_idx)\n        end\n        head = tail[1]\n\
    \        table.remove(tail, 1)\n    end\n    table.insert(result, head)\n    return\
    \ result\nend", "  local min, max, flag, tmp = 999999, -999999, true, {}\n  while\
    \ (#lst > 0) do\n    if flag then\n      min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \      table.insert(tmp, min)\n      if #lst > 1 then table.insert(tmp, max) end\n\
    \    else\n      table.insert(tmp, max)\n      if #lst > 1 then table.insert(tmp,\
    \ min) end\n    end\n    for k,v in pairs(lst) do\n      if v == min or v == max\
    \ then\n        table.remove(lst, k)\n        break\n      end\n    end\n    flag\
    \ = not flag\n  end\n  return tmp\nend", "   local min, max = math.min, math.max\n\
    \   local idx = 2\n   local list = {min(table.unpack(lst))}", "    --[[ Solution\
    \ 1:\n    --\n    -- If the given list is empty, return it.\n    if #lst == 0\
    \ then\n        return lst\n    end", "  local val = table.remove(lst, 1)\n  table.insert(lst,\
    \ val)\n  local lo = {}\n  local hi = {}\n  for _, elem in ipairs(lst) do\n  \
    \  if elem > val then\n      table.insert(hi, elem)\n    else\n      table.insert(lo,\
    \ elem)\n    end\n  end\n  table.sort(lo)\n  table.sort(hi, function(a, b) return\
    \ a > b end)\n  table.insert(lo, val)\n  for _, elem in ipairs(hi) do\n    table.insert(lo,\
    \ elem)\n  end\n  return lo\nend", "  local result = { }\n  local even = false\n\
    \  local second = true\n  while next(lst) do\n    local min, min_i = lst[1], 1\n\
    \    local max, max_i = lst[1], 1\n    for i, val in ipairs(lst) do\n      if\
    \ val < min then\n        min, min_i = val, i\n      end\n      if val > max then\n\
    \        max, max_i = val, i\n      end\n    end\n    if not second or not even\
    \ then\n      result[#result + 1] = min\n      table.remove(lst, min_i)\n    else\n\
    \      result[#result + 1] = max\n      table.remove(lst, max_i)\n    end\n  \
    \  second = not second\n    if next(lst) == nil then\n      even = not even\n\
    \      second = true\n    end\n  end\n  return result\nend", "  if not lst or\
    \ #lst < 2 then return lst end\n  local min_index = 1\n  local max_index = #lst\n\
    \  local result = {}\n  local i = 1\n  while true do\n    result[i] = lst[min_index]\n\
    \    i = i + 1\n    if max_index == min_index then break end\n    result[i] =\
    \ lst[max_index]\n    i = i + 1\n    if max_index == min_index + 1 then break\
    \ end\n    min_index = min_index + 1\n    max_index = max_index - 1\n  end\n \
    \ return result\nend", "    local res = {}\n    local start_min = true\n    local\
    \ sorted_lst = quicksort(lst)\n    local i = 1\n    while i <= #sorted_lst do\n\
    \        if start_min then\n            res[#res + 1] = sorted_lst[i]\n      \
    \      i = i + 1\n        else\n            res[#res + 1] = sorted_lst[#sorted_lst\
    \ - i + 1]\n            i = i + 1\n        end\n        start_min = not start_min\n\
    \    end\n    return res\nend", "  if type(lst) ~= 'table' then\n    return {\
    \ lst }\n  end\n  if #lst == 0 then\n    return {}\n  end\n  local new_lst = {}\n\
    \  local min, max = min_max(lst)\n  local lst_without_min = without(lst, min)\n\
    \  local lst_without_max = without(lst, max)\n  local min_idx = 1\n  local max_idx\
    \ = #lst - 1\n  if #lst_without_min > 0 then\n    local first_idx = min_idx\n\
    \    local res = strange_sort_list(lst_without_min)\n    for i, v in ipairs(res)\
    \ do\n      new_lst[first_idx] = v\n      first_idx = first_idx + 2\n    end\n\
    \  end\n  if #lst_without_max > 0 then\n    local second_idx = max_idx\n    local\
    \ res = strange_sort_list(lst_without_max)\n    for i, v in ipairs(res) do\n \
    \     new_lst[second_idx] = v\n      second_idx = second_idx - 2\n    end\n  end\n\
    \  new_lst[min_idx] = min\n  new_lst[max_idx] = max\n  return new_lst\nend", " \
    \   local res = { }\n    local min = math.min(unpack(lst))\n    local max = math.max(unpack(lst))\n\
    \    local is_min = true\n    while true do\n        if is_min then\n        \
    \    local i = 1\n            while lst[i] ~= min do\n                i = i +\
    \ 1\n            end\n            table.insert(res, min)\n            table.remove(lst,\
    \ i)\n            if #lst == 0 then\n                break\n            end\n\
    \            min = math.min(unpack(lst))\n        else\n            local i =\
    \ 1\n            while lst[i] ~= max do\n                i = i + 1\n         \
    \   end\n            table.insert(res, max)\n            table.remove(lst, i)\n\
    \            if #lst == 0 then\n                break\n            end\n     \
    \       max = math.max(unpack(lst))\n        end\n        is_min = not is_min\n\
    \    end\n    return res\nend", "\tlocal function swap(i, j)\n\t\tlocal temp =\
    \ lst[i]\n\t\tlst[i] = lst[j]\n\t\tlst[j] = temp\n\tend", "  -- Implementation\
    \ of a Max-Heap.\n  local function swap(t, i, j)\n    t[i], t[j] = t[j], t[i]\n\
    \  end", "    local sorted = {}\n    local sorted_index = 1\n    -- find smallest\
    \ and biggest elements\n    local min, max = math.min(unpack(lst)), math.max(unpack(lst))\n\
    \    -- remove smallest element\n    for i = 1, #lst do\n        if lst[i] ==\
    \ min then\n            table.remove(lst, i)\n            break\n        end\n\
    \    end\n    -- remove biggest element\n    for i = 1, #lst do\n        if lst[i]\
    \ == max then\n            table.remove(lst, i)\n            break\n        end\n\
    \    end\n    -- add elements in strange order\n    repeat\n        sorted[sorted_index]\
    \ = min\n        sorted_index = sorted_index + 1\n        min = math.min(unpack(lst))\n\
    \        for i = 1, #lst do\n            if lst[i] == min then\n             \
    \   table.remove(lst, i)\n                break\n            end\n        end\n\
    \        if sorted_index == #lst then\n            sorted[sorted_index] = min\n\
    \            break\n        end\n        sorted[sorted_index] = max\n        sorted_index\
    \ = sorted_index + 1\n        max = math.max(unpack(lst))\n        for i = 1,\
    \ #lst do\n            if lst[i] == max then\n                table.remove(lst,\
    \ i)\n                break\n            end\n        end\n    until sorted_index\
    \ == #lst\n    return sorted\nend", "    local res = {}\n    local min_value =\
    \ math.min(unpack(lst))\n    local max_value = math.max(unpack(lst))\n    local\
    \ size = #lst\n    for i = 1, size do\n        if min_value <= max_value then\n\
    \            res[i] = min_value\n            min_value = math.min(unpack(lst))\n\
    \        else\n            res[i] = max_value\n            max_value = math.max(unpack(lst))\n\
    \        end\n    end\n    return res\nend", "    local function find_min_and_max_and_remove(lst)\n\
    \        local min_i = 1\n        local max_i = 1\n        for i, v in ipairs(lst)\
    \ do\n            if v < lst[min_i] then\n                min_i = i\n        \
    \    end\n            if v > lst[max_i] then\n                max_i = i\n    \
    \        end\n        end\n        local min = lst[min_i]\n        local max =\
    \ lst[max_i]\n        table.remove(lst, max_i)\n        table.remove(lst, min_i)\n\
    \        return min, max\n    end", "  local result = {}\n  local max = nil\n\
    \  local min = nil\n  local inc = true\n  local function get_min(lst)\n    local\
    \ min_idx = 1\n    local min_val = lst[1]\n    for i = 2, #lst do\n      if lst[i]\
    \ < min_val then\n        min_idx = i\n        min_val = lst[i]\n      end\n \
    \   end\n    return min_idx, min_val\n  end\n  local function get_max(lst)\n \
    \   local max_idx = 1\n    local max_val = lst[1]\n    for i = 2, #lst do\n  \
    \    if lst[i] > max_val then\n        max_idx = i\n        max_val = lst[i]\n\
    \      end\n    end\n    return max_idx, max_val\n  end\n  while #lst > 0 do\n\
    \    if inc then\n      min, min_idx = get_min(lst)\n      lst[min_idx] = nil\n\
    \      inc = false\n    else\n      max, max_idx = get_max(lst)\n      lst[max_idx]\
    \ = nil\n      inc = true\n    end\n    table.insert(result, min)\n    table.insert(result,\
    \ max)\n  end\n  return result\nend", "    -- Insert your code here\n    local\
    \ min=lst[1]\n    local max=lst[1]\n    local min_idx=1\n    local max_idx=1\n\
    \    local len=#lst\n    local res={}\n    local swap=0\n    local result_len=0\n\
    \    local is_min=true\n    for idx=1,len do\n        if lst[idx]>max then\n \
    \           max=lst[idx]\n            max_idx=idx\n        end\n        if lst[idx]<min\
    \ then\n            min=lst[idx]\n            min_idx=idx\n        end\n    end\n\
    \    res[1]=min\n    result_len=1\n    if min_idx==1 then\n        is_min=false\n\
    \    end\n    for idx=1,len do\n        if lst[idx]~=res[result_len] then\n  \
    \          if is_min then\n                if lst[idx]>res[result_len] then\n\
    \                    res[result_len+1]=lst[idx]\n                    result_len=result_len+1\n\
    \                    is_min=false\n                end\n            else\n   \
    \             if lst[idx]<res[result_len] then\n                    res[result_len+1]=lst[idx]\n\
    \                    result_len=result_len+1\n                    is_min=true\n\
    \                end\n            end\n        end\n    end\n    return res\n\
    end", "    local lst_as_str = {}\n    for _, v in ipairs(lst) do\n        lst_as_str[#lst_as_str\
    \ + 1] = tostring(v)\n    end\n    table.sort(lst_as_str)\n    local index = 1\n\
    \    local res = {}\n    while #lst_as_str > 0 do\n        res[index] = tonumber(lst_as_str[1])\n\
    \        table.remove(lst_as_str, 1)\n        if #lst_as_str > 0 then\n      \
    \      res[index + 1] = tonumber(lst_as_str[#lst_as_str])\n            table.remove(lst_as_str,\
    \ #lst_as_str)\n        end\n        index = index + 2\n    end\n    return res\n\
    end", "  -- fill in implementation here\nend", "    local index = 1\n    local\
    \ sign = 1\n    local result = {}\n    local copy = {}\n    for i = 1, #lst do\n\
    \        copy[i] = lst[i]\n    end\n    table.sort(copy)\n    for i = 1, #copy\
    \ do\n        result[index] = copy[i]\n        index = index + sign\n        if\
    \ index > #copy then\n            index = #copy - 1\n            sign = -1\n \
    \       elseif index < 1 then\n            index = 2\n            sign = 1\n \
    \       end\n    end\n    return result\nend", "    --[[\n    local function strange_sort_list(lst)\n\
    \        if #lst == 0 then return {} end\n        local result = {}\n        local\
    \ min_index = 0\n        local max_index = 0\n        for i, item in ipairs(lst)\
    \ do\n            if lst[min_index] < item then\n                min_index = i\n\
    \            end\n            if lst[max_index] > item then\n                max_index\
    \ = i\n            end\n        end\n        result[#result + 1] = lst[min_index]\n\
    \        table.remove(lst, min_index)\n        result[#result + 1] = lst[max_index]\n\
    \        table.remove(lst, max_index)\n        return result\n    end\n    local\
    \ tmp = {}\n    for i = 1, #lst do\n        tmp[i] = lst[i]\n    end\n    lst\
    \ = tmp\n    local result = {}\n    while #lst > 0 do\n        local tmp = strange_sort_list(lst)\n\
    \        for i = 1, #tmp do\n            result[#result + 1] = tmp[i]\n      \
    \  end\n    end\n    return result\n    --]]\n    --[]\n    local function strange_sort_list(lst)\n\
    \        if #lst == 0 then return {} end\n        local result = {}\n        local\
    \ min_index = 0\n        local max_index = 0\n        for i, item in ipairs(lst)\
    \ do\n            if lst[min_index] < item then\n                min_index = i\n\
    \            end\n            if lst[max_index] > item then\n                max_index\
    \ = i\n            end\n        end\n        result[#result + 1] = lst[min_index]\n\
    \        table.remove(lst, min_index)\n        result[#result + 1] = lst[max_index]\n\
    \        table.remove(lst, max_index)\n        return result\n    end\n    local\
    \ tmp = {}\n    for i = 1, #lst do\n        tmp[i] = lst[i]\n    end\n    lst\
    \ = tmp\n    local result = {}\n", "  local function strange_sort(min_val, max_val,\
    \ rem)\n    -- Base case\n    if #rem == 0 then\n      return {}\n    end\n  \
    \  -- Recursive case\n    if #rem == 1 then\n      if min_val then\n        return\
    \ {min_val, rem[1]}\n      else\n        return {rem[1]}\n      end\n    end\n\
    \    local new_rem = {}\n    for _, v in ipairs(rem) do\n      if v ~= min_val\
    \ and v ~= max_val then\n        table.insert(new_rem, v)\n      end\n    end\n\
    \    local next_max = math.max(table.unpack(new_rem))\n    local next_min = math.min(table.unpack(new_rem))\n\
    \    if min_val then\n      return strange_sort(min_val, next_max, new_rem)\n\
    \        .. strange_sort(next_min, max_val, new_rem)\n    else\n      return strange_sort(next_min,\
    \ next_max, new_rem)\n    end\n  end\n  return strange_sort(nil, nil, lst)\nend",
  "    local ordered = {}\n    local min = math.min(unpack(lst))\n    ordered[#ordered\
    \ + 1] = min\n    table.remove(lst, table.index_of(lst, min))\n    while #lst\
    \ > 0 do\n        local max = math.max(unpack(lst))\n        ordered[#ordered\
    \ + 1] = max\n        table.remove(lst, table.index_of(lst, max))\n        if\
    \ #lst == 0 then break end\n        local min = math.min(unpack(lst))\n      \
    \  ordered[#ordered + 1] = min\n        table.remove(lst, table.index_of(lst,\
    \ min))\n    end\n    return ordered\nend", "    local result = {}\n    local\
    \ nums = {}\n    for i = 1, #lst do\n        nums[i] = lst[i]\n    end\n    local\
    \ up = true\n    local count = 1\n    while #nums > 0 do\n        if up then\n\
    \            local min = math.min(unpack(nums))\n            result[count] = min\n\
    \            for i = 1, #nums do\n                if nums[i] == min then\n   \
    \                 table.remove(nums, i)\n                    break\n         \
    \       end\n            end\n        else\n            local max = math.max(unpack(nums))\n\
    \            result[count] = max\n            for i = 1, #nums do\n          \
    \      if nums[i] == max then\n                    table.remove(nums, i)\n   \
    \                 break\n                end\n            end\n        end\n \
    \       up = not up\n        count = count + 1\n    end\n    return result\nend",
  "  local res = {}\n  local t_lst = lua_table_copy(lst)\n  local t_lst_len = #t_lst\n\
    \  for i = 1, t_lst_len do\n    local min_val = math.min(unpack(t_lst))\n    local\
    \ max_val = math.max(unpack(t_lst))\n    local min_idx = table.index_of(t_lst,\
    \ min_val)\n    local max_idx = table.index_of(t_lst, max_val)\n    table.remove(t_lst,\
    \ max_idx)\n    table.remove(t_lst, min_idx)\n    table.insert(res, min_val)\n\
    \    table.insert(res, max_val)\n  end\n  return res\nend", "    if #lst <= 2\
    \ then\n        return lst\n    end\n    local function extract_extremes(lst)\n\
    \        local min_val, min_idx, max_val, max_idx\n        for idx, val in ipairs(lst)\
    \ do\n            if min_val == nil or val < min_val then\n                min_val\
    \ = val\n                min_idx = idx\n            end\n            if max_val\
    \ == nil or val > max_val then\n                max_val = val\n              \
    \  max_idx = idx\n            end\n        end\n        return min_val, min_idx,\
    \ max_val, max_idx\n    end\n    local function is_even(num)\n        return math.floor(num\
    \ / 2) == num / 2\n    end\n    local sorted_lst = {}\n    local idx = 1\n   \
    \ local min_val, min_idx, max_val, max_idx = extract_extremes(lst)\n    while\
    \ idx <= #lst do\n        table.insert(sorted_lst, min_val)\n        table.remove(lst,\
    \ min_idx)\n        table.insert(sorted_lst, max_val)\n        table.remove(lst,\
    \ max_idx)\n        if #lst > 0 then\n            min_val, min_idx, max_val, max_idx\
    \ = extract_extremes(lst)\n        end\n        idx = idx + 2\n    end\n    return\
    \ sorted_lst\nend", "   local function is_odd(x)\n      return x % 2 == 1\n  \
    \ end\n   local function is_even(x)\n      return x % 2 == 0\n   end\n   local\
    \ function sort_by_func(func)\n      return table.sort(lst, func)\n   end\n  \
    \ local function take_first_remaining(xs)\n      return xs[1]\n   end\n   local\
    \ function take_last_remaining(xs)\n      return xs[#xs]\n   end\n   local function\
    \ ordered_indices(xs)\n      local ret = {}\n      for i = 1, #xs do\n       \
    \  ret[i] = i\n      end\n      return ret\n   end\n   local function is_ordered(lst)\n\
    \      local function ordered_iter(xs)\n         return coroutine.wrap(function()\n\
    \            local prev = xs[1]\n            for i = 2, #xs do\n             \
    \  local curr = xs[i]\n               coroutine.yield(prev <= curr)\n        \
    \       prev = curr\n            end\n         end)\n      end\n      for is_ordered\
    \ in ordered_iter(lst) do\n         if not is_ordered then\n            return\
    \ false\n         end\n      end\n      return true\n   end\n   local function\
    \ ordered_indices_iter(lst)\n      return coroutine.wrap(function()\n        \
    \ local function ordered_indices_iter_core(i)\n            if i > #lst then\n\
    \               return\n            end\n            if is_ordered(lst) then\n\
    \               coroutine.yield(table.pack(table.unpack(ordered_indices(lst))))\n\
    \            end\n            for _,j in ipairs(ordered_indices(lst)) do\n   \
    \            for _,k in ipairs(ordered_indices(lst)) do\n                  local\
    \ copy = table.pack(table.unpack(lst))\n                  copy[j], copy[k] = copy[k],\
    \ copy[j]\n                  ordered_indices_iter_core(i + 1)\n              \
    \ end\n            end\n         end\n         ordered_indices_iter_core(1)\n\
    \      end)\n   end\n   local function ordered_ind", "    lst = util.lst2table(lst)\n\
    \    table.sort(lst)\n    local n = #lst\n    local i, j = 1, n", "  local a,\
    \ b = fp.partition(function(x) return x < 0 end, lst)\n  local a_odd, a_even =\
    \ fp.partition(function(x) return x % 2 == 1 end, a)\n  local b_odd, b_even =\
    \ fp.partition(function(x) return x % 2 == 1 end, b)\n  local a1 = fp.map(function(x)\
    \ return x * -1 end, a_odd)\n  local a2 = fp.map(function(x) return x * -1 end,\
    \ a_even)\n  local b1 = b_odd\n  local b2 = b_even\n  local a = a1\n  local b\
    \ = fp.map(function(x) return x * -1 end, b1)\n  local c = a2\n  local d = b2\n\
    \  return a .. b .. c .. d\nend", "\tlocal max_idx, min_idx, max, min\n\tlocal\
    \ result = {}\n\tfor i = 1, #lst do\n\t\tmax_idx, min_idx = 1, 1\n\t\tmax, min\
    \ = lst[1], lst[1]\n\t\tfor j = 1, #lst do\n\t\t\tif lst[j] < min then\n\t\t\t\
    \tmin = lst[j]\n\t\t\t\tmin_idx = j\n\t\t\tend\n\t\t\tif lst[j] > max then\n\t\
    \t\t\tmax = lst[j]\n\t\t\t\tmax_idx = j\n\t\t\tend\n\t\tend\n\t\ttable.insert(result,\
    \ lst[min_idx])\n\t\ttable.remove(lst, min_idx)\n\t\ttable.insert(result, lst[max_idx])\n\
    \t\ttable.remove(lst, max_idx)\n\tend\n\treturn result\nend", "    local min =\
    \ math.min(table.unpack(lst))\n    local max = math.max(table.unpack(lst))\n \
    \   local ret = {}\n    local i = 1\n    while #lst > 0 do\n        if i == 1\
    \ then\n            ret[#ret + 1] = min\n            remove_value(lst, min)\n\
    \        else\n            ret[#ret + 1] = max\n            remove_value(lst,\
    \ max)\n        end\n        i = (i == 1) and 2 or 1\n    end\n    return ret\n\
    end", "    -- not optimal, but easy to code\n    return recur_list(lst, {}, 1)\n\
    end", "    local t = {}\n    for i, val in ipairs(lst) do\n        t[i] = {val,\
    \ i}\n    end\n    table.sort(t, function(a, b) return a[1] < b[1] end)\n    local\
    \ res = {}\n    local len = #t\n    local i = 1\n    local j = len\n    while\
    \ i <= len do\n        res[i] = t[i][2]\n        if i < len then\n           \
    \ res[len] = t[j][2]\n            j = j - 1\n        end\n        i = i + 1\n\
    \        len = len - 1\n    end\n    return res\nend", "    local r = {}\n   \
    \ for i, v in ipairs(lst) do\n        r[#r + 1] = {v, i}\n    end\n    table.sort(r,\
    \ function(a, b) return a[1] < b[1] end)\n    local i = 1\n    local r2 = {}\n\
    \    while #r > 0 do\n        local v = table.remove(r, i)\n        if i == 1\
    \ then\n            i = #r\n        else\n            i = i - 1\n        end\n\
    \        r2[#r2 + 1] = v[1]\n    end\n    return r2\nend", "    local result =\
    \ {}\n    local maxi = -math.huge\n    local mini = math.huge\n    local index\
    \ = 1\n    for i = 1, #lst do\n        if lst[i] > maxi then\n            maxi\
    \ = lst[i]\n        end\n        if lst[i] < mini then\n            mini = lst[i]\n\
    \        end\n    end\n    while index <= #lst do\n        local min = math.huge\n\
    \        local max = -math.huge\n        for i = 1, #lst do\n            if lst[i]\
    \ < min and lst[i] > mini then\n                min = lst[i]\n            end\n\
    \            if lst[i] > max and lst[i] < maxi then\n                max = lst[i]\n\
    \            end\n        end\n        table.insert(result, mini)\n        table.insert(result,\
    \ maxi)\n        mini = min\n        maxi = max\n        index = index + 2\n \
    \   end\n    return result\nend", "    -- TODO: Write your code here\n    return\
    \ {}\nend", "    -- The list is not passed by reference, therefore it is not modified.\n\
    \    -- A sorted copy of the list is created.\n    local sorted_lst = bubble_sort_list(lst)\n\
    \    local new_lst = {}\n    local min_value = sorted_lst[1]\n    local max_value\
    \ = sorted_lst[#sorted_lst]\n    local min_value_pos = 1\n    local max_value_pos\
    \ = #sorted_lst\n    local min_max_value\n    -- `min_max_value` is a variable\
    \ that holds the value of the next element\n    -- to be placed in the new list.\
    \ If it is `min_value`, then the next value\n    -- will be the minimum from the\
    \ rest of the remaining integers in the list.\n    -- Otherwise, it is `max_value`\
    \ and the next value will be the maximum\n    -- from the rest of the remaining\
    \ integers in the list.\n    min_max_value = min_value\n    for i = 1, #sorted_lst\
    \ do\n        if min_max_value == min_value then\n            new_lst[i] = min_value\n\
    \            min_value_pos = min_value_pos + 1\n            if min_value_pos <=\
    \ #sorted_lst then\n                min_value = sorted_lst[min_value_pos]\n  \
    \          end\n            min_max_value = max_value\n        else\n        \
    \    new_lst[i] = max_value\n            max_value_pos = max_value_pos - 1\n \
    \           if max_value_pos >= 1 then\n                max_value = sorted_lst[max_value_pos]\n\
    \            end\n            min_max_value = min_value\n        end\n    end\n\
    \    return new_lst\nend", "    local len = #lst\n    local new_list = {}\n  \
    \  local remaining = {}\n    for i, v in ipairs(lst) do\n        remaining[i]\
    \ = true\n    end\n    for i = 1, len, 2 do\n        if i == len then\n      \
    \      new_list[i] = min_int(lst, remaining)\n        else\n            new_list[i]\
    \ = min_int(lst, remaining)\n            new_list[i + 1] = max_int(lst, remaining)\n\
    \        end\n    end\n    return new_list\nend", "  local ordered = {}\n  local\
    \ length = #lst\n  for i = 1, length do\n    ordered[i] = math.min(unpack(lst))\n\
    \    local idx = nil\n    for i2, v in ipairs(lst) do\n      if v == ordered[i]\
    \ then\n        idx = i2\n        break\n      end\n    end\n    table.remove(lst,\
    \ idx)\n  end\n  return ordered\nend", "    local idx = 1\n    local res = {}\n\
    \    local left = #lst\n    local asc = true\n    while idx <= #lst do\n     \
    \   if asc then\n            res[idx] = math.min(unpack(lst))\n        else\n\
    \            res[idx] = math.max(unpack(lst))\n        end\n        table.remove(lst,\
    \ lst:indexOf(res[idx]))\n        idx = idx + 1\n        asc = not asc\n    end\n\
    \    return res\nend", "    local res = {}\n    local sort_up = true\n    local\
    \ tmp = lst\n    while #tmp > 0 do\n        local min_el = min(tmp)\n        tmp\
    \ = _.filter(tmp, function(el) return el ~= min_el end)\n        table.insert(res,\
    \ min_el)\n        if #tmp == 0 then break end\n        local max_el = max(tmp)\n\
    \        tmp = _.filter(tmp, function(el) return el ~= max_el end)\n        table.insert(res,\
    \ max_el)\n    end\n    return res\nend", "  local sorted_lst = {}\n  for k, v\
    \ in pairs(lst) do\n    table.insert(sorted_lst, v)\n  end\n  table.sort(sorted_lst)\n\
    \  local min_vals = {}\n  local max_vals = {}\n  local i = 1\n  local j = #sorted_lst\n\
    \  while i <= j do\n    if i == j then\n      table.insert(min_vals, sorted_lst[i])\n\
    \      break\n    end\n    table.insert(min_vals, sorted_lst[i])\n    table.insert(max_vals,\
    \ sorted_lst[j])\n    i = i + 1\n    j = j - 1\n  end\n  local result = {}\n \
    \ for i = 1, #min_vals do\n    table.insert(result, min_vals[i])\n    if max_vals[i]\
    \ then\n      table.insert(result, max_vals[i])\n    end\n  end\n  return result\n\
    end", "  local min = 0\n  local max = 0\n  local result = {}\n  for i = 1, #lst\
    \ do\n    if i % 2 == 1 then\n      -- Take minimum\n      local index = 0\n \
    \     for j = 1, #lst do\n        if lst[j] ~= min and lst[j] ~= max then\n  \
    \        if index == 0 or lst[j] < lst[index] then\n            index = j\n  \
    \        end\n        end\n      end\n      table.insert(result, lst[index])\n\
    \      min = lst[index]\n    else\n      -- Take maximum\n      local index =\
    \ 0\n      for j = 1, #lst do\n        if lst[j] ~= min and lst[j] ~= max then\n\
    \          if index == 0 or lst[j] > lst[index] then\n            index = j\n\
    \          end\n        end\n      end\n      table.insert(result, lst[index])\n\
    \      max = lst[index]\n    end\n  end\n  return result\nend", "  local min_val\
    \ = min(lst)\n  local rem_list = lst - min_val\n  if null(rem_list) then\n   \
    \ return list(min_val)\n  else\n    local max_val = max(rem_list)\n    return\
    \ list(min_val, strange_sort_list(rem_list - max_val))\n  end\nend", "    --base\
    \ case\n    if lst == nil then\n        return lst\n    end\n    --find min and\
    \ max in remaining list\n    local min, max = math.min(table.unpack(lst)), math.max(table.unpack(lst))\n\
    \    --remove min and max from list\n    local i = 1\n    while i <= #lst do\n\
    \        if lst[i] == min or lst[i] == max then\n            table.remove(lst,\
    \ i)\n        else\n            i = i + 1\n        end\n    end\n    --recursive\
    \ call with remaining list\n    return {min, max} + strange_sort_list(lst)\nend",
  "    table.sort(lst)\n    local i, j = 1, #lst\n    local res = {}\n    for _ =\
    \ 1, #lst do\n        res[#res + 1] = lst[i]\n        res[#res + 1] = lst[j]\n\
    \        i = i + 1\n        j = j - 1\n    end\n    return res\nend", "    local\
    \ t = table.new(#lst, 0)\n    local i = 1\n    while #lst > 0 do\n        local\
    \ min, min_i = math.min(unpack(lst))\n        table.insert(t, min)\n        table.remove(lst,\
    \ min_i)\n        if #lst > 0 then\n            local max, max_i = math.max(unpack(lst))\n\
    \            table.insert(t, max)\n            table.remove(lst, max_i)\n    \
    \    end\n    end\n    return t\nend", "    local function push_value(v, lst)\n\
    \        if #lst % 2 == 0 then\n            table.insert(lst, 1, v)\n        else\n\
    \            table.insert(lst, v)\n        end\n    end", "   local vals = {}\n\
    \   local vmin, vmax = math.min(unpack(lst)), math.max(unpack(lst))\n   local\
    \ dir = 1\n   local idx = 1\n   while idx <= #lst do\n      if dir == 1 then\n\
    \         local v = math.min(unpack(lst))\n         table.insert(vals, v)\n  \
    \       if v == vmin then dir = -1 end\n      else\n         local v = math.max(unpack(lst))\n\
    \         table.insert(vals, v)\n         if v == vmax then dir = 1 end\n    \
    \  end\n      for i, v in ipairs(lst) do\n         if v == vals[#vals] then\n\
    \            table.remove(lst, i)\n            break\n         end\n      end\n\
    \      idx = idx + 1\n   end\n   return vals\nend", "  local first = table.remove(lst,\
    \ 1)\n  local asc = true\n  local new_lst = {first}\n  for i = 1, #lst do\n  \
    \  if asc then\n      table.insert(new_lst, table.remove(lst, 1))\n    else\n\
    \      table.insert(new_lst, table.remove(lst, #lst))\n    end\n    asc = not\
    \ asc\n  end\n  return new_lst\nend", "    if not lst then return end\n    local\
    \ result = {}\n    local asc = true\n    local len = #lst\n    local i = 1\n \
    \   while #result < len do\n        if asc then\n            table.insert(result,\
    \ table.remove(lst, 1))\n        else\n            table.insert(result, table.remove(lst))\n\
    \        end\n        asc = not asc\n    end\n    return result\nend", "   local\
    \ a, b, len, res = 1, #lst, #lst, {}\n   for i = 1, len do\n      if len % 2 ==\
    \ 1 and i == len then\n         res[i] = lst[a]\n      elseif i % 2 == 1 then\n\
    \         res[i] = lst[a]\n         a = a + 1\n      else\n         res[i] = lst[b]\n\
    \         b = b - 1\n      end\n   end\n   return res\nend", "  local min = table.remove(lst,\
    \ 1)\n  local result = {min}\n  while #lst > 0 do\n    table.insert(result, math.max(unpack(lst)))\n\
    \    table.insert(result, math.min(unpack(lst)))\n  end\n  return result\nend",
  "    local start = arg[1]\n    local finish = arg[2]\n    local result = {}\n  \
    \  local list1 = {}\n    local list2 = {}\n    local list3 = {}\n    for i = start,\
    \ finish do\n        list1[i] = i\n    end\n    for i = 1, #list1 / 2 do\n   \
    \     local min = math.min(unpack(list1))\n        local max = math.max(unpack(list1))\n\
    \        table.insert(list2, min)\n        table.insert(list2, max)\n        table.remove(list1,\
    \ min)\n        table.remove(list1, max)\n    end\n    return list2\nend", "\t\
    local sorted = {}\n\tlocal copy = copy_table(lst)\n\tfor i = 1, #lst do\n\t\t\
    if i % 2 == 1 then\n\t\t\tlocal min = 1\n\t\t\tfor i, v in ipairs(copy) do\n\t\
    \t\t\tif v < copy[min] then\n\t\t\t\t\tmin = i\n\t\t\t\tend\n\t\t\tend\n\t\t\t\
    table.insert(sorted, copy[min])\n\t\t\ttable.remove(copy, min)\n\t\telse\n\t\t\
    \tlocal max = 1\n\t\t\tfor i, v in ipairs(copy) do\n\t\t\t\tif v > copy[max] then\n\
    \t\t\t\t\tmax = i\n\t\t\t\tend\n\t\t\tend\n\t\t\ttable.insert(sorted, copy[max])\n\
    \t\t\ttable.remove(copy, max)\n\t\tend\n\tend\n\treturn sorted\nend", "  local\
    \ reversed_lst = clone_list(lst)\n  -- reverse list so that we can pop of values\n\
    \  reversed_lst = reverse_list(reversed_lst)\n  local ordered_lst = List:new()\n\
    \  while #reversed_lst > 0 do\n    local max = reversed_lst:max()\n    reversed_lst:remove(max)\n\
    \    ordered_lst:append(max)\n    if #reversed_lst > 0 then\n      local min =\
    \ reversed_lst:min()\n      reversed_lst:remove(min)\n      ordered_lst:append(min)\n\
    \    end\n  end\n  return ordered_lst\nend", "   local sorted_lst = {}\n   --\
    \ TODO: Write your code here\n   return sorted_lst\nend", "    local i,n,l,d =\
    \ 1,#lst,{},1\n    while i<=n do\n        if d==1 then\n            table.insert(l,math.min(unpack(lst)))\n\
    \        else\n            table.insert(l,math.max(unpack(lst)))\n        end\n\
    \        table.remove(lst,lst:indexOf(l[i]))\n        d = -d\n        i = i +\
    \ 1\n    end\n    return l\nend", "  local sorted = {}\n  local ascending = true\n\
    \  for _ = 1, #lst do\n    if ascending then\n      local v = math.min(unpack(lst))\n\
    \      table.insert(sorted, v)\n      table.remove(lst, table.indexof(lst, v))\n\
    \    else\n      local v = math.max(unpack(lst))\n      table.insert(sorted, v)\n\
    \      table.remove(lst, table.indexof(lst, v))\n    end\n    ascending = not\
    \ ascending\n  end\n  return sorted\nend", "   local res = {}\n   table.sort(lst)\n\
    \   local i = 1\n   while #lst > 0 do\n      res[i] = table.remove(lst, 1)\n \
    \     res[i+1] = table.remove(lst, #lst)\n      i = i + 2\n   end\n   return res\n\
    end", "   local res = {}\n   table.sort(lst)\n   local i = 1\n   local dir = 1\n\
    \   local t = 'min'\n   while #lst > 0 do\n      if t == 'min' then\n        \
    \ res[i] = table.remove(lst, 1)\n      else\n         res[i] = table.remove(lst)\n\
    \      end\n      if t == 'min' then\n         t = 'max'\n      else\n       \
    \  t = 'min'\n      end\n      i = i + dir\n      if i == #lst or i == 0 then\n\
    \         dir = -dir\n      end\n   end\n   return res\nend", "    -- sort in\
    \ ascending order\n    local sorted = merge_sort(lst)\n    -- print(sorted)\n\
    \    local odd = {}\n    local even = {}\n    -- remove the first and last elements\
    \ of the list and\n    -- add to a new list.\n    local function remove(list)\n\
    \        table.insert(odd, list[1])\n        table.insert(even, list[#list])\n\
    \        table.remove(list, 1)\n        table.remove(list, #list)\n    end\n \
    \   -- make sure there are still numbers in the list,\n    -- and swap between\
    \ odd and even.\n    while #sorted > 0 do\n        if #odd % 2 == 0 then\n   \
    \         remove(sorted)\n        else\n            remove(sorted)\n        end\n\
    \    end\n    -- merge odd and even list\n    return merge_sort(odd, even)\nend",
  "  -- sort given integers list\n  local sort_lst = {}\n  for _,v in pairs(lst) do\n\
    \    table.insert(sort_lst, v)\n  end\n  table.sort(sort_lst)", "    local lst2\
    \ = {}\n    -- sort list numerically\n    table.sort(lst)\n    -- keep pointers\
    \ to start and end of list\n    local start = 1\n    local finish = #lst\n   \
    \ -- keep track of direction\n    local direction = \"min\"\n    while start <=\
    \ finish do\n        -- if direction is \"min\", append minimum element to new\
    \ list\n        if direction == \"min\" then\n            table.insert(lst2, lst[start])\n\
    \            start = start + 1\n            direction = \"max\"\n        -- if\
    \ direction is \"max\", append maximum element to new list\n        elseif direction\
    \ == \"max\" then\n            table.insert(lst2, lst[finish])\n            finish\
    \ = finish - 1\n            direction = \"min\"\n        end\n    end\n    return\
    \ lst2\nend", "    local i, j = 1, #lst\n    local sorted = {}\n    while i <=\
    \ j do\n        local a, b = lst[i], lst[j]\n        if a > b then\n         \
    \   table.insert(sorted, b)\n            j = j - 1\n        else\n           \
    \ table.insert(sorted, a)\n            i = i + 1\n        end\n    end\n    return\
    \ sorted\nend", "  lst = List.map(lst, {}, function(v) return v end)\n  List.sort(lst,\
    \ function(a, b) return a < b end)\n  local res = {}\n  while List.length(lst)\
    \ > 0 do\n    res[#res + 1] = List.pop_first(lst)\n    if List.length(lst) > 0\
    \ then\n      res[#res + 1] = List.pop_last(lst)\n    end\n  end\n  return res\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
