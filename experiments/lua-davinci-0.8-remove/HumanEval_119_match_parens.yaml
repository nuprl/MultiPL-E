name: HumanEval_119_match_parens
language: lua
prompt: "-- You are given a list of two strings, both strings consist of open\n--\
  \ parentheses '(' or close parentheses ')' only.\n-- Your job is to check if it\
  \ is possible to concatenate the two strings in\n-- some order, that the resulting\
  \ string will be good.\n-- A string S is considered to be good if and only if all\
  \ parentheses in S\n-- are balanced. For example: the string '(())()' is good, while\
  \ the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make a good\
  \ string, and return 'No' otherwise.\n-- Examples:\nlocal function match_parens(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
  \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
  \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n  \
  \  lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
  \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n  \
  \  lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
  \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n   \
  \ lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
  \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local depth = 0\n    for _, v in ipairs(lst) do\n        if v ==\
    \ '(' then\n            depth = depth + 1\n        else\n            depth = depth\
    \ - 1\n        end\n        if depth < 0 then\n            return false\n    \
    \    end\n    end\n    return depth == 0\nend", "    local stack = {}\n    for\
    \ _, v in ipairs(lst) do\n        if v == '(' then\n            table.insert(stack,\
    \ v)\n        else\n            if #stack == 0 then\n                return false\n\
    \            end\n            table.remove(stack)\n        end\n    end\n    return\
    \ #stack == 0\nend", "  if not lst then return \"Yes\" end\n  local open, close\
    \ = 0, 0\n  for i = 1, #lst do\n    if lst:sub(i, i) == \"(\" then\n      open\
    \ = open + 1\n    else\n      close = close + 1\n    end\n    if close > open\
    \ then return \"No\" end\n  end\n  return open == close and \"Yes\" or \"No\"\n\
    end", "    local function match(p)\n        return p == '(' and ')' or '('\n \
    \   end\n    local open,close = 0,0\n    for i = 1, #lst do\n        if lst[i]\
    \ == '(' then\n            open = open + 1\n        else\n            close =\
    \ close + 1\n        end\n    end\n    if open ~= close then\n        return 'No'\n\
    \    end\n    for i = 1, #lst do\n        if lst[i] == ')' then\n            local\
    \ found = false\n            for j = 1, i - 1 do\n                if lst[j] ==\
    \ '(' then\n                    lst[i], lst[j] = lst[j], lst[i]\n            \
    \        found = true\n                    break\n                end\n      \
    \      end\n            if not found then\n                return 'No'\n     \
    \       end\n        end\n    end\n    return 'Yes'\nend", "    local stack =\
    \ {}\n    for _, p in ipairs(lst) do\n        if p == '(' then\n            table.insert(stack,\
    \ '(')\n        else\n            if #stack == 0 then\n                return\
    \ false\n            end\n            table.remove(stack)\n        end\n    end\n\
    \    return #stack == 0\nend", "    local open = string.find(lst, '(', 1, true)\n\
    \    if not open then return 0 end\n    local close = string.find(lst, ')', open,\
    \ true)\n    if not close then return 1 end\n    local new = lst:sub(1, open -\
    \ 1) .. lst:sub(close + 1)\n    return match_parens(new)\nend", "  local stack\
    \ = {}\n  for _, x in ipairs(lst) do\n    if x == '(' then\n      stack[#stack\
    \ + 1] = x\n    else\n      if #stack == 0 then\n        return false\n      end\n\
    \      stack[#stack] = nil\n    end\n  end\n  return #stack == 0\nend", "    local\
    \ open = 0\n    for _, x in ipairs(lst) do\n        if x == '(' then\n       \
    \     open = open + 1\n        else\n            open = open - 1\n        end\n\
    \        if open < 0 then\n            return false\n        end\n    end\n  \
    \  return open == 0\nend", "  local cnt = 0\n  for _, v in ipairs(lst) do\n  \
    \  if v == '(' then\n      cnt = cnt + 1\n    else\n      cnt = cnt - 1\n    end\n\
    \    if cnt < 0 then\n      return false\n    end\n  end\n  return cnt == 0\n\
    end", "    -- Find the last opening paren and make sure it matches a closing paren,\n\
    \    -- and all of the parens before it match up as well.\n    local function\
    \ check_parens(lst, parens)\n        if type(lst) ~= 'table' then\n          \
    \  return lst == '(' and #parens == 0\n        end\n        local last = #lst\n\
    \        while last > 0 and lst[last] == ')' do\n            table.remove(lst,\
    \ last)\n            last = last - 1\n        end\n        if last == 0 then\n\
    \            return false\n        end\n        local open = lst[last]\n     \
    \   if open == '(' then\n            local parens_copy = { table.unpack(parens)\
    \ }\n            table.insert(parens_copy, open)\n            return check_parens(lst,\
    \ parens_copy)\n        else\n            table.remove(lst, last)\n          \
    \  if #parens == 0 then\n                return false\n            end\n     \
    \       table.remove(parens, #parens)\n            return check_parens(lst, parens)\n\
    \        end\n    end\n    return check_parens(lst, {})\nend", "    local stack\
    \ = {}\n    for i = 1, #lst do\n        local x = lst[i]\n        if x == '('\
    \ then\n            stack[#stack + 1] = i\n        else\n            if #stack\
    \ == 0 then\n                return false\n            end\n            stack[#stack]\
    \ = nil\n        end\n    end\n    return #stack == 0\nend", "    local stack\
    \ = {}\n    for i = 1, #lst do\n        local ch = lst[i]\n        if ch == '('\
    \ then\n            table.insert(stack, ch)\n        else\n            if #stack\
    \ == 0 then\n                return false\n            end\n            table.remove(stack)\n\
    \        end\n    end\n    return #stack == 0\nend", "    local good = {\n   \
    \     ['()'] = true,\n        [')('] = true,\n        ['()('] = true,\n      \
    \  ['(())'] = true,\n        ['(()'] = true,\n        ['(()('] = true,\n     \
    \   ['(()())'] = true,\n        ['(()()'] = true,\n        ['()(()'] = true,\n\
    \        ['()(())'] = true,\n        ['(())(()'] = true,\n        ['()(()())']\
    \ = true,\n        ['()(()()'] = true,\n        ['(()())(()'] = true,\n      \
    \  ['(()())(())'] = true,\n        ['()(()())(()'] = true,\n        ['()(()())(())']\
    \ = true,\n        ['(()())(())(()'] = true,\n        ['(()())(())(())'] = true,\n\
    \        ['()(()())(())(()'] = true,\n        ['()(()())(())(())'] = true,\n \
    \       ['(()())(())(())(()'] = true,\n        ['(()())(())(())(())'] = true,\n\
    \        ['()(()())(())(())(()'] = true,\n        ['()(()())(())(())(())'] = true,\n\
    \        ['(()())(())(())(())(()'] = true,\n        ['(()())(())(())(())(())']\
    \ = true,\n        ['()(()())(())(())(())(()'] = true,\n        ['()(()())(())(())(())(())']\
    \ = true,\n        ['(()())(())(())(())(())(()'] = true,\n        ['(()())(())(())(())(())(())']\
    \ = true,\n        ['()(()())(())(())(())(())(()'] = true,\n        ['()(()())(())(())(())(())(())']\
    \ = true,\n        ['(()())(())(())(())(())(())(()'] = true,\n        ['(()())(())(())(())(())(())(())']\
    \ = true,\n        ['()(()", "    local stack = {}\n    for _, c in ipairs(lst)\
    \ do\n        if c == '(' then\n            stack[#stack + 1] = '('\n        else\n\
    \            if #stack == 0 then\n                return 'No'\n            end\n\
    \            stack[#stack] = nil\n        end\n    end\n    return #stack == 0\
    \ and 'Yes' or 'No'\nend", "    -- (())()\n    -- ()()()\n    -- 2 * 3\n    --\
    \ sum of ( # of open parens ) must be even\n    -- sum of ( # of close parens\
    \ ) must be even\n    -- sum of ( # of open parens ) must be equal to sum of (\
    \ # of close parens )\n    local sum_1, sum_2 = 0, 0\n    for i = 1, #lst[1] do\n\
    \        sum_1 = sum_1 + (lst[1]:sub(i, i) == '(' and 1 or -1)\n    end\n    for\
    \ i = 1, #lst[2] do\n        sum_2 = sum_2 + (lst[2]:sub(i, i) == '(' and 1 or\
    \ -1)\n    end\n    local sum = sum_1 + sum_2\n    if sum ~= 0 and sum % 2 ==\
    \ 0 then\n        return 'Yes'\n    end\n    return 'No'\nend", "    local paren_stack\
    \ = {}\n    for i = 1, #lst do\n        local c = lst:sub(i, i)\n        if c\
    \ == '(' then\n            paren_stack[#paren_stack + 1] = c\n        else\n \
    \           if #paren_stack == 0 then\n                return false\n        \
    \    end\n            paren_stack[#paren_stack] = nil\n        end\n    end\n\
    \    return #paren_stack == 0\nend", "  -- Your code here\nend", "    local s\
    \ = ''\n    for _, p in ipairs(lst) do\n        s = s .. p\n    end\n    local\
    \ counter = 0\n    for i = 1, #s do\n        if s:sub(i, i) == '(' then\n    \
    \        counter = counter + 1\n        else\n            counter = counter -\
    \ 1\n        end\n        if counter < 0 then\n            return false\n    \
    \    end\n    end\n    return counter == 0\nend", "    local len = #lst\n    local\
    \ left = 0\n    local right = 0\n    for i = 1, len do\n        if lst[i] == '('\
    \ then\n            left = left + 1\n        else\n            right = right +\
    \ 1\n        end\n    end\n    local r = 0\n    local l = 0\n    for i = 1, len\
    \ do\n        if lst[i] == '(' then\n            l = l + 1\n        else\n   \
    \         r = r + 1\n        end\n        if r > l then\n            return false\n\
    \        end\n    end\n    return true\nend", "  local good = false\n  local parens\
    \ = {}\n  local PUSH = table.insert\n  local POP = table.remove\n  local function\
    \ is_good(str)\n    local res = 0\n    for i = 1, #str do\n      local c = str:sub(i,\
    \ i)\n      if c == '(' then\n        res = res + 1\n      else\n        res =\
    \ res - 1\n      end\n      if res < 0 then\n        return false\n      end\n\
    \    end\n    return true\n  end\n  for _, s in ipairs(lst) do\n    if not is_good(s)\
    \ then\n      return 'No'\n    end\n    for i = 1, #s do\n      PUSH(parens, s:sub(i,\
    \ i))\n    end\n  end\n  while #parens > 0 do\n    local c = POP(parens)\n   \
    \ if c == '(' then\n      local q = POP(parens)\n      if q ~= ')' then\n    \
    \    return 'No'\n      end\n    end\n  end\n  return 'Yes'\nend", "  local opens\
    \ = 0\n  local closes = 0\n  for _, v in ipairs(lst) do\n    if v == '(' then\n\
    \      opens = opens + 1\n    else\n      closes = closes + 1\n    end\n  end\n\
    \  return opens, closes\nend", "    local count = 0\n    for i, v in ipairs(lst)\
    \ do\n        if v == '(' then\n            count = count + 1\n        else\n\
    \            count = count - 1\n        end\n        if count < 0 then\n     \
    \       return 'No'\n        end\n    end\n    return count == 0 and 'Yes' or\
    \ 'No'\nend", "    if #lst == 0 then\n        return true\n    end\n    if not\
    \ lst[1] == '(' then\n        return false\n    end\n    local c = 1\n    for\
    \ i = 2, #lst do\n        if lst[i] == '(' then\n            c = c + 1\n     \
    \   else\n            c = c - 1\n        end\n        if c == 0 then\n       \
    \     return match_parens(table.slice(lst, 2, i - 1)) and\n                match_parens(table.slice(lst,\
    \ i + 1))\n        end\n    end\n    return false\nend", "  local stack = {}\n\
    \  for _, p in ipairs(lst) do\n    if p == '(' then\n      table.insert(stack,\
    \ p)\n    else\n      if #stack == 0 then\n        return false\n      end\n \
    \     table.remove(stack)\n    end\n  end\n  return #stack == 0\nend", "    local\
    \ left = 0\n    local right = 0\n    for _, c in ipairs(lst) do\n        if c\
    \ == '(' then\n            left = left + 1\n        else\n            right =\
    \ right + 1\n        end\n    end\n    return left, right\nend", "  local open\
    \ = 0\n  for i = 1, #lst do\n    if lst[i] == '(' then\n      open = open + 1\n\
    \    else\n      open = open - 1\n    end\n    if open < 0 then\n      return\
    \ false\n    end\n  end\n  return open == 0\nend", "  local count = 0\n  for _,\
    \ v in ipairs(lst) do\n    if v == '(' then\n      count = count + 1\n    else\n\
    \      count = count - 1\n    end\n    if count < 0 then\n      return false\n\
    \    end\n  end\n  return count == 0\nend", "    local n = 0\n    for _, v in\
    \ ipairs(lst) do\n        if v == '(' then\n            n = n + 1\n        else\n\
    \            n = n - 1\n        end\n        if n < 0 then\n            return\
    \ false\n        end\n    end\n    return n == 0\nend", "   local s = table.concat(lst)\n\
    \   local opens = {}\n   for i=1, #s do\n      local ch = s:sub(i,i)\n      if\
    \ ch == '(' then\n         table.insert(opens, i)\n      else\n         if #opens\
    \ == 0 then\n            return false\n         end\n         table.remove(opens)\n\
    \      end\n   end\n   return #opens == 0\nend", "    local s = table.concat(lst)\n\
    \    local cnt = 0\n    for i = 1, #s do\n        if s:sub(i, i) == '(' then\n\
    \            cnt = cnt + 1\n        else\n            cnt = cnt - 1\n        end\n\
    \        if cnt < 0 then\n            return 'No'\n        end\n    end\n    return\
    \ cnt == 0 and 'Yes' or 'No'\nend", "    local result = 'Yes'\n    local open\
    \ = 0\n    local closed = 0\n    local s = table.concat(lst)\n    for i = 1, #s\
    \ do\n        if s:sub(i, i) == '(' then\n            open = open + 1\n      \
    \  else\n            closed = closed + 1\n        end\n        if closed > open\
    \ then\n            result = 'No'\n            break\n        end\n    end\n \
    \   return result\nend", "  -- Your code here\nend", "  local tbl = {}\n  for\
    \ i=1,#lst do\n    local s = lst[i]\n    for j=1,#s do\n      local c = s:sub(j,j)\n\
    \      if c == '(' then\n        tbl[c] = (tbl[c] or 0) + 1\n      else\n    \
    \    tbl[c] = (tbl[c] or 0) - 1\n      end\n    end\n  end\n  local good = true\n\
    \  for k,v in pairs(tbl) do\n    if v ~= 0 then\n      good = false\n      break\n\
    \    end\n  end\n  return good and 'Yes' or 'No'\nend", "    local open_par =\
    \ 0\n    for i = 1, #lst do\n        if lst[i] == '(' then\n            open_par\
    \ = open_par + 1\n        else\n            open_par = open_par - 1\n        end\n\
    \        if open_par < 0 then\n            return false\n        end\n    end\n\
    \    return open_par == 0\nend", "    local l, r = lst:gsub('%(', ''), lst:gsub('%)',\
    \ '')\n    return l:len() == r:len()\nend", "    -- You've got the input list.\n\
    \    -- The easiest way to solve this problem is to use two stacks: one for\n\
    \    -- opening parentheses and another for closing parentheses.\n    -- Then\
    \ for each opening parentheses, pop an item from closing parentheses\n    -- stack.\n\
    \    -- At the end, if the string was good, both stacks should be empty.\n   \
    \ local opens = deque()\n    local closes = deque()\n    for s = 1, #lst do\n\
    \        local c = lst[s]\n        if c == '(' then\n            opens:push(s)\n\
    \        else\n            closes:push(s)\n        end\n    end\n    while #opens\
    \ > 0 and #closes > 0 do\n        if opens:pop() > closes:pop() then\n       \
    \     return false\n        end\n    end\n    if #opens == 0 and #closes == 0\
    \ then\n        return true\n    end\n    return false\nend", "  for i=1,#lst\
    \ do\n    local c = lst[i]\n    local n = lst[i+1]\n    if c=='(' and n~=')' then\n\
    \      return false\n    end\n  end\n  return true\nend", "  local stack = {}\n\
    \  for i = 1, #lst do\n    local x = lst[i]\n    if x == '(' then\n      stack[#stack\
    \ + 1] = x\n    elseif x == ')' then\n      if #stack == 0 then\n        return\
    \ false\n      end\n      table.remove(stack)\n    end\n  end\n  return #stack\
    \ == 0\nend", "    local stack = {}\n    for i = 1,#lst do\n        local c =\
    \ lst[i]\n        if c == '(' then\n            push(stack,c)\n        else\n\
    \            local v = pop(stack)\n            if v == nil then\n            \
    \    return false\n            end\n        end\n    end\n    return #stack ==\
    \ 0\nend", "    local a, b = lst[1], lst[2]\n    local stack = {}\n    for i =\
    \ 1, #a do\n        local c = a:sub(i, i)\n        if c == '(' then\n        \
    \    table.insert(stack, c)\n        else\n            if stack[#stack] == '('\
    \ then\n                table.remove(stack)\n            else\n              \
    \  return 'No'\n            end\n        end\n    end\n    for i = 1, #b do\n\
    \        local c = b:sub(i, i)\n        if c == '(' then\n            table.insert(stack,\
    \ c)\n        else\n            if stack[#stack] == '(' then\n               \
    \ table.remove(stack)\n            else\n                return 'No'\n       \
    \     end\n        end\n    end\n    return #stack == 0 and 'Yes' or 'No'\nend",
  "  local stack = {}\n  for _, s in ipairs(lst) do\n    for c in s:gmatch('.') do\n\
    \      if c == '(' then\n        table.insert(stack, c)\n      else\n        if\
    \ #stack == 0 then\n          return false\n        end\n        table.remove(stack)\n\
    \      end\n    end\n  end\n  return #stack == 0\nend\nassert(match_parens({'()',\
    \ '())'}) == false)\nassert(match_parens({'(())', '())'}) == true)\nassert(match_parens({'(())',\
    \ '()'}) == true)\nassert(match_parens({'(())', '()()'}) == true)\nassert(match_parens({'()()',\
    \ '()()'}) == true)\nassert(match_parens({'(()', '()'}) == false)\nassert(match_parens({'(()',\
    \ '())'}) == false)\nassert(match_parens({'(())', ')('}) == false)\nassert(match_parens({'((()',\
    \ ')()'}) == false)\nassert(match_parens({'((()()()))', '()()'}) == true)\nassert(match_parens({'((()()())',\
    \ '()()'}) == true)\nassert(match_parens({'(()((()(((()()))))', '()()'}) == true)\n\
    assert(match_parens({'(()((()(((()()))))))', '()()'}) == true)\nassert(match_parens({'(()((()(((()()))))))',\
    \ '()))'}) == false)\nassert(match_parens({'(((()()(((()()))', '()()'}) == false)\n\
    assert(match_parens({'(((()()(((()()))', '()()'}) == false)\nassert(match_parens({'(()()(()()(()()()()()()()',\
    \ '()'}) == true)\nassert(match_parens({'(()()(()()(()()()()()()()', '()()'})\
    \ == true", "    local opened = 0\n    for _, c in ipairs(lst) do\n        if\
    \ c == '(' then\n            opened = opened + 1\n        else\n            opened\
    \ = opened - 1\n        end\n        if opened < 0 then\n            return false\n\
    \        end\n    end\n    return opened == 0\nend", "    local open = 0\n   \
    \ for _, p in ipairs(lst) do\n        if p == '(' then\n            open = open\
    \ + 1\n        else\n            open = open - 1\n        end\n        if open\
    \ < 0 then\n            return false\n        end\n    end\n    return open ==\
    \ 0\nend", "  local s = table.concat(lst)\n  local c = 0\n  for i = 1, #s do\n\
    \    if s:sub(i, i) == '(' then\n      c = c + 1\n    else\n      c = c - 1\n\
    \    end\n    if c < 0 then\n      return false\n    end\n  end\n  return c ==\
    \ 0\nend", "   local n = #lst\n   local stack = {}\n   for i = 1, n do\n     \
    \ local c = lst[i]\n      if c == '(' then\n         table.insert(stack, 1, c)\n\
    \      else\n         if #stack == 0 then\n            return false\n        \
    \ end\n         table.remove(stack, 1)\n      end\n   end\n   return #stack ==\
    \ 0\nend", "   -- ()(())\n   -- ()()\n   local stack = {}\n   for i = 1, #lst\
    \ do\n      local char = lst[i]\n      if char == '(' then\n         table.insert(stack,\
    \ char)\n      elseif char == ')' then\n         if #stack == 0 then\n       \
    \     return false\n         else\n            table.remove(stack)\n         end\n\
    \      end\n   end\n   return #stack == 0\nend", "  local it, s = lst:gmatch('.')\n\
    \  local bal = 0\n  for c in it do\n    if c == '(' then\n      bal = bal + 1\n\
    \    else\n      bal = bal - 1\n    end\n    if bal < 0 then\n      return false\n\
    \    end\n  end\n  return bal == 0\nend", "  local stack = {}\n  for _, v in ipairs(lst)\
    \ do\n    if v == '(' then\n      stack[#stack + 1] = v\n    else\n      if #stack\
    \ == 0 then\n        return false\n      end\n      stack[#stack] = nil\n    end\n\
    \  end\n  return #stack == 0\nend", "  local left = 0\n  for c in lst:gmatch(\"\
    .\") do\n    if c == \"(\" then\n      left = left + 1\n    else\n      left =\
    \ left - 1\n    end\n    if left < 0 then\n      return false\n    end\n  end\n\
    \  return left == 0\nend", "    local stack = {}\n    for i = 1, #lst do\n   \
    \     local cur = lst[i]\n        if cur == '(' then\n            table.insert(stack,\
    \ cur)\n        else\n            if #stack == 0 then\n                return\
    \ false\n            end\n            table.remove(stack)\n        end\n    end\n\
    \    return #stack == 0\nend", "    return function(ch)\n        for _, pair in\
    \ ipairs(lst) do\n            if pair[1] == ch then\n                return pair[2]\n\
    \            end\n        end\n    end\nend", "    return function(s)\n      \
    \  local stack = {}\n        for i = 1, #s do\n            local c = s:sub(i,\
    \ i)\n            if c == lst[1] then\n                table.insert(stack, i)\n\
    \            elseif c == lst[2] then\n                if #stack == 0 then\n  \
    \                  return false\n                end\n                table.remove(stack)\n\
    \            end\n        end\n        return #stack == 0\n    end\nend", "  local\
    \ function aux(lst, i, o)\n    if i == 0 and o == 0 then return true end\n   \
    \ if i > 0 and match(lst, i-1, o+1) then return true end\n    if o > 0 and match(lst,\
    \ i, o-1) then return true end\n    return false\n  end\n  local function match(lst,\
    \ i, o)\n    if not lst then return aux(lst, i, o) end\n    if car(lst) == '('\
    \ then return match(cdr(lst), i+1, o) end\n    if car(lst) == ')' then return\
    \ match(cdr(lst), i, o+1) end\n    return false\n  end\n  return aux(lst, 0, 0)\n\
    end\nmatch_parens(list(\"()\", \")))\")) == false\nmatch_parens(list(\"((()\"\
    , \")))\")) == true\nmatch_parens(list(\"()\", \"()\")) == true\nmatch_parens(list(\"\
    \", \"\")) == true\nmatch_parens(list(\")))((\", \")))\")) == false\nmatch_parens(list(\"\
    ((()\", \")))(\")) == false\nmatch_parens(list(\"((()\", \"\")) == true\nmatch_parens(list(\"\
    \", \")))(\")) == false\nmatch_parens(list(\"(((())))\", \"\")) == true\nmatch_parens(list(\"\
    \", \"(((())))\")) == true\nmatch_parens(list(\"()()(()\", \"()())\")) == true\n\
    match_parens(list(\"()(()()()(()\", \"()())\")) == true\nmatch_parens(list(\"\
    ()(()()()(()\", \"())))\")) == false\nmatch_parens(list(\"()(()()()(()\", \"()))\"\
    )) == true\nmatch_parens(list(\"(()(()(()(()\", \")))))()(())\")) == true\nmatch_parens(list(\"\
    (()(()(()(()\", \"))())))()(())\")) == false\nmatch_parens(list(\"(()(()(()(()\"\
    , \")))))", "    -- good: [1, 2, 3, 4, 5]\n    -- bad:  [2, 3, 4, 5, 1]\n    local\
    \ count = { ['('] = 1, [')'] = -1 }\n    local res = 0\n    local ok = true\n\
    \    for _, v in ipairs(lst) do\n        res = res + count[v]\n        if res\
    \ < 0 then\n            ok = false\n            break\n        end\n    end\n\
    \    return ok and res == 0\nend", "  for s in lst:gmatch(\"%(\") do\n    for\
    \ e in lst:gmatch(\"%)\") do\n      if s == e then\n        lst = lst:gsub(s,\
    \ \"\")\n      end\n    end\n  end\n  if lst == \"\" then\n    return \"Yes\"\n\
    \  else\n    return \"No\"\n  end\nend", "  local prev = lst[1]\n  local bal =\
    \ 0\n  for i = 2, #lst do\n    local item = lst[i]\n    if prev == '(' and item\
    \ == ')' then\n      bal = bal - 1\n    elseif prev == ')' and item == '(' then\n\
    \      bal = bal + 1\n    end\n    prev = item\n  end\n  return bal\nend", " \
    \   return function(chr)\n        if chr == '(' then\n            table.insert(lst,\
    \ chr)\n        else\n            if #lst == 0 then\n                return false\n\
    \            end\n            table.remove(lst)\n        end\n        return true\n\
    \    end\nend", "  local function is_good(str)\n    local parens = 0\n    for\
    \ i = 1, #str do\n      if str:sub(i, i) == '(' then\n        parens = parens\
    \ + 1\n      else\n        parens = parens - 1\n      end\n      if parens < 0\
    \ then\n        return false\n      end\n    end\n    return parens == 0\n  end\n\
    \  return is_good(lst[1] .. lst[2]) or is_good(lst[2] .. lst[1])\nend", "    local\
    \ open = 0\n    for _, v in ipairs(lst) do\n        if v == '(' then\n       \
    \     open = open + 1\n        else\n            open = open - 1\n        end\n\
    \        if open < 0 then\n            return false\n        end\n    end\n  \
    \  return open == 0\nend", "    local s = table.concat(lst)\n    local stack =\
    \ {}\n    for c in s:gmatch('.') do\n        if c == '(' then\n            table.insert(stack,\
    \ c)\n        else\n            table.remove(stack)\n        end\n    end\n  \
    \  return #stack == 0\nend", "    if lst == nil then\n        return 0\n    end\n\
    \    local max_len = string.len(lst[1]) + string.len(lst[2])\n    local parens\
    \ = \"\"\n    for i = 1, max_len do\n        parens = parens .. \"()\"\n    end\n\
    \    return string.find(parens, lst[1] .. lst[2]) ~= nil and \"Yes\" or \"No\"\
    \nend", "  local n, i = 0, 1\n  for c in lst:gmatch\".\" do\n    n = n + (c ==\
    \ \"(\" and 1 or -1)\n    if n < 0 then break end\n    i = i + 1\n  end\n  return\
    \ n == 0 and i, n\nend", "    local left = 0\n    local right = 0\n    for i=1,\
    \ #lst do\n        if lst[i] == '(' then\n            left = left + 1\n      \
    \  else\n            right = right + 1\n        end\n    end\n    if left > right\
    \ then\n        return true\n    else\n        return false\n    end\nend", " \
    \  local count = 0\n   for _, p in ipairs(lst) do\n      if p == '(' then\n  \
    \       count = count + 1\n      else\n         count = count - 1\n      end\n\
    \      if count < 0 then\n         return false\n      end\n   end\n   return\
    \ count == 0\nend", "  local stack = {}\n  for i=1,#lst do\n    local c = lst:sub(i,i)\n\
    \    if c == '(' then\n      table.insert(stack, c)\n    else\n      if #stack\
    \ == 0 then\n        return false\n      end\n      table.remove(stack)\n    end\n\
    \  end\n  return #stack == 0\nend", "  local list = {unpack(lst)}\n  local parens\
    \ = 0\n  for i = 1, #list do\n    local letter = list[i]\n    if letter == '('\
    \ then\n      parens = parens + 1\n    else\n      parens = parens - 1\n    end\n\
    \    if parens < 0 then\n      return false\n    end\n  end\n  return parens ==\
    \ 0\nend", "  local n = #lst\n  local n_opened = 0\n  for i = 1, n do\n    if\
    \ lst[i] == '(' then\n      n_opened = n_opened + 1\n    else\n      n_opened\
    \ = n_opened - 1\n    end\n    if n_opened < 0 then\n      return false\n    end\n\
    \  end\n  return n_opened == 0\nend", "  local s = table.concat(lst)\n  local\
    \ pos = 1\n  local lpos = 0\n  while true do\n    lpos = s:find('%(', pos)\n \
    \   if not lpos then break end\n    local rpos = s:find('%)', lpos)\n    if not\
    \ rpos then return false end\n    pos = rpos + 1\n  end\n  return true\nend",
  "    if #lst == 0 then\n        return 'Yes'\n    end\n    local chars = {}\n  \
    \  for _, v in ipairs(lst) do\n        for c in v:gmatch('.') do\n           \
    \ table.insert(chars, c)\n        end\n    end\n    local stack = {}\n    for\
    \ _, c in ipairs(chars) do\n        if c == '(' then\n            table.insert(stack,\
    \ c)\n        else\n            if #stack == 0 then\n                return 'No'\n\
    \            end\n            if stack[#stack] == '(' then\n                table.remove(stack)\n\
    \            else\n                return 'No'\n            end\n        end\n\
    \    end\n    if #stack > 0 then\n        return 'No'\n    end\n    return 'Yes'\n\
    end", "    local nopen, nclose = 0, 0\n    for i = 1, #lst do\n        if lst[i]\
    \ == '(' then\n            nopen = nopen + 1\n        else\n            nclose\
    \ = nclose + 1\n        end\n    end\n    return nopen == nclose\nend", "    local\
    \ function outmost_match(s)\n        local lvl = 0\n        for i = 1, #s do\n\
    \            local c = s:sub(i, i)\n            if c == '(' then\n           \
    \     lvl = lvl + 1\n            else\n                lvl = lvl - 1\n       \
    \     end\n            if lvl < 0 then\n                return i - 1\n       \
    \     end\n        end\n        return #s\n    end\n    local s1, s2 = lst[1],\
    \ lst[2]\n    local count1, count2 = 0, 0\n    local function try_match(s1, s2)\n\
    \        while count1 < #s1 and count2 < #s2 do\n            local l = outmost_match(s1:sub(count1\
    \ + 1))\n            local r = outmost_match(s2:sub(count2 + 1))\n           \
    \ if l == 0 and r == 0 then\n                break\n            end\n        \
    \    if l == 0 then\n                s1 = s1 .. s2:sub(count2 + 1, count2 + r)\n\
    \                count2 = count2 + r\n            elseif r == 0 then\n       \
    \         s2 = s2 .. s1:sub(count1 + 1, count1 + l)\n                count1 =\
    \ count1 + l\n            else\n                local left = s1:sub(count1 + 1,\
    \ count1 + l)\n                local right = s2:sub(count2 + 1, count2 + r)\n\
    \                if #left < #right then\n                    s1 = s1 .. s2:sub(count2\
    \ + 1, count2 + r)\n                    count2 = count2 + r\n                else\n\
    \                    s2 = s2 .. s1:sub(count1 + 1, count1 + l)\n             \
    \       count1 = count1 + l\n                end\n            end\n        end\n\
    \        local s = s1:sub(count1 + 1) .. s2:sub(count2 + 1)\n        return paren_balanced(s)\n\
    \    end\n    if try_match(s1, s2) then\n        return 'Yes'\n    else\n    \
    \    return 'No'\n    end\nend\nassert(match_parens({\"))(\", \"))(\"}) == '",
  "  local matches = {'(', ')'}\n  local stack = {}\n  for _, v in ipairs(lst) do\n\
    \    local ch = v:match(\"^%s*(.)%s*$\")\n    if ch == matches[1] then\n     \
    \ table.insert(stack, 1, v)\n    elseif ch == matches[2] then\n      if stack[1]\
    \ == matches[1] then\n        table.remove(stack, 1)\n      else\n        return\
    \ false\n      end\n    end\n  end\n  return #stack == 0\nend", "  if not lst[1]\
    \ then return true end\n  if lst[1] == '(' then\n    if lst[2] == ')' then\n \
    \     return match_parens(lst(3, -1))\n    else\n      return false\n    end\n\
    \  else\n    if lst[2] == '(' then\n      return match_parens(lst(3, -1))\n  \
    \  else\n      return false\n    end\n  end\nend", "    local s = table.concat(lst)\n\
    \    while s:match'()' do\n        s = s:gsub('()', '')\n    end\n    return s\
    \ == ''\nend", "    local flst = {}\n    for i = 1, #lst do\n        local c =\
    \ lst:sub(i, i)\n        if c == '(' then\n            tinsert(flst, 1, c)\n \
    \       else\n            if flst[1] == '(' then\n                tremove(flst,\
    \ 1)\n            else\n                return 'No'\n            end\n       \
    \ end\n    end\n    if #flst > 0 then\n        return 'No'\n    end\n    return\
    \ 'Yes'\nend", "    local stk = {}\n    for i = 1, #lst do\n        local ch =\
    \ lst[i]\n        if ch == '(' then\n            table.insert(stk, ch)\n     \
    \   elseif ch == ')' then\n            if #stk == 0 then\n                return\
    \ false\n            end\n            table.remove(stk)\n        end\n    end\n\
    \    return #stk == 0\nend", "    local good, bad = '('..lst[1]..lst[2]..')',\
    \ lst[1]..lst[2]\n    local i, l, bal = 1, #good, 0\n    while i <= l do\n   \
    \     local c = good:sub(i, i)\n        if c == '(' then\n            bal = bal\
    \ + 1\n        else\n            bal = bal - 1\n        end\n        if bal <\
    \ 0 then\n            return 'No'\n        end\n        i = i + 1\n    end\n \
    \   return bal == 0 and 'Yes' or 'No'\nend", "    local n_open = 0\n    local\
    \ n_close = 0\n    for i = 1, #lst do\n        if lst[i] == '(' then\n       \
    \     n_open = n_open + 1\n        else\n            n_close = n_close + 1\n \
    \       end\n    end\n    return n_open == n_close\nend", "  local l = #lst\n\
    \  for i = 1, l do\n    if lst[i] == '(' then\n      for j = l, i + 1, -1 do\n\
    \        if lst[j] == ')' then\n          lst[i] = nil\n          lst[j] = nil\n\
    \          break\n        end\n      end\n    end\n  end\n  if #lst == 0 then\n\
    \    return 'Yes'\n  else\n    return 'No'\n  end\nend", "  if lst == nil then\n\
    \    return true\n  end\n  local match = { ['('] = ')', [')'] = '(' }\n  local\
    \ i = 1\n  while lst[i] do\n    if match[lst[i]] == lst[i+1] then\n      -- remove\
    \ matched parens\n      table.remove(lst, i)\n      table.remove(lst, i)\n   \
    \   i = i - 1\n    end\n    i = i + 1\n  end\n  return #lst == 0\nend", "    local\
    \ count = 0\n    for _, s in ipairs(lst) do\n        for c in s:gmatch '.' do\n\
    \            if c == '(' then\n                count = count + 1\n           \
    \ else\n                count = count - 1\n            end\n            if count\
    \ < 0 then\n                return 'No'\n            end\n        end\n    end\n\
    \    return count == 0 and 'Yes' or 'No'\nend\nassert(match_parens {'()(())',\
    \ '))((()'} == 'Yes')\nassert(match_parens {'))))))(((((', '))((((('} == 'No')\n\
    assert(match_parens {'))(((((((((', '))))))((((('} == 'No')", "    -- >>> match_parens(['()',\
    \ '()'])\n    -- 'Yes'\n    -- >>> match_parens(['()', ')('])\n    -- 'No'\n \
    \   -- >>> match_parens(['())', '()'])\n    -- 'No'\n    local c = 0\n    for\
    \ _, s in ipairs(lst) do\n        for c in s:gmatch('%(') do\n            c =\
    \ c + 1\n        end\n        for c in s:gmatch('%)') do\n            c = c -\
    \ 1\n        end\n        if c < 0 then\n            return 'No'\n        end\n\
    \    end\n    return 'Yes'\nend", "    local l_parens = 0\n    local r_parens\
    \ = 0\n    for _, ch in ipairs(lst) do\n        if ch == '(' then\n          \
    \  l_parens = l_parens + 1\n        else\n            if l_parens == 0 then\n\
    \                r_parens = r_parens + 1\n            else\n                l_parens\
    \ = l_parens - 1\n            end\n        end\n    end\n    return l_parens,\
    \ r_parens\nend", "    local count = 0\n    for i = 1, #lst do\n        if lst[i]\
    \ == '(' then\n            count = count + 1\n        else\n            count\
    \ = count - 1\n        end\n        if count < 0 then\n            return 'No'\n\
    \        end\n    end\n    return count == 0 and 'Yes' or 'No'\nend", "  local\
    \ open = 0\n  for i = 1, #lst do\n    local c = lst:sub(i, i)\n    if c == '('\
    \ then\n      open = open + 1\n    else\n      open = open - 1\n    end\n    if\
    \ open < 0 then\n      return false\n    end\n  end\n  return open == 0\nend",
  "    local stack = {}\n    for i, v in ipairs(lst) do\n        if v == '(' then\n\
    \            table.insert(stack, v)\n        else\n            if #stack == 0\
    \ then\n                return false\n            end\n            table.remove(stack)\n\
    \        end\n    end\n    return #stack == 0\nend", "  local function _match_parens(lst,\
    \ bal)\n    if not lst then return bal == 0 end\n    local c = lst[1]\n    if\
    \ c == '(' then\n      return _match_parens(lst.next, bal + 1)\n    else\n   \
    \   return bal > 0 and _match_parens(lst.next, bal - 1)\n    end\n  end\n  return\
    \ _match_parens(lst, 0)\nend", "  local opened = 0\n  for i=1,#lst do\n    local\
    \ ch = lst:sub(i,i)\n    if ch == '(' then\n      opened = opened + 1\n    else\n\
    \      opened = opened - 1\n      if opened < 0 then\n        return false\n \
    \     end\n    end\n  end\n  return opened == 0\nend", "  local open = 0\n  for\
    \ _, c in ipairs(lst) do\n    if c == '(' then\n      open = open + 1\n    else\n\
    \      open = open - 1\n    end\n    if open < 0 then\n      return false\n  \
    \  end\n  end\n  return open == 0\nend", "    local s = table.concat(lst)\n  \
    \  local unopened = 0\n    for i = 1, #s do\n        if s:sub(i, i) == '(' then\n\
    \            unopened = unopened + 1\n        else\n            unopened = unopened\
    \ - 1\n            if unopened < 0 then\n                return false\n      \
    \      end\n        end\n    end\n    return unopened == 0\nend", "    local length,\
    \ count = #lst, 0\n    for i = 1, length do\n        if lst:sub(i, i) == '(' then\n\
    \            count = count + 1\n        else\n            count = count - 1\n\
    \        end\n        if count < 0 then\n            return false\n        end\n\
    \    end\n    return count == 0\nend", "  --\n  local function go(lst, counter)\n\
    \    if counter < 0 then\n      return false\n    end\n    if is_empty(lst) then\n\
    \      return counter == 0\n    end\n    local op = car(lst)\n    if op == '('\
    \ then\n      return go(cdr(lst), counter + 1)\n    else\n      return go(cdr(lst),\
    \ counter - 1)\n    end\n  end\n  return go(lst, 0)\nend", "    local open_pairs\
    \ = 0\n    for _, v in ipairs(lst) do\n        if v == '(' then\n            open_pairs\
    \ = open_pairs + 1\n        else\n            open_pairs = open_pairs - 1\n  \
    \      end\n        if open_pairs < 0 then\n            return false\n       \
    \ end\n    end\n    return open_pairs == 0\nend", "   if not lst[1] then return\
    \ true end\n   local i = 1\n   local n = #lst\n   while i <= n do\n      if lst[i]\
    \ == '(' then\n         local j = i + 1\n         while j <= n do\n          \
    \  if lst[j] == ')' then\n               local res = match_parens(table.concat(lst,\
    \ '', 1, i - 1) ..\n                                        table.concat(lst,\
    \ '', j + 1, n))\n               if res then return true end\n            end\n\
    \            j = j + 1\n         end\n      end\n      i = i + 1\n   end\n   return\
    \ false\nend", "    local tbl = {}\n    for i = 1, #lst do\n        local c =\
    \ lst[i]\n        if c == '(' then\n            tbl[#tbl + 1] = c\n        else\n\
    \            if tbl[#tbl] == '(' then\n                tbl[#tbl] = nil\n     \
    \       else\n                return false\n            end\n        end\n   \
    \ end\n    return (#tbl == 0)\nend", "  local function good(S)\n    local t =\
    \ {}\n    for i = 1, #S do\n      local c = S:sub(i, i)\n      if c == '(' then\n\
    \        table.insert(t, c)\n      else\n        if #t == 0 then\n          return\
    \ false\n        end\n        table.remove(t)\n      end\n    end\n    return\
    \ #t == 0\n  end\n  return good(lst[1] .. lst[2]) and 'Yes' or 'No'\nend", " \
    \   local s = table.concat(lst)\n    local balance = 0\n    for i = 1, #s do\n\
    \        if s:sub(i, i) == '(' then\n            balance = balance + 1\n     \
    \   else\n            balance = balance - 1\n        end\n        if balance <\
    \ 0 then\n            return false\n        end\n    end\n    return balance ==\
    \ 0\nend", "    local acc = 0\n    for _, c in ipairs(lst) do\n        if c ==\
    \ '(' then\n            acc = acc + 1\n        else\n            acc = acc - 1\n\
    \        end\n        if acc < 0 then\n            return false\n        end\n\
    \    end\n    return acc == 0\nend", "  local sum = 0\n  for _, v in ipairs(lst)\
    \ do\n    if v == '(' then\n      sum = sum + 1\n    else\n      sum = sum - 1\n\
    \    end\n    if sum < 0 then\n      return false\n    end\n  end\n  return sum\
    \ == 0\nend", "    local stack = {}\n    for _, p in ipairs(lst) do\n        if\
    \ p == '(' then\n            table.insert(stack, p)\n        else\n          \
    \  if #stack == 0 then\n                return false\n            end\n      \
    \      table.remove(stack)\n        end\n    end\n    return #stack == 0\nend",
  "    local stack = {}\n    for i = 1, #lst do\n        local c = lst:sub(i, i)\n\
    \        if c == '(' then\n            table.insert(stack, c)\n        else\n\
    \            table.remove(stack)\n        end\n    end\n    return #stack == 0\n\
    end", "    return ((lst:gsub('%(%(%)%)', '')):len() == 0) and 'Yes' or 'No'\n\
    end", "    -- (.)(.) -> No\n    -- . -> .\n    -- (.) -> (.)\n    -- () -> ()\n\
    \    -- (.) -> ()\n    -- (() -> No\n    -- (.) -> ()\n    local function c (lst,\
    \ pair)\n        if empty(lst) then\n            return lst\n        elseif first(lst)\
    \ == '(' then\n            return cons(pair[1], c(rest(lst), pair))\n        else\n\
    \            return cons(pair[2], c(rest(lst), pair))\n        end\n    end\n\
    \    local result = c(lst, {'(', ')'})\n    local count = 0\n    local i = 1\n\
    \    while i <= length(result) do\n        local x = result[i]\n        if x ==\
    \ '(' then\n            count = count + 1\n        else\n            count = count\
    \ - 1\n        end\n        if count < 0 then\n            return 'No'\n     \
    \   end\n        i = i + 1\n    end\n    if count == 0 then\n        return 'Yes'\n\
    \    else\n        return 'No'\n    end\nend", "    local stack = {}\n    for\
    \ _, p in ipairs(lst) do\n        if p == '(' then\n            table.insert(stack,\
    \ p)\n        else\n            table.remove(stack)\n        end\n    end\n  \
    \  return #stack == 0\nend", "  local stack = {}\n  for i = 1, #lst do\n    local\
    \ curr = lst[i]\n    if curr == '(' then\n      table.insert(stack, curr)\n  \
    \  else\n      if #stack == 0 then\n        return false\n      end\n      table.remove(stack)\n\
    \    end\n  end\n  return #stack == 0\nend", "    local stack = {}\n    for _,\
    \ p in ipairs(lst) do\n        if p == '(' then\n            table.insert(stack,\
    \ p)\n        else\n            if #stack > 0 then\n                table.remove(stack)\n\
    \            else\n                return false\n            end\n        end\n\
    \    end\n    return #stack == 0\nend", "    return table.concat(lst)\nend", " \
    \   local stack = {}\n    for _, char in ipairs(lst) do\n        if char == '('\
    \ then\n            table.insert(stack, char)\n        else\n            if #stack\
    \ == 0 then\n                return false\n            end\n            table.remove(stack)\n\
    \        end\n    end\n    return #stack == 0\nend", "  local cnt = 0\n  for i\
    \ = 1, #lst do\n    local c = lst:sub(i, i)\n    if c == '(' then\n      cnt =\
    \ cnt + 1\n    else\n      cnt = cnt - 1\n    end\n    if cnt < 0 then\n     \
    \ return false\n    end\n  end\n  return cnt == 0\nend", "    -- [string, string]\
    \ -> string\n    -- Match the strings to check whether it is possible to concatenate\
    \ the\n    -- strings in some order, that the resulting string will be good.\n\
    \    -- A string S is considered to be good if and only if all parentheses in\
    \ S\n    -- are balanced. For example: the string '(())()' is good, while the\
    \ string\n    -- '())' is not.\n    -- >>> match_parens({\"(())\", \"()()\"})\n\
    \    -- 'Yes'\n    -- >>> match_parens({\"()(()\", \"()\"})\n    -- 'No'\n   \
    \ local s1, s2 = lst[1], lst[2]\n    if not (s1 and s2) then\n        return 'No'\n\
    \    end\n    local t1, t2 = 0, 0\n    for i = 1, #s1 do\n        local c = s1:sub(i,\
    \ i)\n        if c == '(' then\n            t1 = t1 + 1\n        else\n      \
    \      t1 = t1 - 1\n        end\n        if t1 < 0 then\n            return 'No'\n\
    \        end\n    end\n    for i = 1, #s2 do\n        local c = s2:sub(i, i)\n\
    \        if c == '(' then\n            t2 = t2 + 1\n        else\n           \
    \ t2 = t2 - 1\n        end\n        if t2 < 0 then\n            return 'No'\n\
    \        end\n    end\n    return (t1 == t2) and 'Yes' or 'No'\nend", "  local\
    \ stack = {}\n  for _, c in ipairs(lst) do\n    if c == '(' then\n      table.insert(stack,\
    \ c)\n    else\n      if #stack == 0 then\n        return false\n      end\n \
    \     local top = table.remove(stack)\n      if top ~= '(' then\n        return\
    \ false\n      end\n    end\n  end\n  return #stack == 0\nend", "  local function\
    \ aux(lst, sum)\n    if lst[1] == '(' then sum = sum + 1\n    elseif lst[1] ==\
    \ ')' then sum = sum - 1 end\n    if sum < 0 then return \"No\" end\n    return\
    \ sum == 0 and #lst == 1 and \"Yes\" or aux(tail(lst), sum)\n  end\n  return aux(lst,\
    \ 0)\nend", "    local total_close = 0\n    local total_open = 0\n    for _, c\
    \ in ipairs(lst) do\n        if c == '(' then\n            total_open = total_open\
    \ + 1\n        else\n            total_close = total_close + 1\n        end\n\
    \    end\n    return total_open == total_close\nend", "   local function dfs(open,\
    \ close, count, lst)\n      if open == close and count == 0 then\n         return\
    \ true\n      end\n      if open > close or count < 0 then\n         return false\n\
    \      end\n      return dfs(open+1, close, count+1, lst) or dfs(open, close+1,\
    \ count-1, lst)\n   end\n   return dfs(1, 0, 0, lst)\nend", "   local stack =\
    \ {}\n   for i = 1, #lst do\n      local cur = lst[i]\n      if cur == '(' then\n\
    \         table.insert(stack, i)\n      elseif cur == ')' then\n         if #stack\
    \ == 0 then\n            return false\n         end\n         table.remove(stack)\n\
    \      end\n   end\n   return #stack == 0\nend", "   local stack = {}\n   for\
    \ i = 1, #lst do\n      local c = lst[i]\n      if c == '(' then\n         stack[#stack\
    \ + 1] = c\n      elseif c == ')' then\n         if #stack == 0 then\n       \
    \     return false\n         end\n         local e = stack[#stack]\n         if\
    \ e == '(' then\n            stack[#stack] = nil\n         else\n            return\
    \ false\n         end\n      end\n   end\n   return #stack == 0\nend", "    local\
    \ balance = 0\n    for _, c in ipairs(lst) do\n        if c == '(' then\n    \
    \        balance = balance + 1\n        else\n            balance = balance -\
    \ 1\n        end\n        if balance < 0 then\n            return false\n    \
    \    end\n    end\n    return balance == 0\nend", "  local is_good = true\n  local\
    \ stack = {}\n  for i, c in ipairs(lst) do\n    if c == '(' then\n      table.insert(stack,\
    \ c)\n    else\n      if #stack == 0 then\n        is_good = false\n        break\n\
    \      end\n      table.remove(stack)\n    end\n  end\n  if #stack > 0 then\n\
    \    is_good = false\n  end\n  return is_good\nend", "    local stk = {}\n   \
    \ for i = 1, #lst do\n        local c = lst[i]\n        if c == '(' then\n   \
    \         stk[#stk + 1] = '('\n        else\n            if #stk == 0 then\n \
    \               return false\n            end\n            stk[#stk] = nil\n \
    \       end\n    end\n    return #stk == 0\nend", "    local function count_parens(s)\n\
    \        local cnt = 0\n        for i = 1, #s do\n            local c = s:sub(i,\
    \ i)\n            if c == '(' then\n                cnt = cnt + 1\n          \
    \  else\n                cnt = cnt - 1\n            end\n        end\n       \
    \ return cnt\n    end\n    local cnt1 = count_parens(lst[1])\n    local cnt2 =\
    \ count_parens(lst[2])\n    if cnt1 == 0 and cnt2 == 0 then\n        return 'Yes'\n\
    \    elseif cnt1 == cnt2 then\n        return 'No'\n    elseif cnt1 > 0 and cnt2\
    \ < 0 then\n        return 'Yes'\n    elseif cnt1 < 0 and cnt2 > 0 then\n    \
    \    return 'Yes'\n    else\n        return 'No'\n    end\nend", "    local nesting\
    \ = 0\n    for _, p in ipairs(lst) do\n        if p == '(' then\n            nesting\
    \ = nesting + 1\n        else\n            nesting = nesting - 1\n        end\n\
    \        if nesting < 0 then\n            return false\n        end\n    end\n\
    \    return nesting == 0\nend", "   local nlst = {}\n   for i = 1, #lst do\n \
    \     nlst[i] = lst[i] == '(' and 1 or -1\n   end\n   local function loop(acc,\
    \ i)\n      if i > #lst then\n         return acc == 0\n      else\n         return\
    \ loop(acc + nlst[i], i + 1)\n      end\n   end\n   return loop(0, 1)\nend", " \
    \   local function recurse(left, right, s)\n        if left == 0 and right ==\
    \ 0 then\n            return \"Yes\"\n        elseif left == 0 then\n        \
    \    if right == 1 then\n                return \"No\"\n            else\n   \
    \             return recurse(left, right - 1, s)\n            end\n        elseif\
    \ right == 0 then\n            return recurse(left - 1, right, s)\n        elseif\
    \ left > right then\n            return \"No\"\n        else\n            return\
    \ recurse(left - 1, right, s) .. ' ' .. recurse(left, right - 1, s)\n        end\n\
    \    end\n    local left, right = 0, 0\n    for i = 1, #lst[1] do\n        if\
    \ lst[1]:sub(i, i) == '(' then\n            left = left + 1\n        else\n  \
    \          right = right + 1\n        end\n    end\n    for i = 1, #lst[2] do\n\
    \        if lst[2]:sub(i, i) == '(' then\n            left = left + 1\n      \
    \  else\n            right = right + 1\n        end\n    end\n    return recurse(left,\
    \ right, '')\nend\nassert(match_parens({\"(((\", \")))\"}) == \"Yes\")\nassert(match_parens({\"\
    )))\", \"(((\"}) == \"No\")\nassert(match_parens({\"))))\", \"((((\"}) == \"No\"\
    )\nassert(match_parens({\"(((\", \"))))\"}) == \"Yes\")\nassert(match_parens({\"\
    (((\", \"))))))\"}) == \"No\")\nassert(match_parens({\"(((((((((((((\", \"))))))))))))))\"\
    }) == \"Yes\")\nassert(match_parens({\"(\", \")\"}) == \"Yes\")", "   local s\
    \ = table.concat(lst)\n   local n = 0\n   for i = 1, #s do\n      if s:sub(i,\
    \ i) == '(' then\n         n = n + 1\n      else\n         n = n - 1\n      end\n\
    \      if n < 0 then\n         return 'No'\n      end\n   end\n   return n ==\
    \ 0 and 'Yes' or 'No'\nend", "   local function helper(str, par)\n      local\
    \ first = string.sub(str, 1, 1)\n      if first == \"(\" then\n         return\
    \ helper(string.sub(str, 2), par + 1)\n      elseif first == \")\" then\n    \
    \     return helper(string.sub(str, 2), par - 1)\n      elseif str == \"\" then\n\
    \         return par == 0\n      else\n         return false\n      end\n   end\n\
    \   local function check_parens(str)\n      return helper(str, 0)\n   end\n  \
    \ local function all_parens(lst)\n      local function h(lst, str)\n         if\
    \ #lst == 0 then\n            return str\n         else\n            return h(tail(lst),\
    \ str .. head(lst))\n         end\n      end\n      return h(lst, \"\")\n   end\n\
    \   local function concat(s1, s2)\n      return s1 .. s2\n   end\n   local function\
    \ concat_to_str(s1, s2)\n      return {s1, s2}\n   end\n   local function filter(fn,\
    \ lst)\n      local function h(lst, acc)\n         if #lst == 0 then\n       \
    \     return acc\n         else\n            if fn(head(lst)) then\n         \
    \      return h(tail(lst), cons(head(lst), acc))\n            else\n         \
    \      return h(tail(lst), acc)\n            end\n         end\n      end\n  \
    \    return h(lst, nil)\n   end\n   local function keep_good(lst)\n      return\
    \ filter(check_parens, lst)\n   end\n   local function combine(lst1, lst2)\n \
    \     local function h(lst1, lst2, acc)\n         if #lst1 == 0 then\n       \
    \     return acc\n         else\n            return h(tail(lst1), lst2, cons(concat_to_str(head(lst1),\
    \ head(lst2)), acc))\n         end\n      end\n      return h(lst1, lst2, nil)\n\
    \   end\n   local function combine_all(lst1, lst2)", "  local stack = {}\n  for\
    \ _, e in ipairs(lst) do\n    if e == '(' then\n      stack[#stack + 1] = e\n\
    \    else\n      if #stack == 0 then\n        return false\n      end\n      stack[#stack]\
    \ = nil\n    end\n  end\n  return #stack == 0\nend", "    local s = ''\n    for\
    \ _, v in ipairs(lst) do\n        s = s .. v\n    end\n    local stack = {}\n\
    \    for i = 1, #s do\n        local c = s:sub(i, i)\n        if c == '(' then\n\
    \            table.insert(stack, c)\n        else\n            if #stack == 0\
    \ then\n                return false\n            end\n            table.remove(stack)\n\
    \        end\n    end\n    return #stack == 0\nend", "  local stack = {}\n  for\
    \ _, v in ipairs(lst) do\n    table.insert(stack, v)\n    while #stack >= 2 and\
    \ stack[#stack] == ')' and stack[#stack - 1] == '(' do\n      table.remove(stack,\
    \ #stack)\n      table.remove(stack, #stack)\n    end\n  end\n  return #stack\
    \ == 0\nend", "  local function check(str)\n    local arr = str:split('')\n  \
    \  local sum = 0\n    for _, c in ipairs(arr) do\n      if c == '(' then\n   \
    \     sum = sum + 1\n      else\n        sum = sum - 1\n      end\n      if sum\
    \ < 0 then\n        return false\n      end\n    end\n    return sum == 0\n  end\n\
    \  return (check(lst[1]) and check(lst[2])) and 'Yes' or 'No'\nend", "    local\
    \ match = {\n        [\"(\"] = \")\",\n        [\")\"] = \"(\"\n    }\n    local\
    \ stack = {}\n    for _, x in ipairs(lst) do\n        if #stack == 0 then\n  \
    \          table.insert(stack, x)\n        else\n            local top = stack[#stack]\n\
    \            if match[top] == x then\n                table.remove(stack)\n  \
    \          else\n                table.insert(stack, x)\n            end\n   \
    \     end\n    end\n    return #stack == 0\nend", "  local n = 0\n  for i = 1,\
    \ #lst do\n    if lst:sub(i, i) == '(' then\n      n = n + 1\n    else\n     \
    \ n = n - 1\n    end\n    if n < 0 then\n      return false\n    end\n  end\n\
    \  return n == 0\nend", "  local v = 0\n  for i=1,#lst do\n    if lst:sub(i,i)\
    \ == '(' then\n      v = v + 1\n    else\n      v = v - 1\n    end\n    if v <\
    \ 0 then\n      return false\n    end\n  end\n  return v == 0\nend", "    -- Use\
    \ these two values to determine if concatenating two strings results\n    -- in\
    \ a good string or not.\n    local openParens = 0\n    local closeParens = 0",
  "    local stack = {}\n    for _, c in ipairs(lst) do\n        if c == '(' then\n\
    \            table.insert(stack, c)\n        else\n            if #stack == 0\
    \ then\n                return false\n            end\n            table.remove(stack)\n\
    \        end\n    end\n    return #stack == 0\nend", "    local left_paren = 0\n\
    \    local right_paren = 0\n    for _, char in ipairs(lst) do\n        if char\
    \ == '(' then\n            left_paren = left_paren + 1\n        else\n       \
    \     right_paren = right_paren + 1\n        end\n    end\n    if left_paren >\
    \ right_paren then\n        return '('\n    elseif right_paren > left_paren then\n\
    \        return ')'\n    else\n        return nil\n    end\nend", "  local res\
    \ = {}\n  for i = 1, #lst do\n    if lst[i] == '(' then\n      table.insert(res,\
    \ i)\n    else\n      if #res == 0 then\n        return false\n      end\n   \
    \   table.remove(res)\n    end\n  end\n  return #res == 0\nend", "  -- For this\
    \ problem, we'll be checking the validity of a string\n  -- of parentheses by\
    \ keeping a count of how many more open parentheses\n  -- we have remaining.\n\
    \  -- When we reach the end of a string, we'll be at zero open parentheses,\n\
    \  -- with all parentheses having been closed.\n  -- (We can set the initial count\
    \ to 1 to check for the case where the\n  -- last character is not a closing parenthesis.)\n\
    \  local count = 1\n  -- Now we just have to check each character in the string,\
    \ and increase\n  -- the count for each open parenthesis, and decrease the count\
    \ for each\n  -- close parenthesis.\n  for i = 1, #lst do\n    local char = lst:sub(i,\
    \ i)\n    if char == '(' then\n      count = count + 1\n    elseif char == ')'\
    \ then\n      count = count - 1\n    end\n    -- If we ever go below zero (with\
    \ too many close parentheses), then\n    -- the string is invalid.\n    if count\
    \ < 0 then\n      return false\n    end\n  end\n  -- If the count is zero after\
    \ the whole string, then we have a valid\n  -- string.\n  return count == 0\n\
    end", "    local count = 0\n    for _, char in ipairs(lst) do\n        if char\
    \ == '(' then\n            count = count + 1\n        else\n            count\
    \ = count - 1\n        end\n        if count < 0 then\n            return 'No'\n\
    \        end\n    end\n    return count == 0 and 'Yes' or 'No'\nend", "    local\
    \ left = 0\n    local right = 0\n    for _, i in ipairs(lst) do\n        if i\
    \ == '(' then\n            left = left + 1\n        else\n            right =\
    \ right + 1\n        end\n    end\n    return left == right\nend", "  local s\
    \ = table.concat(lst)\n  return s:gsub('%b()', '') == ''\nend", "  -- good_string({\"\
    (())\", \"())()\"}) => 'Yes'\n  -- good_string({\"(((\", \"()\"}) => 'No'\n  --\
    \ good_string({\"(()\", \"))(\"}) => 'No'\n  -- good_string({\"(())\", \"(()\"\
    }) => 'No'\n  -- good_string({\"(())\", \"))))\"}) => 'No'\n  -- good_string({\"\
    (()\", \")()\"}) => 'Yes'\n  -- good_string({\"()\", \"((())\"}) => 'Yes'\n  local\
    \ s = lst[1] .. lst[2]\n  local sz = #s\n  local parens = {}\n  for i = 1, sz\
    \ do\n    if s:sub(i, i) == '(' then\n      table.insert(parens, i)\n    else\n\
    \      if #parens > 0 then\n        table.remove(parens)\n      else\n       \
    \ return 'No'\n      end\n    end\n  end\n  return #parens == 0 and 'Yes' or 'No'\n\
    end", "    local n = #lst\n    if n == 0 then\n        return true\n    end\n\
    \    if n % 2 == 1 then\n        return false\n    end\n    local stack = {}\n\
    \    for i = 1, n do\n        local c = lst[i]\n        if c == '(' then\n   \
    \         table.insert(stack, c)\n        else\n            local top = stack[#stack]\n\
    \            if top == '(' then\n                table.remove(stack)\n       \
    \     else\n                return false\n            end\n        end\n    end\n\
    \    return #stack == 0\nend", "  local count = 0\n  for i = 1, #lst do\n    if\
    \ lst:sub(i, i) == '(' then\n      count = count + 1\n    else\n      count =\
    \ count - 1\n    end\n    if count < 0 then\n      return false\n    end\n  end\n\
    \  return count == 0\nend", "    local open = 0\n    for _, c in ipairs(lst) do\n\
    \        if c == '(' then\n            open = open + 1\n        else\n       \
    \     open = open - 1\n        end\n        if open < 0 then\n            return\
    \ false\n        end\n    end\n    return open == 0\nend", "    local p = 0\n\
    \    for _, c in ipairs(lst) do\n        if c == '(' then\n            p = p +\
    \ 1\n        else\n            p = p - 1\n        end\n        if p < 0 then\n\
    \            return false\n        end\n    end\n    return p == 0\nend", "  \
    \  local n = 0\n    for i = 1, #lst do\n        if lst[i] == '(' then\n      \
    \      n = n + 1\n        else\n            n = n - 1\n        end\n        if\
    \ n < 0 then\n            return false\n        end\n    end\n    return n ==\
    \ 0\nend", "    local l, r = lst:gsub('[()]', { ['('] = '', [')'] = '' })\n  \
    \  return l == r\nend", "    local idx = {}\n    for i,c in ipairs(lst) do\n \
    \       if c == '(' then\n            idx[#idx+1] = i\n        else\n        \
    \    if #idx > 0 then\n                local j = idx[#idx]\n                idx[#idx]\
    \ = nil\n                lst[i] = j\n                lst[j] = i\n            else\n\
    \                return false\n            end\n        end\n    end\n    return\
    \ true\nend", "   local stack = {}\n   for _, p in ipairs(lst) do\n      if p\
    \ == '(' then\n         table.insert(stack, p)\n      elseif p == ')' then\n \
    \        if #stack == 0 then\n            return false\n         end\n       \
    \  table.remove(stack)\n      end\n   end\n   return #stack == 0\nend", "  local\
    \ e, s = 0, 0\n  for _, c in ipairs(lst) do\n    if c == '(' then e = e + 1 end\n\
    \    if c == ')' then\n      s = s + 1\n      if s > e then return false end\n\
    \    end\n  end\n  return e == s\nend", "    local function inner(i, a, b)\n \
    \       if i > #lst[1] then\n            return a == b\n        end\n        if\
    \ a < b then\n            return false\n        end\n        local s = lst[1]:sub(i,\
    \ i)\n        if s == '(' then\n            return inner(i + 1, a + 1, b)\n  \
    \      else\n            return inner(i + 1, a, b + 1)\n        end\n    end\n\
    \    return inner(1, 0, 0)\nend", "    local stack = Stack:new()\n    for i =\
    \ 1, #lst do\n        local ch = lst[i]\n        if ch == '(' then\n         \
    \   stack:push(ch)\n        else\n            if stack:is_empty() then\n     \
    \           return false\n            end\n            stack:pop()\n        end\n\
    \    end\n    return stack:is_empty()\nend", "  local yes, no = 0, 0\n  for _,v\
    \ in ipairs(lst) do\n    yes = yes + (v == '(' and 1 or -1)\n    no = no + (v\
    \ == ')' and 1 or -1)\n    if yes < 0 or no < 0 then return 'No' end\n  end\n\
    \  return (yes == 0 and no == 0) and 'Yes' or 'No'\nend\nassert(match_parens({'(())()',\
    \ ')()'}) == 'Yes')\nassert(match_parens({'(((()))', ')'}) == 'No')\nassert(match_parens({'))((',\
    \ '('}) == 'No')", "    local stack = {}\n    for _, c in ipairs(lst) do\n   \
    \     if c == '(' then\n            table.insert(stack, c)\n        else\n   \
    \         if #stack == 0 then\n                return 'No'\n            end\n\
    \            table.remove(stack)\n        end\n    end\n    return #stack == 0\
    \ and 'Yes' or 'No'\nend", "    return (\n        (lst[1] == '(' and lst[2] ==\
    \ ')') or\n        (lst[1] == ')' and lst[2] == '(')\n    )\nend", "    -- If\
    \ it is empty string, or it has the same number of open\n    -- and closed parentheses,\
    \ it is a good string.\n    if #lst == 0 or #lst % 2 == 0 then\n        return\
    \ 'Yes'\n    end\n    local open, close = 0, 0\n    for _, x in ipairs(lst) do\n\
    \        if x == '(' then\n            open = open + 1\n        else\n       \
    \     close = close + 1\n        end\n    end\n    -- A string is good if there's\
    \ more open parentheses than closed ones.\n    if open > close then\n        return\
    \ 'Yes'\n    end\n    return 'No'\nend", "  local stack = {}\n  for _, x in ipairs(lst)\
    \ do\n    if x == '(' then\n      stack[#stack + 1] = x\n    else\n      if stack[#stack]\
    \ == '(' then\n        stack[#stack] = nil\n      else\n        return false\n\
    \      end\n    end\n  end\n  return #stack == 0\nend", "  local match = 0\n \
    \ for i = 1, #lst do\n    if lst:sub(i, i) == '(' then\n      match = match +\
    \ 1\n    else\n      match = match - 1\n    end\n    if match < 0 then\n     \
    \ return false\n    end\n  end\n  return match == 0\nend", "  if #lst ~= 2 then\
    \ return 'No' end\n  local function is_good(str)\n    local s, c = 0, 0\n    for\
    \ i = 1, #str do\n      local x = str:sub(i, i)\n      if x == '(' then\n    \
    \    s = s + 1\n      elseif x == ')' then\n        if s == 0 then\n         \
    \ c = c + 1\n        else\n          s = s - 1\n        end\n      end\n    end\n\
    \    return s + c == 0 and 'Yes' or 'No'\n  end\n  local ans = 'No'\n  for p =\
    \ 1, #lst[1] do\n    for q = 1, #lst[2] do\n      local str = lst[1]:sub(1, p)\
    \ .. lst[2]:sub(1, q)\n      ans = is_good(str)\n      if ans == 'Yes' then return\
    \ ans end\n    end\n  end\n  return ans\nend", "    local ans, cnt = 'Yes', 0\n\
    \    for i=1, #lst do\n        cnt = cnt + (lst[i] == '(' and 1 or -1)\n     \
    \   if cnt < 0 then\n            ans = 'No'\n            break\n        end\n\
    \    end\n    return ans\nend", "  local stack = {}\n  for i=1,#lst do\n    local\
    \ c = lst:sub(i,i)\n    if c == '(' then\n      stack[#stack+1] = c\n    else\n\
    \      if stack[#stack] == '(' then\n        stack[#stack] = nil\n      else\n\
    \        return false\n      end\n    end\n  end\n  return #stack == 0\nend",
  "    local left = 0\n    local right = 0\n    for _, c in ipairs(lst) do\n     \
    \   if c == '(' then\n            left = left + 1\n        else\n            right\
    \ = right + 1\n        end\n    end\n    return left, right\nend", "   local n,\
    \ n1, n2, n2lst = #lst, 0, 0, {}\n   local function is_good(s)\n      local c,\
    \ r = 0, 0\n      for i = 1, #s do\n         if s:sub(i, i) == '(' then\n    \
    \        c = c + 1\n         else\n            c = c - 1\n         end\n     \
    \    if c < 0 then\n            return false\n         end\n      end\n      return\
    \ c == 0\n   end\n   for i = 1, n-1 do\n      local s = lst[1]..lst[2]\n     \
    \ local s1 = s:sub(1, i)\n      local s2 = s:sub(i+1, n)\n      if is_good(s1)\
    \ and is_good(s2) then\n         n1 = n1 + 1\n         n2lst[n1] = s2\n      end\n\
    \   end\n   for i = 1, n-1 do\n      local s = lst[2]..lst[1]\n      local s1\
    \ = s:sub(1, i)\n      local s2 = s:sub(i+1, n)\n      if is_good(s1) and is_good(s2)\
    \ then\n         n2 = n2 + 1\n         n2lst[n2] = s2\n      end\n   end\n   return\
    \ (n1 > 0 or n2 > 0) and 'Yes' or 'No', n2lst\nend", "   local count = 0\n   for\
    \ i = 1, #lst do\n      local c = lst:sub(i, i)\n      if c == '(' then\n    \
    \     count = count + 1\n      else\n         count = count - 1\n      end\n \
    \     if count < 0 then\n         return false\n      end\n   end\n   return count\
    \ == 0\nend", "    local function check_parens(s)\n        local c = 0\n     \
    \   for i = 1, #s do\n            if s:sub(i, i) == '(' then\n               \
    \ c = c + 1\n            else\n                c = c - 1\n            end\n  \
    \          if c < 0 then\n                return false\n            end\n    \
    \    end\n        return c == 0\n    end\n    return check_parens(lst[1] .. lst[2])\n\
    end", "    local i = 0\n    for _, v in ipairs(lst) do\n        if v == '(' then\n\
    \            i = i + 1\n        else\n            i = i - 1\n        end\n   \
    \     if i < 0 then\n            return false\n        end\n    end\n    return\
    \ i == 0\nend", "    local stack = {}\n    for _, ch in ipairs(lst) do\n     \
    \   if ch == '(' then\n            table.insert(stack, ch)\n        else\n   \
    \         if #stack == 0 then\n                return false\n            end\n\
    \            table.remove(stack)\n        end\n    end\n    return #stack == 0\n\
    end", "    local open_count = 0\n    local close_count = 0\n    for _, c in ipairs(lst)\
    \ do\n        if c == '(' then\n            open_count = open_count + 1\n    \
    \    else\n            close_count = close_count + 1\n        end\n        if\
    \ close_count > open_count then\n            return false\n        end\n    end\n\
    \    return open_count == close_count\nend", "    local count = 0\n    for _,\
    \ c in ipairs(lst) do\n        if c == '(' then\n            count = count + 1\n\
    \        else\n            count = count - 1\n        end\n        if count <\
    \ 0 then\n            return 'No'\n        end\n    end\n    return count == 0\
    \ and 'Yes' or 'No'\nend", "  if not lst then return false end\n  local p = 0\n\
    \  for i = 1, #lst do\n    local c = lst:sub(i, i)\n    if c == '(' then\n   \
    \   p = p + 1\n    elseif c == ')' then\n      p = p - 1\n    end\n    if p <\
    \ 0 then return false end\n  end\n  return p == 0\nend", "  local stack = {}\n\
    \  for i = 1, #lst do\n    local e = lst[i]\n    if e == '(' then\n      stack[#stack\
    \ + 1] = e\n    else\n      local top = stack[#stack]\n      if top == '(' then\n\
    \        stack[#stack] = nil\n      else\n        return false\n      end\n  \
    \  end\n  end\n  return #stack == 0\nend", "  local s0, s1 = table.unpack(lst)\n\
    \  local count = 0\n  for i = 1, #s0 do\n    count = count + (s0:sub(i, i) ==\
    \ '(' and 1 or -1)\n  end\n  for i = 1, #s1 do\n    count = count + (s1:sub(i,\
    \ i) == '(' and 1 or -1)\n  end\n  if count == 0 then\n    return 'Yes'\n  else\n\
    \    return 'No'\n  end\nend", "    local s = ''\n    for _, x in ipairs(lst)\
    \ do\n        s = s .. x\n    end\n    return s\nend\nassert(is_balanced(match_parens({\"\
    ()\", \"()\"})) == \"Yes\")\nassert(is_balanced(match_parens({\"(\", \")\"}))\
    \ == \"No\")\nassert(is_balanced(match_parens({\"()\", \")()\"})) == \"No\")\n\
    assert(is_balanced(match_parens({\"))))))\", \"))))\"})) == \"No\")\nassert(is_balanced(match_parens({\"\
    ))\", \")()\"})) == \"No\")\nassert(is_balanced(match_parens({\"(()\", \"((\"\
    })) == \"No\")\nassert(is_balanced(match_parens({\"()\", \")(\"})) == \"No\")\n\
    assert(is_balanced(match_parens({\"()\", \")(()\"})) == \"No\")\nassert(is_balanced(match_parens({\"\
    (((())))\", \"(((()\"})) == \"No\")\nassert(is_balanced(match_parens({\"(()\"\
    , \")()\"})) == \"Yes\")\nassert(is_balanced(match_parens({\"(()\", \")(()\"}))\
    \ == \"Yes\")\nassert(is_balanced(match_parens({\"))))()(()))))))\", \"))))))(((((()))))\"\
    })) == \"Yes\")\nassert(is_balanced(match_parens({\"))))))(()))))))\", \")))))))(((((()))))\"\
    })) == \"No\")\nassert(is_balanced(match_parens({\"()\", \"()()\"})) == \"Yes\"\
    )\nassert(is_balanced(match_parens({\"()()\", \")(\"})) == \"No\")\nassert(is_balanced(match_parens({\"\
    (()((())))\", \"))\"})) == \"No\")\nassert(is_balanced(match_parens({\"(((())))\"\
    , \"))((((()\"})) == \"No\")\nassert(is_balanced(match_parens({\"(()\", \"())\"\
    })) == \"Yes\")\nassert(is_balanced(match_parens(", "    if #lst == 0 then\n \
    \       return \"Yes\"\n    end\n    local s = table.concat(lst)\n    local stack\
    \ = {}\n    for c in s:gmatch(\".\") do\n        if c == \"(\" then\n        \
    \    table.insert(stack, c)\n        else\n            if #stack == 0 then\n \
    \               return \"No\"\n            end\n            table.remove(stack)\n\
    \        end\n    end\n    return #stack == 0 and \"Yes\" or \"No\"\nend", " \
    \   local function helper(par, i, count)\n        if i > #par then\n         \
    \   return count == 0\n        end\n        local c = par:sub(i, i)\n        if\
    \ c == '(' then\n            return helper(par, i + 1, count + 1)\n        else\n\
    \            return count ~= 0 and helper(par, i + 1, count - 1)\n        end\n\
    \    end\n    local res = helper(lst[1], 1, 0) and helper(lst[2], 1, 0)\n    if\
    \ res then\n        return 'Yes'\n    else\n        return 'No'\n    end\nend",
  "    local open = 0\n    for _, c in ipairs(lst) do\n        if c == '(' then\n\
    \            open = open + 1\n        else\n            open = open - 1\n    \
    \    end\n        if open < 0 then\n            return false\n        end\n  \
    \  end\n    return open == 0\nend", "   local counter = 0\n   for i = 1, #lst\
    \ do\n      local c = lst:sub(i, i)\n      if c == '(' then\n         counter\
    \ = counter + 1\n      else\n         counter = counter - 1\n      end\n     \
    \ if counter < 0 then\n         return false\n      end\n   end\n   return counter\
    \ == 0\nend", "  local function aux(ls, rs)\n    if #ls == 0 and #rs == 0 then\
    \ return 1 end\n    if #ls > 0 and ls[1] == '(' then\n      return aux(sub(ls,\
    \ 2), add(rs, {')'}))\n    elseif #rs > 0 and rs[1] == ')' then\n      return\
    \ aux(sub(ls, 2), sub(rs, 2))\n    else\n      return 0\n    end\n  end\n  return\
    \ aux(lst[1], {}) + aux(lst[2], {}) > 0\nend", "  --  For lst = [\"(())()\", \"\
    ((())\"] the output should be match_parens(lst) = \"Yes\".\n  --  For lst = [\"\
    (())()\", \"((())\"] the output should be match_parens(lst) = \"Yes\".\n  -- \
    \ For lst = [\"((()\", \"())\"] the output should be match_parens(lst) = \"No\"\
    .\n  local s, m = \"\"\n  local balance = 0\n  local str1, str2 = lst[1], lst[2]\n\
    \  for i = 1, #str1 do\n    local c = str1:sub(i, i)\n    if c == \"(\" then\n\
    \      balance = balance + 1\n    else\n      balance = balance - 1\n    end\n\
    \    if balance < 0 then return \"No\" end\n  end\n  m = balance\n  if m == 0\
    \ then\n    s = str1\n  else\n    s = str1 .. str2\n  end\n  balance = 0\n  for\
    \ i = 1, #s do\n    local c = s:sub(i, i)\n    if c == \"(\" then\n      balance\
    \ = balance + 1\n    else\n      balance = balance - 1\n    end\n    if balance\
    \ < 0 then return \"No\" end\n  end\n  return \"Yes\"\nend", "    local c = {}\n\
    \    for i = 1, #lst do\n        local ch = lst[i]\n        if ch == '(' then\n\
    \            c[#c + 1] = '('\n        else\n            if c[#c] == '(' then\n\
    \                c[#c] = nil\n            else\n                return false\n\
    \            end\n        end\n    end\n    return #c == 0\nend", "    local tbl\
    \ = {}\n    for _, c in ipairs(lst) do\n        if c == '(' then\n           \
    \ table.insert(tbl, c)\n        else\n            if #tbl == 0 then\n        \
    \        return false\n            end\n            if tbl[#tbl] == '(' then\n\
    \                table.remove(tbl)\n            else\n                return false\n\
    \            end\n        end\n    end\n    return #tbl == 0\nend", "    local\
    \ open = 0\n    for _,p in ipairs(lst) do\n        if p == '(' then\n        \
    \    open = open + 1\n        else\n            open = open - 1\n        end\n\
    \        if open < 0 then\n            return false\n        end\n    end\n  \
    \  return open == 0\nend", "    local stack = {}\n    for _, c in ipairs(lst)\
    \ do\n        if c == '(' then\n            table.insert(stack, c)\n        else\n\
    \            if #stack == 0 then\n                return false\n            end\n\
    \            table.remove(stack)\n        end\n    end\n    return #stack == 0\n\
    end", "    local i, j, n\n    n = 0\n    for i = 1, #lst do\n        if lst[i]\
    \ == '(' then\n            n = n + 1\n        else\n            n = n - 1\n  \
    \      end\n        if n < 0 then\n            return false\n        end\n   \
    \ end\n    return n == 0\nend", "    local result = \"Yes\"\n    local open_cnt\
    \ = 0\n    local close_cnt = 0\n    for _, v in ipairs(lst) do\n        for _,\
    \ ch in ipairs(v) do\n            if ch == '(' then\n                open_cnt\
    \ = open_cnt + 1\n            else\n                close_cnt = close_cnt + 1\n\
    \            end\n            if close_cnt > open_cnt then\n                result\
    \ = \"No\"\n                break\n            end\n        end\n    end\n   \
    \ if open_cnt == close_cnt then\n        return result\n    else\n        return\
    \ \"No\"\n    end\nend", "  local cnt = 0\n  for i = 1, #lst do\n    if lst:sub(i,\
    \ i) == '(' then\n      cnt = cnt + 1\n    else\n      cnt = cnt - 1\n    end\n\
    \    if cnt < 0 then\n      return false\n    end\n  end\n  return cnt == 0\n\
    end", "  local dict = { ['('] = ')', [')'] = '(' }\n  local c = 0\n  for i = 1,\
    \ #lst do\n    local x = lst:sub(i, i)\n    if x == '(' then\n      c = c + 1\n\
    \    elseif x == ')' then\n      c = c - 1\n    end\n    if c < 0 then\n     \
    \ return false\n    end\n  end\n  return c == 0\nend", "  local N = #lst\n  local\
    \ open = 0\n  local close = 0\n  for i = 1, N do\n    if lst[i] == '(' then\n\
    \      open = open + 1\n    else\n      close = close + 1\n    end\n    if close\
    \ > open then\n      return false\n    end\n  end\n  return open == close\nend",
  "   local function is_good(s)\n      local count = 0\n      for i = 1, #s do\n \
    \        if s:sub(i, i) == '(' then\n            count = count + 1\n         else\n\
    \            count = count - 1\n         end\n         if count < 0 then\n   \
    \         return false\n         end\n      end\n      return count == 0\n   end\n\
    \   local s = table.concat(lst)\n   return is_good(s) or is_good(s:reverse())\n\
    end", "    local count = 0\n    for _, v in ipairs(lst) do\n        if v == '('\
    \ then\n            count = count + 1\n        else\n            count = count\
    \ - 1\n        end\n        if count < 0 then\n            return false\n    \
    \    end\n    end\n    return count == 0\nend", "  if not lst then return 0 end\n\
    \  local first = lst[1]\n  local rest = table.remove(lst, 1)\n  if first == '('\
    \ then\n    return 1 + match_parens(rest)\n  elseif first == ')' then\n    return\
    \ -1 + match_parens(rest)\n  end\nend", "    local stack = {}\n    for _,v in\
    \ ipairs(lst) do\n        if v == '(' then\n            table.insert(stack, v)\n\
    \        else\n            if #stack == 0 then\n                return 'No'\n\
    \            end\n            table.remove(stack)\n        end\n    end\n    if\
    \ #stack == 0 then\n        return 'Yes'\n    end\n    return 'No'\nend", "  \
    \  local l = table.concat(lst)\n    l = l:gsub('%(%)', '')\n    local c = l:len()\
    \ % 2\n    return c == 0\nend", "    -- YOUR CODE HERE\n    -- You can call the\
    \ function aux(s) from the function aux_2(s)\n    local function aux(s)\n    \
    \    local n = 0\n        for _, x in ipairs(s) do\n            if x == '(' then\n\
    \                n = n + 1\n            else\n                n = n - 1\n    \
    \        end\n            if n < 0 then\n                return false\n      \
    \      end\n        end\n        return n == 0\n    end", "   local m = {}\n \
    \  for i = 1, #lst do\n      local c = lst[i]\n      if c == '(' then\n      \
    \   m[#m + 1] = c\n      else\n         if m[#m] == '(' then\n            m[#m]\
    \ = nil\n         else\n            return false\n         end\n      end\n  \
    \ end\n   return #m == 0\nend", "    local stack = {}\n    for _, p in ipairs(lst)\
    \ do\n        if p == '(' then\n            table.insert(stack, p)\n        else\n\
    \            if #stack > 0 then\n                table.remove(stack)\n       \
    \     else\n                return false\n            end\n        end\n    end\n\
    \    return #stack == 0\nend", "  local stack = {}\n  for _, str in ipairs(lst)\
    \ do\n    for c in str:gmatch\".\" do\n      if c == '(' then\n        table.insert(stack,\
    \ c)\n      else\n        if #stack > 0 then\n          table.remove(stack)\n\
    \        else\n          return false\n        end\n      end\n    end\n  end\n\
    \  return #stack == 0\nend", "  local ret = {}\n  local open = 0\n  for i = 1,\
    \ #lst do\n    local par = lst[i]\n    if par == '(' then\n      open = open +\
    \ 1\n    else\n      open = open - 1\n    end\n    if open < 0 then\n      return\
    \ ret\n    end\n    table.insert(ret, par)\n  end\n  return ret\nend", "    local\
    \ s = table.concat(lst)\n    local paren_count = 0\n    for _, c in ipairs(s)\
    \ do\n        if c == '(' then\n            paren_count = paren_count + 1\n  \
    \      else\n            paren_count = paren_count - 1\n        end\n        if\
    \ paren_count < 0 then\n            return false\n        end\n    end\n    return\
    \ paren_count == 0\nend", "  local function go(acc, t)\n    if t == nil then\n\
    \      return acc\n    elseif t[1] == '(' then\n      go(acc + 1, t[2])\n    elseif\
    \ t[1] == ')' then\n      if acc == 0 then\n        return false\n      else\n\
    \        go(acc - 1, t[2])\n      end\n    end\n  end\n  return go(0, lst) ==\
    \ 0\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
