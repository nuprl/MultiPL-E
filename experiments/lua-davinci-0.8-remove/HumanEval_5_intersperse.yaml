name: HumanEval_5_intersperse
language: lua
prompt: "-- Insert a number 'delimeter' between every two consecutive elements of\
  \ input list `numbers'\nlocal function intersperse(numbers, delimeter)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = intersperse\n\
  \    lu.assertEquals(candidate({}, 7), {})\n    lu.assertEquals(candidate({5, 6,\
  \ 3, 2}, 8), {5, 8, 6, 8, 3, 8, 2})\n    lu.assertEquals(candidate({2, 2, 2}, 2),\
  \ {2, 2, 2, 2, 2})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local results = {}\n  for index,number in ipairs(numbers) do\n  \
    \  results[#results+1] = number\n    if index ~= #numbers then\n      results[#results+1]\
    \ = delimeter\n    end\n  end\n  return results\nend", "  local acc = {}\n  local\
    \ len = #numbers\n  for i = 1, len - 1 do\n    local str = tostring(numbers[i])\n\
    \    if i > 1 then\n      table.insert(acc, delimeter)\n    end\n    table.insert(acc,\
    \ str)\n  end\n  table.insert(acc, tostring(numbers[len]))\n  return table.concat(acc)\n\
    end", "    if #numbers < 2 then\n        return numbers\n    end\n    local output\
    \ = {}\n    for i = 1, #numbers - 1 do\n        table.insert(output, numbers[i])\n\
    \        table.insert(output, delimeter)\n    end\n    table.insert(output, numbers[#numbers])\n\
    \    return output\nend", "    local res = {}\n    for i = 1, #numbers do\n  \
    \      res[2 * i - 1] = numbers[i]\n        res[2 * i] = delimeter\n    end\n\
    \    res[#res] = nil\n    return res\nend", "\tlocal result = {}\n\tfor i = 1,\
    \ #numbers - 1 do\n\t\tresult[#result + 1] = numbers[i]\n\t\tresult[#result +\
    \ 1] = delimeter\n\tend\n\tresult[#result + 1] = numbers[#numbers]\n\treturn result\n\
    end", "\tlocal newNumbers = {}\n\tfor i = 1, #numbers-1 do\n\t\ttable.insert(newNumbers,\
    \ numbers[i])\n\t\ttable.insert(newNumbers, delimeter)\n\tend\n\ttable.insert(newNumbers,\
    \ numbers[#numbers])\n\treturn newNumbers\nend", "  local result = { numbers[1]\
    \ }\n  for i = 2, #numbers do\n    table.insert(result, delimeter)\n    table.insert(result,\
    \ numbers[i])\n  end\n  return result\nend", "    local buffer = {}\n    for i\
    \ = 1, #numbers - 1 do\n        buffer[#buffer + 1] = numbers[i]\n        buffer[#buffer\
    \ + 1] = delimeter\n    end\n    buffer[#buffer + 1] = numbers[#numbers]\n   \
    \ return buffer\nend", "    local list = {}\n    for i = 1, #numbers do\n    \
    \    list[#list + 1] = numbers[i]\n        if i ~= #numbers then\n           \
    \ list[#list + 1] = delimeter\n        end\n    end\n    return list\nend", " \
    \   for i = #numbers, 1, -1 do\n        table.insert(numbers, i, delimeter)\n\
    \    end\n    return numbers\nend", "    local result = {}\n    local length =\
    \ #numbers\n    for i = 1, length - 1 do\n        table.insert(result, numbers[i])\n\
    \        table.insert(result, delimeter)\n    end\n    table.insert(result, numbers[length])\n\
    \    return result\nend", "    local interspersed = {}\n    for i, num in ipairs(numbers)\
    \ do\n        interspersed[#interspersed + 1] = num\n        if i < #numbers then\n\
    \            interspersed[#interspersed + 1] = delimeter\n        end\n    end\n\
    \    return interspersed\nend", "  local result = {}\n  for i = 1, #numbers do\n\
    \    result[i * 2 - 1] = numbers[i]\n    result[i * 2] = delimeter\n  end\n  table.remove(result)\n\
    \  return result\nend", "\tlocal a, b, c = nil, nil, nil\n\tif (type(numbers)\
    \ == \"table\") then\n\t\tb = #numbers\n\t\tc = numbers\n\telseif (type(numbers)\
    \ == \"string\") then\n\t\tnumbers = {strsplit(\"\\n\", numbers)}\n\t\tb = #numbers\n\
    \t\tc = numbers\n\telseif (type(numbers) == \"number\") then\n\t\tb = 1\n\t\t\
    c = {numbers}\n\tend\n\tif (b == 0) then\n\t\treturn \"\"\n\telseif (b == 1) then\n\
    \t\treturn tostring(c[1])\n\telse\n\t\tfor i = 1, b do\n\t\t\tif (i == 1) then\n\
    \t\t\t\ta = tostring(c[i])\n\t\t\telse\n\t\t\t\ta = a .. delimeter .. tostring(c[i])\n\
    \t\t\tend\n\t\tend\n\t\treturn a\n\tend\nend", "\tif #numbers == 0 then\n\t\t\
    return \"\"\n\telseif #numbers == 1 then\n\t\treturn numbers[1]\n\telse\n\t\t\
    local parts = {}\n\t\tlocal last = #numbers\n\t\tfor i, number in ipairs(numbers)\
    \ do\n\t\t\tparts[#parts + 1] = number\n\t\t\tif i ~= last then\n\t\t\t\tparts[#parts\
    \ + 1] = delimeter\n\t\t\tend\n\t\tend\n\t\treturn table.concat(parts)\n\tend\n\
    end", "  local result = {numbers[1]}\n  for i = 2, #numbers do\n    table.insert(result,\
    \ delimeter)\n    table.insert(result, numbers[i])\n  end\n  return result\nend",
  "\tlocal result = {}\n\tfor i, num in ipairs(numbers) do\n\t\ttable.insert(result,\
    \ num)\n\t\tif i < #numbers then\n\t\t\ttable.insert(result, delimeter)\n\t\t\
    end\n\tend\n\treturn result\nend", "  local v = {}\n  local k = 1\n  for i = 1,\
    \ #numbers - 1 do\n    v[k] = numbers[i]\n    v[k + 1] = delimeter\n    k = k\
    \ + 2\n  end\n  v[k] = numbers[#numbers]\n  return v\nend", "    if #numbers <=\
    \ 1 then\n        return numbers\n    end\n    local result = {}\n    for i =\
    \ 1, #numbers - 1 do\n        result[#result + 1] = numbers[i]\n        result[#result\
    \ + 1] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n   \
    \ return result\nend", "    local result = {}\n    local first  = true\n    for\
    \ _, num in ipairs(numbers) do\n        if first then\n            first = false\n\
    \        else\n            table.insert(result, delimeter)\n        end\n    \
    \    table.insert(result, num)\n    end\n    return result\nend", "\tlocal result\
    \ = {}\n\tlocal sep_inserted = false\n\tfor i = 1, #numbers do\n\t\tresult[#result\
    \ + 1] = numbers[i]\n\t\tif i < #numbers then\n\t\t\tif numbers[i] ~= numbers[i\
    \ + 1] then\n\t\t\t\tresult[#result + 1] = delimeter\n\t\t\t\tsep_inserted = true\n\
    \t\t\telse\n\t\t\t\tsep_inserted = false\n\t\t\tend\n\t\tend\n\tend\n\tif not\
    \ sep_inserted then\n\t\tresult[#result] = nil\n\tend\n\treturn result\nend",
  "  local result = {}\n  for _, n in ipairs(numbers) do\n    table.insert(result,\
    \ n)\n    table.insert(result, delimeter)\n  end\n  table.remove(result)\n  return\
    \ result\nend", "\tlocal result = {}\n\tfor i = 1, #numbers do\n\t\ttable.insert(result,\
    \ numbers[i])\n\t\tif i < #numbers then\n\t\t\ttable.insert(result, delimeter)\n\
    \t\tend\n\tend\n\treturn result\nend", "    local new_list = {}\n    local numbers_count\
    \ = #numbers\n    for i, number in ipairs(numbers) do\n        new_list[i] = number\n\
    \        if i ~= numbers_count then\n            new_list[i + 1] = delimeter\n\
    \        end\n    end\n    return new_list\nend", "    local output = {}\n   \
    \ for i = 1, #numbers do\n        output[#output + 1] = numbers[i]\n        if\
    \ i ~= #numbers then\n            output[#output + 1] = delimeter\n        end\n\
    \    end\n    return output\nend", "  local result = {}\n  for i = 1, #numbers\
    \ - 1 do\n    table.insert(result, numbers[i])\n    table.insert(result, delimeter)\n\
    \  end\n  table.insert(result, numbers[#numbers])\n  return result\nend", "  local\
    \ result = {}\n  for i = 1, #numbers - 1 do\n    result[i * 2 - 1] = numbers[i]\n\
    \    result[i * 2] = delimeter\n  end\n  result[#result] = numbers[#numbers]\n\
    \  return result\nend", "\tlocal result = {}\n\tfor i = 1, #numbers do\n\t\tresult[#result\
    \ + 1] = numbers[i]\n\t\tif i < #numbers then\n\t\t\tresult[#result + 1] = delimeter\n\
    \t\tend\n\tend\n\treturn result\nend", "\tlocal result = {}\n\tlocal n = #numbers\n\
    \tfor i = 1, n - 1 do\n\t\tresult[#result + 1] = numbers[i]\n\t\tresult[#result\
    \ + 1] = delimeter\n\tend\n\tresult[#result + 1] = numbers[n]\n\treturn result\n\
    end", "    local output = {}\n    for i = 1, #numbers - 1 do\n        output[#output\
    \ + 1] = numbers[i]\n        output[#output + 1] = delimeter\n    end\n    output[#output\
    \ + 1] = numbers[#numbers]\n    return output\nend", "  local r = {}\n  for i,\
    \ v in ipairs(numbers) do\n    r[#r+1] = v\n    if i < #numbers then\n      r[#r+1]\
    \ = delimeter\n    end\n  end\n  return r\nend", "    local result = {}\n    local\
    \ n = #numbers\n    if n == 0 then\n        return result\n    end\n    result[1]\
    \ = numbers[1]\n    for i = 2, n do\n        result[(i - 1) * 2] = delimeter\n\
    \        result[(i - 1) * 2 + 1] = numbers[i]\n    end\n    return result\nend",
  "    local result = {}\n    local index = 1\n    for i = 1, #numbers do\n      \
    \  if numbers[i] ~= 0 then\n            result[index] = numbers[i]\n         \
    \   index = index + 1\n            if i ~= #numbers then\n                result[index]\
    \ = delimeter\n                index = index + 1\n            end\n        end\n\
    \    end\n    return result\nend", "    local result = {}\n    for i = 1, #numbers\
    \ do\n        table.insert(result, numbers[i])\n        if i ~= #numbers then\n\
    \            table.insert(result, delimeter)\n        end\n    end\n    return\
    \ result\nend", "\tlocal new_list = {}\n\tfor i,v in ipairs(numbers) do\n\t\t\
    if i > 1 then\n\t\t\tnew_list[#new_list+1] = delimeter\n\t\tend\n\t\tnew_list[#new_list+1]\
    \ = v\n\tend\n\treturn new_list\nend", "    local count = #numbers\n    if count\
    \ == 0 then\n        return {}\n    elseif count == 1 then\n        return numbers\n\
    \    else\n        local result = {}\n        for i = 1, count - 1 do\n      \
    \      table.insert(result, numbers[i])\n            table.insert(result, delimeter)\n\
    \        end\n        table.insert(result, numbers[count])\n        return result\n\
    \    end\nend", "\tlocal ret = {}\n\tlocal last = 1\n\tfor i = 1, #numbers do\n\
    \t\tif i % 2 == 0 then\n\t\t\ttable.insert(ret, numbers[i - 1])\n\t\t\ttable.insert(ret,\
    \ delimeter)\n\t\telse\n\t\t\ttable.insert(ret, numbers[i])\n\t\tend\n\tend\n\t\
    return ret\nend", "    if not numbers then return end\n    if not delimeter then\
    \ delimeter = ' ' end\n    local t = {}\n    for i = 1, #numbers do\n        local\
    \ v = numbers[i]\n        if v then t[#t+1] = v end\n        if i < #numbers then\
    \ t[#t+1] = delimeter end\n    end\n    return t\nend", "    local result = {}\n\
    \    for i, x in ipairs(numbers) do\n        table.insert(result, x)\n       \
    \ if i < #numbers then\n            table.insert(result, delimeter)\n        end\n\
    \    end\n    return result\nend", "\tlocal result = {}\n\tfor i = 1, #numbers\
    \ do\n\t\ttable.insert(result, numbers[i])\n\t\tif i < #numbers then\n\t\t\ttable.insert(result,\
    \ delimeter)\n\t\tend\n\tend\n\treturn result\nend", "\tlocal result = {}\n\t\
    local count = #numbers\n\tfor i = 1, count-1 do\n\t\tresult[#result+1] = numbers[i]\n\
    \t\tresult[#result+1] = delimeter\n\tend\n\tresult[#result+1] = numbers[count]\n\
    \treturn result\nend", "    local list = {numbers[1]}\n    for i = 2, #numbers\
    \ do\n        table.insert(list, delimeter)\n        table.insert(list, numbers[i])\n\
    \    end\n    return list\nend", "    local result = {}\n    for i = 1, #numbers\
    \ - 1 do\n        table.insert(result, numbers[i])\n        table.insert(result,\
    \ delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n    return\
    \ result\nend", "    if #numbers == 0 then\n        return numbers\n    elseif\
    \ #numbers == 1 then\n        return numbers\n    else\n        local out = {}\n\
    \        for i = 1, #numbers - 1 do\n            out[i * 2 - 1] = numbers[i]\n\
    \            out[i * 2] = delimeter\n        end\n        out[#out] = numbers[#numbers]\n\
    \        return out\n    end\nend", "    local results = {}\n    local i = 1\n\
    \    while numbers[i] do\n        results[#results + 1] = numbers[i]\n       \
    \ if numbers[i + 1] then\n            results[#results + 1] = delimeter\n    \
    \    end\n        i = i + 1\n    end\n    return results\nend", "    local result\
    \ = {}\n    for i,v in ipairs(numbers) do\n        result[#result+1] = v\n   \
    \     if i < #numbers then\n            result[#result+1] = delimeter\n      \
    \  end\n    end\n    return result\nend", "  local result = {}\n  for i = 1, #numbers\
    \ - 1 do\n    table.insert(result, numbers[i])\n    table.insert(result, delimeter)\n\
    \  end\n  table.insert(result, numbers[#numbers])\n  return result\nend", "  local\
    \ ret = {}\n  for i,number in ipairs(numbers) do\n    table.insert(ret, number)\n\
    \    if i ~= #numbers then\n      table.insert(ret, delimeter)\n    end\n  end\n\
    \  return ret\nend", "\tlocal ret = {}\n\tfor i = 1, #numbers do\n\t\ttable.insert(ret,\
    \ numbers[i])\n\t\tif i ~= #numbers then\n\t\t\ttable.insert(ret, delimeter)\n\
    \t\tend\n\tend\n\treturn ret\nend", "    local out = {}\n    for i, num in ipairs(numbers)\
    \ do\n        if i > 1 then\n            out[#out + 1] = delimeter\n        end\n\
    \        out[#out + 1] = num\n    end\n    return out\nend", "\tlocal result =\
    \ {}\n\tfor i = 1, #numbers do\n\t\tresult[2 * i - 1] = numbers[i]\n\t\tresult[2\
    \ * i] = delimeter\n\tend\n\tresult[#result] = nil\n\treturn result\nend", " \
    \   local new_numbers = {}\n    local last_index = #numbers\n    for i = 1, last_index\
    \ do\n        new_numbers[i * 2 - 1] = numbers[i]\n        new_numbers[i * 2]\
    \ = delimeter\n    end\n    new_numbers[#new_numbers] = nil\n    return new_numbers\n\
    end", "\tlocal result = {}\n\t\n\tfor i, v in ipairs(numbers) do\n\t\tif (i ~=\
    \ 1) then\n\t\t\ttable.insert(result, delimeter)\n\t\tend\n\t\t\n\t\ttable.insert(result,\
    \ v)\n\tend\n\t\n\treturn result\nend", "\tlocal str = {}\n\tlocal n = #numbers\n\
    \tfor i = 1, n do\n\t\tstr[#str + 1] = numbers[i]\n\t\tif i < n then\n\t\t\tstr[#str\
    \ + 1] = delimeter\n\t\tend\n\tend\n\treturn table.concat(str)\nend", "    local\
    \ new = {}\n    for i, n in ipairs(numbers) do\n        new[#new + 1] = n\n  \
    \      if i ~= #numbers then\n            new[#new + 1] = delimeter\n        end\n\
    \    end\n    return new\nend", "  return list.map(util.merge,\n             \
    \     list.zip(numbers, util.repeat_elem(delimeter, list.len(numbers))))\nend",
  "\tlocal output = {}\n\tlocal last = #numbers\n\tfor i, v in ipairs(numbers) do\n\
    \t\toutput[i * 2 - 1] = v\n\t\tif i < last then\n\t\t\toutput[i * 2] = delimeter\n\
    \t\tend\n\tend\n\treturn output\nend", "    local result = {}\n    for i, number\
    \ in ipairs(numbers) do\n        table.insert(result, number)\n        if i <\
    \ #numbers then\n            table.insert(result, delimeter)\n        end\n  \
    \  end\n    return result\nend", "    if #numbers == 0 then\n        return \"\
    \"\n    elseif #numbers == 1 then\n        return numbers[1]\n    else\n     \
    \   local result = numbers[1]\n        for i = 2, #numbers do\n            result\
    \ = result .. delimeter .. numbers[i]\n        end\n        return result\n  \
    \  end\nend", "\tassert(type(numbers) == \"table\")\n\tlocal result = {}\n\tfor\
    \ i, number in ipairs(numbers) do\n\t\tresult[#result + 1] = number\n\t\tif i\
    \ < #numbers then\n\t\t\tresult[#result + 1] = delimeter\n\t\tend\n\tend\n\treturn\
    \ result\nend", "\tlocal str, num = {}, nil\n\tfor i, number in ipairs(numbers)\
    \ do\n\t\tif num then\n\t\t\tstr[#str + 1] = delimeter\n\t\tend\n\t\tstr[#str\
    \ + 1] = number\n\t\tnum = number\n\tend\n\treturn str\nend", "\tlocal result\
    \ = {}\n\tfor i = 1, #numbers do\n\t\ttable.insert(result, numbers[i])\n\t\tif\
    \ i < #numbers then\n\t\t\ttable.insert(result, delimeter)\n\t\tend\n\tend\n\t\
    return result\nend", "  local interspersed = {}\n  for i = 1, #numbers - 1 do\n\
    \    local first_number = numbers[i]\n    local second_number = numbers[i + 1]\n\
    \    if first_number < second_number then\n      interspersed[#interspersed +\
    \ 1] = first_number\n      interspersed[#interspersed + 1] = delimeter\n    else\n\
    \      interspersed[#interspersed + 1] = second_number\n      interspersed[#interspersed\
    \ + 1] = delimeter\n    end\n  end\n  interspersed[#interspersed + 1] = numbers[#numbers]\n\
    \  return interspersed\nend", "\t-- TODO: Sort out spaces?\n\tif #numbers > 1\
    \ then\n\t\tlocal output = {}\n\t\tfor i = 1, #numbers do\n\t\t\ttable.insert(output,\
    \ numbers[i])\n\t\t\tif i < #numbers then\n\t\t\t\ttable.insert(output, delimeter)\n\
    \t\t\tend\n\t\tend\n\t\treturn output\n\telse\n\t\treturn numbers\n\tend\nend",
  "\tlocal result = {}\n\tfor i = 1, #numbers - 1 do\n\t\tlocal number = numbers[i]\n\
    \t\ttable.insert(result, number)\n\t\ttable.insert(result, delimeter)\n\tend\n\
    \ttable.insert(result, numbers[#numbers])\n\treturn result\nend", "  if #numbers\
    \ == 0 then\n    return { }\n  elseif #numbers == 1 then\n    return numbers\n\
    \  else\n    local newNumbers = { }\n    for i = 1, #numbers - 1 do\n      table.insert(newNumbers,\
    \ numbers[i])\n      table.insert(newNumbers, delimeter)\n    end\n    table.insert(newNumbers,\
    \ numbers[#numbers])\n    return newNumbers\n  end\nend", "    assert(type(numbers)\
    \ == \"table\", \"argument 'numbers' to method 'intersperse' must be a table\"\
    )\n    assert(type(delimeter) == \"number\", \"argument 'delimeter' to method\
    \ 'intersperse' must be a number\")\n    local result = {}\n    for i = 1, #numbers\
    \ do\n        table.insert(result, numbers[i])\n        if i < #numbers then\n\
    \            table.insert(result, delimeter)\n        end\n    end\n    return\
    \ result\nend", "  local output = {}\n  for i, v in ipairs(numbers) do\n    table.insert(output,\
    \ v)\n    if i < #numbers then\n      table.insert(output, delimeter)\n    end\n\
    \  end\n  return output\nend", "  local result = {}\n  for i = 1, #numbers do\n\
    \    result[2 * i - 1] = numbers[i]\n    result[2 * i] = delimeter\n  end\n  result[#result]\
    \ = nil\n  return result\nend", "\tlocal result = {}\n\tlocal last = 0\n\tfor\
    \ _, number in ipairs(numbers) do\n\t\tif last ~= 0 then\n\t\t\ttable.insert(result,\
    \ delimeter)\n\t\tend\n\t\ttable.insert(result, number)\n\t\tlast = number\n\t\
    end\n\treturn result\nend", "  local str = {}\n  for i,v in ipairs(numbers) do\n\
    \    str[#str+1] = v\n    if i < #numbers then\n      str[#str+1] = delimeter\n\
    \    end\n  end\n  return str\nend", "  local interspersed = {}\n  for i = 1,\
    \ #numbers do\n    if i == 1 then\n      interspersed[i] = numbers[i]\n    else\n\
    \      interspersed[2*i-1] = delimeter\n      interspersed[2*i] = numbers[i]\n\
    \    end\n  end\n  return interspersed\nend", "  local str = tostring(numbers[1])\n\
    \  for i = 2, #numbers do\n    str = str .. delimeter .. tostring(numbers[i])\n\
    \  end\n  return str\nend", "  local result = {}\n  local max = #numbers\n  for\
    \ i = 1, max-1 do\n    result[2*i-1] = numbers[i]\n    result[2*i] = delimeter\n\
    \  end\n  result[2*max-1] = numbers[max]\n  return result\nend", "    local result\
    \ = {}\n    for i = 1, #numbers - 1 do\n        table.insert(result, numbers[i])\n\
    \        table.insert(result, delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n\
    \    return result\nend", "  local l = {}\n  for i, v in ipairs(numbers) do\n\
    \    l[i] = v\n    if i < #numbers then\n      l[i+1] = delimeter\n    end\n \
    \ end\n  return l\nend", "  local result = {}\n  local last_index = #numbers\n\
    \  for i, number in ipairs(numbers) do\n    table.insert(result, number)\n   \
    \ if i < last_index then\n      table.insert(result, delimeter)\n    end\n  end\n\
    \  return result\nend", "    assert(type(numbers) == \"table\")\n    assert(type(delimeter)\
    \ == \"number\")\n    local result = {}\n    for i = 1, #numbers do\n        if\
    \ i > 1 then\n            table.insert(result, delimeter)\n        end\n     \
    \   table.insert(result, numbers[i])\n    end\n    return result\nend", "    local\
    \ interspersed = {}\n    for i = 1, #numbers - 1 do\n        table.insert(interspersed,\
    \ numbers[i])\n        table.insert(interspersed, delimeter)\n    end\n    table.insert(interspersed,\
    \ numbers[#numbers])\n    return interspersed\nend", "    local result = {}\n\
    \    for i = 1, #numbers do\n        table.insert(result, numbers[i])\n      \
    \  if i ~= #numbers then\n            table.insert(result, delimeter)\n      \
    \  end\n    end\n    return result\nend", "    local list = {}\n    for i, number\
    \ in ipairs(numbers) do\n        table.insert(list, number)\n        if i < #numbers\
    \ then\n            table.insert(list, delimeter)\n        end\n    end\n    return\
    \ list\nend", "\tlocal result = {}\n\t\n\tfor i, number in ipairs(numbers) do\n\
    \t\ttable.insert(result, number)\n\t\tif i < #numbers then\n\t\t\ttable.insert(result,\
    \ delimeter)\n\t\tend\n\tend\n\t\n\treturn result\nend", "    local result = {\
    \ }\n    local delimeter = delimeter or 0\n    local prev = 0\n    for i, v in\
    \ ipairs(numbers) do\n        result[#result + 1] = (prev + v) / 2\n        result[#result\
    \ + 1] = v\n        prev = v\n    end\n    return result\nend", "  local last\
    \ = 0\n  local res = {}\n  for _, x in ipairs(numbers) do\n    if last == 0 then\n\
    \      res[#res + 1] = x\n    else\n      res[#res + 1] = delimeter\n      res[#res\
    \ + 1] = x\n    end\n    last = x\n  end\n  return res\nend", "    local result\
    \ = {numbers[1]}\n    for i = 2, #numbers do\n        table.insert(result, delimeter)\n\
    \        table.insert(result, numbers[i])\n    end\n    return result\nend", " \
    \   local result = {}\n    for i = 1, #numbers - 1 do\n        result[i] = numbers[i]\n\
    \        result[i + 1] = delimeter\n    end\n    result[#result] = numbers[#numbers]\n\
    \    return result\nend", "\tlocal result = {}\n\tfor i = 1, #numbers do\n\t\t\
    result[#result + 1] = numbers[i]\n\t\tif i < #numbers then\n\t\t\tresult[#result\
    \ + 1] = delimeter\n\t\tend\n\tend\n\treturn result\nend", "\tlocal result = {numbers[1]}\n\
    \tlocal n = 2\n\twhile n <= #numbers do\n\t\tresult[#result + 1] = delimeter\n\
    \t\tresult[#result + 1] = numbers[n]\n\t\tn = n + 1\n\tend\n\treturn result\n\
    end", "  local output = {}\n  for i, val in ipairs(numbers) do\n    output[i]\
    \ = val\n    output[i + 1] = delimeter\n  end\n  output[#output] = nil\n  return\
    \ output\nend", "  local output = { }\n  local num = #numbers\n  for i = 1, num\
    \ do\n    output[#output + 1] = numbers[i]\n    if i < num then\n      output[#output\
    \ + 1] = delimeter\n    end\n  end\n  return output\nend", "    local result =\
    \ {}\n    for i = 1, #numbers - 1 do\n        result[#result + 1] = numbers[i]\n\
    \        result[#result + 1] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n\
    \    return result\nend", "    local s = \"\"\n    for i, value in ipairs(numbers)\
    \ do\n        if (i > 1) then\n            s = s .. delimeter\n        end\n \
    \       s = s .. value\n    end\n    return s\nend", "    if #numbers == 0 then\n\
    \        return {}\n    elseif #numbers == 1 then\n        return numbers\n  \
    \  else\n        local result = {}\n        for i, v in ipairs(numbers) do\n \
    \           if i > 1 then\n                table.insert(result, delimeter)\n \
    \           end\n            table.insert(result, v)\n        end\n        return\
    \ result\n    end\nend", "\tlocal acc = {}\n\tif numbers[1] then\n\t\tacc[1] =\
    \ numbers[1]\n\t\tfor i = 2, #numbers do\n\t\t\tacc[#acc + 1] = delimeter\n\t\t\
    \tacc[#acc + 1] = numbers[i]\n\t\tend\n\tend\n\treturn acc\nend", "\tlocal result\
    \ = { numbers[1] }\n\tfor i = 2, #numbers do\n\t\ttable.insert(result, delimeter)\n\
    \t\ttable.insert(result, numbers[i])\n\tend\n\treturn result\nend", "  local result\
    \ = {}\n  for _, v in ipairs(numbers) do\n    result[#result + 1] = v\n    result[#result\
    \ + 1] = delimeter\n  end\n  result[#result] = nil -- removes trailing delimeter\n\
    \  return result\nend", "\tlocal result = {}\n\tlocal i = 1\n\twhile i <= #numbers\
    \ do\n\t\tresult[#result + 1] = numbers[i]\n\t\tresult[#result + 1] = delimeter\n\
    \t\ti = i + 1\n\tend\n\tresult[#result] = nil -- Remove last delimeter\n\treturn\
    \ result\nend", "    local result = {}\n    local n = #numbers\n    if n == 0\
    \ then\n        return result\n    end\n    result[1] = numbers[1]\n    for i\
    \ = 2, n do\n        result[2 * i - 1] = delimeter\n        result[2 * i] = numbers[i]\n\
    \    end\n    return result\nend", "    local ret = {}\n    for i = 1, #numbers\
    \ do\n        if i > 1 then\n            ret[#ret + 1] = delimeter\n        end\n\
    \        ret[#ret + 1] = numbers[i]\n    end\n    return ret\nend", "    local\
    \ result = {}\n    for i = 1, #numbers - 1 do\n        result[#result + 1] = numbers[i]\n\
    \        result[#result + 1] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n\
    \    return result\nend", "    assert(type(numbers) == \"table\", \"argument to\
    \ intersperse must be a table\")\n    assert(type(delimeter) == \"number\", \"\
    delimeter to intersperse must be a number\")\n    for i = #numbers, 2, -1 do\n\
    \        table.insert(numbers, i, delimeter)\n    end\n    return numbers\nend",
  "\tlocal result = {}\n\tfor i, v in ipairs(numbers) do\n\t\ttable.insert(result,\
    \ v)\n\t\tif i < #numbers then\n\t\t\ttable.insert(result, delimeter)\n\t\tend\n\
    \tend\n\treturn result\nend", "  local result = {}\n  for i, v in ipairs(numbers)\
    \ do\n    table.insert(result, v)\n    if i < #numbers then\n      table.insert(result,\
    \ delimeter)\n    end\n  end\n  return result\nend", "  local list = {}\n  for\
    \ i = 1, #numbers - 1 do\n    table.insert(list, numbers[i])\n    table.insert(list,\
    \ delimeter)\n  end\n  table.insert(list, numbers[#numbers])\n  return list\n\
    end", "  local result = {}\n  for i, number in ipairs(numbers) do\n    if i >\
    \ 1 then table.insert(result, delimeter) end\n    table.insert(result, number)\n\
    \  end\n  return result\nend", "    local newList = {}\n    for i, n in ipairs(numbers)\
    \ do\n        newList[#newList + 1] = n\n        if i < #numbers then\n      \
    \      newList[#newList + 1] = delimeter\n        end\n    end\n    return newList\n\
    end", "\tlocal separator = {delimeter}\n\tlocal result = {}\n\tfor i = 1, #numbers\
    \ - 1 do\n\t\ttable.insert(result, numbers[i])\n\t\ttable.insert(result, separator)\n\
    \tend\n\ttable.insert(result, numbers[#numbers])\n\treturn result\nend", "\tif\
    \ #numbers == 0 then\n\t\treturn {}\n\telseif #numbers == 1 then\n\t\treturn numbers\n\
    \telse\n\t\tlocal result = {}\n\t\tfor i, v in ipairs(numbers) do\n\t\t\tresult[i\
    \ * 2 - 1] = v\n\t\t\tresult[i * 2] = delimeter\n\t\tend\n\t\tresult[#result]\
    \ = nil\n\t\treturn result\n\tend\nend", "    local result = {}\n    for i = 1,\
    \ #numbers - 1 do\n        result[#result + 1] = numbers[i]\n        result[#result\
    \ + 1] = delimeter\n    end\n    result[#result + 1] = numbers[#numbers]\n   \
    \ return result\nend", "    local result = {}\n    for _, v in ipairs(numbers)\
    \ do\n        table.insert(result, v)\n        table.insert(result, delimeter)\n\
    \    end\n    table.remove(result) -- remove the last delimeter\n    return result\n\
    end", "    local result = {}\n    for i = 1, #numbers - 1 do\n        table.insert(result,\
    \ numbers[i])\n        table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ numbers[#numbers])\n    return result\nend", "\tlocal n = #numbers\n\tif n ==\
    \ 0 then\n\t\treturn numbers\n\telseif n == 1 then\n\t\treturn numbers[1]\n\t\
    else\n\t\tlocal new = {}\n\t\tfor i = 1, n - 1 do\n\t\t\tnew[2 * i - 1] = numbers[i]\n\
    \t\t\tnew[2 * i] = delimeter\n\t\tend\n\t\tnew[2 * n - 1] = numbers[n]\n\t\treturn\
    \ new\n\tend\nend", "\tlocal r = {numbers[1]}\n\tfor i = 2, #numbers do\n\t\t\
    r[#r + 1] = delimeter\n\t\tr[#r + 1] = numbers[i]\n\tend\n\treturn r\nend", " \
    \   local result = {}\n    for i, v in ipairs(numbers) do\n        if i > 1 then\n\
    \            result[#result + 1] = delimeter\n        end\n        result[#result\
    \ + 1] = v\n    end\n    return result\nend", "    local result = { }\n    for\
    \ i = 1, #numbers-1 do\n        result[#result+1] = numbers[i]\n        result[#result+1]\
    \ = delimeter\n    end\n    result[#result+1] = numbers[#numbers]\n    return\
    \ result\nend", "    local result = {}\n    for i = 1, #numbers do\n        table.insert(result,\
    \ numbers[i])\n        if i < #numbers then\n            table.insert(result,\
    \ delimeter)\n        end\n    end\n    return result\nend", "    local result\
    \ = {}\n    local i = 1\n    while i <= #numbers do\n        table.insert(result,\
    \ numbers[i])\n        if i ~= #numbers then\n            table.insert(result,\
    \ delimeter)\n        end\n        i = i + 1\n    end\n    return result\nend",
  "\tlocal n = #numbers\n\tif n < 2 then\n\t\treturn numbers\n\tend\n\t\n\tlocal result\
    \ = {numbers[1]}\n\tfor i = 2, n do\n\t\ttable.insert(result, delimeter)\n\t\t\
    table.insert(result, numbers[i])\n\tend\n\treturn result\nend", "  local result\
    \ = {}\n  for i = 1, #numbers - 1 do\n    result[#result + 1] = numbers[i]\n \
    \   result[#result + 1] = delimeter\n  end\n  result[#result + 1] = numbers[#numbers]\n\
    \  return result\nend", "\tlocal result = {}\n\tfor index, number in ipairs(numbers)\
    \ do\n\t\ttable.insert(result, number)\n\t\tif index ~= #numbers then\n\t\t\t\
    table.insert(result, delimeter)\n\t\tend\n\tend\n\treturn result\nend", "  local\
    \ result = {}\n  for i = 1, #numbers do\n    if i > 1 then\n      table.insert(result,\
    \ delimeter)\n    end\n    table.insert(result, numbers[i])\n  end\n  return result\n\
    end", "    local list = {}\n    for i = 1, #numbers do\n        list[#list + 1]\
    \ = numbers[i]\n        if i < #numbers then\n            list[#list + 1] = delimeter\n\
    \        end\n    end\n    return list\nend", "\tlocal result = {}\n\tfor i =\
    \ 1, #numbers do\n\t\ttable.insert(result, numbers[i])\n\t\tif i < #numbers then\n\
    \t\t\ttable.insert(result, delimeter)\n\t\tend\n\tend\n\treturn result\nend",
  "  if #numbers == 0 then\n    return {}\n  elseif #numbers == 1 then\n    return\
    \ numbers\n  else\n    return {numbers[1], delimeter, intersperse(table.slice(numbers,\
    \ 2), delimeter)}\n  end\nend", "  local list = {}\n  for i, number in ipairs(numbers)\
    \ do\n    table.insert(list, number)\n    if i < #numbers then\n      table.insert(list,\
    \ delimeter)\n    end\n  end\n  return list\nend", "    local result = {}\n  \
    \  for i = 1, #numbers - 1 do\n        table.insert(result, numbers[i])\n    \
    \    table.insert(result, delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n\
    \    return result\nend", "\tlocal out = {}\n\tfor i = 1, #numbers - 1 do\n\t\t\
    out[#out + 1] = numbers[i]\n\t\tout[#out + 1] = delimeter\n\tend\n\tout[#out +\
    \ 1] = numbers[#numbers]\n\treturn out\nend", "    local result = {}\n    for\
    \ i = 1, #numbers - 1 do\n        result[i * 2 - 1] = numbers[i]\n        result[i\
    \ * 2] = delimeter\n    end\n    result[#result] = numbers[#numbers]\n    return\
    \ result\nend", "    local result = {}\n    for i = 1, #numbers - 1 do\n     \
    \   result[#result + 1] = numbers[i]\n        result[#result + 1] = delimeter\n\
    \    end\n    result[#result + 1] = numbers[#numbers]\n    return result\nend",
  "    local result = {numbers[1]}\n    for i = 2, #numbers do\n        table.insert(result,\
    \ delimeter)\n        table.insert(result, numbers[i])\n    end\n    return result\n\
    end", "\tlocal result = {}\n\tfor i, number in ipairs(numbers) do\n\t\tresult[#result\
    \ + 1] = number\n\t\tif i < #numbers then\n\t\t\tresult[#result + 1] = delimeter\n\
    \t\tend\n\tend\n\treturn result\nend", "    local str = \"\"\n    for i = 1, #numbers\
    \ do\n        if i ~= 1 then\n            str = str .. delimeter\n        end\n\
    \        str = str .. numbers[i]\n    end\n    return str\nend", "  local result\
    \ = {}\n  local previous = nil\n  for _, number in ipairs(numbers) do\n    if\
    \ previous then\n      table.insert(result, previous)\n      table.insert(result,\
    \ delimeter)\n    end\n    previous = number\n  end\n  table.insert(result, previous)\n\
    \  return result\nend", "    local r = {}\n    for i = 1, #numbers - 1 do\n  \
    \      r[#r + 1] = numbers[i]\n        r[#r + 1] = delimeter\n    end\n    r[#r\
    \ + 1] = numbers[#numbers]\n    return r\nend", "    local s = \"\"\n    local\
    \ delim = \"\"\n    for _, number in ipairs(numbers) do\n        s = s .. delim\
    \ .. tostring(number)\n        delim = delimeter\n    end\n    return s\nend",
  "  local result = {}\n  for _, number in ipairs(numbers) do\n    if result[#result]\
    \ ~= nil then\n      table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ number)\n  end\n  return result\nend", "  assert(type(numbers) == 'table', \"\
    `numbers' must be a table!\")\n  assert(type(delimeter) == 'number', \"`delimeter'\
    \ must be a number!\")\n  local out = {}\n  for i = 1, #numbers - 1 do\n    out[#out\
    \ + 1] = numbers[i]\n    out[#out + 1] = delimeter\n  end\n  out[#out + 1] = numbers[#numbers]\n\
    \  return out\nend", "\tlocal result = {}\n\tfor i, number in ipairs(numbers)\
    \ do\n\t\ttable.insert(result, number)\n\t\tif i < #numbers then\n\t\t\ttable.insert(result,\
    \ delimeter)\n\t\tend\n\tend\n\treturn result\nend", "\tlocal table = {}\n\tlocal\
    \ temp\n\t\n\tif #numbers == 0 then\n\t\treturn \"\"\n\tend\n\t\n\ttemp = numbers[1]\n\
    \ttable[1] = temp\n\t\n\tfor i = 2, #numbers do\n\t\ttemp = numbers[i]\n\t\ttable[i*2\
    \ - 1] = delimeter\n\t\ttable[i*2] = temp\n\tend\n\t\n\treturn table\nend", "\t\
    local result = {}\n\tfor i = 1, #numbers - 1 do\n\t\tresult[i * 2 - 1] = numbers[i]\n\
    \t\tresult[i * 2] = delimeter\n\tend\n\tresult[#result] = numbers[#numbers]\n\t\
    return result\nend", "\tlocal result = {}\n\tfor i,v in ipairs(numbers) do\n\t\
    \tresult[i] = v\n\t\tif i ~= #numbers then\n\t\t\tresult[i+1] = delimeter\n\t\t\
    end\n\tend\n\treturn result\nend", "  local out = {}\n  for i = 1, #numbers -\
    \ 1 do\n    out[#out + 1] = numbers[i]\n    out[#out + 1] = delimeter\n  end\n\
    \  out[#out + 1] = numbers[#numbers]\n  return out\nend", "\tif #numbers == 0\
    \ then\n\t\treturn {}\n\telseif #numbers == 1 then\n\t\treturn numbers\n\telse\n\
    \t\tlocal result = {}\n\t\tlocal i = 1\n\t\tlocal last = #numbers\n\t\tfor _,v\
    \ in ipairs(numbers) do\n\t\t\tresult[i] = v\n\t\t\ti = i + 1\n\t\t\tif i <= last\
    \ then\n\t\t\t\tresult[i] = delimeter\n\t\t\t\ti = i + 1\n\t\t\tend\n\t\tend\n\
    \t\treturn result\n\tend\nend", "\tlocal output, index = {}, 1\n\tfor number in\
    \ ipairs(numbers) do\n\t\toutput[index], output[index + 1], index = number, delimeter,\
    \ index + 2\n\tend\n\treturn output\nend", "    local first = numbers[1]\n   \
    \ local arr = {first}\n    for i=2,#numbers do\n        local number = numbers[i]\n\
    \        table.insert(arr, delimeter)\n        table.insert(arr, number)\n   \
    \ end\n    return arr\nend", "    local list = {}\n    for index, number in ipairs(numbers)\
    \ do\n        table.insert(list, number)\n        if index < #numbers then\n \
    \           table.insert(list, delimeter)\n        end\n    end\n    return list\n\
    end", "  local result = {}\n  for i, n in ipairs(numbers) do\n    table.insert(result,\
    \ n)\n    if i < #numbers then\n      table.insert(result, delimeter)\n    end\n\
    \  end\n  return result\nend", "  local result = {}\n  for i = 1, #numbers - 1\
    \ do\n    table.insert(result, numbers[i])\n    table.insert(result, delimeter)\n\
    \  end\n  table.insert(result, numbers[#numbers])\n  return result\nend", "  \
    \  local result = {}\n    for i = 1, #numbers do\n        result[#result + 1]\
    \ = numbers[i]\n        if i < #numbers then\n            result[#result + 1]\
    \ = delimeter\n        end\n    end\n    return result\nend", "  local result\
    \ = {}\n  for i, v in ipairs(numbers) do\n    if i > 1 then table.insert(result,\
    \ delimeter) end\n    table.insert(result, v)\n  end\n  return result\nend", " \
    \   local result = {}\n    for i, v in ipairs(numbers) do\n        if i ~= 1 then\n\
    \            result[#result + 1] = delimeter\n        end\n        result[#result\
    \ + 1] = v\n    end\n    return result\nend", "    if #numbers == 0 then\n   \
    \     return {}\n    elseif #numbers == 1 then\n        return numbers\n    else\n\
    \        local result = {}\n        for i = 1, #numbers do\n            table.insert(result,\
    \ numbers[i])\n            if i ~= #numbers then\n                table.insert(result,\
    \ delimeter)\n            end\n        end\n        return result\n    end\nend",
  "  local result = { numbers[1] }\n  for i = 2, #numbers do\n    table.insert(result,\
    \ delimeter)\n    table.insert(result, numbers[i])\n  end\n  return result\nend",
  "    local result = {}\n    for i, num in ipairs(numbers) do\n        result[2 *\
    \ i - 1] = num\n        result[2 * i] = delimeter\n    end\n    result[#result]\
    \ = nil\n    return result\nend", "  local n = #numbers\n  local result = {}\n\
    \  for i = 1, n do\n    result[2*i-1] = numbers[i]\n    result[2*i] = delimeter\n\
    \  end\n  result[2*n] = nil\n  return result\nend", "  local t = {}\n  for i =\
    \ 1, #numbers do\n    if i > 1 then\n      t[#t + 1] = delimeter\n    end\n  \
    \  t[#t + 1] = numbers[i]\n  end\n  return t\nend", "\tlocal size = #numbers\n\
    \tlocal new_list = {}\n\t\n\tif size == 0 then\n\t\treturn new_list\n\tend\n\t\
    \n\tfor i = 1, size do\n\t\ttable.insert(new_list, numbers[i])\n\t\tif i ~= size\
    \ then\n\t\t\ttable.insert(new_list, delimeter)\n\t\tend\n\tend\n\t\n\treturn\
    \ new_list\nend", "  local output = {}\n  for i = 1, #numbers - 1 do\n    output[#output\
    \ + 1] = numbers[i]\n    output[#output + 1] = delimeter\n  end\n  output[#output\
    \ + 1] = numbers[#numbers]\n  return output\nend", "    assert(#numbers > 0)\n\
    \    return table.concat(map(numbers, function(i) return tostring(i) end), tostring(delimeter))\n\
    end", "    local list = {}\n    for i, number in ipairs(numbers) do\n        table.insert(list,\
    \ number)\n        if i < #numbers then\n            table.insert(list, delimeter)\n\
    \        end\n    end\n    return list\nend", "  local len = #numbers\n  if len\
    \ < 2 then\n    return numbers\n  end\n  local result = {numbers[1]}\n  for i\
    \ = 2, len - 1 do\n    table.insert(result, delimeter)\n    table.insert(result,\
    \ numbers[i])\n  end\n  table.insert(result, delimeter)\n  table.insert(result,\
    \ numbers[len])\n  return result\nend", "  local result = {}\n  for i, number\
    \ in ipairs(numbers) do\n    result[i] = number\n    result[i + 1] = delimeter\n\
    \  end\n  return result\nend", "  assert(numbers ~= nil, \"numbers cannot be nil\"\
    )\n  assert(delimeter ~= nil, \"delimeter cannot be nil\")\n  assert(type(numbers)\
    \ == \"table\", \"numbers should be of type table, got \" .. type(numbers))\n\
    \  assert(type(delimeter) == \"number\", \"delimeter should be of type number,\
    \ got \" .. type(delimeter))", "    local len = #numbers\n    local res = {numbers[1]}\n\
    \    for i = 2, len-1 do\n        res[#res+1] = delimeter\n        res[#res+1]\
    \ = numbers[i]\n    end\n    if len > 1 then\n        res[#res+1] = delimeter\n\
    \        res[#res+1] = numbers[len]\n    end\n    return res\nend", "    local\
    \ result = {}\n    local delimeter = delimeter or \",\"\n    for i, num in ipairs(numbers)\
    \ do\n        if i > 1 then table.insert(result, delimeter) end\n        table.insert(result,\
    \ num)\n    end\n    return result\nend", "    local n = #numbers\n    if n ==\
    \ 0 then\n        return {}\n    elseif n == 1 then\n        return numbers\n\
    \    else\n        local result = {}\n        for i = 1, n - 1 do\n          \
    \  table.insert(result, numbers[i])\n            table.insert(result, delimeter)\n\
    \        end\n        table.insert(result, numbers[n])\n        return result\n\
    \    end\nend", "    local result = {}\n    for i = 1, #numbers do\n        table.insert(result,\
    \ numbers[i])\n        if i ~= #numbers then\n            table.insert(result,\
    \ delimeter)\n        end\n    end\n    return result\nend", "    local last_index\
    \ = #numbers - 1\n    if last_index <= 0 then\n        return numbers\n    end\n\
    \    local result = {}\n    for i = 1, last_index do\n        table.insert(result,\
    \ numbers[i])\n        table.insert(result, delimeter)\n    end\n    table.insert(result,\
    \ numbers[last_index + 1])\n    return result\nend", "\tlocal result = {}\n\t\
    local first = true\n\tfor _, num in ipairs(numbers) do\n\t\tif first then\n\t\t\
    \tfirst = false\n\t\telse\n\t\t\ttable.insert(result, delimeter)\n\t\tend\n\t\t\
    table.insert(result, num)\n\tend\n\treturn result\nend", "  local list = {}\n\
    \  for i, number in ipairs(numbers) do\n    table.insert(list, number)\n    if\
    \ i < #numbers then\n      table.insert(list, delimeter)\n    end\n  end\n  return\
    \ list\nend", "  assert(type(numbers) == 'table', 'First parameter must be a table')\n\
    \  local function helper(last, rest)\n    if #rest == 0 then\n      return {}\n\
    \    else\n      return {last, delimeter} .. helper(rest[1], {select(2, unpack(rest))})\n\
    \    end\n  end\n  return helper(numbers[1], {select(2, unpack(numbers))})\nend",
  "\tlocal output = {}\n\tlocal i = 1\n\twhile i <= #numbers do\n\t\ttable.insert(output,\
    \ numbers[i])\n\t\ttable.insert(output, delimeter)\n\t\ti = i + 1\n\tend\n\treturn\
    \ output\nend", "    if not numbers or #numbers == 0 then\n        return {}\n\
    \    end\n    local result = {numbers[1]}\n    for i = 2, #numbers do\n      \
    \  table.insert(result, delimeter)\n        table.insert(result, numbers[i])\n\
    \    end\n    return result\nend", "  local out = {}\n  local k = 1\n  for i =\
    \ 1, #numbers do\n    out[k] = numbers[i]\n    out[k+1] = delimeter\n    k = k\
    \ + 2\n  end\n  out[#out] = nil\n  return out\nend", "    local result = { }\n\
    \    for i = 1, #numbers do\n        if i ~= 1 then table.insert(result, delimeter)\
    \ end\n        table.insert(result, numbers[i])\n    end\n    return result\n\
    end", "\tlocal result = {}\n\tfor i = 1, #numbers do\n\t\tresult[2 * i - 1] =\
    \ numbers[i]\n\t\tresult[2 * i] = delimeter\n\tend\n\treturn result\nend", " \
    \ local result = {}\n  for i = 1, #numbers - 1 do\n    table.insert(result, numbers[i])\n\
    \    table.insert(result, delimeter)\n  end\n  table.insert(result, numbers[#numbers])\n\
    \  return result\nend", "  local accumulated = {}\n  for i, number in ipairs(numbers)\
    \ do\n    if i > 1 then\n      table.insert(accumulated, delimeter)\n    end\n\
    \    table.insert(accumulated, number)\n  end\n  return accumulated\nend", "\t\
    local interspersed = {}\n\tfor i = 1, #numbers - 1 do\n\t\ttable.insert(interspersed,\
    \ numbers[i])\n\t\ttable.insert(interspersed, delimeter)\n\tend\n\tif #numbers\
    \ >= 1 then\n\t\ttable.insert(interspersed, numbers[#numbers])\n\tend\n\treturn\
    \ interspersed\nend", "\tlocal res = {}\n\tfor i = 1, #numbers - 1 do\n\t\tres[#res\
    \ + 1] = numbers[i]\n\t\tres[#res + 1] = delimeter\n\tend\n\tres[#res + 1] = numbers[#numbers]\n\
    \treturn res\nend", "    local result = {numbers[1]}\n    for i=2,#numbers do\n\
    \        table.insert(result, delimeter)\n        table.insert(result, numbers[i])\n\
    \    end\n    return result\nend", "\tlocal result = {}\n\tfor i, v in ipairs(numbers)\
    \ do\n\t\ttable.insert(result, v)\n\t\tif i < #numbers then\n\t\t\ttable.insert(result,\
    \ delimeter)\n\t\tend\n\tend\n\treturn result\nend", "\tlocal res = {}\n\tfor\
    \ i, num in ipairs(numbers) do\n\t\tres[i * 2 - 1] = num\n\t\tres[i * 2] = delimeter\n\
    \tend\n\tres[#res] = nil\n\treturn res\nend", "    local result = {}\n    for\
    \ i, number in ipairs(numbers) do\n        result[i * 2 - 1] = number\n      \
    \  result[i * 2] = delimeter\n    end\n    table.remove(result)\n    return result\n\
    end", "\tlocal newList = {}\n\tlocal i = 1\n\twhile i <= #numbers do\n\t\tnewList[#newList\
    \ + 1] = numbers[i]\n\t\tnewList[#newList + 1] = delimeter\n\t\ti = i + 1\n\t\
    end\n\tnewList[#newList] = nil\n\treturn newList\nend", "  local result = { numbers[1]\
    \ }\n  for i = 2, #numbers do\n    table.insert(result, delimeter)\n    table.insert(result,\
    \ numbers[i])\n  end\n  return result\nend", "  local acc = {}\n  for i, v in\
    \ ipairs(numbers) do\n    acc[#acc + 1] = v\n    if i < #numbers then\n      acc[#acc\
    \ + 1] = delimeter\n    end\n  end\n  return acc\nend", "    local new_numbers\
    \ = {}\n    for i = 1, #numbers - 1 do\n        new_numbers[#new_numbers + 1]\
    \ = numbers[i]\n        new_numbers[#new_numbers + 1] = delimeter\n    end\n \
    \   new_numbers[#new_numbers + 1] = numbers[#numbers]\n    return new_numbers\n\
    end", "  local result = {}\n  local insert = table.insert\n  for i = 1, #numbers\
    \ - 1 do\n    insert(result, numbers[i])\n    insert(result, delimeter)\n  end\n\
    \  insert(result, numbers[#numbers])\n  return result\nend", "    if #numbers\
    \ == 0 then\n        return {}\n    elseif #numbers == 1 then\n        return\
    \ numbers\n    else\n        local ret = {}\n        for i = 1, #numbers-1 do\n\
    \            ret[#ret+1] = numbers[i]\n            ret[#ret+1] = delimeter\n \
    \       end\n        ret[#ret+1] = numbers[#numbers]\n        return ret\n   \
    \ end\nend", "    local result = {}\n    for i = 1, #numbers do\n        table.insert(result,\
    \ numbers[i])\n        if i ~= #numbers then\n            table.insert(result,\
    \ delimeter)\n        end\n    end\n    return result\nend", "    local ret =\
    \ {}\n    for i = 1, #numbers do\n        if i == 1 then\n            ret[#ret\
    \ + 1] = numbers[i]\n        else\n            ret[#ret + 1] = delimeter\n   \
    \         ret[#ret + 1] = numbers[i]\n        end\n    end\n    return ret\nend",
  "    local i = 0\n    local result = {}\n    for _, number in ipairs(numbers) do\n\
    \        i = i + 1\n        result[i] = number\n        i = i + 1\n        result[i]\
    \ = delimeter\n    end\n    return result\nend", "  local result = {}\n  for i,\
    \ number in ipairs(numbers) do\n    if i ~= 1 then\n      table.insert(result,\
    \ delimeter)\n    end\n    table.insert(result, number)\n  end\n  return result\n\
    end", "    local result = {}\n    for i = 1, #numbers do\n        result[i * 2\
    \ - 1] = numbers[i]\n        result[i * 2] = delimeter\n    end\n    result[#result]\
    \ = nil -- remove last delimeter\n    return result\nend", "\tlocal result = {}\n\
    \tfor i = 1, #numbers - 1 do\n\t\tresult[#result + 1] = numbers[i]\n\t\tresult[#result\
    \ + 1] = delimeter\n\tend\n\tresult[#result + 1] = numbers[#numbers]\n\treturn\
    \ result\nend", "  local str = ''\n  for i, number in ipairs(numbers) do\n   \
    \ if i > 1 then\n      str = str .. delimeter\n    end\n    str = str .. number\n\
    \  end\n  return str\nend", "    local result = {}\n    for i = 1, #numbers -\
    \ 1 do\n        table.insert(result, numbers[i])\n        table.insert(result,\
    \ delimeter)\n    end\n    table.insert(result, numbers[#numbers])\n    return\
    \ result\nend", "    if #numbers < 2 then\n        return numbers\n    end\n \
    \   local new_table = {}\n    for i, v in ipairs(numbers) do\n        if i ~=\
    \ 1 then\n            new_table[#new_table + 1] = delimeter\n        end\n   \
    \     new_table[#new_table + 1] = v\n    end\n    return new_table\nend", "\t\
    local ret = {}\n\tfor i = 1, #numbers do\n\t\tif i > 1 then\n\t\t\tret[#ret +\
    \ 1] = delimeter\n\t\tend\n\t\tret[#ret + 1] = numbers[i]\n\tend\n\treturn ret\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
