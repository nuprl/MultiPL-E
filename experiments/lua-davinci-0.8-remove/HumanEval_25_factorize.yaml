name: HumanEval_25_factorize
language: lua
prompt: "-- Return list of prime factors of given integer in the order from smallest\
  \ to largest.\n-- Each of the factors should be listed number of times corresponding\
  \ to how many times it appeares in factorization.\n-- Input number should be equal\
  \ to the product of all factors\nlocal function factorize(n)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = factorize\n\
  \    lu.assertEquals(candidate(2), {2})\n    lu.assertEquals(candidate(4), {2, 2})\n\
  \    lu.assertEquals(candidate(8), {2, 2, 2})\n    lu.assertEquals(candidate(57),\
  \ {3, 19})\n    lu.assertEquals(candidate(3249), {3, 3, 19, 19})\n    lu.assertEquals(candidate(185193),\
  \ {3, 3, 3, 19, 19, 19})\n    lu.assertEquals(candidate(20577), {3, 19, 19, 19})\n\
  \    lu.assertEquals(candidate(18), {2, 3, 3})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal factors = {}\n\tlocal fac\n\tlocal i = 2\n\twhile n ~= 1 do\n\
    \t\tfac = 1\n\t\twhile n % i == 0 do\n\t\t\tfac = fac * i\n\t\t\tn = n / i\n\t\
    \tend\n\t\tif fac ~= 1 then\n\t\t\ttable.insert(factors, fac)\n\t\tend\n\t\ti\
    \ = i + 1\n\tend\n\treturn factors\nend", "  local result = {}\n  for k, v in\
    \ pairs(primfac(n)) do\n    for i = 1, v do\n      table.insert(result, k)\n \
    \   end\n  end\n  return result\nend", "  local divider = 2\n  local factors =\
    \ {}\n  local count = 0\n  while n ~= 1 do\n    if n % divider == 0 then\n   \
    \   count = count + 1\n      n = n / divider\n    else\n      if count > 0 then\n\
    \        table.insert(factors, {divider, count})\n      end\n      divider = divider\
    \ + 1\n      count = 0\n    end\n  end\n  table.insert(factors, {divider, count})\n\
    \  return factors\nend", "\tlocal factors = {}\n\t\n\t-- Remove any powers of\
    \ 2\n\twhile n % 2 == 0 do\n\t\tfactors[2] = (factors[2] or 0) + 1\n\t\tn = n\
    \ / 2\n\tend\n\t\n\t-- Remove any other factors\n\tfor i = 3, math.sqrt(n), 2\
    \ do\n\t\twhile n % i == 0 do\n\t\t\tfactors[i] = (factors[i] or 0) + 1\n\t\t\t\
    n = n / i\n\t\tend\n\tend\n\t\n\t-- If nothing left, n is prime\n\tif n > 2 then\n\
    \t\tfactors[n] = 1\n\tend\n\t\n\treturn factors\nend", "\tlocal primeFactors =\
    \ {}\n\t\n\t-- Insert prime factors of n to primeFactors using n as the starting\
    \ value for possible factors\n\twhile not(isPrime(n)) do\n\t\tlocal nextFactor\
    \ = getNextFactor(n)\n\t\ttable.insert(primeFactors, nextFactor)\n\t\tn = n /\
    \ nextFactor\n\tend\n\t\n\t-- Insert last prime factor\n\ttable.insert(primeFactors,\
    \ n)\n\t\n\treturn primeFactors\nend", "\tlocal factors = {}\n\tlocal d = 2\n\t\
    while n > 1 do\n\t\tlocal power = 0\n\t\twhile not (n % d > 0) do\n\t\t\tn = n\
    \ / d\n\t\t\tpower = power + 1\n\t\tend\n\t\tif power > 0 then\n\t\t\ttable.insert(factors,\
    \ {d, power})\n\t\tend\n\t\td = d + 1\n\tend\n\treturn factors\nend", "  local\
    \ factors = {}\n  local function factorize_helper(n, i)\n    if n == 1 then\n\
    \      return\n    end\n    while n % i == 0 do\n      table.insert(factors, i)\n\
    \      n = n / i\n    end\n    if n ~= 1 then\n      factorize_helper(n, i + 1)\n\
    \    end\n  end\n  factorize_helper(n, 2)\n  return factors\nend", "    if n <\
    \ 1 then return \"Number should be positive.\" end\n    local factors = {}\n \
    \   for i = 2, math.floor(math.sqrt(n)) do\n        while n % i == 0 do\n    \
    \        n = n / i\n            table.insert(factors, i)\n        end\n    end\n\
    \    if n > 1 then table.insert(factors, n) end\n    return factors\nend", " \
    \   local primes = math.primefactorize(n)\n    local factors = {}\n    for _,p\
    \ in ipairs(primes) do\n        table.insert(factors, p[1])\n        table.insert(factors,\
    \ p[2])\n    end\n    return factors\nend", "\tlocal factors = {}\n\tif n == 1\
    \ then return factors end\n\tlocal i = 2\n\twhile n ~= 1 do\n\t\tif n % i == 0\
    \ then\n\t\t\tn = n / i\n\t\t\ttable.insert(factors, i)\n\t\telse\n\t\t\ti = i\
    \ + 1\n\t\tend\n\tend\n\treturn factors\nend", "    local primeFactors = {}\n\
    \    local primes = {}\n    local d = 2\n    local nPrimes = 0\n    while n >\
    \ 1 do\n        while n % d == 0 do\n            if nPrimes == 0 or d ~= primes[nPrimes]\
    \ then\n                nPrimes = nPrimes + 1\n                primes[nPrimes]\
    \ = d\n            end\n            n = n / d\n        end\n        d = d + 1\n\
    \    end\n    local powers = {}\n    for i = 1, nPrimes do\n        powers[i]\
    \ = 0\n    end\n    for i = 1, nPrimes do\n        for j = 1, nPrimes do\n   \
    \         if i ~= j and primes[i] % primes[j] == 0 then\n                powers[i]\
    \ = powers[i] + 1\n            end\n        end\n    end\n    for i = 1, nPrimes\
    \ do\n        for j = 1, powers[i] do\n            primeFactors[#primeFactors\
    \ + 1] = primes[i]\n        end\n    end\n    return primeFactors\nend", "   \
    \ local factors = {}\n    local num = n\n    local i = 2\n    while num > 1 do\n\
    \        if num % i == 0 then\n            num = num / i\n            table.insert(factors,\
    \ i)\n        else\n            i = i + 1\n        end\n    end\n    return factors\n\
    end", "\tlocal factors = {}\n\tlocal d = 2\n\twhile n > 1 do\n\t\tlocal nd, c\
    \ = n / d, 0\n\t\twhile nd == math.floor(nd) do\n\t\t\tn, c = nd, c + 1\n\t\t\t\
    nd = n / d\n\t\tend\n\t\tif c > 0 then\n\t\t\tfactors[#factors + 1] = { d, c }\n\
    \t\tend\n\t\td = d + 1\n\tend\n\treturn factors\nend", "\tlocal result = {}\n\t\
    if(n == 1) then\n\t\treturn result\n\tend\n\tlocal div = 2\n\tlocal rem = n\n\t\
    while(rem > 1) do\n\t\tif(rem % div == 0) then\n\t\t\trem = rem / div\n\t\t\t\
    table.insert(result, div)\n\t\telse\n\t\t\tdiv = div + 1\n\t\tend\n\tend\n\treturn\
    \ result\nend", "\tlocal primes = get_primes(n)\n\tlocal fact = {}\n\tlocal index\
    \ = 1\n\tfor i = 1, #primes do\n\t\tif index > #fact then\n\t\t\tfact[index] =\
    \ 1\n\t\tend\n\t\twhile n % primes[i] == 0 do\n\t\t\tn = n / primes[i]\n\t\t\t\
    fact[index] = primes[i]\n\t\t\tindex = index + 1\n\t\tend\n\tend\n\treturn fact\n\
    end", "\tlocal i = 2\n\tlocal factors = {}\n\trepeat\n\t\tif (n % i) == 0 then\n\
    \t\t\tfactors[#factors + 1] = i\n\t\t\tn = n / i\n\t\telse\n\t\t\ti = i + 1\n\t\
    \tend\n\tuntil n == 1\n\treturn factors\nend", "\tassert(type(n) == \"number\"\
    , \"number expected\")\n\tlocal factors = {}\n\tif n ~= 1 then\n\t\tfor _, p in\
    \ ipairs(primes) do\n\t\t\twhile n % p == 0 do\n\t\t\t\ttable.insert(factors,\
    \ p)\n\t\t\t\tn = n / p\n\t\t\tend\n\t\t\tif n == 1 then\n\t\t\t\tbreak\n\t\t\t\
    end\n\t\tend\n\t\tif n ~= 1 then\n\t\t\ttable.insert(factors, n)\n\t\tend\n\t\
    end\n\treturn factors\nend", "\tlocal factors = {}\n\tlocal i = 2\n\twhile n >\
    \ 1 do\n\t\tif n % i == 0 then\n\t\t\tfactors[#factors + 1] = i\n\t\t\tn = n /\
    \ i\n\t\telse\n\t\t\ti = i + 1\n\t\tend\n\tend\n\treturn factors\nend", "  local\
    \ prime_factors = {}\n  local k = 1\n  local i = 2\n  while n > 1 do\n    if n\
    \ % i == 0 then\n      if prime_factors[k] ~= i then\n        prime_factors[k]\
    \ = i\n        k = k + 1\n      end\n      n = n / i\n    else\n      i = i +\
    \ 1\n    end\n  end\n  return prime_factors\nend", "\tlocal primes = prime_factorization(n)\n\
    \tlocal factors = {}\n\tfor _,v in ipairs(primes) do\n\t\tlocal f = v[1]\n\t\t\
    local c = v[2]\n\t\tfor i=1,c do\n\t\t\ttable.insert(factors, f)\n\t\tend\n\t\
    end\n\treturn factors\nend", "    local factors = {}\n    local primes = {2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,\
    \ 83, 89, 97}\n    for i = 1, #primes do\n        while n % primes[i] == 0 do\n\
    \            n = n / primes[i]\n            table.insert(factors, primes[i])\n\
    \        end\n    end\n    return factors\nend", "    local factors = {}\n   \
    \ for i = 2, n do\n        while n % i == 0 do\n            table.insert(factors,\
    \ i)\n            n = n / i\n        end\n    end\n    return factors\nend", "\t\
    local result = {}\n\tlocal fact = 2\n\tlocal sqrt_n = sqrt(n)\n\twhile n > 1 and\
    \ fact <= sqrt_n do\n\t\tif n % fact == 0 then\n\t\t\tn = n / fact\n\t\t\ttable.insert(result,\
    \ fact)\n\t\telse\n\t\t\tfact = fact + 1\n\t\tend\n\tend\n\tif n > 1 then\n\t\t\
    table.insert(result, n)\n\tend\n\treturn result\nend", "\tlocal factors = {}\n\
    \tfor k,v in ipairs(PRIMES) do\n\t\tif v > n then\n\t\t\tbreak\n\t\tend\n\t\t\
    local factor = 0\n\t\twhile n % v == 0 do\n\t\t\tn = n / v\n\t\t\tfactor = factor\
    \ + 1\n\t\tend\n\t\tif factor > 0 then\n\t\t\tfactors[#factors + 1] = {v, factor}\n\
    \t\tend\n\tend\n\treturn factors\nend", "    local result = {}\n    local prime\
    \ = 2\n    while n > 1 do\n        if n % prime == 0 then\n            result[#result\
    \ + 1] = prime\n            n = n / prime\n        else\n            prime = prime\
    \ + 1\n        end\n    end\n    return result\nend", "    local res = {}\n  \
    \  while n ~= 1 do\n        local prime_div = get_smallest_prime_divisor(n)\n\
    \        res[#res + 1] = prime_div\n        n = n / prime_div\n    end\n    return\
    \ res\nend", "    local res = {}\n    for i = 2, n do\n        if n % i == 0 then\n\
    \            table.insert(res, i)\n            res = table.merge(res, factorize(n\
    \ / i))\n            break\n        end\n    end\n    return res\nend", "  local\
    \ factors = {}\n  local d = 2\n  while n > 1 do\n    while n % d == 0 do\n   \
    \   n = n / d\n      table.insert(factors, d)\n    end\n    d = d + 1\n  end\n\
    \  return factors\nend", "    local out = {}\n    for p in list_primes(prime_factors(n))\
    \ do\n        out[p] = (out[p] or 0) + 1\n    end\n    return out\nend", "\tif\
    \ n < 1 then\n\t\terror(\"Invalid input number \" .. n)\n\tend\n\tif n == 1 then\n\
    \t\treturn {}\n\tend\n\tlocal factors = {}\n\tlocal prime = 2\n\tlocal n2 = n\n\
    \twhile prime <= n2 do\n\t\tlocal p = n2 % prime\n\t\tif p == 0 then\n\t\t\tn2\
    \ = n2 / prime\n\t\t\tfactors[#factors + 1] = prime\n\t\telse\n\t\t\tprime = nextPrime(prime)\n\
    \t\tend\n\tend\n\treturn factors\nend", "    if n == 1 then\n        return {}\n\
    \    end\n    local factors = {}\n    local d = 2\n    while n > 1 do\n      \
    \  while n % d == 0 do\n            n = n / d\n            table.insert(factors,\
    \ d)\n        end\n        d = d + 1\n    end\n    return factors\nend", "\tif\
    \ n < 2 then return {} end\n\tlocal function collect_prime_factors(t, n)\n\t\t\
    if n == 1 then return t end\n\t\tlocal first_factor = 2\n\t\twhile n % first_factor\
    \ ~= 0 do\n\t\t\tfirst_factor = first_factor + 1\n\t\tend\n\t\tlocal f = factorize(first_factor)\n\
    \t\tlocal r = factorize(n / first_factor)\n\t\tfor _, x in ipairs(r) do table.insert(f,\
    \ x) end\n\t\tfor _, x in ipairs(f) do table.insert(t, x) end\n\t\treturn t\n\t\
    end\n\treturn collect_prime_factors({}, n)\nend", "    local primeFactors = {}\n\
    \    local divisor = 2\n    while n > 1 do\n        if n % divisor == 0 then\n\
    \            primeFactors[#primeFactors + 1] = divisor\n            n = n / divisor\n\
    \        else\n            divisor = divisor + 1\n        end\n    end\n    return\
    \ primeFactors\nend", "  local factors = {}\n  local d = 2\n  while n > 1 do\n\
    \    while (n % d) == 0 do\n      table.insert(factors, d)\n      n = n / d\n\
    \    end\n    d = d + 1\n  end\n  return factors\nend", "    -- table that holds\
    \ prime factors of input number\n    local factors = {}\n    -- for every prime\
    \ numbers starting from 2 up to the floor of given number\n    for p = 2, math.floor(n\
    \ ^ 0.5) do\n        -- if given number is dividable by prime factor\n       \
    \ while n % p == 0 do\n            -- add that prime factor to the list\n    \
    \        factors[#factors + 1] = p\n            -- and divide given number with\
    \ that prime factor\n            n = n / p\n        end\n    end\n    -- if given\
    \ number is not a perfect square then add its last prime factor to the list\n\
    \    if n > 1 then\n        factors[#factors + 1] = n\n    end\n    -- return\
    \ list of prime factors\n    return factors\nend", "    local res = {}\n    local\
    \ i = 1\n    while n ~= 1 do\n        local p = primes[i]\n        if n % p ==\
    \ 0 then\n            res[#res + 1] = p\n            n = n / p\n        else\n\
    \            i = i + 1\n        end\n    end\n    return res\nend", "    assert(n\
    \ > 0, \"can only factorize positive numbers\")\n    local factors = {}\n    local\
    \ divisor = 2\n    while (n > 1) do\n        if (n % divisor == 0) then\n    \
    \        n = n / divisor\n            table.insert(factors, divisor)\n       \
    \ else\n            divisor = divisor + 1\n        end\n    end\n    return factors\n\
    end", "    local factors = {}\n    for i = 2, n / 2 do\n        if n % i == 0\
    \ then\n            for j = 2, n / i do\n                if n % (i ^ j) == 0 then\n\
    \                    factors[#factors + 1] = i\n                else\n       \
    \             factors[#factors + 1] = i ^ j\n                    break\n     \
    \           end\n            end\n        end\n    end\n    factors[#factors +\
    \ 1] = n\n    return factors\nend", "    local res = {}\n    for p,_ in pairs(primes)\
    \ do\n        if n % p == 0 then\n            repeat\n                n = n /\
    \ p\n                res[#res+1] = p\n            until n % p ~= 0\n        end\n\
    \    end\n    return res\nend", "\tlocal t = {}\n\tlocal n = n\n\tlocal prime\
    \ = 2\n\t\n\twhile n ~= 1 do\n\t\tif n % prime == 0 then\n\t\t\tn = n / prime\n\
    \t\t\ttable.insert(t, prime)\n\t\telse\n\t\t\tprime = prime + 1\n\t\tend\n\tend\n\
    \t\n\treturn t\nend", "    local t = {}\n    while n % 2 == 0 do\n        table.insert(t,\
    \ 2)\n        n = n / 2\n    end\n    local i = 3\n    while i * i <= n do\n \
    \       while n % i == 0 do\n            table.insert(t, i)\n            n = n\
    \ / i\n        end\n        i = i + 2\n    end\n    if n > 1 then\n        table.insert(t,\
    \ n)\n    end\n    return t\nend", "    local prime_factors = {}\n    if n < 2\
    \ then\n        return prime_factors\n    end\n    local primes = {\n        2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,\
    \ 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\
    \ 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\
    \ 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,\
    \ 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,\
    \ 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\
    \ 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063,\
    \ 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129", "    local factors\
    \ = {}\n    while n ~= 1 do\n        local divisor = divisors[n]\n        if divisor\
    \ then\n            table.insert(factors, divisor)\n            n = n / divisor\n\
    \        else\n            for i = 3, math.sqrt(n), 2 do\n                if n\
    \ % i == 0 then\n                    table.insert(factors, i)\n              \
    \      n = n / i\n                    break\n                end\n           \
    \ end\n        end\n    end\n    return factors\nend", "    assert(type(n) ==\
    \ \"number\" and n > 0 and math.floor(n) == n, \"Invalid input\")\n    local factors\
    \ = {}\n    while n > 1 do\n        local smallest_factor = smallest_prime_factor(n)\n\
    \        table.insert(factors, smallest_factor)\n        n = n / smallest_factor\n\
    \    end\n    return factors\nend", "\tassert_integer(n)\n\tif n == 1 then return\
    \ {} end\n\tif primes_cache[n] then return {n} end\n\tlocal factors = {}\n\tlocal\
    \ q,r\n\tlocal d = 2\n\twhile n > 1 do\n\t\tq,r = divmod(n,d)\n\t\tif r == 0 then\n\
    \t\t\tn = q\n\t\t\ttable.insert(factors, d)\n\t\telse\n\t\t\td = d + 1\n\t\tend\n\
    \tend\n\treturn factors\nend", "\tlocal lim = math.floor(math.sqrt(n))\n\tlocal\
    \ factors = {}\n\twhile n%2 == 0 do\n\t\ttable.insert(factors, 2)\n\t\tn = n/2\n\
    \tend\n\tlocal p = 3\n\twhile n > 1 do\n\t\tif n%p == 0 then\n\t\t\ttable.insert(factors,\
    \ p)\n\t\t\tn = n/p\n\t\telse\n\t\t\tp = p + 2\n\t\tend\n\tend\n\treturn factors\n\
    end", "\t-- your code here\nend", "\tlocal factors = {}\n\tif n > 1 then\n\t\t\
    if math.mod(n, 2) == 0 then\n\t\t\ttable.insert(factors, 2)\n\t\t\twhile math.mod(n,\
    \ 2) == 0 do\n\t\t\t\tn = n / 2\n\t\t\tend\n\t\tend\n\t\tlocal factor = 3\n\t\t\
    while factor * factor <= n do\n\t\t\tif math.mod(n, factor) == 0 then\n\t\t\t\t\
    table.insert(factors, factor)\n\t\t\t\twhile math.mod(n, factor) == 0 do\n\t\t\
    \t\t\tn = n / factor\n\t\t\t\tend\n\t\t\tend\n\t\t\tfactor = factor + 2\n\t\t\
    end\n\t\tif n > 1 then\n\t\t\ttable.insert(factors, n)\n\t\tend\n\tend\n\treturn\
    \ factors\nend", "\tif (n <= 1) then return {n} end\n\tif (primes[n]) then return\
    \ {n} end\n\tlocal c = primes[1]\n\twhile (c * c <= n) do\n\t\tif (n % c == 0)\
    \ then\n\t\t\treturn insertList({c}, factorize(n / c))\n\t\tend\n\t\tc = primes[c\
    \ + 1]\n\tend\n\treturn {n}\nend", "\tn = n or 0\n\tlocal factors = {}\n\twhile\
    \ n % 2 == 0 do\n\t\tn = n / 2\n\t\ttable.insert(factors, 2)\n\tend\n\tlocal i\
    \ = 3\n\twhile i <= math.sqrt(n) do\n\t\twhile n % i == 0 do\n\t\t\tn = n / i\n\
    \t\t\ttable.insert(factors, i)\n\t\tend\n\t\ti = i + 2\n\tend\n\tif n > 2 then\n\
    \t\ttable.insert(factors, n)\n\tend\n\treturn factors\nend", "\tlocal result =\
    \ {}\n\tlocal divisor = 2\n\twhile n > 1 do\n\t\tlocal count = 0\n\t\twhile n\
    \ % divisor == 0 do\n\t\t\tn = n / divisor\n\t\t\tcount = count + 1\n\t\tend\n\
    \t\tif count > 0 then\n\t\t\tresult[#result + 1] = {divisor, count}\n\t\tend\n\
    \t\tdivisor = divisor + 1\n\tend\n\treturn result\nend", "\tlocal factors = {}\n\
    \t\n\t-- Helper function:\n\t-- Insert new factor in factors table, checking if\
    \ it already exists.\n\t-- If it does, it has to be added the the 'count' field.\n\
    \tlocal function insert(factor)\n\t\tfor i, f in ipairs(factors) do\n\t\t\tif\
    \ f.factor == factor then\n\t\t\t\tf.count = f.count + 1\n\t\t\t\treturn\n\t\t\
    \tend\n\t\tend\n\t\ttable.insert(factors, { factor = factor, count = 1 })\n\t\
    end\n\t\n\t-- Start with 2, increment by 2, stop when n is reached.\n\tfor i =\
    \ 2, n, 2 do\n\t\twhile n % i == 0 do\n\t\t\tn = n / i\n\t\t\tinsert(i)\n\t\t\
    end\n\tend\n\t\n\t-- If n is not 1, there is still an odd prime factor left\n\t\
    if n ~= 1 then\n\t\tinsert(n)\n\tend\n\t\n\treturn factors\nend", "    if n <\
    \ 2 then return {} end\n    local factors = {}\n    while n % 2 == 0 do\n    \
    \    n = n / 2\n        table.insert(factors, 2)\n    end\n    local f = 3\n \
    \   while f <= math.sqrt(n) do\n        if n % f == 0 then\n            n = n\
    \ / f\n            table.insert(factors, f)\n        else\n            f = f +\
    \ 2\n        end\n    end\n    if n > 1 then\n        table.insert(factors, n)\n\
    \    end\n    return factors\nend", "\tlocal factors = {}\n\tfor i = 2, n / 2\
    \ do\n\t\tif n % i == 0 then\n\t\t\tn = n / i\n\t\t\ttable.insert(factors, i)\n\
    \t\t\ti = i - 1\n\t\tend\n\tend\n\ttable.insert(factors, n)\n\treturn factors\n\
    end", "    local function add(list, x)\n        if n % x == 0 then\n         \
    \   n = n / x\n            table.insert(list, x)\n            return true\n  \
    \      end\n        return false\n    end", "\tlocal prime_factors = {}\n\tlocal\
    \ factor = 2", "\tif n < 1 then\n\t\treturn {}\n\tend\n\t\n\tlocal function pf(n,\
    \ p)\n\t\tlocal i = 1\n\t\twhile i * i <= n do\n\t\t\tif n % i == 0 then\n\t\t\
    \t\tlocal f = n / i\n\t\t\t\tif is_prime(i) then\n\t\t\t\t\tpf(f, i)\n\t\t\t\t\
    \treturn\n\t\t\t\telseif is_prime(f) then\n\t\t\t\t\tpf(i, f)\n\t\t\t\t\treturn\n\
    \t\t\t\tend\n\t\t\tend\n\t\t\ti = i + 1\n\t\tend\n\t\ttable.insert(p, n)\n\tend\n\
    \t\n\tlocal p = {}\n\tpf(n, p)\n\treturn p\nend", "  assert(type(n) == \"number\"\
    \ and n >= 1 and n == math.floor(n), \"n should be a positive integer\")\n  local\
    \ factors = {}\n  local function factorize2(n, i)\n    if n == 1 then\n      return\n\
    \    end\n    while n % i ~= 0 do\n      i = i + 1\n    end\n    factors[#factors\
    \ + 1] = i\n    factorize2(n / i, i)\n  end\n  factorize2(n, 2)\n  return factors\n\
    end", "    local factors = {}\n    for i = 2, n - 1 do\n        while n % i ==\
    \ 0 do\n            table.insert(factors, i)\n            n = n / i\n        end\n\
    \    end\n    return factors\nend", "\tlocal factors = {}\n\tlocal divisor = 2\n\
    \twhile n > 1 do\n\t\twhile n % divisor == 0 do\n\t\t\tn = n / divisor\n\t\t\t\
    factors[#factors + 1] = divisor\n\t\tend\n\t\tdivisor = divisor + 1\n\tend\n\t\
    return factors\nend", "  assert(type(n) == \"number\", \"parameter is not a number\"\
    )\n  assert(n > 0, \"parameter must be positive\")\n  local t = {}\n  while (n\
    \ % 2) == 0 do\n    t[#t + 1] = 2\n    n = n / 2\n  end\n  local max = math.sqrt(n)\n\
    \  local f = 3\n  while f <= max do\n    while (n % f) == 0 do\n      t[#t + 1]\
    \ = f\n      n = n / f\n    end\n    max = math.sqrt(n)\n    f = f + 2\n  end\n\
    \  if n > 1 then\n    t[#t + 1] = n\n  end\n  return t\nend", "    local t = {}\n\
    \    while n % 2 == 0 do\n        t[2] = (t[2] or 0) + 1\n        n = n / 2\n\
    \    end\n    for i = 3, math.sqrt(n), 2 do\n        while n % i == 0 do\n   \
    \         t[i] = (t[i] or 0) + 1\n            n = n / i\n        end\n    end\n\
    \    if n > 2 then\n        t[n] = 1\n    end\n    return t\nend", "\tlocal factors\
    \ = {}\n\tfor p = 2, n / 2 do\n\t\twhile n % p == 0 do\n\t\t\tfactors[#factors\
    \ + 1] = p\n\t\t\tn = n / p\n\t\tend\n\tend\n\tfactors[#factors + 1] = n\n\treturn\
    \ factors\nend", "\t-- assumes n is prime\n\tlocal factors = {}\n\tlocal i = 2\n\
    \twhile n > 1 do\n\t\twhile n % i == 0 do\n\t\t\tfactors[#factors + 1] = i\n\t\
    \t\tn = n / i\n\t\tend\n\t\ti = i + 1\n\tend\n\treturn factors\nend", "  local\
    \ factors = {}\n  local d = 2\n  while n > 1 do\n    while n % d == 0 do\n   \
    \   factors[#factors + 1] = d\n      n = n / d\n    end\n    d = d + 1\n  end\n\
    \  return factors\nend", "\t-- validate input\n\tif not isNumber(n) then\n\t\t\
    error('bad argument #1 to \\'factorize\\' (number expected, got ' .. type(n) ..\
    \ ')', 2)\n\tend\n\tif n <= 0 then\n\t\terror('bad argument #1 to \\'factorize\\\
    ' (number > 0 expected, got ' .. n .. ')', 2)\n\tend\n\t-- Do factorization\n\t\
    local factors = {}\n\tlocal fs = sieve(math.floor(math.sqrt(n)))\n\tfor i = 1,\
    \ #fs do\n\t\tlocal f = fs[i]\n\t\twhile (n % f == 0) do\n\t\t\ttable.insert(factors,\
    \ f)\n\t\t\tn = n / f\n\t\tend\n\tend\n\tif n > 1 then table.insert(factors, n)\
    \ end\n\treturn factors\nend", "\tlocal retval = {}\n\tlocal sn = n\n\tlocal small_factors\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97}\n\tfor _,f in ipairs(small_factors) do\n\t\twhile sn % f\
    \ == 0 do\n\t\t\tsn = sn / f\n\t\t\tretval[#retval+1] = f\n\t\tend\n\tend\n\t\
    if sn ~= 1 then\n\t\tfor i = 2,sn-1 do\n\t\t\tif math.sqrt(sn) < i then\n\t\t\t\
    \tretval[#retval+1] = sn\n\t\t\t\tbreak\n\t\t\tend\n\t\t\twhile sn % i == 0 do\n\
    \t\t\t\tsn = sn / i\n\t\t\t\tretval[#retval+1] = i\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn retval\nend", "\tif n <= 1 then return {} end", "\tlocal factors = {}\n\
    \tfor p,e in factorize_prime(n) do\n\t\tfor i=1,e do\n\t\t\tfactors[#factors+1]\
    \ = p\n\t\tend\n\tend\n\treturn factors\nend", "    if n < 2 then return {} end\n\
    \    local factors = {}\n    for _, p in ipairs(primes) do\n        local k =\
    \ 0\n        while n % p == 0 do\n            n = n / p\n            k = k + 1\n\
    \        end\n        if k > 0 then\n            factors[p] = k\n        end\n\
    \        if n == 1 then break end\n    end\n    return factors\nend", "\tlocal\
    \ primes, prime, factors = primeSieve(n), 2, {}\n\twhile prime <= n do\n\t\tif\
    \ not primes[prime] then prime = prime + 1 else\n\t\t\tlocal exp = 1\n\t\t\twhile\
    \ n % prime == 0 do\n\t\t\t\tn = n / prime\n\t\t\t\texp = exp + 1\n\t\t\tend\n\
    \t\t\tif exp > 1 then\n\t\t\t\tfactors[#factors + 1] = prime\n\t\t\t\tfactors[#factors\
    \ + 1] = exp - 1\n\t\t\tend\n\t\t\tprime = prime + 1\n\t\tend\n\tend\n\treturn\
    \ factors\nend", "  local factorization = {}\n  local current_n = n\n  for _,\
    \ p in ipairs(get_primes(n)) do\n    local count = 0\n    while(math.fmod(current_n,\
    \ p) == 0) do\n      current_n = current_n / p\n      count = count + 1\n    end\n\
    \    if(count > 0) then\n      table.insert(factorization, {p, count})\n    end\n\
    \  end\n  return factorization\nend", "    local factors = {}\n    while n % 2\
    \ == 0 do\n        n = n / 2\n        factors[2] = (factors[2] or 0) + 1\n   \
    \ end\n    for i = 3, math.sqrt(n), 2 do\n        while n % i == 0 do\n      \
    \      n = n / i\n            factors[i] = (factors[i] or 0) + 1\n        end\n\
    \    end\n    if n > 2 then\n        factors[n] = (factors[n] or 0) + 1\n    end\n\
    \    return factors\nend", "  local result = {}\n  while n > 1 do\n    local a\
    \ = smallest_prime_factor(n)\n    result[#result + 1] = a\n    n = n // a\n  end\n\
    \  return result\nend", "    if n == 1 then\n        return {1}\n    end\n   \
    \ local smallest_factor = next(n % 2 == 0 and {2} or nil)\n    while smallest_factor\
    \ ~= nil do\n        local is_factor = true\n        for i = 3, math.sqrt(n),\
    \ 2 do\n            if n % i == 0 then\n                is_factor = false\n  \
    \              n = n / i\n                smallest_factor = i\n              \
    \  break\n            end\n        end\n        if is_factor then\n          \
    \  return {n}\n        end\n    end\nend", "\tlocal pow, product = 0, 1\n\tlocal\
    \ factors = {}\n\tlocal sqrt_n = math.sqrt(n)\n\tlocal i = 1\n\twhile true do\n\
    \t\tlocal is_prime, prime = is_prime_cache[i]\n\t\tif not is_prime then\n\t\t\t\
    is_prime, prime = is_prime_number(i)\n\t\t\tis_prime_cache[i] = is_prime\n\t\t\
    \tis_prime_cache[prime] = is_prime\n\t\tend\n\t\tif is_prime then\n\t\t\tpow =\
    \ 0\n\t\t\twhile n % prime == 0 do\n\t\t\t\tn = n / prime\n\t\t\t\tpow = pow +\
    \ 1\n\t\t\tend\n\t\t\tif pow > 0 then\n\t\t\t\ttable.insert(factors, prime)\n\t\
    \t\t\ttable.insert(factors, pow)\n\t\t\t\tproduct = product * prime ^ pow\n\t\t\
    \tend\n\t\t\tif n <= 1 then\n\t\t\t\tbreak\n\t\t\tend\n\t\tend\n\t\ti = i + 1\n\
    \tend\n\tassert(product == n)\n\treturn factors\nend", "    local fs = {};\n \
    \   local f;\n    while n%2 == 0 do\n        n = n/2;\n        table.insert(fs,\
    \ 2);\n    end\n    f = 3;\n    while f*f <= n do\n        if n%f == 0 then\n\
    \            n = n/f;\n            table.insert(fs, f);\n        else\n      \
    \      f = f+2;\n        end\n    end\n    if n > 1 then\n        table.insert(fs,\
    \ n);\n    end\n    return fs;\nend", "\tlocal out = {}\n\tlocal m = n\n\tlocal\
    \ divisor = 2\n\twhile m > 1 do\n\t\twhile m % divisor == 0 do\n\t\t\ttable.insert(out,\
    \ divisor)\n\t\t\tm = m / divisor\n\t\tend\n\t\tdivisor = divisor + 1\n\tend\n\
    \treturn out\nend", "    if n < 1 then\n        return nil\n    end\n    local\
    \ factors = {}\n    local d = 2\n    local dd = d * d\n    while n >= dd do\n\
    \        if n % d == 0 then\n            factors[#factors + 1] = d\n         \
    \   n = n / d\n        else\n            d = d + 1\n            dd = d * d\n \
    \       end\n    end\n    -- n is prime or prime * some prime\n    if n > 1 then\n\
    \        factors[#factors + 1] = n\n    end\n    return factors\nend", "    local\
    \ factors = {}\n    local d = 2\n    while n > 1 do\n        if n % d == 0 then\n\
    \            factors[#factors + 1] = d\n            n = n / d\n        else\n\
    \            d = d + 1\n        end\n    end\n    return factors\nend", "\tif\
    \ n == 1 then return {1} end", "\tif n == 1 then return {1} end\n\tlocal primes\
    \ = primeSieve(n)\n\tlocal factors = {}\n\tfor i,v in ipairs(primes) do\n\t\t\
    if n % v == 0 then\n\t\t\ttable.insert(factors, v)\n\t\t\tn = n / v\n\t\t\tif\
    \ n == 1 then return factors end\n\t\t\ti = i - 1\n\t\tend\n\tend\n\treturn factors\n\
    end", "    local factors = {}\n    while n > 1 do\n        local prime = n % 2\
    \ == 0 and 2 or find_next_prime(3, n)\n        n = n / prime\n        table.insert(factors,\
    \ prime)\n    end\n    return factors\nend", "    -- your code here\n    local\
    \ prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,\
    \ 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149,\
    \ 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,\
    \ 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331,\
    \ 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431,\
    \ 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523,\
    \ 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631,\
    \ 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739,\
    \ 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853,\
    \ 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967,\
    \ 971, 977, 983, 991, 997}\n    local i = 1\n    local j = 1\n    local product\
    \ = n\n    local result = {}\n    while product > 1 do\n        if product % prime[i]\
    \ == 0 then\n            result[j] = prime[i]\n            product = product /\
    \ prime[i]\n            j = j + 1\n        else\n            i = i + 1\n     \
    \   end\n", "    local primeFactors = {}\n    local function helper(n, i)\n  \
    \      if n == 1 then return end\n        while n % i ~= 0 do\n            i =\
    \ i + 1\n        end\n        primeFactors[#primeFactors + 1] = i\n        helper(n\
    \ / i, i)\n    end\n    helper(n, 2)\n    return primeFactors\nend", "\tlocal\
    \ factors,lastP = {},2\n\tfor d=2,n do\n\t\tif n%d==0 then\n\t\t\t-- Current factor\
    \ is prime?\n\t\t\tfor _,p in ipairs(factors) do\n\t\t\t\tif d%p==0 then\n\t\t\
    \t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\t\t-- Not prime. Add factor to list.\n\
    \t\t\tfactors[#factors+1]=d\n\t\t\tn=n/d\n\t\t\td=d-1\n\t\tend\n\tend\n\treturn\
    \ factors\nend", "\t--List of prime numbers from 2 to n\n\tlocal primes = { 2\
    \ }\n\tfor i = 3, n do\n\t\tif not factorize.isDivisibleByAny(i, primes) then\n\
    \t\t\ttable.insert(primes, i)\n\t\tend\n\tend\n\t--Factorization\n\tlocal factors\
    \ = {}\n\tfor _, prime in ipairs(primes) do\n\t\twhile n % prime == 0 do\n\t\t\
    \ttable.insert(factors, prime)\n\t\t\tn = n / prime\n\t\tend\n\tend\n\t--Returning\
    \ the result\n\treturn factors\nend", "    if n < 1 then\n        return { }\n\
    \    end\n    if n == 1 then\n        return { 1 }\n    end\n    local t = { }\n\
    \    for p, _ in pairs(primes) do\n        while n % p == 0 do\n            t[#t\
    \ + 1] = p\n            n = n / p\n        end\n    end\n    return t\nend", " \
    \ local factors = {}\n  if n <= 1 then\n    return factors\n  end\n  local d =\
    \ 2\n  while n > 1 do\n    while n % d == 0 do\n      table.insert(factors, d)\n\
    \      n = n / d\n    end\n    d = d + 1\n  end\n  return factors\nend", "  local\
    \ factors = {}\n  local i = 2\n  local limit = math.floor(math.sqrt(n))\n  while\
    \ n > 1 and i <= limit do\n    if n % i == 0 then\n      factors[#factors + 1]\
    \ = i\n      n = n / i\n    else\n      i = i + 1\n    end\n  end\n  if n > 1\
    \ then\n    factors[#factors + 1] = n\n  end\n  return factors\nend", "  if n\
    \ == 1 then return {1} end\n  local factors = {}\n  local idx = 2\n  while n >\
    \ 1 do\n    if n % idx == 0 then\n      table.insert(factors, idx)\n      n =\
    \ n / idx\n    else\n      idx = idx + 1\n    end\n  end\n  return factors\nend",
  "    local factors = {}\n    local d = 2\n    while n > 1 do\n        while n %\
    \ d == 0 do\n            table.insert(factors, d)\n            n = n / d\n   \
    \     end\n        d = d + 1\n    end\n    return factors\nend", "\tif n == 1\
    \ then return {} end\n\tlocal t = {}\n\tlocal b = 2\n\twhile n > 1 do\n\t\tif\
    \ n % b == 0 then\n\t\t\ttable.insert(t, b)\n\t\t\tn = n / b\n\t\telse\n\t\t\t\
    b = b + 1\n\t\tend\n\tend\n\treturn t\nend", "  if type(n) ~= \"number\" then\n\
    \    error(\"Error: only numbers are allowed\")\n  end\n  if n <= 0 then\n   \
    \ error(\"Error: non-positive numbers are not allowed\")\n  end\n  local primeFactors\
    \ = {}\n  local remainder = n\n  for _,p in ipairs(primes) do\n    if p*p > n\
    \ then\n      if remainder ~= 1 then\n        table.insert(primeFactors, remainder)\n\
    \      end\n      break\n    end\n    while remainder % p == 0 do\n      table.insert(primeFactors,\
    \ p)\n      remainder = remainder / p\n    end\n  end\n  if remainder > 1 then\n\
    \    error(\"Error: number is too big to factorize\")\n  end\n  return primeFactors\n\
    end", "\tlocal factors = {}\n\tfor p in divisors(n) do\n\t\tlocal m = n\n\t\t\
    while m % p == 0 do\n\t\t\tm = m / p\n\t\t\ttable.insert(factors, p)\n\t\tend\n\
    \tend\n\treturn factors\nend", "\tlocal factor_table = {}", "    local factors\
    \ = {}\n    for _, factor in ipairs(get_prime_factors(n)) do\n        factors[factor]\
    \ = (factors[factor] or 0) + 1\n    end\n    return factors\nend", "    local\
    \ function factorize_into_primes(n, d)\n        -- d is the divisor\n        --\
    \ TODO: remove hardcoded 2\n        if d == 2 then\n            if n % d == 0\
    \ then\n                return factorize_into_primes(n / d, d)\n            else\n\
    \                return factorize_into_primes(n, d + 1)\n            end\n   \
    \     else\n            if n % d == 0 then\n                return d, factorize_into_primes(n\
    \ / d, d)\n            else\n                return factorize_into_primes(n, d\
    \ + 1)\n            end\n        end\n    end", "    local factors = {}\n    for\
    \ _, prime in ipairs(genPrimes(n)) do\n        local num = 0\n        while (n\
    \ % prime) == 0 do\n            n = n / prime\n            num = num + 1\n   \
    \     end\n        if num > 0 then\n            table.insert(factors, {prime,\
    \ num})\n        end\n    end\n    return factors\nend", "  local factors = {}\n\
    \  for i = 2, math.sqrt(n) do\n    if n % i == 0 then\n      table.insert(factors,\
    \ i)\n      n = n / i\n      i = i - 1\n    end\n  end\n  table.insert(factors,\
    \ n)\n  return factors\nend", "    assert(type(n) == \"number\", \"Integer expected\"\
    )\n    if n == 1 then return {} end", "\tlocal result = {}\n\tlocal i = 2\n\t\
    while n > 1 do\n\t\tlocal c = 0\n\t\twhile n % i == 0 do\n\t\t\tn = n / i\n\t\t\
    \tc = c + 1\n\t\tend\n\t\tif c > 0 then\n\t\t\ttable.insert(result, {i, c})\n\t\
    \tend\n\t\ti = i + 1\n\tend\n\treturn result\nend", "    local factors = {}\n\
    \    local d = 2\n    while n > 1 do\n        while n % d == 0 do\n          \
    \  factors[#factors + 1] = d\n            n = n / d\n        end\n        d =\
    \ d + 1\n    end\n    return factors\nend", "\tlocal t = {}\n\tlocal d = 2\n\t\
    while n > 1 do\n\t\tlocal p = 1\n\t\twhile n % d == 0 do\n\t\t\tn = n / d\n\t\t\
    \tp = p + 1\n\t\tend\n\t\tif p > 1 then\n\t\t\tt[#t + 1] = {d, p}\n\t\tend\n\t\
    \td = d + 1\n\tend\n\treturn t\nend", "    local factors = {}\n    local divisor\
    \ = 2", "\tlocal res = {}\n\tfor i = 2, n do\n\t\tif n % i == 0 then\n\t\t\tlocal\
    \ count = 0\n\t\t\twhile n % i == 0 do\n\t\t\t\tn = n / i\n\t\t\t\tcount = count\
    \ + 1\n\t\t\tend\n\t\t\ttable.insert(res, {i, count})\n\t\tend\n\tend\n\treturn\
    \ res\nend", "  if n == 1 then return {1} end\n  local factors = {}\n  local primes\
    \ = getPrimes(n)\n  local primesCount = #primes\n  local primeIndex = 1\n  while\
    \ n > 1 do\n    local prime = primes[primeIndex]\n    if n % prime == 0 then\n\
    \      n = n / prime\n      factors[#factors + 1] = prime\n    else\n      primeIndex\
    \ = primeIndex + 1\n      if primeIndex > primesCount then\n        error('Unexpected:\
    \ Number ' .. n .. ' is not prime.')\n      end\n    end\n  end\n  return factors\n\
    end", "    local primes = prime_factors(n)\n    local factors = {}\n    while\
    \ n > 1 do\n        local prime = table.remove(primes, 1)\n        while n % prime\
    \ == 0 do\n            n = n / prime\n            table.insert(factors, prime)\n\
    \        end\n    end\n    return factors\nend", "  local result = {}\n  local\
    \ function recurse(n, i)\n    while i <= math.sqrt(n) do\n      if n % i == 0\
    \ then\n        table.insert(result, i)\n        recurse(n / i, i)\n        break\n\
    \      end\n      i = i + 1\n    end\n    if n ~= 1 then\n      table.insert(result,\
    \ n)\n    end\n  end\n  recurse(n, 2)\n  return result\nend", "\tlocal result\
    \ = {}\n\tif n == 1 then\n\t\treturn result\n\tend\n\tlocal max = math.sqrt(n)\n\
    \tlocal i = 2\n\twhile n > 1 and i <= max do\n\t\tlocal factor = nil\n\t\tif n\
    \ % i == 0 then\n\t\t\tfactor = i\n\t\tend\n\t\twhile n % i == 0 do\n\t\t\tn =\
    \ n / i\n\t\t\tmax = math.sqrt(n)\n\t\tend\n\t\tif factor then\n\t\t\ttable.insert(result,\
    \ factor)\n\t\tend\n\t\ti = i + 1\n\tend\n\tif n > 1 then\n\t\ttable.insert(result,\
    \ n)\n\tend\n\treturn result\nend", "    if n < 2 then return {} end\n    local\
    \ pf = {}\n    local nn = n\n    while nn % 2 == 0 do\n        table.insert(pf,\
    \ 2)\n        nn = nn / 2\n    end\n    local i = 3\n    while i <= nn do\n  \
    \      if nn % i == 0 then\n            table.insert(pf, i)\n            nn =\
    \ nn / i\n        else\n            i = i + 2\n        end\n    end\n    return\
    \ pf\nend", "  local function factorize_2(acc, n)\n    for _, p in ipairs(primes)\
    \ do\n      if n % p == 0 then\n        return factorize_2(acc * (p ^ (1 + math.floor(math.log(n)/math.log(p)))),\
    \ n / (p ^ math.floor(math.log(n)/math.log(p))))\n      end\n    end\n    return\
    \ acc\n  end\n  local n_fact = factorize_2(1, n)\n  local factors = {}\n  for\
    \ _, p in ipairs(primes) do\n    if n_fact % p == 0 then\n      factors[#factors\
    \ + 1] = p\n      n_fact = n_fact / p\n    end\n  end\n  return factors\nend",
  "  local function factor(n,p)\n    if n==1 then return {} end\n    if n%p==0 then\
    \ return {p,factor(n/p,p)} end\n    return factor(n,p+1)\n  end\n  return factor(n,2)\n\
    end", "    local factors = {}\n    for i = 2, n, 1 do\n        if n % i == 0 then\n\
    \            table.insert(factors, i)\n            n = n / i\n            i =\
    \ i - 1\n        end\n    end\n    return factors\nend", "  if type(n) ~= \"number\"\
    \ then\n    error(\"Input argument should be a number\", 2)\n  end\n  local factors\
    \ = {}\n  local max = math.floor(math.sqrt(n))\n  for f = 2, max do\n    while\
    \ n % f == 0 do\n      table.insert(factors, f)\n      n = n / f\n    end\n  end\n\
    \  if n > 1 then\n    table.insert(factors, n)\n  end\n  return factors\nend",
  "\tlocal fac = {}", "\tlocal result = {}\n\tif not n or n < 1 then return result\
    \ end\n\t\n\tlocal lastFactor = nil\n\tfor i = 2, n do\n\t\tlocal factor = n /\
    \ i\n\t\tif factor == math.floor(factor) then\n\t\t\tlastFactor = factor\n\t\t\
    \tn = factor\n\t\t\tbreak\n\t\tend\n\tend\n\t\n\tif lastFactor then\n\t\treturn\
    \ factorize(lastFactor), lastFactor\n\telse\n\t\treturn n\n\tend\nend", "    local\
    \ result = {}\n    local d = 2\n    while n > 1 do\n        while n % d == 0 do\n\
    \            result[#result + 1] = d\n            n = n / d\n        end\n   \
    \     d = d + 1\n    end\n    return result\nend", "\tlocal factors = {}\n\tlocal\
    \ remaining = n\n\twhile remaining > 1 do\n\t\tlocal p, e = next(primes)\n\t\t\
    if remaining % p == 0 then\n\t\t\tfactors[p] = (factors[p] or 0) + 1\n\t\t\tremaining\
    \ = remaining / p\n\t\telse\n\t\t\tprimes:pop()\n\t\tend\n\tend\n\treturn factors\n\
    end", "\tlocal result = {}\n\tfor _,p in ipairs(primes) do\n\t\tif p > n then\
    \ break end\n\t\twhile n % p == 0 do\n\t\t\ttable.insert(result, p)\n\t\t\tn =\
    \ n/p\n\t\tend\n\tend\n\treturn result\nend", "    local factors = {}\n    local\
    \ d = 2\n    while n > 1 do\n        while n % d == 0 do\n            table.insert(factors,\
    \ d)\n            n = n / d\n        end\n        d = d + 1\n    end\n    return\
    \ factors\nend", "    local factors = {}\n    while n % 2 == 0 do\n        table.insert(factors,\
    \ 2)\n        n = n / 2\n    end\n    local divisor = 3\n    while n > 1 do\n\
    \        while n % divisor == 0 do\n            table.insert(factors, divisor)\n\
    \            n = n / divisor\n        end\n        divisor = divisor + 2\n   \
    \ end\n    return factors\nend", "\tlocal factors = {}\n\tif n == 1 then\n\t\t\
    return {1}\n\tend\n\tlocal f = 2\n\twhile n > 1 do\n\t\tlocal e = 0\n\t\twhile\
    \ n % f == 0 do\n\t\t\tn = n / f\n\t\t\te = e + 1\n\t\tend\n\t\tif e > 0 then\n\
    \t\t\ttable.insert(factors, {factor = f, exp = e})\n\t\tend\n\t\tf = f + 1\n\t\
    end\n\treturn factors\nend", "  local factors = {}\n  local n_org = n\n  -- by\
    \ definition the factor 2 is present at least once\n  table.insert(factors, 2)\n\
    \  while n % 2 == 0 do\n    n = n / 2\n  end\n  -- only need to consider odd divisors,\
    \ factor 3\n  local divisor = 3\n  while divisor * divisor <= n do\n    if n %\
    \ divisor == 0 then\n      table.insert(factors, divisor)\n      while n % divisor\
    \ == 0 do\n        n = n / divisor\n      end\n    end\n    divisor = divisor\
    \ + 2\n  end\n  -- n at this point is either 1 or a prime number\n  if n > 2 then\n\
    \    table.insert(factors, n)\n  end\n  -- here we check that given integer is\
    \ actually the product of all factors\n  local factorization = 1\n  for i,factor\
    \ in ipairs(factors) do\n    factorization = factorization * factor\n  end\n \
    \ assert(factorization == n_org, 'factorization failed')\n  return factors\nend",
  "\t--check if the number is prime \n\tif isPrime(n) then\n\t\treturn {n}\n\tend\n\
    \t-- Check if it's a positive integer.\n\tif n < 1 or n ~= math.floor(n) then\n\
    \t\terror(\"Expected a positive integer, got \" .. n)\n\tend\n\t-- \n\tlocal primes\
    \ = {}\n\tlocal x = n\n\tlocal index = 1\n\twhile x ~= 1 do\n\t\t-- check if x\
    \ is divisible by the index-th prime.\n\t\t-- If it is, append that prime to our\
    \ list and divide x by that prime.\n\t\t-- If not, go to the next prime.\n\t\t\
    if x % index == 0 then\n\t\t\ttable.insert(primes, index)\n\t\t\tx = x / index\n\
    \t\telse\n\t\t\tindex = index + 1\n\t\tend\n\tend\n\treturn primes\nend", "  \
    \  local factors = {}\n    while n > 1 do\n        local minPrime = minFactor(n)\n\
    \        factors[#factors + 1] = minPrime\n        n = n / minPrime\n    end\n\
    \    return factors\nend", "\tlocal result = {}\n\tif (n < 2) then\n\t\treturn\
    \ result\n\tend\n\tlocal index = 1\n\tlocal value = primes[index]\n\twhile (value\
    \ <= n) do\n\t\tif (n % value == 0) then\n\t\t\tresult[#result + 1] = value\n\t\
    \t\tn = n / value\n\t\telse\n\t\t\tindex = index + 1\n\t\t\tvalue = primes[index]\n\
    \t\tend\n\tend\n\treturn result\nend", "  -- this is the obvious solution, but\
    \ it's too slow\n  --local factors = {}\n  --for i = 2, n do\n  --  while n %\
    \ i == 0 do\n  --    table.insert(factors, i)\n  --    n = n / i\n  --  end\n\
    \  --end\n  --return factors", "    local list = {}\n    local divisor = 2\n \
    \   while n > 1 do\n        local power = 0\n        while n % divisor == 0 do\n\
    \            n = n / divisor\n            power = power + 1\n        end\n   \
    \     if power > 0 then\n            table.insert(list, {divisor, power})\n  \
    \      end\n        divisor = divisor + 1\n    end\n    return list\nend", "\t\
    local list = {}\n\tfor p, e in decompose(n) do\n\t\tfor _ = 1, e do\n\t\t\ttable.insert(list,\
    \ p)\n\t\tend\n\tend\n\treturn list\nend", "\tlocal factors = {}\n\tlocal divisor\
    \ = 2", "  local factors = {}\n  if n < 0 then\n    factors[#factors + 1] = -1\n\
    \    n = -n\n  end\n  while n % 2 == 0 do\n    factors[#factors + 1] = 2\n   \
    \ n = n / 2\n  end\n  local divisor = 3\n  while n > 1 do\n    if n % divisor\
    \ == 0 then\n      factors[#factors + 1] = divisor\n      n = n / divisor\n  \
    \  else\n      divisor = divisor + 2\n    end\n  end\n  return factors\nend",
  '    if n < 2 then return {} end', "\tlocal factors = {}\n\tlocal divisor = 2\n\t\
    while (n > 1) do\n\t\tif (n % divisor == 0) then\n\t\t\ttable.insert(factors,\
    \ divisor)\n\t\t\tn = n / divisor\n\t\telse\n\t\t\tdivisor = divisor + 1\n\t\t\
    end\n\tend\n\treturn factors\nend", "\tlocal prime_factors = {}\n\tlocal p = 2",
  "    local result = {}\n    for i = 2, n - 1 do\n        if n % i == 0 then\n  \
    \          table.insert(result, i)\n            n = n / i\n            i = 1\n\
    \        end\n    end\n    return result\nend", "    if n <= 1 then\n        return\
    \ {n}\n    end\n    local factors = {}\n    local i = 2\n    while i <= n do\n\
    \        if n % i == 0 then\n            table.insert(factors, i)\n          \
    \  n = n / i\n        else\n            i = i + 1\n        end\n    end\n    return\
    \ factors\nend", '  local primitives = {}', "  local factors = {}\n  local i =\
    \ 2\n  while n ~= 1 do\n    if n % i == 0 then\n      factors[#factors + 1] =\
    \ i\n      n = n / i\n    else\n      i = i + 1\n    end\n  end\n  return factors\n\
    end", "\tlocal function helper(n, factors)\n\t\tif n < 2 then\n\t\t\treturn factors\n\
    \t\tend\n\t\tfor i = 2, n do\n\t\t\tif n % i == 0 then\n\t\t\t\treturn helper(n\
    \ / i, mappend(i, factors))\n\t\t\tend\n\t\tend\n\tend\n\treturn helper(n, {})\n\
    end", "    local factors = {}\n    for p, exp in pairs(primes.sieve(n)) do\n \
    \       for i = 1, exp do\n            table.insert(factors, p)\n        end\n\
    \    end\n    return factors\nend", "\tlocal factors = {}\n\tlocal lastFactor\
    \ = nil\n\tlocal factorCount = 0\n\tfor i = 2, n/2 do\n\t\tif n % i == 0 then\n\
    \t\t\tif i == lastFactor then\n\t\t\t\tfactorCount = factorCount + 1\n\t\t\telse\n\
    \t\t\t\tif lastFactor ~= nil then\n\t\t\t\t\tfor j = 1, factorCount do\n\t\t\t\
    \t\t\ttable.insert(factors, lastFactor)\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\
    lastFactor = i\n\t\t\t\tfactorCount = 1\n\t\t\tend\n\t\tend\n\tend\n\tif lastFactor\
    \ ~= nil then\n\t\tfor j = 1, factorCount do\n\t\t\ttable.insert(factors, lastFactor)\n\
    \t\tend\n\tend\n\treturn factors\nend", "    local t = {}\n    for i = 2, n /\
    \ 2 do\n        while n % i == 0 do\n            n = n / i\n            t[#t +\
    \ 1] = i\n        end\n    end\n    if n > 1 then\n        t[#t + 1] = n\n   \
    \ end\n    return t\nend", "\tlocal factorization = {}\n\tlocal d = 2\n\tlocal\
    \ n = math.abs(n)\n\twhile d <= n do\n\t\tif n % d == 0 then\n\t\t\ttable.insert(factorization,\
    \ d)\n\t\t\tn = n / d\n\t\telse\n\t\t\td = d + 1\n\t\tend\n\tend\n\treturn factorization\n\
    end", "    assert(n >= 1, 'factors not defined for integers < 1')\n    local factors\
    \ = {}\n    for p, a in pairs(factorization(n)) do\n        for i = 1, a do\n\
    \            table.insert(factors, p)\n        end\n    end\n    return factors\n\
    end", "    local factors = {}\n    while n % 2 == 0 do\n        table.insert(factors,\
    \ 2)\n        n = n / 2\n    end\n    local limit = math.sqrt(n)\n    local divisor\
    \ = 3\n    while n > 1 and divisor <= limit do\n        while n % divisor == 0\
    \ do\n            table.insert(factors, divisor)\n            n = n / divisor\n\
    \        end\n        divisor = divisor + 2\n    end\n    if n > 1 then\n    \
    \    table.insert(factors, n)\n    end\n    return factors\nend", "\tlocal result\
    \ = {}\n\tif n <= 1 then\n\t\treturn result\n\tend\n\tlocal d = 2\n\tlocal i =\
    \ 0\n\twhile n > 1 do\n\t\ti = 0\n\t\twhile n % d == 0 do\n\t\t\tn = n / d\n\t\
    \t\ti = i + 1\n\t\tend\n\t\tif i > 0 then\n\t\t\tresult[#result + 1] = {d, i}\n\
    \t\tend\n\t\td = d + 1\n\tend\n\treturn result\nend", "  local factors = {}\n\
    \  local d = 2\n  while n > 1 do\n    if n % d == 0 then\n      table.insert(factors,\
    \ d)\n      n = n / d\n    else\n      d = d + 1\n    end\n  end\n  return factors\n\
    end", "  local factors = {}\n  for prime, power in pairs(factorize_iter(n)) do\n\
    \    for i = 1, power do\n      table.insert(factors, prime)\n    end\n  end\n\
    \  return factors\nend", "  local factors = {}\n  for _, p in ipairs(primes) do\n\
    \    if n <= 1 then\n      break\n    end\n    while n % p == 0 do\n      table.insert(factors,\
    \ p)\n      n = n / p\n    end\n  end\n  if n > 1 then\n    error('Failed to factorize:\
    \ ' .. n)\n  end\n  return factors\nend", "\tlocal result = {}\n\tlocal max =\
    \ math.floor(math.sqrt(n))\n\tfor i = 2, max do\n\t\twhile n % i == 0 do\n\t\t\
    \ttable.insert(result, i)\n\t\t\tn = n / i\n\t\tend\n\tend\n\tif n > 1 then\n\t\
    \ttable.insert(result, n)\n\tend\n\treturn result\nend", "\tlocal primfac = {}\n\
    \tlocal d = 2\n\twhile d*d <= n do\n\t\twhile (n % d) == 0 do\n\t\t\ttable.insert(primfac,\
    \ d)\n\t\t\tn = n / d\n\t\tend\n\t\td = d + 1\n\tend\n\tif n > 1 then\n\t\ttable.insert(primfac,\
    \ n)\n\tend\n\treturn primfac\nend", "\tlocal f = {}\n\tfor i = 2, n do\n\t\t\
    while n % i == 0 do\n\t\t\tf[#f + 1] = i\n\t\t\tn = n / i\n\t\tend\n\tend\n\t\
    return f\nend", "\tlocal primes = {}\n\tlocal count = 0\n\twhile true do\n\t\t\
    count = count + 1\n\t\tif isPrime(count) then\n\t\t\tprimes[#primes + 1] = count\n\
    \t\tend\n\t\tif count >= n then\n\t\t\tbreak\n\t\tend\n\tend\n\tlocal factors\
    \ = {}\n\tfor i = 1, #primes do\n\t\tif n % primes[i] == 0 then\n\t\t\twhile n\
    \ % primes[i] == 0 do\n\t\t\t\tfactors[#factors + 1] = primes[i]\n\t\t\t\tn =\
    \ n / primes[i]\n\t\t\tend\n\t\tend\n\tend\n\treturn factors\nend", '  if n <
    2 then return {} end', "\tlocal res = {}\n\tif n <= 1 then return res end\n\t\
    local last = nil\n\tfor i = 2, n do\n\t\tif n % i == 0 then\n\t\t\tn = n / i\n\
    \t\t\tif last ~= i then\n\t\t\t\tres[#res + 1] = i\n\t\t\t\tlast = i\n\t\t\tend\n\
    \t\t\tif n == 1 then break end\n\t\tend\n\tend\n\treturn res\nend", "  local factors\
    \ = {}\n  local d = 2\n  while n > 1 do\n    if n % d == 0 then\n      table.insert(factors,\
    \ d)\n      n = n / d\n    else\n      d = d + 1\n    end\n  end\n  return factors\n\
    end", "\tlocal factors = {}\n\tlocal p = 2\n\twhile n > 1 do\n\t\twhile n % p\
    \ == 0 do\n\t\t\tfactors[#factors + 1] = p\n\t\t\tn = n / p\n\t\tend\n\t\tp =\
    \ p + 1\n\tend\n\treturn factors\nend", "\tlocal factors = {}\n\tfor i = 2, n\
    \ do\n\t\twhile n % i == 0 do\n\t\t\ttable.insert(factors, i)\n\t\t\tn = n / i\n\
    \t\tend\n\tend\n\treturn factors\nend", "\tlocal factors = {}\n\tlocal d = 2\n\
    \twhile d * d <= n do\n\t\twhile n % d == 0 do\n\t\t\ttable.insert(factors, d)\n\
    \t\t\tn = n / d\n\t\tend\n\t\td = d + 1\n\tend\n\tif n > 1 then\n\t\ttable.insert(factors,\
    \ n)\n\tend\n\treturn factors\nend", "    local factors = {}\n    for i = 2, n\
    \ do\n        if isPrime(i) then\n            while n % i == 0 do\n          \
    \      n = n / i\n                table.insert(factors, i)\n            end\n\
    \        end\n    end\n    return factors\nend", "    if n <= 0 then return {}\
    \ end\n    local f = {}\n    while n % 2 == 0 do\n        f[2] = (f[2] or 0) +\
    \ 1\n        n = n / 2\n    end\n    for d = 3, math.sqrt(n), 2 do\n        while\
    \ n % d == 0 do\n            f[d] = (f[d] or 0) + 1\n            n = n / d\n \
    \       end\n    end\n    if n > 1 then\n        f[n] = (f[n] or 0) + 1\n    end\n\
    \    return f\nend", "    if n == 1 then\n        return {}\n    end\n    if n\
    \ == 2 then\n        return {2}\n    end\n    local p = 1\n    for i = 2, math.sqrt(n)\
    \ do\n        if n % i == 0 then\n            p = i\n            break\n     \
    \   end\n    end\n    local list = {}\n    if p == 1 then\n        table.insert(list,\
    \ n)\n    else\n        local l = factorize(n / p)\n        table.insert(list,\
    \ p)\n        for i = 1, #l do\n            table.insert(list, l[i])\n       \
    \ end\n    end\n    return list\nend", "  local p,a = 2,{}\n  while n > 1 do\n\
    \    if n % p == 0 then\n      n = n / p\n      a[#a+1] = p\n    else\n      p\
    \ = p + 1\n    end\n  end\n  return a\nend", "\tlocal result = {}\n\tlocal iter\
    \ = make_iter(primes())\n\twhile n ~= 1 do\n\t\tlocal divisor = iter()\n\t\tif\
    \ n % divisor == 0 then\n\t\t\tresult[#result + 1] = divisor\n\t\t\tn = n / divisor\n\
    \t\tend\n\tend\n\treturn result\nend", "\tlocal function go(n, acc)\n\t\tif primes[n]\
    \ then return {n}, acc end\n\t\tfor i,factor in ipairs(primes) do\n\t\t\tif n\
    \ % factor == 0 then\n\t\t\t\treturn go(n / factor, {factor, unpack(acc)})\n\t\
    \t\tend\n\t\tend\n\tend\n\tlocal factors, primes = go(n, {})\n\ttable.sort(factors)\n\
    \treturn factors\nend", "  if n == 1 then return {} end\n  local factors = {}\n\
    \  local root = math.sqrt(n)\n  for i = 2, root do\n    while n % i == 0 do\n\
    \      n = n / i\n      factors[#factors + 1] = i\n    end\n  end\n  if n > 1\
    \ then\n    factors[#factors + 1] = n\n  end\n  return factors\nend", "\tlocal\
    \ factors = {}\n\tlocal number = n\n\tlocal i = 2\n\trepeat\n\t\twhile number\
    \ % i == 0 do\n\t\t\tnumber = number / i\n\t\t\tfactors[#factors + 1] = i\n\t\t\
    end\n\t\ti = i + 1\n\tuntil number == 1\n\treturn factors\nend", "    local factors\
    \ = {}\n    local i = 2\n    while i <= n do\n        if n % i == 0 then\n   \
    \         n = n / i\n            factors[#factors + 1] = i\n        else\n   \
    \         i = i + 1\n        end\n    end\n    return factors\nend", "    local\
    \ t = {}\n    for i=2,n do\n        while n%i == 0 do\n            n = n/i\n \
    \           table.insert(t, i)\n        end\n    end\n    return t\nend", "  \
    \  -- Get all possible factors and count the number of times each of them can\
    \ be factored into the number\n    local factors = {}\n    for d = 2, n do\n \
    \       while n % d == 0 do\n            factors[d] = (factors[d] or 0) + 1\n\
    \            n = n / d\n        end\n    end\n    -- Convert to list of factors\n\
    \    local result = {}\n    for k, v in pairs(factors) do\n        for i = 1,\
    \ v do\n            table.insert(result, k)\n        end\n    end\n    return\
    \ result\nend", "  assert(n >= 1, \"n must be positive\")\n  local factors = {}\n\
    \  local k = 1\n  while n > 1 do\n    if n % k == 0 then\n      table.insert(factors,\
    \ k)\n      n = n / k\n    else\n      k = k + 1\n    end\n  end\n  return factors\n\
    end", "    if n < 2 then\n        return {}\n    end\n    local primeFactors =\
    \ {}\n    for divisor = 2, math.sqrt(n) do\n        while n % divisor == 0 do\n\
    \            n = n / divisor\n            table.insert(primeFactors, divisor)\n\
    \        end\n    end\n    if n > 1 then\n        table.insert(primeFactors, n)\n\
    \    end\n    return primeFactors\nend", "    local factors = {}\n    local function\
    \ helper(n, i)\n        while n % i == 0 do\n            n = n / i\n         \
    \   table.insert(factors, i)\n        end\n        if n == 1 then\n          \
    \  return factors\n        else\n            return helper(n, i + 1)\n       \
    \ end\n    end\n    return helper(n, 2)\nend", "    local factors = {}\n    for\
    \ p, c in factor_count(n) do\n        for i = 1, c do\n            table.insert(factors,\
    \ p)\n        end\n    end\n    return factors\nend", "\tlocal factors = {}\n\t\
    for i = 2, n do\n\t\twhile n % i == 0 do\n\t\t\ttable.insert(factors, i)\n\t\t\
    \tn = n / i\n\t\tend\n\tend\n\treturn factors\nend", "    if n == 1 then\n   \
    \     return {}\n    end\n    local number = n\n    local factor = 2\n    local\
    \ factors = {}\n    while number > 1 do\n        if number % factor == 0 then\n\
    \            number = number / factor\n            table.insert(factors, factor)\n\
    \        else\n            factor = factor + 1\n        end\n    end\n    return\
    \ factors\nend", '  if not n or n < 2 then return {} end', "  if n <= 1 then\n\
    \    return {n}\n  end\n  local factors = {}\n  for i = 2, n do\n    if n % i\
    \ == 0 then\n      local factor = factorize(i)\n      local factor_mult = factorize(n\
    \ / i)\n      if not is_prime(i) then\n        for j = 1, #factor do\n       \
    \   factors[#factors + 1] = factor[j]\n        end\n      else\n        factors[#factors\
    \ + 1] = i\n      end\n      if not is_prime(n / i) then\n        for j = 1, #factor_mult\
    \ do\n          factors[#factors + 1] = factor_mult[j]\n        end\n      else\n\
    \        factors[#factors + 1] = n / i\n      end\n      return factors\n    end\n\
    \  end\nend", "\tlocal factors = {}\n\tlocal function factorize_aux(n,ps)\n\t\t\
    local p = ps[1]\n\t\tif n == 1 then\n\t\t\treturn\n\t\telseif n % p == 0 then\n\
    \t\t\ttable.insert(factors,p)\n\t\t\tfactorize_aux(n/p,ps)\n\t\telse\n\t\t\tfactorize_aux(n,{unpack(ps,2)})\n\
    \t\tend\n\tend\n\tfactorize_aux(n,primes)\n\treturn factors\nend", "\tlocal factors\
    \ = {}\n\tif n == 1 then\n\t\treturn {1}\n\tend\n\twhile n % 2 == 0 do\n\t\tfactors[2]\
    \ = (factors[2] or 0) + 1\n\t\tn = n / 2\n\tend\n\tlocal p = 3\n\twhile n > 1\
    \ do\n\t\twhile n % p == 0 do\n\t\t\tfactors[p] = (factors[p] or 0) + 1\n\t\t\t\
    n = n / p\n\t\tend\n\t\tp = p + 2\n\tend\n\treturn factors\nend", "  local factors\
    \ = {}\n  local div = 2\n  while n > 1 do\n    if n % div == 0 then\n      factors[#factors\
    \ + 1] = div\n      n = n / div\n    else\n      div = div + 1\n    end\n  end\n\
    \  return factors\nend", "\tlocal t = {}\n\t\n\twhile true do\n\t\tlocal k = not\
    \ prime.isprime(n) and prime.first_factor(n) or n\n\t\ttable.insert(t, k)\n\t\t\
    n = n/k\n\t\tif n == 1 then break end\n\tend\n\t\n\treturn t\nend", "\tlocal function\
    \ helper(n, factor, primes, start_index)\n\t\tif n == 1 then\n\t\t\ttable.insert(factor,1)\n\
    \t\t\treturn factor\n\t\tend\n\t\tfor i = start_index, #primes do\n\t\t\tif n\
    \ % primes[i] == 0 then\n\t\t\t\tlocal new_n = n / primes[i]\n\t\t\t\ttable.insert(factor,\
    \ primes[i])\n\t\t\t\tif helper(new_n, factor, primes, i) then\n\t\t\t\t\treturn\
    \ factor\n\t\t\t\tend\n\t\t\t\ttable.remove(factor)\n\t\t\tend\n\t\tend\n\tend\n\
    \tlocal result = helper(n, {}, primes, 1)\n\tlocal calculated_value = 1\n\tfor\
    \ i = 1, #result do\n\t\tcalculated_value = calculated_value * result[i]\n\tend\n\
    \tif calculated_value ~= n then\n\t\treturn nil\n\tend\n\treturn result\nend",
  "    if not n or n < 1 then return {} end\n    local r = {};\n    while n % 2 ==\
    \ 0 do\n        r[2] = (r[2] or 0) + 1;\n        n = n / 2;\n    end\n    for\
    \ i = 3, math.sqrt(n), 2 do\n        while n % i == 0 do\n            r[i] = (r[i]\
    \ or 0) + 1;\n            n = n / i;\n        end\n    end\n    if n > 2 then\n\
    \        r[n] = (r[n] or 0) + 1;\n    end\n    return r;\nend", "    local factors\
    \ = {}\n    local d = 2", "\tlocal factors, primeFactor = {}, 2", "  local factors\
    \ = {}\n  for i = 2, math.sqrt(n) do\n    while n % i == 0 do\n      table.insert(factors,\
    \ i)\n      n = n / i\n    end\n  end\n  if n > 1 then\n    table.insert(factors,\
    \ n)\n  end\n  return factors\nend", "  local i = 2\n  local factors = {}\n  while\
    \ n > 1 do\n    if n % i == 0 then\n      n = n / i\n      factors[#factors +\
    \ 1] = i\n    else\n      i = i + 1\n    end\n  end\n  return factors\nend", " \
    \   assert(type(n) == \"number\", \"Incorrect number type for factorization\"\
    )\n    local factors = {}\n    if n < 2 then\n        return factors\n    end\n\
    \    local prime = next_prime(1)\n    while n > 1 do\n        if n % prime ==\
    \ 0 then\n            factors[#factors + 1] = prime\n            n = n / prime\n\
    \        else\n            prime = next_prime(prime)\n        end\n    end\n \
    \   return factors\nend", "\tlocal result = {}\n\tlocal divisor = 2\n\trepeat\n\
    \t\twhile n % divisor == 0 do\n\t\t\ttable.insert(result, divisor)\n\t\t\tn =\
    \ n / divisor\n\t\tend\n\t\tdivisor = divisor + 1\n\tuntil n == 1 or divisor >\
    \ n", "\tlocal primes = { [2] = 2 }\n\tlocal p = 0\n\tlocal factors = {}\n\tlocal\
    \ cur = n\n\t\n\t-- Find primes up to sqrt(n)\n\twhile p < cur do\n\t\tp = next(primes,\
    \ p)\n\t\tif not p then\n\t\t\tp = (p or 1) + 1\n\t\t\twhile not isPrime(p) do\n\
    \t\t\t\tp = p + 1\n\t\t\tend\n\t\t\tprimes[p] = p\n\t\tend\n\t\tif cur % p ==\
    \ 0 then\n\t\t\tfactors[#factors + 1] = p\n\t\t\tcur = cur / p\n\t\tend\n\tend\n\
    \t\n\treturn factors\nend", "\tlocal function is_prime(n)\n\t\tfor i = 2, n -\
    \ 1 do\n\t\t\tif n % i == 0 then\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\t\
    \treturn true\n\tend", "\tlocal res = {}\n\tif n > 1 then\n\t\tlocal function\
    \ helper(n, d)\n\t\t\tif n == 1 then\n\t\t\t\treturn\n\t\t\tend\n\t\t\tif n %\
    \ d == 0 then\n\t\t\t\ttable.insert(res, d)\n\t\t\t\thelper(n/d, d)\n\t\t\telse\n\
    \t\t\t\thelper(n, d+1)\n\t\t\tend\n\t\tend\n\t\thelper(n, 2)\n\tend\n\treturn\
    \ res\nend", "  local ret = {}\n  local p = 2\n  local np = 0\n  repeat\n    np\
    \ = n/p\n    if math.floor(np) == np then\n      ret[#ret+1] = p\n      n = np\n\
    \    else\n      p = p + 1\n    end\n  until n == 1\n  return ret\nend", "\tlocal\
    \ f = { }\n\tlocal function _factorize(n)\n\t\tlocal d = math.floor(math.sqrt(n))\n\
    \t\tfor i = 2, d do\n\t\t\tif n % i == 0 then\n\t\t\t\ttable.insert(f, i)\n\t\t\
    \t\t_factorize(n / i)\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\t\ttable.insert(f,\
    \ n)\n\tend\n\t_factorize(n)\n\treturn f\nend", "\tlocal factors = {}\n\tlocal\
    \ factor = 2\n\twhile n ~= 1 do\n\t\tif n % factor == 0 then\n\t\t\ttable.insert(factors,\
    \ factor)\n\t\t\tn = n / factor\n\t\telse\n\t\t\tfactor = factor + 1\n\t\tend\n\
    \tend\n\treturn factors\nend", "\t-- list of prime factors of n\n\tlocal prime_factors\
    \ = {}\n\t-- go through the prime numbers starting from 2 until n^0.5\n\tfor p\
    \ = 2, floor(sqrt(n)) do\n\t\t-- if p divides n then add p to the list of prime\
    \ factors\n\t\tif n % p == 0 then\n\t\t\t-- divide n by p until n is no longer\
    \ divisible by p\n\t\t\twhile n % p == 0 do\n\t\t\t\t-- add p to list of prime\
    \ factors\n\t\t\t\tappend(prime_factors, p)\n\t\t\t\t-- divide n by p\n\t\t\t\t\
    n = n / p\n\t\t\tend\n\t\tend\n\tend\n\t-- if n is greater than 1 and is prime,\
    \ add it to the list of prime factors\n\tif n > 1 then\n\t\tappend(prime_factors,\
    \ n)\n\tend\n\t-- return list of prime factors\n\treturn prime_factors\nend",
  "    local function try_factor(n, factor)\n        if n % factor == 0 then\n   \
    \         local factors = factorize(n/factor)\n            factors[factor] = (factors[factor]\
    \ or 0) + 1\n            return factors\n        end\n    end", "    local factors\
    \ = {}\n    while n ~= 1 do\n        local max_factor\n        for i=1,n do\n\
    \            if n % i == 0 then\n                max_factor = i\n            end\n\
    \        end\n        table.insert(factors, max_factor)\n        n = n / max_factor\n\
    \    end\n    return factors\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
