name: HumanEval_90_next_smallest
language: lua
prompt: "-- You are given a list of integers.\n-- Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n-- Return None if there is\
  \ no such element.\nlocal function next_smallest(lst)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = next_smallest\n\
  \    lu.assertEquals(candidate({1, 2, 3, 4, 5}), 2)\n    lu.assertEquals(candidate({5,\
  \ 1, 4, 3, 2}), 2)\n    lu.assertEquals(candidate({}), None)\n    lu.assertEquals(candidate({1,\
  \ 1}), None)\n    lu.assertEquals(candidate({1, 1, 1, 1, 0}), 1)\n    lu.assertEquals(candidate({1,\
  \ 1}), None)\n    lu.assertEquals(candidate({-35, 34, 12, -45}), -35)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local min, min2 = nil, nil\n    for i = 1, #lst do\n        if\
    \ lst[i] < min or min == nil then\n            min2 = min\n            min = lst[i]\n\
    \        elseif lst[i] < min2 or min2 == nil then\n            min2 = lst[i]\n\
    \        end\n    end\n    return min2\nend\nassert(next_smallest{3, 2, 1} ==\
    \ 2)\nassert(next_smallest{1, 2, 1} == 1)\nassert(next_smallest{1, 1, 2} == 1)\n\
    assert(next_smallest{4, -1, 2, 2} == -1)\nassert(next_smallest{3, 2, 1, 2} ==\
    \ 1)\nassert(next_smallest{2, 2, 2, 1} == 1)\nassert(next_smallest{2, 2, 2, 2}\
    \ == nil)\nassert(next_smallest{} == nil)", "    local min = lst[1]\n    local\
    \ next = min\n    for i=2,#lst do\n        if lst[i] < min then\n            next\
    \ = min\n            min = lst[i]\n        elseif lst[i] < next then\n       \
    \     next = lst[i]\n        end\n    end\n    return next\nend", "  local smallest,\
    \ secondsmallest\n  for _, e in ipairs(lst) do\n    if not smallest or e < smallest\
    \ then\n      secondsmallest = smallest\n      smallest = e\n    elseif not secondsmallest\
    \ or e < secondsmallest then\n      secondsmallest = e\n    end\n  end\n  return\
    \ secondsmallest\nend", "\t-- lst is a list of integers.\n\t-- Return the 2nd\
    \ smallest element of the list.\n\t-- Return None if there is no such element.\n\
    \tassert(type(lst) == \"table\")\n\tfor _, v in ipairs(lst) do\n\t\tassert(type(v)\
    \ == \"number\")\n\tend\n\t\n\tif #lst < 2 then\n\t\treturn nil\n\tend\n\t\n\t\
    local min, min2\n\tfor _, v in ipairs(lst) do\n\t\tif min2 == nil then\n\t\t\t\
    if min == nil then\n\t\t\t\tmin = v\n\t\t\telseif v < min then\n\t\t\t\tmin2 =\
    \ min\n\t\t\t\tmin = v\n\t\t\telse\n\t\t\t\tmin2 = v\n\t\t\tend\n\t\telseif v\
    \ < min2 then\n\t\t\tmin2 = v\n\t\tend\n\tend\n\t\n\treturn min2\nend", "  local\
    \ l = {}\n  for i, n in ipairs(lst) do\n    l[i] = n\n  end\n  local s, ss\n \
    \ for i, n in ipairs(l) do\n    if i == 1 then\n      s = n\n    elseif i == 2\
    \ then\n      if n < s then\n        ss = s\n        s = n\n      else\n     \
    \   ss = n\n      end\n    else\n      if n < s then\n        ss = s\n       \
    \ s = n\n      elseif n < ss then\n        ss = n\n      end\n    end\n  end\n\
    \  return ss\nend", "  table.sort(lst)\n  return lst[2]\nend", "    local smallest\
    \ = math.huge\n    local second_smallest = math.huge\n    for i, v in ipairs(lst)\
    \ do\n        if v < smallest then\n            second_smallest = smallest\n \
    \           smallest = v\n        elseif v < second_smallest then\n          \
    \  second_smallest = v\n        end\n    end\n    return second_smallest\nend",
  "  local min, second_min\n  for _, v in ipairs(lst) do\n    if not min or v < min\
    \ then\n      second_min = min\n      min = v\n    elseif v < second_min or not\
    \ second_min then\n      second_min = v\n    end\n  end\n  return second_min\n\
    end", "    local answer = nil\n    local smallest = math.huge\n    for _, v in\
    \ ipairs(lst) do\n        if v < smallest then\n            answer = smallest\n\
    \            smallest = v\n        elseif v < answer then\n            answer\
    \ = v\n        end\n    end\n    return answer\nend", "    if not lst then return\
    \ nil end\n    local min, min2\n    for _, v in ipairs(lst) do\n        if min\
    \ == nil or v < min then\n            min2 = min\n            min = v\n      \
    \  elseif min2 == nil or v < min2 then\n            min2 = v\n        end\n  \
    \  end\n    return min2\nend", "  -- TODO\nend", "    local sorted = {}\n    for\
    \ i = 1, #lst do\n        table.insert(sorted, lst[i])\n    end\n    table.sort(sorted)\n\
    \    return sorted[2]\nend", "  local min, tmp = math.huge, {}\n  for _, x in\
    \ ipairs(lst) do\n    min = math.min(min, x)\n  end\n  for _, x in ipairs(lst)\
    \ do\n    if x > min then\n      table.insert(tmp, x)\n    end\n  end\n  if #tmp\
    \ == 0 then\n    return nil\n  end\n  table.sort(tmp)\n  return tmp[1]\nend",
  "  local next_smallest\n  local smallest\n  for _, x in ipairs(lst) do\n    if not\
    \ smallest or x < smallest then\n      next_smallest = smallest\n      smallest\
    \ = x\n    elseif not next_smallest or x < next_smallest then\n      next_smallest\
    \ = x\n    end\n  end\n  return next_smallest\nend", "    local min, next = math.huge,\
    \ math.huge\n    for _, n in ipairs(lst) do\n        if n < min then\n       \
    \     next = min\n            min = n\n        elseif n < next then\n        \
    \    next = n\n        end\n    end\n    return next ~= math.huge and next or\
    \ nil\nend", "    local min1, min2\n    for i, v in ipairs(lst) do\n        if\
    \ not min1 or v < min1 then\n            min2 = min1\n            min1 = v\n \
    \       elseif not min2 or v < min2 then\n            min2 = v\n        end\n\
    \    end\n    return min2\nend\nassert(next_smallest({1, 2, 3, -1, 4}) == 2)\n\
    assert(next_smallest({2, 3, 4, 1}) == 2)\nassert(next_smallest({1, 2, 3, 4}) ==\
    \ 2)\nassert(next_smallest({1, 3, 2, 4}) == 2)\nassert(next_smallest({1, 2, 4,\
    \ 3}) == 2)\nassert(next_smallest({1, 2, 3}) == nil)\nassert(next_smallest({2,\
    \ 1}) == nil)\nassert(next_smallest({1}) == nil)\nassert(next_smallest({}) ==\
    \ nil)", "  local min, min2\n  for _, v in ipairs(lst) do\n    if min == nil or\
    \ v < min then\n      min2 = min\n      min = v\n    elseif min2 == nil or v <\
    \ min2 then\n      min2 = v\n    end\n  end\n  return min2\nend\nprint(next_smallest({1,\
    \ 2, 3, 4, 5}))", "    local m = math.huge\n    local n = math.huge\n    for _,\
    \ v in ipairs(lst) do\n        if v < m then\n            n = m\n            m\
    \ = v\n        elseif v < n then\n            n = v\n        end\n    end\n  \
    \  return n ~= math.huge and n or nil\nend", "  local smallest, smallest_idx =\
    \ lst[1], 1\n  local second_smallest = nil\n  for idx, val in ipairs(lst) do\n\
    \    if val < smallest then\n      second_smallest = smallest\n      smallest\
    \ = val\n      smallest_idx = idx\n    elseif val > smallest and (second_smallest\
    \ == nil or val < second_smallest) then\n      second_smallest = val\n    end\n\
    \  end\n  return second_smallest\nend", "  if #lst < 2 then return nil end\n \
    \ local smallest = math.huge\n  local second = math.huge\n  for _,i in ipairs(lst)\
    \ do\n    if i < smallest then\n      second = smallest\n      smallest = i\n\
    \    elseif i < second then\n      second = i\n    end\n  end\n  return second\n\
    end", "  assert(is_list(lst))\n  if #lst == 0 then return nil end\n  if #lst ==\
    \ 1 then return nil end\n  local smallest = math.huge\n  local second_smallest\
    \ = math.huge\n  for _, v in ipairs(lst) do\n    if v < smallest then\n      second_smallest\
    \ = smallest\n      smallest = v\n    elseif v < second_smallest then\n      second_smallest\
    \ = v\n    end\n  end\n  if second_smallest == math.huge then return nil end\n\
    \  return second_smallest\nend", "    local min = nil\n    local min2 = nil\n\
    \    for i,v in ipairs(lst) do\n        if min == nil or v < min then\n      \
    \      min2 = min\n            min = v\n        elseif min2 == nil or v < min2\
    \ then\n            min2 = v\n        end\n    end\n    return min2\nend", " \
    \   -- TODO: implement this function and return a value\n    return nil\nend",
  "  if not lst or #lst < 2 then return nil end\n  local min, sec_min = lst[1], lst[2]\n\
    \  if min > sec_min then min, sec_min = sec_min, min end\n  for i = 3, #lst do\n\
    \    local current = lst[i]\n    if current < min then\n      sec_min = min\n\
    \      min = current\n    elseif current < sec_min then\n      sec_min = current\n\
    \    end\n  end\n  return sec_min\nend", "  table.sort(lst)\n  local ret = lst[2]\n\
    \  return ret\nend", "    if not lst or #lst < 2 then\n        return nil\n  \
    \  end\n    local smallest = lst[1]\n    local next_smallest = lst[2]\n    for\
    \ i = 3, #lst do\n        if lst[i] < smallest then\n            next_smallest\
    \ = smallest\n            smallest = lst[i]\n        elseif lst[i] < next_smallest\
    \ then\n            next_smallest = lst[i]\n        end\n    end\n    return next_smallest\n\
    end", "    local min1, min2\n    for i = 1, #lst do\n        if not min1 or lst[i]\
    \ < min1 then\n            min2 = min1\n            min1 = lst[i]\n        elseif\
    \ not min2 or lst[i] < min2 then\n            min2 = lst[i]\n        end\n   \
    \ end\n    return min2\nend", "    if #lst < 2 then\n        return nil\n    end\n\
    \    local function find_smallest(lst, smallest, second_smallest)\n        if\
    \ #lst == 0 then\n            return second_smallest\n        end\n        local\
    \ head = lst[1]\n        local tail = lst[2]\n        if head < smallest then\n\
    \            second_smallest = smallest\n            smallest = head\n       \
    \ elseif head < second_smallest then\n            second_smallest = head\n   \
    \     end\n        return find_smallest(tail, smallest, second_smallest)\n   \
    \ end\n    return find_smallest(lst, lst[1], lst[2])\nend", "    local smallest,\
    \ next_smallest\n    for _, x in ipairs(lst) do\n        if smallest == nil or\
    \ x < smallest then\n            next_smallest = smallest\n            smallest\
    \ = x\n        elseif next_smallest == nil or x < next_smallest then\n       \
    \     next_smallest = x\n        end\n    end\n    return next_smallest\nend",
  "    local function fn(x, y)\n        if x > y then\n            return y\n    \
    \    else\n            return x\n        end\n    end\n    table.sort(lst, fn)\n\
    \    if #lst < 2 then\n        return nil\n    else\n        return lst[2]\n \
    \   end\nend", "  if #lst < 2 then return nil end\n  local min = lst[1]\n  local\
    \ min2 = lst[2]\n  if min2 < min then\n    min, min2 = min2, min\n  end\n  for\
    \ i = 3, #lst do\n    local x = lst[i]\n    if x < min then\n      min2 = min\n\
    \      min = x\n    elseif x < min2 then\n      min2 = x\n    end\n  end\n  return\
    \ min2\nend", "    local smallest, next_smallest = math.huge, math.huge\n    for\
    \ i = 1, #lst do\n        if lst[i] < smallest then\n            next_smallest\
    \ = smallest\n            smallest = lst[i]\n        elseif lst[i] < next_smallest\
    \ then\n            next_smallest = lst[i]\n        end\n    end\n    return next_smallest\n\
    end", "  local elems = {}\n  for _, elem in ipairs(lst) do\n    table.insert(elems,\
    \ elem)\n  end\n  table.sort(elems)\n  return elems[2]\nend", "    local sorted\
    \ = table.sort(lst)\n    for i, v in ipairs(sorted) do\n        if sorted[i+1]\
    \ then\n            return sorted[i+1]\n        end\n    end\n    return nil\n\
    end", "    local min, min2 = math.huge, math.huge\n    for _, v in ipairs(lst)\
    \ do\n        if v < min then\n            min2 = min\n            min = v\n \
    \       elseif v < min2 then\n            min2 = v\n        end\n    end\n   \
    \ return min2\nend", "    local res\n    local prev = math.huge\n    for _,v in\
    \ ipairs(lst) do\n        if v < prev then\n            res = prev\n         \
    \   prev = v\n        elseif v < res then\n            res = v\n        end\n\
    \    end\n    return res ~= math.huge and res or nil\nend", "    local min = math.min(unpack(lst))\n\
    \    for _, val in ipairs(lst) do\n        if val ~= min then\n            return\
    \ math.min(min, val)\n        end\n    end\n    return nil\nend\nassert(next_smallest({4,\
    \ 2, 1, 5, 0}) == 0)\nassert(next_smallest({4, 2, 1, 5, 0, 7}) == 1)\nassert(next_smallest({1,\
    \ 2, 3, 4, 5}) == 2)\nassert(next_smallest({5, 4, 3, 2, 1}) == nil)", "    if\
    \ #lst < 2 then\n        return nil\n    end\n    if #lst == 2 then\n        return\
    \ lst[1] == math.min(lst[1], lst[2]) and lst[2] or lst[1]\n    end\n    local\
    \ min = math.min(lst[1], lst[2])\n    local nxt_min = math.max(lst[1], lst[2])\n\
    \    for i = 3, #lst do\n        if lst[i] < min then\n            nxt_min = min\n\
    \            min = lst[i]\n        elseif lst[i] < nxt_min then\n            nxt_min\
    \ = lst[i]\n        end\n    end\n    return nxt_min\nend", "  local min = 0\n\
    \  local min2 = 0\n  for k, v in pairs(lst) do\n    if v < min then\n      min2\
    \ = min\n      min = v\n    elseif v < min2 then\n      min2 = v\n    end\n  end\n\
    \  return min2\nend", "    if not lst then return nil end\n    local min = math.min(unpack(lst))\n\
    \    local next_min = math.max(unpack(lst))\n    for _, e in ipairs(lst) do\n\
    \        if e > min and e < next_min then\n            next_min = e\n        end\n\
    \    end\n    if next_min == math.max(unpack(lst)) then\n        return nil\n\
    \    else\n        return next_min\n    end\nend", "    if not lst then return\
    \ nil end\n    local _, min_ind, min_val = next(lst)\n    local _, sec_min_ind,\
    \ sec_min_val = next(lst, min_ind)\n    for i, v in next, lst, sec_min_ind do\n\
    \        if v < min_val then\n            sec_min_val = min_val\n            sec_min_ind\
    \ = min_ind\n            min_val = v\n            min_ind = i\n        elseif\
    \ v < sec_min_val then\n            sec_min_val = v\n            sec_min_ind =\
    \ i\n        end\n    end\n    return sec_min_val\nend", "    local smallest,\
    \ next_smallest = math.huge, math.huge\n    for i = 1, #lst do\n        if lst[i]\
    \ < smallest then\n            next_smallest = smallest\n            smallest\
    \ = lst[i]\n        elseif lst[i] < next_smallest then\n            next_smallest\
    \ = lst[i]\n        end\n    end\n    return next_smallest ~= math.huge and next_smallest\
    \ or nil\nend", "\tlocal smallest, smallest2 = lst[1], nil\n\tfor _, v in ipairs(lst)\
    \ do\n\t\tif v < smallest then\n\t\t\tsmallest2 = smallest\n\t\t\tsmallest = v\n\
    \t\telseif v < smallest2 or smallest2 == nil then\n\t\t\tsmallest2 = v\n\t\tend\n\
    \tend\n\treturn smallest2\nend", "    local function smallest(x, y)\n        if\
    \ x < y then\n            return x\n        else\n            return y\n     \
    \   end\n    end\n    if #lst < 2 then\n        return nil\n    end\n    local\
    \ smallest = lst[1]\n    local second_smallest = lst[2]\n    if second_smallest\
    \ < smallest then\n        smallest = second_smallest\n        second_smallest\
    \ = lst[1]\n    end\n    for i = 3, #lst do\n        if lst[i] < smallest then\n\
    \            second_smallest = smallest\n            smallest = lst[i]\n     \
    \   elseif lst[i] < second_smallest then\n            second_smallest = lst[i]\n\
    \        end\n    end\n    return second_smallest\nend", "  if #lst < 2 then return\
    \ nil end\n  local a, b = table.remove(lst, 1), table.remove(lst, 1)\n  if a <\
    \ b then return a end\n  return b\nend", "  -- make sure the list is not empty\n\
    \  if #lst == 0 then return nil end\n  -- sort the list in ascending order\n \
    \ local sorted = {}\n  for _, v in ipairs(lst) do\n    table.insert(sorted, v)\n\
    \  end\n  table.sort(sorted)\n  -- look up the index of the smallest element\n\
    \  local i = 1\n  while sorted[i] ~= lst[1] do\n    i = i + 1\n  end\n  -- return\
    \ the next element if it exists\n  if i + 1 <= #sorted then\n    return sorted[i\
    \ + 1]\n  else\n    return nil\n  end\nend", "\tlocal min_one = math.huge\n\t\
    local min_two = math.huge\n\tlocal n = 0\n\twhile n < #lst do\n\t\tlocal val =\
    \ lst[n]\n\t\tif val < min_one then\n\t\t\tmin_two = min_one\n\t\t\tmin_one =\
    \ val\n\t\telseif val < min_two then\n\t\t\tmin_two = val\n\t\tend\n\t\tn = n\
    \ + 1\n\tend\n\tif min_two == math.huge then\n\t\treturn nil\n\tend\n\treturn\
    \ min_two\nend", "    local len = #lst\n    if len < 2 then\n        return nil\n\
    \    end\n    local i = 1\n    while i < len do\n        if lst[i] > lst[i + 1]\
    \ then\n            return lst[i + 1]\n        end\n        i = i + 1\n    end\n\
    \    return nil\nend", "    local min, min2\n    for _, n in ipairs(lst) do\n\
    \        if n < min or min == nil then\n            min2 = min\n            min\
    \ = n\n        elseif n < min2 or min2 == nil then\n            min2 = n\n   \
    \     end\n    end\n    return min2\nend", "  if #lst < 2 then return nil end\n\
    \  local min_v,min_idx,small_v,small_idx=0x7FFFFFFF,0,0x7FFFFFFF,0\n  for i=1,#lst\
    \ do\n    if lst[i] < min_v then\n      small_v,small_idx = min_v,min_idx\n  \
    \    min_v,min_idx = lst[i],i\n    elseif lst[i] < small_v then\n      small_v,small_idx\
    \ = lst[i],i\n    end\n  end\n  return small_v\nend", "  if #lst < 2 then return\
    \ nil end\n  local min, min2\n  for _, v in ipairs(lst) do\n    if not min or\
    \ v < min then\n      min2 = min\n      min = v\n    elseif not min2 or v < min2\
    \ then\n      min2 = v\n    end\n  end\n  return min2\nend", "  local mn = math.min(unpack(lst))\n\
    \  for _,x in ipairs(lst) do\n    if x > mn then return x end\n  end\nend", " \
    \ table.sort(lst)\n  return lst[2]\nend", "  local k = lst[1]\n  local m = k\n\
    \  for i = 2, #lst do\n    if lst[i] < k then\n      m = k\n      k = lst[i]\n\
    \    elseif lst[i] < m then\n      m = lst[i]\n    end\n  end\n  return m\nend",
  "  local smallest = math.huge\n  local next_smallest = math.huge\n  for i = 1, #lst\
    \ do\n    if lst[i] < smallest then\n      next_smallest = smallest\n      smallest\
    \ = lst[i]\n    elseif lst[i] < next_smallest then\n      next_smallest = lst[i]\n\
    \    end\n  end\n  return next_smallest == math.huge and nil or next_smallest\n\
    end", "  local min = math.min(unpack(lst))\n  local min_i = lst[1]\n  local min2\
    \ = min\n  local min2_i = min_i\n  for i,v in ipairs(lst) do\n    if v < min then\n\
    \      min2 = min\n      min_i = min_i\n      min = v\n      min_i = i\n    elseif\
    \ v < min2 then\n      min2 = v\n      min2_i = i\n    end\n  end\n  if min_i\
    \ == min2_i then\n    return nil\n  else\n    return min2\n  end\nend", "    local\
    \ min = math.huge\n    local secondMin = math.huge\n    for _, v in ipairs(lst)\
    \ do\n        if v < min then\n            secondMin = min\n            min =\
    \ v\n        elseif v < secondMin then\n            secondMin = v\n        end\n\
    \    end\n    return secondMin == math.huge and nil or secondMin\nend", "  local\
    \ len = #lst\n  if len == 0 then return nil end\n  local min, min_index = lst[1],\
    \ 1\n  local smin, smin_index = min, min_index\n  for i = 2, len do\n    local\
    \ e = lst[i]\n    if e < min then\n      smin, smin_index = min, min_index\n \
    \     min, min_index = e, i\n    elseif e < smin then\n      smin, smin_index\
    \ = e, i\n    end\n  end\n  return smin, smin_index\nend", "    if #lst < 2 then\n\
    \        return nil\n    end\n    local min = lst[1]\n    local min_i = 1\n  \
    \  local next_min = lst[2]\n    local next_min_i = 2\n    for i = 3, #lst do\n\
    \        if lst[i] < min then\n            next_min = min\n            next_min_i\
    \ = min_i\n            min = lst[i]\n            min_i = i\n        elseif lst[i]\
    \ < next_min then\n            next_min = lst[i]\n            next_min_i = i\n\
    \        end\n    end\n    return next_min, next_min_i\nend", "  local t = table.pack(table.unpack(lst))\n\
    \  table.sort(t)\n  return t[2]\nend", "  table.sort(lst)\n  return lst[2]\nend",
  "    local mn1, mn2 = math.huge, math.huge\n    for _, x in ipairs(lst) do\n   \
    \     if x <= mn1 then\n            mn2 = mn1\n            mn1 = x\n        elseif\
    \ x < mn2 then\n            mn2 = x\n        end\n    end\n    return mn2\nend",
  "    local min, second_min = math.huge, math.huge\n    for _, el in ipairs(lst)\
    \ do\n        if el < min then\n            second_min = min\n            min\
    \ = el\n        elseif el < second_min then\n            second_min = el\n   \
    \     end\n    end\n    return second_min\nend", "  local l1, l2, curr\n  for\
    \ i = 1, #lst do\n    curr = lst[i]\n    if not l1 or curr < l1 then\n      l2\
    \ = l1\n      l1 = curr\n    elseif not l2 or curr < l2 then\n      l2 = curr\n\
    \    end\n  end\n  return l2\nend", "    local min = math.min(unpack(lst))\n \
    \   local second_min\n    for i, v in ipairs(lst) do\n        if v > min then\n\
    \            second_min = v\n            break\n        end\n    end\n    for\
    \ i, v in ipairs(lst) do\n        if v < second_min and v > min then\n       \
    \     second_min = v\n        end\n    end\n    return second_min\nend", "  assert(type(lst)\
    \ == 'table', 'lst must be a table')\n  assert(lst[1], 'lst must not be empty')\n\
    \  local s, i = lst[1], 2\n  for _, v in ipairs(lst) do\n    if v < s then\n \
    \     s, i = v, 1\n    elseif v > s and (i == 2 or v < lst[i]) then\n      i =\
    \ 2\n    end\n  end\n  return i == 2 and lst[i] or nil\nend", "  local min = math.huge\n\
    \  local second = math.huge\n  for _, v in ipairs(lst) do\n    if v < min then\n\
    \      second = min\n      min = v\n    elseif v < second then\n      second =\
    \ v\n    end\n  end\n  return second == math.huge and nil or second\nend", " \
    \   local smallest = math.huge\n    local second_smallest\n    for i, v in ipairs(lst)\
    \ do\n        if v < smallest then\n            second_smallest = smallest\n \
    \           smallest = v\n        elseif v < second_smallest then\n          \
    \  second_smallest = v\n        end\n    end\n    return second_smallest\nend",
  "  local min = math.huge\n  local min_min = math.huge\n  for i = 1, #lst do\n  \
    \  if lst[i] < min then\n      min_min = min\n      min = lst[i]\n    elseif lst[i]\
    \ < min_min then\n      min_min = lst[i]\n    end\n  end\n  return min_min\nend",
  "    assertx.is_table(lst)\n    local min = lst[1]\n    local next = nil\n    for\
    \ i = 2, #lst do\n        if lst[i] < min then\n            next = min\n     \
    \       min = lst[i]\n        elseif lst[i] < next or next == nil then\n     \
    \       next = lst[i]\n        end\n    end\n    return next\nend", "    if #lst\
    \ == 0 then\n        return nil\n    end\n    if #lst == 1 then\n        return\
    \ nil\n    end\n    if #lst == 2 then\n        if lst[1] < lst[2] then\n     \
    \       return lst[2]\n        else\n            return lst[1]\n        end\n\
    \    end\n    local max = math.max(unpack(lst))\n    local min = math.min(unpack(lst))\n\
    \    if min == max then\n        return nil\n    end\n    local min_table = {}\n\
    \    for i = 1, #lst do\n        if lst[i] == min then\n            min_table[#min_table\
    \ + 1] = i\n        end\n    end\n    if #min_table == 1 then\n        return\
    \ min\n    end\n    local new_lst = {}\n    for i = 1, #lst do\n        if i ~=\
    \ min_table[1] then\n            new_lst[#new_lst + 1] = lst[i]\n        end\n\
    \    end\n    return next_smallest(new_lst)\nend", "    -- TODO: Implement\nend",
  "    if #lst < 2 then\n        return nil\n    end\n    local min, min2 = math.min(lst[1],\
    \ lst[2]), math.max(lst[1], lst[2])\n    for i = 3, #lst do\n        if lst[i]\
    \ < min then\n            min2 = min\n            min = lst[i]\n        elseif\
    \ lst[i] < min2 then\n            min2 = lst[i]\n        end\n    end\n    return\
    \ min2\nend", "  local min = lst[1]\n  local min2 = nil\n  for i = 2, #lst do\n\
    \    if lst[i] < min then\n      min2 = min\n      min = lst[i]\n    elseif not\
    \ min2 or lst[i] < min2 then\n      min2 = lst[i]\n    end\n  end\n  return min2\n\
    end", "    if #lst < 2 then\n        return nil\n    end\n    local smallest =\
    \ math.huge\n    local smallest_idx = 0\n    local second_smallest = math.huge\n\
    \    local second_smallest_idx = 0\n    for i, v in ipairs(lst) do\n        if\
    \ v < smallest then\n            second_smallest = smallest\n            second_smallest_idx\
    \ = smallest_idx\n            smallest = v\n            smallest_idx = i\n   \
    \     elseif v < second_smallest then\n            second_smallest = v\n     \
    \       second_smallest_idx = i\n        end\n    end\n    if second_smallest\
    \ == math.huge then\n        return nil\n    end\n    return second_smallest,\
    \ second_smallest_idx\nend", "    local min = lst[1]\n    local min2 = nil\n \
    \   for _, v in ipairs(lst) do\n        if v < min then\n            min2 = min\n\
    \            min = v\n        elseif min2 == nil or v < min2 then\n          \
    \  min2 = v\n        end\n    end\n    return min2\nend", "  if #lst < 2 then\
    \ return nil end\n  local a,b,i = math.huge,math.huge,0\n  while i < #lst do\n\
    \    local n = lst[i]\n    if n < a then a,b = n,a\n    elseif n < b then b =\
    \ n end\n    i = i + 1\n  end\n  return b\nend", "    table.sort(lst)\n    return\
    \ lst[2]\nend", "    local l = #lst\n    if l == 0 then return nil end\n    if\
    \ l == 1 then return nil end\n    if l == 2 then return lst[2] end\n    local\
    \ first = lst[1]\n    local second = lst[2]\n    for i = 3, l do\n        if first\
    \ <= lst[i] and second >= lst[i] then\n            second = lst[i]\n        end\n\
    \    end\n    return second\nend", "    local min, min2\n    for _, v in ipairs(lst)\
    \ do\n        if not min or v < min then\n            min2 = min\n           \
    \ min = v\n        elseif not min2 or v < min2 then\n            min2 = v\n  \
    \      end\n    end\n    return min2\nend", "  if #lst < 2 then return nil end\n\
    \  table.sort(lst)\n  return lst[2]\nend", "  if #lst < 2 then return nil end\n\
    \  local tmp = lst[1]\n  local res = math.huge\n  for i=2,#lst do\n    if lst[i]<tmp\
    \ then\n      res = tmp\n      tmp = lst[i]\n    elseif lst[i]<res then\n    \
    \  res = lst[i]\n    end\n  end\n  return res==math.huge and nil or res\nend",
  "    if #lst < 2 then\n        return nil\n    end\n    local smallest = lst[1]\n\
    \    local next_smallest = nil\n    for _, num in ipairs(lst) do\n        if num\
    \ < smallest then\n            next_smallest = smallest\n            smallest\
    \ = num\n        elseif num < next_smallest or next_smallest == nil then\n   \
    \         next_smallest = num\n        end\n    end\n    return next_smallest\n\
    end", "    local max, second_max = math.mininteger, math.mininteger\n    for _,\
    \ v in ipairs(lst) do\n        if v > max then\n            second_max = max\n\
    \            max = v\n        elseif v > second_max then\n            second_max\
    \ = v\n        end\n    end\n    return second_max == math.mininteger and nil\
    \ or second_max\nend", "  --\nend", "    local elem = math.huge\n    local smallest\
    \ = math.huge\n    for _, val in ipairs(lst) do\n        if val < elem then\n\
    \            smallest = elem\n            elem = val\n        elseif val < smallest\
    \ then\n            smallest = val\n        end\n    end\n    return smallest\
    \ ~= math.huge and smallest or nil\nend", "  local min = nil\n  local nxt = nil\n\
    \  for _, i in ipairs(lst) do\n    if min == nil or i < min then\n      nxt =\
    \ min\n      min = i\n    elseif nxt == nil or i < nxt then\n      nxt = i\n \
    \   end\n  end\n  return nxt\nend", "  local smallest = math.huge\n  local result\
    \ = nil\n  for _, e in ipairs(lst) do\n    if e < smallest then\n      smallest\
    \ = e\n    elseif e < result or result == nil then\n      result = e\n    end\n\
    \  end\n  return result\nend", "    if not lst or #lst < 2 then\n        return\
    \ nil\n    end\n    local smallest, next_smallest = math.huge, math.huge\n   \
    \ for _, el in ipairs(lst) do\n        if el < smallest then\n            next_smallest\
    \ = smallest\n            smallest = el\n        elseif el < next_smallest then\n\
    \            next_smallest = el\n        end\n    end\n    return next_smallest\n\
    end", "    local min = math.huge\n    local smin = math.huge\n    for _, val in\
    \ ipairs(lst) do\n        if val <= min then\n            smin = min\n       \
    \     min = val\n        elseif val < smin then\n            smin = val\n    \
    \    end\n    end\n    return smin == math.huge and nil or smin\nend", "    local\
    \ smallest, second_smallest = math.huge, math.huge\n    for i = 1, #lst do\n \
    \       if lst[i] < smallest then\n            second_smallest = smallest\n  \
    \          smallest = lst[i]\n        elseif lst[i] < second_smallest then\n \
    \           second_smallest = lst[i]\n        end\n    end\n    return (second_smallest\
    \ ~= math.huge) and second_smallest or nil\nend", "    assertx.is_table(lst)\n\
    \    local min = math.huge\n    local min2 = math.huge\n    for _, v in ipairs(lst)\
    \ do\n        if v < min then\n            min2 = min\n            min = v\n \
    \       elseif v < min2 then\n            min2 = v\n        end\n    end\n   \
    \ if min2 == math.huge then\n        return nil\n    end\n    return min2\nend",
  "    local min = math.min(unpack(lst))\n    local secondMin = math.max(unpack(lst))\n\
    \    for _, e in ipairs(lst) do\n        if e ~= min and e < secondMin then\n\
    \            secondMin = e\n        end\n    end\n    return (secondMin ~= math.max(unpack(lst)))\
    \ and secondMin or nil\nend", "    local min, min2, n = math.huge, math.huge,\
    \ 0\n    for _, v in ipairs(lst) do\n        if v < min then\n            min2\
    \ = min\n            min = v\n        elseif v < min2 then\n            min2 =\
    \ v\n        end\n        n = n + 1\n    end\n    return n >= 2 and min2 or nil\n\
    end", "  if #lst == 0 then return nil end\n  if #lst == 1 then return nil end\n\
    \  if #lst == 2 then return math.min(lst[1], lst[2]) end\n  local m1, m2\n  if\
    \ lst[1] < lst[2] then\n    m1, m2 = lst[1], lst[2]\n  else\n    m1, m2 = lst[2],\
    \ lst[1]\n  end\n  for i = 3, #lst do\n    if lst[i] < m1 then\n      m2 = m1\n\
    \      m1 = lst[i]\n    elseif lst[i] < m2 then\n      m2 = lst[i]\n    end\n\
    \  end\n  return m2\nend", "    local min_value, min_2nd_value = math.huge, math.huge\n\
    \    for _, value in ipairs(lst) do\n        if value < min_value then\n     \
    \       min_2nd_value = min_value\n            min_value = value\n        elseif\
    \ value < min_2nd_value then\n            min_2nd_value = value\n        end\n\
    \    end\n    return min_2nd_value == math.huge and nil or min_2nd_value\nend\n\
    assert(next_smallest({6, 1, 4, 2, 5, 3}) == 2)\nassert(next_smallest({1, 5, 4,\
    \ 2, 3}) == 2)\nassert(next_smallest({2, 3, 4, 5}) == 3)\nassert(next_smallest({2,\
    \ 3, 4, 1}) == 2)\nassert(next_smallest({1, 2, 3, 4}) == 2)\nassert(next_smallest({1,\
    \ 2, 3}) == 2)\nassert(next_smallest({1, 1, 2}) == 1)\nassert(next_smallest({1,\
    \ 2, 1}) == 1)\nassert(next_smallest({1, 1, 1}) == nil)\nassert(next_smallest({})\
    \ == nil)\nprint('OK')", "  local smallest = math.huge\n  local second_smallest\
    \ = math.huge\n  for _, v in ipairs(lst) do\n    if v < smallest then\n      second_smallest\
    \ = smallest\n      smallest = v\n    elseif v < second_smallest then\n      second_smallest\
    \ = v\n    end\n  end\n  return second_smallest\nend", "  local smallest = math.huge\n\
    \  local next = math.huge\n  for _, v in ipairs(lst) do\n    if v < smallest then\n\
    \      next = smallest\n      smallest = v\n    elseif v < next then\n      next\
    \ = v\n    end\n  end\n  return next\nend", "  table.sort(lst)\n  return lst[2]\n\
    end", "    local min, min2 = math.huge, math.huge\n    for i = 1, #lst do\n  \
    \      if lst[i] < min then\n            min2 = min\n            min = lst[i]\n\
    \        elseif lst[i] < min2 then\n            min2 = lst[i]\n        end\n \
    \   end\n    return min2 ~= math.huge and min2 or nil\nend", "\tif not lst then\
    \ return nil end\n\tif #lst < 2 then return nil end\n\tlocal smallest, second_smallest\
    \ = math.huge, math.huge\n\tfor _, v in ipairs(lst) do\n\t\tif v < smallest then\n\
    \t\t\tsecond_smallest = smallest\n\t\t\tsmallest = v\n\t\telseif v < second_smallest\
    \ then\n\t\t\tsecond_smallest = v\n\t\tend\n\tend\n\treturn second_smallest ==\
    \ math.huge and nil or second_smallest\nend", "  local h = lst[1]\n  local n =\
    \ h\n  for i = 2, #lst do\n    local v = lst[i]\n    if v > h then\n      if v\
    \ < n then\n        n = v\n      end\n    else\n      h = v\n      n = h\n   \
    \ end\n  end\n  return n\nend", "    table.sort(lst)\n    return lst[2]\nend",
  "  local n = table.remove(lst, 1)\n  if n == nil then return nil end\n  local n2\
    \ = math.huge\n  for _, elem in ipairs(lst) do\n    if elem < n and elem < n2\
    \ then\n      n2 = elem\n    end\n  end\n  return n2\nend", "  local smallest\
    \ = lst[1]\n  local count = 0\n  for i, v in ipairs(lst) do\n    if v < smallest\
    \ then\n      smallest = v\n      count = 0\n    elseif v == smallest then\n \
    \     count = count + 1\n    end\n  end\n  if count == 0 then\n    smallest =\
    \ nil\n  end\n  return smallest\nend", "    local smallest, second_smallest =\
    \ math.huge, math.huge\n    for _, x in ipairs(lst) do\n        if x < smallest\
    \ then\n            second_smallest = smallest\n            smallest = x\n   \
    \     elseif x < second_smallest then\n            second_smallest = x\n     \
    \   end\n    end\n    return second_smallest == math.huge and nil or second_smallest\n\
    end", "\tif not lst then return nil end\n\tif #lst == 0 then return nil end\n\t\
    if #lst == 1 then return nil end\n\tlocal smallest = math.huge\n\tlocal next_smallest\
    \ = nil\n\tfor _, v in ipairs(lst) do\n\t\tif v < smallest then\n\t\t\tnext_smallest\
    \ = smallest\n\t\t\tsmallest = v\n\t\telseif v < next_smallest and v > smallest\
    \ then\n\t\t\tnext_smallest = v\n\t\tend\n\tend\n\treturn next_smallest\nend",
  "  local curr = math.huge\n  local result = math.huge\n  for _, v in ipairs(lst)\
    \ do\n    if v < curr then\n      result = curr\n      curr = v\n    elseif v\
    \ < result then\n      result = v\n    end\n  end\n  return result ~= math.huge\
    \ and result or nil\nend", "  local min, min2 = math.huge, math.huge\n  for i\
    \ = 1, #lst do\n    if lst[i] < min then\n      min2 = min\n      min = lst[i]\n\
    \    elseif lst[i] < min2 then\n      min2 = lst[i]\n    end\n  end\n  return\
    \ min2 == math.huge and nil or min2\nend", "    local min = math.min(unpack(lst))\n\
    \    local result\n    for _, e in ipairs(lst) do\n        if e ~= min then\n\
    \            if not result or e < result then\n                result = e\n  \
    \          end\n        end\n    end\n    return result\nend", "    local small,\
    \ small2 = math.huge, math.huge\n    for _, v in ipairs(lst) do\n        if v\
    \ < small then\n            small2 = small\n            small = v\n        elseif\
    \ v < small2 then\n            small2 = v\n        end\n    end\n    return small2\
    \ == math.huge and nil or small2\nend", "  local smallest = math.huge\n  local\
    \ next_smallest = math.huge\n  for _, n in ipairs(lst) do\n    if n < smallest\
    \ then\n      next_smallest = smallest\n      smallest = n\n    elseif n < next_smallest\
    \ then\n      next_smallest = n\n    end\n  end\n  return next_smallest ~= math.huge\
    \ and next_smallest or nil\nend", "    local smallest = math.huge\n    local second\
    \ = math.huge\n    for _, v in ipairs(lst) do\n        if v < smallest then\n\
    \            second = smallest\n            smallest = v\n        elseif v < second\
    \ then\n            second = v\n        end\n    end\n    return second\nend",
  "    if #lst < 2 then\n        return nil\n    end\n    local smallest = math.min(unpack(lst))\n\
    \    for i, v in ipairs(lst) do\n        if v == smallest then\n            table.remove(lst,\
    \ i)\n            return math.min(unpack(lst))\n        end\n    end\nend", " \
    \   if not lst or not next(lst) then\n        return nil\n    end\n    local min,\
    \ second_min = math.min(unpack(lst))\n    for _, elem in ipairs(lst) do\n    \
    \    if elem > min and elem < second_min then\n            second_min = elem\n\
    \        end\n    end\n    return second_min\nend", "    local small, nextSmall\
    \ = math.huge, math.huge\n    for i, v in ipairs(lst) do\n        if v < small\
    \ then\n            nextSmall = small\n            small = v\n        elseif v\
    \ < nextSmall then\n            nextSmall = v\n        end\n    end\n    return\
    \ nextSmall == math.huge and nil or nextSmall\nend", "    local smallest = math.huge\n\
    \    local next_smallest = math.huge\n    for _, x in ipairs(lst) do\n       \
    \ if x < smallest then\n            next_smallest = smallest\n            smallest\
    \ = x\n        elseif x < next_smallest then\n            next_smallest = x\n\
    \        end\n    end\n    return next_smallest ~= math.huge and next_smallest\
    \ or nil\nend", "  -- your code here\nend", "    local min, min2\n    for _, v\
    \ in ipairs(lst) do\n        if not min or v < min then\n            min2 = min\n\
    \            min = v\n        elseif not min2 or v < min2 then\n            min2\
    \ = v\n        end\n    end\n    return min2\nend", "    local min, min2 = math.huge,\
    \ math.huge\n    for _, n in ipairs(lst) do\n        if n < min then\n       \
    \     min2 = min\n            min = n\n        elseif n < min2 then\n        \
    \    min2 = n\n        end\n    end\n    return min2\nend", "  local smallest,\
    \ ns = math.huge, math.huge\n  for _, n in ipairs(lst) do\n    if n < smallest\
    \ then\n      ns, smallest = smallest, n\n    elseif n < ns then\n      ns = n\n\
    \    end\n  end\n  return ns == math.huge and nil or ns\nend", "  local first,\
    \ second = math.huge, math.huge\n  for _, v in ipairs(lst) do\n    if v < first\
    \ then\n      second = first\n      first = v\n    elseif v < second then\n  \
    \    second = v\n    end\n  end\n  return second\nend", "    if #lst < 2 then\n\
    \        return nil\n    end\n    local min1, min2 = math.min(lst[1], lst[2]),\
    \ math.max(lst[1], lst[2])\n    for i = 3, #lst do\n        if lst[i] < min1 then\n\
    \            min2 = min1\n            min1 = lst[i]\n        elseif lst[i] < min2\
    \ then\n            min2 = lst[i]\n        end\n    end\n    return min2\nend",
  "  if not lst or #lst < 2 then return nil end\n  local min, min2 = lst[1], lst[2]\n\
    \  for i = 2, #lst do\n    if lst[i] < min then\n      min2 = min\n      min =\
    \ lst[i]\n    elseif lst[i] < min2 then\n      min2 = lst[i]\n    end\n  end\n\
    \  return min2\nend", "\tlocal first_min, second_min\n\tfor i = 1, #lst do\n\t\
    \tif not first_min or lst[i] < first_min then\n\t\t\tsecond_min = first_min\n\t\
    \t\tfirst_min = lst[i]\n\t\telseif not second_min or lst[i] < second_min then\n\
    \t\t\tsecond_min = lst[i]\n\t\tend\n\tend\n\treturn second_min\nend\nassert(next_smallest{5,\
    \ 10, 2, 3, 9, 5, 2, 8, 9, 1} == 2)\nassert(next_smallest{10, 9, 8, 7, 6, 5, 4,\
    \ 3, 2, 1} == 2)\nassert(next_smallest{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} == 2)\n\
    assert(next_smallest{-5, -10, -2, -3, -9, -5, -2, -8, -9, -1} == -2)\nassert(next_smallest{-10,\
    \ -9, -8, -7, -6, -5, -4, -3, -2, -1} == -2)\nassert(next_smallest{-1, -2, -3,\
    \ -4, -5, -6, -7, -8, -9, -10} == -2)\nassert(next_smallest{} == nil)\nassert(next_smallest{3}\
    \ == nil)\nassert(next_smallest{3, 1} == nil)\nassert(next_smallest{3, 1, 2} ==\
    \ nil)\nassert(next_smallest{3, 2, 1} == nil)\nassert(next_smallest{3, 2, 3} ==\
    \ nil)\nassert(next_smallest{3, 1, 1} == nil)\nassert(next_smallest{3, 1, 2, 1}\
    \ == nil)", "    if not lst or not lst[1] then return nil end\n    local min1,\
    \ min2 = lst[1], nil\n    for i = 2, #lst do\n        if lst[i] < min1 then\n\
    \            min2 = min1\n            min1 = lst[i]\n        elseif lst[i] < min2\
    \ or min2 == nil then\n            min2 = lst[i]\n        end\n    end\n    return\
    \ min2\nend", "  local smallest, second_smallest\n  for _,n in ipairs(lst) do\n\
    \    if not smallest or n < smallest then\n      second_smallest = smallest\n\
    \      smallest = n\n    elseif not second_smallest or n < second_smallest then\n\
    \      second_smallest = n\n    end\n  end\n  return second_smallest\nend", " \
    \ local smallest = lst[1]\n  local second_smallest = nil\n  for i = 2, #lst do\n\
    \    if lst[i] < smallest then\n      second_smallest = smallest\n      smallest\
    \ = lst[i]\n    elseif lst[i] < second_smallest or second_smallest == nil then\n\
    \      second_smallest = lst[i]\n    end\n  end\n  return second_smallest\nend\n\
    assert(next_smallest{} == nil)\nassert(next_smallest{1} == nil)\nassert(next_smallest{1,\
    \ 2} == 1)\nassert(next_smallest{2, 1} == 1)\nassert(next_smallest{1, 3, 2} ==\
    \ 2)\nassert(next_smallest{5, 4, 3, 2, 1} == 2)", "\tlocal min = math.huge\n\t\
    local next = math.huge\n\tfor _, val in ipairs(lst) do\n\t\tif val < min then\n\
    \t\t\tnext = min\n\t\t\tmin = val\n\t\telseif val < next then\n\t\t\tnext = val\n\
    \t\tend\n\tend\n\treturn next\nend", "    local min, min_index, min2, min2_index\n\
    \    for i, v in ipairs(lst) do\n        if not min or v < min then\n        \
    \    min = v\n            min_index = i\n        end\n    end\n    for i, v in\
    \ ipairs(lst) do\n        if (not min2 or v < min2) and i ~= min_index then\n\
    \            min2 = v\n            min2_index = i\n        end\n    end\n    return\
    \ min2\nend", "  local min, min2 = math.huge, math.huge\n  for i = 1, #lst do\n\
    \    if lst[i] < min then\n      min2 = min\n      min = lst[i]\n    elseif lst[i]\
    \ < min2 then\n      min2 = lst[i]\n    end\n  end\n  return min2 == math.huge\
    \ and nil or min2\nend", "  -- return lst[2]\n  table.sort(lst)\n  if #lst > 1\
    \ then\n    return lst[2]\n  else\n    return nil\n  end\nend", "    if (#lst\
    \ < 2) then\n        return nil\n    end\n    local smallest = math.min(unpack(lst))\n\
    \    for _, v in ipairs(lst) do\n        if v > smallest then\n            return\
    \ v\n        end\n    end\n    return nil\nend", "    local smallest = math.huge\n\
    \    local second_smallest = math.huge\n    for _, x in ipairs(lst) do\n     \
    \   if x < smallest then\n            second_smallest = smallest\n           \
    \ smallest = x\n        elseif x < second_smallest then\n            second_smallest\
    \ = x\n        end\n    end\n    return second_smallest == math.huge and nil or\
    \ second_smallest\nend", "  local min1, min2\n  for _, v in ipairs(lst) do\n \
    \   if not min1 or v < min1 then\n      min2 = min1\n      min1 = v\n    elseif\
    \ not min2 or v < min2 then\n      min2 = v\n    end\n  end\n  return min2\nend",
  "  if not lst then return nil end\n  table.sort(lst)\n  return lst[2]\nend", " \
    \   if #lst < 2 then\n        return nil\n    end\n    local smallest = math.huge\n\
    \    local second_smallest = math.huge\n    for _, v in ipairs(lst) do\n     \
    \   if v < smallest then\n            second_smallest = smallest\n           \
    \ smallest = v\n        elseif v < second_smallest then\n            second_smallest\
    \ = v\n        end\n    end\n    if second_smallest == math.huge then\n      \
    \  return nil\n    end\n    return second_smallest\nend", "  local min = lst[1]\n\
    \  local second_min = nil\n  for i = 2, #lst do\n    if lst[i] < min then\n  \
    \    second_min = min\n      min = lst[i]\n    elseif lst[i] < second_min or second_min\
    \ == nil then\n      second_min = lst[i]\n    end\n  end\n  return second_min\n\
    end", "    local min = math.min(unpack(lst))\n    local count = 0\n    for i =\
    \ 1, #lst do\n        if lst[i] ~= min then\n            count = count + 1\n \
    \       end\n    end\n    if count < 2 then\n        return nil\n    end\n   \
    \ for i = 1, #lst do\n        if lst[i] == min then\n            return math.min(unpack(lst,\
    \ i + 1))\n        end\n    end\nend\nassert(next_smallest({8, 1, 2, 3, 4, 5,\
    \ 6, 7}) == 2)\nassert(next_smallest({1, 2, 3, 4, 5, 6, 7}) == 2)\nassert(next_smallest({1,\
    \ 1, 2, 3, 4, 5, 6, 7}) == 2)\nassert(next_smallest({1, 2, 3, 4, 5, 6, 7, 1})\
    \ == 2)\nassert(next_smallest({1, 2, 3, 4, 5, 6, 7, 8}) == 2)\nassert(next_smallest({1,\
    \ 1, 1, 1, 1, 1, 1, 1}) == nil)\nassert(next_smallest({}) == nil)", "  local smallest\
    \ = math.huge\n  local smallest2 = math.huge\n  for _, v in ipairs(lst) do\n \
    \   if v < smallest then\n      smallest, smallest2 = v, smallest\n    elseif\
    \ v < smallest2 then\n      smallest2 = v\n    end\n  end\n  return smallest2\n\
    end\nassert(next_smallest({2, 3, 5, 8, 9, 1}) == 2)\nassert(next_smallest({1,\
    \ 2, 3, 4, 5}) == 2)\nassert(next_smallest({5, 4, 3, 2, 1}) == math.huge)\nassert(next_smallest({})\
    \ == math.huge)\nassert(next_smallest({1}) == math.huge)", "\tlocal smallest =\
    \ lst[1]\n\tlocal second_smallest = nil\n\tfor _, x in ipairs(lst) do\n\t\tif\
    \ x < smallest then\n\t\t\tsecond_smallest = smallest\n\t\t\tsmallest = x\n\t\t\
    elseif x < second_smallest or second_smallest == nil then\n\t\t\tsecond_smallest\
    \ = x\n\t\tend\n\tend\n\treturn second_smallest\nend", "  local n = lst[1]\n \
    \ local m = n", "    if #lst < 2 then\n        return nil\n    end\n    local\
    \ min, second_min = lst[1], lst[2]\n    if min > second_min then\n        min,\
    \ second_min = second_min, min\n    end\n    for i = 3, #lst do\n        local\
    \ cur = lst[i]\n        if cur < min then\n            second_min = min\n    \
    \        min = cur\n        elseif cur < second_min then\n            second_min\
    \ = cur\n        end\n    end\n    return second_min\nend", "    local min1, min2\
    \ = math.huge, math.huge\n    for _, e in ipairs(lst) do\n        if e < min1\
    \ then\n            min2 = min1\n            min1 = e\n        elseif e < min2\
    \ then\n            min2 = e\n        end\n    end\n    return min2 == math.huge\
    \ and nil or min2\nend", "    assert(type(lst) == 'table', 'Argument must be a\
    \ table')\n    assert(#lst > 0, 'List cannot be empty')", "    local smallest,\
    \ smallest2\n    for _, v in ipairs(lst) do\n        if smallest == nil or v <\
    \ smallest then\n            smallest2 = smallest\n            smallest = v\n\
    \        elseif smallest2 == nil or v < smallest2 then\n            smallest2\
    \ = v\n        end\n    end\n    return smallest2\nend", "    local min, second,\
    \ size = math.huge, math.huge, #lst\n    for i = 1, size do\n        local current\
    \ = lst[i]\n        if current < min then\n            second = min\n        \
    \    min = current\n        elseif current < second then\n            second =\
    \ current\n        end\n    end\n    return second ~= math.huge and second or\
    \ nil\nend", "  -- your code goes here\nend", "    local smallest = math.huge\n\
    \    local second = math.huge\n    for _, n in ipairs(lst) do\n        if n <\
    \ smallest then\n            second = smallest\n            smallest = n\n   \
    \     elseif n < second then\n            second = n\n        end\n    end\n \
    \   return second\nend", "    local res = nil\n    local smallest = math.huge\n\
    \    for i = 1, #lst do\n        if lst[i] < smallest then\n            res =\
    \ smallest\n            smallest = lst[i]\n        elseif (lst[i] < res) or (res\
    \ == nil) then\n            res = lst[i]\n        end\n    end\n    return res\n\
    end", "    local min = math.min(unpack(lst))\n    local min_index = table.index_of(lst,\
    \ min)\n    table.remove(lst, min_index)\n    return math.min(unpack(lst))\nend",
  "    local ret\n    local min = math.min(unpack(lst))\n    for _, e in ipairs(lst)\
    \ do\n        if e > min and (not ret or e < ret) then\n            ret = e\n\
    \        end\n    end\n    return ret\nend", "  local tab = {}\n  for i, v in\
    \ ipairs(lst) do\n    tab[v] = i\n  end\n  local min = math.min(unpack(lst))\n\
    \  local min_index = tab[min]\n  table.remove(lst, min_index)\n  return math.min(unpack(lst))\n\
    end", "    if not lst or #lst < 2 then\n        return nil\n    end\n    local\
    \ smallest = lst[1]\n    local second_smallest = nil\n    for _, x in ipairs(lst)\
    \ do\n        if x < smallest then\n            second_smallest = smallest\n \
    \           smallest = x\n        elseif second_smallest == nil or x < second_smallest\
    \ then\n            second_smallest = x\n        end\n    end\n    return second_smallest\n\
    end", "  local min, min_2\n  for _, v in ipairs(lst) do\n    if not min or v <\
    \ min then\n      min_2 = min\n      min = v\n    elseif not min_2 or v < min_2\
    \ then\n      min_2 = v\n    end\n  end\n  return min_2\nend", "    if #lst ==\
    \ 0 then\n        return nil\n    end\n    if #lst == 1 then\n        return nil\n\
    \    end\n    if #lst == 2 then\n        return lst[2]\n    end\n    local i,\
    \ j, max = 0, 0, lst[1]\n    for i = 1, #lst do\n        if lst[i] > max then\n\
    \            max = lst[i]\n        end\n    end\n    local num1, num2 = max, max\n\
    \    for j = 1, #lst do\n        if lst[j] < num1 then\n            num2 = num1\n\
    \            num1 = lst[j]\n        elseif lst[j] < num2 then\n            num2\
    \ = lst[j]\n        end\n    end\n    return num2\nend", "  local min = math.huge\n\
    \  local min2 = math.huge\n  for _, x in ipairs(lst) do\n    if x < min then\n\
    \      min2 = min\n      min = x\n    elseif x < min2 then\n      min2 = x\n \
    \   end\n  end\n  return min2\nend", "  table.sort(lst)\n  return lst[2]\nend\n\
    assert(next_smallest({1, 2, 3, 4, 5}) == 2)\nassert(next_smallest({1, 2, 3, 4,\
    \ 5, 6}) == 2)\nassert(next_smallest({1, 2, 3, 4, 5, 6, 7}) == 2)\nassert(next_smallest({1,\
    \ 2, 3, 4, 5, 6, 7, 8}) == 2)\nassert(next_smallest({1, 2, 3, 4, 5, 6, 7, 8, 9})\
    \ == 2)\nassert(next_smallest({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == 2)\nassert(next_smallest({2,\
    \ 1, 3, 4, 5}) == 2)\nassert(next_smallest({1, 2, 5, 4, 3}) == 2)\nassert(next_smallest({1,\
    \ 3, 2, 4, 5}) == 2)\nassert(next_smallest({1, 3, 4, 2, 5}) == 2)\nassert(next_smallest({1,\
    \ 3, 4, 5, 2}) == 2)\nassert(next_smallest({1, 2, 4, 3, 5}) == 2)\nassert(next_smallest({1,\
    \ 2, 4, 5, 3}) == 2)\nassert(next_smallest({1, 2, 5, 3, 4}) == 2)\nassert(next_smallest({1,\
    \ 2, 5, 4, 3}) == 2)\nassert(next_smallest({1, 3, 2, 5, 4}) == 2)\nassert(next_smallest({1,\
    \ 3, 2, 4, 5}) == 2)\nassert(next_smallest({1, 3, 4, 2, 5}) == 2)\nassert(next_smallest({1,\
    \ 3, 4, 5, 2}) == 2)\nassert(next_smallest({1, 3, 5, 2, 4}) == 2)\nassert(next_smallest({1,\
    \ 3, 5, 4, 2}) == 2)\nassert(next_smallest({1, 4, 2, 3, 5}) == 2)\n", "\tlocal\
    \ min = math.huge\n\tlocal min2 = math.huge\n\tfor _, item in ipairs(lst) do\n\
    \t\tif item < min then\n\t\t\tmin2 = min\n\t\t\tmin = item\n\t\telseif item <\
    \ min2 then\n\t\t\tmin2 = item\n\t\tend\n\tend\n\treturn min2 == math.huge and\
    \ nil or min2\nend", "    local min, second\n    for _, val in ipairs(lst) do\n\
    \        if min == nil or val < min then\n            second = min\n         \
    \   min = val\n        elseif val < second or second == nil then\n           \
    \ second = val\n        end\n    end\n    return second\nend", "    local smallest\
    \ = math.min(unpack(lst))\n    for i = 1, #lst do\n        if lst[i] ~= smallest\
    \ then\n            return math.min(unpack(lst))\n        end\n    end\n    return\
    \ nil\nend", "  local size = #lst\n  if size < 2 then\n    return nil\n  end\n\
    \  table.sort(lst)\n  return lst[2]\nend", "  if not lst or #lst < 2 then return\
    \ nil end\n  local smallest = math.huge\n  local second_smallest = math.huge\n\
    \  for _,v in ipairs(lst) do\n    if v < smallest then\n      second_smallest\
    \ = smallest\n      smallest = v\n    elseif v < second_smallest then\n      second_smallest\
    \ = v\n    end\n  end\n  return second_smallest\nend", "\tlst = utils.unique(lst)\n\
    \ttable.sort(lst)\n\treturn lst[2]\nend", "    local min, min2 = math.huge, math.huge\n\
    \    for i, v in ipairs(lst) do\n        if v < min then\n            min2 = min\n\
    \            min = v\n        elseif v < min2 then\n            min2 = v\n   \
    \     end\n    end\n    return min2 ~= math.huge and min2 or nil\nend", "  local\
    \ min = math.huge\n  local min2 = math.huge\n  for _, v in ipairs(lst) do\n  \
    \  if v < min then\n      min2 = min\n      min = v\n    elseif v < min2 then\n\
    \      min2 = v\n    end\n  end\n  return min2 == math.huge and nil or min2\n\
    end", "  local min = nil\n  local min2 = nil\n  for _, v in ipairs(lst) do\n \
    \   if min == nil or v < min then\n      min2 = min\n      min = v\n    elseif\
    \ min2 == nil or v < min2 then\n      min2 = v\n    end\n  end\n  return min2\n\
    end", "    local smallest, smallest2\n    for _, n in ipairs(lst) do\n       \
    \ if smallest == nil or n < smallest then\n            smallest2 = smallest\n\
    \            smallest = n\n        elseif smallest2 == nil or n < smallest2 then\n\
    \            smallest2 = n\n        end\n    end\n    return smallest2\nend\n\
    assert(next_smallest({1, 4, 7, 2, 6, 3}) == 2)\nassert(next_smallest({1, 2, 3,\
    \ 4, 5}) == 2)\nassert(next_smallest({4, 5, 1, 2, 3}) == 2)\nassert(next_smallest({4,\
    \ 3, 2, 1}) == nil)\nassert(next_smallest({2, 3, 4, 5}) == 3)\nassert(next_smallest({1,\
    \ 2, 3, 4}) == 2)\nassert(next_smallest({5, 4, 3, 2, 1}) == 4)\nassert(next_smallest({1,\
    \ 2, 3, 3, 3}) == 2)\nassert(next_smallest({1, 2, 1, 2, 1}) == 1)", "  local function\
    \ find_smallest(lst, cur_smallest)\n    if #lst == 0 then\n      return cur_smallest\n\
    \    end\n    local smallest = cur_smallest and cur_smallest or math.maxinteger\n\
    \    local idx\n    for i, v in ipairs(lst) do\n      if v < smallest then\n \
    \       smallest = v\n        idx = i\n      end\n    end\n    lst[idx] = math.maxinteger\n\
    \    local cmp = find_smallest(lst, smallest)\n    if cmp ~= smallest then\n \
    \     return cmp\n    end\n    cmp = find_smallest(lst)\n    if cmp ~= smallest\
    \ then\n      return cmp\n    end\n    return nil\n  end\n  return find_smallest(lst)\n\
    end", "  local min1, min2\n  for _, v in ipairs(lst) do\n    if not min1 or v\
    \ < min1 then\n      min2 = min1\n      min1 = v\n    elseif not min2 or v < min2\
    \ then\n      min2 = v\n    end\n  end\n  return min2\nend\nassert(next_smallest({9,\
    \ 2, 10, 3, 1, 6, 8, 5, 4, 7}) == 2)\nassert(next_smallest({12, 13, 1, 10, 34,\
    \ 1}) == 10)\nassert(next_smallest({9, 2, 9, 9, 2, 1}) == 2)\nassert(next_smallest({9,\
    \ 2, 9, 9, 2, 1, 0}) == 0)\nassert(next_smallest({0, -1, 1, 2, -2, -3}) == -1)\n\
    assert(next_smallest({9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3}) == -1)\nassert(next_smallest({-3,\
    \ -2, -1, 0, 1, 2, 3}) == -2)\nassert(next_smallest({-3, -2, -1, 0, 1, 2, 3, -100})\
    \ == -100)\nassert(next_smallest({-100, -3, -2, -1, 0, 1, 2, 3}) == -3)\nassert(next_smallest({-100,\
    \ -3, -2, -1, 0, 1, 2, 3, 100}) == -3)\nassert(next_smallest({-3, -2, -1, 0, 1,\
    \ 2, 3, 100}) == -2)\nassert(next_smallest({-1, 0, 1, 2, 3, 100}) == 0)\nassert(next_smallest({100,\
    \ 3, 2, 1, 0, -1}) == 3)\nassert(next_smallest({100, 100, 100}) == nil)\nassert(next_smallest({-100,\
    \ -100, -100}) == nil)\nassert(next_smallest({1}) == nil)\nassert(next_smallest",
  "  local smallest, second_smallest = lst[1], lst[2]\n  for _, value in ipairs(lst)\
    \ do\n    if value < smallest then\n      second_smallest = smallest\n      smallest\
    \ = value\n    elseif value < second_smallest then\n      second_smallest = value\n\
    \    end\n  end\n  return second_smallest\nend", "  if #lst == 0 then return nil\
    \ end\n  table.sort(lst)\n  return lst[2]\nend", "    local first, second = math.huge,\
    \ math.huge\n    for i = 1, #lst do\n        if lst[i] < first then\n        \
    \    second = first\n            first = lst[i]\n        elseif lst[i] < second\
    \ then\n            second = lst[i]\n        end\n    end\n    return second ==\
    \ math.huge and nil or second\nend", "    assertx.is_table(lst)\n    local next_smallest\
    \ = nil\n    local smallest = nil\n    for i = 1, #lst do\n        local item\
    \ = lst[i]\n        if smallest == nil or item < smallest then\n            next_smallest\
    \ = smallest\n            smallest = item\n        elseif next_smallest == nil\
    \ or item < next_smallest then\n            next_smallest = item\n        end\n\
    \    end\n    return next_smallest\nend", "    local a, b = math.huge, math.huge\n\
    \    for _, v in ipairs(lst) do\n        if v < a then\n            b = a\n  \
    \          a = v\n        elseif v < b then\n            b = v\n        end\n\
    \    end\n    return b == math.huge and nil or b\nend", "  local min = lst[1]\n\
    \  local second = nil\n  for i, v in ipairs(lst) do\n    if v < min then\n   \
    \   second = min\n      min = v\n    elseif v < second or second == nil then\n\
    \      second = v\n    end\n  end\n  return second\nend", "    local smallest,\
    \ second_smallest = math.huge, math.huge\n    for _, value in ipairs(lst) do\n\
    \        if value < smallest then\n            second_smallest = smallest\n  \
    \          smallest = value\n        elseif value < second_smallest then\n   \
    \         second_smallest = value\n        end\n    end\n    return second_smallest\
    \ == math.huge and nil or second_smallest\nend", "  local min1, min2\n  for i,\
    \ v in ipairs(lst) do\n    if not min1 or v < min1 then\n      min2 = min1\n \
    \     min1 = v\n    elseif not min2 or v < min2 then\n      min2 = v\n    end\n\
    \  end\n  return min2\nend", "\t-- TODO: write your code here\nend", "  if #lst\
    \ < 2 then return nil end\n  local min1, min2 = math.huge, math.huge\n  for _,\
    \ v in ipairs(lst) do\n    if v < min1 then\n      min2 = min1\n      min1 = v\n\
    \    elseif v < min2 then\n      min2 = v\n    end\n  end\n  return min2\nend",
  "    table.sort(lst)\n    local prev = lst[1]\n    for _, v in ipairs(lst) do\n\
    \        if v > prev then\n            return v\n        end\n        prev = v\n\
    \    end\n    return nil\nend", "  local n, next_n\n  for _, n in ipairs(lst)\
    \ do\n    if not next_n or n < next_n then\n      next_n = n\n    end\n  end\n\
    \  return next_n\nend", "  -- print(\"START: next_smallest()\", lst)\n  local\
    \ smallest, second_smallest = math.maxinteger, math.maxinteger\n  for _, n in\
    \ ipairs(lst) do\n    if n < smallest then\n      second_smallest = smallest\n\
    \      smallest = n\n    elseif n < second_smallest then\n      second_smallest\
    \ = n\n    end\n  end\n  if second_smallest == math.maxinteger then\n    return\
    \ nil\n  end\n  return second_smallest\nend", "    local min, min2 = lst[1], lst[1]\n\
    \    for _, v in ipairs(lst) do\n        if v < min then\n            min, min2\
    \ = v, min\n        elseif v < min2 then\n            min2 = v\n        end\n\
    \    end\n    return min2\nend", "    -- TODO: implement\nend", "    table.sort(lst)\n\
    \    return lst[2]\nend", "    local smallest = math.huge\n    local second =\
    \ math.huge\n    for i = 1, #lst do\n        if lst[i] < smallest then\n     \
    \       second = smallest\n            smallest = lst[i]\n        elseif lst[i]\
    \ < second then\n            second = lst[i]\n        end\n    end\n    return\
    \ second == math.huge and nil or second\nend\nassert(next_smallest({1, 2, 3, 4,\
    \ 5}) == 2)\nassert(next_smallest({1, 1, 1, 1, 1}) == nil)\nassert(next_smallest({5,\
    \ 4, 3, 2, 1}) == 4)\nassert(next_smallest({1, 3, 2, 4, 5}) == 2)", "  local min_value,\
    \ min_idx = math.huge, 0\n  local min2_value, min2_idx = math.huge, 0\n  for idx,\
    \ value in ipairs(lst) do\n    if value < min_value then\n      min2_value, min2_idx\
    \ = min_value, min_idx\n      min_value, min_idx = value, idx\n    elseif value\
    \ < min2_value then\n      min2_value, min2_idx = value, idx\n    end\n  end\n\
    \  return min2_value, min2_idx\nend", "    if lst[2] == nil then\n        return\
    \ nil\n    end\n    local tmp = lst[1]\n    for i = 2, #lst do\n        if lst[i]\
    \ < tmp then\n            tmp = lst[i]\n        end\n    end\n    for i = 1, #lst\
    \ do\n        if lst[i] == tmp then\n            table.remove(lst, i)\n      \
    \      break\n        end\n    end\n    return next_smallest(lst)\nend", "  local\
    \ min = math.min(unpack(lst))\n  local min2 = min\n  for _, v in ipairs(lst) do\n\
    \    if v < min2 and v > min then\n      min2 = v\n    end\n  end\n  return min2\n\
    end\nassert(next_smallest{1, 2, 3, 4, 5} == 2)\nassert(next_smallest{10, 2, 3,\
    \ 4, 5} == 3)\nassert(next_smallest{2, 3, 3, 4, 5} == 3)\nassert(next_smallest{1,\
    \ 2, 2, 4, 5} == 2)\nassert(next_smallest{1, 2, 2, 2, 5} == 2)\nassert(next_smallest{1,\
    \ 2, 2, 2, 2} == nil)", "  if lst[1] == nil then return nil end\n  if lst[2] ==\
    \ nil then return nil end\n  local sm = lst[1]\n  local nsm = nil\n  for i, e\
    \ in ipairs(lst) do\n    if sm > e then sm = e end\n    if nsm == nil and e ~=\
    \ sm then nsm = e end\n    if e < nsm and e > sm then nsm = e end\n  end\n  return\
    \ nsm\nend", "    local n = #lst\n    if n < 2 then\n        return nil\n    end\n\
    \    local smallest = math.min(lst[1], lst[2])\n    local second_smallest = math.max(lst[1],\
    \ lst[2])\n    for i = 3, n do\n        if lst[i] < smallest then\n          \
    \  second_smallest = smallest\n            smallest = lst[i]\n        elseif lst[i]\
    \ < second_smallest then\n            second_smallest = lst[i]\n        end\n\
    \    end\n    return second_smallest\nend", "  local smallest, next_smallest =\
    \ lst[1], lst[1]\n  for _, i in ipairs(lst) do\n    if i < smallest then\n   \
    \   next_smallest = smallest\n      smallest = i\n    elseif i < next_smallest\
    \ then\n      next_smallest = i\n    end\n  end\n  return next_smallest\nend",
  "    if #lst < 2 then\n        return nil\n    end\n    local first, second = lst[1],\
    \ lst[2]\n    if first > second then\n        first, second = second, first\n\
    \    end\n    for i = 3, #lst do\n        local cur = lst[i]\n        if cur <\
    \ first then\n            second = first\n            first = cur\n        elseif\
    \ cur < second then\n            second = cur\n        end\n    end\n    return\
    \ second\nend", "  local smallest, second_smallest = math.huge, math.huge\n  for\
    \ _, v in ipairs(lst) do\n    if v < smallest then\n      second_smallest = smallest\n\
    \      smallest = v\n    elseif v < second_smallest then\n      second_smallest\
    \ = v\n    end\n  end\n  return second_smallest\nend", "    local smallest = lst[1]\n\
    \    local next_smallest = nil\n    for i = 2, #lst do\n        if lst[i] < smallest\
    \ then\n            next_smallest = smallest\n            smallest = lst[i]\n\
    \        elseif not next_smallest or lst[i] < next_smallest then\n           \
    \ next_smallest = lst[i]\n        end\n    end\n    return next_smallest\nend",
  "    local first, second = math.maxinteger, math.maxinteger\n    for _,v in ipairs(lst)\
    \ do\n        if v < first then\n            second = first\n            first\
    \ = v\n        elseif v < second then\n            second = v\n        end\n \
    \   end\n    return second ~= math.maxinteger and second or nil\nend", "    table.sort(lst)\n\
    \    if lst[2] then\n        return lst[2]\n    end\nend", "    local els = {}\n\
    \    for _, el in ipairs(lst) do\n        table.insert(els, el)\n    end\n   \
    \ table.sort(els)\n    return els[2]\nend", "    local min, secmin = lst[1], nil\n\
    \    for i=2,#lst do\n        if lst[i] < min then\n            secmin = min\n\
    \            min = lst[i]\n        elseif lst[i] < secmin or secmin == nil then\n\
    \            secmin = lst[i]\n        end\n    end\n    return secmin\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
