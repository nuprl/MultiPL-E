name: HumanEval_21_rescale_to_unit
language: lua
prompt: "-- Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n-- such that the smallest number will become 0 and the largest\
  \ will become 1\nlocal function rescale_to_unit(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = rescale_to_unit\n\
  \    lu.assertEquals(candidate({2.0, 49.9}), {0.0, 1.0})\n    lu.assertEquals(candidate({100.0,\
  \ 49.9}), {1.0, 0.0})\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0}),\
  \ {0.0, 0.25, 0.5, 0.75, 1.0})\n    lu.assertEquals(candidate({2.0, 1.0, 5.0, 3.0,\
  \ 4.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\n    lu.assertEquals(candidate({12.0, 11.0,\
  \ 15.0, 13.0, 14.0}), {0.25, 0.0, 1.0, 0.5, 0.75})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local scale = max - min\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(result, (number - min) / scale)\n    end\n    return\
    \ result\nend", "    local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local range = max - min\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(result, (number - min) / range)\n    end\n    return\
    \ result\nend", "    local min = numbers[1]\n    local max = numbers[1]\n    for\
    \ _, number in ipairs(numbers) do\n        if number < min then\n            min\
    \ = number\n        end\n        if number > max then\n            max = number\n\
    \        end\n    end\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(result, (number - min) / (max - min))\n    end\n  \
    \  return result\nend", "    local min = numbers[1]\n    local max = numbers[1]\n\
    \    for _, number in ipairs(numbers) do\n        if number < min then\n     \
    \       min = number\n        end\n        if number > max then\n            max\
    \ = number\n        end\n    end\n    local result = {}\n    for _, number in\
    \ ipairs(numbers) do\n        table.insert(result, (number - min) / (max - min))\n\
    \    end\n    return result\nend", "    local min = numbers[1]\n    local max\
    \ = numbers[1]\n    for i = 2, #numbers do\n        if numbers[i] < min then\n\
    \            min = numbers[i]\n        elseif numbers[i] > max then\n        \
    \    max = numbers[i]\n        end\n    end\n    local result = {}\n    for i\
    \ = 1, #numbers do\n        result[i] = (numbers[i] - min) / (max - min)\n   \
    \ end\n    return result\nend", "    local min_number = math.min(unpack(numbers))\n\
    \    local max_number = math.max(unpack(numbers))\n    local range = max_number\
    \ - min_number\n    local rescaled = {}\n    for i, number in ipairs(numbers)\
    \ do\n        rescaled[i] = (number - min_number) / range\n    end\n    return\
    \ rescaled\nend", "    local min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n\
    \    local result = {}\n    for _, v in ipairs(numbers) do\n        table.insert(result,\
    \ (v - min) / (max - min))\n    end\n    return result\nend", "    local min =\
    \ numbers[1]\n    local max = numbers[1]\n    for _, number in ipairs(numbers)\
    \ do\n        if number < min then\n            min = number\n        end\n  \
    \      if number > max then\n            max = number\n        end\n    end\n\
    \    local result = {}\n    for _, number in ipairs(numbers) do\n        table.insert(result,\
    \ (number - min) / (max - min))\n    end\n    return result\nend", "    local\
    \ min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local range = max - min\n    local rescaled = {}\n    for _, n in ipairs(numbers)\
    \ do\n        table.insert(rescaled, (n - min) / range)\n    end\n    return rescaled\n\
    end", "    local min = numbers[1]\n    local max = numbers[1]\n    for i = 2,\
    \ #numbers do\n        if numbers[i] < min then\n            min = numbers[i]\n\
    \        elseif numbers[i] > max then\n            max = numbers[i]\n        end\n\
    \    end\n    local result = {}\n    for i = 1, #numbers do\n        result[i]\
    \ = (numbers[i] - min) / (max - min)\n    end\n    return result\nend", "    local\
    \ min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local result = {}\n    for _, number in ipairs(numbers) do\n        table.insert(result,\
    \ (number - min) / (max - min))\n    end\n    return result\nend", "    local\
    \ min_number = math.min(unpack(numbers))\n    local max_number = math.max(unpack(numbers))\n\
    \    local range = max_number - min_number\n    local rescaled = {}\n    for i,\
    \ number in ipairs(numbers) do\n        rescaled[i] = (number - min_number) /\
    \ range\n    end\n    return rescaled\nend", "    local min = numbers[1]\n   \
    \ local max = numbers[1]\n    for _, n in ipairs(numbers) do\n        if n < min\
    \ then\n            min = n\n        end\n        if n > max then\n          \
    \  max = n\n        end\n    end\n    local result = {}\n    for _, n in ipairs(numbers)\
    \ do\n        table.insert(result, (n - min) / (max - min))\n    end\n    return\
    \ result\nend", "    local min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local range = max - min\n    local rescaled = {}\n    for _, number in ipairs(numbers)\
    \ do\n        rescaled[#rescaled + 1] = (number - min) / range\n    end\n    return\
    \ rescaled\nend", "    local min = math.min(unpack(numbers))\n    local max =\
    \ math.max(unpack(numbers))\n    local factor = 1 / (max - min)\n    local result\
    \ = {}\n    for _, number in ipairs(numbers) do\n        table.insert(result,\
    \ (number - min) * factor)\n    end\n    return result\nend", "    local min =\
    \ math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n    local\
    \ scale = max - min\n    local result = {}\n    for _, number in ipairs(numbers)\
    \ do\n        table.insert(result, (number - min) / scale)\n    end\n    return\
    \ result\nend", "    local min, max = math.min(unpack(numbers)), math.max(unpack(numbers))\n\
    \    local result = {}\n    for _, number in ipairs(numbers) do\n        table.insert(result,\
    \ (number - min) / (max - min))\n    end\n    return result\nend", "    local\
    \ min = math.min(unpack(numbers))\n    local max = math.max(unpack(numbers))\n\
    \    local result = {}\n    for i, v in ipairs(numbers) do\n        result[i]\
    \ = (v - min) / (max - min)\n    end\n    return result\nend", "    local min_number\
    \ = math.min(unpack(numbers))\n    local max_number = math.max(unpack(numbers))\n\
    \    local range = max_number - min_number\n    local rescaled = {}\n    for i,\
    \ number in ipairs(numbers) do\n        rescaled[i] = (number - min_number) /\
    \ range\n    end\n    return rescaled\nend", "    local min = math.min(unpack(numbers))\n\
    \    local max = math.max(unpack(numbers))\n    local range = max - min\n    local\
    \ result = {}\n    for _, number in ipairs(numbers) do\n        table.insert(result,\
    \ (number - min) / range)\n    end\n    return result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
