language: lua
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = \"\"\n\
    \  local num = number\n  local numeral_map = {\n    {1000, \"m\"}, {900, \"cm\"\
    }, {500, \"d\"}, {400, \"cd\"}, {100, \"c\"},\n    {90, \"xc\"}, {50, \"l\"},\
    \ {40, \"xl\"}, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"},\n    {4, \"iv\"}, {1, \"\
    i\"}\n  }\n  for _, pair in ipairs(numeral_map) do\n    local arabic, roman_string\
    \ = pair[1], pair[2]\n    while num >= arabic do\n      roman = roman .. roman_string\n\
    \      num = num - arabic\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.010 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = \"\"\n\
    \  local num = number\n  local digits = {\n    {1000, \"m\"},\n    {900, \"cm\"\
    },\n    {500, \"d\"},\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90, \"xc\"\
    },\n    {50, \"l\"},\n    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"ix\"},\n\
    \    {5, \"v\"},\n    {4, \"iv\"},\n    {1, \"i\"}\n  }\n  for i = 1, #digits\
    \ do\n    local digit = digits[i]\n    local value = digit[1]\n    local letter\
    \ = digit[2]\n    while num >= value do\n      roman = roman .. letter\n     \
    \ num = num - value\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = ''\n \
    \ local num = number\n  local numeral_map = {\n    {1000, 'm'},\n    {900, 'cm'},\n\
    \    {500, 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50,\
    \ 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4,\
    \ 'iv'},\n    {1, 'i'},\n  }\n  for _, pair in ipairs(numeral_map) do\n    local\
    \ arabic, roman_string = pair[1], pair[2]\n    while num >= arabic do\n      roman\
    \ = roman .. roman_string\n      num = num - arabic\n    end\n  end\n  return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        { \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\" },\n        { \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\",\
    \ \"lx\", \"lxx\", \"lxxx\", \"xc\" },\n        { \"\", \"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\" },\n        { \"\", \"m\",\
    \ \"mm\", \"mmm\" }\n    }\n    local result = \"\"\n    local num = number\n\
    \    for i = 4, 1, -1 do\n        local digit = num % 10\n        result = result\
    \ .. roman_numerals[i][digit + 1]\n        num = (num - digit) / 10\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpr338xpaa.lua:16:\
    \ attempt to concatenate field '?' (a nil value)\nstack traceback:\n\t/tmp/tmpr338xpaa.lua:16:\
    \ in function 'candidate'\n\t/tmp/tmpr338xpaa.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local numeral_map = {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"\
    }, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"\
    },\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n  \
    \  }\n    for _, r in ipairs(numeral_map) do\n        while number >= r[1] do\n\
    \            roman = roman .. r[2]\n            number = number - r[1]\n     \
    \   end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n\tlocal roman = \"\"\n\
    \tlocal num = number\n\twhile num > 0 do\n\t\tif num >= 1000 then\n\t\t\troman\
    \ = roman .. \"m\"\n\t\t\tnum = num - 1000\n\t\telseif num >= 900 then\n\t\t\t\
    roman = roman .. \"cm\"\n\t\t\tnum = num - 900\n\t\telseif num >= 500 then\n\t\
    \t\troman = roman .. \"d\"\n\t\t\tnum = num - 500\n\t\telseif num >= 400 then\n\
    \t\t\troman = roman .. \"cd\"\n\t\t\tnum = num - 400\n\t\telseif num >= 100 then\n\
    \t\t\troman = roman .. \"c\"\n\t\t\tnum = num - 100\n\t\telseif num >= 90 then\n\
    \t\t\troman = roman .. \"xc\"\n\t\t\tnum = num - 90\n\t\telseif num >= 50 then\n\
    \t\t\troman = roman .. \"l\"\n\t\t\tnum = num - 50\n\t\telseif num >= 40 then\n\
    \t\t\troman = roman .. \"xl\"\n\t\t\tnum = num - 40\n\t\telseif num >= 10 then\n\
    \t\t\troman = roman .. \"x\"\n\t\t\tnum = num - 10\n\t\telseif num >= 9 then\n\
    \t\t\troman = roman .. \"ix\"\n\t\t\tnum = num - 9\n\t\telseif num >= 5 then\n\
    \t\t\troman = roman .. \"v\"\n\t\t\tnum = num - 5\n\t\telseif num >= 4 then\n\t\
    \t\troman = roman .. \"iv\"\n\t\t\tnum = num - 4\n\t\telseif num >= 1 then\n\t\
    \t\troman = roman .. \"i\"\n\t\t\tnum = num - 1\n\t\tend\n\tend\n\treturn roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = {\n\
    \        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n        [50]\
    \ = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000] = \"\
    m\",\n    }\n    local result = \"\"\n    local num = number\n    local factor\
    \ = 1\n    while num > 0 do\n        local digit = num % 10\n        if digit\
    \ == 9 then\n            result = roman[factor] .. roman[factor * 10] .. result\n\
    \        elseif digit >= 5 then\n            result = roman[5 * factor] .. string.rep(roman[factor],\
    \ digit - 5) .. result\n        elseif digit == 4 then\n            result = roman[factor]\
    \ .. roman[5 * factor] .. result\n        else\n            result = string.rep(roman[factor],\
    \ digit) .. result\n        end\n        num = math.floor(num / 10)\n        factor\
    \ = factor * 10\n    end\n    return result\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = \"\"\n\
    \  local numbers = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n  local\
    \ letters = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\"\
    , \"ix\", \"v\", \"iv\", \"i\"}\n  for i, num in ipairs(numbers) do\n    while\
    \ number >= num do\n      roman = roman .. letters[i]\n      number = number -\
    \ num\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = ''\n \
    \ local num = number\n  while num > 0 do\n    if num >= 1000 then\n      roman\
    \ = roman .. 'm'\n      num = num - 1000\n    elseif num >= 900 then\n      roman\
    \ = roman .. 'cm'\n      num = num - 900\n    elseif num >= 500 then\n      roman\
    \ = roman .. 'd'\n      num = num - 500\n    elseif num >= 400 then\n      roman\
    \ = roman .. 'cd'\n      num = num - 400\n    elseif num >= 100 then\n      roman\
    \ = roman .. 'c'\n      num = num - 100\n    elseif num >= 90 then\n      roman\
    \ = roman .. 'xc'\n      num = num - 90\n    elseif num >= 50 then\n      roman\
    \ = roman .. 'l'\n      num = num - 50\n    elseif num >= 40 then\n      roman\
    \ = roman .. 'xl'\n      num = num - 40\n    elseif num >= 10 then\n      roman\
    \ = roman .. 'x'\n      num = num - 10\n    elseif num >= 9 then\n      roman\
    \ = roman .. 'ix'\n      num = num - 9\n    elseif num >= 5 then\n      roman\
    \ = roman .. 'v'\n      num = num - 5\n    elseif num >= 4 then\n      roman =\
    \ roman .. 'iv'\n      num = num - 4\n    elseif num >= 1 then\n      roman =\
    \ roman .. 'i'\n      num = num - 1\n    end\n  end\n  return roman\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local roman_numeral = \"\"\n    local digit_value = 1\n\
    \    local digit_count = 0\n    local digit_limit = 3\n    while number > 0 do\n\
    \        local digit = number % 10\n        number = math.floor(number / 10)\n\
    \        if digit == 4 then\n            roman_numeral = roman_numerals[digit_value]\
    \ .. roman_numerals[digit_value * 5] .. roman_numeral\n        elseif digit ==\
    \ 9 then\n            roman_numeral = roman_numerals[digit_value] .. roman_numerals[digit_value\
    \ * 10] .. roman_numeral\n        else\n            local digit_string = \"\"\n\
    \            for i = 1, digit do\n                digit_string = digit_string\
    \ .. roman_numerals[digit_value]\n            end\n            roman_numeral =\
    \ digit_string .. roman_numeral\n        end\n        digit_value = digit_value\
    \ * 10\n        digit_count = digit_count + 1\n        if digit_count == digit_limit\
    \ then\n            digit_value = digit_value * 10\n            digit_count =\
    \ 0\n        end\n    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplgnsht5y.lua:47:\
    \ expected: \"clii\"\nactual: \"cxxxxxii\"\nstack traceback:\n\t/tmp/tmplgnsht5y.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i = 1, #roman_numerals do\n        local arabic,\
    \ roman = unpack(roman_numerals[i])\n        while number >= arabic do\n     \
    \       number = number - arabic\n            result = result .. roman\n     \
    \   end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            roman = roman .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            roman = roman .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            roman\
    \ = roman .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. \"xc\"\n            num = num -\
    \ 90\n        elseif num >= 50 then\n            roman = roman .. \"l\"\n    \
    \        num = num - 50\n        elseif num >= 40 then\n            roman = roman\
    \ .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n     \
    \       roman = roman .. \"x\"\n            num = num - 10\n        elseif num\
    \ >= 9 then\n            roman = roman .. \"ix\"\n            num = num - 9\n\
    \        elseif num >= 5 then\n            roman = roman .. \"v\"\n          \
    \  num = num - 5\n        elseif num >= 4 then\n            roman = roman .. \"\
    iv\"\n            num = num - 4\n        elseif num >= 1 then\n            roman\
    \ = roman .. \"i\"\n            num = num - 1\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    [1] = \"i\",\n    [5] = \"v\",\n    [10] = \"x\",\n    [50] = \"l\"\
    ,\n    [100] = \"c\",\n    [500] = \"d\",\n    [1000] = \"m\",\n  }\n  local result\
    \ = \"\"\n  local num = number\n  local factor = 1\n  while num > 0 do\n    local\
    \ digit = num % 10\n    num = math.floor(num / 10)\n    local roman_digit = \"\
    \"\n    if digit == 9 then\n      roman_digit = roman_numerals[factor] .. roman_numerals[factor\
    \ * 10]\n    elseif digit >= 5 then\n      roman_digit = roman_numerals[5 * factor]\n\
    \      for i = 1, digit - 5 do\n        roman_digit = roman_digit .. roman_numerals[factor]\n\
    \      end\n    elseif digit == 4 then\n      roman_digit = roman_numerals[factor]\
    \ .. roman_numerals[5 * factor]\n    else\n      for i = 1, digit do\n       \
    \ roman_digit = roman_digit .. roman_numerals[factor]\n      end\n    end\n  \
    \  result = roman_digit .. result\n    factor = factor * 10\n  end\n  return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    if number > 1000 then\n\
    \        return nil\n    end\n    local roman = \"\"\n    local numeral_map =\
    \ {\n        {1000, \"m\"}, {900, \"cm\"}, {500, \"d\"}, {400, \"cd\"}, {100,\
    \ \"c\"},\n        {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"}, {10, \"x\"}, {9, \"\
    ix\"},\n        {5, \"v\"}, {4, \"iv\"}, {1, \"i\"}\n    }\n    for _, numeral\
    \ in ipairs(numeral_map) do\n        local arabic, roman_string = numeral[1],\
    \ numeral[2]\n        while number >= arabic do\n            roman = roman ..\
    \ roman_string\n            number = number - arabic\n        end\n    end\n \
    \   return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local result = \"\"\
    \n    local num = number\n    local numeral = {\n        {1000, \"m\"},\n    \
    \    {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100,\
    \ \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n\
    \        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4,\
    \ \"iv\"},\n        {1, \"i\"}\n    }\n    for i = 1, #numeral do\n        while\
    \ num >= numeral[i][1] do\n            result = result .. numeral[i][2]\n    \
    \        num = num - numeral[i][1]\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    [1] = 'i',\n    [5] = 'v',\n    [10] = 'x',\n    [50] = 'l',\n    [100]\
    \ = 'c',\n    [500] = 'd',\n    [1000] = 'm',\n  }\n  local roman_numeral = ''\n\
    \  local remainder = number\n  local divisor = 1000\n  while remainder > 0 do\n\
    \    local quotient = math.floor(remainder / divisor)\n    remainder = remainder\
    \ % divisor\n    if quotient == 9 then\n      roman_numeral = roman_numeral ..\
    \ roman_numerals[divisor] .. roman_numerals[divisor * 10]\n    elseif quotient\
    \ >= 5 then\n      roman_numeral = roman_numeral .. roman_numerals[divisor * 5]\n\
    \      for i = 1, quotient - 5 do\n        roman_numeral = roman_numeral .. roman_numerals[divisor]\n\
    \      end\n    elseif quotient == 4 then\n      roman_numeral = roman_numeral\
    \ .. roman_numerals[divisor] .. roman_numerals[divisor * 5]\n    else\n      for\
    \ i = 1, quotient do\n        roman_numeral = roman_numeral .. roman_numerals[divisor]\n\
    \      end\n    end\n    divisor = divisor / 10\n  end\n  return roman_numeral\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = ''\n\
    \    local num = number\n    local i = 1\n    while num > 0 do\n        local\
    \ digit = num % 10\n        num = (num - digit) / 10\n        if digit == 4 then\n\
    \            roman = roman .. 'iv'\n        elseif digit == 9 then\n         \
    \   roman = roman .. 'ix'\n        else\n            if digit >= 5 then\n    \
    \            roman = roman .. 'v'\n                digit = digit - 5\n       \
    \     end\n            for j = 1, digit do\n                roman = roman .. 'i'\n\
    \            end\n        end\n        i = i + 1\n    end\n    return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphzrelbal.lua:33:\
    \ expected: \"xix\"\nactual: \"ixi\"\nstack traceback:\n\t/tmp/tmphzrelbal.lua:33:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local roman_numerals = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n\
    \        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n      \
    \  {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"\
    x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n     \
    \   {1, \"i\"}\n    }\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, letters = numeral[1], numeral[2]\n        while number >= value\
    \ do\n            roman = roman .. letters\n            number = number - value\n\
    \        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numeral\
    \ = \"\"\n  local numeral_map = {\n    {1000, \"m\"}, {900, \"cm\"}, {500, \"\
    d\"}, {400, \"cd\"}, {100, \"c\"},\n    {90, \"xc\"}, {50, \"l\"}, {40, \"xl\"\
    }, {10, \"x\"}, {9, \"ix\"}, {5, \"v\"},\n    {4, \"iv\"}, {1, \"i\"}\n  }\n \
    \ for _, numeral in ipairs(numeral_map) do\n    local arabic, roman = numeral[1],\
    \ numeral[2]\n    while number >= arabic do\n      roman_numeral = roman_numeral\
    \ .. roman\n      number = number - arabic\n    end\n  end\n  return roman_numeral\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local arabic, roman = numeral[1], numeral[2]\n        while number >= arabic\
    \ do\n            result = result .. roman\n            number = number - arabic\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = \"\"\n\
    \  local num = number\n  while num > 0 do\n    if num >= 900 then\n      roman\
    \ = roman .. \"cm\"\n      num = num - 900\n    elseif num >= 500 then\n     \
    \ roman = roman .. \"d\"\n      num = num - 500\n    elseif num >= 400 then\n\
    \      roman = roman .. \"cd\"\n      num = num - 400\n    elseif num >= 100 then\n\
    \      roman = roman .. \"c\"\n      num = num - 100\n    elseif num >= 90 then\n\
    \      roman = roman .. \"xc\"\n      num = num - 90\n    elseif num >= 50 then\n\
    \      roman = roman .. \"l\"\n      num = num - 50\n    elseif num >= 40 then\n\
    \      roman = roman .. \"xl\"\n      num = num - 40\n    elseif num >= 10 then\n\
    \      roman = roman .. \"x\"\n      num = num - 10\n    elseif num >= 9 then\n\
    \      roman = roman .. \"ix\"\n      num = num - 9\n    elseif num >= 5 then\n\
    \      roman = roman .. \"v\"\n      num = num - 5\n    elseif num >= 4 then\n\
    \      roman = roman .. \"iv\"\n      num = num - 4\n    elseif num >= 1 then\n\
    \      roman = roman .. \"i\"\n      num = num - 1\n    end\n  end\n  return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpotym9c4z.lua:66:\
    \ expected: \"m\"\nactual: \"cmc\"\nstack traceback:\n\t/tmp/tmpotym9c4z.lua:66:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local result = \"\"\
    \n    local roman_numerals = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n\
    \        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n      \
    \  {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"\
    x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n     \
    \   {1, \"i\"}\n    }\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, letters = numeral[1], numeral[2]\n        while number >= value\
    \ do\n            result = result .. letters\n            number = number - value\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = ''\n \
    \ local num = number\n  local numeral_map = {\n    {1000, 'm'},\n    {900, 'cm'},\n\
    \    {500, 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50,\
    \ 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4,\
    \ 'iv'},\n    {1, 'i'},\n  }\n  for k, v in ipairs(numeral_map) do\n    local\
    \ value = v[1]\n    local letters = v[2]\n    while num >= value do\n      roman\
    \ = roman .. letters\n      num = num - value\n    end\n  end\n  return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i, v in ipairs(roman_numerals) do\n        while\
    \ number >= v[1] do\n            result = result .. v[2]\n            number =\
    \ number - v[1]\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = {\n\
    \        {'i', 'v'},\n        {'x', 'l'},\n        {'c', 'd'},\n        {'m'},\n\
    \    }\n    local result = ''\n    local digit = 1\n    while number > 0 do\n\
    \        local d = number % 10\n        if d == 9 then\n            result = roman[digit][1]\
    \ .. roman[digit + 1][1] .. result\n        elseif d >= 5 then\n            result\
    \ = roman[digit][2] .. string.rep(roman[digit][1], d - 5) .. result\n        elseif\
    \ d == 4 then\n            result = roman[digit][1] .. roman[digit][2] .. result\n\
    \        else\n            result = string.rep(roman[digit][1], d) .. result\n\
    \        end\n        digit = digit + 1\n        number = math.floor(number /\
    \ 10)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local result = \"\"\n    local remainder = number\n   \
    \ local factor = 1\n    while remainder > 0 do\n        local digit = remainder\
    \ % 10\n        local roman_digit = \"\"\n        if digit == 9 then\n       \
    \     roman_digit = roman_numerals[factor] .. roman_numerals[factor * 10]\n  \
    \      elseif digit >= 5 then\n            roman_digit = roman_numerals[5 * factor]\n\
    \            for i = 1, digit - 5 do\n                roman_digit = roman_digit\
    \ .. roman_numerals[factor]\n            end\n        elseif digit == 4 then\n\
    \            roman_digit = roman_numerals[factor] .. roman_numerals[5 * factor]\n\
    \        else\n            for i = 1, digit do\n                roman_digit =\
    \ roman_digit .. roman_numerals[factor]\n            end\n        end\n      \
    \  result = roman_digit .. result\n        remainder = math.floor(remainder /\
    \ 10)\n        factor = factor * 10\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numeral\
    \ = \"\"\n  local roman_numerals = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n\
    \    {500, \"d\"},\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n\
    \    {50, \"l\"},\n    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"ix\"},\n   \
    \ {5, \"v\"},\n    {4, \"iv\"},\n    {1, \"i\"}\n  }\n  for _, numeral in ipairs(roman_numerals)\
    \ do\n    local arabic, roman = numeral[1], numeral[2]\n    while number >= arabic\
    \ do\n      roman_numeral = roman_numeral .. roman\n      number = number - arabic\n\
    \    end\n  end\n  return roman_numeral\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = 'i',\n        [5] = 'v',\n        [10] = 'x',\n        [50]\
    \ = 'l',\n        [100] = 'c',\n        [500] = 'd',\n        [1000] = 'm',\n\
    \    }\n    local result = ''\n    local num = number\n    local digit = 1\n \
    \   local digit_value = 0\n    local digit_value_5 = 0\n    local digit_value_10\
    \ = 0\n    local digit_value_50 = 0\n    local digit_value_100 = 0\n    local\
    \ digit_value_500 = 0\n    local digit_value_1000 = 0\n    local digit_value_5000\
    \ = 0\n    local digit_value_10000 = 0\n    local digit_value_50000 = 0\n    local\
    \ digit_value_100000 = 0\n    local digit_value_500000 = 0\n    local digit_value_1000000\
    \ = 0\n    local digit_value_5000000 = 0\n    local digit_value_10000000 = 0\n\
    \    local digit_value_50000000 = 0\n    local digit_value_100000000 = 0\n   \
    \ local digit_value_500000000 = 0\n    local digit_value_1000000000 = 0\n    local\
    \ digit_value_5000000000 = 0\n    local digit_value_10000000000 = 0\n    local\
    \ digit_value_50000000000 = 0\n    local digit_value_100000000000 = 0\n    local\
    \ digit_value_500000000000 = 0\n    local digit_value_1000000000000 = 0\n    local\
    \ digit_value_5000000000000 = 0\n    local digit_value_10000000000000 = 0\n  \
    \  local digit_value_50000000000000 = 0\n    local digit_value_100000000000000\
    \ = 0\n    local digit_value_500000000000000 = 0\n    local digit_value_1000000000000000\
    \ = 0\n    local digit_value_5000000000000000 = 0\n    local digit_value_10000000000000000\
    \ = 0\n    local digit_value_50000000000000000 = 0\n    local digit_value_100000000000000000\
    \ = 0\n    local digit_value_500000000000000000 = 0\n    local digit_value_1000000000000000000\
    \ = 0\n   \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpe9n23qqk.lua:76: ''end'' expected (to close ''function'' at
    line 5) near ''<eof>''

    '
  stdout: ''
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            roman = roman .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            roman = roman .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            roman\
    \ = roman .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. \"xc\"\n            num = num -\
    \ 90\n        elseif num >= 50 then\n            roman = roman .. \"l\"\n    \
    \        num = num - 50\n        elseif num >= 40 then\n            roman = roman\
    \ .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n     \
    \       roman = roman .. \"x\"\n            num = num - 10\n        elseif num\
    \ >= 9 then\n            roman = roman .. \"ix\"\n            num = num - 9\n\
    \        elseif num >= 5 then\n            roman = roman .. \"v\"\n          \
    \  num = num - 5\n        elseif num >= 4 then\n            roman = roman .. \"\
    iv\"\n            num = num - 4\n        elseif num >= 1 then\n            roman\
    \ = roman .. \"i\"\n            num = num - 1\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local result = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            result = result .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            result = result .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            result = result .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            result\
    \ = result .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            result = result .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            result = result .. \"xc\"\n            num = num\
    \ - 90\n        elseif num >= 50 then\n            result = result .. \"l\"\n\
    \            num = num - 50\n        elseif num >= 40 then\n            result\
    \ = result .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n\
    \            result = result .. \"x\"\n            num = num - 10\n        elseif\
    \ num >= 9 then\n            result = result .. \"ix\"\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            result = result .. \"v\"\n  \
    \          num = num - 5\n        elseif num >= 4 then\n            result = result\
    \ .. \"iv\"\n            num = num - 4\n        elseif num >= 1 then\n       \
    \     result = result .. \"i\"\n            num = num - 1\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = unpack(pair)\n        while number >= arabic do\n          \
    \  result = result .. roman\n            number = number - arabic\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = \"\"\n\
    \  local i = 1\n  while number > 0 do\n    local digit = number % 10\n    if digit\
    \ == 9 then\n      roman = \"ix\" .. roman\n    elseif digit == 4 then\n     \
    \ roman = \"iv\" .. roman\n    else\n      if digit >= 5 then\n        roman =\
    \ \"v\" .. roman\n        digit = digit - 5\n      end\n      for j = 1, digit\
    \ do\n        roman = \"i\" .. roman\n      end\n    end\n    number = (number\
    \ - digit) / 10\n    i = i + 1\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbt27y9e7.lua:32:\
    \ expected: \"xix\"\nactual: \"iix\"\nstack traceback:\n\t/tmp/tmpbt27y9e7.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   while number >= numeral[1] do\n            result = result .. numeral[2]\n\
    \            number = number - numeral[1]\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"\
    cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"\
    },\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n  \
    \  {1, \"i\"}\n  }\n  local result = \"\"\n  for _, pair in ipairs(roman_numerals)\
    \ do\n    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n\
    \      number = number - arabic\n      result = result .. roman\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local result = \"\"\n\
    \  local num = number\n  local numeral = {\n    {1000, \"m\"},\n    {900, \"cm\"\
    },\n    {500, \"d\"},\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90, \"xc\"\
    },\n    {50, \"l\"},\n    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"ix\"},\n\
    \    {5, \"v\"},\n    {4, \"iv\"},\n    {1, \"i\"}\n  }\n  for i = 1, #numeral\
    \ do\n    while num >= numeral[i][1] do\n      result = result .. numeral[i][2]\n\
    \      num = num - numeral[i][1]\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            roman = roman .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            roman = roman .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            roman\
    \ = roman .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. \"xc\"\n            num = num -\
    \ 90\n        elseif num >= 50 then\n            roman = roman .. \"l\"\n    \
    \        num = num - 50\n        elseif num >= 40 then\n            roman = roman\
    \ .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n     \
    \       roman = roman .. \"x\"\n            num = num - 10\n        elseif num\
    \ >= 9 then\n            roman = roman .. \"ix\"\n            num = num - 9\n\
    \        elseif num >= 5 then\n            roman = roman .. \"v\"\n          \
    \  num = num - 5\n        elseif num >= 4 then\n            roman = roman .. \"\
    iv\"\n            num = num - 4\n        elseif num >= 1 then\n            roman\
    \ = roman .. \"i\"\n            num = num - 1\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, letters = numeral[1], numeral[2]\n        while number >= value\
    \ do\n            result = result .. letters\n            number = number - value\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local result = \"\"\n\
    \  local num = number\n  local roman_numerals = {\n    {1000, \"m\"},\n    {900,\
    \ \"cm\"},\n    {500, \"d\"},\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90,\
    \ \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"\
    ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n    {1, \"i\"}\n  }\n  for i = 1, #roman_numerals\
    \ do\n    local arabic, roman = unpack(roman_numerals[i])\n    while num >= arabic\
    \ do\n      result = result .. roman\n      num = num - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"\
    cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"\
    },\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n  \
    \  {1, \"i\"}\n  }\n  local result = \"\"\n  for _, pair in ipairs(roman_numerals)\
    \ do\n    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n\
    \      number = number - arabic\n      result = result .. roman\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local i = 1\n    while num > 0 do\n        local\
    \ digit = num % 10\n        num = math.floor(num / 10)\n        if digit == 0\
    \ then\n            i = i + 1\n        else\n            roman = mini_roman_digits[i][digit]\
    \ .. roman\n            i = i + 1\n        end\n    end\n    return roman\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmptsrsa61q.lua:15:\
    \ attempt to index global 'mini_roman_digits' (a nil value)\nstack traceback:\n\
    \t/tmp/tmptsrsa61q.lua:15: in function 'candidate'\n\t/tmp/tmptsrsa61q.lua:25:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral_map = {\n        {1000, \"m\"}, {900,\
    \ \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50,\
    \ \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"\
    iv\"}, {1, \"i\"}\n    }\n    for _, pair in ipairs(numeral_map) do\n        local\
    \ arabic, roman_string = pair[1], pair[2]\n        while num >= arabic do\n  \
    \          roman = roman .. roman_string\n            num = num - arabic\n   \
    \     end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = unpack(pair)\n        while number >= arabic do\n          \
    \  result = result .. roman\n            number = number - arabic\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            roman = roman .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            roman = roman .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            roman\
    \ = roman .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. \"xc\"\n            num = num -\
    \ 90\n        elseif num >= 50 then\n            roman = roman .. \"l\"\n    \
    \        num = num - 50\n        elseif num >= 40 then\n            roman = roman\
    \ .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n     \
    \       roman = roman .. \"x\"\n            num = num - 10\n        elseif num\
    \ >= 9 then\n            roman = roman .. \"ix\"\n            num = num - 9\n\
    \        elseif num >= 5 then\n            roman = roman .. \"v\"\n          \
    \  num = num - 5\n        elseif num >= 4 then\n            roman = roman .. \"\
    iv\"\n            num = num - 4\n        elseif num >= 1 then\n            roman\
    \ = roman .. \"i\"\n            num = num - 1\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"\
    cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"\
    },\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n  \
    \  {1, \"i\"}\n  }\n  local result = \"\"\n  for _, pair in ipairs(roman_numerals)\
    \ do\n    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n\
    \      number = number - arabic\n      result = result .. roman\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"\
    cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"\
    },\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n  \
    \  {1, \"i\"}\n  }\n  local result = \"\"\n  for i = 1, #roman_numerals do\n \
    \   local arabic, roman = table.unpack(roman_numerals[i])\n    while number >=\
    \ arabic do\n      result = result .. roman\n      number = number - arabic\n\
    \    end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp1m3e_4v3.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmp1m3e_4v3.lua:23:\
    \ in function 'candidate'\n\t/tmp/tmp1m3e_4v3.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = \"\"\n\
    \  local num = number\n  while num > 0 do\n    if num >= 1000 then\n      roman\
    \ = roman .. \"m\"\n      num = num - 1000\n    elseif num >= 900 then\n     \
    \ roman = roman .. \"cm\"\n      num = num - 900\n    elseif num >= 500 then\n\
    \      roman = roman .. \"d\"\n      num = num - 500\n    elseif num >= 400 then\n\
    \      roman = roman .. \"cd\"\n      num = num - 400\n    elseif num >= 100 then\n\
    \      roman = roman .. \"c\"\n      num = num - 100\n    elseif num >= 90 then\n\
    \      roman = roman .. \"xc\"\n      num = num - 90\n    elseif num >= 50 then\n\
    \      roman = roman .. \"l\"\n      num = num - 50\n    elseif num >= 40 then\n\
    \      roman = roman .. \"xl\"\n      num = num - 40\n    elseif num >= 10 then\n\
    \      roman = roman .. \"x\"\n      num = num - 10\n    elseif num >= 9 then\n\
    \      roman = roman .. \"ix\"\n      num = num - 9\n    elseif num >= 5 then\n\
    \      roman = roman .. \"v\"\n      num = num - 5\n    elseif num >= 4 then\n\
    \      roman = roman .. \"iv\"\n      num = num - 4\n    elseif num >= 1 then\n\
    \      roman = roman .. \"i\"\n      num = num - 1\n    end\n  end\n  return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ value = pair[1]\n        local numeral = pair[2]\n        while number >= value\
    \ do\n            result = result .. numeral\n            number = number - value\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i = 1, #roman_numerals do\n        local arabic,\
    \ roman = table.unpack(roman_numerals[i])\n        while number >= arabic do\n\
    \            number = number - arabic\n            result = result .. roman\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_39ffjyt.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmp_39ffjyt.lua:23:\
    \ in function 'candidate'\n\t/tmp/tmp_39ffjyt.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i, v in ipairs(roman_numerals) do\n        local\
    \ div = math.floor(number / v[1])\n        if div > 0 then\n            result\
    \ = result .. string.rep(v[2], div)\n            number = number - div * v[1]\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral_map = {\n        {1000, \"m\"}, {900,\
    \ \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50,\
    \ \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"\
    iv\"}, {1, \"i\"}\n    }\n    for _, n in ipairs(numeral_map) do\n        local\
    \ value = n[1]\n        local letters = n[2]\n        while num >= value do\n\
    \            roman = roman .. letters\n            num = num - value\n       \
    \ end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local result = \"\"\
    \n    local numeral = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10]\
    \ = \"x\",\n        [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"\
    d\",\n        [1000] = \"m\",\n    }\n    local digits = {\n        [1] = {1,\
    \ 5, 10},\n        [2] = {10, 50, 100},\n        [3] = {100, 500, 1000},\n   \
    \ }\n    local digit_count = 0\n    while number > 0 do\n        local digit =\
    \ number % 10\n        number = math.floor(number / 10)\n        digit_count =\
    \ digit_count + 1\n        if digit == 0 then\n            -- do nothing\n   \
    \     elseif digit <= 3 then\n            result = numeral[digits[digit_count][1]]\
    \ .. result\n            for i = 1, digit - 1 do\n                result = numeral[digits[digit_count][1]]\
    \ .. result\n            end\n        elseif digit == 4 then\n            result\
    \ = numeral[digits[digit_count][1]] .. numeral[digits[digit_count][2]] .. result\n\
    \        elseif digit <= 8 then\n            result = numeral[digits[digit_count][2]]\
    \ .. result\n            for i = 1, digit - 5 do\n                result = numeral[digits[digit_count][1]]\
    \ .. result\n            end\n        elseif digit == 9 then\n            result\
    \ = numeral[digits[digit_count][1]] .. numeral[digits[digit_count][3]] .. result\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph875dgbb.lua:53:\
    \ expected: \"cdxxvi\"\nactual: \"cdxxiv\"\nstack traceback:\n\t/tmp/tmph875dgbb.lua:53:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"\
    cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"\
    },\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n  \
    \  {1, \"i\"}\n  }\n  local result = \"\"\n  for _, pair in ipairs(roman_numerals)\
    \ do\n    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n\
    \      number = number - arabic\n      result = result .. roman\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        { \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\" },\n        { \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\",\
    \ \"lx\", \"lxx\", \"lxxx\", \"xc\" },\n        { \"\", \"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\" },\n        { \"\", \"m\",\
    \ \"mm\", \"mmm\" }\n    }\n    local result = \"\"\n    local num = number\n\
    \    for i = 4, 1, -1 do\n        local digit = num % 10\n        num = (num -\
    \ digit) / 10\n        result = result .. roman_numerals[i][digit + 1]\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphv8sfunm.lua:17:\
    \ attempt to concatenate field '?' (a nil value)\nstack traceback:\n\t/tmp/tmphv8sfunm.lua:17:\
    \ in function 'candidate'\n\t/tmp/tmphv8sfunm.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local numeral = \"\
    \"\n    local numeral_table = {\n        {1000, \"m\"},\n        {900, \"cm\"\
    },\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n   \
    \     {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10,\
    \ \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n \
    \       {1, \"i\"}\n    }\n    for i = 1, #numeral_table do\n        local num\
    \ = numeral_table[i][1]\n        local roman = numeral_table[i][2]\n        while\
    \ number >= num do\n            numeral = numeral .. roman\n            number\
    \ = number - num\n        end\n    end\n    return numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral = {\n        {1000, \"m\"},\n    \
    \    {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100,\
    \ \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n\
    \        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4,\
    \ \"iv\"},\n        {1, \"i\"}\n    }\n    for i = 1, #numeral do\n        local\
    \ arabic, roman_numeral = unpack(numeral[i])\n        while num >= arabic do\n\
    \            roman = roman .. roman_numeral\n            num = num - arabic\n\
    \        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, letters = numeral[1], numeral[2]\n        while number >= value\
    \ do\n            result = result .. letters\n            number = number - value\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = ''\n \
    \ while number > 0 do\n    if number >= 1000 then\n      roman = roman .. 'm'\n\
    \      number = number - 1000\n    elseif number >= 900 then\n      roman = roman\
    \ .. 'cm'\n      number = number - 900\n    elseif number >= 500 then\n      roman\
    \ = roman .. 'd'\n      number = number - 500\n    elseif number >= 400 then\n\
    \      roman = roman .. 'cd'\n      number = number - 400\n    elseif number >=\
    \ 100 then\n      roman = roman .. 'c'\n      number = number - 100\n    elseif\
    \ number >= 90 then\n      roman = roman .. 'xc'\n      number = number - 90\n\
    \    elseif number >= 50 then\n      roman = roman .. 'l'\n      number = number\
    \ - 50\n    elseif number >= 40 then\n      roman = roman .. 'xl'\n      number\
    \ = number - 40\n    elseif number >= 10 then\n      roman = roman .. 'x'\n  \
    \    number = number - 10\n    elseif number >= 9 then\n      roman = roman ..\
    \ 'ix'\n      number = number - 9\n    elseif number >= 5 then\n      roman =\
    \ roman .. 'v'\n      number = number - 5\n    elseif number >= 4 then\n     \
    \ roman = roman .. 'iv'\n      number = number - 4\n    elseif number >= 1 then\n\
    \      roman = roman .. 'i'\n      number = number - 1\n    end\n  end\n  return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"\
    cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"\
    },\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n  \
    \  {1, \"i\"}\n  }\n  local result = \"\"\n  for i, v in ipairs(roman_numerals)\
    \ do\n    local divisor = v[1]\n    local roman_numeral = v[2]\n    while number\
    \ >= divisor do\n      result = result .. roman_numeral\n      number = number\
    \ - divisor\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        { \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\" },\n        { \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\",\
    \ \"lx\", \"lxx\", \"lxxx\", \"xc\" },\n        { \"\", \"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\" },\n        { \"\", \"m\",\
    \ \"mm\", \"mmm\" }\n    }\n    local result = \"\"\n    local num = number\n\
    \    for i = 4, 1, -1 do\n        local digit = num % 10\n        result = result\
    \ .. roman_numerals[i][digit + 1]\n        num = (num - digit) / 10\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpr338xpaa.lua:16:\
    \ attempt to concatenate field '?' (a nil value)\nstack traceback:\n\t/tmp/tmpr338xpaa.lua:16:\
    \ in function 'candidate'\n\t/tmp/tmpr338xpaa.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, letters = unpack(numeral)\n        while number >= value do\n\
    \            result = result .. letters\n            number = number - value\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral = {\n        {1000, \"m\"},\n    \
    \    {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100,\
    \ \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n\
    \        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4,\
    \ \"iv\"},\n        {1, \"i\"}\n    }\n    for i = 1, #numeral do\n        while\
    \ num >= numeral[i][1] do\n            roman = roman .. numeral[i][2]\n      \
    \      num = num - numeral[i][1]\n        end\n    end\n    return roman\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_table =\
    \ {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"cd\"\
    },\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"},\n\
    \    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n    {1,\
    \ \"i\"}\n  }\n  local result = \"\"\n  for _, pair in ipairs(roman_table) do\n\
    \    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n \
    \     number = number - arabic\n      result = result .. roman\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local result = \"\"\n    local function append_roman_numeral(number,\
    \ numeral)\n        while number >= 1 do\n            result = result .. numeral\n\
    \            number = number - 1\n        end\n    end\n    local function append_roman_numeral_with_subtraction(number,\
    \ numeral, subtraction)\n        if number >= subtraction then\n            result\
    \ = result .. numeral\n            number = number - subtraction\n        end\n\
    \        append_roman_numeral(number, numeral)\n    end\n    local function append_roman_numeral_with_subtraction_and_subtraction_numeral(number,\
    \ numeral, subtraction, subtraction_numeral)\n        if number >= subtraction\
    \ then\n            result = result .. subtraction_numeral .. numeral\n      \
    \      number = number - subtraction\n        end\n        append_roman_numeral(number,\
    \ numeral)\n    end\n    local function append_roman_numeral_with_subtraction_and_subtraction_numeral_and_subtraction_numeral_subtraction(number,\
    \ numeral, subtraction, subtraction_numeral, subtraction_numeral_subtraction)\n\
    \        if number >= subtraction then\n            result = result .. subtraction_numeral\
    \ .. numeral\n            number = number - subtraction\n        elseif number\
    \ >= subtraction_numeral_subtraction then\n            result = result .. subtraction_numeral\n\
    \            number = number - subtraction_numeral_subtraction\n        end\n\
    \        append_roman_numeral(number, numeral)\n    end\n    if number >= 1000\
    \ then\n        append_roman_numeral(number / 1000, roman_numerals[1000])\n  \
    \      number = number % 1000\n    end\n    if number >= 100 then\n        append_roman_numeral_with_subtraction_and_subtraction_numeral_and\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpntl3gnkb.lua:52: ''='' expected near ''lu''

    '
  stdout: ''
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            roman = roman .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            roman = roman .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            roman\
    \ = roman .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. \"xc\"\n            num = num -\
    \ 90\n        elseif num >= 50 then\n            roman = roman .. \"l\"\n    \
    \        num = num - 50\n        elseif num >= 40 then\n            roman = roman\
    \ .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n     \
    \       roman = roman .. \"x\"\n            num = num - 10\n        elseif num\
    \ >= 9 then\n            roman = roman .. \"ix\"\n            num = num - 9\n\
    \        elseif num >= 5 then\n            roman = roman .. \"v\"\n          \
    \  num = num - 5\n        elseif num >= 4 then\n            roman = roman .. \"\
    iv\"\n            num = num - 4\n        elseif num >= 1 then\n            roman\
    \ = roman .. \"i\"\n            num = num - 1\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local roman_numeral = \"\"\n    local digits = {}\n   \
    \ local digit = 0\n    local digit_value = 0\n    local digit_value_next = 0\n\
    \    local digit_value_prev = 0\n    local digit_value_prev_prev = 0\n    local\
    \ digit_value_next_next = 0\n    local digit_value_next_next_next = 0\n    local\
    \ digit_value_prev_prev_prev = 0\n    local digit_value_prev_prev_prev_prev =\
    \ 0\n    local digit_value_next_next_next_next = 0\n    local digit_value_next_next_next_next_next\
    \ = 0\n    local digit_value_prev_prev_prev_prev_prev = 0\n    local digit_value_prev_prev_prev_prev_prev_prev\
    \ = 0\n    local digit_value_next_next_next_next_next_next = 0\n    local digit_value_next_next_next_next_next_next_next\
    \ = 0\n    local digit_value_prev_prev_prev_prev_prev_prev_prev = 0\n    local\
    \ digit_value_prev_prev_prev_prev_prev_prev_prev_prev = 0\n    local digit_value_next_next_next_next_next_next_next_next\
    \ = 0\n    local digit_value_next_next_next_next_next_next_next_next_next = 0\n\
    \    local digit_value_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n    local\
    \ digit_value_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0\n    local\
    \ digit_value_next_next_next_next_next_next_next_next_next_next = 0\n    local\
    \ digit_value_next_next_next_next_next_next_next_next_next_\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp_l2y4zga.lua:60: ''end'' expected (to close ''function'' at
    line 5) near ''<eof>''

    '
  stdout: ''
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numeral\
    \ = \"\"\n  local roman_numerals = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n\
    \    {500, \"d\"},\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n\
    \    {50, \"l\"},\n    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"ix\"},\n   \
    \ {5, \"v\"},\n    {4, \"iv\"},\n    {1, \"i\"}\n  }\n  for i = 1, #roman_numerals\
    \ do\n    while number >= roman_numerals[i][1] do\n      roman_numeral = roman_numeral\
    \ .. roman_numerals[i][2]\n      number = number - roman_numerals[i][1]\n    end\n\
    \  end\n  return roman_numeral\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i, v in ipairs(roman_numerals) do\n        while\
    \ number >= v[1] do\n            result = result .. v[2]\n            number =\
    \ number - v[1]\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local result = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            result = result .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            result = result .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            result = result .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            result\
    \ = result .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            result = result .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            result = result .. \"xc\"\n            num = num\
    \ - 90\n        elseif num >= 50 then\n            result = result .. \"l\"\n\
    \            num = num - 50\n        elseif num >= 40 then\n            result\
    \ = result .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n\
    \            result = result .. \"x\"\n            num = num - 10\n        elseif\
    \ num >= 9 then\n            result = result .. \"ix\"\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            result = result .. \"v\"\n  \
    \          num = num - 5\n        elseif num >= 4 then\n            result = result\
    \ .. \"iv\"\n            num = num - 4\n        elseif num >= 1 then\n       \
    \     result = result .. \"i\"\n            num = num - 1\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = ''\n \
    \ local num = number\n  local numeral = {\n    {'i', 1},\n    {'v', 5},\n    {'x',\
    \ 10},\n    {'l', 50},\n    {'c', 100},\n    {'d', 500},\n    {'m', 1000}\n  }\n\
    \  for i = #numeral, 1, -1 do\n    local n = numeral[i]\n    local r = n[1]\n\
    \    local v = n[2]\n    while num >= v do\n      roman = roman .. r\n      num\
    \ = num - v\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2x1ux1ep.lua:32:\
    \ expected: \"xix\"\nactual: \"xviiii\"\nstack traceback:\n\t/tmp/tmp2x1ux1ep.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"\
    cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"\
    },\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n  \
    \  {1, \"i\"}\n  }\n  local result = \"\"\n  for i = 1, #roman_numerals do\n \
    \   local arabic, roman = table.unpack(roman_numerals[i])\n    while number >=\
    \ arabic do\n      result = result .. roman\n      number = number - arabic\n\
    \    end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp1m3e_4v3.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmp1m3e_4v3.lua:23:\
    \ in function 'candidate'\n\t/tmp/tmp1m3e_4v3.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i = 1, #roman_numerals do\n        local arabic,\
    \ roman = table.unpack(roman_numerals[i])\n        while number >= arabic do\n\
    \            number = number - arabic\n            result = result .. roman\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_39ffjyt.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmp_39ffjyt.lua:23:\
    \ in function 'candidate'\n\t/tmp/tmp_39ffjyt.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local arabic = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n\
    \    local roman_numeral = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n    for i = 1, #arabic do\n  \
    \      while number >= arabic[i] do\n            roman = roman .. roman_numeral[i]\n\
    \            number = number - arabic[i]\n        end\n    end\n    return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral_value = {\n        {1000, \"m\"},\n\
    \        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n     \
    \   {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"\
    xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n    \
    \    {4, \"iv\"},\n        {1, \"i\"}\n    }\n    for _, pair in ipairs(numeral_value)\
    \ do\n        local value = pair[1]\n        local letters = pair[2]\n       \
    \ while num >= value do\n            roman = roman .. letters\n            num\
    \ = num - value\n        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = ''\n \
    \ local num = number\n  local numeral_value = {\n    {'m', 1000},\n    {'cm',\
    \ 900},\n    {'d', 500},\n    {'cd', 400},\n    {'c', 100},\n    {'xc', 90},\n\
    \    {'l', 50},\n    {'xl', 40},\n    {'x', 10},\n    {'ix', 9},\n    {'v', 5},\n\
    \    {'iv', 4},\n    {'i', 1}\n  }\n  for k, v in ipairs(numeral_value) do\n \
    \   local s, n = v[1], v[2]\n    while num >= n do\n      roman = roman .. s\n\
    \      num = num - n\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = \"\"\n\
    \  local roman_numerals = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500,\
    \ \"d\"},\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50,\
    \ \"l\"},\n    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"\
    },\n    {4, \"iv\"},\n    {1, \"i\"}\n  }\n  for i = 1, #roman_numerals do\n \
    \   local arabic, roman_numeral = unpack(roman_numerals[i])\n    while number\
    \ >= arabic do\n      roman = roman .. roman_numeral\n      number = number -\
    \ arabic\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = \"\"\n\
    \  local num = number\n  if num >= 1000 then\n    roman = roman .. \"m\"\n   \
    \ num = num - 1000\n  end\n  if num >= 900 then\n    roman = roman .. \"cm\"\n\
    \    num = num - 900\n  end\n  if num >= 500 then\n    roman = roman .. \"d\"\n\
    \    num = num - 500\n  end\n  if num >= 400 then\n    roman = roman .. \"cd\"\
    \n    num = num - 400\n  end\n  if num >= 100 then\n    roman = roman .. \"c\"\
    \n    num = num - 100\n  end\n  if num >= 90 then\n    roman = roman .. \"xc\"\
    \n    num = num - 90\n  end\n  if num >= 50 then\n    roman = roman .. \"l\"\n\
    \    num = num - 50\n  end\n  if num >= 40 then\n    roman = roman .. \"xl\"\n\
    \    num = num - 40\n  end\n  if num >= 10 then\n    roman = roman .. \"x\"\n\
    \    num = num - 10\n  end\n  if num >= 9 then\n    roman = roman .. \"ix\"\n\
    \    num = num - 9\n  end\n  if num >= 5 then\n    roman = roman .. \"v\"\n  \
    \  num = num - 5\n  end\n  if num >= 4 then\n    roman = roman .. \"iv\"\n   \
    \ num = num - 4\n  end\n  if num >= 1 then\n    roman = roman .. \"i\"\n    num\
    \ = num - 1\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1_hfq1sc.lua:67:\
    \ expected: \"clii\"\nactual: \"cli\"\nstack traceback:\n\t/tmp/tmp1_hfq1sc.lua:67:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = {\n\
    \        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n     \
    \   {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50,\
    \ \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n\
    \        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"},\n    }\n    local\
    \ result = \"\"\n    for _, v in ipairs(roman) do\n        while number >= v[1]\
    \ do\n            result = result .. v[2]\n            number = number - v[1]\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = {\n  \
    \  {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"cd\"},\n\
    \    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"},\n \
    \   {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n    {1,\
    \ \"i\"}\n  }\n  local result = \"\"\n  for i = 1, #roman do\n    local arabic,\
    \ roman_string = unpack(roman[i])\n    while number >= arabic do\n      result\
    \ = result .. roman_string\n      number = number - arabic\n    end\n  end\n \
    \ return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = unpack(pair)\n        while number >= arabic do\n          \
    \  result = result .. roman\n            number = number - arabic\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numeral\
    \ = \"\"\n    local roman_numerals = {\n        {1000, \"m\"},\n        {900,\
    \ \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"\
    },\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n     \
    \   {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"\
    },\n        {1, \"i\"}\n    }\n    for _, pair in ipairs(roman_numerals) do\n\
    \        local arabic, roman = pair[1], pair[2]\n        while number >= arabic\
    \ do\n            roman_numeral = roman_numeral .. roman\n            number =\
    \ number - arabic\n        end\n    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local roman_numerals = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n\
    \        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n      \
    \  {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"\
    x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n     \
    \   {1, \"i\"}\n    }\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, letters = numeral[1], numeral[2]\n        while number >= value\
    \ do\n            roman = roman .. letters\n            number = number - value\n\
    \        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            roman = roman .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            roman = roman .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            roman\
    \ = roman .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. \"xc\"\n            num = num -\
    \ 90\n        elseif num >= 50 then\n            roman = roman .. \"l\"\n    \
    \        num = num - 50\n        elseif num >= 40 then\n            roman = roman\
    \ .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n     \
    \       roman = roman .. \"x\"\n            num = num - 10\n        elseif num\
    \ >= 9 then\n            roman = roman .. \"ix\"\n            num = num - 9\n\
    \        elseif num >= 5 then\n            roman = roman .. \"v\"\n          \
    \  num = num - 5\n        elseif num >= 4 then\n            roman = roman .. \"\
    iv\"\n            num = num - 4\n        elseif num >= 1 then\n            roman\
    \ = roman .. \"i\"\n            num = num - 1\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = ''\n \
    \ local num = number\n  local numeral_map = {\n    {1000, 'm'},\n    {900, 'cm'},\n\
    \    {500, 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50,\
    \ 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4,\
    \ 'iv'},\n    {1, 'i'},\n  }\n  for _, pair in ipairs(numeral_map) do\n    local\
    \ arabic, roman_string = pair[1], pair[2]\n    if num >= arabic then\n      local\
    \ quotient = math.floor(num / arabic)\n      roman = roman .. roman_string:rep(quotient)\n\
    \      num = num - arabic * quotient\n    end\n  end\n  return roman\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i = 1, #roman_numerals do\n        local arabic,\
    \ roman = table.unpack(roman_numerals[i])\n        while number >= arabic do\n\
    \            number = number - arabic\n            result = result .. roman\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_39ffjyt.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmp_39ffjyt.lua:23:\
    \ in function 'candidate'\n\t/tmp/tmp_39ffjyt.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = {\n  \
    \  {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"cd\"},\n\
    \    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"},\n \
    \   {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n    {1,\
    \ \"i\"}\n  }\n  local result = \"\"\n  for i = 1, #roman do\n    local div =\
    \ math.floor(number / roman[i][1])\n    if div > 0 then\n      result = result\
    \ .. roman[i][2]:rep(div)\n      number = number - div * roman[i][1]\n    end\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = \"\"\n\
    \  local num = number\n  local m = math.floor(num / 1000)\n  num = num - m * 1000\n\
    \  local d = math.floor(num / 500)\n  num = num - d * 500\n  local c = math.floor(num\
    \ / 100)\n  num = num - c * 100\n  local l = math.floor(num / 50)\n  num = num\
    \ - l * 50\n  local x = math.floor(num / 10)\n  num = num - x * 10\n  local v\
    \ = math.floor(num / 5)\n  num = num - v * 5\n  local i = num\n  roman = string.rep(\"\
    m\", m) .. string.rep(\"d\", d) .. string.rep(\"c\", c) ..\n  string.rep(\"l\"\
    , l) .. string.rep(\"x\", x) .. string.rep(\"v\", v) ..\n  string.rep(\"i\", i)\n\
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkohbpti5.lua:30:\
    \ expected: \"xix\"\nactual: \"xviiii\"\nstack traceback:\n\t/tmp/tmpkohbpti5.lua:30:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            roman = roman .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            roman = roman .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            roman\
    \ = roman .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. \"xc\"\n            num = num -\
    \ 90\n        elseif num >= 50 then\n            roman = roman .. \"l\"\n    \
    \        num = num - 50\n        elseif num >= 40 then\n            roman = roman\
    \ .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n     \
    \       roman = roman .. \"x\"\n            num = num - 10\n        elseif num\
    \ >= 9 then\n            roman = roman .. \"ix\"\n            num = num - 9\n\
    \        elseif num >= 5 then\n            roman = roman .. \"v\"\n          \
    \  num = num - 5\n        elseif num >= 4 then\n            roman = roman .. \"\
    iv\"\n            num = num - 4\n        elseif num >= 1 then\n            roman\
    \ = roman .. \"i\"\n            num = num - 1\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"\
    cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"\
    },\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n  \
    \  {1, \"i\"}\n  }\n  local result = \"\"\n  for _, pair in ipairs(roman_numerals)\
    \ do\n    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n\
    \      number = number - arabic\n      result = result .. roman\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral_map = {\n        {1000, \"m\"}, {900,\
    \ \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50,\
    \ \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"\
    iv\"}, {1, \"i\"}\n    }\n    for _, n in ipairs(numeral_map) do\n        while\
    \ num >= n[1] do\n            roman = roman .. n[2]\n            num = num - n[1]\n\
    \        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, letters = numeral[1], numeral[2]\n        while number >= value\
    \ do\n            result = result .. letters\n            number = number - value\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = 'i',\n        [5] = 'v',\n        [10] = 'x',\n        [50]\
    \ = 'l',\n        [100] = 'c',\n        [500] = 'd',\n        [1000] = 'm',\n\
    \    }\n    local roman_numeral = ''\n    local digit = 0\n    local digit_value\
    \ = 0\n    local digit_value_1 = 0\n    local digit_value_5 = 0\n    local digit_value_10\
    \ = 0\n    local digit_value_50 = 0\n    local digit_value_100 = 0\n    local\
    \ digit_value_500 = 0\n    local digit_value_1000 = 0\n    local digit_value_next\
    \ = 0\n    local digit_value_next_1 = 0\n    local digit_value_next_5 = 0\n  \
    \  local digit_value_next_10 = 0\n    local digit_value_next_50 = 0\n    local\
    \ digit_value_next_100 = 0\n    local digit_value_next_500 = 0\n    local digit_value_next_1000\
    \ = 0\n    local digit_value_next_next = 0\n    local digit_value_next_next_1\
    \ = 0\n    local digit_value_next_next_5 = 0\n    local digit_value_next_next_10\
    \ = 0\n    local digit_value_next_next_50 = 0\n    local digit_value_next_next_100\
    \ = 0\n    local digit_value_next_next_500 = 0\n    local digit_value_next_next_1000\
    \ = 0\n    local digit_value_next_next_next = 0\n    local digit_value_next_next_next_1\
    \ = 0\n    local digit_value_next_next_next_5 = 0\n    local digit_value_next_next_next_10\
    \ = 0\n    local digit_value_next_next_next_50 = 0\n    local digit_value_next_next_next_100\
    \ = 0\n    local digit_value_next_next_next_500 = 0\n    local digit_value_next_next_next_1000\
    \ = 0\n    local digit_value_next_next_\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp6s6p_xfz.lua:70: ''end'' expected (to close ''function'' at
    line 5) near ''<eof>''

    '
  stdout: ''
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local arabic, roman = unpack(numeral)\n        while number >= arabic do\n\
    \            result = result .. roman\n            number = number - arabic\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = {\n\
    \        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n     \
    \   {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50,\
    \ \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n\
    \        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"},\n    }\n    local\
    \ result = \"\"\n    for _, pair in ipairs(roman) do\n        local arabic, roman_numeral\
    \ = unpack(pair)\n        while number >= arabic do\n            result = result\
    \ .. roman_numeral\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = table.unpack(pair)\n        while number >= arabic do\n    \
    \        result = result .. roman\n            number = number - arabic\n    \
    \    end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzkodzyut.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmpzkodzyut.lua:23:\
    \ in function 'candidate'\n\t/tmp/tmpzkodzyut.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local result = \"\"\n    local num = number\n    local\
    \ factor = 1\n    while num > 0 do\n        local digit = num % 10\n        if\
    \ digit == 4 then\n            result = roman_numerals[factor] .. roman_numerals[factor\
    \ * 5] .. result\n        elseif digit == 9 then\n            result = roman_numerals[factor]\
    \ .. roman_numerals[factor * 10] .. result\n        else\n            local numeral\
    \ = \"\"\n            if digit >= 5 then\n                numeral = roman_numerals[factor\
    \ * 5]\n                digit = digit - 5\n            end\n            numeral\
    \ = numeral .. string.rep(roman_numerals[factor], digit)\n            result =\
    \ numeral .. result\n        end\n        num = math.floor(num / 10)\n       \
    \ factor = factor * 10\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = unpack(pair)\n        while number >= arabic do\n          \
    \  result = result .. roman\n            number = number - arabic\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            roman = roman .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            roman = roman .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            roman\
    \ = roman .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. \"xc\"\n            num = num -\
    \ 90\n        elseif num >= 50 then\n            roman = roman .. \"l\"\n    \
    \        num = num - 50\n        elseif num >= 40 then\n            roman = roman\
    \ .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n     \
    \       roman = roman .. \"x\"\n            num = num - 10\n        elseif num\
    \ >= 9 then\n            roman = roman .. \"ix\"\n            num = num - 9\n\
    \        elseif num >= 5 then\n            roman = roman .. \"v\"\n          \
    \  num = num - 5\n        elseif num >= 4 then\n            roman = roman .. \"\
    iv\"\n            num = num - 4\n        elseif num >= 1 then\n            roman\
    \ = roman .. \"i\"\n            num = num - 1\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = {\n\
    \        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n     \
    \   {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50,\
    \ \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n\
    \        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"},\n    }\n    local\
    \ result = \"\"\n    for i = 1, #roman do\n        local n, r = roman[i][1], roman[i][2]\n\
    \        while number >= n do\n            result = result .. r\n            number\
    \ = number - n\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = {\n\
    \        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n     \
    \   {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50,\
    \ \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n\
    \        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"},\n    }\n    local\
    \ result = \"\"\n    for _, pair in ipairs(roman) do\n        local arabic, roman_numeral\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman_numeral\n            number = number - arabic\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral_map = {\n        {1000, \"m\"}, {900,\
    \ \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50,\
    \ \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"\
    iv\"}, {1, \"i\"}\n    }\n    for _, pair in ipairs(numeral_map) do\n        local\
    \ arabic, roman_string = pair[1], pair[2]\n        while num >= arabic do\n  \
    \          roman = roman .. roman_string\n            num = num - arabic\n   \
    \     end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local roman_numerals_order = {1000, 500, 100, 50, 10, 5,\
    \ 1}\n    local result = \"\"\n    for _, roman_numeral_value in ipairs(roman_numerals_order)\
    \ do\n        local num_of_roman_numeral = math.floor(number / roman_numeral_value)\n\
    \        number = number % roman_numeral_value\n        if num_of_roman_numeral\
    \ == 4 then\n            result = result .. roman_numerals[roman_numeral_value]\
    \ .. roman_numerals[roman_numeral_value * 5]\n        elseif num_of_roman_numeral\
    \ == 9 then\n            result = result .. roman_numerals[roman_numeral_value]\
    \ .. roman_numerals[roman_numeral_value * 10]\n        else\n            result\
    \ = result .. roman_numerals[roman_numeral_value]:rep(num_of_roman_numeral)\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppzbcdmsc.lua:34:\
    \ expected: \"xix\"\nactual: \"xviv\"\nstack traceback:\n\t/tmp/tmppzbcdmsc.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = ''\n\
    \    local num = number\n    local numeral_map = {\n        {1000, 'm'},\n   \
    \     {900, 'cm'},\n        {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n\
    \        {90, 'xc'},\n        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n\
    \        {9, 'ix'},\n        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'},\n\
    \    }\n    for _, pair in ipairs(numeral_map) do\n        local arabic, roman_string\
    \ = pair[1], pair[2]\n        while num >= arabic do\n            roman = roman\
    \ .. roman_string\n            num = num - arabic\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral = {\n        {1000, \"m\"},\n    \
    \    {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100,\
    \ \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n\
    \        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4,\
    \ \"iv\"},\n        {1, \"i\"}\n    }\n    for _, v in ipairs(numeral) do\n  \
    \      while num >= v[1] do\n            roman = roman .. v[2]\n            num\
    \ = num - v[1]\n        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numeral\
    \ = \"\"\n    local numeral_map = {\n        {1000, \"m\"},\n        {900, \"\
    cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n\
    \        {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10,\
    \ \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n \
    \       {1, \"i\"},\n    }\n    for _, numeral in ipairs(numeral_map) do\n   \
    \     local arabic, roman = numeral[1], numeral[2]\n        while number >= arabic\
    \ do\n            roman_numeral = roman_numeral .. roman\n            number =\
    \ number - arabic\n        end\n    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i = 1, #roman_numerals do\n        local arabic,\
    \ roman = table.unpack(roman_numerals[i])\n        while number >= arabic do\n\
    \            number = number - arabic\n            result = result .. roman\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_39ffjyt.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmp_39ffjyt.lua:23:\
    \ in function 'candidate'\n\t/tmp/tmp_39ffjyt.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, letters = numeral[1], numeral[2]\n        while number >= value\
    \ do\n            result = result .. letters\n            number = number - value\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numeral\
    \ = \"\"\n    local num = number\n    local numeral_map = {\n        {1000, \"\
    m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"},\n\
    \        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n        {40,\
    \ \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n\
    \        {4, \"iv\"},\n        {1, \"i\"},\n    }\n    for _, pair in ipairs(numeral_map)\
    \ do\n        local value = pair[1]\n        local numeral = pair[2]\n       \
    \ while num >= value do\n            roman_numeral = roman_numeral .. numeral\n\
    \            num = num - value\n        end\n    end\n    return roman_numeral\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, letters = numeral[1], numeral[2]\n        while number >= value\
    \ do\n            result = result .. letters\n            number = number - value\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral_map = {\n        {1000, \"m\"}, {900,\
    \ \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50,\
    \ \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"\
    iv\"}, {1, \"i\"}\n    }\n    for k, v in ipairs(numeral_map) do\n        while\
    \ num >= v[1] do\n            roman = roman .. v[2]\n            num = num - v[1]\n\
    \        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"\
    cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"\
    },\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n  \
    \  {1, \"i\"}\n  }\n  local result = \"\"\n  for _, pair in ipairs(roman_numerals)\
    \ do\n    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n\
    \      number = number - arabic\n      result = result .. roman\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    {'i', 'v'},\n    {'x', 'l'},\n    {'c', 'd'},\n    {'m'}\n  }\n  local\
    \ roman_string = ''\n  local index = 1\n  local digit\n  while number > 0 do\n\
    \    digit = number % 10\n    if digit > 0 then\n      if digit < 4 then\n   \
    \     roman_string = string.rep(roman_numerals[index][1], digit) .. roman_string\n\
    \      elseif digit == 4 then\n        roman_string = roman_numerals[index][1]\
    \ .. roman_numerals[index][2] .. roman_string\n      elseif digit == 5 then\n\
    \        roman_string = roman_numerals[index][2] .. roman_string\n      elseif\
    \ digit < 9 then\n        roman_string = roman_numerals[index][2] .. string.rep(roman_numerals[index][1],\
    \ digit - 5) .. roman_string\n      else\n        roman_string = roman_numerals[index][1]\
    \ .. roman_numerals[index + 1][1] .. roman_string\n      end\n    end\n    index\
    \ = index + 1\n    number = math.floor(number / 10)\n  end\n  return roman_string\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    while num >= 1000 do\n        roman = roman .. \"\
    m\"\n        num = num - 1000\n    end\n    if num >= 900 then\n        roman\
    \ = roman .. \"cm\"\n        num = num - 900\n    end\n    if num >= 500 then\n\
    \        roman = roman .. \"d\"\n        num = num - 500\n    end\n    if num\
    \ >= 400 then\n        roman = roman .. \"cd\"\n        num = num - 400\n    end\n\
    \    while num >= 100 do\n        roman = roman .. \"c\"\n        num = num -\
    \ 100\n    end\n    if num >= 90 then\n        roman = roman .. \"xc\"\n     \
    \   num = num - 90\n    end\n    if num >= 50 then\n        roman = roman .. \"\
    l\"\n        num = num - 50\n    end\n    if num >= 40 then\n        roman = roman\
    \ .. \"xl\"\n        num = num - 40\n    end\n    while num >= 10 do\n       \
    \ roman = roman .. \"x\"\n        num = num - 10\n    end\n    if num >= 9 then\n\
    \        roman = roman .. \"ix\"\n        num = num - 9\n    end\n    if num >=\
    \ 5 then\n        roman = roman .. \"v\"\n        num = num - 5\n    end\n   \
    \ if num >= 4 then\n        roman = roman .. \"iv\"\n        num = num - 4\n \
    \   end\n    while num >= 1 do\n        roman = roman .. \"i\"\n        num =\
    \ num - 1\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local roman_numeral = \"\"\n    local num = number\n  \
    \  while num > 0 do\n        local digit = num % 10\n        if digit == 9 then\n\
    \            roman_numeral = roman_numerals[1] .. roman_numerals[10] .. roman_numeral\n\
    \        elseif digit == 4 then\n            roman_numeral = roman_numerals[1]\
    \ .. roman_numerals[5] .. roman_numeral\n        elseif digit >= 5 then\n    \
    \        roman_numeral = roman_numerals[5] .. string.rep(roman_numerals[1], digit\
    \ - 5) .. roman_numeral\n        else\n            roman_numeral = string.rep(roman_numerals[1],\
    \ digit) .. roman_numeral\n        end\n        num = math.floor(num / 10)\n \
    \   end\n    return roman_numeral\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl8lf3xd6.lua:36:\
    \ expected: \"xix\"\nactual: \"iix\"\nstack traceback:\n\t/tmp/tmpl8lf3xd6.lua:36:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local result = \"\"\n    local num = number\n    local\
    \ digit = 0\n    local digit_value = 0\n    local digit_value_next = 0\n    local\
    \ digit_value_next_next = 0\n    local digit_value_prev = 0\n    local digit_value_prev_prev\
    \ = 0\n    while num > 0 do\n        digit = num % 10\n        digit_value = digit\
    \ * 10 ^ digit\n        digit_value_next = digit_value * 10\n        digit_value_next_next\
    \ = digit_value_next * 10\n        digit_value_prev = digit_value / 10\n     \
    \   digit_value_prev_prev = digit_value_prev / 10\n        if digit == 9 then\n\
    \            result = roman_numerals[digit_value_prev] .. roman_numerals[digit_value_next]\
    \ .. result\n        elseif digit >= 5 then\n            result = roman_numerals[digit_value_prev]\
    \ .. string.rep(roman_numerals[digit_value], digit - 5) .. result\n        elseif\
    \ digit == 4 then\n            result = roman_numerals[digit_value_prev] .. roman_numerals[digit_value]\
    \ .. result\n        else\n            result = string.rep(roman_numerals[digit_value],\
    \ digit) .. result\n        end\n        num = math.floor(num / 10)\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpiplkbwej.lua:31:\
    \ attempt to concatenate field '?' (a nil value)\nstack traceback:\n\t/tmp/tmpiplkbwej.lua:31:\
    \ in function 'candidate'\n\t/tmp/tmpiplkbwej.lua:47: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = ''\n\
    \    local num = number\n    while num > 0 do\n        if num >= 1000 then\n \
    \           roman = roman .. 'm'\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. 'cm'\n            num = num -\
    \ 900\n        elseif num >= 500 then\n            roman = roman .. 'd'\n    \
    \        num = num - 500\n        elseif num >= 400 then\n            roman =\
    \ roman .. 'cd'\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. 'c'\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. 'xc'\n            num = num - 90\n\
    \        elseif num >= 50 then\n            roman = roman .. 'l'\n           \
    \ num = num - 50\n        elseif num >= 40 then\n            roman = roman ..\
    \ 'xl'\n            num = num - 40\n        elseif num >= 10 then\n          \
    \  roman = roman .. 'x'\n            num = num - 10\n        elseif num >= 9 then\n\
    \            roman = roman .. 'ix'\n            num = num - 9\n        elseif\
    \ num >= 5 then\n            roman = roman .. 'v'\n            num = num - 5\n\
    \        elseif num >= 4 then\n            roman = roman .. 'iv'\n           \
    \ num = num - 4\n        elseif num >= 1 then\n            roman = roman .. 'i'\n\
    \            num = num - 1\n        end\n    end\n    return roman\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = table.unpack(pair)\n        while number >= arabic do\n    \
    \        result = result .. roman\n            number = number - arabic\n    \
    \    end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzkodzyut.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmpzkodzyut.lua:23:\
    \ in function 'candidate'\n\t/tmp/tmpzkodzyut.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local result = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            result = result .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            result = result .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            result = result .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            result\
    \ = result .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            result = result .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            result = result .. \"xc\"\n            num = num\
    \ - 90\n        elseif num >= 50 then\n            result = result .. \"l\"\n\
    \            num = num - 50\n        elseif num >= 40 then\n            result\
    \ = result .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n\
    \            result = result .. \"x\"\n            num = num - 10\n        elseif\
    \ num >= 9 then\n            result = result .. \"ix\"\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            result = result .. \"v\"\n  \
    \          num = num - 5\n        elseif num >= 4 then\n            result = result\
    \ .. \"iv\"\n            num = num - 4\n        elseif num >= 1 then\n       \
    \     result = result .. \"i\"\n            num = num - 1\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        { \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\" },\n        { \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\",\
    \ \"lx\", \"lxx\", \"lxxx\", \"xc\" },\n        { \"\", \"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\" },\n        { \"\", \"m\",\
    \ \"mm\", \"mmm\" }\n    }\n    local result = \"\"\n    local thousands = math.floor(number\
    \ / 1000)\n    local hundreds = math.floor((number % 1000) / 100)\n    local tens\
    \ = math.floor((number % 100) / 10)\n    local ones = number % 10\n    result\
    \ = roman_numerals[4][thousands + 1] ..\n             roman_numerals[3][hundreds\
    \ + 1] ..\n             roman_numerals[2][tens + 1] ..\n             roman_numerals[1][ones\
    \ + 1]\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local symbols = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n    \
    \    {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90,\
    \ \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n\
    \        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1,\
    \ \"i\"}\n    }\n    for _, symbol in ipairs(symbols) do\n        while number\
    \ >= symbol[1] do\n            roman = roman .. symbol[2]\n            number\
    \ = number - symbol[1]\n        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local result = \"\"\n    local num = number\n    local\
    \ factor = 1\n    while num > 0 do\n        local digit = num % 10\n        if\
    \ digit == 4 then\n            result = roman_numerals[factor] .. roman_numerals[factor\
    \ * 5] .. result\n        elseif digit == 9 then\n            result = roman_numerals[factor]\
    \ .. roman_numerals[factor * 10] .. result\n        else\n            local numeral\
    \ = roman_numerals[factor]\n            if digit >= 5 then\n                numeral\
    \ = roman_numerals[factor * 5]\n                digit = digit - 5\n          \
    \  end\n            result = numeral:rep(digit) .. result\n        end\n     \
    \   num = math.floor(num / 10)\n        factor = factor * 10\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6tvbneeh.lua:42:\
    \ expected: \"clii\"\nactual: \"cii\"\nstack traceback:\n\t/tmp/tmp6tvbneeh.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local result = \"\"\n    local digit = 0\n    local num\
    \ = number\n    while num > 0 do\n        digit = num % 10\n        if digit ==\
    \ 9 then\n            result = roman_numerals[1] .. roman_numerals[10] .. result\n\
    \        elseif digit == 4 then\n            result = roman_numerals[1] .. roman_numerals[5]\
    \ .. result\n        elseif digit >= 5 then\n            result = roman_numerals[5]\
    \ .. string.rep(roman_numerals[1], digit - 5) .. result\n        else\n      \
    \      result = string.rep(roman_numerals[1], digit) .. result\n        end\n\
    \        num = math.floor(num / 10)\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz2zvv5in.lua:37:\
    \ expected: \"xix\"\nactual: \"iix\"\nstack traceback:\n\t/tmp/tmpz2zvv5in.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            roman = roman .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            roman = roman .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            roman\
    \ = roman .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. \"xc\"\n            num = num -\
    \ 90\n        elseif num >= 50 then\n            roman = roman .. \"l\"\n    \
    \        num = num - 50\n        elseif num >= 40 then\n            roman = roman\
    \ .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n     \
    \       roman = roman .. \"x\"\n            num = num - 10\n        elseif num\
    \ >= 9 then\n            roman = roman .. \"ix\"\n            num = num - 9\n\
    \        elseif num >= 5 then\n            roman = roman .. \"v\"\n          \
    \  num = num - 5\n        elseif num >= 4 then\n            roman = roman .. \"\
    iv\"\n            num = num - 4\n        elseif num >= 1 then\n            roman\
    \ = roman .. \"i\"\n            num = num - 1\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = ''\n \
    \ local num = number\n  while num > 0 do\n    if num >= 1000 then\n      roman\
    \ = roman .. 'm'\n      num = num - 1000\n    elseif num >= 900 then\n      roman\
    \ = roman .. 'cm'\n      num = num - 900\n    elseif num >= 500 then\n      roman\
    \ = roman .. 'd'\n      num = num - 500\n    elseif num >= 400 then\n      roman\
    \ = roman .. 'cd'\n      num = num - 400\n    elseif num >= 100 then\n      roman\
    \ = roman .. 'c'\n      num = num - 100\n    elseif num >= 90 then\n      roman\
    \ = roman .. 'xc'\n      num = num - 90\n    elseif num >= 50 then\n      roman\
    \ = roman .. 'l'\n      num = num - 50\n    elseif num >= 40 then\n      roman\
    \ = roman .. 'xl'\n      num = num - 40\n    elseif num >= 10 then\n      roman\
    \ = roman .. 'x'\n      num = num - 10\n    elseif num >= 9 then\n      roman\
    \ = roman .. 'ix'\n      num = num - 9\n    elseif num >= 5 then\n      roman\
    \ = roman .. 'v'\n      num = num - 5\n    elseif num >= 4 then\n      roman =\
    \ roman .. 'iv'\n      num = num - 4\n    elseif num >= 1 then\n      roman =\
    \ roman .. 'i'\n      num = num - 1\n    end\n  end\n  return roman\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            roman = roman .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            roman = roman .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            roman\
    \ = roman .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. \"xc\"\n            num = num -\
    \ 90\n        elseif num >= 50 then\n            roman = roman .. \"l\"\n    \
    \        num = num - 50\n        elseif num >= 40 then\n            roman = roman\
    \ .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n     \
    \       roman = roman .. \"x\"\n            num = num - 10\n        elseif num\
    \ >= 9 then\n            roman = roman .. \"ix\"\n            num = num - 9\n\
    \        elseif num >= 5 then\n            roman = roman .. \"v\"\n          \
    \  num = num - 5\n        elseif num >= 4 then\n            roman = roman .. \"\
    iv\"\n            num = num - 4\n        elseif num >= 1 then\n            roman\
    \ = roman .. \"i\"\n            num = num - 1\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i, v in ipairs(roman_numerals) do\n        while\
    \ number >= v[1] do\n            result = result .. v[2]\n            number =\
    \ number - v[1]\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = {}\n \
    \ local num = number\n  local digits = {1, 4, 5, 9, 10, 40, 50, 90, 100, 400,\
    \ 500, 900, 1000}\n  local romans = {\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\"\
    , \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"}\n  for i = #digits, 1, -1\
    \ do\n    while num >= digits[i] do\n      roman[#roman + 1] = romans[i]\n   \
    \   num = num - digits[i]\n    end\n  end\n  return table.concat(roman)\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   while number >= numeral[1] do\n            result = result .. numeral[2]\n\
    \            number = number - numeral[1]\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local digits = {\n        [1] = {1, 5, 10},\n        [2]\
    \ = {10, 50, 100},\n        [3] = {100, 500, 1000},\n        [4] = {1000, nil,\
    \ nil},\n    }\n    local result = \"\"\n    local digit_index = 1\n    while\
    \ number > 0 do\n        local digit = number % 10\n        local digit_values\
    \ = digits[digit_index]\n        if digit == 4 then\n            result = roman_numerals[digit_values[1]]\
    \ .. roman_numerals[digit_values[2]] .. result\n        elseif digit == 9 then\n\
    \            result = roman_numerals[digit_values[1]] .. roman_numerals[digit_values[3]]\
    \ .. result\n        else\n            local digit_roman = \"\"\n            if\
    \ digit >= 5 then\n                digit_roman = roman_numerals[digit_values[2]]\n\
    \                digit = digit - 5\n            end\n            digit_roman =\
    \ digit_roman .. string.rep(roman_numerals[digit_values[1]], digit)\n        \
    \    result = digit_roman .. result\n        end\n        number = math.floor(number\
    \ / 10)\n        digit_index = digit_index + 1\n    end\n    return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local result = ''\n\
    \    local numeral_map = {\n        {1000, 'm'}, {900, 'cm'}, {500, 'd'}, {400,\
    \ 'cd'},\n        {100, 'c'}, {90, 'xc'}, {50, 'l'}, {40, 'xl'},\n        {10,\
    \ 'x'}, {9, 'ix'}, {5, 'v'}, {4, 'iv'}, {1, 'i'}\n    }\n    for _, pair in ipairs(numeral_map)\
    \ do\n        local arabic, roman = table.unpack(pair)\n        while number >=\
    \ arabic do\n            result = result .. roman\n            number = number\
    \ - arabic\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdhlgpk70.lua:13:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmpdhlgpk70.lua:13:\
    \ in function 'candidate'\n\t/tmp/tmpdhlgpk70.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    for i, v in ipairs(mini_roman_table) do\n        while number >= v[1] do\n\
    \            roman = roman .. v[2]\n            number = number - v[1]\n     \
    \   end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_4sycrk1.lua:7:\
    \ bad argument #1 to 'ipairs' (table expected, got nil)\nstack traceback:\n\t\
    /tmp/tmp_4sycrk1.lua:7: in function 'candidate'\n\t/tmp/tmp_4sycrk1.lua:19: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i, v in ipairs(roman_numerals) do\n        while\
    \ number >= v[1] do\n            result = result .. v[2]\n            number =\
    \ number - v[1]\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = {\n\
    \        {'i', 'v'},\n        {'x', 'l'},\n        {'c', 'd'},\n        {'m'},\n\
    \    }\n    local result = ''\n    local digit = 1\n    while number > 0 do\n\
    \        local d = number % 10\n        if d == 9 then\n            result = roman[digit][1]\
    \ .. roman[digit + 1][1] .. result\n        elseif d == 4 then\n            result\
    \ = roman[digit][1] .. roman[digit][2] .. result\n        else\n            local\
    \ f = math.floor(d / 5)\n            local r = d % 5\n            if f == 1 then\n\
    \                result = roman[digit][2] .. result\n            end\n       \
    \     for i = 1, r do\n                result = roman[digit][1] .. result\n  \
    \          end\n        end\n        number = math.floor(number / 10)\n      \
    \  digit = digit + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa1qlhgpp.lua:42:\
    \ expected: \"cdxxvi\"\nactual: \"cdxxiv\"\nstack traceback:\n\t/tmp/tmpa1qlhgpp.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral_map = {\n        {1000, \"m\"}, {900,\
    \ \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50,\
    \ \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"\
    iv\"}, {1, \"i\"}\n    }\n    for _, n in ipairs(numeral_map) do\n        while\
    \ num >= n[1] do\n            roman = roman .. n[2]\n            num = num - n[1]\n\
    \        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local m = math.floor(number / 1000)\n    local d = math.floor((number %\
    \ 1000) / 500)\n    local c = math.floor((number % 500) / 100)\n    local l =\
    \ math.floor((number % 100) / 50)\n    local x = math.floor((number % 50) / 10)\n\
    \    local v = math.floor((number % 10) / 5)\n    local i = math.floor(number\
    \ % 5)\n    roman = string.rep(\"m\", m) .. string.rep(\"d\", d) .. string.rep(\"\
    c\", c) .. string.rep(\"l\", l) .. string.rep(\"x\", x) .. string.rep(\"v\", v)\
    \ .. string.rep(\"i\", i)\n    return roman\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyz27td1t.lua:21:\
    \ expected: \"xix\"\nactual: \"xviiii\"\nstack traceback:\n\t/tmp/tmpyz27td1t.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local symbols = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n    \
    \    {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n        {90,\
    \ \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n\
    \        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1,\
    \ \"i\"}\n    }\n    for _, symbol in ipairs(symbols) do\n        local value,\
    \ letters = symbol[1], symbol[2]\n        while number >= value do\n         \
    \   roman = roman .. letters\n            number = number - value\n        end\n\
    \    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = {\n\
    \        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n     \
    \   {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50,\
    \ \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n\
    \        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"},\n    }\n    local\
    \ result = \"\"\n    for _, pair in ipairs(roman) do\n        local arabic, roman_numeral\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman_numeral\n            number = number - arabic\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4micdxsx.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmp4micdxsx.lua:23:\
    \ in function 'candidate'\n\t/tmp/tmp4micdxsx.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i = 1, #roman_numerals do\n        local arabic,\
    \ roman = table.unpack(roman_numerals[i])\n        while number >= arabic do\n\
    \            number = number - arabic\n            result = result .. roman\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_39ffjyt.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmp_39ffjyt.lua:23:\
    \ in function 'candidate'\n\t/tmp/tmp_39ffjyt.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local roman_numeral = \"\"\n    local remainder = number\n\
    \    local factor = 1\n    while remainder > 0 do\n        local digit = remainder\
    \ % 10\n        remainder = math.floor(remainder / 10)\n        if digit == 4\
    \ then\n            roman_numeral = roman_numerals[factor] .. roman_numerals[5\
    \ * factor] .. roman_numeral\n        elseif digit == 9 then\n            roman_numeral\
    \ = roman_numerals[factor] .. roman_numerals[10 * factor] .. roman_numeral\n \
    \       else\n            local roman_digit = \"\"\n            if digit >= 5\
    \ then\n                roman_digit = roman_numerals[5 * factor]\n           \
    \     digit = digit - 5\n            end\n            for i = 1, digit do\n  \
    \              roman_digit = roman_digit .. roman_numerals[factor]\n         \
    \   end\n            roman_numeral = roman_digit .. roman_numeral\n        end\n\
    \        factor = factor * 10\n    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = {\n  \
    \  {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"cd\"},\n\
    \    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"},\n \
    \   {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n    {1,\
    \ \"i\"}\n  }\n  local result = \"\"\n  for i, pair in ipairs(roman) do\n    local\
    \ arabic, roman_numeral = pair[1], pair[2]\n    while number >= arabic do\n  \
    \    result = result .. roman_numeral\n      number = number - arabic\n    end\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    [1] = \"i\",\n    [5] = \"v\",\n    [10] = \"x\",\n    [50] = \"l\"\
    ,\n    [100] = \"c\",\n    [500] = \"d\",\n    [1000] = \"m\",\n  }\n  local roman_numeral\
    \ = \"\"\n  local num = number\n  local digit = 1\n  while num > 0 do\n    local\
    \ digit_value = digit * 10^(math.floor(math.log10(num)))\n    local digit_num\
    \ = math.floor(num / digit_value)\n    num = num % digit_value\n    if digit_num\
    \ == 9 then\n      roman_numeral = roman_numeral .. roman_numerals[digit] .. roman_numerals[digit_value\
    \ * 10]\n    elseif digit_num >= 5 then\n      roman_numeral = roman_numeral ..\
    \ roman_numerals[digit_value * 5]\n      for i = 1, digit_num - 5 do\n       \
    \ roman_numeral = roman_numeral .. roman_numerals[digit]\n      end\n    elseif\
    \ digit_num == 4 then\n      roman_numeral = roman_numeral .. roman_numerals[digit]\
    \ .. roman_numerals[digit_value * 5]\n    else\n      for i = 1, digit_num do\n\
    \        roman_numeral = roman_numeral .. roman_numerals[digit]\n      end\n \
    \   end\n    digit = digit * 10\n  end\n  return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgkevikzd.lua:44:\
    \ expected: \"xix\"\nactual: \"i\"\nstack traceback:\n\t/tmp/tmpgkevikzd.lua:44:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"\
    cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"\
    },\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n  \
    \  {1, \"i\"}\n  }\n  local result = \"\"\n  for _, pair in ipairs(roman_numerals)\
    \ do\n    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n\
    \      number = number - arabic\n      result = result .. roman\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local result = ''\n\
    \    local numeral_map = {\n        {1000, 'm'}, {900, 'cm'}, {500, 'd'}, {400,\
    \ 'cd'},\n        {100, 'c'}, {90, 'xc'}, {50, 'l'}, {40, 'xl'},\n        {10,\
    \ 'x'}, {9, 'ix'}, {5, 'v'}, {4, 'iv'}, {1, 'i'}\n    }\n    for _, pair in ipairs(numeral_map)\
    \ do\n        local arabic, roman = pair[1], pair[2]\n        while number >=\
    \ arabic do\n            result = result .. roman\n            number = number\
    \ - arabic\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = \"\"\n\
    \  local num = number\n  while num > 0 do\n    if num >= 1000 then\n      roman\
    \ = roman .. \"m\"\n      num = num - 1000\n    elseif num >= 900 then\n     \
    \ roman = roman .. \"cm\"\n      num = num - 900\n    elseif num >= 500 then\n\
    \      roman = roman .. \"d\"\n      num = num - 500\n    elseif num >= 400 then\n\
    \      roman = roman .. \"cd\"\n      num = num - 400\n    elseif num >= 100 then\n\
    \      roman = roman .. \"c\"\n      num = num - 100\n    elseif num >= 90 then\n\
    \      roman = roman .. \"xc\"\n      num = num - 90\n    elseif num >= 50 then\n\
    \      roman = roman .. \"l\"\n      num = num - 50\n    elseif num >= 40 then\n\
    \      roman = roman .. \"xl\"\n      num = num - 40\n    elseif num >= 10 then\n\
    \      roman = roman .. \"x\"\n      num = num - 10\n    elseif num >= 9 then\n\
    \      roman = roman .. \"ix\"\n      num = num - 9\n    elseif num >= 5 then\n\
    \      roman = roman .. \"v\"\n      num = num - 5\n    elseif num >= 4 then\n\
    \      roman = roman .. \"iv\"\n      num = num - 4\n    elseif num >= 1 then\n\
    \      roman = roman .. \"i\"\n      num = num - 1\n    end\n  end\n  return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = {\n\
    \        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n     \
    \   {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50,\
    \ \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n\
    \        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"},\n    }\n    local\
    \ result = \"\"\n    for _, pair in ipairs(roman) do\n        local arabic, roman_numeral\
    \ = unpack(pair)\n        while number >= arabic do\n            result = result\
    \ .. roman_numeral\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman_numerals\
    \ = {\n    {1000, \"m\"},\n    {900, \"cm\"},\n    {500, \"d\"},\n    {400, \"\
    cd\"},\n    {100, \"c\"},\n    {90, \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"\
    },\n    {10, \"x\"},\n    {9, \"ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n  \
    \  {1, \"i\"}\n  }\n  local result = \"\"\n  for _, pair in ipairs(roman_numerals)\
    \ do\n    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n\
    \      number = number - arabic\n      result = result .. roman\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local result = \"\"\n    local num = number\n    local\
    \ digit = 1\n    while num > 0 do\n        local digit_value = num % 10\n    \
    \    if digit_value == 4 then\n            result = roman_numerals[digit] .. roman_numerals[digit\
    \ * 5] .. result\n        elseif digit_value == 9 then\n            result = roman_numerals[digit]\
    \ .. roman_numerals[digit * 10] .. result\n        else\n            local digit_string\
    \ = \"\"\n            if digit_value >= 5 then\n                digit_string =\
    \ roman_numerals[digit * 5]\n                digit_value = digit_value - 5\n \
    \           end\n            for i = 1, digit_value do\n                digit_string\
    \ = digit_string .. roman_numerals[digit]\n            end\n            result\
    \ = digit_string .. result\n        end\n        num = math.floor(num / 10)\n\
    \        digit = digit * 10\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i, v in ipairs(roman_numerals) do\n        while\
    \ number >= v[1] do\n            result = result .. v[2]\n            number =\
    \ number - v[1]\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    if number == 0 then\n\
    \        return \"\"\n    elseif number < 4 then\n        return \"i\" .. int_to_mini_roman(number\
    \ - 1)\n    elseif number == 4 then\n        return \"iv\"\n    elseif number\
    \ < 9 then\n        return \"v\" .. int_to_mini_roman(number - 5)\n    elseif\
    \ number == 9 then\n        return \"ix\"\n    elseif number < 40 then\n     \
    \   return \"x\" .. int_to_mini_roman(number - 10)\n    elseif number < 50 then\n\
    \        return \"xl\" .. int_to_mini_roman(number - 40)\n    elseif number <\
    \ 90 then\n        return \"l\" .. int_to_mini_roman(number - 50)\n    elseif\
    \ number < 100 then\n        return \"xc\" .. int_to_mini_roman(number - 90)\n\
    \    elseif number < 400 then\n        return \"c\" .. int_to_mini_roman(number\
    \ - 100)\n    elseif number < 500 then\n        return \"cd\" .. int_to_mini_roman(number\
    \ - 400)\n    elseif number < 900 then\n        return \"d\" .. int_to_mini_roman(number\
    \ - 500)\n    elseif number < 1000 then\n        return \"cm\" .. int_to_mini_roman(number\
    \ - 900)\n    elseif number == 1000 then\n        return \"m\"\n    else\n   \
    \     return \"?\"\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local result = \"\"\n\
    \  local num = number\n  local numeral = {\n    {1000, \"m\"},\n    {900, \"cm\"\
    },\n    {500, \"d\"},\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90, \"xc\"\
    },\n    {50, \"l\"},\n    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"ix\"},\n\
    \    {5, \"v\"},\n    {4, \"iv\"},\n    {1, \"i\"}\n  }\n  for i = 1, #numeral\
    \ do\n    local arabic, roman = numeral[i][1], numeral[i][2]\n    if num >= arabic\
    \ then\n      local count = math.floor(num / arabic)\n      result = result ..\
    \ roman:rep(count)\n      num = num - count * arabic\n    end\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral_map = {\n        {1000, \"m\"}, {900,\
    \ \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50,\
    \ \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"\
    iv\"}, {1, \"i\"}\n    }\n    for _, n in ipairs(numeral_map) do\n        while\
    \ num >= n[1] do\n            roman = roman .. n[2]\n            num = num - n[1]\n\
    \        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, letters = numeral[1], numeral[2]\n        while number >= value\
    \ do\n            result = result .. letters\n            number = number - value\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local result = \"\"\n    local num = number\n    local\
    \ digit = 0\n    while num > 0 do\n        digit = num % 10\n        if digit\
    \ == 9 then\n            result = roman_numerals[1] .. roman_numerals[10] .. result\n\
    \        elseif digit >= 5 then\n            result = roman_numerals[5] .. string.rep(roman_numerals[1],\
    \ digit - 5) .. result\n        elseif digit == 4 then\n            result = roman_numerals[1]\
    \ .. roman_numerals[5] .. result\n        else\n            result = string.rep(roman_numerals[1],\
    \ digit) .. result\n        end\n        num = math.floor(num / 10)\n        for\
    \ i = 1, #roman_numerals do\n            roman_numerals[i] = roman_numerals[i]\
    \ .. roman_numerals[i]\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphrraautj.lua:40:\
    \ expected: \"xix\"\nactual: \"iiix\"\nstack traceback:\n\t/tmp/tmphrraautj.lua:40:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = ''\n\
    \    local num = number\n    local numeral_map = {\n        {1000, 'm'},\n   \
    \     {900, 'cm'},\n        {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n\
    \        {90, 'xc'},\n        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n\
    \        {9, 'ix'},\n        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'},\n\
    \    }\n    for _, pair in ipairs(numeral_map) do\n        local arabic, roman_string\
    \ = pair[1], pair[2]\n        while num >= arabic do\n            roman = roman\
    \ .. roman_string\n            num = num - arabic\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i, v in ipairs(roman_numerals) do\n        while\
    \ number >= v[1] do\n            result = result .. v[2]\n            number =\
    \ number - v[1]\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, symbol = numeral[1], numeral[2]\n        while number >= value\
    \ do\n            result = result .. symbol\n            number = number - value\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        { \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\" },\n        { \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\",\
    \ \"lx\", \"lxx\", \"lxxx\", \"xc\" },\n        { \"\", \"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\" },\n        { \"\", \"m\",\
    \ \"mm\", \"mmm\" }\n    }\n    local result = \"\"\n    local num = number\n\
    \    for i = 4, 1, -1 do\n        local digit = num % 10\n        result = result\
    \ .. roman_numerals[i][digit + 1]\n        num = (num - digit) / 10\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpr338xpaa.lua:16:\
    \ attempt to concatenate field '?' (a nil value)\nstack traceback:\n\t/tmp/tmpr338xpaa.lua:16:\
    \ in function 'candidate'\n\t/tmp/tmpr338xpaa.lua:25: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral_map = {\n        {1000, \"m\"}, {900,\
    \ \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50,\
    \ \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"\
    iv\"}, {1, \"i\"}\n    }\n    for _, n in ipairs(numeral_map) do\n        local\
    \ count = math.floor(num / n[1])\n        roman = roman .. n[2]:rep(count)\n \
    \       num = num - n[1] * count\n    end\n    return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    while num > 0 do\n        if num >= 1000 then\n\
    \            roman = roman .. \"m\"\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. \"cm\"\n            num = num\
    \ - 900\n        elseif num >= 500 then\n            roman = roman .. \"d\"\n\
    \            num = num - 500\n        elseif num >= 400 then\n            roman\
    \ = roman .. \"cd\"\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. \"c\"\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. \"xc\"\n            num = num -\
    \ 90\n        elseif num >= 50 then\n            roman = roman .. \"l\"\n    \
    \        num = num - 50\n        elseif num >= 40 then\n            roman = roman\
    \ .. \"xl\"\n            num = num - 40\n        elseif num >= 10 then\n     \
    \       roman = roman .. \"x\"\n            num = num - 10\n        elseif num\
    \ >= 9 then\n            roman = roman .. \"ix\"\n            num = num - 9\n\
    \        elseif num >= 5 then\n            roman = roman .. \"v\"\n          \
    \  num = num - 5\n        elseif num >= 4 then\n            roman = roman .. \"\
    iv\"\n            num = num - 4\n        elseif num >= 1 then\n            roman\
    \ = roman .. \"i\"\n            num = num - 1\n        end\n    end\n    return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for i = 1, #roman_numerals do\n        local arabic,\
    \ roman = table.unpack(roman_numerals[i])\n        while number >= arabic do\n\
    \            number = number - arabic\n            result = result .. roman\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_39ffjyt.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmp_39ffjyt.lua:23:\
    \ in function 'candidate'\n\t/tmp/tmp_39ffjyt.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local result = \"\"\
    \n    local roman_numerals = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n\
    \        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n      \
    \  {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"\
    x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n     \
    \   {1, \"i\"}\n    }\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, letters = numeral[1], numeral[2]\n        while number >= value\
    \ do\n            result = result .. letters\n            number = number - value\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local num = number\n    local numeral_map = {\n        {1000, \"m\"}, {900,\
    \ \"cm\"}, {500, \"d\"}, {400, \"cd\"},\n        {100, \"c\"}, {90, \"xc\"}, {50,\
    \ \"l\"}, {40, \"xl\"},\n        {10, \"x\"}, {9, \"ix\"}, {5, \"v\"}, {4, \"\
    iv\"}, {1, \"i\"}\n    }\n    for k, v in ipairs(numeral_map) do\n        while\
    \ num >= v[1] do\n            roman = roman .. v[2]\n            num = num - v[1]\n\
    \        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = ''\n\
    \    local num = number\n    while num > 0 do\n        if num >= 1000 then\n \
    \           roman = roman .. 'm'\n            num = num - 1000\n        elseif\
    \ num >= 900 then\n            roman = roman .. 'cm'\n            num = num -\
    \ 900\n        elseif num >= 500 then\n            roman = roman .. 'd'\n    \
    \        num = num - 500\n        elseif num >= 400 then\n            roman =\
    \ roman .. 'cd'\n            num = num - 400\n        elseif num >= 100 then\n\
    \            roman = roman .. 'c'\n            num = num - 100\n        elseif\
    \ num >= 90 then\n            roman = roman .. 'xc'\n            num = num - 90\n\
    \        elseif num >= 50 then\n            roman = roman .. 'l'\n           \
    \ num = num - 50\n        elseif num >= 40 then\n            roman = roman ..\
    \ 'xl'\n            num = num - 40\n        elseif num >= 10 then\n          \
    \  roman = roman .. 'x'\n            num = num - 10\n        elseif num >= 9 then\n\
    \            roman = roman .. 'ix'\n            num = num - 9\n        elseif\
    \ num >= 5 then\n            roman = roman .. 'v'\n            num = num - 5\n\
    \        elseif num >= 4 then\n            roman = roman .. 'iv'\n           \
    \ num = num - 4\n        elseif num >= 1 then\n            roman = roman .. 'i'\n\
    \            num = num - 1\n        end\n    end\n    return roman\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local m = number / 1000\n    if m >= 1 then\n        roman = roman .. string.rep(\"\
    m\", m)\n        number = number - m * 1000\n    end\n    local d = number / 500\n\
    \    if d >= 1 then\n        roman = roman .. string.rep(\"d\", d)\n        number\
    \ = number - d * 500\n    end\n    local c = number / 100\n    if c >= 1 then\n\
    \        roman = roman .. string.rep(\"c\", c)\n        number = number - c *\
    \ 100\n    end\n    local l = number / 50\n    if l >= 1 then\n        roman =\
    \ roman .. string.rep(\"l\", l)\n        number = number - l * 50\n    end\n \
    \   local x = number / 10\n    if x >= 1 then\n        roman = roman .. string.rep(\"\
    x\", x)\n        number = number - x * 10\n    end\n    local v = number / 5\n\
    \    if v >= 1 then\n        roman = roman .. string.rep(\"v\", v)\n        number\
    \ = number - v * 5\n    end\n    local i = number\n    if i >= 1 then\n      \
    \  roman = roman .. string.rep(\"i\", i)\n    end\n    return roman\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyquhm94f.lua:47:\
    \ expected: \"xix\"\nactual: \"x\"\nstack traceback:\n\t/tmp/tmpyquhm94f.lua:47:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = \"\"\n\
    \  local num = number\n  local num_to_roman = {\n    {1000, \"m\"},\n    {900,\
    \ \"cm\"},\n    {500, \"d\"},\n    {400, \"cd\"},\n    {100, \"c\"},\n    {90,\
    \ \"xc\"},\n    {50, \"l\"},\n    {40, \"xl\"},\n    {10, \"x\"},\n    {9, \"\
    ix\"},\n    {5, \"v\"},\n    {4, \"iv\"},\n    {1, \"i\"}\n  }\n  for i = 1, #num_to_roman\
    \ do\n    local arabic, roman_string = unpack(num_to_roman[i])\n    if num >=\
    \ arabic then\n      local factor = math.floor(num / arabic)\n      num = num\
    \ - factor * arabic\n      roman = roman .. roman_string:rep(factor)\n    end\n\
    \  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        [1] = \"i\",\n        [5] = \"v\",\n        [10] = \"x\",\n   \
    \     [50] = \"l\",\n        [100] = \"c\",\n        [500] = \"d\",\n        [1000]\
    \ = \"m\",\n    }\n    local result = \"\"\n    local num = number\n    local\
    \ digits = {}\n    local digit_count = 0\n    while num > 0 do\n        digit_count\
    \ = digit_count + 1\n        digits[digit_count] = num % 10\n        num = math.floor(num\
    \ / 10)\n    end\n    for i = digit_count, 1, -1 do\n        local digit = digits[i]\n\
    \        local digit_roman = \"\"\n        if digit == 9 then\n            digit_roman\
    \ = roman_numerals[10^(i-1)] .. roman_numerals[10^i]\n        elseif digit >=\
    \ 5 then\n            digit_roman = roman_numerals[5*10^(i-1)]\n            for\
    \ j = 1, digit - 5 do\n                digit_roman = digit_roman .. roman_numerals[10^(i-1)]\n\
    \            end\n        elseif digit == 4 then\n            digit_roman = roman_numerals[10^(i-1)]\
    \ .. roman_numerals[5*10^(i-1)]\n        else\n            for j = 1, digit do\n\
    \                digit_roman = digit_roman .. roman_numerals[10^(i-1)]\n     \
    \       end\n        end\n        result = result .. digit_roman\n    end\n  \
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = \"\"\
    \n    local roman_numerals = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n\
    \        {500, \"d\"},\n        {400, \"cd\"},\n        {100, \"c\"},\n      \
    \  {90, \"xc\"},\n        {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"\
    x\"},\n        {9, \"ix\"},\n        {5, \"v\"},\n        {4, \"iv\"},\n     \
    \   {1, \"i\"}\n    }\n    for _, numeral in ipairs(roman_numerals) do\n     \
    \   local value, symbol = unpack(numeral)\n        while number >= value do\n\
    \            roman = roman .. symbol\n            number = number - value\n  \
    \      end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750528
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n  local roman = \"\"\n\
    \  local arabic = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}\n  local\
    \ roman_numerals = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n  for i = 1, #arabic do\n    while number\
    \ >= arabic[i] do\n      roman = roman .. roman_numerals[i]\n      number = number\
    \ - arabic[i]\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local result = \"\"\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ arabic, roman = pair[1], pair[2]\n        while number >= arabic do\n      \
    \      number = number - arabic\n            result = result .. roman\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 1
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman_numerals\
    \ = {\n        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n\
    \        {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n      \
    \  {50, \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"\
    },\n        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n   \
    \ local roman_numeral = \"\"\n    for _, pair in ipairs(roman_numerals) do\n \
    \       local arabic, numeral = table.unpack(pair)\n        while number >= arabic\
    \ do\n            roman_numeral = roman_numeral .. numeral\n            number\
    \ = number - arabic\n        end\n    end\n    return roman_numeral\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpkw27cto3.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\nstack traceback:\n\t/tmp/tmpkw27cto3.lua:23:\
    \ in function 'candidate'\n\t/tmp/tmpkw27cto3.lua:35: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = ''\n\
    \    local num = number\n    local numeral_value = {\n        {'m', 1000},\n \
    \       {'cm', 900},\n        {'d', 500},\n        {'cd', 400},\n        {'c',\
    \ 100},\n        {'xc', 90},\n        {'l', 50},\n        {'xl', 40},\n      \
    \  {'x', 10},\n        {'ix', 9},\n        {'v', 5},\n        {'iv', 4},\n   \
    \     {'i', 1}\n    }\n    for i = 1, #numeral_value do\n        local numeral\
    \ = numeral_value[i][1]\n        local value = numeral_value[i][2]\n        while\
    \ num >= value do\n            roman = roman .. numeral\n            num = num\
    \ - value\n        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
- exit_code: 0
  program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\nlocal function int_to_mini_roman(number)\n    local roman = {\n\
    \        {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n     \
    \   {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50,\
    \ \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n\
    \        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"},\n    }\n    local\
    \ result = \"\"\n    for i = 1, #roman do\n        local arabic, roman_string\
    \ = unpack(roman[i])\n        while number >= arabic do\n            number =\
    \ number - arabic\n            result = result .. roman_string\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: OK
  stderr: ''
  stdout: '.

    Ran 1 tests in 0.000 seconds, 1 success, 0 failures

    OK

    '
  timestamp: 1659750527
