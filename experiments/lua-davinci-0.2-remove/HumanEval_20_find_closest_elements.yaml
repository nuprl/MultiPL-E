name: HumanEval_20_find_closest_elements
language: lua
prompt: "-- From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n-- other and return them in order (smaller number,\
  \ larger number).\nlocal function find_closest_elements(numbers)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = find_closest_elements\n\
  \    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}), {3.9, 4.0})\n  \
  \  lu.assertEquals(candidate({1.0, 2.0, 5.9, 4.0, 5.0}), {5.0, 5.9})\n    lu.assertEquals(candidate({1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2}), {2.0, 2.2})\n    lu.assertEquals(candidate({1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.0}), {2.0, 2.0})\n    lu.assertEquals(candidate({1.1, 2.2, 3.1,\
  \ 4.1, 5.1}), {2.2, 3.1})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["\tlocal closest_distance = math.huge\n\tlocal closest_elements = {0,\
    \ 0}\n\tfor i = 1, #numbers do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal distance\
    \ = math.abs(numbers[i] - numbers[j])\n\t\t\tif distance < closest_distance then\n\
    \t\t\t\tclosest_distance = distance\n\t\t\t\tclosest_elements = {numbers[i], numbers[j]}\n\
    \t\t\tend\n\t\tend\n\tend\n\treturn closest_elements[1], closest_elements[2]\n\
    end", "    local closest_distance = math.huge\n    local closest_pair = {numbers[1],\
    \ numbers[2]}\n    for i = 1, #numbers - 1 do\n        for j = i + 1, #numbers\
    \ do\n            local distance = math.abs(numbers[i] - numbers[j])\n       \
    \     if distance < closest_distance then\n                closest_distance =\
    \ distance\n                closest_pair = {numbers[i], numbers[j]}\n        \
    \    end\n        end\n    end\n    return closest_pair[1], closest_pair[2]\n\
    end", "    local min_diff = math.huge\n    local min_diff_elements = {numbers[1],\
    \ numbers[2]}\n    for i = 1, #numbers - 1 do\n        for j = i + 1, #numbers\
    \ do\n            local diff = math.abs(numbers[i] - numbers[j])\n           \
    \ if diff < min_diff then\n                min_diff = diff\n                min_diff_elements\
    \ = {numbers[i], numbers[j]}\n            end\n        end\n    end\n    return\
    \ min_diff_elements\nend", "\tlocal smallest_difference = math.huge\n\tlocal smallest_difference_index\
    \ = nil\n\tfor i = 1, #numbers - 1 do\n\t\tlocal difference = numbers[i + 1] -\
    \ numbers[i]\n\t\tif difference < smallest_difference then\n\t\t\tsmallest_difference\
    \ = difference\n\t\t\tsmallest_difference_index = i\n\t\tend\n\tend\n\treturn\
    \ numbers[smallest_difference_index], numbers[smallest_difference_index + 1]\n\
    end", "\tlocal smallest_difference = math.huge\n\tlocal smallest_difference_elements\
    \ = {numbers[1], numbers[2]}\n\tfor i = 1, #numbers - 1 do\n\t\tfor j = i + 1,\
    \ #numbers do\n\t\t\tlocal difference = math.abs(numbers[i] - numbers[j])\n\t\t\
    \tif difference < smallest_difference then\n\t\t\t\tsmallest_difference = difference\n\
    \t\t\t\tsmallest_difference_elements = {numbers[i], numbers[j]}\n\t\t\tend\n\t\
    \tend\n\tend\n\treturn smallest_difference_elements\nend", "  local smallest_difference\
    \ = math.huge\n  local smallest_difference_elements = {numbers[1], numbers[2]}\n\
    \  for i = 1, #numbers do\n    for j = i + 1, #numbers do\n      local difference\
    \ = math.abs(numbers[i] - numbers[j])\n      if difference < smallest_difference\
    \ then\n        smallest_difference = difference\n        smallest_difference_elements\
    \ = {numbers[i], numbers[j]}\n      end\n    end\n  end\n  return smallest_difference_elements\n\
    end", "    local smallest_difference = math.huge\n    local closest_elements =\
    \ {0, 0}\n    for i = 1, #numbers do\n        for j = i + 1, #numbers do\n   \
    \         local difference = math.abs(numbers[i] - numbers[j])\n            if\
    \ difference < smallest_difference then\n                smallest_difference =\
    \ difference\n                closest_elements = {numbers[i], numbers[j]}\n  \
    \          end\n        end\n    end\n    return closest_elements\nend", "\tlocal\
    \ min_diff = math.huge\n\tlocal min_diff_pair = nil\n\tfor i = 1, #numbers - 1\
    \ do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal diff = math.abs(numbers[i] -\
    \ numbers[j])\n\t\t\tif diff < min_diff then\n\t\t\t\tmin_diff = diff\n\t\t\t\t\
    min_diff_pair = {numbers[i], numbers[j]}\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ min_diff_pair\nend", "\tlocal closest_diff = math.huge\n\tlocal closest_elements\
    \ = {numbers[1], numbers[2]}\n\tfor i = 1, #numbers - 1 do\n\t\tfor j = i + 1,\
    \ #numbers do\n\t\t\tlocal diff = math.abs(numbers[i] - numbers[j])\n\t\t\tif\
    \ diff < closest_diff then\n\t\t\t\tclosest_diff = diff\n\t\t\t\tclosest_elements\
    \ = {numbers[i], numbers[j]}\n\t\t\tend\n\t\tend\n\tend\n\treturn closest_elements[1],\
    \ closest_elements[2]\nend", "    local min_diff = math.huge\n    local min_diff_elements\
    \ = {0, 0}\n    for i = 1, #numbers do\n        for j = i + 1, #numbers do\n \
    \           local diff = math.abs(numbers[i] - numbers[j])\n            if diff\
    \ < min_diff then\n                min_diff = diff\n                min_diff_elements\
    \ = {numbers[i], numbers[j]}\n            end\n        end\n    end\n    return\
    \ min_diff_elements\nend", "    local closest_distance = math.huge\n    local\
    \ closest_pair = nil\n    for i = 1, #numbers do\n        for j = i + 1, #numbers\
    \ do\n            local distance = math.abs(numbers[i] - numbers[j])\n       \
    \     if distance < closest_distance then\n                closest_distance =\
    \ distance\n                closest_pair = { numbers[i], numbers[j] }\n      \
    \      end\n        end\n    end\n    return closest_pair\nend", "    local closest_distance\
    \ = math.huge\n    local closest_numbers = {numbers[1], numbers[2]}\n    for i\
    \ = 1, #numbers - 1 do\n        for j = i + 1, #numbers do\n            local\
    \ distance = math.abs(numbers[i] - numbers[j])\n            if distance < closest_distance\
    \ then\n                closest_distance = distance\n                closest_numbers\
    \ = {numbers[i], numbers[j]}\n            end\n        end\n    end\n    return\
    \ closest_numbers[1], closest_numbers[2]\nend", "\tlocal min_diff = math.huge\n\
    \tlocal min_diff_elements = {numbers[1], numbers[2]}\n\tfor i = 1, #numbers do\n\
    \t\tfor j = i + 1, #numbers do\n\t\t\tlocal diff = math.abs(numbers[i] - numbers[j])\n\
    \t\t\tif diff < min_diff then\n\t\t\t\tmin_diff = diff\n\t\t\t\tmin_diff_elements\
    \ = {numbers[i], numbers[j]}\n\t\t\tend\n\t\tend\n\tend\n\treturn min_diff_elements[1],\
    \ min_diff_elements[2]\nend", "    local closest_difference = math.huge\n    local\
    \ closest_elements = {numbers[1], numbers[2]}\n    for i = 1, #numbers do\n  \
    \      for j = i + 1, #numbers do\n            local difference = math.abs(numbers[i]\
    \ - numbers[j])\n            if difference < closest_difference then\n       \
    \         closest_difference = difference\n                closest_elements =\
    \ {numbers[i], numbers[j]}\n            end\n        end\n    end\n    return\
    \ closest_elements[1], closest_elements[2]\nend", "  local min_diff = math.huge\n\
    \  local min_diff_elements = {numbers[1], numbers[2]}\n  for i = 1, #numbers do\n\
    \    for j = i + 1, #numbers do\n      local diff = math.abs(numbers[i] - numbers[j])\n\
    \      if diff < min_diff then\n        min_diff = diff\n        min_diff_elements\
    \ = {numbers[i], numbers[j]}\n      end\n    end\n  end\n  return min_diff_elements\n\
    end", "\tlocal closest_diff = math.huge\n\tlocal closest_pair = {numbers[1], numbers[2]}\n\
    \tfor i = 1, #numbers do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal diff = math.abs(numbers[i]\
    \ - numbers[j])\n\t\t\tif diff < closest_diff then\n\t\t\t\tclosest_diff = diff\n\
    \t\t\t\tclosest_pair = {numbers[i], numbers[j]}\n\t\t\tend\n\t\tend\n\tend\n\t\
    return closest_pair[1], closest_pair[2]\nend", "    local min_diff = math.huge\n\
    \    local min_diff_pair = nil\n    for i = 1, #numbers do\n        for j = i\
    \ + 1, #numbers do\n            local diff = math.abs(numbers[i] - numbers[j])\n\
    \            if diff < min_diff then\n                min_diff = diff\n      \
    \          min_diff_pair = {numbers[i], numbers[j]}\n            end\n       \
    \ end\n    end\n    return min_diff_pair\nend", "    local smallest_difference\
    \ = math.huge\n    local closest_elements = {numbers[1], numbers[2]}\n    for\
    \ i = 1, #numbers do\n        for j = i + 1, #numbers do\n            local difference\
    \ = math.abs(numbers[i] - numbers[j])\n            if difference < smallest_difference\
    \ then\n                smallest_difference = difference\n                closest_elements\
    \ = {numbers[i], numbers[j]}\n            end\n        end\n    end\n    return\
    \ closest_elements[1], closest_elements[2]\nend", "\tlocal min_diff = math.huge\n\
    \tlocal min_pair = {numbers[1], numbers[2]}\n\tfor i = 1, #numbers do\n\t\tfor\
    \ j = i + 1, #numbers do\n\t\t\tlocal diff = math.abs(numbers[i] - numbers[j])\n\
    \t\t\tif diff < min_diff then\n\t\t\t\tmin_diff = diff\n\t\t\t\tmin_pair = {numbers[i],\
    \ numbers[j]}\n\t\t\tend\n\t\tend\n\tend\n\treturn min_pair[1], min_pair[2]\n\
    end", "\tlocal closest_distance = math.huge\n\tlocal closest_numbers = { 0, 0\
    \ }\n\tfor i = 1, #numbers do\n\t\tfor j = i + 1, #numbers do\n\t\t\tlocal distance\
    \ = math.abs(numbers[i] - numbers[j])\n\t\t\tif distance < closest_distance then\n\
    \t\t\t\tclosest_distance = distance\n\t\t\t\tclosest_numbers = { numbers[i], numbers[j]\
    \ }\n\t\t\tend\n\t\tend\n\tend\n\treturn closest_numbers[1], closest_numbers[2]\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
