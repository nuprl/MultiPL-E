name: HumanEval_115_max_fill
language: lua
prompt: "-- You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n-- and\
  \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
  \ the wells.\n-- Output the number of times you need to lower the buckets.\n-- Example\
  \ 1:\n-- Example 2:\n-- Example 3:\n-- Constraints:\n-- * all wells have the same\
  \ length\n-- * 1 <= grid.length <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n--\
  \ * grid[i][j] -> 0 | 1\n-- * 1 <= capacity <= 10\nlocal function max_fill(grid,\
  \ capacity)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
  \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n\
  \    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1,\
  \ 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}}, 5), 0)\n\
  \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1,\
  \ 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n\
    \    for i = 1, n do\n        local fill = 0\n        for j = 1, m do\n      \
    \      fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n\
    \ do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n         \
    \       max_fill = max_fill + 1\n            end\n        end\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n    local cols\
    \ = #grid[1]\n    local fill = 0\n    for i = 1, rows do\n        local row_fill\
    \ = 0\n        for j = 1, cols do\n            if grid[i][j] == 1 then\n     \
    \           row_fill = row_fill + 1\n            end\n        end\n        fill\
    \ = math.max(fill, row_fill)\n    end\n    return math.ceil(fill / capacity)\n\
    end", "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n \
    \   for i = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n\
    \                max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local n = #grid\n    local\
    \ m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n        local fill\
    \ = 0\n        for j = 1, m do\n            fill = fill + grid[i][j]\n       \
    \ end\n        max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local max_fill\
    \ = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j = 1, #grid[i]\
    \ do\n            fill = fill + grid[i][j]\n        end\n        if fill > max_fill\
    \ then\n            max_fill = fill\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local max_fill = 0\n    for i = 1, #grid do\n      \
    \  local row = grid[i]\n        local fill = 0\n        for j = 1, #row do\n \
    \           local cell = row[j]\n            if cell == 1 then\n             \
    \   fill = fill + 1\n            else\n                if fill > 0 then\n    \
    \                max_fill = max_fill + math.ceil(fill / capacity)\n          \
    \          fill = 0\n                end\n            end\n        end\n     \
    \   if fill > 0 then\n            max_fill = max_fill + math.ceil(fill / capacity)\n\
    \        end\n    end\n    return max_fill\nend", "    local n = #grid\n    local\
    \ m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n        for j = 1,\
    \ m do\n            if grid[i][j] == 1 then\n                max_fill = max_fill\
    \ + 1\n            end\n        end\n    end\n    return math.ceil(max_fill /\
    \ capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill_row\
    \ = {}\n    for i = 1, n do\n        local max_fill_col = 0\n        for j = 1,\
    \ m do\n            if grid[i][j] == 1 then\n                max_fill_col = max_fill_col\
    \ + 1\n            else\n                max_fill_col = 0\n            end\n \
    \           max_fill_row[j] = math.max(max_fill_row[j] or 0, max_fill_col)\n \
    \       end\n    end\n    local max_fill_col = {}\n    for j = 1, m do\n     \
    \   local max_fill_row = 0\n        for i = 1, n do\n            if grid[i][j]\
    \ == 1 then\n                max_fill_row = max_fill_row + 1\n            else\n\
    \                max_fill_row = 0\n            end\n            max_fill_col[i]\
    \ = math.max(max_fill_col[i] or 0, max_fill_row)\n        end\n    end\n    local\
    \ max_fill = 0\n    for i = 1, n do\n        for j = 1, m do\n            local\
    \ max_fill_ij = math.min(max_fill_row[j], max_fill_col[i])\n            if grid[i][j]\
    \ == 1 then\n                max_fill_ij = max_fill_ij - 1\n            end\n\
    \            max_fill = math.max(max_fill, max_fill_ij)\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local max_fill = 0\n  \
    \  for _, row in ipairs(grid) do\n        local fill = 0\n        for _, well\
    \ in ipairs(row) do\n            fill = fill + well\n            if fill > capacity\
    \ then\n                max_fill = max_fill + 1\n                fill = 0\n  \
    \          end\n        end\n        if fill > 0 then\n            max_fill =\
    \ max_fill + 1\n        end\n    end\n    return max_fill\nend", "    local n\
    \ = #grid\n    local m = #grid[1]\n    local res = 0\n    for i = 1, n do\n  \
    \      for j = 1, m do\n            if grid[i][j] == 1 then\n                res\
    \ = res + 1\n            end\n        end\n    end\n    return math.ceil(res /\
    \ capacity)\nend", "    local max_fill = 0\n    for i = 1, #grid do\n        local\
    \ fill = 0\n        for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n\
    \        end\n        if fill > max_fill then\n            max_fill = fill\n \
    \       end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n\
    \ do\n        local fill = 0\n        for j = 1, m do\n            fill = fill\
    \ + grid[i][j]\n        end\n        max_fill = math.max(max_fill, fill)\n   \
    \ end\n    return math.ceil(max_fill / capacity)\nend", "    local n = #grid\n\
    \    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n       \
    \ for j = 1, m do\n            if grid[i][j] == 1 then\n                max_fill\
    \ = max_fill + 1\n            end\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    local min_fill = math.floor(max_fill / capacity)\n    if\
    \ max_fill % capacity ~= 0 then\n        min_fill = min_fill + 1\n    end\n  \
    \  return min_fill\nend", "    local n = #grid\n    local m = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    local min_fill = math.floor(max_fill / capacity)\n    if\
    \ max_fill % capacity ~= 0 then\n        min_fill = min_fill + 1\n    end\n  \
    \  return min_fill\nend", "    local n = #grid\n    local m = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, n do\n        local fill = 0\n        for j = 1,\
    \ m do\n            fill = fill + grid[i][j]\n        end\n        max_fill =\
    \ math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n\
    \        for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n      \
    \  end\n        if fill > max_fill then\n            max_fill = fill\n       \
    \ end\n    end\n    return max_fill\nend", "    local max_fill = 0\n    for i=1,#grid\
    \ do\n        local fill = 0\n        for j=1,#grid[i] do\n            fill =\
    \ fill + grid[i][j]\n        end\n        if fill > max_fill then\n          \
    \  max_fill = fill\n        end\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n\
    \        for j = 1, #grid[i] do\n            if grid[i][j] == 1 then\n       \
    \         fill = fill + 1\n            end\n        end\n        if fill > max_fill\
    \ then\n            max_fill = fill\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local rows = #grid\n    local cols = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, rows do\n        local fill = 0\n        for j\
    \ = 1, cols do\n            fill = fill + grid[i][j]\n        end\n        max_fill\
    \ = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local rows = #grid\n    local cols = #grid[1]\n    local max_fill =\
    \ 0\n    for i = 1, rows do\n        local fill = 0\n        for j = 1, cols do\n\
    \            if grid[i][j] == 1 then\n                fill = fill + 1\n      \
    \      end\n        end\n        max_fill = math.max(max_fill, fill)\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local function fill(row)\n\
    \        local filled = 0\n        for i = 1, #row do\n            if row[i] ==\
    \ 1 then\n                filled = filled + 1\n            end\n        end\n\
    \        return filled\n    end\n    local function empty(row)\n        local\
    \ emptied = 0\n        for i = 1, #row do\n            if row[i] == 1 then\n \
    \               emptied = emptied + 1\n                row[i] = 0\n          \
    \  end\n        end\n        return emptied\n    end\n    local function fill_all(grid,\
    \ capacity)\n        local filled = 0\n        for i = 1, #grid do\n         \
    \   filled = filled + fill(grid[i])\n        end\n        return filled\n    end\n\
    \    local function empty_all(grid, capacity)\n        local emptied = 0\n   \
    \     for i = 1, #grid do\n            emptied = emptied + empty(grid[i])\n  \
    \      end\n        return emptied\n    end\n    local function fill_row(row,\
    \ capacity)\n        local filled = 0\n        for i = 1, #row do\n          \
    \  if row[i] == 1 then\n                filled = filled + 1\n                row[i]\
    \ = 0\n            end\n            if filled == capacity then\n             \
    \   break\n            end\n        end\n        return filled\n    end\n    local\
    \ function fill_all_rows(grid, capacity)\n        local filled = 0\n        for\
    \ i = 1, #grid do\n            filled = filled + fill_row(grid[i], capacity)\n\
    \        end\n        return filled\n    end\n    local function empty_row(row,\
    \ capacity)\n        local emptied = 0\n        for i = 1, #row do\n         \
    \   if row[i] == 0 then\n                emptied = emptied + 1\n             \
    \   row[i] = 1\n            end\n            if emptied == capacity then\n   \
    \             break\n            end\n        end\n        return emptied\n  \
    \  end\n    local function empty_all_rows(grid, capacity)\n        local emptied\
    \ = 0\n        for i = 1, #grid do\n            emptied = emptied + empty_row(grid[i],\
    \ capacity)\n        end\n        return emptied\n    end\n    local function\
    \ fill_column(grid, capacity)\n        local filled = 0\n        for i = 1, #",
  "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i\
    \ = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n  \
    \              max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    local min_fill = math.ceil(max_fill / capacity)\n    return min_fill\nend",
  "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i\
    \ = 1, n do\n        local fill = 0\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                fill = fill + 1\n            end\n        end\n \
    \       max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    return math.ceil(max_fill / capacity)\nend", "  local rows\
    \ = #grid\n  local cols = #grid[1]\n  local max_fill = 0\n  for i = 1, rows do\n\
    \    local row_fill = 0\n    for j = 1, cols do\n      row_fill = row_fill + grid[i][j]\n\
    \    end\n    max_fill = math.max(max_fill, row_fill)\n  end\n  return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local n\
    \ = #grid\n    local m = #grid[1]\n    local function fill(i, j)\n        local\
    \ r = 0\n        for k = 1, capacity do\n            if grid[i][j] == 1 then\n\
    \                grid[i][j] = 0\n                r = r + 1\n            end\n\
    \            j = j + 1\n            if j > m then\n                break\n   \
    \         end\n        end\n        return r\n    end\n    local function empty(i,\
    \ j)\n        local r = 0\n        for k = 1, capacity do\n            if grid[i][j]\
    \ == 0 then\n                grid[i][j] = 1\n                r = r + 1\n     \
    \       end\n            j = j - 1\n            if j < 1 then\n              \
    \  break\n            end\n        end\n        return r\n    end\n    local function\
    \ fill_row(i)\n        local r = 0\n        local j = 1\n        while j <= m\
    \ do\n            if grid[i][j] == 1 then\n                r = r + fill(i, j)\n\
    \            end\n            j = j + 1\n        end\n        return r\n    end\n\
    \    local function empty_row(i)\n        local r = 0\n        local j = m\n \
    \       while j >= 1 do\n            if grid[i][j] == 1 then\n               \
    \ r = r + empty(i, j)\n            end\n            j = j - 1\n        end\n \
    \       return r\n    end\n    local function fill_all()\n        local r = 0\n\
    \        for i = 1, n do\n            r = r + fill_row(i)\n        end\n     \
    \   return r\n    end\n    local function empty_all()\n        local r = 0\n \
    \       for i = n, 1, -1 do\n            r = r + empty_row(i)\n        end\n \
    \       return r\n    end\n    local r = 0\n    while fill_all() > 0 do\n    \
    \    r = r + 1\n        empty_all()\n        r = r + 1\n    end\n    return r\n\
    end", "    local rows = #grid\n    local cols = #grid[1]\n    local max_fill =\
    \ 0\n    for i = 1, rows do\n        local fill = 0\n        for j = 1, cols do\n\
    \            fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ rows = #grid\n    local cols = #grid[1]\n    local max_fill = 0\n    for i =\
    \ 1, rows do\n        local fill = 0\n        for j = 1, cols do\n           \
    \ fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j\
    \ = 1, #grid[i] do\n            fill = fill + grid[i][j]\n        end\n      \
    \  if fill > max_fill then\n            max_fill = fill\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local max_fill = 0\n  \
    \  for i = 1, #grid do\n        local fill = 0\n        for j = 1, #grid[i] do\n\
    \            fill = fill + grid[i][j]\n        end\n        if fill > max_fill\
    \ then\n            max_fill = fill\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local rows = #grid\n    local cols = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, rows do\n        local fill = 0\n        for j\
    \ = 1, cols do\n            if grid[i][j] == 1 then\n                fill = fill\
    \ + 1\n            end\n        end\n        max_fill = math.max(max_fill, fill)\n\
    \    end\n    return math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n\
    \    local cols = #grid[1]\n    local max_fill = 0\n    for i = 1, rows do\n \
    \       local fill = 0\n        for j = 1, cols do\n            if grid[i][j]\
    \ == 1 then\n                fill = fill + 1\n            end\n        end\n \
    \       max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local rows = #grid\n    local cols = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, rows do\n        local fill = 0\n        for j\
    \ = 1, cols do\n            fill = fill + grid[i][j]\n        end\n        max_fill\
    \ = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n\
    \        for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n      \
    \  end\n        if fill > max_fill then\n            max_fill = fill\n       \
    \ end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local n\
    \ = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n\
    \        for j = 1, m do\n            if grid[i][j] == 1 then\n              \
    \  max_fill = max_fill + 1\n            end\n        end\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n\
    \    local max_fill = 0\n    for i = 1, n do\n        local fill = 0\n       \
    \ for j = 1, m do\n            fill = fill + grid[i][j]\n        end\n       \
    \ max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    local min_fill = math.ceil(max_fill / capacity)\n    return\
    \ min_fill\nend", "    local n = #grid\n    local m = #grid[1]\n    local fill\
    \ = 0\n    local function fill_row(row)\n        local i = 1\n        while i\
    \ <= m do\n            local j = i\n            while j <= m and grid[row][j]\
    \ == 1 do\n                j = j + 1\n            end\n            local k = j\
    \ - 1\n            local count = k - i + 1\n            if count > capacity then\n\
    \                fill = fill + 1\n                i = i + capacity\n         \
    \   else\n                i = j\n            end\n        end\n    end\n    for\
    \ i = 1, n do\n        fill_row(i)\n    end\n    return fill\nend", "    local\
    \ rows = #grid\n    local cols = #grid[1]\n    local max_fill = 0\n    for i =\
    \ 1, rows do\n        local fill = 0\n        for j = 1, cols do\n           \
    \ if grid[i][j] == 1 then\n                fill = fill + 1\n            end\n\
    \        end\n        max_fill = math.max(max_fill, fill)\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "  local rows = #grid\n  local cols =\
    \ #grid[1]\n  local max_fill = 0\n  for i = 1, rows do\n    local fill = 0\n \
    \   for j = 1, cols do\n      fill = fill + grid[i][j]\n    end\n    if fill >\
    \ max_fill then\n      max_fill = fill\n    end\n  end\n  return math.ceil(max_fill\
    \ / capacity)\nend", "    local rows = #grid\n    local cols = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, rows do\n        local fill = 0\n        for j\
    \ = 1, cols do\n            fill = fill + grid[i][j]\n        end\n        max_fill\
    \ = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n\
    \        for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n      \
    \  end\n        if fill > max_fill then\n            max_fill = fill\n       \
    \ end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local rows\
    \ = #grid\n    local cols = #grid[1]\n    local max_fill = 0\n    for i = 1, rows\
    \ do\n        local fill = 0\n        for j = 1, cols do\n            fill = fill\
    \ + grid[i][j]\n        end\n        max_fill = math.max(max_fill, fill)\n   \
    \ end\n    return math.ceil(max_fill / capacity)\nend", "    local n = #grid\n\
    \    local m = #grid[1]\n    local max_fill = {}\n    for i = 1, n do\n      \
    \  max_fill[i] = {}\n        for j = 1, m do\n            max_fill[i][j] = 0\n\
    \        end\n    end\n    for i = 1, n do\n        for j = 1, m do\n        \
    \    if grid[i][j] == 1 then\n                max_fill[i][j] = 1\n           \
    \ end\n        end\n    end\n    for i = 1, n do\n        for j = 1, m do\n  \
    \          if max_fill[i][j] == 1 then\n                for k = i + 1, n do\n\
    \                    if max_fill[k][j] == 1 then\n                        break\n\
    \                    end\n                    max_fill[k][j] = 1\n           \
    \     end\n            end\n        end\n    end\n    local result = 0\n    for\
    \ i = 1, n do\n        for j = 1, m do\n            if max_fill[i][j] == 1 then\n\
    \                result = result + 1\n            end\n        end\n    end\n\
    \    return result\nend", "    local rows = #grid\n    local cols = #grid[1]\n\
    \    local max_fill = 0\n    for i = 1, rows do\n        local fill = 0\n    \
    \    for j = 1, cols do\n            if grid[i][j] == 1 then\n               \
    \ fill = fill + 1\n            end\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n\
    \ do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n         \
    \       max_fill = max_fill + 1\n            end\n        end\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n    local cols\
    \ = #grid[1]\n    local max_fill = 0\n    for i = 1, rows do\n        local fill\
    \ = 0\n        for j = 1, cols do\n            fill = fill + grid[i][j]\n    \
    \    end\n        max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "  local n = #grid\n  local m = #grid[1]\n  local result\
    \ = 0\n  local function fill(i, j)\n    if i > n or j > m then\n      return\n\
    \    end\n    if grid[i][j] == 1 then\n      grid[i][j] = 0\n      result = result\
    \ + 1\n      fill(i, j + 1)\n      fill(i + 1, j)\n    end\n  end\n  for i = 1,\
    \ n do\n    for j = 1, m do\n      fill(i, j)\n    end\n  end\n  return result\n\
    end", "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n \
    \   for i = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n\
    \                max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local n = #grid\n    local\
    \ m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n        for j = 1,\
    \ m do\n            if grid[i][j] == 1 then\n                max_fill = max_fill\
    \ + 1\n            end\n        end\n    end\n    return math.ceil(max_fill /\
    \ capacity)\nend", "    local max_fill = 0\n    for _, row in ipairs(grid) do\n\
    \        local fill = 0\n        for _, well in ipairs(row) do\n            fill\
    \ = fill + well\n            if fill > capacity then\n                max_fill\
    \ = max_fill + 1\n                fill = 0\n            end\n        end\n   \
    \     if fill > 0 then\n            max_fill = max_fill + 1\n        end\n   \
    \ end\n    return max_fill\nend", "    local rows = #grid\n    local cols = #grid[1]\n\
    \    local max_fill = 0\n    for i = 1, rows do\n        local fill = 0\n    \
    \    for j = 1, cols do\n            fill = fill + grid[i][j]\n        end\n \
    \       max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local max_fill = 0\n    for i = 1, #grid do\n      \
    \  local fill = 0\n        for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n\
    \        end\n        if fill > max_fill then\n            max_fill = fill\n \
    \       end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ rows = #grid\n    local cols = #grid[1]\n    local max_fill = 0\n    for i =\
    \ 1, rows do\n        local fill = 0\n        for j = 1, cols do\n           \
    \ fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j\
    \ = 1, #grid[i] do\n            fill = fill + grid[i][j]\n        end\n      \
    \  if fill > max_fill then\n            max_fill = fill\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local n = #grid\n    local\
    \ m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n        local fill\
    \ = 0\n        for j = 1, m do\n            fill = fill + grid[i][j]\n       \
    \ end\n        max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local max_fill = 0\n    for i = 1, #grid do\n      \
    \  local fill = 0\n        for j = 1, #grid[i] do\n            if grid[i][j] ==\
    \ 1 then\n                fill = fill + 1\n            end\n        end\n    \
    \    if fill > max_fill then\n            max_fill = fill\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n  \
    \  local cols = #grid[1]\n    local max_fill = 0\n    for j = 1, cols do\n   \
    \     local fill = 0\n        for i = 1, rows do\n            fill = fill + grid[i][j]\n\
    \        end\n        max_fill = math.max(max_fill, fill)\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n\
    \    local max_fill = 0\n    for i = 1, n do\n        local fill = 0\n       \
    \ for j = 1, m do\n            fill = fill + grid[i][j]\n        end\n       \
    \ max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local max_fill = 0\n    for i = 1, #grid do\n      \
    \  local fill = 0\n        for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n\
    \        end\n        if fill > max_fill then\n            max_fill = fill\n \
    \       end\n    end\n    return math.ceil(max_fill / capacity)\nend", "  local\
    \ function fill(row)\n    local count = 0\n    for i = 1, #row do\n      if row[i]\
    \ == 1 then\n        row[i] = 0\n        count = count + 1\n      end\n    end\n\
    \    return count\n  end\n  local function empty(row)\n    local count = 0\n \
    \   for i = 1, #row do\n      if row[i] == 0 then\n        row[i] = 1\n      \
    \  count = count + 1\n      end\n    end\n    return count\n  end\n  local function\
    \ fill_row(row, capacity)\n    local count = 0\n    while capacity > 0 do\n  \
    \    local filled = fill(row)\n      if filled == 0 then\n        break\n    \
    \  end\n      count = count + 1\n      capacity = capacity - filled\n    end\n\
    \    return count\n  end\n  local function empty_row(row, capacity)\n    local\
    \ count = 0\n    while capacity > 0 do\n      local emptied = empty(row)\n   \
    \   if emptied == 0 then\n        break\n      end\n      count = count + 1\n\
    \      capacity = capacity - emptied\n    end\n    return count\n  end\n  local\
    \ count = 0\n  for i = 1, #grid do\n    count = count + fill_row(grid[i], capacity)\n\
    \    count = count + empty_row(grid[i], capacity)\n  end\n  return count\nend",
  "    local n = #grid\n    local m = #grid[1]\n    local count = 0\n    for i = 1,\
    \ n do\n        local max_fill = 0\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n        count = count + math.ceil(max_fill / capacity)\n    end\n    return\
    \ count\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local rows\
    \ = #grid\n    local cols = #grid[1]\n    local max_fill = 0\n    for i=1,rows\
    \ do\n        local fill = 0\n        for j=1,cols do\n            fill = fill\
    \ + grid[i][j]\n        end\n        max_fill = math.max(max_fill, fill)\n   \
    \ end\n    return math.ceil(max_fill / capacity)\nend", "    local n = #grid\n\
    \    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n       \
    \ for j = 1, m do\n            if grid[i][j] == 1 then\n                max_fill\
    \ = max_fill + 1\n            end\n        end\n    end\n    return max_fill *\
    \ capacity\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local n\
    \ = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n\
    \        for j = 1, m do\n            if grid[i][j] == 1 then\n              \
    \  max_fill = max_fill + 1\n            end\n        end\n    end\n    return\
    \ max_fill\nend", "    local rows = #grid\n    local cols = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, rows do\n        local fill = 0\n        for j\
    \ = 1, cols do\n            fill = fill + grid[i][j]\n        end\n        max_fill\
    \ = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local max_fill = 0\n    for _, row in ipairs(grid) do\n        local\
    \ fill = 0\n        for _, well in ipairs(row) do\n            fill = fill + well\n\
    \            if fill > capacity then\n                fill = capacity\n      \
    \      end\n        end\n        if fill > max_fill then\n            max_fill\
    \ = fill\n        end\n    end\n    return max_fill\nend", "    local max_fill\
    \ = 0\n    for _, row in ipairs(grid) do\n        local fill = 0\n        for\
    \ _, well in ipairs(row) do\n            fill = fill + well\n            if fill\
    \ > capacity then\n                max_fill = max_fill + 1\n                fill\
    \ = 0\n            end\n        end\n        if fill > 0 then\n            max_fill\
    \ = max_fill + 1\n        end\n    end\n    return max_fill\nend", "    local\
    \ n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n\
    \ do\n        local fill = 0\n        for j = 1, m do\n            fill = fill\
    \ + grid[i][j]\n        end\n        max_fill = math.max(max_fill, fill)\n   \
    \ end\n    return math.ceil(max_fill / capacity)\nend", "    local n = #grid\n\
    \    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n       \
    \ for j = 1, m do\n            if grid[i][j] == 1 then\n                max_fill\
    \ = max_fill + 1\n            end\n        end\n    end\n    local min_fill =\
    \ math.ceil(max_fill / capacity)\n    return min_fill\nend", "    local rows =\
    \ #grid\n    local cols = #grid[1]\n    local max_fill = 0\n    for i = 1, rows\
    \ do\n        local fill = 0\n        for j = 1, cols do\n            fill = fill\
    \ + grid[i][j]\n        end\n        max_fill = math.max(max_fill, fill)\n   \
    \ end\n    local times = math.ceil(max_fill / capacity)\n    return times\nend",
  "    local rows = #grid\n    local cols = #grid[1]\n    local max_fill = 0\n   \
    \ for i = 1, rows do\n        local fill = 0\n        for j = 1, cols do\n   \
    \         fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j\
    \ = 1, #grid[i] do\n            fill = fill + grid[i][j]\n        end\n      \
    \  if fill > max_fill then\n            max_fill = fill\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n  \
    \  local cols = #grid[1]\n    local max_fill = 0\n    for i = 1, rows do\n   \
    \     local fill = 0\n        for j = 1, cols do\n            fill = fill + grid[i][j]\n\
    \        end\n        max_fill = math.max(max_fill, fill)\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n    local cols\
    \ = #grid[1]\n    local max_fill = 0\n    for i = 1, rows do\n        local fill\
    \ = 0\n        for j = 1, cols do\n            fill = fill + grid[i][j]\n    \
    \    end\n        max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        local fill = 0\n        for j = 1, m do\n\
    \            fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j\
    \ = 1, #grid[i] do\n            fill = fill + grid[i][j]\n        end\n      \
    \  if fill > max_fill then\n            max_fill = fill\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local max_fill = 0\n  \
    \  for _, row in ipairs(grid) do\n        local fill = 0\n        for _, col in\
    \ ipairs(row) do\n            fill = fill + col\n            if fill > capacity\
    \ then\n                max_fill = max_fill + 1\n                fill = 0\n  \
    \          end\n        end\n        if fill > 0 then\n            max_fill =\
    \ max_fill + 1\n        end\n    end\n    return max_fill\nend", "  local n =\
    \ #grid\n  local m = #grid[1]\n  local max_fill = 0\n  for i = 1, n do\n    for\
    \ j = 1, m do\n      if grid[i][j] == 1 then\n        max_fill = max_fill + 1\n\
    \      end\n    end\n  end\n  local min_buckets = math.ceil(max_fill / capacity)\n\
    \  local buckets = {}\n  for i = 1, min_buckets do\n    buckets[i] = 0\n  end\n\
    \  local i = 1\n  while i <= n do\n    local j = 1\n    while j <= m do\n    \
    \  if grid[i][j] == 1 then\n        local bucket = 1\n        while bucket <=\
    \ min_buckets do\n          if buckets[bucket] < capacity then\n            buckets[bucket]\
    \ = buckets[bucket] + 1\n            grid[i][j] = 0\n            break\n     \
    \     end\n          bucket = bucket + 1\n        end\n      end\n      j = j\
    \ + 1\n    end\n    i = i + 1\n  end\n  return min_buckets\nend", "    local n\
    \ = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n\
    \        for j = 1, m do\n            if grid[i][j] == 1 then\n              \
    \  max_fill = max_fill + 1\n            end\n        end\n    end\n    local min_fill\
    \ = math.floor(max_fill / capacity)\n    if max_fill % capacity ~= 0 then\n  \
    \      min_fill = min_fill + 1\n    end\n    return min_fill\nend", "    local\
    \ n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n\
    \ do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n         \
    \       max_fill = max_fill + 1\n            end\n        end\n    end\n    local\
    \ min_fill = math.floor(max_fill / capacity)\n    if max_fill % capacity ~= 0\
    \ then\n        min_fill = min_fill + 1\n    end\n    return min_fill\nend", " \
    \   local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i\
    \ = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n  \
    \              max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    local min_fill = math.floor(max_fill / capacity)\n    local max_fill = min_fill\
    \ * capacity\n    return min_fill, max_fill\nend", "    local n = #grid\n    local\
    \ m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n        local fill\
    \ = 0\n        for j = 1, m do\n            fill = fill + grid[i][j]\n       \
    \ end\n        max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    local min_fill = math.ceil(max_fill / capacity)\n    return\
    \ min_fill\nend", "    local max_fill = 0\n    for _, row in ipairs(grid) do\n\
    \        local fill = 0\n        for _, cell in ipairs(row) do\n            fill\
    \ = fill + cell\n            if fill > capacity then\n                max_fill\
    \ = max_fill + 1\n                fill = 0\n            end\n        end\n   \
    \     if fill > 0 then\n            max_fill = max_fill + 1\n        end\n   \
    \ end\n    return max_fill\nend", "    local max_fill = 0\n    for _, row in ipairs(grid)\
    \ do\n        local fill = 0\n        for _, cell in ipairs(row) do\n        \
    \    fill = fill + cell\n            if fill > capacity then\n               \
    \ max_fill = max_fill + 1\n                fill = 0\n            end\n       \
    \ end\n        if fill > 0 then\n            max_fill = max_fill + 1\n       \
    \ end\n    end\n    return max_fill\nend", "    local max_fill = 0\n    for i\
    \ = 1, #grid do\n        local fill = 0\n        for j = 1, #grid[i] do\n    \
    \        fill = fill + grid[i][j]\n        end\n        if fill > max_fill then\n\
    \            max_fill = fill\n        end\n    end\n    return max_fill\nend",
  "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i\
    \ = 1, n do\n        local fill = 0\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                fill = fill + 1\n            end\n        end\n \
    \       max_fill = math.max(max_fill, fill)\n    end\n    return max_fill\nend",
  "    local max_fill = 0\n    for _, row in ipairs(grid) do\n        local fill =\
    \ 0\n        for _, well in ipairs(row) do\n            fill = fill + well\n \
    \           if fill > capacity then\n                max_fill = max_fill + 1\n\
    \                fill = 0\n            end\n        end\n        if fill > 0 then\n\
    \            max_fill = max_fill + 1\n        end\n    end\n    return max_fill\n\
    end", "    local max_fill = 0\n    for _, row in ipairs(grid) do\n        local\
    \ fill = 0\n        for _, cell in ipairs(row) do\n            fill = fill + cell\n\
    \            if fill > capacity then\n                max_fill = max_fill + 1\n\
    \                fill = 0\n            end\n        end\n        if fill > 0 then\n\
    \            max_fill = max_fill + 1\n        end\n    end\n    return max_fill\n\
    end", "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n \
    \   for i = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n\
    \                max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    local min_fill = math.ceil(max_fill / capacity)\n    return min_fill\nend",
  "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i\
    \ = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n  \
    \              max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    local min_fill = math.ceil(max_fill / capacity)\n    return min_fill\nend",
  "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i\
    \ = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n  \
    \              max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    local min_fill = math.ceil(max_fill / capacity)\n    return min_fill\nend",
  "    local rows = #grid\n    local cols = #grid[1]\n    local max_fill = 0\n   \
    \ for i = 1, rows do\n        local fill = 0\n        for j = 1, cols do\n   \
    \         fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n\
    \ do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n         \
    \       max_fill = max_fill + 1\n            end\n        end\n    end\n    local\
    \ min_fill = math.floor(max_fill / capacity)\n    if max_fill % capacity > 0 then\n\
    \        min_fill = min_fill + 1\n    end\n    return min_fill\nend", "    local\
    \ n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n\
    \ do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n         \
    \       max_fill = max_fill + 1\n            end\n        end\n    end\n    local\
    \ min_fill = math.ceil(max_fill / capacity)\n    return min_fill\nend", "    local\
    \ max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j\
    \ = 1, #grid[i] do\n            fill = fill + grid[i][j]\n        end\n      \
    \  if fill > max_fill then\n            max_fill = fill\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n  \
    \  local cols = #grid[1]\n    local max_fill = 0\n    for i = 1, rows do\n   \
    \     local fill = 0\n        for j = 1, cols do\n            fill = fill + grid[i][j]\n\
    \        end\n        max_fill = math.max(max_fill, fill)\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n    local cols\
    \ = #grid[1]\n    local max_fill = 0\n    for i = 1, rows do\n        local fill\
    \ = 0\n        for j = 1, cols do\n            fill = fill + grid[i][j]\n    \
    \    end\n        max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local max_fill = 0\n    for i = 1, #grid do\n      \
    \  local fill = 0\n        for j = 1, #grid[i] do\n            if grid[i][j] ==\
    \ 1 then\n                fill = fill + 1\n            end\n        end\n    \
    \    if fill > max_fill then\n            max_fill = fill\n        end\n    end\n\
    \    return max_fill\nend", "  local rows = #grid\n  local cols = #grid[1]\n \
    \ local max_fill = 0\n  for i = 1, rows do\n    local fill = 0\n    for j = 1,\
    \ cols do\n      fill = fill + grid[i][j]\n    end\n    max_fill = math.max(max_fill,\
    \ fill)\n  end\n  return math.ceil(max_fill / capacity)\nend", "    local max_fill\
    \ = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j = 1, #grid[i]\
    \ do\n            fill = fill + grid[i][j]\n        end\n        if fill > max_fill\
    \ then\n            max_fill = fill\n        end\n    end\n    return max_fill\n\
    end", "    local max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n\
    \        for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n      \
    \  end\n        if fill > max_fill then\n            max_fill = fill\n       \
    \ end\n    end\n    return max_fill\nend", "    local max_fill = 0\n    for _,\
    \ row in ipairs(grid) do\n        local fill = 0\n        for _, well in ipairs(row)\
    \ do\n            fill = fill + well\n            if fill > capacity then\n  \
    \              max_fill = max_fill + 1\n                fill = 0\n           \
    \ end\n        end\n        if fill > 0 then\n            max_fill = max_fill\
    \ + 1\n        end\n    end\n    return max_fill\nend", "    local n = #grid\n\
    \    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n       \
    \ for j = 1, m do\n            if grid[i][j] == 1 then\n                max_fill\
    \ = max_fill + 1\n            end\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "  local n = #grid\n  local m = #grid[1]\n  local result\
    \ = 0\n  local function fill(i, j)\n    if i < 1 or i > n or j < 1 or j > m then\n\
    \      return 0\n    end\n    if grid[i][j] == 0 then\n      return 0\n    end\n\
    \    grid[i][j] = 0\n    return 1 + fill(i, j+1) + fill(i, j-1) + fill(i+1, j)\
    \ + fill(i-1, j)\n  end\n  for i = 1, n do\n    for j = 1, m do\n      if grid[i][j]\
    \ == 1 then\n        local fill_count = fill(i, j)\n        local bucket_count\
    \ = math.ceil(fill_count / capacity)\n        result = result + bucket_count\n\
    \      end\n    end\n  end\n  return result\nend", "    local max_fill = 0\n \
    \   for i = 1, #grid do\n        local fill = 0\n        for j = 1, #grid[i] do\n\
    \            fill = fill + grid[i][j]\n        end\n        if fill > max_fill\
    \ then\n            max_fill = fill\n        end\n    end\n    return max_fill\n\
    end", "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n \
    \   for i = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n\
    \                max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    local min_fill = math.ceil(max_fill / capacity)\n    return min_fill\nend",
  "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i\
    \ = 1, n do\n        local fill = 0\n        for j = 1, m do\n            fill\
    \ = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill, fill)\n\
    \    end\n    return math.ceil(max_fill / capacity)\nend", "    local max_fill\
    \ = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j = 1, #grid[i]\
    \ do\n            fill = fill + grid[i][j]\n        end\n        if fill > max_fill\
    \ then\n            max_fill = fill\n        end\n    end\n    return max_fill\n\
    end", "    local n = #grid\n    local m = #grid[1]\n    local function fill(i,\
    \ j)\n        local c = 0\n        while i <= n and grid[i][j] == 1 do\n     \
    \       grid[i][j] = 0\n            c = c + 1\n            i = i + 1\n       \
    \ end\n        return c\n    end\n    local function empty(i, j)\n        local\
    \ c = 0\n        while i >= 1 and grid[i][j] == 0 do\n            grid[i][j] =\
    \ 1\n            c = c + 1\n            i = i - 1\n        end\n        return\
    \ c\n    end\n    local function fill_all(j)\n        local c = 0\n        for\
    \ i = 1, n do\n            c = c + fill(i, j)\n        end\n        return c\n\
    \    end\n    local function empty_all(j)\n        local c = 0\n        for i\
    \ = n, 1, -1 do\n            c = c + empty(i, j)\n        end\n        return\
    \ c\n    end\n    local function fill_capacity(j)\n        local c = 0\n     \
    \   for i = 1, n do\n            if grid[i][j] == 1 then\n                c =\
    \ c + fill(i, j)\n                if c == capacity then\n                    return\
    \ c\n                end\n            end\n        end\n        return c\n   \
    \ end\n    local function empty_capacity(j)\n        local c = 0\n        for\
    \ i = n, 1, -1 do\n            if grid[i][j] == 0 then\n                c = c\
    \ + empty(i, j)\n                if c == capacity then\n                    return\
    \ c\n                end\n            end\n        end\n        return c\n   \
    \ end\n    local function fill_empty(j)\n        local c = 0\n        for i =\
    \ 1, n do\n            if grid[i][j] == 1 then\n                c = c + fill(i,\
    \ j)\n                if c == capacity then\n                    return c\n  \
    \              end\n            elseif grid[i][j] == 0 then\n                c\
    \ = c + empty(i, j)\n                if c == capacity then\n                 \
    \   return c\n                end\n            end\n        end\n        return",
  "    local max_fill = 0\n    for _, row in ipairs(grid) do\n        local fill =\
    \ 0\n        for _, cell in ipairs(row) do\n            fill = fill + cell\n \
    \           if fill > capacity then\n                fill = capacity\n       \
    \     end\n        end\n        if fill > max_fill then\n            max_fill\
    \ = fill\n        end\n    end\n    return max_fill\nend", "    local rows = #grid\n\
    \    local cols = #grid[1]\n    local fill = 0\n    local row_max = {}\n    for\
    \ i = 1, rows do\n        local max = 0\n        for j = 1, cols do\n        \
    \    if grid[i][j] == 1 then\n                max = j\n            end\n     \
    \   end\n        row_max[i] = max\n    end\n    local col_max = {}\n    for j\
    \ = 1, cols do\n        local max = 0\n        for i = 1, rows do\n          \
    \  if grid[i][j] == 1 then\n                max = i\n            end\n       \
    \ end\n        col_max[j] = max\n    end\n    for i = 1, rows do\n        for\
    \ j = 1, cols do\n            if grid[i][j] == 1 then\n                local max\
    \ = math.min(row_max[i], col_max[j])\n                local delta = max - i\n\
    \                if delta > 0 then\n                    fill = fill + delta\n\
    \                end\n            end\n        end\n    end\n    return fill\n\
    end", "    local rows = #grid\n    local cols = #grid[1]\n    local max_fill =\
    \ 0\n    for i = 1, rows do\n        for j = 1, cols do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local n\
    \ = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n\
    \        for j = 1, m do\n            if grid[i][j] == 1 then\n              \
    \  max_fill = max_fill + 1\n            end\n        end\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local max_fill = 0\n    for i = 1,\
    \ #grid do\n        local fill = 0\n        for j = 1, #grid[i] do\n         \
    \   fill = fill + grid[i][j]\n        end\n        if fill > max_fill then\n \
    \           max_fill = fill\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local max_fill = 0\n    for i = 1, #grid do\n      \
    \  local fill = 0\n        for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n\
    \        end\n        if fill > max_fill then\n            max_fill = fill\n \
    \       end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j\
    \ = 1, #grid[i] do\n            fill = fill + grid[i][j]\n        end\n      \
    \  if fill > max_fill then\n            max_fill = fill\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local max_fill = 0\n  \
    \  for _, row in ipairs(grid) do\n        local fill = 0\n        for _, well\
    \ in ipairs(row) do\n            fill = fill + well\n            if fill > capacity\
    \ then\n                max_fill = max_fill + 1\n                fill = 0\n  \
    \          end\n        end\n        if fill > 0 then\n            max_fill =\
    \ max_fill + 1\n        end\n    end\n    return max_fill\nend", "    local max_fill\
    \ = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j = 1, #grid[i]\
    \ do\n            fill = fill + grid[i][j]\n        end\n        if fill > max_fill\
    \ then\n            max_fill = fill\n        end\n    end\n    return max_fill\n\
    end", "    local n = #grid\n    local m = #grid[1]\n    local max_fill = {}\n\
    \    for i = 1, n do\n        max_fill[i] = 0\n        for j = 1, m do\n     \
    \       if grid[i][j] == 1 then\n                max_fill[i] = max_fill[i] + 1\n\
    \            end\n        end\n    end\n    local max_fill_sum = 0\n    for i\
    \ = 1, n do\n        max_fill_sum = max_fill_sum + max_fill[i]\n    end\n    local\
    \ max_fill_avg = math.floor(max_fill_sum / n)\n    local max_fill_max = 0\n  \
    \  for i = 1, n do\n        max_fill_max = math.max(max_fill_max, max_fill[i])\n\
    \    end\n    local max_fill_min = max_fill_max\n    for i = 1, n do\n       \
    \ max_fill_min = math.min(max_fill_min, max_fill[i])\n    end\n    local max_fill_diff\
    \ = max_fill_max - max_fill_min\n    local max_fill_diff_avg = math.floor(max_fill_diff\
    \ / n)\n    local max_fill_diff_max = 0\n    for i = 1, n do\n        max_fill_diff_max\
    \ = math.max(max_fill_diff_max, max_fill[i] - max_fill_avg)\n    end\n    local\
    \ max_fill_diff_min = max_fill_diff_max\n    for i = 1, n do\n        max_fill_diff_min\
    \ = math.min(max_fill_diff_min, max_fill[i] - max_fill_avg)\n    end\n    local\
    \ max_fill_diff_diff = max_fill_diff_max - max_fill_diff_min\n    local max_fill_diff_diff_avg\
    \ = math.floor(max_fill_diff_diff / n)\n    local max_fill_diff_diff_max = 0\n\
    \    for i = 1, n do\n        max_fill_diff_diff_max = math.", "    local n =\
    \ #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n\
    \        for j = 1, m do\n            if grid[i][j] == 1 then\n              \
    \  max_fill = max_fill + 1\n            end\n        end\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "  local n = #grid\n  local m = #grid[1]\n\
    \  local max_fill = 0\n  for i = 1, n do\n    for j = 1, m do\n      if grid[i][j]\
    \ == 1 then\n        max_fill = max_fill + 1\n      end\n    end\n  end\n  return\
    \ math.ceil(max_fill / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n\
    \    local max_fill = 0\n    for i = 1, n do\n        for j = 1, m do\n      \
    \      if grid[i][j] == 1 then\n                max_fill = max_fill + 1\n    \
    \        end\n        end\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n \
    \   for i = 1, n do\n        local fill = 0\n        for j = 1, m do\n       \
    \     fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j\
    \ = 1, #grid[i] do\n            fill = fill + grid[i][j]\n        end\n      \
    \  if fill > max_fill then\n            max_fill = fill\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local n = #grid\n    local\
    \ m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n        local fill\
    \ = 0\n        for j = 1, m do\n            fill = fill + grid[i][j]\n       \
    \ end\n        max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local rows\
    \ = #grid\n    local cols = #grid[1]\n    local max_fill = 0\n    for i = 1, rows\
    \ do\n        local fill = 0\n        for j = 1, cols do\n            fill = fill\
    \ + grid[i][j]\n        end\n        max_fill = math.max(max_fill, fill)\n   \
    \ end\n    return math.ceil(max_fill / capacity)\nend", "    local max_fill =\
    \ 0\n    for i = 1, #grid do\n        local fill = 0\n        for j = 1, #grid[i]\
    \ do\n            fill = fill + grid[i][j]\n        end\n        if fill > max_fill\
    \ then\n            max_fill = fill\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local rows = #grid\n    local cols = #grid[1]\n    local\
    \ max_fill = 0\n    for i=1,rows do\n        local fill = 0\n        for j=1,cols\
    \ do\n            fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ rows = #grid\n    local cols = #grid[1]\n    local max_fill = 0\n    for i =\
    \ 1, rows do\n        local fill = 0\n        for j = 1, cols do\n           \
    \ fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n\
    \ do\n        local fill = 0\n        for j = 1, m do\n            fill = fill\
    \ + grid[i][j]\n        end\n        max_fill = math.max(max_fill, fill)\n   \
    \ end\n    return math.ceil(max_fill / capacity)\nend", "    local n = #grid\n\
    \    local m = #grid[1]\n    local fill = {}\n    for i = 1, n do\n        fill[i]\
    \ = {}\n        for j = 1, m do\n            fill[i][j] = 0\n        end\n   \
    \ end\n    local function fill_row(i)\n        local row = grid[i]\n        local\
    \ row_fill = fill[i]\n        local j = 1\n        while j <= m do\n         \
    \   if row[j] == 1 then\n                local k = j + 1\n                while\
    \ k <= m and row[k] == 1 do\n                    k = k + 1\n                end\n\
    \                local c = capacity\n                for l = j, k - 1 do\n   \
    \                 c = c - row_fill[l]\n                end\n                if\
    \ c > 0 then\n                    local d = math.floor(c / (k - j))\n        \
    \            local r = c % (k - j)\n                    for l = j, k - 1 do\n\
    \                        row_fill[l] = row_fill[l] + d\n                     \
    \   if r > 0 then\n                            row_fill[l] = row_fill[l] + 1\n\
    \                            r = r - 1\n                        end\n        \
    \            end\n                end\n                j = k\n            else\n\
    \                j = j + 1\n            end\n        end\n    end\n    for i =\
    \ 1, n do\n        fill_row(i)\n    end\n    local max_fill = 0\n    for i = 1,\
    \ n do\n        for j = 1, m do\n            max_fill = math.max(max_fill, fill[i][j])\n\
    \        end\n    end\n    return max_fill\nend", "    local row_max = {}\n  \
    \  for i = 1, #grid do\n        local max = 0\n        for j = 1, #grid[i] do\n\
    \            if grid[i][j] > max then\n                max = grid[i][j]\n    \
    \        end\n        end\n        row_max[i] = max\n    end\n    local col_max\
    \ = {}\n    for j = 1, #grid[1] do\n        local max = 0\n        for i = 1,\
    \ #grid do\n            if grid[i][j] > max then\n                max = grid[i][j]\n\
    \            end\n        end\n        col_max[j] = max\n    end\n    local count\
    \ = 0\n    for i = 1, #grid do\n        for j = 1, #grid[i] do\n            local\
    \ max = math.min(row_max[i], col_max[j])\n            if max > grid[i][j] then\n\
    \                local diff = max - grid[i][j]\n                local times =\
    \ math.ceil(diff / capacity)\n                count = count + times\n        \
    \    end\n        end\n    end\n    return count\nend", "    local n = #grid\n\
    \    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n       \
    \ for j = 1, m do\n            if grid[i][j] == 1 then\n                max_fill\
    \ = max_fill + 1\n            end\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local max_fill = 0\n    for _, row in ipairs(grid) do\n\
    \        local fill = 0\n        for _, well in ipairs(row) do\n            fill\
    \ = fill + well\n            if fill > capacity then\n                max_fill\
    \ = max_fill + 1\n                fill = 0\n            end\n        end\n   \
    \     if fill > 0 then\n            max_fill = max_fill + 1\n        end\n   \
    \ end\n    return max_fill\nend", "    local rows = #grid\n    local cols = #grid[1]\n\
    \    local result = 0\n    for i = 1, rows do\n        local row = grid[i]\n \
    \       local sum = 0\n        for j = 1, cols do\n            sum = sum + row[j]\n\
    \        end\n        local count = math.floor(sum / capacity)\n        result\
    \ = result + count\n        if sum % capacity ~= 0 then\n            result =\
    \ result + 1\n        end\n    end\n    return result\nend", "    local max_fill\
    \ = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j = 1, #grid[i]\
    \ do\n            fill = fill + grid[i][j]\n        end\n        if fill > max_fill\
    \ then\n            max_fill = fill\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local max_fill = 0\n    for i = 1, #grid do\n      \
    \  local fill = 0\n        for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n\
    \        end\n        if fill > max_fill then\n            max_fill = fill\n \
    \       end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n\
    \ do\n        local fill = 0\n        for j = 1, m do\n            fill = fill\
    \ + grid[i][j]\n        end\n        max_fill = math.max(max_fill, fill)\n   \
    \ end\n    return math.ceil(max_fill / capacity)\nend", "    local function fill(row,\
    \ col)\n        local fill_count = 0\n        local fill_level = 0\n        for\
    \ i = 1, #row do\n            if row[i] == 1 then\n                fill_level\
    \ = fill_level + 1\n                if fill_level == capacity then\n         \
    \           fill_count = fill_count + 1\n                    fill_level = 0\n\
    \                end\n            end\n        end\n        return fill_count\n\
    \    end\n    local function max_fill_row(grid)\n        local max_fill_count\
    \ = 0\n        for i = 1, #grid do\n            local fill_count = fill(grid[i],\
    \ capacity)\n            if fill_count > max_fill_count then\n               \
    \ max_fill_count = fill_count\n            end\n        end\n        return max_fill_count\n\
    \    end\n    local function max_fill_col(grid)\n        local max_fill_count\
    \ = 0\n        for i = 1, #grid[1] do\n            local row = {}\n          \
    \  for j = 1, #grid do\n                table.insert(row, grid[j][i])\n      \
    \      end\n            local fill_count = fill(row, capacity)\n            if\
    \ fill_count > max_fill_count then\n                max_fill_count = fill_count\n\
    \            end\n        end\n        return max_fill_count\n    end\n    return\
    \ max_fill_row(grid) + max_fill_col(grid)\nend", "    local n = #grid\n    local\
    \ m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n        for j = 1,\
    \ m do\n            if grid[i][j] == 1 then\n                max_fill = max_fill\
    \ + 1\n            end\n        end\n    end\n    return math.ceil(max_fill /\
    \ capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local n\
    \ = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n\
    \        local fill = 0\n        for j = 1, m do\n            fill = fill + grid[i][j]\n\
    \        end\n        max_fill = math.max(max_fill, fill)\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n\
    \    local max_fill = 0\n    for i = 1, n do\n        for j = 1, m do\n      \
    \      if grid[i][j] == 1 then\n                max_fill = max_fill + 1\n    \
    \        end\n        end\n    end\n    local min_fill = math.floor(max_fill /\
    \ capacity)\n    if max_fill % capacity ~= 0 then\n        min_fill = min_fill\
    \ + 1\n    end\n    return min_fill\nend", "    local n = #grid\n    local m =\
    \ #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n        for j = 1, m\
    \ do\n            if grid[i][j] == 1 then\n                max_fill = max_fill\
    \ + 1\n            end\n        end\n    end\n    return math.ceil(max_fill /\
    \ capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    local max_fill_per_bucket = math.floor(max_fill / capacity)\n\
    \    local max_fill_per_bucket_remainder = max_fill % capacity\n    local max_fill_per_bucket_remainder_per_bucket\
    \ = math.floor(max_fill_per_bucket_remainder / n)\n    local max_fill_per_bucket_remainder_per_bucket_remainder\
    \ = max_fill_per_bucket_remainder % n\n    local max_fill_per_bucket_remainder_per_bucket_remainder_per_bucket\
    \ = math.floor(max_fill_per_bucket_remainder_per_bucket_remainder / m)\n    local\
    \ max_fill_per_bucket_remainder_per_bucket_remainder_per_bucket_remainder = max_fill_per_bucket_remainder_per_bucket_remainder\
    \ % m\n    return max_fill_per_bucket + max_fill_per_bucket_remainder_per_bucket\
    \ + max_fill_per_bucket_remainder_per_bucket_remainder_per_bucket + max_fill_per_bucket_remainder_per_bucket_remainder_per_bucket_remainder\n\
    end", "    local n = #grid\n    local m = #grid[1]\n    local max_row = {}\n \
    \   for i = 1, n do\n        local max = 0\n        for j = 1, m do\n        \
    \    if grid[i][j] == 1 then\n                max = j\n            end\n     \
    \   end\n        max_row[i] = max\n    end\n    local max_col = {}\n    for j\
    \ = 1, m do\n        local max = 0\n        for i = 1, n do\n            if grid[i][j]\
    \ == 1 then\n                max = i\n            end\n        end\n        max_col[j]\
    \ = max\n    end\n    local result = 0\n    for i = 1, n do\n        for j = 1,\
    \ m do\n            if grid[i][j] == 1 then\n                local max_row_fill\
    \ = max_row[i]\n                local max_col_fill = max_col[j]\n            \
    \    local max_fill = math.min(max_row_fill, max_col_fill)\n                local\
    \ fill = math.min(max_fill, capacity)\n                result = result + fill\n\
    \                grid[i][j] = grid[i][j] - fill\n            end\n        end\n\
    \    end\n    return result\nend", "    local n = #grid\n    local m = #grid[1]\n\
    \    local max_fill = 0\n    for i = 1, n do\n        for j = 1, m do\n      \
    \      if grid[i][j] == 1 then\n                max_fill = max_fill + 1\n    \
    \        end\n        end\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "  local n = #grid\n  local m = #grid[1]\n  local result = 0\n  for i =\
    \ 1, n do\n    local fill = 0\n    for j = 1, m do\n      fill = fill + grid[i][j]\n\
    \      if fill == capacity then\n        result = result + 1\n        fill = 0\n\
    \      end\n    end\n    if fill > 0 then\n      result = result + 1\n    end\n\
    \  end\n  return result\nend", "    local max_fill = 0\n    for _, row in ipairs(grid)\
    \ do\n        local fill = 0\n        for _, well in ipairs(row) do\n        \
    \    fill = fill + well\n            if fill > capacity then\n               \
    \ fill = capacity\n            end\n        end\n        if fill > max_fill then\n\
    \            max_fill = fill\n        end\n    end\n    return max_fill\nend",
  "    local max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n     \
    \   for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n        end\n\
    \        if fill > max_fill then\n            max_fill = fill\n        end\n \
    \   end\n    return math.ceil(max_fill / capacity)\nend", "    local function\
    \ fill(i, j)\n        local sum = 0\n        for k = i, #grid do\n           \
    \ sum = sum + grid[k][j]\n            if sum > capacity then\n               \
    \ return false\n            end\n        end\n        return true\n    end\n \
    \   local function fill_all(j)\n        for i = 1, #grid do\n            if not\
    \ fill(i, j) then\n                return false\n            end\n        end\n\
    \        return true\n    end\n    local function fill_all_cols()\n        for\
    \ j = 1, #grid[1] do\n            if not fill_all(j) then\n                return\
    \ false\n            end\n        end\n        return true\n    end\n    local\
    \ function fill_all_rows()\n        for i = 1, #grid do\n            if not fill(i,\
    \ 1) then\n                return false\n            end\n        end\n      \
    \  return true\n    end\n    local function fill_all_rows_cols()\n        for\
    \ i = 1, #grid do\n            for j = 1, #grid[1] do\n                if not\
    \ fill(i, j) then\n                    return false\n                end\n   \
    \         end\n        end\n        return true\n    end\n    local function fill_all_cols_rows()\n\
    \        for j = 1, #grid[1] do\n            for i = 1, #grid do\n           \
    \     if not fill(i, j) then\n                    return false\n             \
    \   end\n            end\n        end\n        return true\n    end\n    local\
    \ function fill_all_rows_cols_rows()\n        for i = 1, #grid do\n          \
    \  for j = 1, #grid[1] do\n                if not fill(i, j) then\n          \
    \          return false\n                end\n            end\n        end\n \
    \       for i = 1, #grid do\n            if not fill(i, 1) then\n            \
    \    return false\n            end\n        end\n        return true\n    end\n\
    \    local function fill_all_cols_rows_cols()\n        for j = 1, #grid[1] do\n\
    \            for i = 1, #grid do\n                if not fill(i, j) then\n   \
    \                 return false\n                end\n            end\n       \
    \ end\n        for j =", "    local n = #grid\n    local m = #grid[1]\n    local\
    \ result = 0\n    local max_row = 0\n    for i = 1, n do\n        local row =\
    \ 0\n        for j = 1, m do\n            row = row + grid[i][j]\n        end\n\
    \        max_row = math.max(max_row, row)\n    end\n    result = math.ceil(max_row\
    \ / capacity)\n    return result\nend", "    local n = #grid\n    local m = #grid[1]\n\
    \    local max_fill = 0\n    for i = 1, n do\n        for j = 1, m do\n      \
    \      if grid[i][j] == 1 then\n                max_fill = max_fill + 1\n    \
    \        end\n        end\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local rows = #grid\n    local cols = #grid[1]\n    local max_fill =\
    \ 0\n    for i = 1, rows do\n        local fill = 0\n        for j = 1, cols do\n\
    \            fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n\
    \ do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n         \
    \       max_fill = max_fill + 1\n            end\n        end\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n\
    \    local max_fill = 0\n    for i = 1, n do\n        for j = 1, m do\n      \
    \      if grid[i][j] == 1 then\n                max_fill = max_fill + 1\n    \
    \        end\n        end\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local rows = #grid\n    local cols = #grid[1]\n    local max_fill =\
    \ 0\n    for i = 1, rows do\n        local fill = 0\n        for j = 1, cols do\n\
    \            fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "  local n\
    \ = #grid\n  local m = #grid[1]\n  local max_fill = 0\n  for i = 1, n do\n   \
    \ for j = 1, m do\n      if grid[i][j] == 1 then\n        max_fill = max_fill\
    \ + 1\n      end\n    end\n  end\n  return math.ceil(max_fill / capacity)\nend",
  "    local rows = #grid\n    local cols = #grid[1]\n    local max_fill = 0\n   \
    \ for i = 1, rows do\n        local fill = 0\n        for j = 1, cols do\n   \
    \         fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "  local n\
    \ = #grid\n  local m = #grid[1]\n  local max_fill = 0\n  for i = 1, n do\n   \
    \ local fill = 0\n    for j = 1, m do\n      fill = fill + grid[i][j]\n    end\n\
    \    max_fill = math.max(max_fill, fill)\n  end\n  return math.ceil(max_fill /\
    \ capacity)\nend", "    local rows = #grid\n    local cols = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, rows do\n        local fill = 0\n        for j\
    \ = 1, cols do\n            fill = fill + grid[i][j]\n        end\n        max_fill\
    \ = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local max_fill = 0\n    for _, row in ipairs(grid) do\n        local\
    \ fill = 0\n        for _, well in ipairs(row) do\n            fill = fill + well\n\
    \            if fill > capacity then\n                max_fill = max_fill + 1\n\
    \                fill = well\n            end\n        end\n        max_fill =\
    \ max_fill + 1\n    end\n    return max_fill\nend", "    local n = #grid\n   \
    \ local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n        local\
    \ fill = 0\n        for j = 1, m do\n            fill = fill + grid[i][j]\n  \
    \      end\n        max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "  local rows = #grid\n  local cols = #grid[1]\n  local max_fill\
    \ = 0\n  for i = 1, rows do\n    for j = 1, cols do\n      if grid[i][j] == 1\
    \ then\n        max_fill = max_fill + 1\n      end\n    end\n  end\n  return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    local min_fill = math.floor(max_fill / capacity)\n    if\
    \ max_fill % capacity ~= 0 then\n        min_fill = min_fill + 1\n    end\n  \
    \  return min_fill\nend", "    local n = #grid\n    local m = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, n do\n        local fill = 0\n        for j = 1,\
    \ m do\n            fill = fill + grid[i][j]\n        end\n        max_fill =\
    \ math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n\
    \        for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n      \
    \  end\n        if fill > max_fill then\n            max_fill = fill\n       \
    \ end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local max_fill\
    \ = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j = 1, #grid[i]\
    \ do\n            fill = fill + grid[i][j]\n        end\n        if fill > max_fill\
    \ then\n            max_fill = fill\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    local min_fill = math.floor(max_fill / capacity)\n    if\
    \ max_fill % capacity ~= 0 then\n        min_fill = min_fill + 1\n    end\n  \
    \  return min_fill\nend", "    local n = #grid\n    local m = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local result\
    \ = 0\n    for i = 1, #grid do\n        local row = grid[i]\n        local j =\
    \ 1\n        while j <= #row do\n            if row[j] == 1 then\n           \
    \     local k = j + 1\n                while k <= #row and row[k] == 1 do\n  \
    \                  k = k + 1\n                end\n                local fill\
    \ = k - j\n                if fill > capacity then\n                    fill =\
    \ capacity\n                end\n                result = result + fill\n    \
    \            j = k\n            else\n                j = j + 1\n            end\n\
    \        end\n    end\n    return result\nend", "    local max_fill = 0\n    for\
    \ i = 1, #grid do\n        local fill = 0\n        for j = 1, #grid[i] do\n  \
    \          fill = fill + grid[i][j]\n        end\n        if fill > max_fill then\n\
    \            max_fill = fill\n        end\n    end\n    return max_fill\nend",
  "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i\
    \ = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n  \
    \              max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n  \
    \  local cols = #grid[1]\n    local max_fill = 0\n    for i = 1, rows do\n   \
    \     for j = 1, cols do\n            if grid[i][j] == 1 then\n              \
    \  max_fill = max_fill + 1\n            end\n        end\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n\
    \    local max_fill = 0\n    for i = 1, n do\n        for j = 1, m do\n      \
    \      if grid[i][j] == 1 then\n                max_fill = max_fill + 1\n    \
    \        end\n        end\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n \
    \   for i = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n\
    \                max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    local min_fill = math.floor(max_fill / capacity)\n    if max_fill % capacity\
    \ ~= 0 then\n        min_fill = min_fill + 1\n    end\n    return min_fill\nend",
  "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i\
    \ = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n  \
    \              max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n  \
    \  local cols = #grid[1]\n    local max_fill = 0\n    for i = 1, rows do\n   \
    \     for j = 1, cols do\n            if grid[i][j] == 1 then\n              \
    \  max_fill = max_fill + 1\n            end\n        end\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n    local cols\
    \ = #grid[1]\n    local fill = 0\n    local i = 1\n    while i <= rows do\n  \
    \      local j = 1\n        while j <= cols do\n            if grid[i][j] == 1\
    \ then\n                fill = fill + 1\n                local k = i\n       \
    \         while k <= rows and grid[k][j] == 1 do\n                    grid[k][j]\
    \ = 0\n                    k = k + 1\n                end\n            end\n \
    \           j = j + 1\n        end\n        i = i + 1\n    end\n    return fill\n\
    end", "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n \
    \   for i = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n\
    \                max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "  local n = #grid\n  local\
    \ m = #grid[1]\n  local max_fill = 0\n  for i = 1, n do\n    for j = 1, m do\n\
    \      if grid[i][j] == 1 then\n        max_fill = max_fill + 1\n      end\n \
    \   end\n  end\n  return math.ceil(max_fill / capacity)\nend", "    local rows\
    \ = #grid\n    local cols = #grid[1]\n    local max_fill = 0\n    for i = 1, rows\
    \ do\n        local fill = 0\n        for j = 1, cols do\n            fill = fill\
    \ + grid[i][j]\n        end\n        max_fill = math.max(max_fill, fill)\n   \
    \ end\n    return math.ceil(max_fill / capacity)\nend", "    local n = #grid\n\
    \    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n       \
    \ for j = 1, m do\n            if grid[i][j] == 1 then\n                max_fill\
    \ = max_fill + 1\n            end\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local rows = #grid\n    local cols = #grid[1]\n    local\
    \ max_fill = 0\n    local fill = 0\n    for j = 1, cols do\n        fill = 0\n\
    \        for i = 1, rows do\n            fill = fill + grid[i][j]\n        end\n\
    \        max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    local min_fill = math.floor(max_fill / capacity)\n    if\
    \ max_fill % capacity ~= 0 then\n        min_fill = min_fill + 1\n    end\n  \
    \  return min_fill\nend", "    local max_fill = 0\n    for i = 1, #grid do\n \
    \       local fill = 0\n        for j = 1, #grid[i] do\n            fill = fill\
    \ + grid[i][j]\n        end\n        if fill > max_fill then\n            max_fill\
    \ = fill\n        end\n    end\n    return math.ceil(max_fill / capacity)\nend",
  "    local n = #grid\n    local m = #grid[1]\n    local result = 0\n    for i =\
    \ 1, n do\n        local row = grid[i]\n        local max_fill = 0\n        for\
    \ j = 1, m do\n            if row[j] == 1 then\n                max_fill = max_fill\
    \ + 1\n            else\n                if max_fill > 0 then\n              \
    \      local fill = math.floor(max_fill / capacity)\n                    if max_fill\
    \ % capacity > 0 then\n                        fill = fill + 1\n             \
    \       end\n                    result = result + fill\n                    max_fill\
    \ = 0\n                end\n            end\n        end\n        if max_fill\
    \ > 0 then\n            local fill = math.floor(max_fill / capacity)\n       \
    \     if max_fill % capacity > 0 then\n                fill = fill + 1\n     \
    \       end\n            result = result + fill\n        end\n    end\n    return\
    \ result\nend", "    local rows = #grid\n    local cols = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, rows do\n        local fill = 0\n        for j\
    \ = 1, cols do\n            fill = fill + grid[i][j]\n        end\n        max_fill\
    \ = math.max(max_fill, fill)\n    end\n    return max_fill\nend", "    local n\
    \ = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n\
    \        for j = 1, m do\n            if grid[i][j] == 1 then\n              \
    \  max_fill = max_fill + 1\n            end\n        end\n    end\n    local min_fill\
    \ = math.ceil(max_fill / capacity)\n    return min_fill\nend", "    local n =\
    \ #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n\
    \        for j = 1, m do\n            if grid[i][j] == 1 then\n              \
    \  max_fill = max_fill + 1\n            end\n        end\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n    local cols\
    \ = #grid[1]\n    local max_fill = 0\n    for i = 1, rows do\n        local fill\
    \ = 0\n        for j = 1, cols do\n            fill = fill + grid[i][j]\n    \
    \    end\n        max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
