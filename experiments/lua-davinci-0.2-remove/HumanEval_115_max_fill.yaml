name: HumanEval_115_max_fill
language: lua
prompt: "-- You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n-- and each 1 in a row represents a single unit of water.\n-- Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n-- and\
  \ all buckets have the same capacity.\n-- Your task is to use the buckets to empty\
  \ the wells.\n-- Output the number of times you need to lower the buckets.\n-- Example\
  \ 1:\n-- Example 2:\n-- Example 3:\n-- Constraints:\n-- * all wells have the same\
  \ length\n-- * 1 <= grid.length <= 10^2\n-- * 1 <= grid[:,1].length <= 10^2\n--\
  \ * grid[i][j] -> 0 | 1\n-- * 1 <= capacity <= 10\nlocal function max_fill(grid,\
  \ capacity)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = max_fill\n\
  \    lu.assertEquals(candidate({{0, 0, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}}, 1), 6)\n\
  \    lu.assertEquals(candidate({{0, 0, 1, 1}, {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 1,\
  \ 1, 1}}, 2), 5)\n    lu.assertEquals(candidate({{0, 0, 0}, {0, 0, 0}}, 5), 0)\n\
  \    lu.assertEquals(candidate({{1, 1, 1, 1}, {1, 1, 1, 1}}, 2), 4)\n    lu.assertEquals(candidate({{1,\
  \ 1, 1, 1}, {1, 1, 1, 1}}, 9), 2)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n\
    \    for i = 1, n do\n        local fill = 0\n        for j = 1, m do\n      \
    \      fill = fill + grid[i][j]\n        end\n        max_fill = math.max(max_fill,\
    \ fill)\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n\
    \ do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n         \
    \       max_fill = max_fill + 1\n            end\n        end\n    end\n    return\
    \ math.ceil(max_fill / capacity)\nend", "    local rows = #grid\n    local cols\
    \ = #grid[1]\n    local fill = 0\n    for i = 1, rows do\n        local row_fill\
    \ = 0\n        for j = 1, cols do\n            if grid[i][j] == 1 then\n     \
    \           row_fill = row_fill + 1\n            end\n        end\n        fill\
    \ = math.max(fill, row_fill)\n    end\n    return math.ceil(fill / capacity)\n\
    end", "    local n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n \
    \   for i = 1, n do\n        for j = 1, m do\n            if grid[i][j] == 1 then\n\
    \                max_fill = max_fill + 1\n            end\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local n = #grid\n    local\
    \ m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n        local fill\
    \ = 0\n        for j = 1, m do\n            fill = fill + grid[i][j]\n       \
    \ end\n        max_fill = math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local max_fill\
    \ = 0\n    for i = 1, #grid do\n        local fill = 0\n        for j = 1, #grid[i]\
    \ do\n            fill = fill + grid[i][j]\n        end\n        if fill > max_fill\
    \ then\n            max_fill = fill\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local max_fill = 0\n    for i = 1, #grid do\n      \
    \  local row = grid[i]\n        local fill = 0\n        for j = 1, #row do\n \
    \           local cell = row[j]\n            if cell == 1 then\n             \
    \   fill = fill + 1\n            else\n                if fill > 0 then\n    \
    \                max_fill = max_fill + math.ceil(fill / capacity)\n          \
    \          fill = 0\n                end\n            end\n        end\n     \
    \   if fill > 0 then\n            max_fill = max_fill + math.ceil(fill / capacity)\n\
    \        end\n    end\n    return max_fill\nend", "    local n = #grid\n    local\
    \ m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n        for j = 1,\
    \ m do\n            if grid[i][j] == 1 then\n                max_fill = max_fill\
    \ + 1\n            end\n        end\n    end\n    return math.ceil(max_fill /\
    \ capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill_row\
    \ = {}\n    for i = 1, n do\n        local max_fill_col = 0\n        for j = 1,\
    \ m do\n            if grid[i][j] == 1 then\n                max_fill_col = max_fill_col\
    \ + 1\n            else\n                max_fill_col = 0\n            end\n \
    \           max_fill_row[j] = math.max(max_fill_row[j] or 0, max_fill_col)\n \
    \       end\n    end\n    local max_fill_col = {}\n    for j = 1, m do\n     \
    \   local max_fill_row = 0\n        for i = 1, n do\n            if grid[i][j]\
    \ == 1 then\n                max_fill_row = max_fill_row + 1\n            else\n\
    \                max_fill_row = 0\n            end\n            max_fill_col[i]\
    \ = math.max(max_fill_col[i] or 0, max_fill_row)\n        end\n    end\n    local\
    \ max_fill = 0\n    for i = 1, n do\n        for j = 1, m do\n            local\
    \ max_fill_ij = math.min(max_fill_row[j], max_fill_col[i])\n            if grid[i][j]\
    \ == 1 then\n                max_fill_ij = max_fill_ij - 1\n            end\n\
    \            max_fill = math.max(max_fill, max_fill_ij)\n        end\n    end\n\
    \    return math.ceil(max_fill / capacity)\nend", "    local max_fill = 0\n  \
    \  for _, row in ipairs(grid) do\n        local fill = 0\n        for _, well\
    \ in ipairs(row) do\n            fill = fill + well\n            if fill > capacity\
    \ then\n                max_fill = max_fill + 1\n                fill = 0\n  \
    \          end\n        end\n        if fill > 0 then\n            max_fill =\
    \ max_fill + 1\n        end\n    end\n    return max_fill\nend", "    local n\
    \ = #grid\n    local m = #grid[1]\n    local res = 0\n    for i = 1, n do\n  \
    \      for j = 1, m do\n            if grid[i][j] == 1 then\n                res\
    \ = res + 1\n            end\n        end\n    end\n    return math.ceil(res /\
    \ capacity)\nend", "    local max_fill = 0\n    for i = 1, #grid do\n        local\
    \ fill = 0\n        for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n\
    \        end\n        if fill > max_fill then\n            max_fill = fill\n \
    \       end\n    end\n    return math.ceil(max_fill / capacity)\nend", "    local\
    \ n = #grid\n    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n\
    \ do\n        local fill = 0\n        for j = 1, m do\n            fill = fill\
    \ + grid[i][j]\n        end\n        max_fill = math.max(max_fill, fill)\n   \
    \ end\n    return math.ceil(max_fill / capacity)\nend", "    local n = #grid\n\
    \    local m = #grid[1]\n    local max_fill = 0\n    for i = 1, n do\n       \
    \ for j = 1, m do\n            if grid[i][j] == 1 then\n                max_fill\
    \ = max_fill + 1\n            end\n        end\n    end\n    return math.ceil(max_fill\
    \ / capacity)\nend", "    local n = #grid\n    local m = #grid[1]\n    local max_fill\
    \ = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    local min_fill = math.floor(max_fill / capacity)\n    if\
    \ max_fill % capacity ~= 0 then\n        min_fill = min_fill + 1\n    end\n  \
    \  return min_fill\nend", "    local n = #grid\n    local m = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, n do\n        for j = 1, m do\n            if grid[i][j]\
    \ == 1 then\n                max_fill = max_fill + 1\n            end\n      \
    \  end\n    end\n    local min_fill = math.floor(max_fill / capacity)\n    if\
    \ max_fill % capacity ~= 0 then\n        min_fill = min_fill + 1\n    end\n  \
    \  return min_fill\nend", "    local n = #grid\n    local m = #grid[1]\n    local\
    \ max_fill = 0\n    for i = 1, n do\n        local fill = 0\n        for j = 1,\
    \ m do\n            fill = fill + grid[i][j]\n        end\n        max_fill =\
    \ math.max(max_fill, fill)\n    end\n    return math.ceil(max_fill / capacity)\n\
    end", "    local max_fill = 0\n    for i = 1, #grid do\n        local fill = 0\n\
    \        for j = 1, #grid[i] do\n            fill = fill + grid[i][j]\n      \
    \  end\n        if fill > max_fill then\n            max_fill = fill\n       \
    \ end\n    end\n    return max_fill\nend", "    local max_fill = 0\n    for i=1,#grid\
    \ do\n        local fill = 0\n        for j=1,#grid[i] do\n            fill =\
    \ fill + grid[i][j]\n        end\n        if fill > max_fill then\n          \
    \  max_fill = fill\n        end\n    end\n    return math.ceil(max_fill / capacity)\n\
    end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
