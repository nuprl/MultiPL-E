name: HumanEval_99_closest_integer
language: r
prompt: "# Create a function that takes a value (string) representing a number\n#\
  \ and returns the closest integer to it. If the number is equidistant\n# from two\
  \ integers, round it away from zero.\n# Examples\n# >>> closest_integer('10')\n\
  # 10\n# >>> closest_integer('15.3')\n# 15\n# Note:\n# Rounding away from zero means\
  \ that if the given number is equidistant\n# from two integers, the one you should\
  \ return is the one that is the\n# farthest from zero. For example closest_integer(\"\
  14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\n\
  closest_integer <- function(value) {"
tests: "test_humaneval <- function() {\ncandidate <- closest_integer\n    if(!identical(candidate('10'),\
  \ 10)){quit('no', 1)}\n    if(!identical(candidate('14.5'), 15)){quit('no', 1)}\n\
  \    if(!identical(candidate('-15.5'), -16)){quit('no', 1)}\n    if(!identical(candidate('15.3'),\
  \ 15)){quit('no', 1)}\n    if(!identical(candidate('0'), 0)){quit('no', 1)}\n}\n\
  test_humaneval()"
completions: ["\n  if (substr(value, nchar(value), nchar(value)) > 4) {\n    return(as.integer(value)+1)\n\
    \  } else {\n    return(as.integer(value))\n  }\n}\n", "\n    # ... your code\
    \ here ...\n}\nlibrary(testthat)\ntest_that(\"Testing closest_integer\", {\n \
    \   expect_equal(closest_integer(\"10\"), 10)\n    expect_equal(closest_integer(\"\
    15.3\"), 15)\n    expect_equal(closest_integer(\"14.5\"), 15)\n    expect_equal(closest_integer(\"\
    -14.5\"), -15)\n})\n \n ", "\n    value <- as.integer(value)\n    return(value)\n\
    }\nclosest_integer('10')\n", "\n  # value to number\n  value <- as.numeric(value)\n\
    \  # checking if value is integer,\n  # if it is just return it\n  if (value ==\
    \ as.integer(value)) {\n    return(value)\n  }\n  # if not, return the closest\
    \ integer\n  else {\n    # checking if the value is positive\n    if (value >\
    \ 0) {\n      # if it is, return the floor value\n      return(floor(value))\n\
    \    }\n    # but if it is negative, return the ceiling value\n    else {\n  \
    \    return(ceiling(value))\n    }\n  }\n}", "\n    if (is.character(value)) {\n\
    \        value <- as.numeric(value)\n    }\n    if (is.numeric(value)) {\n   \
    \     value <- round(value)\n    }\n    if (is.integer(value)) {\n        value\
    \ <- value\n    }\n    return(value)\n}\n\nclosest_integer(\"10\")\n", "\n  if\
    \ (value > 0) {\n    return(floor(value))\n  } else {\n    return(ceiling(value))\n\
    \  }\n}\n", "\n    # your code here\n    return(NA)\n}\n ", "\n  return( round(as.numeric(value))\
    \ )\n}\nclosest_integer('10')\nclosest_integer('15.3')", "\n  # your code here\n\
    \  as.integer(value)\n}", "\n  # Convert the string to a numeric type.\n  number\
    \ <- as.numeric(value)\n  # Round the number using the round function.\n  round(number)\n\
    }", "\n  value <- as.numeric(value)\n  if(value%%1 > 0.5) {\n    return(value\
    \ %/% 1 + 1)\n  } else {\n    return(value %/% 1)\n  }\n}\n\nclosest_integer(\"\
    15.3\")\nclosest_integer(\"10\")\nclosest_integer(\"-14.5\")\n", "\n  # split\
    \ the number into digits\n  digits <- strsplit(value, \"\")[[1]]\n  result <-\
    \ c()\n  # if there is no decimal point in the number, just return the number\n\
    \  if (!grepl(\"\\\\.\", value)) {\n    return(as.integer(value))\n  }\n  # search\
    \ for the decimal point and remove the fractional part\n  for (digit in digits)\
    \ {\n    if (digit == \".\") {\n      break\n    }\n    result <- c(result, digit)\n\
    \  }\n  # check to see if the number is greater than 5\n  if (as.integer(result[length(result)])\
    \ >= 5) {\n    result[length(result)] <- result[length(result)] + 1\n  }\n  as.integer(paste(result,\
    \ collapse = \"\"))\n}\n", "\n    if (value - floor(value) > 0.5) {\n        return(ceiling(value))\n\
    \    } else {\n        return(floor(value))\n    }\n}\n", "\n  # Generate the\
    \ two choices, then use the ternary operator to select the\n  # one that is farther\
    \ from zero.\n  c <- ceiling(as.numeric(value))\n  f <- floor(as.numeric(value))\n\
    \  c - f > 1 ? f : c\n}\n", "\n  value <- as.integer(value)\n\n  if(value %% 1\
    \ == 0) {\n    return(value)\n  } else {\n    return(value + 0.5)\n  }\n}\n\n\
    closest_integer('10')\nclosest_integer('15.3')\n", "\n  as.integer(round(as.numeric(value),\
    \ digits = 0))\n}\n", "\n  value_number <- as.numeric(value)\n  cat(value_number,\
    \ \"\\n\")\n  up_to_integer <- ceiling(value_number)\n  less_to_integer <- floor(value_number)\n\
    \  if (value_number - less_to_integer > up_to_integer - value_number) {\n    return(up_to_integer)\n\
    \  } else {\n    return(less_to_integer)\n  }\n}\n\ncat(closest_integer(\"14.5\"\
    ), \"\\n\")\ncat(closest_integer(\"-14.5\"), \"\\n\")\n", "\n  x <- as.numeric(value)\n\
    \  x_round <- round(x)\n  x_ceiling <- ceiling(x)\n  x_floor <- floor(x)\n  if(abs(x\
    \ - x_round) == abs(x - x_ceiling)) {\n    if(abs(x_ceiling) >= abs(x_round))\
    \ {\n      x_ceiling\n    } else {\n      x_round\n    }\n  } else if(abs(x -\
    \ x_round) == abs(x - x_floor)) {\n    if(abs(x_floor) >= abs(x_round)) {\n  \
    \    x_floor\n    } else {\n      x_round\n    }\n  } else if(abs(x - x_round)\
    \ < abs(x - x_ceiling)) {\n    x_round\n  } else if(abs(x - x_round) < abs(x -\
    \ x_floor)) {\n    x_round\n  } else if(abs(x - x_ceiling) < abs(x - x_round))\
    \ {\n    x_ceiling\n  } else if(abs(x - x_floor) < abs(x - x_round)) {\n    x_floor\n\
    \  }\n}", "\n    # check that value is numeric\n    if (!is.numeric(value)) {\n\
    \        stop(\"Value must be numeric\")\n    }\n\n    # check that number is\
    \ not a fraction\n    # if it is a fraction round it to the closest integer\n\
    \    if (fround(value) != value) {\n        value <- fround(value)\n    }\n\n\
    \    # create a list of integers close to the number\n    if (value > 0) {\n \
    \       list <- c(value-1, value, value+1)\n    } else {\n        list <- c(value-1,\
    \ value, value+1)\n    }\n\n    # check which integer is closest to the number\n\
    \    # round it and return it\n    if (abs(value - list[1]) <= abs(value - list[2]))\
    \ {\n        return(fround(list[1]))\n    } else {\n        return(fround(list[3]))\n\
    \    }\n}", "\n  int_val <- as.integer(value)\n  float_val <- as.double(value)\n\
    \  float_val - int_val > 0.5 ? int_val + 1 : int_val\n}\n \nclosest_integer('10')\n"]
stop_tokens:
- "\n#"
- "\n```"
