name: HumanEval_9_rolling_max
language: r
prompt: "# From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n# in the sequence.\n# >>> rolling_max(c(1, 2, 3, 2,\
  \ 3, 4, 2))\n# c(1, 2, 3, 3, 3, 4, 4)\nrolling_max <- function(numbers) {"
tests: "test_humaneval <- function() {\ncandidate <- rolling_max\n    if(!identical(candidate(c()),\
  \ c())){quit('no', 1)}\n    if(!identical(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(4, 3, 2, 1)), c(4, 4, 4, 4))){quit('no', 1)}\n\
  \    if(!identical(candidate(c(3, 2, 3, 100, 3)), c(3, 3, 3, 100, 100))){quit('no',\
  \ 1)}\n}\ntest_humaneval()"
completions: ["\n  res <- numeric(length(numbers))\n  for (i in seq_along(numbers))\
    \ {\n    res[i] <- max(numbers[1:i])\n  }\n  res\n}\n\nrolling_max(c(1, 2, 3,\
    \ 2, 3, 4, 2))\n", "\n    max_value <- NULL\n    for (i in 1:length(numbers))\
    \ {\n        number <- numbers[i]\n        if (is.null(max_value)) {\n       \
    \     max_value <- number\n        } else {\n            max_value <- c(max_value,\
    \ max(max_value[i - 1], number))\n        }\n    }\n    return(max_value)\n}\n",
  "\n  numbers[cumsum(numbers > shift(numbers, -1, fill = 0, type = \"lead\"))]\n\
    }\n", "\n  res <- vector(mode = \"integer\", length = length(numbers))\n  res[1]\
    \ <- numbers[1]\n  for (i in 2:length(numbers)) {\n    res[i] <- max(res[i - 1],\
    \ numbers[i])\n  }\n  return(res)\n}\n", "\n  unlist(lapply(\n    1:length(numbers),\n\
    \    function(i) {\n      max(numbers[1:i])\n    }\n  ))\n}\n", "\n   # Input:\
    \ numbers - a vector of integer numbers\n   # Output: a vector of integers - a\
    \ sliding maximum\n   n <- length(numbers)\n   max <- numbers[1]\n   sliding_max\
    \ <- numeric(n)\n   for (i in seq_along(numbers)) {\n     if (max < numbers[i])\
    \ {\n        max <- numbers[i]\n     }\n     sliding_max[i] <- max\n   }\n   return(sliding_max)\n\
    }\n", "\n    numbers <- as.integer(numbers)\n    maxes <- rep(0, length(numbers))\n\
    \    current_max <- numbers[1]\n    for (i in 1:length(numbers)) {\n        if\
    \ (numbers[i] > current_max) {\n            current_max <- numbers[i]\n      \
    \  }\n        maxes[i] <- current_max\n    }\n    return(maxes)\n}\n", "\n  numbers\
    \ <- unlist(numbers)\n\n  lapply(1:length(numbers), function(x) {\n    max(numbers[1:x])\n\
    \  })\n}\n", "\n  # Write your code here!\n  first_max <- numbers[1]\n  l <- length(numbers)\n\
    \  rolling_max <- c()\n  for (i in 1:l) {\n    if (numbers[i] > first_max) {\n\
    \      first_max <- numbers[i]\n    }\n    rolling_max <- c(rolling_max, first_max)\n\
    \  }\n  return(rolling_max)\n}\nc(1, 2, 3, 2, 3, 4, 2) %>% \n  rolling_max()\n\
    \ ", "\n  result <- c()\n  current_max <- -Inf\n  for (number in numbers) {\n\
    \    if (number > current_max) {\n      current_max <- number\n    }\n    result\
    \ <- c(result, current_max)\n  }\n  return(result)\n}\n", "\n  rolling_max_list\
    \ <- c()\n  rolling_max <- numbers[1]\n  rolling_max_list <- c(rolling_max_list,\
    \ rolling_max)\n  for (i in 2:length(numbers)) {\n    if (numbers[i] > rolling_max)\
    \ {\n      rolling_max <- numbers[i]\n    }\n    rolling_max_list <- c(rolling_max_list,\
    \ rolling_max)\n  }\n  return(rolling_max_list)\n}\n", "\n  current_max <- NULL\n\
    \  for (number in numbers) {\n    if (is.null(current_max) || number > current_max)\
    \ {\n      current_max <- number\n    }\n    print(current_max)\n  }\n}\n\nprint(rolling_max(c(1,\
    \ 2, 3, 2, 3, 4, 2)))", "\n  rolling_max <- numeric(length(numbers))\n  max_so_far\
    \ <- 0\n  i <- 1\n  for (number in numbers) {\n    if (number > max_so_far) {\n\
    \      max_so_far <- number\n    }\n    rolling_max[i] <- max_so_far\n    i <-\
    \ i + 1\n  }\n  return(rolling_max)\n}\n", "\n  maximum <- numeric(length(numbers))\n\
    \  maximum[1] <- numbers[1]\n  for (i in 2:length(numbers)) {\n    maximum[i]\
    \ <- max(maximum[i-1], numbers[i])\n  }\n  return(maximum)\n}\n", "\n  max <-\
    \ numbers[1]\n  result <- c()\n  for (i in seq_along(numbers)) {\n    if (numbers[i]\
    \ > max) {\n      max <- numbers[i]\n    }\n    result <- c(result, max)\n  }\n\
    \  return(result)\n}\n\nsimple_rolling_max <- function(numbers) {\n  result <-\
    \ c()\n  for (i in seq_along(numbers)) {\n    result <- c(result, max(numbers[1:i]))\n\
    \  }\n  return(result)\n}\n\nkendall_tau <- function(x, y) {\n  x <- as.numeric(x)\n\
    \  y <- as.numeric(y)\n  z <- y[x]\n  z <- sort(z)\n  zz <- sort(y)\n  n <- length(z)\n\
    \  zz.index <- match(z, zz)\n  zz.index <- zz.index[order(zz.index)]\n  zz.index\
    \ <- zz.index - 1\n  zz.index <- zz.index[order(zz.index)]\n  c <- sum(zz.index\
    \ - c(0, cumsum(zz.index)[-n]))\n  return(c)\n}\n", "\n  max <- 0\n  for (number\
    \ in numbers) {\n    if (number > max) {\n      max <- number\n    }\n    print(max)\n\
    \  }\n}\n\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  lapply(1:length(numbers),\
    \ function(i) {\n    numbers[i:length(numbers)]\n  }) %>% lapply(max)\n}\n", "\n\
    \    max <- numbers[1]\n    result <- vector(\"integer\", length = length(numbers))\n\
    \    result[1] <- max\n    for (index in 2:length(numbers)) {\n        if (numbers[index]\
    \ > max) {\n            max <- numbers[index]\n        }\n        result[index]\
    \ <- max\n    }\n    return(result)\n}\n", "\n    if (length(numbers) == 0) return(vector())\n\
    \    if (length(numbers) == 1) return(numbers)\n    c(numbers[1], rolling_max(cummax(numbers[-1])))\n\
    }\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  numbers <- unlist(numbers)\n \
    \ state <- vector(\"list\", length = length(numbers))\n  state[[1]] <- numbers[1]\n\
    \  for (i in seq(2, length(numbers))) {\n    state[[i]] <- max(state[[i - 1]],\
    \ numbers[i])\n  }\n  state\n}\n", "\n    max <- numbers[1]\n    res <- list()\n\
    \    for (i in numbers) {\n        if (i > max) {\n            max <- i\n    \
    \    }\n        res <- c(res, max)\n    }\n    res\n}\n", "\n  r <- numbers[1]\n\
    \  for (i in 2:length(numbers)) {\n    r <- c(r, max(r[i-1], numbers[i]))\n  }\n\
    \  return(r)\n}\nrolling_max <- function(numbers) {\n  r <- numbers[1]\n  for\
    \ (i in 2:length(numbers)) {\n    r <- c(r, max(r[i-1], numbers[i]))\n  }\n  return(r)\n\
    }\nv = c(1, 2, 3, 2, 3, 4, 2)\nrolling_max(v)\n\ndef rolling_max(numbers):\n \
    \   r = [numbers[0]]\n    for i in range(1, len(numbers)):\n        r.append(max(r[i-1],\
    \ numbers[i]))\n    return r\nrolling_max(v)\n\na = np.array(v)\nr = np.maximum.accumulate(a)\n\
    r\n", "\n    maximum <- 0\n    output <- numeric(length(numbers))\n    for (i\
    \ in seq_along(numbers)) {\n        current <- numbers[i]\n        maximum <-\
    \ max(maximum, current)\n        output[i] <- maximum\n    }\n    return(output)\n\
    }\n\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  # this is inefficient, but good\
    \ enough for the purpose of the exercise\n  rolling_max <- rep(NA, length(numbers))\n\
    \  rolling_max[1] <- numbers[1]\n  for (i in seq(2, length(numbers))) {\n    rolling_max[i]\
    \ <- max(rolling_max[i - 1], numbers[i])\n  }\n  return(rolling_max)\n}", "\n\
    \    cumsum(max(numbers, na.rm = TRUE))\n}\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n",
  "\n  result <- numeric(length(numbers))\n  current_max <- numbers[1]\n  result[1]\
    \ <- current_max\n  for (i in 2:length(numbers)) {\n    current_max <- max(current_max,\
    \ numbers[i])\n    result[i] <- current_max\n  }\n  return(result)\n}\n", "\n\
    \  vapply(seq_along(numbers), function(i) max(numbers[1:i]), numeric(1))\n}\n",
  "\n    max_until_now <- NULL\n    for (current_number in numbers) {\n        max_until_now\
    \ <- c(max_until_now, ifelse(is.null(max_until_now), current_number, max(current_number,\
    \ max_until_now[length(max_until_now)])))\n    }\n    return(max_until_now)\n\
    }\n", "\n    last_max <- 0\n    sapply(numbers, function(n) {\n        if (n >\
    \ last_max) {\n            last_max <<- n\n        }\n        last_max\n    })\n\
    }\n", "\n  answer <- rep(NA, length(numbers))\n  answer[1] <- numbers[1]\n  for\
    \ (i in 2:length(numbers)) {\n    answer[i] <- max(answer[i-1], numbers[i])\n\
    \  }\n  return(answer)\n}\n", "\n  result <- numeric(length(numbers))\n  max <-\
    \ numbers[1]\n  result[1] <- max\n  for (i in 2:length(numbers)) {\n    result[i]\
    \ <- max\n    if (numbers[i] > max) {\n      max <- numbers[i]\n    }\n  }\n \
    \ return(result)\n}\n", "\n  # ... TODO\n}\n", "\n  if (length(numbers) < 1) {\n\
    \    stop(\"'numbers' must not be empty!\")\n  }\n\n  result <- c()\n  curr_max\
    \ <- numbers[1]\n  result <- c(result, curr_max)\n\n  for (i in 2:length(numbers))\
    \ {\n    if (numbers[i] > curr_max) {\n      curr_max <- numbers[i]\n    }\n \
    \   result <- c(result, curr_max)\n  }\n\n  return(result)\n}\n", "\n  result\
    \ <- c()\n  for (i in 1:length(numbers)) {\n    result <- c(result, max(numbers[1:i]))\n\
    \  }\n  return(result)\n}\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  sapply(seq_along(numbers),\
    \ function(i) max(numbers[1:i]))\n}\n", "\n    acc <- list()\n    acc[1] <- numbers[1]\n\
    \    for (i in 2:length(numbers)) {\n        acc[i] <- max(numbers[i], acc[i-1])\n\
    \    }\n    acc\n}\n", "\n  cumsum <- cumsum(numbers)\n  prev_max <- -Inf\n  for\
    \ (i in 1:length(cumsum)) {\n    cumsum[i] <- max(cumsum[i], prev_max)\n    prev_max\
    \ <- cumsum[i]\n  }\n  cumsum\n}\n", "\n  numbers <- numbers[is.na(numbers) ==\
    \ FALSE]\n  accumulator <- numbers[1]\n  result <- c()\n  for (value in numbers)\
    \ {\n    accumulator <- max(accumulator, value)\n    result <- c(result, accumulator)\n\
    \  }\n  return(result)\n}\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  numbers.reverse\
    \ <- rev(numbers)\n  cumsum(numbers.reverse)\n}", "\n  roll <- list()\n  for (i\
    \ in seq_along(numbers)) {\n    roll[[i]] <- max(numbers[1:i])\n  }\n  return(unlist(roll))\n\
    }\n", "\n  lapply(seq_along(numbers), function(idx) {\n    max(numbers[1:idx])\n\
    \  })\n}\n", "\n  max <- numbers[1]\n  lapply(numbers, function(x) {\n    if (x\
    \ > max) max <- x\n    max\n  })\n}\n", "\n  res <- c()\n  for (i in 1:length(numbers))\
    \ {\n    new_max <- max(numbers[1:i])\n    res <- c(res, new_max)\n  }\n  return(res)\n\
    }\n\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n\nrolling_max <- function(numbers) {\n\
    \  res <- c()\n  last_max <- numbers[1]\n  for (i in 1:length(numbers)) {\n  \
    \  new_max <- max(last_max, numbers[i])\n    res <- c(res, new_max)\n    last_max\
    \ <- new_max\n  }\n  return(res)\n}\n\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n",
  "\n  if (length(numbers) == 0) {\n    return (numeric())\n  }\n  vector <- numeric(length(numbers))\n\
    \  vector[1] <- numbers[1]\n  for (i in 2:length(numbers)) {\n    vector[i] <-\
    \ max(vector[i - 1], numbers[i])\n  }\n  return (vector)\n}\n", "\n  cummax(numbers)\n\
    }\n", "\n    # ...TODO...\n}\n", "\n  if(is.null(numbers)) return()\n  if(length(numbers)\
    \ == 1) return(numbers)\n  max(numbers[1], rolling_max(numbers[-1]))\n}\nrolling_max_list\
    \ <- function(numbers) {\n  if(is.null(numbers)) return()\n  if(length(numbers)\
    \ == 1) return(numbers)\n  c(rolling_max(numbers), rolling_max_list(numbers[-1]))\n\
    }\n", "\n  cumsum <- cumsum(numbers)\n  roll_max <- unlist(\n    sapply(\n   \
    \   1:length(numbers),\n      function(i) {\n        max(\n          numbers[(cumsum[i]\
    \ - numbers[i] + 1):i]\n        )\n      }\n    )\n  )\n  roll_max\n}", "\n  result\
    \ <- c()\n  n <- length(numbers)\n  for (i in 1:n) {\n    result <- c(result,\
    \ max(numbers[1:i]))\n  }\n  return(result)\n}\n\nrolling_max(c(1, 2, 3, 2, 3,\
    \ 4, 2))\n", "\n  stopifnot(is.vector(numbers))\n  stopifnot(all(is.numeric(numbers)))\n\
    \  rolling_max <- numeric(length(numbers))\n  current_max <- numbers[1]\n  rolling_max[1]\
    \ <- current_max\n  for (i in 2:length(numbers)) {\n    if (numbers[i] > current_max)\
    \ {\n      current_max <- numbers[i]\n    }\n    rolling_max[i] <- current_max\n\
    \  }\n  return(rolling_max)\n}\n", "\n  max <- numbers[1]\n  roll_max <- numeric(length(numbers))\n\
    \  roll_max[1] <- max\n  for (i in 2:length(numbers)) {\n    max <- max(max, numbers[i])\n\
    \    roll_max[i] <- max\n  }\n  return(roll_max)\n}\nrolling_max_vec <- Vectorize(rolling_max)\n",
  "\n    if (length(numbers) == 0) {\n        return(numeric(0))\n    } else {\n \
    \       return(c(head(numbers, 1), rollmax(tail(numbers, -1), head(numbers, 1))))\n\
    \    }\n}", "\n  cumsum <- c()\n  max <- 0\n  for (number in numbers) {\n    if\
    \ (number > max) {\n      max <- number\n    }\n    cumsum <- c(cumsum, max)\n\
    \  }\n  return(cumsum)\n}\nrolling_max(numbers)\n", "\n  n <- length(numbers)\n\
    \  rolling_max <- NULL\n  for (i in 1:n) {\n    rolling_max <- c(rolling_max,\
    \ max(numbers[1:i]))\n  }\n  return(rolling_max)\n}\n", "\n  result <- c()\n \
    \ for (number in numbers) {\n    result <- c(result, max(result, number))\n  }\n\
    \  return(result)\n}\n", "\n  cumsum <- cumsum(numbers)\n  cummax <- cummax(numbers)\n\
    \  c(cummax[1], cummax[-1] - cumsum[-1])\n}", "\n    result <- rep(NA, length(numbers))\n\
    \    current_max <- -Inf\n    for (i in seq_along(numbers)) {\n        current_max\
    \ <- max(current_max, numbers[i])\n        result[i] <- current_max\n    }\n \
    \   return(result)\n}\n ", "\n    # YOUR CODE HERE\n    # Please use the rpy2\
    \ library to access R within Python\n    # - perform your solution in R and return\
    \ the result\n    # - do not install additional R packages\n    # - you may use\
    \ whatever datastructures you find suitable\n    # - don't use for loops\n\n \
    \   # THIS IS WRONG\n    # return numbers\n\n    import rpy2.robjects as robjects\n\
    \    from rpy2.robjects import r, pandas2ri\n\n    # Convert Python list to R\
    \ vector\n    r_list = robjects.IntVector(numbers)\n\n    # Return R vector to\
    \ Python\n    python_list = list(r_list)\n\n    return python_list\n\n    #c =\
    \ robjects.r['c']\n    #max = robjects.r['max']\n    #roll_max = robjects.r['roll_max']\n\
    \n    #r_list = c(r_list)\n    #rolling_max = max(r_list)\n    #return r_list\n\
    \n", "\n  result <- c()\n  max_value <- 0\n  for (number in numbers) {\n    max_value\
    \ <- max(max_value, number)\n    result <- c(result, max_value)\n  }\n  return(result)\n\
    }\n ", "\n  vapply(seq_along(numbers),\n         function(i) {\n           max(numbers[1:i])\n\
    \         },\n         1L)\n}\n", "\n  rolling_max_helper(numbers, c(numbers[1]))\n\
    }\n\nrolling_max_helper <- function(numbers, maxes) {\n  if (length(numbers) ==\
    \ 1) {\n    return(maxes)\n  }\n  rolling_max_helper(tail(numbers, -1), c(maxes,\
    \ max(numbers[1], maxes[length(maxes)])))\n}\n", "\n    cumsum <- c()\n    for\
    \ (number in numbers) {\n        cumsum <- c(cumsum, max(number, if (length(cumsum)\
    \ > 0) cumsum[length(cumsum)] else number))\n    }\n    return(cumsum)\n}", "\n\
    \    print(numbers)\n    n <- length(numbers)\n    maximum <- c()\n    current_max\
    \ <- -1\n    for (i in 1:n) {\n        current_max <- max(current_max, numbers[i])\n\
    \        maximum <- c(maximum, current_max)\n    }\n    maximum\n}\n\nrolling_max(c(1,\
    \ 2, 3, 2, 3, 4, 2))\n", "\n  c(\n    cumsum(numbers),\n    0\n  )[1:length(numbers)]\n\
    }\n", "\n  res <- list()\n  for (idx in seq_along(numbers)) {\n    res[idx] <-\
    \ max(numbers[1:idx])\n  }\n  unlist(res)\n}\n", "\n  cumsum(numbers)\n}\n", "\n\
    \    nums <- as.vector(numbers)\n    roll_max <- c()\n    for (i in 1:length(nums))\
    \ {\n        roll_max <- c(roll_max, max(nums[seq(1, i)]))\n    }\n    return(roll_max)\n\
    }\n", "\n  # Compute first element\n  max <- numbers[1]\n  rolling_max <- c(max)\n\
    \  # Compute next elements\n  for (number in numbers[2:length(numbers)]) {\n \
    \   max <- ifelse(number > max, number, max)\n    rolling_max <- c(rolling_max,\
    \ max)\n  }\n  return(rolling_max)\n}\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n",
  "\n  list_max <- integer(length(numbers))\n  list_max[1] <- numbers[1]\n  for (i\
    \ in 2:length(numbers)) {\n    if (numbers[i] > list_max[i-1]) {\n      list_max[i]\
    \ <- numbers[i]\n    } else {\n      list_max[i] <- list_max[i-1]\n    }\n  }\n\
    \  return(list_max)\n}\n\nnumbers <- c(1, 2, 3, 2, 3, 4, 2)\nrolling_max(numbers)\n",
  "\n  #TODO\n}\n", "\n  numbers[cumsum(numbers > (c(0, numbers[-length(numbers)])))]\n\
    }\n", "\n  rolling_max <- rep(0, length(numbers))\n  for (i in 1:length(numbers))\
    \ {\n    num <- numbers[i]\n    if (i == 1) {\n      rolling_max[i] <- num\n \
    \   } else {\n      rolling_max[i] <- max(rolling_max[i - 1], num)\n    }\n  }\n\
    \  return(rolling_max)\n}\n", "\n  vector(\"list\", length(numbers))\n}\n", "\n\
    \    maxima <- c()\n    max <- 0\n    for (number in numbers) {\n        if (number\
    \ > max) {\n            max <- number\n        }\n        maxima <- c(maxima,\
    \ max)\n    }\n    return(maxima)\n}", "\n    res <- numeric(length(numbers))\n\
    \    current_max <- numeric(length(numbers))\n    current_max[1] <- numbers[1]\n\
    \    res[1] <- numbers[1]\n    for (i in 2:length(numbers)) {\n        if (numbers[i]\
    \ >= current_max[i-1]) {\n            current_max[i] <- numbers[i]\n        }\
    \ else {\n            current_max[i] <- current_max[i-1]\n        }\n        res[i]\
    \ <- current_max[i]\n    }\n    return(res)\n}\n", "\n    result <- vector()\n\
    \    max_number <- NULL\n    for (number in numbers) {\n        if (is.null(max_number)\
    \ || number > max_number) {\n            max_number <- number\n        }\n   \
    \     result <- c(result, max_number)\n    }\n    return(result)\n}\n\nrolling_max_list\
    \ <- function(numbers) {\n    result <- list()\n    max_number <- NULL\n    for\
    \ (number in numbers) {\n        if (is.null(max_number) || number > max_number)\
    \ {\n            max_number <- number\n        }\n        result <- append(result,\
    \ list(max_number))\n    }\n    return(result)\n}\n", "\n  m <- 0\n  lapply(numbers,\
    \ function(n) {\n    if (n > m) {\n      m <<- n\n    }\n    m\n  })\n}\n\nrolling_max(c(1,\
    \ 2, 3, 2, 3, 4, 2))", "\n  # To make vector of rolling max we need to use `Reduce`\
    \ function and `max` function on two inputs.\n  # `Reduce` takes an input vector,\
    \ an accumulator function, and an initial accumulator state.\n  # It will return\
    \ a vector of all accumulator states.\n  # `max` function has the following prototype:\
    \ max(x, y), where x and y are numbers.\n  # `Reduce` will take a vector and a\
    \ function as inputs.\n  # Then it applies the function to the first two elements\
    \ of the vector,\n  # updates the accumulator with the result,\n  # and repeats\
    \ the process for the rest of the elements.\n  # In our case, initial accumulator\
    \ state is the first element of the input vector.\n  # We will not modify accumulator\
    \ state and will simply return the result of max function.\n  Reduce(function(x,\
    \ y) max(x, y), numbers, numbers[1])\n}\n", "\n  return(replicate(length(numbers),\
    \ max(numbers[1:j])))\n}\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n    if (length(numbers)\
    \ <= 1) {\n        return(numbers)\n    } else {\n        return(c(numbers[1],\
    \ rolling_max(numbers[-1])[1:length(numbers[-1])]))\n    }\n}\nrolling_max(c(1,\
    \ 2, 3, 2, 3, 4, 2))\n", "\n  res <- numeric(length(numbers))\n  for (i in seq_along(numbers))\
    \ {\n    res[i] <- max(numbers[1:i])\n  }\n  res\n}\n", "\n  cumsum(as.numeric(numbers))\n\
    }\n", "\n  # Generate a sequence from 1 to number of numbers in the list.\n  seq\
    \ <- seq(1, length(numbers))\n  # Create a new vector. This is the result.\n \
    \ result <- c()\n  # For each element in the sequence, find max value up to this\
    \ moment.\n  for (i in seq) {\n    result[i] <- max(numbers[1:i])\n  }\n  # Return\
    \ the result.\n  return(result)\n}", "\n  cumsum <- c()\n  for (i in 1:length(numbers))\
    \ {\n    cumsum[i] <- max(numbers[1:i])\n  }\n  return(cumsum)\n}", "\n  cumsum(\n\
    \    numeric(length(numbers))\n  )\n}\n", "\n  # TODO: implement me\n  max(numbers)\n\
    }\n", "\n  max.sequence <- rep(0, length(numbers))\n  for (i in 1:length(numbers))\
    \ {\n    # calculate sum of the first i elements\n    if (i == 1) {\n      # on\
    \ the first iteration store the current number into the max.sequence\n      max.sequence[i]\
    \ <- numbers[i]\n    } else {\n      # on the subsequent iterations compare the\
    \ current number with the max.sequence[i-1] and\n      # store the maximum one\n\
    \      max.sequence[i] <- max(numbers[i], max.sequence[i-1])\n    }\n  }\n  return(max.sequence)\n\
    }\n", "\n    max <- numbers[1]\n    for (i in seq(2, length(numbers))) {\n   \
    \     if (numbers[i] > max) {\n            max <- numbers[i]\n        }\n    \
    \    numbers[i] <- max\n    }\n    return(numbers)\n}\n", "\n  cummax(numbers)\n\
    }\n", "\n    l <- length(numbers)\n    result <- c()\n    for (i in seq(l)) {\n\
    \        result <- c(result, max(numbers[1:i]))\n    }\n    return(result)\n}\n",
  "\n  sapply(seq_along(numbers), function(i) {\n    if (i == 1) {\n      numbers[i]\n\
    \    } else {\n      max(numbers[1:i])\n    }\n  })\n}\n", "\n    last_max <-\
    \ 0\n    map(numbers, function(number) {\n        if (number > last_max) {\n \
    \           last_max <- number\n        }\n        last_max\n    })\n}\n", "\n\
    \  if (length(numbers) == 0) {\n    return(NULL)\n  } else {\n    return(c(numbers[1],\
    \ rolling_max(numbers[-1]) + (numbers[1] >= head(rolling_max(numbers[-1]), n=1))))\n\
    \  }\n}\n", "\n  if(length(numbers) == 0) {\n    return(numeric(0))\n  }\n  if(length(numbers)\
    \ == 1) {\n    return(numbers)\n  }\n  return(c(numbers[1], rolling_max(numbers[-1])[1],\
    \ rolling_max(numbers[-1])[-1]))\n}\n\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n",
  "\n  rolling_max <- numeric(length(numbers))\n  rolling_max[1] <- numbers[1]\n \
    \ for (i in 2:length(numbers)) {\n    rolling_max[i] <- max(rolling_max[i-1],\
    \ numbers[i])\n  }\n  return(rolling_max)\n}\n", "\n  result <- numeric(length(numbers))\n\
    \  max <- 0\n  for (i in 1:length(numbers)) {\n    if (numbers[i] > max) {\n \
    \     max <- numbers[i]\n    }\n    result[i] <- max\n  }\n  return(result)\n}",
  "\n  unlist(Reduce(pmax, split(numbers, findInterval(seq_along(numbers), seq(2,\
    \ length(numbers) + 1, 2)))))\n}\n", "\n  c(head(numbers, 1), sapply(tail(numbers,\
    \ -1), function(i) max(numbers[1:which(numbers == i)])))\n}\n\nx <- c(1, 2, 3,\
    \ 2, 3, 4, 2)\n\nrolling_max(x)\nrolling_max(x)\nrolling_max(x)\nrolling_max(x)\n\
    rolling_max(x)\nrolling_max(x)\nrolling_max(x)\n", "\n  max = numbers[1]\n  result\
    \ = max\n  for (number in numbers[2:length(numbers)]) {\n    if (number > max)\
    \ {\n      max = number\n    }\n    result = c(result, max)\n  }\n  return(result)\n\
    }\n", "\n  output <- vector(\"numeric\", length = length(numbers))\n  output[1]\
    \ <- numbers[1]\n  for (i in 2:length(numbers)) {\n    output[i] <- max(output[i-1],\
    \ numbers[i])\n  }\n  return(output)\n}", "\n  cumsum <- c()\n  numbers <- numbers[cumsum(numbers)\
    \ == 0]\n  cumsum <- cumsum(numbers)\n  return(cumsum)\n}\n ", "\n\tresult <-\
    \ c()\n\tfor (i in seq_along(numbers)) {\n\t\tif (i == 1) {\n\t\t\tresult <- c(result,\
    \ numbers[i])\n\t\t} else {\n\t\t\tresult <- c(result, max(result[i - 1], numbers[i]))\n\
    \t\t}\n\t}\n\treturn(result)\n}\n", "\n    cumsum(ifelse(numbers < max(numbers),\
    \ 0, 1))\n}", "\n  result <- numeric(length(numbers))\n  result[1] <- numbers[1]\n\
    \  for (i in 2:length(numbers)) {\n    result[i] <- max(result[i-1], numbers[i])\n\
    \  }\n  return(result)\n}\n", "\n  c(numbers[1],\n    vector(mode = \"integer\"\
    , length = length(numbers) - 1))\n}\n\nassert_equal(rolling_max(c(1, 2, 3, 2,\
    \ 3, 4, 2)), c(1, 2, 3, 3, 3, 4, 4))\nassert_equal(rolling_max(c(1, 1, 1, 1, 1,\
    \ 1, 1)), c(1, 1, 1, 1, 1, 1, 1))\nassert_equal(rolling_max(c(1, 2, 1, 2, 1, 2,\
    \ 1)), c(1, 2, 2, 2, 2, 2, 2))\nassert_equal(rolling_max(c(10, 9, 8, 7, 6, 5,\
    \ 4)), c(10, 10, 10, 10, 10, 10, 10))\n", "\n  # TODO\n}\n", "\n    return(sapply(numbers,\
    \ FUN = function(x) {\n        sapply(numbers, FUN = function(y) {\n         \
    \   if (y <= x) {\n                return(y)\n            } else {\n         \
    \       return(x)\n            }\n        })\n    }))\n}\n", "\n  result <- numeric(length(numbers))\n\
    \  rolling_max <- numeric(length(numbers))\n  for (i in 1:length(numbers)) {\n\
    \    result[i] <- numbers[i]\n    if (i > 1) {\n      result[i] <- max(result[i],\
    \ rolling_max[i - 1])\n    }\n    rolling_max[i] <- result[i]\n  }\n  return(result)\n\
    }\n", "\n    ret <- vector()\n    current_max <- numbers[1]\n    for (i in 2:length(numbers))\
    \ {\n        if (numbers[i] > current_max) {\n            current_max <- numbers[i]\n\
    \        }\n        ret <- c(ret, current_max)\n    }\n    return(ret)\n}\n\n\
    rolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  max <- numbers[1]\n  for (i in 2:length(numbers))\
    \ {\n    if (numbers[i] > max) {\n      max <- numbers[i]\n    }\n    numbers[i]\
    \ <- max\n  }\n  return(numbers)\n}\n ", "\n  c(head(numbers, 1), sapply(2:length(numbers),\
    \ function(i) max(numbers[1:i])))\n}\n", "\n    max_elems <- integer(length(numbers))\n\
    \    curr_max_elem <- NULL\n    for (i in seq_along(numbers)) {\n        if (is.null(curr_max_elem)\
    \ || curr_max_elem < numbers[i]) {\n            curr_max_elem <- numbers[i]\n\
    \        }\n        max_elems[i] <- curr_max_elem\n    }\n    return(max_elems)\n\
    }\n", "\n  indices <- (1:length(numbers))\n  result <- list()\n  for (index in\
    \ indices) {\n    subs <- numbers[1:index]\n    result <- c(result, max(subs))\n\
    \  }\n  return(result)\n}\n", "\n  # write your code here\n  n <- length(numbers)\n\
    \  if (n == 0) {\n    return(NULL)\n  } else {\n    rm <- numeric(n)\n    rm[1]\
    \ <- numbers[1]\n    for (i in 2:n) {\n      if (numbers[i] > rm[i-1]) {\n   \
    \     rm[i] <- numbers[i]\n      } else {\n        rm[i] <- rm[i-1]\n      }\n\
    \    }\n    return(rm)\n  }\n}\n", "\n  numbers[which.max(numbers)]\n}\n", "\n\
    \    res <- numeric(length(numbers))\n    res[1] <- numbers[1]\n    for (i in\
    \ 2:length(numbers)) {\n        res[i] <- max(res[i-1], numbers[i])\n    }\n \
    \   return(res)\n}", "\n  numbers.max <- c()\n  for (i in seq_along(numbers))\
    \ {\n    numbers.max <- c(numbers.max, max(numbers[1:i]))\n  }\n  return(numbers.max)\n\
    }\n", "\n  if (length(numbers) == 0) {\n    return(numeric(0))\n  }\n\n  result\
    \ <- numeric(length(numbers))\n  current_max <- numbers[1]\n  result[1] <- current_max\n\
    \n  for (i in 2:length(numbers)) {\n    current_max <- max(current_max, numbers[i])\n\
    \    result[i] <- current_max\n  }\n\n  return(result)\n}\n", "\n  l <- length(numbers)\n\
    \  res <- c()\n  for (i in 1:l) {\n    res <- c(res, max(numbers[seq(i)]))\n \
    \ }\n  return(res)\n}\n", "\n    n <- length(numbers)\n    if (n < 1)\n      \
    \  return(NULL)\n    rolling_max <- c(numbers[1])\n    for (i in seq(2, n)) {\n\
    \        if (numbers[i] > rolling_max[i - 1])\n            rolling_max <- c(rolling_max,\
    \ numbers[i])\n        else\n            rolling_max <- c(rolling_max, rolling_max[i\
    \ - 1])\n    }\n    return(rolling_max)\n}\n\nrolling_max(c(1, 2, 3, 2, 3, 4,\
    \ 2))\n", "\n  message(\"generating rolling maximum\")\n  result <- c()\n  for\
    \ (i in 1:length(numbers)) {\n    result <- c(result, max(numbers[1:i]))\n  }\n\
    \  return(result)\n}\n", "\n    # for each number in the numbers, generate a list\
    \ of numbers that are maximum up to that point in the sequence\n    numbers %>%\n\
    \        map(function(number) {\n            1:number %>%\n                map(function(i)\
    \ max(numbers[1:i]))\n        }) %>%\n        reduce(rbind) %>%\n        c()\n\
    }\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  # TODO\n}\n\nprint(rolling_max(c(1,\
    \ 2, 3, 2, 3, 4, 2)))\n", "\n  result <- rep(0, length(numbers))\n  idx <- 1:length(numbers)\n\
    \  result[idx < 3] <- numbers[idx[idx < 3]]\n  result[idx >= 3] <- pmax(numbers[idx[idx\
    \ >= 3]], numbers[idx[idx >= 3] - 1], numbers[idx[idx >= 3] - 2])\n  return(result)\n\
    }\n", "\n   # create an empty list\n   maximums <- list()\n   # loop over the\
    \ elements and add the maximum of all elements up to the current position\n  \
    \ for (i in 1:length(numbers)) {\n      maximums[[i]] <- max(numbers[1:i])\n \
    \  }\n   # unlist the list\n   unlist(maximums)\n}\n", "\n    curr_max <- numbers[1]\n\
    \    result <- integer(length(numbers))\n    result[1] <- curr_max\n    for (i\
    \ in 2:length(numbers)) {\n        curr_num <- numbers[i]\n        if (curr_num\
    \ > curr_max) {\n            curr_max <- curr_num\n        }\n        result[i]\
    \ <- curr_max\n    }\n    return(result)\n}\n", "\n  rollapply(numbers, width\
    \ = seq_along(numbers), max, partial = TRUE)\n}\n", "\n  # Your code here\n  rolling_max\
    \ <- numeric(length(numbers))\n  for (i in 1:length(numbers)) {\n    rolling_max[i]\
    \ <- max(numbers[1:i])\n  }\n  return(rolling_max)\n}\n", "\n  rolling_max_rec(numbers,\
    \ numeric(length(numbers)))\n}\n\nrolling_max_rec <- function(numbers, result)\
    \ {\n  if (length(numbers) == 0) {\n    return(result)\n  }\n  result[length(result)]\
    \ <- max(numbers[1], result[length(result) - 1])\n  rolling_max_rec(numbers[-1],\
    \ result)\n}\n\na <- c(1,2,3,2,3,4,2)\nrolling_max(a)\n", "\n  out <- vector(mode=\"\
    integer\", length=length(numbers))\n  for (i in seq_along(numbers)) {\n    out[i]\
    \ <- max(numbers[1:i])\n  }\n  return(out)\n}\n", "\n  # Your code goes here\n\
    }\n", "\n    c(head(numbers, 1),\n      lapply(tail(numbers, -1), function(x)\
    \ max(head(numbers, which(numbers == x)))))\n}\n", "\n  # TODO: implement this\n\
    \  return(numbers)\n}\n\na <- c(1, 2, 3, 2, 3, 4, 2)\nrolling_max(a)\n", "\n \
    \ cumsum(numbers) - cumsum(c(0, head(numbers, -1)))\n}\n", "\n  max <- numbers[1]\n\
    \  for (i in 2:length(numbers)) {\n    if (numbers[i] > max) {\n      max <- numbers[i]\n\
    \    }\n    numbers[i] <- max\n  }\n  return(numbers)\n}\n", "\n  rolling_max\
    \ <- numbers[1]\n  rolling_maxes <- numeric(length(numbers))\n  for (i in 1:length(numbers))\
    \ {\n    rolling_max <- max(rolling_max, numbers[i])\n    rolling_maxes[i] <-\
    \ rolling_max\n  }\n  rolling_maxes\n}\n", "\n    index <- 1\n    for (n in numbers)\
    \ {\n        if (index == 1) {\n            yield <- n\n        } else {\n   \
    \         yield <- max(n, yield)\n        }\n        index <- index + 1\n    }\n\
    \    return(yield)\n}\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  tmp <- NULL\n\
    \  for (i in 1:length(numbers)) {\n    tmp <- c(tmp, max(numbers[1:i]))\n  }\n\
    \  return(tmp)\n}", "\n    unlist(lapply(seq_along(numbers), function(x) max(numbers[1:x])))\n\
    }\n", "\n  max <- numbers[1]\n  rolling_max <- c()\n  for (i in 1:length(numbers))\
    \ {\n    if (numbers[i] > max) {\n      max <- numbers[i]\n    }\n    rolling_max\
    \ <- c(rolling_max, max)\n  }\n  return(rolling_max)\n}\n", "\n    max(numbers)\n\
    }\n", "\n  cummax(numbers)\n}\n", "\n  if (length(numbers) == 0) return(numbers)\n\
    \  result <- c(numbers[1])\n  for (i in 2:length(numbers)) {\n    if (numbers[i]\
    \ > result[i - 1]) {\n      result <- c(result, numbers[i])\n    } else {\n  \
    \    result <- c(result, result[i - 1])\n    }\n  }\n  return(result)\n}\n", "\n\
    \  out <- numeric(length(numbers))\n  last_max <- 0\n  for (i in seq_along(numbers))\
    \ {\n    out[i] <- max(last_max, numbers[i])\n    last_max <- out[i]\n  }\n  out\n\
    }\n", "\n  numbers <- numbers[!is.na(numbers)]\n  result <- c()\n  n <- length(numbers)\n\
    \  max <- numbers[1]\n  result <- c(result, max)\n  if (n < 2) {\n    return(result)\n\
    \  }\n  for (i in 2:n) {\n    if (numbers[i] > max) {\n      max <- numbers[i]\n\
    \    }\n    result <- c(result, max)\n  }\n  return(result)\n}", "\n  if (length(numbers)\
    \ == 0) {\n    return(numeric(0))\n  }\n  # You can access the first element of\
    \ a vector using the following syntax\n  # vector[1]\n  # or in some cases\n \
    \ # vector[[1]]\n  current_max <- numbers[1]\n  output <- c(current_max)\n  for\
    \ (number in numbers[-1]) {\n    if (number > current_max) {\n      current_max\
    \ <- number\n    }\n    output <- c(output, current_max)\n  }\n  return(output)\n\
    }\n", "\n    current_max <- numbers[1]\n    ans <- c()\n    for (number in numbers)\
    \ {\n        if (number > current_max) {\n            current_max <- number\n\
    \        }\n        ans <- c(ans, current_max)\n    }\n    return(ans)\n}\n\n\
    print(rolling_max(c(1, 2, 3, 2, 3, 4, 2)))\n", "\n    if (length(numbers) == 0)\
    \ return(NULL)\n    n <- length(numbers)\n    result <- numeric(n)\n    result[1]\
    \ <- numbers[1]\n    for (i in 2:n) {\n        result[i] <- max(result[i-1], numbers[i])\n\
    \    }\n    return(result)\n}\n", "\n  n <- length(numbers)\n  maxes <- c()\n\
    \  current_max <- numbers[1]\n  maxes <- c(maxes, current_max)\n  for (i in 2:n)\
    \ {\n    if (numbers[i] > current_max) {\n      current_max <- numbers[i]\n  \
    \  }\n    maxes <- c(maxes, current_max)\n  }\n  return(maxes)\n}\n\nget_data_point\
    \ <- function(data, ix) {\n  return(data[which(data[,1] == ix),][1,])\n}\n", "\n\
    \  maxes <- c()\n  for (idx in seq_along(numbers)) {\n    maxes <- c(maxes, max(numbers[1:idx]))\n\
    \  }\n  return(maxes)\n}\n ", "\n    if (length(numbers) == 0) {\n        return(integer(0))\n\
    \    }\n    if (length(numbers) == 1) {\n        return(numbers)\n    }\n    if\
    \ (length(numbers) == 2) {\n        return(c(numbers[1], max(numbers)))\n    }\n\
    \    if (length(numbers) == 3) {\n        return(c(numbers[1], max(numbers[1:2]),\
    \ max(numbers)))\n    }\n    if (length(numbers) == 4) {\n        return(c(numbers[1],\
    \ max(numbers[1:2]), max(numbers[1:3]), max(numbers)))\n    }\n    if (length(numbers)\
    \ == 5) {\n        return(c(numbers[1], max(numbers[1:2]), max(numbers[1:3]),\
    \ max(numbers[1:4]), max(numbers)))\n    }\n    return(rolling_max(numbers[1:5])\
    \ + rolling_max(numbers[6:length(numbers)]))\n}\n", "\n  cumsum(sapply(numbers,\
    \ function(x) {c(rep(0, x-1), rep(1, length(numbers)-x+1))}))\n}\n", "\n    max\
    \ <- NULL\n    for (i in 1:length(numbers)) {\n        if (i == 1) {\n       \
    \     max <- numbers[i]\n        } else {\n            if (numbers[i] > max) {\n\
    \                max <- numbers[i]\n            }\n        }\n        print(max)\n\
    \    }\n}\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n    rolling_max_implementation\
    \ <- function(l, m) {\n        if (length(l) == 0) {\n            return(m)\n\
    \        } else {\n            return(c(m, rolling_max_implementation(tail(l,\
    \ 1), max(m, head(l, 1)))))\n        }\n    }\n    return(rolling_max_implementation(numbers,\
    \ 0))\n}\n\nlibrary(testthat)\nexpect_equal(rolling_max(c(1, 2, 3, 2, 3, 4, 2)),\
    \ c(1, 2, 3, 3, 3, 4, 4))\nexpect_equal(rolling_max(c(2, 3, 2, 1, 4, 3, 1)), c(2,\
    \ 3, 3, 3, 4, 4, 4))", "\n  result <- c()\n  maximum <- NULL\n  for (number in\
    \ numbers) {\n    if (is.null(maximum) || number > maximum) {\n      maximum <-\
    \ number\n    }\n    result <- c(result, maximum)\n  }\n  return(result)\n}\n\
    rolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  # Your solution here...\n}\n ", "\n\
    \  result <- c()\n  curr_max <- -Inf\n  for (number in numbers) {\n    if (number\
    \ > curr_max) {\n      curr_max <- number\n    }\n    result <- c(result, curr_max)\n\
    \  }\n  return(result)\n}\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  maxes\
    \ <- vector(\"integer\", length(numbers))\n  for (i in seq_along(numbers)) {\n\
    \    maxes[i] <- max(numbers[1:i])\n  }\n  return(maxes)\n}\n", "\n  rollapply(numbers,\
    \ 2, max, fill = NA, align = \"right\")\n}\n", "\n    maximum <- numbers[1]\n\
    \    result <- c()\n    for (number in numbers) {\n        if (number > maximum)\
    \ {\n            maximum <- number\n        }\n        result <- c(result, maximum)\n\
    \    }\n    return(result)\n}\n ", "\n  max_numbers <- c()\n  for (i in 1:length(numbers))\
    \ {\n    if (length(max_numbers) == 0) {\n      max_numbers <- numbers[i]\n  \
    \  } else {\n      max_numbers <- c(max_numbers, max(max_numbers[i - 1], numbers[i]))\n\
    \    }\n  }\n  return(max_numbers)\n}\n\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))",
  "\n  maxs <- c()\n  rolling_max <- numbers[1]\n  for (number in numbers) {\n   \
    \ if (number > rolling_max) {\n      rolling_max <- number\n    }\n    maxs <-\
    \ c(maxs, rolling_max)\n  }\n  return(maxs)\n}\nrolling_max(c(1, 2, 3, 2, 3, 4,\
    \ 2))\n", "\n  vector(\"list\", length(numbers))\n}\n", "\n  ret_list <- c()\n\
    \  for (number in numbers) {\n    if (length(ret_list) == 0) {\n      ret_list\
    \ <- append(ret_list, number)\n    } else {\n      ret_list <- append(ret_list,\
    \ max(ret_list[length(ret_list)], number))\n    }\n  }\n  return(ret_list)\n}\n",
  "\n    res <- list()\n    for (num in numbers) {\n        res <- c(res, max(num,\
    \ tail(res, 1)))\n    }\n    return(res)\n}\n", "\n  result <- c()\n  for (i in\
    \ 1:length(numbers)) {\n    result <- c(result, max(numbers[1:i]))\n  }\n  return(result)\n\
    }\n\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n\nrolling_max(runif(100))\n", "\n  result\
    \ <- rep(NA, length(numbers))\n  for (i in seq_along(numbers)) {\n    result[i]\
    \ <- max(numbers[1:i])\n  }\n  return(result)\n}\nrolling_max(c(1, 2, 3, 2, 3,\
    \ 4, 2))\n", "\n    results <- c()\n    for (number in numbers) {\n        current_max\
    \ <- ifelse(length(results) == 0, number, max(results[length(results)], number))\n\
    \        results <- c(results, current_max)\n    }\n    return(results)\n}\n",
  "\n  # Initialize the result vector with first element\n  rolling_maxes <- numbers[1]\n\
    \  for (i in seq(from = 2, to = length(numbers))) {\n    # Append maximum between\
    \ the current maximum and current element\n    rolling_maxes <- c(rolling_maxes,\
    \ max(rolling_maxes[i - 1], numbers[i]))\n  }\n  return(rolling_maxes)\n}\n",
  "\n    if (length(numbers) == 0) {\n        return(c())\n    }\n    if (length(numbers)\
    \ == 1) {\n        return(numbers)\n    }\n    rolling_max_aux(numbers, numbers[1])\n\
    }\nrolling_max_aux <- function(numbers, max_so_far) {\n    if (length(numbers)\
    \ == 0) {\n        return(c())\n    }\n    if (length(numbers) == 1) {\n     \
    \   return(c(max_so_far))\n    }\n    c(max_so_far, rolling_max_aux(tail(numbers,\
    \ -1), max(max_so_far, head(numbers, 1))))\n}\n", "\n    for (i in 1:length(numbers))\
    \ {\n        if (i == 1) {\n            numbers[i]\n        } else {\n       \
    \     numbers[i] <- max(numbers[i], numbers[i-1])\n        }\n    }\n}\nrolling_max(x)\n",
  "\n  roll_max <- numeric(length(numbers))\n  for (i in 1:length(numbers)) {\n  \
    \  roll_max[i] <- max(numbers[1:i])\n  }\n  return(roll_max)\n}\n", "\n\tif(!is.numeric(numbers))\
    \ {\n\t\treturn(\"ERROR: Variable is not numeric!\")\n\t}\n\trolling_max <- c()\n\
    \tmax <- 0\n\tfor(i in numbers) {\n\t\tif(i > max) {\n\t\t\tmax <- i\n\t\t}\n\t\
    \trolling_max <- c(rolling_max, max)\n\t}\n\treturn(rolling_max)\n}", "\n    #\
    \ write your code here\n    n <- length(numbers)\n    max <- rep(NA, n)\n    max[1]\
    \ <- numbers[1]\n    for (i in 2:n) {\n        if (numbers[i] > max[i-1])\n  \
    \          max[i] <- numbers[i]\n        else\n            max[i] <- max[i-1]\n\
    \    }\n    return(max)\n}\n", "\n  n <- length(numbers)\n  c(numbers[1], numbers[2:n][numbers[2:n]\
    \ > numbers[1:(n-1)]])\n}\n", "\n  max_so_far <- -Inf\n  for (number in numbers)\
    \ {\n    max_so_far <- max(max_so_far, number)\n    print(max_so_far)\n  }\n}\n\
    numbers <- c(1, 2, 3, 2, 3, 4, 2)\nrolling_max(numbers)\n", "\n  stopifnot(is.integer(numbers))\n\
    \  if (length(numbers) == 0) {\n    return(integer())\n  }\n  result <- numeric(length(numbers))\n\
    \  result[1] <- numbers[1]\n  for (i in 2:length(numbers)) {\n    result[i] <-\
    \ max(result[i - 1], numbers[i])\n  }\n  return(result)\n}", "\n    m <- c()\n\
    \    for (number in numbers) {\n        m <- c(m, max(number, ifelse(length(m)\
    \ > 0, m[length(m)], number)))\n    }\n    return(m)\n}\n", "\n  max = c()\n \
    \ c = 1\n  max[c] = numbers[c]\n  for (c in 2:length(numbers)) {\n    if (numbers[c]\
    \ > max[c-1]) {\n      max[c] = numbers[c]\n    } else {\n      max[c] = max[c-1]\n\
    \    }\n  }\n  return(max)\n}\n\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n \
    \ n <- length(numbers)\n  numbers[n] <- max(numbers[n], numbers[n - 1])\n  if\
    \ (n > 1) {\n    numbers[(n - 1):1] <- rolling_max(numbers[(n - 1):1])\n  }\n\
    \  numbers\n}\n\nrolling_max <- function(numbers) {\n  # http://stackoverflow.com/questions/12938028/how-can-i-add-elements-to-a-vector-in-r-with-a-for-loop\n\
    \  cumsum(numbers)\n}\n", "\n  max_vector <- numeric(length(numbers))\n  for (i\
    \ in 1:length(numbers)) {\n    max_vector[i] <- max(numbers[1:i])\n  }\n  return(max_vector)\n\
    }\n", "\n  result <- numeric(length(numbers))\n  result[1] <- numbers[1]\n  for\
    \ (i in seq(2, length(numbers))) {\n    if (numbers[i] > result[i - 1]) {\n  \
    \    result[i] <- numbers[i]\n    } else {\n      result[i] <- result[i - 1]\n\
    \    }\n  }\n  return(result)\n}\n", "\n    max <- numbers[1]\n    result <- list()\n\
    \    for (number in numbers) {\n        if (number > max) {\n            max <-\
    \ number\n        }\n        result <- c(result, max)\n    }\n    return(result)\n\
    }\n", "\n    if (length(numbers) == 0) {\n        return(numeric(0))\n    }\n\
    \    max <- numbers[1]\n    result <- rep(0, length(numbers))\n    result[1] <-\
    \ max\n    for (i in 2:length(numbers)) {\n        max <- max(max, numbers[i])\n\
    \        result[i] <- max\n    }\n    return(result)\n}", "\n    results <- rep(NA,\
    \ length(numbers))\n    for (i in seq_along(numbers)) {\n        results[i] <-\
    \ max(numbers[1:i])\n    }\n    return(results)\n}\n", "\n    result <- c()\n\
    \    for (x in numbers) {\n        result <- c(result, max(result, x))\n    }\n\
    \    return(result)\n}\n ", "\n  for (n in 1:length(numbers))\n    numbers[n]\
    \ <- max(numbers[1:n])\n  return(numbers)\n}\n", "\n  maxs <- c()\n  for (i in\
    \ 1:length(numbers)) {\n    maxs <- c(maxs, max(numbers[1:i]))\n  }\n  return(maxs)\n\
    }\n\nnumbers <- c(1, 2, 3, 2, 3, 4, 2)\nrolling_max(numbers)\n", "\n    # replace\
    \ this code by the appropriate R expression\n    return(c())\n}\n\nrolling_max(c(1,\
    \ 2, 3, 2, 3, 4, 2))\n ", "\n    maxes <- numeric(length(numbers))\n    cur_max\
    \ <- -1\n    for (i in 1:length(numbers)) {\n        if (numbers[i] > cur_max)\
    \ {\n            cur_max <- numbers[i]\n        }\n        maxes[i] <- cur_max\n\
    \    }\n    return(maxes)\n}\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  max(c(1,2,3,2,3,4,2))\n\
    }\n", "\n  apply(data.frame(numbers), MARGIN = 1, FUN = max)\n}\n\nlibrary(modeltools)\n\
    \nrun_rolling_max_test <- function(test_name, input, expected_output) {\n  actual_output\
    \ <- rolling_max(input)\n  message(paste0(test_name, \": \"))\n  print(all.equal(actual_output,\
    \ expected_output))\n}\n\nrun_rolling_max_test(\"Test 1\", c(1, 2, 3, 2, 3, 4,\
    \ 2), c(1, 2, 3, 3, 3, 4, 4))\nrun_rolling_max_test(\"Test 2\", c(4, 3, 2, 1),\
    \ c(4, 4, 4, 4))\nrun_rolling_max_test(\"Test 3\", c(1, 1, 1, 1), c(1, 1, 1, 1))\n\
    run_rolling_max_test(\"Test 4\", c(1, 2, 3, 1, 2, 3, 1, 2, 3), c(1, 2, 3, 3, 3,\
    \ 3, 3, 3, 3))\nrun_rolling_max_test(\"Test 5\", c(3, 2, 1, 2, 3, 2, 1, 2, 3),\
    \ c(3, 3, 3, 3, 3, 3, 3, 3, 3))\nrun_rolling_max_test(\"Test 6\", c(3, 2, 1, 2,\
    \ 3, 2, 1, 2, 3, 2, 1, 2, 3, 2, 1, 2, 3), c(3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3))", "\n    stopifnot(!any(is.na(numbers)))\n    numbers[1]\n\n\
    \    for (i in 2:length(numbers)) {\n        numbers[i] <- max(numbers[i], numbers[i\
    \ - 1])\n    }\n\n    numbers\n}\n", "\n  result <- c()\n  for (i in 1:length(numbers))\
    \ {\n    result <- c(result, max(numbers[1:i]))\n  }\n  return(result)\n}\n\n\
    rolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  maxes <- sapply(seq_along(numbers),\
    \ function(i) max(numbers[1:i]))\n  maxes\n}\n", "\n  xs <- c()\n  max <- -Inf\n\
    \  for (n in numbers) {\n    max <- max(max, n)\n    xs <- c(xs, max)\n  }\n \
    \ return(xs)\n}\n\nplot(rolling_max(numbers))\n", "\n  if (length(numbers) <=\
    \ 1) {\n    return(numbers)\n  }\n  x <- numbers[1]\n  prev <- rolling_max(numbers[-1])\n\
    \  return(c(x, pmin(x, prev[-1])))\n}\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n",
  "\n  rolling_max <- c()\n  curr_max <- numbers[1]\n  rolling_max <- c(rolling_max,\
    \ curr_max)\n  for (i in 2:length(numbers)) {\n    num <- numbers[i]\n    if (num\
    \ > curr_max) {\n      curr_max <- num\n    }\n    rolling_max <- c(rolling_max,\
    \ curr_max)\n  }\n  return(rolling_max)\n}\n", "\n    # initial value is the first\
    \ number\n    rolling_max <- numbers[1]\n    result <- list()\n    # build rolling\
    \ max values as we iterate through the list\n    for (number in numbers) {\n \
    \       if (number > rolling_max) {\n            rolling_max <- number\n     \
    \   }\n        result <- c(result, rolling_max)\n    }\n    return(result)\n}",
  "\n  current_max <- numbers[1]\n  for (index in seq(1, length(numbers))) {\n   \
    \ if (numbers[index] > current_max) {\n      current_max <- numbers[index]\n \
    \   }\n    numbers[index] <- current_max\n  }\n  return(numbers)\n}\nrolling_max(c(1,\
    \ 2, 3, 2, 3, 4, 2))\n"]
stop_tokens:
- "\n#"
- "\n```"
