name: HumanEval_9_rolling_max
language: r
prompt: "# From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n# in the sequence.\n# >>> rolling_max(c(1, 2, 3, 2,\
  \ 3, 4, 2))\n# c(1, 2, 3, 3, 3, 4, 4)\nrolling_max <- function(numbers) {"
tests: "test_humaneval <- function() {\ncandidate <- rolling_max\n    if(!identical(candidate(c()),\
  \ c())){quit('no', 1)}\n    if(!identical(candidate(c(1, 2, 3, 4)), c(1, 2, 3, 4))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(4, 3, 2, 1)), c(4, 4, 4, 4))){quit('no', 1)}\n\
  \    if(!identical(candidate(c(3, 2, 3, 100, 3)), c(3, 3, 3, 100, 100))){quit('no',\
  \ 1)}\n}\ntest_humaneval()"
completions: ["\n  res <- numeric(length(numbers))\n  for (i in seq_along(numbers))\
    \ {\n    res[i] <- max(numbers[1:i])\n  }\n  res\n}\n\nrolling_max(c(1, 2, 3,\
    \ 2, 3, 4, 2))\n", "\n    max_value <- NULL\n    for (i in 1:length(numbers))\
    \ {\n        number <- numbers[i]\n        if (is.null(max_value)) {\n       \
    \     max_value <- number\n        } else {\n            max_value <- c(max_value,\
    \ max(max_value[i - 1], number))\n        }\n    }\n    return(max_value)\n}\n",
  "\n  numbers[cumsum(numbers > shift(numbers, -1, fill = 0, type = \"lead\"))]\n\
    }\n", "\n  res <- vector(mode = \"integer\", length = length(numbers))\n  res[1]\
    \ <- numbers[1]\n  for (i in 2:length(numbers)) {\n    res[i] <- max(res[i - 1],\
    \ numbers[i])\n  }\n  return(res)\n}\n", "\n  unlist(lapply(\n    1:length(numbers),\n\
    \    function(i) {\n      max(numbers[1:i])\n    }\n  ))\n}\n", "\n   # Input:\
    \ numbers - a vector of integer numbers\n   # Output: a vector of integers - a\
    \ sliding maximum\n   n <- length(numbers)\n   max <- numbers[1]\n   sliding_max\
    \ <- numeric(n)\n   for (i in seq_along(numbers)) {\n     if (max < numbers[i])\
    \ {\n        max <- numbers[i]\n     }\n     sliding_max[i] <- max\n   }\n   return(sliding_max)\n\
    }\n", "\n    numbers <- as.integer(numbers)\n    maxes <- rep(0, length(numbers))\n\
    \    current_max <- numbers[1]\n    for (i in 1:length(numbers)) {\n        if\
    \ (numbers[i] > current_max) {\n            current_max <- numbers[i]\n      \
    \  }\n        maxes[i] <- current_max\n    }\n    return(maxes)\n}\n", "\n  numbers\
    \ <- unlist(numbers)\n\n  lapply(1:length(numbers), function(x) {\n    max(numbers[1:x])\n\
    \  })\n}\n", "\n  # Write your code here!\n  first_max <- numbers[1]\n  l <- length(numbers)\n\
    \  rolling_max <- c()\n  for (i in 1:l) {\n    if (numbers[i] > first_max) {\n\
    \      first_max <- numbers[i]\n    }\n    rolling_max <- c(rolling_max, first_max)\n\
    \  }\n  return(rolling_max)\n}\nc(1, 2, 3, 2, 3, 4, 2) %>% \n  rolling_max()\n\
    \ ", "\n  result <- c()\n  current_max <- -Inf\n  for (number in numbers) {\n\
    \    if (number > current_max) {\n      current_max <- number\n    }\n    result\
    \ <- c(result, current_max)\n  }\n  return(result)\n}\n", "\n  rolling_max_list\
    \ <- c()\n  rolling_max <- numbers[1]\n  rolling_max_list <- c(rolling_max_list,\
    \ rolling_max)\n  for (i in 2:length(numbers)) {\n    if (numbers[i] > rolling_max)\
    \ {\n      rolling_max <- numbers[i]\n    }\n    rolling_max_list <- c(rolling_max_list,\
    \ rolling_max)\n  }\n  return(rolling_max_list)\n}\n", "\n  current_max <- NULL\n\
    \  for (number in numbers) {\n    if (is.null(current_max) || number > current_max)\
    \ {\n      current_max <- number\n    }\n    print(current_max)\n  }\n}\n\nprint(rolling_max(c(1,\
    \ 2, 3, 2, 3, 4, 2)))", "\n  rolling_max <- numeric(length(numbers))\n  max_so_far\
    \ <- 0\n  i <- 1\n  for (number in numbers) {\n    if (number > max_so_far) {\n\
    \      max_so_far <- number\n    }\n    rolling_max[i] <- max_so_far\n    i <-\
    \ i + 1\n  }\n  return(rolling_max)\n}\n", "\n  maximum <- numeric(length(numbers))\n\
    \  maximum[1] <- numbers[1]\n  for (i in 2:length(numbers)) {\n    maximum[i]\
    \ <- max(maximum[i-1], numbers[i])\n  }\n  return(maximum)\n}\n", "\n  max <-\
    \ numbers[1]\n  result <- c()\n  for (i in seq_along(numbers)) {\n    if (numbers[i]\
    \ > max) {\n      max <- numbers[i]\n    }\n    result <- c(result, max)\n  }\n\
    \  return(result)\n}\n\nsimple_rolling_max <- function(numbers) {\n  result <-\
    \ c()\n  for (i in seq_along(numbers)) {\n    result <- c(result, max(numbers[1:i]))\n\
    \  }\n  return(result)\n}\n\nkendall_tau <- function(x, y) {\n  x <- as.numeric(x)\n\
    \  y <- as.numeric(y)\n  z <- y[x]\n  z <- sort(z)\n  zz <- sort(y)\n  n <- length(z)\n\
    \  zz.index <- match(z, zz)\n  zz.index <- zz.index[order(zz.index)]\n  zz.index\
    \ <- zz.index - 1\n  zz.index <- zz.index[order(zz.index)]\n  c <- sum(zz.index\
    \ - c(0, cumsum(zz.index)[-n]))\n  return(c)\n}\n", "\n  max <- 0\n  for (number\
    \ in numbers) {\n    if (number > max) {\n      max <- number\n    }\n    print(max)\n\
    \  }\n}\n\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  lapply(1:length(numbers),\
    \ function(i) {\n    numbers[i:length(numbers)]\n  }) %>% lapply(max)\n}\n", "\n\
    \    max <- numbers[1]\n    result <- vector(\"integer\", length = length(numbers))\n\
    \    result[1] <- max\n    for (index in 2:length(numbers)) {\n        if (numbers[index]\
    \ > max) {\n            max <- numbers[index]\n        }\n        result[index]\
    \ <- max\n    }\n    return(result)\n}\n", "\n    if (length(numbers) == 0) return(vector())\n\
    \    if (length(numbers) == 1) return(numbers)\n    c(numbers[1], rolling_max(cummax(numbers[-1])))\n\
    }\nrolling_max(c(1, 2, 3, 2, 3, 4, 2))\n", "\n  numbers <- unlist(numbers)\n \
    \ state <- vector(\"list\", length = length(numbers))\n  state[[1]] <- numbers[1]\n\
    \  for (i in seq(2, length(numbers))) {\n    state[[i]] <- max(state[[i - 1]],\
    \ numbers[i])\n  }\n  state\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
