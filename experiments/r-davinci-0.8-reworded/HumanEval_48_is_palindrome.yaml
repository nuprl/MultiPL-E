name: HumanEval_48_is_palindrome
language: r
prompt: "# Checks if given string is a palindrome\n# >>> is_palindrome('')\n# TRUE\n\
  # >>> is_palindrome('aba')\n# TRUE\n# >>> is_palindrome('aaaaa')\n# TRUE\n# >>>\
  \ is_palindrome('zbcd')\n# FALSE\nis_palindrome <- function(text) {"
tests: "test_humaneval <- function() {\ncandidate <- is_palindrome\n    if(!identical(candidate(''),\
  \ TRUE)){quit('no', 1)}\n    if(!identical(candidate('aba'), TRUE)){quit('no', 1)}\n\
  \    if(!identical(candidate('aaaaa'), TRUE)){quit('no', 1)}\n    if(!identical(candidate('zbcd'),\
  \ FALSE)){quit('no', 1)}\n    if(!identical(candidate('xywyx'), TRUE)){quit('no',\
  \ 1)}\n    if(!identical(candidate('xywyz'), FALSE)){quit('no', 1)}\n    if(!identical(candidate('xywzx'),\
  \ FALSE)){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  tolower(text) == tolower(rev(text))\n}\n ", "\n  \n  if (length(text)\
    \ == 0) return(TRUE)\n  \n  half <- ceiling(length(text)/2)\n  first_half <- substr(text,\
    \ 1, half)\n  second_half <- substr(text, (length(text)-half+1), length(text))\n\
    \  \n  return(isTRUE(all.equal(first_half, rev(second_half))))\n  \n}\n", "\n\
    \    if (str_length(text) %in% c(0, 1)) {\n        TRUE\n    } else {\n      \
    \  str_sub(text, 1, 1) == str_sub(text, -1, -1) && is_palindrome(str_sub(text,\
    \ 2, -2))\n    }\n}\n", "\n  stopifnot(is.character(text))\n  text <- gsub(\"\
    [[:punct:]]\", \"\", text)\n  text <- gsub(\" \", \"\", text)\n  text <- tolower(text)\n\
    \  if (nchar(text) <= 1) return(TRUE)\n  return(substr(text, 1, 1) == substr(text,\
    \ nchar(text), nchar(text)) && is_palindrome(substr(text, 2, nchar(text) - 1)))\n\
    }\n", "\n  return(identical(text, rev(text)))\n}", "\n    max <- length(text)\n\
    \n    # 0, 1\n    if (max <= 1) {\n        return(TRUE)\n    }\n    # 2, 3\n \
    \   if (max <= 3) {\n        return(text[1] == text[max])\n    }\n\n    # 4, 5\n\
    \    if (max <= 5) {\n        return(text[1] == text[max] && text[2] == text[max\
    \ - 1])\n    }\n\n    # 6, 7\n    if (max <= 7) {\n        return(text[1] == text[max]\
    \ && text[2] == text[max - 1] && text[3] == text[max - 2])\n    }\n\n    # 8,\
    \ 9\n    if (max <= 9) {\n        return(text[1] == text[max] && text[2] == text[max\
    \ - 1] && text[3] == text[max - 2] && text[4] == text[max - 3])\n    }\n\n   \
    \ # 10\n    if (max <= 10) {\n        return(text[1] == text[max] && text[2] ==\
    \ text[max - 1] && text[3] == text[max - 2] && text[4] == text[max - 3] && text[5]\
    \ == text[max - 4])\n    }\n\n    # Bigger than 10\n    for (i in 1:ceiling(max\
    \ / 2)) {\n        if (text[i] != text[max - i + 1]) {\n            return(FALSE)\n\
    \        }\n    }\n\n    return(TRUE)\n}\n ", "\n    # Handle empty strings\n\
    \    if (text == '') {\n        return(TRUE)\n    }\n    \n    mid <- floor(nchar(text)\
    \ / 2)\n    left <- substr(text, 1, mid)\n    right <- substr(text, nchar(text)\
    \ - mid + 1, nchar(text))\n    left == rev(right)\n}\n", "\n  cleaned_text <-\
    \ gsub(\"[^[:alnum:]]\", \"\", tolower(text))\n  paste(rev(strsplit(cleaned_text,\
    \ \"\")[[1]]), collapse=\"\") == cleaned_text\n}\n", "\n    text_length <- nchar(text)\n\
    \    for (i in 1:(text_length/2)) {\n        if (substr(text, i, i) != substr(text,\
    \ text_length + 1 - i, text_length + 1 - i)) {\n            return(FALSE)\n  \
    \      }\n    }\n    return(TRUE)\n}\n", "\n    tolower(text) == tolower(rev(text))\n\
    }\n", "\n  text <- tolower(text)\n  count <- nchar(text)\n  half_count <- ceiling(count\
    \ / 2)\n  first_half <- substr(text, 1, half_count)\n  second_half <- substr(text,\
    \ count - half_count + 1, count)\n  return(first_half == second_half)\n}\n", "\n\
    \  a <- stringr::str_split(text, '')[[1]]\n  n <- length(a)\n  n2 <- ceiling(n\
    \ / 2)\n  for (i in 1:n2) {\n    if (a[i] != a[n - i + 1]) {\n      return(FALSE)\n\
    \    }\n  }\n  return(TRUE)\n}\n", "\n  text <- tolower(text)\n  text <- gsub(\"\
    [[:punct:]]\", \"\", text)\n  text <- gsub(\"[[:space:]]\", \"\", text)\n  if\
    \ (text == gsub(\"(.)\", \"\\\\1\", text, perl = TRUE))\n    return(TRUE)\n  else\n\
    \    return(FALSE)\n}\n", "\n    # YOUR CODE HERE\n    length(text)\n    return(text\
    \ == rev(text))\n}\ntest_that('Task4.4 - is_palindrome()', {\n    expect_true(is_palindrome(''))\n\
    \    expect_true(is_palindrome('aba'))\n    expect_true(is_palindrome('aaaaa'))\n\
    \    expect_false(is_palindrome('zbcd'))\n    expect_false(is_palindrome('  '))\n\
    \    expect_false(is_palindrome('123321'))\n})\n ", "\n  # YOUR CODE HERE\n}\n",
  "\n  # convert text to lowercase\n  text <- tolower(text)\n  # if text is not a\
    \ string, return FALSE\n  if (!is.character(text)) {\n    return(FALSE)\n  }\n\
    \  # if text has zero length, return TRUE\n  if (nchar(text) == 0) {\n    return(TRUE)\n\
    \  }\n  # if first and last characters are the same, call is_palindrome() with\
    \ the second character\n  # and the second-to-last character\n  if (substr(text,\
    \ 1, 1) == substr(text, nchar(text), nchar(text))) {\n    return(is_palindrome(substr(text,\
    \ 2, nchar(text) - 1)))\n  }\n  # otherwise, return FALSE\n  return(FALSE)\n}",
  "\n  # YOUR CODE HERE\n  if (identical(str_split(text, '')[[1]], str_split(str_reverse(text),\
    \ '')[[1]])){\n    TRUE\n  } else {\n    FALSE\n  }\n}\n", "\n    is_palindrome_acc(text,\
    \ 0, nchar(text) - 1)\n}\n", "\n  if (nchar(text) == 0) {\n    return(TRUE)\n\
    \  } else if (substr(text, 1, 1) == substr(text, nchar(text), nchar(text))) {\n\
    \    return(is_palindrome(substr(text, 2, nchar(text) - 1)))\n  } else {\n   \
    \ return(FALSE)\n  }\n}\n", "\n\tstring_length <- nchar(text)\n\tif (string_length\
    \ <= 1) {\n\t\treturn(TRUE)\n\t}\n\tif (substr(text, 1, 1) == substr(text, string_length,\
    \ string_length)) {\n\t\tis_palindrome(substr(text, 2, string_length - 1))\n\t\
    } else {\n\t\treturn(FALSE)\n\t}\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
