name: HumanEval_21_rescale_to_unit
language: r
prompt: "# Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n# such that the smallest number will become 0 and the largest will\
  \ become 1\n# >>> rescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))\n# c(0.0, 0.25, 0.5,\
  \ 0.75, 1.0)\nrescale_to_unit <- function(numbers) {"
tests: "test_humaneval <- function() {\ncandidate <- rescale_to_unit\n    if(!identical(candidate(c(2.0,\
  \ 49.9)), c(0.0, 1.0))){quit('no', 1)}\n    if(!identical(candidate(c(100.0, 49.9)),\
  \ c(1.0, 0.0))){quit('no', 1)}\n    if(!identical(candidate(c(1.0, 2.0, 3.0, 4.0,\
  \ 5.0)), c(0.0, 0.25, 0.5, 0.75, 1.0))){quit('no', 1)}\n    if(!identical(candidate(c(2.0,\
  \ 1.0, 5.0, 3.0, 4.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))){quit('no', 1)}\n    if(!identical(candidate(c(12.0,\
  \ 11.0, 15.0, 13.0, 14.0)), c(0.25, 0.0, 1.0, 0.5, 0.75))){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  m = max(numbers)\n  n = min(numbers)\n  out = (numbers - n) / (m\
    \ - n)\n  return(out)\n}", "\n    rescaled <- (numbers - min(numbers)) / (max(numbers)\
    \ - min(numbers))\n    return(rescaled)\n}\n", "\n  max = max(numbers)\n  min\
    \ = min(numbers)\n  (numbers - min) / (max - min)\n}", "\n  return((numbers -\
    \ min(numbers)) / (max(numbers) - min(numbers)))\n}", "\n  return ( (numbers -\
    \ min(numbers)) / diff(range(numbers)) )\n}\n", "\n  # Find the lowest and highest\
    \ number\n  min_num <- min(numbers)\n  max_num <- max(numbers)\n  # Create a sequence\
    \ from 0 to 1, with length of numbers\n  unit_seq <- seq(0, 1, length.out = length(numbers))\n\
    \  # Create a linear transformation from [min_num, max_num] to [0, 1]\n  (numbers\
    \ - min_num) / (max_num - min_num)\n}\n", "\n  return((numbers - min(numbers))\
    \ / (max(numbers) - min(numbers)))\n}\n", "\n    if (length(numbers) < 2) {\n\
    \        stop(\"rescale_to_unit needs a list of at least two numbers\")\n    }\n\
    \    span <- max(numbers) - min(numbers)\n    if (span == 0) {\n        return(rep(0.5,\
    \ length(numbers)))\n    }\n    return((numbers - min(numbers)) / span)\n}\n",
  "\n    (numbers - min(numbers)) / (max(numbers) - min(numbers))\n}\n", "\n  scaled\
    \ <- (numbers - min(numbers)) / (max(numbers) - min(numbers))\n  return(scaled)\n\
    }\n", "\n    minimum <- min(numbers)\n    maximum <- max(numbers)\n    return((numbers\
    \ - minimum) / (maximum - minimum))\n}\n ", "\n    l <- length(numbers)\n    pos_in_list\
    \ <- c(1:l)\n    new_numbers <- numbers\n    for (i in pos_in_list) {\n      \
    \  new_numbers[i] <- (new_numbers[i] - min(new_numbers)) / (max(new_numbers) -\
    \ min(new_numbers))\n    }\n    return(new_numbers)\n}\n", "\n  min <- numbers[which.min(numbers)]\n\
    \  max <- numbers[which.max(numbers)]\n  numbers <- (numbers - min) / (max - min)\n\
    \  return(numbers)\n}\n", "\n  (numbers - min(numbers)) / (max(numbers) - min(numbers))\n\
    }\n\nvisualize_relative_pca_axes <- function(pca,\n                          \
    \              pc_a,\n                                        pc_b,\n        \
    \                                var_a,\n                                    \
    \    var_b,\n                                        label_var,\n            \
    \                            plot_width=400,\n                               \
    \         plot_height=400) {\n  var_a_matrix <- as.matrix(var_a)\n  var_b_matrix\
    \ <- as.matrix(var_b)\n  label_var_matrix <- as.matrix(label_var)\n  pc_a_matrix\
    \ <- as.matrix(pc_a)\n  pc_b_matrix <- as.matrix(pc_b)\n  dist_a <- dist(t(pca$rotation[,\
    \ pc_a_matrix]), method=\"euclidean\")\n  dist_b <- dist(t(pca$rotation[, pc_b_matrix]),\
    \ method=\"euclidean\")\n  sim_a <- 1/(1 + dist_a)\n  sim_b <- 1/(1 + dist_b)\n\
    \  sim_a <- sim_a/max(sim_a)\n  sim_b <- sim_b/max(sim_b)\n  sim_a_label <- apply(sim_a,\
    \ 2, mean)\n  sim_b_label <- apply(sim_b, 2, mean)\n  sim_a_label <- rescale_to_unit(sim_a_label)\n\
    \  sim_b_label <- rescale_to_unit(sim_b_label)\n  sim_a_label <- sim_a_label*as.numeric(var_a_matrix)\n\
    \  sim_b_label <- sim_b_label*as.numeric(var_b_matrix)\n  sim_label <- sim_a_label\
    \ + sim_b_label\n  sim_label <- sim_label/max(sim_label)\n  sim_label <- sim_label*as.numeric(label_var_matrix)\n\
    \  p <- ggplot(pca$x, aes(", "\n    # TODO: Apply linear transform to rescale\
    \ list of numbers to fit on a scale from 0 to 1\n    numbers <- (numbers - min(numbers))/(max(numbers)\
    \ - min(numbers))\n}\n ", "\n    scl_0_1 <- scale(numbers, scale = c(0, 1))\n\
    \    return(scl_0_1)\n}\n", "\n  res <- (numbers - min(numbers)) / (max(numbers)\
    \ - min(numbers))\n  return(res)\n}\n", "\n  min_number <- min(numbers)\n  max_number\
    \ <- max(numbers)\n  scaled_numbers <- numbers - min_number\n  scaled_numbers\
    \ <- scaled_numbers / (max_number - min_number)\n  return(scaled_numbers)\n}\n\
    \nrescale_to_unit(c(1.0, 2.0, 3.0, 4.0, 5.0))\n", "\n  c(0, 5) / range(numbers)\
    \ * numbers\n}\n", "\n    return (numbers - min(numbers)) / (max(numbers) - min(numbers))\n\
    }\n"]
stop_tokens:
- "\n#"
- "\n```"
