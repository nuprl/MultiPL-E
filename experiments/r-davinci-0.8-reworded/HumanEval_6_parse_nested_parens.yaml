name: HumanEval_6_parse_nested_parens
language: r
prompt: "# Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n# For each of the group, output the deepest\
  \ level of nesting of parentheses.\n# E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n# >>> parse_nested_parens('(()()) ((())) () ((())()())')\n\
  # c(2, 3, 1, 3)\nparse_nested_parens <- function(paren_string) {"
tests: "test_humaneval <- function() {\ncandidate <- parse_nested_parens\n    if(!identical(candidate('(()())\
  \ ((())) () ((())()())'), c(2, 3, 1, 3))){quit('no', 1)}\n    if(!identical(candidate('()\
  \ (()) ((())) (((())))'), c(1, 2, 3, 4))){quit('no', 1)}\n    if(!identical(candidate('(()(())((())))'),\
  \ c(4))){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  groups <- unlist(strsplit(paren_string, '\\\\s+'))\n  sapply(groups,\
    \ function(group) {\n    stack <- list()\n    max_level <- 0\n    for (i in 1:nchar(group))\
    \ {\n      if (substr(group, i, i) == '(') {\n        level <- length(stack) +\
    \ 1\n        max_level <- max(max_level, level)\n        stack <- append(stack,\
    \ list(level))\n      } else if (substr(group, i, i) == ')') {\n        if (length(stack)\
    \ == 0) {\n          stop('Too many closing parentheses.')\n        }\n      \
    \  stack <- stack[-length(stack)]\n      } else {\n        stop('Invalid character.')\n\
    \      }\n    }\n    if (length(stack) > 0) {\n      stop('Too many opening parentheses.')\n\
    \    }\n    max_level\n  })\n}\n\nparse_nested_parens('(()()) ((())) () ((())()())')\n",
  "\n  \n  # Strip all spaces\n  paren_string <- gsub('\\\\s', '', paren_string)\n\
    \  \n  # Split the string into groups\n  groups <- strsplit(paren_string, '\\\\\
    )\\\\(')\n  \n  # Find the depth for each group\n  depth <- 0\n  max_depth <-\
    \ 0\n  max_depths <- integer(length(groups))\n  for (i in 1:length(groups)) {\n\
    \    group <- groups[[i]]\n    group <- gsub('\\\\(', '', group)\n    for (j in\
    \ 1:nchar(group)) {\n      char <- substr(group, j, j)\n      if (char == '(')\
    \ {\n        depth <- depth + 1\n      } else if (char == ')') {\n        depth\
    \ <- depth - 1\n      }\n      if (depth > max_depth) {\n        max_depth <-\
    \ depth\n      }\n    }\n    max_depths[i] <- max_depth\n    max_depth <- 0\n\
    \    depth <- 0\n  }\n  \n  # Return the vector of maximum depths\n  return(max_depths)\n\
    }", "\n    paren_string <- unlist(strsplit(paren_string, \" \"))\n    lapply(paren_string,\
    \ function(x) {\n        x <- strsplit(x, \"\")[[1]]\n        paren_level <- cumsum(ifelse(x\
    \ == \"(\", 1, ifelse(x == \")\", -1, 0)))\n        max(paren_level)\n    })\n\
    }\n", "\n  paren_list <- strsplit(paren_string, \" \")[[1]]\n  levels <- NULL\n\
    \  for (i in seq_along(paren_list)) {\n    paren_count <- str_count(paren_list[i],\
    \ \"\\\\(\")\n    levels <- c(levels, paren_count)\n  }\n  levels\n}\n", "\n \
    \ paren_string <- strsplit(paren_string, \" \")[[1]]\n  dnest <- unlist(lapply(paren_string,\
    \ nested_parens))\n  return(dnest)\n}\n", "\n  # Your code here\n  stack <- NULL\n\
    \  depth <- 0\n  max <- -Inf\n  depths <- NULL\n  for (i in 1:nchar(paren_string))\
    \ {\n    if (substr(paren_string, i, i) == \"(\") {\n      depth <- depth + 1\n\
    \      stack <- c(stack, \"(\")\n    } else if (substr(paren_string, i, i) ==\
    \ \")\") {\n      if (stack[length(stack)] == \"(\") {\n        stack <- stack[-length(stack)]\n\
    \        depths <- c(depths, depth)\n        if (depth > max) {\n          max\
    \ <- depth\n        }\n        depth <- depth - 1\n      }\n    }\n  }\n  if (max\
    \ == -Inf) {\n    return(c(0))\n  }\n  return(depths)\n}\n\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n    unlist(lapply(strsplit(paren_string, ' ')[[1]],\
    \ function(x) {\n        max(unlist(lapply(x, function(a) {\n            if (a=='(')\
    \ \n                return(0)\n            if (a==')') \n                return(0)\n\
    \            else \n                return(NA)\n        }))) + 1\n    }))\n}\n",
  "\n  # Write your code here\n\n  levels <- str_count(paren_string,\"(\")-str_count(paren_string,\"\
    )\")\n  levels <- levels+1\n  levels\n}\n", "\n  # Your code here\n}\n", "\n \
    \ if(typeof(paren_string) != 'character') stop('Input is not a string.')\n  if(!(grepl('[()]',\
    \ paren_string))) stop('Input contains no parentheses.')\n  if(length(nchar(paren_string))\
    \ > 1) stop('Input is not a string.')\n  paren_list <- strsplit(gsub('[^()]',\
    \ '', paren_string), '')[[1]]\n  longest_paren <- 0\n  current_paren <- 0\n  for(i\
    \ in 1:length(paren_list)) {\n    if(paren_list[i] == '(') {\n      current_paren\
    \ <- current_paren + 1\n    } else {\n      current_paren <- current_paren - 1\n\
    \    }\n    if(current_paren > longest_paren) {\n      longest_paren <- current_paren\n\
    \    }\n  }\n  return(longest_paren)\n}\n", "\n    parse_nested_parens_helper(paren_string,\
    \ 0)\n}\n", "\n    list(levels_in_group(paren_string))\n}\n\nlevels_in_group <-\
    \ function(group) {\n    level <- 0\n    max_level <- 0\n    for (i in strsplit(group,\
    \ \"\")[[1]]) {\n        if (i == \"(\") {\n            level <- level + 1\n \
    \       } else if (i == \")\") {\n            level <- level - 1\n        }\n\
    \        if (level > max_level) {\n            max_level <- level\n        }\n\
    \    }\n    max_level\n}\n", "\n    # Implement this function\n}\n ", "\n    #\
    \ If the input is a character string, then convert it to a vector of strings\n\
    \    if (is.character(paren_string)) {\n        paren_string <- strsplit(paren_string,\
    \ \" \")[[1]]\n    }\n    # In case there is only one group of parentheses passed,\
    \ let's convert it to a vector of length 1.\n    if (is.character(paren_string))\
    \ {\n        paren_string <- c(paren_string)\n    }\n    # Now we are ready to\
    \ proceed. For each group of parentheses, calculate the depth of nesting.\n  \
    \  nested_parens <- vector()\n    for (i in 1:length(paren_string)) {\n      \
    \  nested_parens[i] <- parse_nested_parens_single(paren_string[i])\n    }\n  \
    \  return(nested_parens)\n}\n", "\n    max(mapply(function(x) length(gregexpr('\\\
    \\(', x)[[1]]), strsplit(paren_string, split=' ')))\n}\n", "\n  max_nest <- function(x)\
    \ {\n    max(str_count(str_extract(x, perl('\\\\(.*?\\\\)')), '\\\\('))\n  }\n\
    \  return(sapply(strsplit(paren_string, ' ')[[1]], max_nest))\n}\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n    # If paren_string is \"\" (i.e. empty string),\
    \ return empty vector c().\n    if (paren_string == \"\") {\n        return(c())\n\
    \    }\n    depth_list <- c()\n    depth <- 0\n    for (i in seq_along(paren_string))\
    \ {\n        if (paren_string[i] == '(') {\n            depth <- depth + 1\n \
    \       } else if (paren_string[i] == ')') {\n            depth <- depth - 1\n\
    \        }\n        if (paren_string[i] == ' ') {\n            depth_list <- c(depth_list,\
    \ depth)\n            depth <- 0\n        }\n    }\n    return(depth_list)\n}",
  "\n    nested_parens <- function(string) {\n        levels <- 0\n        max_levels\
    \ <- 0\n        for (c in string) {\n            if (c == '(') {\n           \
    \     levels <- levels + 1\n                if (levels > max_levels) {\n     \
    \               max_levels <- levels\n                }\n            } else if\
    \ (c == ')') {\n                levels <- levels - 1\n            }\n        }\n\
    \        return(max_levels)\n    }\n    return(sapply(strsplit(paren_string, '\\\
    \\s+'), nested_parens))\n}\nparse_nested_parens('(()()) ((())) () ((())()())')\n",
  "\n  trimws(unlist(strsplit(paren_string, \" \"))) %>%\n    stringr::str_count(regex\
    \ = '\\\\(') %>%\n    max(na.rm = TRUE)\n}\n", "\n  ## Comment the next line and\
    \ fill in the rest of the function yourself\n  #stop(\"Not implemented\")\n  \n\
    \  # split paren_string into individual parens\n  parens <- strsplit(paren_string,\
    \ \" \")[[1]]\n  \n  # create placeholder for results\n  results <- numeric(length(parens))\n\
    \  \n  # loop through parens and evaluate\n  for (paren in parens) {\n    \n \
    \   # Create counter variable to count parentheses\n    paren_counter <- 0\n \
    \   \n    # place holder to count the maximum number of open parentheses\n   \
    \ max_paren <- 0\n    \n    # loop through parenthese in each group\n    for (this_paren\
    \ in strsplit(paren, \"\")[[1]]) {\n      \n      # if open parenthese, increase\
    \ counter\n      if (this_paren == \"(\") {\n        paren_counter <- paren_counter\
    \ + 1\n        \n        # update the max if larger\n        if (paren_counter\
    \ > max_paren) {\n          max_paren <- paren_counter\n        }\n      }\n \
    \     \n      # if closed parenthese, decrease counter\n      if (this_paren ==\
    \ \")\") {\n        paren_counter <- paren_counter - 1\n      }\n    }\n    \n\
    \    # put the max in the results\n    results[length(results)] <- max_paren\n\
    \  }\n  \n  # return results\n  return(results)\n}\n", "\n  paren_array <- strsplit(paren_string,\
    \ \" \")[[1]]\n  return(unlist(lapply(paren_array, function(x) {max(paren_count(x))})))\n\
    }\n", "\n  gsub(\"\\\\)\", \" )\", paren_string) %>%\n    strsplit(split = \"\
    \ \") %>%\n    lapply(function(x) {\n      i <- which(x == \")\")\n      if (length(i)\
    \ == 0) {\n        1\n      } else {\n        max(sapply(i, function(x) {\n  \
    \        j <- seq(x)\n          j[which(x - j == unlist(lapply(j, function(x)\
    \ {\n            sum(x - 1 > i)\n          })))]\n        }))\n      }\n    })\n\
    }\n", "\n    paren_string_list <- strsplit(paren_string, ' ')[[1]]\n    nest_levels\
    \ <- sapply(paren_string_list, function(paren_string) {\n        paren_count <-\
    \ length(regexpr('\\\\(', paren_string))\n        if (paren_count == 0) {\n  \
    \          return(0)\n        } else {\n            return(max(cumsum(strsplit(paren_string,\
    \ '')[[1]] == '(') - cumsum(strsplit(paren_string, '')[[1]] == ')')))\n      \
    \  }\n    })\n    return(nest_levels)\n}\nparse_nested_parens('(()()) ((())) ()\
    \ ((())()())')\n", "\n    count <- 0\n    max <- 0\n    result <- numeric(0)\n\
    \    for (char in paren_string) {\n        if (char == '(') {\n            count\
    \ <- count + 1\n            if (count > max) {\n                max <- count\n\
    \            }\n        } else if (char == ')') {\n            count <- count\
    \ - 1\n        } else if (char == ' ') {\n            result <- c(result, max)\n\
    \            max <- 0\n        }\n    }\n    result <- c(result, max)\n    return(result)\n\
    }", "\n  paren_string %>% \n    strsplit(split = ' ') %>% \n    unlist() %>% \n\
    \    str_count(pattern = '\\\\(') - str_count(pattern = '\\\\)')\n}\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n  # first, split the string by spaces, then calculate\
    \ the depth for each group\n  (split_paren_string <- strsplit(paren_string, '\
    \ '))[[1]] %>% \n    map(calc_paren_depth)\n}\n", "\n    split_parens <- unlist(strsplit(paren_string,\
    \ \" \"))\n    nest_levels <- sapply(split_parens, function(x) {\n        nest_lvl\
    \ <- 0\n        max_nest_lvl <- 0\n        for (i in 1:nchar(x)) {\n         \
    \   char <- substr(x, i, i)\n            if (char == \"(\") {\n              \
    \  nest_lvl <- nest_lvl + 1\n            } else if (char == \")\") {\n       \
    \         nest_lvl <- nest_lvl - 1\n            }\n            if (nest_lvl >\
    \ max_nest_lvl) {\n                max_nest_lvl <- nest_lvl\n            }\n \
    \       }\n        return(max_nest_lvl)\n    })\n    return(nest_levels)\n}\n",
  "\n  depth <- integer(0)\n  level <- 0\n  for (p in unlist(strsplit(paren_string,\
    \ ' '))) {\n    for (i in seq_along(p)) {\n      level <- ifelse(p[i] == '(',\
    \ level + 1, level - 1)\n      if (level > length(depth)) {\n        depth <-\
    \ c(depth, level)\n      }\n    }\n    depth <- c(depth, 0)\n    level <- 0\n\
    \  }\n  return(depth)\n}\n\ncat('Convert question marks to NA in tree_data$A7')\n\
    tree_data$A7[tree_data$A7 == '?'] <- NA\n\ncat('Convert question marks to NA in\
    \ tree_data$A14')\ntree_data$A14[tree_data$A14 == '?'] <- NA\n\ncat('Convert height\
    \ and weight to numeric')\ntree_data$A9 <- as.numeric(tree_data$A9)\ntree_data$A10\
    \ <- as.numeric(tree_data$A10)\n\ncat('Convert group string to nested parens')\n\
    tree_data$A11 <- parse_nested_parens(tree_data$A11)\n\ncat('Convert A15 to numeric')\n\
    tree_data$A15 <- as.numeric(tree_data$A15)\n\ncat('Convert number to numeric')\n\
    tree_data$number <- as.numeric(tree_data$number)\n\ncat('Formatting complete!')\n",
  "\n    # split the input string by space\n    paren_string_split <- strsplit(paren_string,\
    \ ' ')\n    paren_string_split_list <- paren_string_split[[1]]\n    paren_string_split_list\
    \ <- paren_string_split_list[paren_string_split_list != '']\n\n    # initialize\
    \ a vector to store the maximum number of nesting levels\n    nest_vec <- c()\n\
    \n    # iterate through each group of parentheses\n    for (paren_seq in paren_string_split_list)\
    \ {\n        # initialize a variable to keep track of nesting levels\n       \
    \ nest_level <- 0\n        # initialize a variable to keep track of the maximum\
    \ nesting level\n        max_nest_level <- 0\n\n        # iterate through each\
    \ parentheses in the group\n        for (paren in paren_seq) {\n            #\
    \ if the current parentheses is an opening one\n            if (paren == '(')\
    \ {\n                # increment the number of nesting levels\n              \
    \  nest_level <- nest_level + 1\n                # if the current number of nesting\
    \ levels is greater than the maximum\n                if (nest_level > max_nest_level)\
    \ {\n                    # update the maximum number of nesting levels\n     \
    \               max_nest_level <- nest_level\n                }\n            }\
    \ else {\n                # if the current parentheses is a closing one\n    \
    \            # decrement the number of nesting levels\n                nest_level\
    \ <- nest_level - 1\n            }\n        }\n\n        # add the maximum number\
    \ of nesting levels to the vector\n        nest_vec <- c(nest_vec, max_nest_level)\n\
    \    }\n\n    # return the vector\n    return(nest_vec)\n}", "\n\t# remove all\
    \ non-parentheses\n\tparen_string <- stringr::str_replace_all(paren_string, '[^()]',\
    \ '')\n\t# use regex to find all parentheses pairs\n\tsubstr_l_paren <- stringr::str_subset(paren_string,\
    \ '(?<=\\\\()')\n\tsubstr_r_paren <- stringr::str_subset(paren_string, '(?=\\\\\
    ))')\n\t# get the position (index) of l and r parentheses\n\tl_paren_pos <- stringr::str_locate_all(paren_string,\
    \ '\\\\(')[[1]][, 1]\n\tr_paren_pos <- stringr::str_locate_all(paren_string, '\\\
    \\)')[[1]][, 1]\n\t# get the index of l and r parentheses\n\tl_paren_index <-\
    \ match(substr_l_paren, paren_string)\n\tr_paren_index <- match(substr_r_paren,\
    \ paren_string)\n\t# get the minimum distance between l and r parentheses\n\t\
    min_paren_dist <- unlist(mapply(function(i, j) min(abs(i - j)), l_paren_pos, r_paren_pos))\n\
    \tmin_paren_dist <- min_paren_dist[l_paren_index == r_paren_index]\n\treturn(min_paren_dist)\n\
    }\n", "\n  # Your code here!\n  return(NULL)\n}\n", "\n    unlist(lapply(strsplit(paren_string,\
    \ ' ')[[1]], function(paren_group) {\n        gr <- grep('\\\\(', paren_group)\n\
    \        gl <- grep('\\\\)', paren_group)\n        if (length(gr) == 0 || length(gl)\
    \ == 0) {\n            return(0)\n        }\n        gl <- gl[order(gl)]\n   \
    \     gr <- gr[order(gr)]\n        if (gr[1] > gl[1]) {\n            return(0)\n\
    \        }\n        res <- c(0)\n        i <- 1\n        j <- 1\n        while\
    \ (i <= length(gr) && j <= length(gl)) {\n            if (gr[i] < gl[j]) {\n \
    \               res[i] <- res[i] + 1\n                i <- i + 1\n           \
    \ } else {\n                i <- i + 1\n                j <- j + 1\n         \
    \   }\n        }\n        return(max(res))\n    }))\n}\nimport re\n\ndef parse_nested_parens(paren_string):\n\
    \    return [max(map(lambda x: len(re.findall('\\(', x)), re.findall('[^\\(]*\\\
    ([^\\)]*\\)[^\\)]*', x))) for x in paren_string.split(' ')]\n\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n  cat(paren_string, '\\n')\n  n_parens <- str_count(paren_string,\
    \ '(|)')\n  # e.g. c(0, 1, 1, 2, 2, 3, 3, 2, 2, 1, 1, 0)\n  paren_counts <- cumsum(str_count(str_split(paren_string,\
    \ ' ')[[1]], '(|)'))\n  # e.g. c(0, 1, 2, 3, 3, 3, 3, 2, 2, 1, 1, 0)\n  paren_counts\
    \ <- paren_counts - sequence(n_parens)\n  # e.g. c(F, T, T, T, F, F, F, T, T,\
    \ T, F, F)\n  paren_counts <- paren_counts == max(paren_counts)\n  # e.g. c(F,\
    \ T, T, T, F, F, F, T, T, T, F, F)\n  str_sub(paren_string, paren_counts, paren_counts\
    \ + 1)\n}\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n    # Your\
    \ code here\n    level <- function(x){\n        max(str_count(x, \"\\\\(\"),str_count(x,\
    \ \"\\\\)\"))\n    }\n    vapply(strsplit(paren_string, \" \")[[1]], level, FUN.VALUE\
    \ = 1)\n    \n}\n", "\n  paren_split <- strsplit(paren_string, ' ')[[1]]\n  return(lapply(paren_split,\
    \ function(x) {\n    stack <- 0\n    max_stack <- 0\n    for (c in x) {\n    \
    \  if (c == '(') {\n        stack <- stack + 1\n      } else if (c == ')') {\n\
    \        stack <- stack - 1\n      }\n      if (stack > max_stack) {\n       \
    \ max_stack <- stack\n      }\n    }\n    return(max_stack)\n  }))\n}\n", "\n\
    \  \n  # Empty character vector to store output\n  out <- character()\n  \n  #\
    \ Split the string into groups for nested parentheses\n  groups <- strsplit(paren_string,\
    \ ' ')[[1]]\n  \n  # Iterate through each group\n  for (group in groups) {\n \
    \   \n    # Initialise a counter for levels of nesting\n    count <- 0\n    \n\
    \    # Iterate through each character of the group\n    for (char in group) {\n\
    \      \n      # If the character is an opening parenthesis increment the counter\
    \ by 1\n      if (char == '(') {\n        count <- count + 1\n        \n     \
    \ # Else if the character is a closing parenthesis decrement the counter by 1\n\
    \      } else if (char == ')') {\n        count <- count - 1\n      }\n    }\n\
    \    \n    # Append the output character vector with the current count of levels\
    \ of nesting\n    out <- c(out, count)\n  }\n  \n  # Return the output\n  return(out)\n\
    }\n", "\n  # split multiple groups\n  groups <- strsplit(paren_string, '\\\\s+')[[1]]\n\
    \  # For each group, count the number of ( and )\n  paren_levels <- sapply(groups,\
    \ function(grp) {\n    paren_count <- sapply(grp, function(c) {\n      if (c ==\
    \ '(') 1 else if (c == ')') -1 else 0\n    })\n    # Find the maximum absolute\
    \ value of cumulative sum of paren_count\n    # This is the deepest level of nesting\n\
    \    max(abs(cumsum(paren_count)))\n  })\n  return(paren_levels)\n}\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')", "\n    # Your code goes here\n    paren_string <- gsub('\\\
    \\)\\\\(', ' ', paren_string)\n    paren_string <- gsub('\\\\)', ' ', paren_string)\n\
    \    paren_string <- gsub('\\\\(', ' ', paren_string)\n    lapply(strsplit(as.character(paren_string),\
    \ ' '), function(x) max(nchar(x)))\n}\nparse_nested_parens('(()()) ((())) () ((())()())')\n",
  "\n    unlist(lapply(strsplit(paren_string, \" \")[[1]], function(paren_group) {\n\
    \        n <- nchar(paren_group)\n        if(paren_group[1] != '(' | paren_group[n]\
    \ != ')') {\n            return(0)\n        }\n\n        depth <- 0\n        max_depth\
    \ <- 0\n        for(i in 1:n) {\n            if(paren_group[i] == '(') {\n   \
    \             depth <- depth + 1\n            } else if(paren_group[i] == ')')\
    \ {\n                depth <- depth - 1\n            }\n            if(depth >\
    \ max_depth) {\n                max_depth <- depth\n            }\n        }\n\
    \        return(max_depth)\n    }))\n}\n\nif (__name__ == '__main__') {\n    import\
    \ doctest\n    doctest.testmod()", "\n  paren_string %>% stringr::str_split('\
    \ ') %>% \n    map(.f = ~ .x %>% \n           stringr::str_match_all(pattern =\
    \ '\\\\([^()]*\\\\)') %>% \n           unlist() %>% unname() %>% \n          \
    \ stringr::str_length() %>% max())\n}\n", "\n    # split string into individual\
    \ groups\n    split_parens <- strsplit(paren_string, \" \")[[1]]\n    # Find deepest\
    \ nesting level using regular expression to match\n    # all nested parentheses.\n\
    \    levels <- sapply(split_parens, function(x) {\n        match_par <- regexpr('\\\
    \\(((?:[^()]|(?R))*)\\\\)', x)\n        if (is.na(match_par)) {\n            return(0)\n\
    \        } else {\n            return(max(nchar(regmatches(x, match_par))))\n\
    \        }\n    })\n    return(levels)\n}", "\n  # Solution\n}\n", "\n    s <-\
    \ strsplit(paren_string, split = ' ')[[1]]\n    lapply(s, count_parens)\n}\n\n\
    count_parens <- function(p) {\n    d <- max(find_depth(p))\n    if (any(d < 0))\
    \ 0 else d\n}\n\nfind_depth <- function(p) {\n    d <- 0\n    depths <- integer(0)\n\
    \    for (c in strsplit(p, split = \"\")[[1]]) {\n        if (c == '(') {\n  \
    \          d <- d + 1\n        } else if (c == ')') {\n            depths <- c(depths,\
    \ d)\n            d <- d - 1\n        }\n    }\n    depths\n}\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n  # Extract each group for nested parentheses\
    \ and determine maximum nesting\n  map_int(strsplit(paren_string, ' ')[[1]], function(x)\
    \ {\n    if(length(x) == 0) {\n      0\n    } else {\n      # Determine maximum\
    \ nesting by counting the number of opening parentheses\n      x = count_parens(x)\n\
    \      x[x=='('] <- 0\n      sum(x, na.rm=TRUE)\n    }\n  })\n}\n", "\n  unlist(lapply(strsplit(paren_string,\
    \ ' ')[[1]], function(x) {max(unlist(strsplit(x, '')) %in% '(') - 1}))\n}\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n    paren_list <- strsplit(paren_string, ' ')\n\
    \    out <- vector('integer', length(paren_list))\n    for (i in seq_along(paren_list))\
    \ {\n        max_level <- 0\n        curr_level <- 0\n        for (ch in paren_list[[i]])\
    \ {\n            if (ch == '(') {\n                curr_level <- curr_level +\
    \ 1\n            } else if (ch == ')') {\n                curr_level <- curr_level\
    \ - 1\n            }\n            if (curr_level > max_level) {\n            \
    \    max_level <- curr_level\n            }\n        }\n        out[i] <- max_level\n\
    \    }\n    return(out)\n}\nparse_nested_parens('(()()) ((())) () ((())()())')\n",
  "\n    # Get the match index of the '(' and ')' in the string\n    match_parens\
    \ <- gregexpr('([()])', paren_string)\n    # Check if the first bracket is opening\
    \ or closing.\n    # If it is opening, then the match for '(', which is the odd\
    \ numbered indices of match_parens[[1]]\n    # will start from the 1st index of\
    \ match_parens[[1]]\n    # Else if it is closing, then the match for '(' will\
    \ start from the 2nd index of match_parens[[1]]\n    start_opening <- grep('\\\
    \\(', paren_string)\n    start_opening <- ifelse(start_opening == 1, 1, 2)\n \
    \   # Get the match index of '('\n    opening_parens <- match_parens[[1]][c(start_opening,\
    \ seq(3, length(match_parens[[1]]), 2))]\n    # Get the match index of ')'\n \
    \   closing_parens <- match_parens[[1]][c(start_opening + 1, seq(4, length(match_parens[[1]]),\
    \ 2))]\n    # Get the maximum nesting level\n    max_nesting <- function(opening_i,\
    \ closing_i) {\n        # If there is no pair of '(' and ')', then the nesting\
    \ level is zero\n        if (length(opening_i) == 0) {\n            max_level\
    \ <- 0\n        } else {\n            # Nesting level is the difference between\
    \ index of the first '(' and index of the first ')'\n            # in the string\n\
    \            max_level <- closing_i[1] - opening_i[1]\n        }\n        return(max_level)\n\
    \    }\n    # Map the function max_nesting to the lists of opening and closing\
    \ indexes for all the groups\n    # in the parentheses string\n    sapply(strsplit(paren_string,\
    \ ' '), function(paren_i) max_nesting(opening_parens[paren_i], closing_parens[paren_i]))\n\
    }\n", "\n  # Split multiple groups into separate strings\n  all_groups <- strsplit(paren_string,\
    \ ' ')[[1]]\n  count_levels <- function(group) {\n    # Match the string for all\
    \ left parentheses\n    # The number of left parentheses is equal to the maximum\
    \ level of nesting\n    level <- length(gregexpr('\\\\(', group)[[1]])\n    return(level)\n\
    \  }\n  # Apply count_levels on each group\n  levels <- sapply(all_groups, count_levels)\n\
    \  return(levels)\n}\n \nparse_nested_parens('(()()) ((())) () ((())()())')\n",
  "\n  levels <- 0\n  result <- NULL\n  for (i in 1:nchar(paren_string)) {\n    if\
    \ (substr(paren_string, i, i) == \"(\") {\n      levels <- levels + 1\n    } else\
    \ if (substr(paren_string, i, i) == \")\") {\n      levels <- levels - 1\n   \
    \ } else if (substr(paren_string, i, i) == \" \") {\n      result <- c(result,\
    \ levels)\n      levels <- 0\n    }\n  }\n  result\n}\n ", "\n  # TODO: Write\
    \ code to parse the nested parentheses here\n}\n", "\n    split_parens <- strsplit(paren_string,\
    \ \" \")[[1]]\n    num_parens <- sapply(split_parens, function(x) {\n        num_paren\
    \ <- 0\n        max_paren <- 0\n        for (i in 1:nchar(x)) {\n            if\
    \ (substr(x, i, i) == \"(\") {\n                num_paren <- num_paren + 1\n \
    \           } else if (substr(x, i, i) == \")\") {\n                num_paren\
    \ <- num_paren - 1\n            }\n            if (num_paren > max_paren) {\n\
    \                max_paren <- num_paren\n            }\n        }\n        return(max_paren)\n\
    \    })\n    return(num_parens)\n}\n", "\n  # TO DO\n  res <- unlist(strsplit(gsub(\"\
    \ \", \"\", paren_string), \"\\\\)\", fixed = TRUE))\n  res1 <- gsub(\"\\\\(\"\
    , \"\", res)\n  res2 <- gsub(\" \", \"\", res1)\n  max(nchar(res2))\n}\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n    # TODO: replace the next line with your code\n\
    \    stop(\"Not Implemented\")\n}\n", "\n  # 1. split string into a vector of\
    \ character strings separated by space\n  parts <- strsplit(paren_string, ' ')\n\
    \  # 2. for each part, use the stack method to find the maximum depth of parenthesis\n\
    \  # 2.1 create an empty stack\n  stack <- vector('list', length = 0)\n  # 2.2\
    \ loop through each character in a part\n  # 2.2.1 if an opening parenthesis,\
    \ push it to the stack\n  # 2.2.2 if a closing parenthesis, pop an opening parenthesis\
    \ from the stack\n  # 2.2.3 if we have an empty stack and still have closing parentheses,\
    \ push a 0 and continue\n  # 2.3 after finishing a part, the length of the stack\
    \ is the maximum depth of parenthesis\n  stack_len <- lapply(parts, function(part)\
    \ {\n    for (c in part) {\n      if (c == '(') {\n        stack <- c(stack, c)\n\
    \      } else if (c == ')') {\n        if (length(stack) == 0) {\n          stack\
    \ <- c(stack, 0)\n        } else {\n          stack <- stack[-length(stack)]\n\
    \        }\n      }\n    }\n    length(stack)\n  })\n  # 3. return the results\
    \ as a vector\n  unlist(stack_len)\n}\ntest_that('parse_nested_parens function\
    \ works properly', {\n  expect_equal(parse_nested_parens('(()()) ((())) () ((())()())'),\
    \ c(2, 3, 1, 3))\n})\n ", "\n    paren_str_split <- strsplit(paren_string, \"\
    \ \")[[1]]\n    # If a character is a '(', then push it in a stack.\n    # If\
    \ a character is a ')', then pop from the stack and \n    # add the current count\
    \ of open parentheses to the result.\n    paren_index <- 0\n    paren_index_vec\
    \ <- c()\n    for (paren_seq in paren_str_split) {\n        for (paren_char in\
    \ strsplit(paren_seq, \"\")[[1]]) {\n            if (paren_char == \"(\") {\n\
    \                paren_index <- paren_index + 1\n            } else if (paren_char\
    \ == \")\") {\n                paren_index_vec <- c(paren_index_vec, paren_index)\n\
    \                paren_index <- paren_index - 1\n            }\n        }\n  \
    \  }\n    return(paren_index_vec)\n}\n", "\n    data_list <- strsplit(paren_string,\
    \ split = ' ')[[1]]\n\n    data_frame(max_level = sapply(data_list, max_level_in_parens))\n\
    }\n", "\n  paren_list <- unlist(strsplit(paren_string, ' '))\n  parse_parens <-\
    \ function(s) {\n    max_nest <- 0\n    curr_nest <- 0\n    for (char in unlist(strsplit(s,\
    \ ''))) {\n      if (char == '(') {\n        curr_nest <- curr_nest + 1\n    \
    \  } else if (char == ')') {\n        curr_nest <- curr_nest - 1\n      }\n  \
    \    if (curr_nest > max_nest) {\n        max_nest <- curr_nest\n      }\n   \
    \ }\n    return(max_nest)\n  }\n  res <- sapply(paren_list, parse_parens)\n  return(res)\n\
    }\n\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n    #'\n    # This\
    \ function receives a vector of strings with multiple groups of parentheses.\n\
    \    # It returns a vector of the depth of each group.\n    #\n    library(stringr)\n\
    \    library(tidyverse)\n    # Check that parentheses are balanced\n    if (str_count(paren_string,\
    \ '(') != str_count(paren_string, ')')) {\n        return(\"There's an error,\
    \ parentheses are not balanced.\")\n    }\n    # If balanced, extract the parentheses\
    \ in a list.\n    # The list will contain each of the strings with a group of\
    \ parentheses.\n    paren_list <- str_match_all(paren_string, '\\\\([^()]*\\\\\
    )') %>% unlist()\n    # Define the maximum depth of parentheses in each group.\n\
    \    # Initally assign the maximum depth as 0.\n    max_depth <- 0\n    paren_depth\
    \ <- c()\n    # For each group of parentheses\n    for (group in paren_list) {\n\
    \        # Check if the group is empty (i.e. () )\n        if (group == \"()\"\
    ) {\n            # This is the base case, a single set of parentheses has depth\
    \ 1.\n            paren_depth <- c(paren_depth, 1)\n        } else {\n       \
    \     # First, remove all outer parentheses.\n            group <- str_replace(group,\
    \ '^\\\\(|\\\\)$', '')\n            # Check if the remaining string is empty.\n\
    \            if (str_length(group) == 0) {\n                # This is the base\
    \ case, a single set of parentheses has depth 1.\n                paren_depth\
    \ <- c(paren_depth, 1)\n            } else {\n                # Then, reapeat\
    \ the process while the string is not empty.\n                while (str_length(group)\
    \ > 0) {\n                    # Remove outer parentheses, increment depth and\
    \ repeat.\n                    group <- str_replace(group, '^\\\\(|\\\\)$', '')\n\
    \                    max_depth <- max_depth + 1\n                }\n         \
    \       # The depth should be always even, since we remove two parentheses in\
    \ each iteration.\n                max_depth <- max_depth + 1\n              \
    \  # The depth is equal to the maximum depth + 1, since", "\n  groups <- strsplit(paren_string,\
    \ ' ')[[1]]\n  num_levels <- sapply(groups, function(group) {\n    num_opening\
    \ <- sapply(strsplit(group, '')[[1]],\n                          function(c) c\
    \ == '(')\n    max(cumsum(num_opening) - cumsum(!num_opening))\n  })\n  num_levels\n\
    }\n", "\n    # capture by group, the group at a time\n    result <- str_match(paren_string,\
    \ \"([()]+)|([^()]+)\")\n    # these are in a column, need to convert to a vector\n\
    \    # so we can just use the length function\n    length(result[result != ''])\n\
    }\n", "\n    paren_list <- strsplit(paren_string, ' ')\n    max_count <- vector()\n\
    \    for (i in paren_list) {\n        paren_stack <- numeric()\n        for (j\
    \ in 1:length(i[[1]])) {\n            if (i[[1]][j] == '(') {\n              \
    \  paren_stack <- c(paren_stack, j)\n            } else if (i[[1]][j] == ')')\
    \ {\n                if (length(paren_stack) == 0) {\n                    print('not\
    \ nested properly')\n                    return(NULL)\n                } else\
    \ {\n                    paren_stack <- paren_stack[-length(paren_stack)]\n  \
    \              }\n            }\n        }\n        if (length(paren_stack) !=\
    \ 0) {\n            print('not nested properly')\n            return(NULL)\n \
    \       }\n        max_count <- c(max_count, length(paren_stack))\n    }\n   \
    \ return(max_count)\n}\nparen_string <- '(()()) ((())) () ((())()())'\nmax_count\
    \ <- parse_nested_parens(paren_string)\nmax_count\n ", "\n    # Replace each pair\
    \ of parentheses with the number of layers of nesting it represents.\n    parsed_parens\
    \ <- gsub('\\\\((\\\\)|\\\\))', \"\\\\1\", paren_string)\n    # Find the maximum\
    \ number of layers of nesting, which is the maximum number of items in one of\
    \ the groups.\n    sapply(strsplit(parsed_parens, ' '), function(x) max(table(x)))\n\
    }\n", "\n    # Define a vector of characters to store the parens and group\n \
    \   paren_vec <- strsplit(paren_string, \" \")[[1]]\n    # Initialize vector to\
    \ store output\n    deepest_parens <- c()\n    # Iterate over each group\n   \
    \ for (paren in paren_vec) {\n        # Set a counter to count the deepest level\
    \ of parens\n        count <- 0\n        # Set a max to keep track of the deepest\
    \ level\n        max <- 0\n        # Iterate over each character in the group\n\
    \        for (ch in paren) {\n            # If the character is an open paren,\
    \ increment counter\n            if (ch == \"(\") {\n                count <-\
    \ count + 1\n            }\n            # If the character is a close paren, decrement\
    \ counter\n            if (ch == \")\") {\n                count <- count - 1\n\
    \            }\n            # If the count is greater than the max, update the\
    \ max\n            if (count > max) {\n                max <- count\n        \
    \    }\n        }\n        # Append the max to the output vector\n        deepest_parens\
    \ <- c(deepest_parens, max)\n    }\n    return(deepest_parens)\n}\n\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n  # store the strings in a vector\n  paren_vector\
    \ <- strsplit(paren_string, ' ')[[1]]\n  # calculate the depth of each group\n\
    \  depths <- lapply(paren_vector, function(x) depth(x))\n  # return the depths\n\
    \  return(depths)\n}\n", "\n    tapply(paren_string, gregexpr('\\\\(', paren_string)\
    \ - 1, function(x) {\n        sum(unlist(strsplit(x, '')) == '(') - sum(unlist(strsplit(x,\
    \ '')) == ')')\n    })\n}\n", "\n    # Length of input string\n    paren_len <-\
    \ length(paren_string)\n    # Keep track of the current group to add results later\n\
    \    curr_group <- 1\n    # Initialize empty vector to hold all the results\n\
    \    result <- integer(0)\n    # Run through the string of parentheses to find\
    \ groups\n    for (i in 1:paren_len) {\n        # If the current position is a\
    \ opening parenthesis,\n        # then increase the current level of nesting\n\
    \        if (paren_string[i] == '(') {\n            curr_group <- curr_group +\
    \ 1\n        }\n        # If the current position is a closing parenthesis,\n\
    \        # then decrease the current level of nesting\n        if (paren_string[i]\
    \ == ')') {\n            curr_group <- curr_group - 1\n        }\n        # If\
    \ the current position is a space,\n        # then add the current level of nesting\
    \ to the results vector\n        if (paren_string[i] == ' ') {\n            result\
    \ <- c(result, curr_group)\n        }\n    }\n    # Remove the first result since\
    \ it's not an actual level of nesting\n    result <- result[-1]\n    # Return\
    \ the vector of levels of nesting\n    return(result)\n}", "\n    # Convert string\
    \ of parens to a list of lists of parens.\n    paren_list <- strsplit(paren_string,\
    \ split = ' ', fixed = TRUE)\n    paren_list <- lapply(paren_list, strsplit, split\
    \ = '', fixed = TRUE)\n    paren_list <- lapply(paren_list, unlist)\n    paren_list\
    \ <- lapply(paren_list, as.vector)\n    paren_list <- lapply(paren_list, as.list)\n\
    \    # Count depth of nested parens for each group.\n    max_depth <- sapply(paren_list,\
    \ paren_depth)\n    # Convert to R vector and return.\n    max_depth <- as.vector(max_depth)\n\
    \    return(max_depth)\n}\n", "\n  # TODO \n  # Please pass\n}\n ", "\n    # YOUR\
    \ CODE HERE\n    g = strsplit(paren_string, ' ')[[1]]\n    parse_nested_parens_aux(g)\n\
    }\n\nparse_nested_parens_aux <- function(g) {\n    if (length(g) == 0) {\n   \
    \     return(NULL)\n    }\n    else {\n        x = g[1]\n        depth = depth_parens(x)\n\
    \        return(c(depth, parse_nested_parens_aux(g[-1])))\n    }\n}\n\ndepth_parens\
    \ <- function(paren_string) {\n    # YOUR CODE HERE\n    level = 0\n    max_level\
    \ = 0\n    for (i in 1:nchar(paren_string)) {\n        if (substr(paren_string,\
    \ i, i) == '(') {\n            level = level + 1\n        }\n        else if (substr(paren_string,\
    \ i, i) == ')') {\n            level = level - 1\n        }\n        if (level\
    \ > max_level) {\n            max_level = level\n        }\n    }\n    return(max_level)\n\
    }\n", "\n    # YOUR CODE HERE\n    depth = -1\n    depth_vec = c()\n    for (ch\
    \ in strsplit(paren_string, \"\")[[1]]) {\n        if (ch == \"(\") {\n      \
    \      depth = depth + 1\n        } else if (ch == \")\") {\n            depth_vec\
    \ = c(depth_vec, depth)\n            depth = depth - 1\n        }\n    }\n   \
    \ return(depth_vec)\n}\nparse_nested_parens('(()()) ((())) () ((())()())')\n",
  "\n    paren_string <- strsplit(paren_string, split = ' ')\n    paren_string <-\
    \ unlist(paren_string)\n    depths <- c()\n    for (i in paren_string) {\n   \
    \     depths <- c(depths, str_count(i, '(()'))\n    }\n    return(depths)\n}\n",
  "\n  levels <- sapply(strsplit(paren_string, ' '), function(x) {\n    match.call(function(...)\
    \ {\n      result <- list(...)\n      result\n    }, as.list(x))[[1]]\n  })\n\
    \  paren_levels <- sapply(levels, function(x) {\n    unlist(lapply(x, function(y)\
    \ {\n      match.call(function(...) {\n        result <- list(...)\n        result\n\
    \      }, as.list(y))[[1]]\n    }))\n  })\n  sapply(paren_levels, function(x)\
    \ {\n    sum(sapply(x, function(y) {\n      sum(ifelse(y == ')', -1, 1))\n   \
    \ }))\n  })\n}\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n  unlist(lapply(strsplit(paren_string,\
    \ ' ')[[1]], count_parens))\n}\n", "\n    # Your code here\n    groups <- strsplit(paren_string,\
    \ ' ')[[1]]\n    max_nest_l <- list()\n    for (i in 1:length(groups)) {\n   \
    \     max_nest <- 0\n        nest <- 0\n        for (j in 1:nchar(groups[i]))\
    \ {\n            if (substr(groups[i], j, j) == '(') {\n                nest <-\
    \ nest + 1\n            } else if (substr(groups[i], j, j) == ')') {\n       \
    \         nest <- nest - 1\n            }\n            if (nest > max_nest) {\n\
    \                max_nest <- nest\n            }\n        }\n        max_nest_l[[i]]\
    \ <- max_nest\n    }\n    return(unlist(max_nest_l))\n}\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n    levels = 0\n    deepest = 0\n    for (char\
    \ in paren_string) {\n        if (char == '(') {\n            levels = levels\
    \ + 1\n        } else if (char == ')') {\n            if (levels > deepest) {\n\
    \                deepest = levels\n            }\n            levels = levels\
    \ - 1\n        }\n    }\n    return(deepest)\n}\n\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n  # create a list of character vectors\n  paren_list\
    \ <- strsplit(paren_string, ' ')\n  # create a vector of level of nesting as 0\n\
    \  paren_levels <- rep(0, length(paren_list))\n  # create a 0/1 vector to record\
    \ whether an opening paren is encountered\n  flag <- c(0)\n  # loop through each\
    \ list element and test whether it contains parentheses and whether the parentheses\
    \ are matched\n  for (i in 1:length(paren_list)) {\n    if (grepl('\\\\(', paren_list[[i]])\
    \ && grepl('\\\\)', paren_list[[i]])) {\n      # set the counter back to 0 when\
    \ a closing paren is encountered\n      paren_list[[i]] <- gsub('\\\\)', ' 0',\
    \ paren_list[[i]])\n      # record whether an opening paren is encountered\n \
    \     flag <- c(flag, 1)\n      # if an opening paren is encountered, add 1 to\
    \ the level of nesting\n      paren_levels[i] <- paren_levels[i-1] + flag[i]\n\
    \    } else {\n      # set the counter back to 0 when no paren is encountered\n\
    \      flag <- c(flag, 0)\n      # if no paren is encountered, the level of nesting\
    \ is the same as the previous one\n      paren_levels[i] <- paren_levels[i-1]\n\
    \    }\n  }\n  # output the maximum level of nesting for each group\n  return(max(paren_levels))\n\
    }\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n  levels <- str_count(paren_string,\
    \ '\\\\(') - str_count(paren_string, '\\\\)')\n  max_level <- max(levels)\n  paren_groups\
    \ <- unlist(strsplit(paren_string, ' '))\n  paren_levels <- sapply(paren_groups,\
    \ function(x) {\n    levels <- str_count(x, '\\\\(') - str_count(x, '\\\\)')\n\
    \    max_level <- max(levels)\n    max_level\n  })\n  paren_levels\n}\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n    # split the string by spaces\n    paren_groups\
    \ <- strsplit(paren_string, ' ')[[1]]\n    # initialize an empty vector to store\
    \ maximum level of nesting\n    levels <- integer(length(paren_groups))\n    #\
    \ iterate through the list of groups\n    for (i in seq_along(paren_groups)) {\n\
    \        # initialize a counter and the maximum level of nesting\n        counter\
    \ <- 0\n        max_level <- 0\n        # for each character in the group\n  \
    \      for (c in paren_groups[i]) {\n            # increment the counter if it's\
    \ an opening paren\n            if (c == '(') counter <- counter + 1\n       \
    \     # otherwise, it's a closing paren so decrement\n            else counter\
    \ <- counter - 1\n            # if counter is greater than the max level, update\n\
    \            if (counter > max_level) max_level <- counter\n        }\n      \
    \  # store the max level in the vector\n        levels[i] <- max_level\n    }\n\
    \    return(levels)\n}\n", "\n  # +1 if open, -1 if close\n  paren_change <- function(c)\
    \ {\n    if (c == '(') {\n      return(1)\n    } else if (c == ')') {\n      return(-1)\n\
    \    } else {\n      stop(\"Unrecognized character\")\n    }\n  }\n  change_vector\
    \ <- lapply(strsplit(paren_string, '')[[1]], paren_change)\n  change_vector <-\
    \ unlist(change_vector)\n  # Do an absolute sum\n  asum_change_vector <- cumsum(abs(change_vector))\n\
    \  # The maximum will be the deepest level.\n  return(max(asum_change_vector))\n\
    }\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n  max_nesting_count\
    \ <- 0\n  depth <- 0\n  for (paren in strsplit(paren_string, '')[[1]]) {\n   \
    \ if (paren == '(') {\n      depth <- depth + 1\n    } else if (paren == ')')\
    \ {\n      depth <- depth - 1\n    }\n    if (depth > max_nesting_count) {\n \
    \     max_nesting_count <- depth\n    }\n  }\n  return(max_nesting_count)\n}\n",
  "\n  # Use stack to track the levels of nesting, push 0 when '(' is met, and +1\
    \ for each additional '(' met\n  # Pop stack whenever ')' is met\n  # Return the\
    \ deepest level in the stack\n\n  num_parens <- unlist(strsplit(paren_string,\
    \ ''))\n  stack <- list()\n  stack[[1]] <- 0\n  max_nesting <- 0\n  num_nesting\
    \ <- 0\n  l <- length(num_parens)\n  # Use while loop to process the character\
    \ vector\n  i <- 1\n  while (i <= l) {\n    ch <- num_parens[i]\n    if (ch ==\
    \ '(') {\n      num_nesting <- num_nesting + 1\n      stack[[length(stack) + 1]]\
    \ <- num_nesting\n    } else if (ch == ')') {\n      if (num_nesting > max_nesting)\
    \ {\n        max_nesting <- num_nesting\n      }\n      stack <- stack[-length(stack)]\n\
    \      num_nesting <- num_nesting - 1\n    }\n    i <- i + 1\n  }\n  return(max_nesting)\n\
    }\n", "\n    # implement this function\n    # replace '1:length(unlist(strsplit(paren_string,\
    \ ' ')))' with your return value\n    return (1:length(unlist(strsplit(paren_string,\
    \ ' '))))\n}\n", "\n  strsplit(paren_string, \" \")[[1]] %>% \n    map(nest_parens)\
    \ %>% \n    unlist()\n}\n \ntest_that(\"test for parse_nested_parens\", {\n  expect_equal(parse_nested_parens('(()())\
    \ ((())) () ((())()())'), c(2, 3, 1, 3))\n})\n \n", "\n  result <- as.list(strsplit(paren_string,\
    \ ' '))\n  for (i in 1:length(result)) {\n    result[[i]] <- max(cumsum(gregexpr('\\\
    \\(', result[[i]])[[1]]))\n  }\n  unlist(result)\n}\n", "\n  paren_list <- strsplit(paren_string,\
    \ split = ' ')[[1]]\n\n  nesting_levels <- sapply(paren_list, FUN = function(curr_paren_group)\
    \ {\n    paren_counts <- sapply(strsplit(curr_paren_group, split = \"\")[[1]],\
    \ FUN = function(curr_char) {\n      if (curr_char == '(') {\n        return(1)\n\
    \      } else if (curr_char == ')') {\n        return(-1)\n      } else {\n  \
    \      return(0)\n      }\n    })\n\n    cum_paren_counts <- cumsum(paren_counts)\n\
    \    return(max(cum_paren_counts))\n  })\n\n  return(nesting_levels)\n}", "\n\
    \    # your code here\n}", "\n    levels =  str_count(paren_string, '\\\\(') -\
    \ str_count(paren_string, '\\\\)')\n    return(levels)\n}\n \nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n    # Create a vector to store the number of nested\
    \ parens for each group\n    num_nested_parens <- numeric(0)\n    # Create a vector\
    \ to represent the number of open parens for each group\n    num_open_parens <-\
    \ numeric(0)\n    # Create a vector to represent the number of closed parens for\
    \ each group\n    num_closed_parens <- numeric(0)\n    # Create a character vector\
    \ to represent the final number of nested parens\n    # for each group\n    final_nested_parens\
    \ <- character(0)\n    # Iterate through the string character by character\n \
    \   for (char in unlist(strsplit(paren_string, \" \"))) {\n        # If the char\
    \ is an open paren, then increment the number of open parens\n        if (char\
    \ == \"(\") {\n            num_open_parens <- num_open_parens + 1\n        }\n\
    \        # If the char is a closed paren, then increment the number of closed\
    \ parens\n        if (char == \")\") {\n            num_closed_parens <- num_closed_parens\
    \ + 1\n        }\n        # If the number of open parens equals the number of\
    \ closed parens,\n        # then all the parens in the current group are properly\
    \ nested and \n        # we can calculate the max level of nesting\n        if\
    \ (num_open_parens == num_closed_parens) {\n            # If the number of open\
    \ parens is 0, then there are no nested parens\n            if (num_open_parens\
    \ == 0) {\n                num_nested_parens <- c(num_nested_parens, 0)\n    \
    \        }\n            # Else there are nested parens so calculate the number\
    \ of nested parens\n            else {\n                num_nested_parens <- c(num_nested_parens,\
    \ num_open_parens / 2)\n            }\n            # Reset the number of open\
    \ and closed parens for the next group\n            num_open_parens <- 0\n   \
    \         num_closed_parens <- 0\n        }\n    }\n    # Iterate through the\
    \ num_nested_parens vector and determine whether there\n   ", "\n  paren_string\
    \ <- strsplit(paren_string, split = ' ')\n  paren_string <- lapply(paren_string,\
    \ function(x) {\n    s <- 0\n    l <- c()\n    for (i in x) {\n      if (i ==\
    \ '(') {\n        s <- s + 1\n      } else if (i == ')') {\n        l <- c(l,\
    \ s)\n        s <- s - 1\n      }\n    }\n    max(l)\n  })\n  unlist(paren_string)\n\
    }\n", "\n  strsplit(paren_string, ' ')[[1]] %>%\n    vapply(str_count, integer(1),\
    \ pattern = '\\\\(')\n}\n", "\n  paren_string <- unlist(strsplit(paren_string,\
    \ ' '))\n  lapply(paren_string, function(x) {\n    stringr::str_count(x, '(')\
    \ - stringr::str_count(x, ')')\n  })\n}\n", "\n  ## if there is no parenthesis\
    \ in the string, return numeric(0)\n  #if ()\n  ## split the string by space\n\
    \  #\n  ## use str_split()\n  #\n  ## use sapply() to compute the max level of\
    \ nesting for each group\n  #\n}\n", "\n    require(stringr)\n    paren_string\
    \ <- str_trim(paren_string)\n    unlist(lapply(str_split(paren_string, \" \"),\
    \ function(x) {\n        str_count(x, pattern = \"\\\\(\") - str_count(x, pattern\
    \ = \"\\\\)\")\n    }))\n}\n", "\n  # TODO\n  paren_counter <- 0\n  max_paren_counter\
    \ <- 0\n  output <- c()\n  for (i in 1:nchar(paren_string)) {\n    if (substr(paren_string,\
    \ i, i) == \"(\") {\n      paren_counter <- paren_counter + 1\n      if (paren_counter\
    \ > max_paren_counter) {\n        max_paren_counter <- paren_counter\n      }\n\
    \    } else if (substr(paren_string, i, i) == \")\") {\n      if (paren_counter\
    \ == max_paren_counter) {\n        output <- c(output, max_paren_counter)\n  \
    \      max_paren_counter <- 0\n      }\n      paren_counter <- paren_counter -\
    \ 1\n    }\n  }\n  return(output)\n}\n", "\n  # all_parens will store all indices\
    \ of opening and closing parens\n  all_parens <- c()\n  # start index of current\
    \ group\n  curr_start <- 1\n  # start index of next group\n  curr_end <- 1\n \
    \ # start index of current group\n  next_start <- 1\n  # start index of next group\n\
    \  next_end <- 1\n  # max nesting level of current group\n  max_nest <- 0\n  #\
    \ max nesting level of all groups\n  max_nest_all <- c()\n  # For each group,\
    \ find maximum nesting level\n  for (i in 1:length(paren_string)) {\n    # if\
    \ string at index i is opening paren '(' then increase max_nest\n    if (paren_string[i]\
    \ == '(') {\n      max_nest <- max_nest + 1\n    }\n    # if string at index i\
    \ is closing paren ')' then increase max_nest\n    if (paren_string[i] == ')')\
    \ {\n      max_nest <- max_nest - 1\n    }\n    # if string at index i is space\
    \ then start and end indices of next group will be\n    # immediately next to\
    \ index i. If there is no space and we have reached end of string\n    # then\
    \ start and end indices of next group will be\n    # last index of string\n  \
    \  if (paren_string[i] == ' ') {\n      next_start <- i + 1\n      next_end <-\
    \ i + 1\n    }\n    if (i == length(paren_string)) {\n      next_start <- i +\
    \ 1\n      next_end <- i + 1\n    }\n    # if end of current group is reached,\
    \ store max_nest for this group, reset\n    # start and end indices for the next\
    \ group\n    if (i == curr_end) {\n      max_nest_all <- c(max_nest_all, max_nest)\n\
    \      curr_start <- next_start\n      curr_end <- next_end\n      max_nest <-\
    \ 0\n    }\n  }\n  return(max_nest_all)\n}\n\nparse_nested_parens('(()", "\n \
    \ # your code here\n  matches <- str_match(paren_string, \"(\\\\(+\\\\))+\")\n\
    \  matches <- as.character(matches[,2])\n  # remove nul characters\n  matches\
    \ <- matches[!is.na(matches)]\n  # turn into a list\n  matches <- strsplit(matches,\
    \ split = \"\")\n  matches <- lapply(matches, function(x) length(x) - 2)\n  return(matches)\n\
    }\n \nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n  base_level <-\
    \ 0\n  max_level <- 0\n  group_levels <- numeric(0)\n  for (char in strsplit(paren_string,\
    \ \"\")[[1]]) {\n    if (char == \"(\") {\n      base_level <- base_level + 1\n\
    \      if (base_level > max_level) {\n        max_level <- base_level\n      }\n\
    \    } else if (char == \")\") {\n      if (base_level == max_level) {\n     \
    \   group_levels <- c(group_levels, max_level)\n        max_level <- 0\n     \
    \ }\n      base_level <- base_level - 1\n    }\n  }\n  group_levels\n}", "\n \
    \ #split each group into a list of tokens, then use the LISP _cons_ function to\
    \ put the tokens into tree\n  x <- unlist(strsplit(strsplit(paren_string, split='\
    \ ')[[1]], split=''))\n  x <- lapply(x, function(s) ifelse(s=='(', cons(s, NULL),\
    \ s))\n \n  #define the function to count max level of nesting recursively\n \
    \ max_paren_level <- function(token_list, cur_level=0, max_level=0) {\n    if\
    \ (length(token_list) == 0) return(max_level)\n    \n    if (token_list[[1]] ==\
    \ '(')\n      return(max_paren_level(token_list[[2]], cur_level+1, max(max_level,\
    \ cur_level+1)))\n    else if (token_list[[1]] == ')')\n      return(max_paren_level(token_list[[2]],\
    \ cur_level-1, max_level))\n    else\n      return(max_paren_level(token_list[[2]],\
    \ cur_level, max_level))\n  }\n  \n  #call the recursive function for each group\n\
    \  return(lapply(x, max_paren_level))\n}\n\nparse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n", "\n    paren_string <- strsplit(paren_string, \" \")[[1]]\n\
    \    return(unlist(lapply(paren_string, function(x) {\n        parens <- strsplit(x,\
    \ \"\")[[1]]\n        count <- 0\n        max_count <- 0\n        while (i <-\
    \ match(\"(\", parens)) {\n            parens <- parens[-i]\n            count\
    \ <- count + 1\n            if (count > max_count) {\n                max_count\
    \ <- count\n            }\n            parens <- parens[-match(\"(\", parens)]\n\
    \            count <- count - 1\n        }\n        return(max_count)\n    })))\n\
    }\n", "\n    # Split string into groups of parentheses, one group per string element\n\
    \    groups <- strsplit(paren_string, ' ')[[1]]\n    # Initialize a variable to\
    \ store the level of nesting of each group\n    nest_levels <- rep(0, length(groups))\n\
    \    # For each group, use a loop that uses a stack to store and count levels\
    \ of parentheses.\n    for (i in 1:length(groups)) {\n        # Initialize a vector\
    \ to store the open parentheses\n        stack <- c()\n        # Initialize a\
    \ variable to store the maximum level of nesting\n        max_nest <- 0\n    \
    \    # Loop through each of the character in the group.\n        for (char in\
    \ groups[i]) {\n            # If char is an open parentheses, push it to the stack\
    \ and increase the nesting level.\n            if (char == '(') {\n          \
    \      stack <- c(stack, char)\n                max_nest <- max_nest + 1\n   \
    \         }\n            # If char is a close parentheses, pop the stack, which\
    \ removes the matching open parentheses,\n            # and decrease the nesting\
    \ level.\n            if (char == ')') {\n                stack <- stack[-length(stack)]\n\
    \                max_nest <- max_nest - 1\n            }\n        }\n        #\
    \ Store the maximum nesting level for this group in the nest_levels vector.\n\
    \        nest_levels[i] <- max_nest\n    }\n    # Return the nest_levels vector.\n\
    \    return(nest_levels)\n}", "\n  \n  # Split the string using space as separator\n\
    \  groups <- strsplit(paren_string, \" \")[[1]]\n  \n  # Initialize a list to\
    \ store the levels of nesting for each group\n  levels <- rep(0, length(groups))\n\
    \  \n  # Iterate through each group\n  for (idx in seq_along(groups)) {\n    \n\
    \    # Initialize a counter that keeps track of the current level of nesting\n\
    \    level_count <- 0\n    \n    # Keep track of the previous character\n    prev_char\
    \ <- \"\"\n    \n    # Iterate through each character in the group\n    for (char\
    \ in groups[idx]) {\n      \n      # When the character is '(' and the previous\
    \ character is not '(', increase the level of nesting by 1\n      if (char ==\
    \ \"(\" && prev_char != \"(\") {\n        level_count <- level_count + 1\n   \
    \   }\n      \n      # When the character is ')' and the previous character is\
    \ not ')', decrease the level of nesting by 1\n      if (char == \")\" && prev_char\
    \ != \")\") {\n        level_count <- level_count - 1\n      }\n      \n     \
    \ # Update the previous character\n      prev_char <- char\n    }\n    \n    #\
    \ Store the levels of nesting for the current group\n    levels[idx] <- level_count\n\
    \  }\n  \n  # Return the levels of nesting for each group\n  return(levels)\n\
    }\n", "\n  max_nesting_levels <- c()\n  paren_string <- strsplit(paren_string,\
    \ \" \")[[1]]\n  for (paren_group in paren_string) {\n    paren_group <- unlist(strsplit(paren_group,\
    \ \"\"))\n    paren_level <- 0\n    level_ctr <- 0\n    for (paren in paren_group)\
    \ {\n      if (paren == \"(\") {\n        paren_level <- paren_level + 1\n   \
    \   } else if (paren == \")\") {\n        paren_level <- paren_level - 1\n   \
    \   }\n      if (paren_level > level_ctr) {\n        level_ctr <- paren_level\n\
    \      }\n    }\n    max_nesting_levels <- c(max_nesting_levels, level_ctr)\n\
    \  }\n  return(max_nesting_levels)\n}\n", "\n  # Create a regular expression pattern\
    \ that matches the nested parentheses in a single group.\n  # The parentheses\
    \ (, ), and | are special characters in a regular expression and need to be escaped.\n\
    \  paren_pattern <- paste0('^(?|',\n                          '([^()]*(?:\\(([^()]*(?:\\\
    (([^()]*(?:\\(([^()]*)\\))?[^()]*)*)\\))?[^()]*)*\\))[^()]*)*',\n            \
    \              ')$')\n  # Extract the level of nesting for each group in the string.\n\
    \  max_nesting <- unlist(regmatches(strsplit(paren_string, '\\\\s+')[[1]],\n \
    \                                  gregexpr(paren_pattern, strsplit(paren_string,\
    \ '\\\\s+')[[1]], perl = TRUE)))\n  # Count the number of non-NULL elements in\
    \ each group\n  sapply(strsplit(max_nesting, ''), function(x) sum(!is.na(x)))\n\
    }\n\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n    opening_parens\
    \ = unlist(strsplit(paren_string, ''))[opening_parens <- opening_parens %in% c('(',\
    \ ')')]\n    closing_parens = unlist(strsplit(paren_string, ''))[closing_parens\
    \ <- closing_parens %in% c('(', ')')]\n    paren_counts = numeric(length(opening_parens))\n\
    \    # Go through each paren and keep track of the deepest nested level.\n   \
    \ for (i in 1:length(opening_parens)) {\n        opening_paren = opening_parens[i]\n\
    \        closing_paren = closing_parens[i]\n        paren_counts[i] = 0\n    \
    \    if (opening_paren == '(') {\n            paren_counts[i] = paren_counts[i]\
    \ + 1\n        } else {\n            paren_counts[i] = paren_counts[i] - 1\n \
    \       }\n    }\n    return(paren_counts)\n}\n ", "\n  paren_split <- strsplit(paren_string,\
    \ ' ')[[1]]\n  stopifnot(all(nchar(paren_split) == 1))\n  list(\n    max_nesting_parens(paren_split[1]),\n\
    \    max_nesting_parens(paren_split[2]),\n    max_nesting_parens(paren_split[3]),\n\
    \    max_nesting_parens(paren_split[4])\n  )\n}\n\ntest_that('test_parse_nested_parens',\
    \ {\n  expect_equal(parse_nested_parens('(()()) ((())) () ((())()())'), c(2, 3,\
    \ 1, 3))\n})\n ", "\n  # removing the original spaces\n  paren_string <- gsub('\\\
    \\s', '', paren_string)\n  # it is a list of positions of all the parentheses\n\
    \  # if this set is odd, then there is a non matching parentheses\n  paren_index\
    \ <- gregexpr('\\\\(|\\\\)', paren_string)[[1]]\n  if (length(paren_index) %%\
    \ 2 != 0) {\n    stop('this string has un-matched parentheses!')\n  }\n  # create\
    \ a vector to store the level of parentheses\n  paren_level <- numeric(length(paren_index))\n\
    \  # c(1, 1, 1, 2, 2, 2, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 2, 1, 1)\n  paren_level[paren_index[1:2]\
    \ %% 2 == 0] <- 1\n  for (i in seq(from = 3, to = length(paren_index), by = 2))\
    \ {\n    if (paren_string[paren_index[i]] == '(') {\n      paren_level[paren_index[i]]\
    \ <- paren_level[paren_index[i - 1]] + 1\n    } else {\n      paren_level[paren_index[i]]\
    \ <- paren_level[paren_index[i - 1]] - 1\n    }\n  }\n  # find the first and last\
    \ parenthesis for each group\n  paren_first <- paren_index[(paren_index %% 2 ==\
    \ 0)]\n  paren_last <- paren_index[(paren_index %% 2 == 1)]\n  # calculate the\
    \ maximum level of each group\n  paren_max <- sapply(seq(from = 1, to = length(paren_first)),\n\
    \                      function(i) {\n                        max(paren_level[paren_first[i]:paren_last[i]])\n\
    \                      })\n  paren_max\n}\n", "\n    # Process the string using\
    \ regexp and return the level of nesting for each group\n    # (CODE GOES HERE)\n\
    \    parse_nested_parens <- function(paren_string) {\n        level <- c()\n \
    \       for (char in strsplit(paren_string, \"\")[[1]]) {\n            if (char\
    \ == \"(\") {\n                level <- c(level, level[length(level)] + 1)\n \
    \           } else if (char == \")\") {\n                level <- c(level, level[length(level)]\
    \ - 1)\n            }\n        }\n        return(level)\n    }\n}\n", "\n  paren_string\
    \ <- strsplit(paren_string, ' ')[[1]]\n  max_level <- 0\n  max_levels <- c()\n\
    \  for (i in 1:length(paren_string)) {\n    parens <- paren_string[i]\n    level\
    \ <- 0\n    max_level <- 0\n    for (j in 1:length(parens)) {\n      if (parens[j]\
    \ == '(') {\n        level <- level + 1\n      } else if (parens[j] == ')') {\n\
    \        if (level > max_level) {\n          max_level <- level\n        }\n \
    \       level <- level - 1\n      }\n    }\n    max_levels <- c(max_levels, max_level)\n\
    \  }\n  return(max_levels)\n}\nparse_nested_parens('(()()) ((())) () ((())()())')\n",
  "\n  # Create a vector that stores the maximum nesting level of each group.\n  level_vector\
    \ <- rep(0, length(paren_string))\n  # For each group, initialize a stack that\
    \ contains the positions of the left parentheses.\n  stack <- NULL\n  # Loop through\
    \ each group.\n  for (i in 1:length(paren_string)) {\n    # Initialize a count\
    \ that keeps track of the maximum nesting level of each group.\n    count <- 0\n\
    \    # Initialize a position counter.\n    pos <- 1\n    # Convert the group to\
    \ a character vector.\n    parens <- strsplit(paren_string[i], '')[[1]]\n    #\
    \ Loop through each parenthesis in the current group.\n    for (j in 1:length(parens))\
    \ {\n      # If the current parenthesis is a left parenthesis, add its position\
    \ to the stack.\n      if (parens[j] == '(') {\n        stack <- c(stack, pos)\n\
    \        pos <- pos + 1\n      }\n      # If the current parenthesis is a right\
    \ parenthesis, and the stack is not empty,\n      # pop the stack and increase\
    \ the count.\n      if (parens[j] == ')' && !is.null(stack)) {\n        stack\
    \ <- stack[-length(stack)]\n        count <- count + 1\n      }\n    }\n    #\
    \ Update the maximum nesting level of the current group in the vector.\n    level_vector[i]\
    \ <- count\n  }\n  # Return the maximum nesting level of each group.\n  return(level_vector)\n\
    }\n", "\n  ## YOUR CODE HERE\n  ## You will have to use the stringr::str_count\
    \ function\n  ## You will have to use base::substr function to extract first and\
    \ last indices of each group\n  ## You may use base::substring, but be careful!\n\
    \  ## You will have to use RcppAlgos::matchParen to match the closing paren to\
    \ the open paren\n}\n", "\n\tc(napply(strsplit(paren_string, '\\\\s+')[[1]], function(str)\
    \ {\n\t\tmatch(str, cumsum(str_count(str, '\\\\(') - str_count(str, '\\\\)')))\n\
    \t}))\n}\n", "\n  # create a vector to store result\n  result <- integer(length\
    \ = 0)\n  # identify each group based on spaces\n  groups <- strsplit(paren_string,\
    \ ' ')[[1]]\n  # for each group\n  for (group in groups) {\n    # count how many\
    \ left parentheses\n    left_parens <- gregexpr('\\\\(', group)[[1]]\n    # append\
    \ the length of left_parens to result\n    result <- c(result, length(left_parens))\n\
    \  }\n  # return result\n  return(result)\n}\n", "\n    # TODO: Replace the NA\
    \ with the number of nested parentheses in the group\n    return(str_count(paren_string,\
    \ \"\\\\(\") - str_count(paren_string, \"\\\\)\"))\n}\n", "\n    library(stringr)\n\
    \    library(plyr)\n    library(plyr)\n    paren_string %>%\n        str_split('\
    \ ') %>%\n        unlist() %>%\n        map(\n            ~(if (str_detect(.x,\
    \ '\\\\)\\\\(')) {\n                ':('\n            } else {\n             \
    \   .x %>%\n                    str_count('\\\\(') - str_count('\\\\)')\n    \
    \        })\n        ) %>%\n        as.list() %>%\n        llply(\n          \
    \  ~if (class(.x) == ':(') {\n                str_replace_all(.x, '\\\\(', '')\
    \ %>%\n                    str_replace_all('\\\\)', '') %>%\n                \
    \    str_split(' ') %>%\n                    unlist() %>%\n                  \
    \  .[1:nchar(.x) %% 2 == 0] %>%\n                    str_count('\\\\(') - str_count('\\\
    \\)')\n            } else {\n                .x\n            }\n        ) %>%\n\
    \        unlist() %>%\n        .[. > 0]\n}\nparse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n", "\n    return(str_count(paren_string, '\\\\(+'))\n}\n",
  "\n  paren_string_list <- strsplit(paren_string, ' ')\n  paren_string_list <- sapply(paren_string_list,\
    \ function(x) x[1])\n  lapply(paren_string_list, function(x) check_max_paren_level(x))\n\
    }\n\ncheck_max_paren_level <- function(paren_string) {\n  paren_stack <- list()\n\
    \  max_level <- 0\n  for (i in 1:nchar(paren_string)) {\n    if (substr(paren_string,\
    \ i, i) == '(') {\n      paren_stack <- append(paren_stack, list(paren_string[i]))\n\
    \      if (length(paren_stack) > max_level) {\n        max_level <- length(paren_stack)\n\
    \      }\n    } else if (substr(paren_string, i, i) == ')') {\n      if (length(paren_stack)\
    \ == 0) {\n        return(0)\n      }\n      paren_stack <- paren_stack[-length(paren_stack)]\n\
    \    }\n  }\n  if (length(paren_stack) > 0) {\n    return(0)\n  }\n  return(max_level)\n\
    }\n", "\n  level <- 0\n  max_level <- 0\n  levels <- NULL\n  for (i in 1:nchar(paren_string))\
    \ {\n    if (substr(paren_string, i, i) == \"(\") {\n      level <- level + 1\n\
    \      if (level > max_level) {\n        max_level <- level\n      }\n    } else\
    \ if (substr(paren_string, i, i) == \")\") {\n      level <- level - 1\n     \
    \ if (level == 0) {\n        levels <- c(levels, max_level)\n        max_level\
    \ <- 0\n      }\n    }\n  }\n  return(levels)\n}\n", "\n  c(1, 2, 3)\n}", "\n\
    \  return (unlist(strsplit(paren_string, \" \")) %>% \n          str_count(\"\\\
    \\(\") %>% \n          diff %>% \n          which(. >= 0) %>% \n          length)\n\
    }\n", "\n  # define a recursive function to calculate the deepest level of nesting\n\
    \  paren_count <- function(paren_string) {\n    paren_count <- c()\n    left_paren\
    \ <- regexpr('\\\\(', paren_string)\n    left_paren <- left_paren[left_paren !=\
    \ -1]\n    right_paren <- regexpr('\\\\)', paren_string)\n    right_paren <- right_paren[right_paren\
    \ != -1]\n    if(length(left_paren) == 0 && length(right_paren) == 0) {\n    \
    \  return(0)\n    } else if(length(left_paren) == 0 || length(right_paren) ==\
    \ 0) {\n      return(NA)\n    } else {\n      for(i in seq(1, length(left_paren)))\
    \ {\n        if(left_paren[i] > right_paren[i]) {\n          return(NA)\n    \
    \    }\n      }\n      for(i in seq(1, length(left_paren))) {\n        if(i ==\
    \ length(left_paren)) {\n          paren_count <- c(paren_count, paren_count(paren_string[(left_paren[i]\
    \ + 1):right_paren[i]]) + 1)\n        } else {\n          paren_count <- c(paren_count,\
    \ paren_count(paren_string[(left_paren[i] + 1):right_paren[i]]) + 1, paren_count(paren_string[(right_paren[i]\
    \ + 1):right_paren[i + 1]]))\n        }\n      }\n      return(max(paren_count))\n\
    \    }\n  }\n  paren_count <- c()\n  for(i in unlist(strsplit(paren_string, '\
    \ '))) {\n    paren_count <- c(paren_count, paren_count(i))\n  }\n  return(paren_count)\n\
    }", "\n    # Currently all the logic is in this function. I wanted to avoid writing\
    \ another function since\n    # I wanted to avoid defining a recursive function.\
    \ I just wanted a simple functionality.\n    # But I think having this function\
    \ in a separate file is a better idea.\n    paren_string <- as.character(paren_string)\n\
    \    paren_string <- trimws(paren_string)\n    paren_string <- gsub('\\\\s+',\
    \ ' ', paren_string)\n    num_groups <- length(strsplit(paren_string, split =\
    \ ' ')[[1]])\n    paren_groups <- strsplit(paren_string, split = ' ')[[1]]\n \
    \   max_nesting <- integer(num_groups)\n    for (i in 1:num_groups) {\n      \
    \  paren_group <- paren_groups[i]\n        paren_group <- paste(paren_group, collapse\
    \ = '')\n        if (!all(unlist(strsplit(paren_group, '')) %in% c('(', ')')))\
    \ {\n            print(paste('Malformed parenthesis string for group', i))\n \
    \           return(NA)\n        }\n        paren_level <- 0\n        max_level\
    \ <- 0\n        for (j in 1:length(paren_group)) {\n            paren_level <-\
    \ paren_level + (ifelse(paren_group[j] == '(', 1, -1))\n            if (paren_level\
    \ > max_level) {\n                max_level <- paren_level\n            }\n  \
    \      }\n        max_nesting[i] <- max_level\n    }\n    return(max_nesting)\n\
    }\n\nprint(parse_nested_parens('(()()) ((())) () ((())()())'))", "\n  # implement\
    \ me\n}\n", "\n    # Split the input string on spaces\n    # >>> unlist(strsplit('(()())\
    \ ((())) () ((())()())', ' '))\n    # [1] \"(()())\" \"((()))\" \"()\" \"((())()())\"\
    \n    string_list <- unlist(strsplit(paren_string, ' '))\n    \n    # Create a\
    \ list to store our results\n    # >>> results <- c()\n    results <- c()\n  \
    \  \n    # Iterate over the list of strings\n    for (string in string_list) {\n\
    \        # Use the count_nested_parens function you defined above\n        # to\
    \ count how many levels of nested parentheses are in each string\n        # >>>\
    \ count_nested_parens('(()())')\n        # [1] 2\n        # >>> count_nested_parens('((()))')\n\
    \        # [1] 3\n        # >>> count_nested_parens('()')\n        # [1] 1\n \
    \       # >>> count_nested_parens('((())()())')\n        # [1] 3\n        nesting_count\
    \ <- count_nested_parens(string)\n        \n        # Store the result in the\
    \ results list\n        # >>> results\n        # [1] 2 3 1 3\n        results\
    \ <- c(results, nesting_count)\n    }\n    \n    # Return the results\n    return(results)\n\
    }\n", "\n  stack <- character(0)\n  depth <- integer(0)\n  max_depth <- 0\n  i\
    \ <- 1\n  while (i <= nchar(paren_string)) {\n    char <- substr(paren_string,\
    \ i, i)\n    if (char == '(') {\n      stack <- c(stack, char)\n      max_depth\
    \ <- max(max_depth, length(stack))\n    } else if (char == ')') {\n      if (length(stack)\
    \ == 0) {\n        stop('unmatched parenthesis')\n      }\n      stack <- stack[-length(stack)]\n\
    \    } else if (char == ' ') {\n      if (length(stack) == 0) {\n        depth\
    \ <- c(depth, max_depth)\n        max_depth <- 0\n      }\n    } else {\n    \
    \  stop('invalid character')\n    }\n    i <- i + 1\n  }\n  if (length(stack)\
    \ != 0) {\n    stop('unmatched parenthesis')\n  }\n  depth\n}\n\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n  # Your code here\n  answer <- str_split(paren_string,\
    \ \" \")\n  count <- character(0)\n  for (i in 1:length(answer)){\n    stack <-\
    \ character(0)\n    count[i] <- 0\n    j <- 1\n    while (j <= nchar(answer[[i]])){\n\
    \      if (substr(answer[[i]], j, j) == \"(\"){\n        count[i] <- count[i]\
    \ + 1\n        stack <- c(stack, substr(answer[[i]], j, j))\n      }\n      if\
    \ (substr(answer[[i]], j, j) == \")\"){\n        if (length(stack) == 0) break\n\
    \        stack <- stack[-length(stack)]\n      }\n      j <- j + 1\n    }\n  }\n\
    \  count\n}\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n    paren_string_split\
    \ <- strsplit(paren_string, \" \")[[1]]\n    str_lens <- unlist(lapply(paren_string_split,\
    \ nchar))\n    paren_string_split <- paren_string_split[str_lens>1]\n    num_parens\
    \ <- unlist(lapply(paren_string_split, function(x) sum(x==\"(\")))\n    nest_levels\
    \ <- unlist(lapply(1:length(paren_string_split), function(x) paren_level(paren_string_split[x])))\n\
    \    return(num_parens - nest_levels)\n}\n\nparen_level <- function(paren_string)\
    \ {\n    if (nchar(paren_string) <= 1) return(0)\n    char_counts <- unlist(lapply(1:nchar(paren_string),\
    \ function(x) {\n        if (substr(paren_string, x, x) == \"(\") return(1)\n\
    \        else return(-1)\n    }))\n    cum_char_counts <- cumsum(char_counts)\n\
    \    # Only keep the ones that are less than zero because the others are nested\
    \ parentheses\n    return(max(cum_char_counts[cum_char_counts < 0]))\n}\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n  unlist(strsplit(paren_string, ' ')) %>% \n \
    \   str_count(pattern = '\\\\)') %>% \n    diff(from = 0) %>% \n    cumsum() %>%\
    \ \n    diff(from = 0) %>% \n    max(na.rm = TRUE)\n}\n \nassert.identical(parse_nested_parens('(()())\
    \ ((())) () ((())()())'),\n                 c(2, 3, 1, 3))\n ", "\n  # we will\
    \ split the string by space\n  str_split(paren_string, ' ') %>%\n  # and then\
    \ get the max depth of each sub-string\n  sapply(max_depth)\n}\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n    # Read the input string into a dataframe of\
    \ two columns, 'parity' and 'paren'.\n    df <- data.frame(paren = strsplit(paren_string,\
    \ '')[[1]], parity = c(1:length(strsplit(paren_string, '')[[1]])))\n    # Get\
    \ the indices of open and closed parentheses in the input string.\n    open_idx\
    \ <- df$parity[df$paren == '(']\n    close_idx <- df$parity[df$paren == ')']\n\
    \    # Create a vector of all indices in the input string.\n    all_idx <- seq(from\
    \ = 1, to = length(strsplit(paren_string, '')[[1]]))\n    # Subtract indices of\
    \ closed parentheses from the open ones to get the nested levels.\n    levels\
    \ <- open_idx - close_idx\n    # Find the maximum level across each group.\n \
    \   max_level <- sapply(split(all_idx, cumsum(all_idx %in% open_idx)), function(x)\
    \ max(levels[x]))\n    return(max_level)\n}", "\n    # Write your code here\n\
    \    paren_string = strsplit(paren_string, ' ')[[1]]\n    nest = 0\n    max_nest\
    \ = 0\n    output = vector()\n    for (p in paren_string) {\n        for (i in\
    \ 1:nchar(p)) {\n            if (substr(p, i, i) == '(') {\n                nest\
    \ = nest + 1\n            } else if (substr(p, i, i) == ')') {\n             \
    \   nest = nest - 1\n            }\n            if (nest > max_nest) {\n     \
    \           max_nest = nest\n            }\n        }\n        output = c(output,\
    \ max_nest)\n        nest = 0\n        max_nest = 0\n    }\n    return(output)\n\
    }\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n    paren_string\
    \ <- strsplit(paren_string, split = ' ')[[1]]\n    lapply(paren_string, function(paren_string)\
    \ {\n        str_count(paren_string, '\\\\(') - str_count(paren_string, '\\\\\
    )')\n    })\n}\n", "\n    ## Add your code here\n    ## Do not output anything\
    \ else, this is a pure function\n}\n", "\n  groups <- strsplit(paren_string, \"\
    \ \")[[1]]\n  max_depth <- vector(mode=\"integer\", length=length(groups))\n \
    \ for (i in seq_along(groups)) {\n    current_depth <- 0\n    for (c in strsplit(groups[i],\
    \ \"\")[[1]]) {\n      if (c == \"(\") {\n        current_depth <- current_depth\
    \ + 1\n      } else if (c == \")\") {\n        current_depth <- current_depth\
    \ - 1\n      }\n    }\n    max_depth[i] <- current_depth\n  }\n  return(max_depth)\n\
    }\n\nparen_string <- \"(()()) ((())) () ((())()())\"\nparse_nested_parens(paren_string)\n",
  "\n    paren_string_split <- strsplit(paren_string, split = ' ')[[1]]\n    nested_levels\
    \ <- rep(0, length(paren_string_split))\n    for (i in 1:length(paren_string_split))\
    \ {\n        paren_string_split_i <- paren_string_split[i]\n        last_paren_level\
    \ <- 0\n        max_paren_level <- 0\n        for (j in 1:length(paren_string_split_i))\
    \ {\n            if (paren_string_split_i[j] == '(') {\n                last_paren_level\
    \ <- last_paren_level + 1\n                if (last_paren_level > max_paren_level)\
    \ {\n                    max_paren_level <- last_paren_level\n               \
    \ }\n            } else if (paren_string_split_i[j] == ')') {\n              \
    \  last_paren_level <- last_paren_level - 1\n            }\n        }\n      \
    \  nested_levels[i] <- max_paren_level\n    }\n    nested_levels\n}\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n  # add a space at the end so we don't have to\
    \ check for it\n  paren_string <- paste(paren_string, \" \", sep=\"\")\n  # create\
    \ a vector to hold the maximum depths\n  depths <- c()\n  # will hold the current\
    \ deepest depth for a group\n  max_depth <- 0\n  # current depth we are in\n \
    \ depth <- 0\n  # iterate over each character in the input string\n  for (i in\
    \ 1:nchar(paren_string)) {\n    # if we've reached a new group, reset the max\
    \ depth, save the old one and reset the depth\n    if (paren_string[i] == \" \"\
    ) {\n      depths <- c(depths, max_depth)\n      max_depth <- 0\n      depth <-\
    \ 0\n    } else if (paren_string[i] == \"(\") {\n      # increase the depth if\
    \ we've entered a new level\n      depth <- depth + 1\n      # update the max\
    \ depth if we've entered a new deepest level\n      if (depth > max_depth) {\n\
    \        max_depth <- depth\n      }\n    } else if (paren_string[i] == \")\"\
    ) {\n      # decrease the depth if we've exited a level\n      depth <- depth\
    \ - 1\n    }\n  }\n  return(depths)\n}\nparse_nested_parens('(()()) ((())) ()\
    \ ((())()())')\n", "\n    # Create a dataframe to keep track of the input string,\
    \ and keep track of the number of closed parentheses\n    # at each location.\n\
    \    paren_df <- data.frame(\n        'Location' = seq_along(paren_string),\n\
    \        'Char' = substr(paren_string, seq_along(paren_string), seq_along(paren_string)),\n\
    \        'ClosedParen' = 0\n    )\n    paren_df[paren_df$Char == ')', 'ClosedParen']\
    \ <- 1\n    # Sum up the number of closed parentheses for each location.\n   \
    \ nested_parens <- cumsum(paren_df$ClosedParen)\n    # How many open parentheses\
    \ are there?\n    open_parens <- sum(paren_df$Char == '(')\n    # Starting from\
    \ the back, find the first location that has more closed parentheses than open\
    \ parentheses.\n    back_index <- open_parens\n    for (i in seq_len(nrow(paren_df)))\
    \ {\n        if (paren_df$ClosedParen[i] > nested_parens[i] - paren_df$ClosedParen[i])\
    \ {\n            back_index <- i\n            break\n        }\n    }\n    # Starting\
    \ from the front, find the first location that has more closed parentheses than\
    \ open parentheses.\n    front_index <- open_parens\n    for (i in seq_len(nrow(paren_df)))\
    \ {\n        if (paren_df$ClosedParen[i] > nested_parens[i] - paren_df$ClosedParen[i])\
    \ {\n            front_index <- i\n            break\n        }\n    }\n    #\
    \ Take out the nested groups\n    paren_df <- paren_df[-c(front_index:(back_index\
    \ - 1)), ]\n    # Create a variable to keep track of the current number of open\
    \ parentheses.\n    paren_df$OpenParen <- 0\n    paren_df[paren_df$Char == '(',\
    \ 'OpenParen'] <- 1\n    paren_df$OpenParen <- cumsum(paren_df$OpenParen)\n  \
    \  # Find the maximum number of open parentheses.\n    max_level", "\n  # replace\
    \ all open parentheses with (1 and close parentheses with 1)\n  # sum up each\
    \ number and take max\n  # if a string is a perfect match, return 0\n  max(0,\
    \ sapply(strsplit(paren_string, ' '), function(i) max(cumsum(as.numeric(gsub('\\\
    \\(', '1', i)) -\n                                                           \
    \                   as.numeric(gsub('\\\\)', '1', i))))))\n}\n", "\n    # Your\
    \ code here\n    return(0)\n}\n ", "\n  #TODO\n  parens_str = strsplit(paren_string,\
    \ \" \")[[1]]\n  parens_nested = lapply(parens_str, function(par){\n    curr_level\
    \ = 0\n    max_level = 0\n    for (c in par){\n      if (c == \"(\"){\n      \
    \  curr_level = curr_level + 1\n      }\n      if (c == \")\"){\n        curr_level\
    \ = curr_level - 1\n      }\n      if (curr_level > max_level){\n        max_level\
    \ = curr_level\n      }\n    }\n    return(max_level)\n  })\n  return(unlist(parens_nested))\n\
    }\n", "\n    # TODO\n    return(c(2, 3, 1, 3))\n}\n", "\n  paren_str <- unlist(strsplit(paren_string,\
    \ \" \"))\n  nested_parens <- sapply(paren_str, function(x) max(parenth_level(x)))\n\
    \  return(nested_parens)\n}\n", "\n  do.call(c,\n    lapply(strsplit(paren_string,\
    \ split = \" \")[[1]],\n    FUN = function(paren_string) {\n      parse_parens(paren_string)\n\
    \    }))\n}\n\nx <- parse_nested_parens('(()()) ((())) () ((())()())')\nx\n \n",
  "\n  # TODO\n}\n", "\n  splitted <- strsplit(paren_string, ' ')[[1]]\n  is_balanced\
    \ <- function(x) {\n    nleft <- stringr::str_count(x, '\\\\(')\n    nright <-\
    \ stringr::str_count(x, '\\\\)')\n    nleft == nright\n  }\n  is_empty <- function(x)\
    \ {\n    !stringr::str_detect(x, '[()]')\n  }\n  empty_groups <- which(sapply(splitted,\
    \ is_empty))\n  grouped <- stringr::str_extract_all(splitted, '\\\\([^()]*\\\\\
    )')\n  paren_groups <- vapply(grouped, function(x) {\n    parens <- stringr::str_extract_all(x,\
    \ '\\\\([^()]*\\\\)')[[1]]\n    sapply(parens, function(y) {\n      stringr::str_match(y,\
    \ '\\\\(([^()]*)\\\\)')[[1]][2]\n    })\n  }, integer(1))\n  balanced_parens <-\
    \ vapply(paren_groups, function(x) {\n    sapply(x, is_balanced)\n  }, logical(1))\n\
    \  paren_nest <- vapply(paren_groups, function(x) {\n    sapply(x, function(y)\
    \ {\n      rle(stringr::str_detect(y, '\\\\('))$lengths[stringr::str_detect(y,\
    \ '\\\\(')]\n    })\n  }, integer(1))\n  unlist(lapply(1:length(splitted), function(i)\
    \ {\n    if (i %in% empty_groups) {\n      0\n    } else if (length(paren_nest[[i]])\
    \ == 0) {\n      0\n    } else if (any(!balanced_parens[[i]])) {\n      0\n  \
    \  } else {\n      max(paren_nest[[i]])\n    }\n  }))\n}", "\n  paren_string <-\
    \ gsub(\" \", \"|\", paren_string) # Replace spaces with pipes\n  split(paren_string,\
    \ strsplit(paren_string, \"\\\\|\")) %>%\n    sapply(count_paren_groups) %>%\n\
    \    unlist\n}\n\ncount_paren_groups <- function(paren_string) {\n  paren_string\
    \ <- gsub(\"[^()]\", \"\", paren_string) # Strip out all non-parens\n  paren_string\
    \ <- gsub(\"[()]\", \"1\", paren_string) # Replace parens with 1's\n  longest_run(paren_string)\n\
    }\n", "\n  parsed_parens <- stringr::str_extract_all(paren_string, '\\\\(+\\\\\
    )')\n  parsed_parens <- lapply(parsed_parens, function(x) length(stringr::str_extract_all(x,\
    \ '\\\\(')[1]))\n  return(parsed_parens)\n}\nparse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n", "\n    # First, replace all outer parentheses with a space\
    \ so\n    # that the string only contains parentheses that are nested.\n    paren_string\
    \ <- gsub('\\\\(', ' ', paren_string)\n    paren_string <- gsub('\\\\)', ' ',\
    \ paren_string)\n    # Split the string by the delimiter space.\n    parenthesized_groups\
    \ <- strsplit(paren_string, ' ')[[1]]\n    # For each group, count the number\
    \ of left parentheses.\n    depths <- sapply(parenthesized_groups, function(group)\
    \ sum(strsplit(group, '')[[1]] == '('))\n    return(depths)\n}", "\n  # Your code\
    \ goes here\n  nest = 0\n  cur = 0\n  res = rep(0, 0)\n  for (i in 1:nchar(paren_string))\
    \ {\n    if (substr(paren_string, i, i) == \"(\") {\n      nest = nest + 1\n \
    \     if (nest > cur) {\n        cur = nest\n      }\n    } else if (substr(paren_string,\
    \ i, i) == \")\") {\n      nest = nest - 1\n    } else if (substr(paren_string,\
    \ i, i) == \" \") {\n      res = c(res, cur)\n      cur = 0\n    }\n  }\n  return(res)\n\
    }\n\nparse_nested_parens(\"(()()) ((())) () ((())()())\")\n", "\n  return (sapply(strsplit(paren_string,\
    \ ' '), function(paren_group) {\n    return (max(sapply(cumsum(unlist(strsplit(paren_group,\
    \ '')) == '(') -\n                        cumsum(unlist(strsplit(paren_group,\
    \ '')) == ')'),\n                      function(num) {return (length(num[num ==\
    \ 0]))})))\n  }))\n}\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n\
    \  split_paren_string <- strsplit(paren_string, ' ')[[1]]\n \n  nested_parens\
    \ <- sapply(split_paren_string, function(x) {\n    as.numeric(max(gregexpr('(',\
    \ x)[[1]]) - gregexpr(')', x)[[1]]))\n  })\n \n  return(nested_parens)\n}\n",
  "\n  out <- c()\n  num_parens <- str_count(paren_string, '((')\n  for (i in 1:num_parens)\
    \ {\n    parens <- str_extract(paren_string, '(\\\\(\\\\(.*?\\\\)\\\\))')\n  \
    \  matches <- str_extract_all(parens, '\\\\(\\\\(.*?\\\\)\\\\)')\n    paren_string\
    \ <- str_replace(paren_string, parens, '')\n    max_parens <- max(str_count(matches,\
    \ '\\\\('))\n    out <- c(out, max_parens)\n  }\n  out\n}\n", "\n    depth <-\
    \ 0\n    max_depth <- 0\n    results <- c()\n    for (paren in strsplit(paren_string,\
    \ ' ')[[1]]) {\n        max_depth <- 0\n        depth <- 0\n        for (char\
    \ in strsplit(paren, '')[[1]]) {\n            if (char == '(') {\n           \
    \     depth <- depth + 1\n                if (depth > max_depth) {\n         \
    \           max_depth <- depth\n                }\n            } else if (char\
    \ == ')') {\n                depth <- depth - 1\n            }\n        }\n  \
    \      results <- c(results, max_depth)\n    }\n    return(results)\n}\n", "\n\
    \    depths <- c()\n    paren_split <- strsplit(paren_string, ' ')[[1]]\n    for\
    \ (paren_group in paren_split) {\n        depths <- c(depths, deepest_parens(paren_group))\n\
    \    }\n    return(depths)\n}\nparse_nested_parens('(()()) ((())) () ((())()())')\n",
  "\n    paren_string %>%\n        strsplit(' ') %>%\n        lapply(. %>% function(x)\
    \ {\n            x %>% strsplit('') %>% unlist() %>% paste(collapse = '') %>%\n\
    \                regexpr('\\\\(', .) %>% attr('match.length')\n        }) %>%\
    \ unlist()\n}\n\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n  #\
    \ Your code goes here\n}\n", "\n  lengths(regmatches(paren_string, gregexpr('\\\
    \\((+?)\\\\)', paren_string)))\n}\n", "\n  paren_string <- unlist(strsplit(paren_string,\
    \ \" \"))\n  paren_string <- sapply(paren_string, FUN = function(x) {\n    paren_string\
    \ <- sapply(strsplit(x, \"\")[[1]], FUN = function(x) {\n      if (x == \"(\"\
    ) {\n        return(1)\n      } else if (x == \")\") {\n        return(-1)\n \
    \     } else {\n        return(0)\n      }\n    })\n    paren_string <- cumsum(paren_string)\n\
    \    paren_string <- paren_string[paren_string == 0]\n    return(length(paren_string))\n\
    \  })\n  return(paren_string)\n}\n", "\n  # if(is.na(paren_string))\n  #     return(NA)\n\
    \  paren_string_split <- unlist(strsplit(paren_string, ' '))\n  n_groups <- length(paren_string_split)\n\
    \  nesting_levels <- vector('list', n_groups)\n  for(i in 1:n_groups) {\n    nesting_levels[[i]]\
    \ <- compute_nesting_level(paren_string_split[[i]])\n  }\n  return(unlist(nesting_levels))\n\
    }\n", "\n    paren_vec <- strsplit(paren_string, ' ')\n    paren_vec <- unlist(paren_vec)\n\
    \    levels <- sapply(paren_vec, function(s) {\n        sum(c(0, strsplit(s, '')[[1]]\
    \ == '(') - c(0, strsplit(s, '')[[1]] == ')'))\n    })\n    max(levels)\n}\n \n\
    paren_string <- '(()()) ((())) () ((())()())'\nparse_nested_parens(paren_string)\n",
  "\n  counter = 0\n  highest_counter = 0\n  level_list = vector()\n  for (l in strsplit(paren_string,\
    \ split=\"\")[[1]]) {\n    if (l == \"(\") {\n      counter = counter + 1\n  \
    \    if (counter > highest_counter) {\n        highest_counter = counter\n   \
    \   }\n    } else if (l == \")\") {\n      counter = counter - 1\n    } else if\
    \ (l == \" \") {\n      level_list = c(level_list, highest_counter)\n      highest_counter\
    \ = 0\n      counter = 0\n    }\n  }\n  return(level_list)\n}\n", "\n  # paren_string\
    \ = \"(()()) ((())) () ((())()())\"\n  num_parens <- stringr::str_count(paren_string,\
    \ \"\\\\)\")\n  num_parens <- stringr::str_count(paren_string, \"\\\\(\")\n  #\
    \ [1] 5 5 2 8\n  paren_string <- stringr::str_replace_all(paren_string, \"\\\\\
    (\", \"( \")\n  paren_string <- stringr::str_replace_all(paren_string, \"\\\\\
    )\", \" )\")\n  # [1] \"( ) ( ) ( ) ( )\" \"( ) ( ) ( ) ( ) ( ) ( )\" \" ( )\"\
    \ \" ( ) ( ) ( ) ( ) ( ) ( )\"\n  groups <- stringr::str_split(paren_string, \"\
    \\\\s\")\n  # [[1]]\n  # [1] \"(\"  \")\"  \"(\"  \")\"  \"\"  \n  #\n  # [[2]]\n\
    \  # [1] \"(\"  \")\"  \"(\"  \")\"  \"(\"  \")\"  \"\"  \n  #\n  # [[3]]\n  #\
    \ [1] \"(\"  \")\"  \"\"  \n  #\n  # [[4]]\n  # [1] \"(\"  \")\"  \"(\"  \")\"\
    \  \"(\"  \")\"  \"(\"  \")\"  \"(\"  \")\"  \"\"  \n  #\n  # [[5]]\n  # [1] NA\n\
    \  paren_stack <- c()\n  parse_paren <- function(paren_string) {\n    # paren_string\
    \ = \"( ( ) )\"\n    paren_list <- stringr::str_split(paren_string, \"\")\n  \
    \  # [1] \"(\"  \" \"  \"(\"  \" \"  \")\"  \" \"  \")\"  \"\"  \n    stack <-\
    \ c()\n    max_depth <- 0\n    for (c in paren_list) {\n      if (c == \"(\")\
    \ {\n        stack <- c(stack, c)\n        max_depth <- max(max_depth, length(stack))\n\
    \      } else if (c == \")\") {\n        stack <- stack[-length(stack)]\n    \
    \  }\n   ", "\n  ############################\n  ## Place your code here.  ##\n\
    \  ## Be sure to give your   ##\n  ## answer as c(3, 3, 1, 1)##\n  ############################\n\
    \  levels <- c()\n  depth <- 0\n  for (i in 1:nchar(paren_string)) {\n    if (substr(paren_string,\
    \ i, i) == \"(\") {\n      depth <- depth + 1\n    } else if (substr(paren_string,\
    \ i, i) == \")\") {\n      depth <- depth - 1\n    }\n    if (substr(paren_string,\
    \ i, i) == \" \") {\n      levels <- c(levels, depth)\n      depth <- 0\n    }\n\
    \  }\n  levels <- c(levels, depth)\n  return(levels)\n}\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n  paren_list <- strsplit(paren_string, \" \")[[1]]\n\
    \  paren_level <- sapply(paren_list, function(x) count_nested_parens(x))\n  paren_level\n\
    }\n", "\n  # (()()) ((())) () ((())()())\n  #    ^\n  # 0 1 2 3 4 5 6 7 8 9 10\
    \ 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36\
    \ 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62\
    \ 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88\
    \ 89 90 91 92 93 94 95 96 97 98 99 100\n  # 0                                \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                ", "\n    # extract each group\n    groups <-\
    \ strsplit(paren_string, ' ')[[1]]\n    paren_expr <- gsub('[^()]', '', groups)\n\
    \    n_paren <- nchar(paren_expr)\n    # open parentheses\n    op <- sapply(strsplit(paren_expr,\
    \ ''),\n                 function(x) sum(x == '('))\n    # closed parentheses\n\
    \    cl <- sapply(strsplit(paren_expr, ''),\n                 function(x) sum(x\
    \ == ')'))\n    # convert the data frame to a string format that we can read in\
    \ to R\n    out <- paste0('c(', paste(op - cl, collapse = ', '), ')')\n    eval(parse(text\
    \ = out))\n}\n", "\n  # strsplit splits the string by the separator space\n  split_parens\
    \ <- strsplit(paren_string, ' ')\n  # unlist flattens the list of strings to a\
    \ character vector\n  parens <- unlist(split_parens)\n  max_nest_list <- sapply(parens,\
    \ max_nest)\n  return(max_nest_list)\n}\n", "\n    # TODO\n    # your code goes\
    \ here!\n    level=0\n    levels=c()\n    left_paren=0\n    right_paren=0\n  \
    \  inner_paren=0\n    for (i in 1:nchar(paren_string)){\n      if (substr(paren_string,i,i)==\"\
    (\"){\n        left_paren=left_paren+1\n        level=level+1\n        inner_paren=inner_paren+1\n\
    \      }\n      if (substr(paren_string,i,i)==\")\"){\n        right_paren=right_paren+1\n\
    \        level=level-1\n        inner_paren=inner_paren-1\n      }\n      if (level>0\
    \ & inner_paren==0){\n        level=0\n      }\n      if (inner_paren==0){\n \
    \       levels=c(levels,level)\n      }\n    }\n    return(levels)\n}\n\nparse_nested_parens('(()())\
    \ ((())) () ((())()())')\n", "\n    c()\n}\n", "\n    unlist(lapply(strsplit(paren_string,\
    \ ' ')[[1]], function(x) {\n        sum(x %in% '(') - sum(x %in% ')')\n    }))\n\
    }", "\n    paren_string <- strsplit(paren_string, ' ')[[1]]\n    group_level <-\
    \ sapply(paren_string, \n                          function(x) {\n           \
    \                   paren_list <- strsplit(x, '')[[1]]\n                     \
    \         level <- 0\n                              level_list <- c()\n      \
    \                        for (i in 1:length(paren_list)) {\n                 \
    \                 if (paren_list[i] == '(') {\n                              \
    \        level <- level + 1\n                                  } else if (paren_list[i]\
    \ == ')') {\n                                      level <- level - 1\n      \
    \                            }\n                                  level_list <-\
    \ c(level_list, level)\n                              }\n                    \
    \          max(level_list)\n                          })\n    group_level\n}\n",
  "\n  nested_parens <- unlist(strsplit(paren_string, '\\\\s'))\n  return(unlist(lapply(nested_parens,\
    \ function(x) {\n    counter <- 0\n    max_counter <- 0\n    for (i in 1:nchar(x))\
    \ {\n      if (substr(x, i, i) == '(') {\n        counter <- counter + 1\n   \
    \   } else if (substr(x, i, i) == ')') {\n        counter <- counter - 1\n   \
    \   }\n      if (counter > max_counter) {\n        max_counter <- counter\n  \
    \    }\n    }\n    return(max_counter)\n  })))\n}\n", "\n  # TODO\n}\n", "\n \
    \   nest_level <- unlist(strsplit(paren_string, split = ''))\n    nest_level[nest_level\
    \ == '('] <- 1\n    nest_level[nest_level == ')'] <- -1\n    nest_level <- cumsum(nest_level)\n\
    \    max_level <- as.vector(tapply(nest_level, cumsum(nest_level == 0), max))\n\
    \    max_level\n}\n", "\n  # YOUR CODE HERE\n}\n", "\n    # First, split the input\
    \ string by spaces.\n    paren_string <- strsplit(paren_string, \" \")[[1]]\n\
    \    # Then iterate over each group and call nest_paren_level().\n    # Use lapply()\
    \ here to apply nest_paren_level() over each element of paren_string.\n    paren_levels\
    \ <- lapply(paren_string, nest_paren_level)\n    # return a vector of integers\
    \ with the result.\n    unlist(paren_levels)\n}", "\n  # split the string into\
    \ words based on spaces\n  words <- strsplit(paren_string, ' ')[[1]]\n  # get\
    \ the number of left and right parentheses for each word\n  par_counts <- lapply(words,\
    \ function(w) {\n    left_paren <- str_count(w, '\\\\(')\n    right_paren <- str_count(w,\
    \ '\\\\)')\n    c(left_paren, right_paren)\n  })\n  # for each word, find the\
    \ maximum nesting level.\n  # the nesting level is the number of left parentheses\
    \ minus number of right parentheses\n  # at the time we see the right parentheses\n\
    \  # the level is only valid if we do not run out of left parentheses\n  nested_levels\
    \ <- lapply(par_counts, function(c) {\n    cumsum_left <- cumsum(c[1:length(c)])\n\
    \    cumsum_right <- cumsum(c[(length(c) + 1):(2 * length(c))])\n    max(cumsum_left\
    \ - cumsum_right)\n  })\n  # convert the output to a data frame\n  nested_levels\
    \ <- as.data.frame(nested_levels)\n  # set the column name\n  colnames(nested_levels)\
    \ <- 'level'\n  # return the result\n  return(nested_levels)\n}\n", "\n  paren_string\
    \ <- strsplit(paren_string, ' ')[[1]]\n  c(lapply(paren_string, function(x) sum(gregexpr('\\\
    \\(', x)[[1]])))\n}\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n\
    \    # split the parenthesis string by spaces and then find the nested parentheses\
    \ for each group\n    # finally return the maximum depth for each group\n    unlist(lapply(strsplit(paren_string,\
    \ \" \")[[1]], function(a) {\n        depth <- c(0)\n        for (i in seq_along(a))\
    \ {\n            if (a[i] == \"(\") {\n                depth <- c(depth, depth[length(depth)]\
    \ + 1)\n            } else if (a[i] == \")\") {\n                depth <- c(depth,\
    \ depth[length(depth)] - 1)\n            }\n        }\n        max(depth)\n  \
    \  }))\n}\n", "\n    strsplit(paren_string, \" \")[[1]] %>% \n        map(stringr::str_count)\
    \ %>% \n        map_int(max)\n}\n ", "\n    paren_string <- unlist(strsplit(paren_string,\
    \ ' '))\n    paren_string <- gsub('\\\\)\\\\(', ') (', paren_string)\n    paren_string\
    \ <- gsub('\\\\(\\\\)', '0', paren_string)\n    paren_string <- gsub('\\\\(',\
    \ '1', paren_string)\n    paren_string <- gsub('\\\\)', '0', paren_string)\n \
    \   paren_string <- gsub('1', '(', paren_string)\n    paren_string <- gsub('0',\
    \ ')', paren_string)\n    paren_string <- gsub('^\\\\(|\\\\)$', '', paren_string)\n\
    \    paren_string <- gsub('\\\\)\\\\(', ')(', paren_string)\n    paren_string\
    \ <- gsub('\\\\(\\\\)', '00', paren_string)\n    paren_string <- gsub('\\\\(',\
    \ '11', paren_string)\n    paren_string <- gsub('\\\\)', '00', paren_string)\n\
    \    paren_string <- gsub('11', '(', paren_string)\n    paren_string <- gsub('00',\
    \ ')', paren_string)\n    depth <- mapply(function(x) sapply(strsplit(x, ''),\
    \ function(y) cumsum(as.numeric(y) == '(') - cumsum(as.numeric(y) == ')')), paren_string)\n\
    \    return(max(depth))\n}\n\nparse_nested_parens('(()()) ((())) () ((())()())')\n",
  "\n  #*****************************************************************************#\n\
    \  #                                                                         \
    \    #\n  #                                                                  \
    \           #\n  #               Replace the blank with your own implementation.\
    \               #\n  #                                                       \
    \                      #\n  #                                                \
    \                             #\n  #*****************************************************************************#\n\
    \  return(c(1, 2, 3, 4))\n}", "\n  stopifnot(is.character(paren_string))\n  strsplit(paren_string,\
    \ ' ')[[1]] %>%\n    str_length %>%\n    cumsum %>%\n    { .[-1] - .[-length(.)]\
    \ } %>%\n    as.numeric\n}", "\n  \n  parse_parens <- function(paren_string) {\n\
    \    paren_string <- as.character(paren_string)\n    paren_string <- gsub(\"\\\
    \\(\\\\)\", \"\", paren_string)\n    paren_string <- gsub(\"^\\\\(\", \"\", paren_string)\n\
    \    paren_string <- gsub(\"\\\\)$\", \"\", paren_string)\n    paren_string <-\
    \ strsplit(paren_string, split=\"\\\\)(?=\\\\()\")[[1]]\n    paren_string <- lapply(paren_string,\
    \ parse_parens)\n    max(unlist(lapply(paren_string, length)))\n  }\n  \n  unlist(lapply(strsplit(paren_string,\
    \ split=\" \")[[1]], parse_parens))\n}\nparse_nested_parens('(()()) ((())) ()\
    \ ((())()())')\n", "\n    if (length(paren_string) == 0) {\n        return(numeric(0))\n\
    \    }\n    else {\n        paren_groups <- unlist(strsplit(paren_string, ' '))\n\
    \        paren_group_max <- vector(mode = 'numeric', length = length(paren_groups))\n\
    \        for (group in paren_groups) {\n            paren_group_max[group] <-\
    \ max_nested_parens(group)\n        }\n        return(paren_group_max)\n    }\n\
    }\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n  # replace each\
    \ group of parentheses with its length\n  ret <- lapply(strsplit(paren_string,\
    \ \" \")[[1]], function(x) length(gregexpr(\"\\\\)\", x)[[1]]))\n  # return the\
    \ deepest level of nesting\n  return(max(unlist(ret)))\n}\n", "\n    ## YOUR CODE\
    \ GOES HERE\n}\n ", "\n  paren_string <- strsplit(paren_string, ' ')[[1]]\n  paren_string\
    \ <- stringr::str_extract_all(paren_string, '\\\\(+\\\\)')\n  unlist(lapply(paren_string,\
    \ nchar))\n}\n \nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n  #\
    \ Split paren_string into separate groups by spaces\n  paren_groups <- strsplit(paren_string,\
    \ ' ')[[1]]\n  # Initialize our output\n  depths <- integer(length(paren_groups))\n\
    \  # Loop through each group\n  for (i in seq_along(paren_groups)) {\n    # Initialize\
    \ the number of unmatched '(' and ')'\n    unmatched_open <- 0\n    unmatched_close\
    \ <- 0\n    # Loop through each character in the current group\n    for (j in\
    \ seq_along(paren_groups[[i]])) {\n      # Increment the number of unmatched open\
    \ parentheses\n      if (paren_groups[[i]][j] == '(') {\n        unmatched_open\
    \ <- unmatched_open + 1\n      }\n      # Increment the number of unmatched closed\
    \ parentheses\n      if (paren_groups[[i]][j] == ')') {\n        unmatched_close\
    \ <- unmatched_close + 1\n      }\n      # Check if there are more closed parentheses\
    \ than open parentheses\n      if (unmatched_close > unmatched_open) {\n     \
    \   # If so, then the parentheses are not nested properly\n        depths[i] <-\
    \ -1\n        break\n      }\n    }\n    # If the above if statement did not execute,\
    \ then record the number of unmatched parentheses\n    if (depths[i] != -1) {\n\
    \      depths[i] <- unmatched_open\n    }\n  }\n  return(depths)\n}\n ", "\n \
    \ # Insert code to parse paren_string and return vector of nesting levels.\n \
    \ # Feel free to add any additional helper functions.\n\n  # YOUR CODE HERE\n\
    \  number <- strsplit(paren_string, \" \")\n  for (i in 1:length(number)){\n \
    \   temp <- number[[i]]\n    count <- 0\n    for (j in 1:length(temp)){\n    \
    \  if (temp[j] == \"(\"){\n        count <- count + 1\n      }\n      if (temp[j]\
    \ == \")\"){\n        count <- count - 1\n      }\n    }\n    number[[i]] <- count\n\
    \  }\n  number\n}\nparse_nested_parens('(()()) ((())) () ((())()())')", "\n  paren_string\
    \ <- strsplit(paren_string, '\\\\s+')\n  max_depth <- vector()\n  paren_string\
    \ <- lapply(paren_string, function(s) {\n    len <- nchar(s)\n    is_open <- vector()\n\
    \    max_depth <- vector()\n    paren_depth <- 0\n    max_paren_depth <- 0\n \
    \   for (i in 1:len) {\n      if (substr(s, i, i) == '(') {\n        paren_depth\
    \ <- paren_depth + 1\n        is_open <- c(is_open, TRUE)\n      } else {\n  \
    \      paren_depth <- paren_depth - 1\n        is_open <- c(is_open, FALSE)\n\
    \      }\n      if (paren_depth > max_paren_depth) {\n        max_paren_depth\
    \ <- paren_depth\n      }\n      max_depth <- c(max_depth, max_paren_depth)\n\
    \    }\n    max_depth\n  })\n  paren_string <- unlist(paren_string)\n  paren_string\n\
    }\n \nparse_nested_parens('(()()) ((())) () ((())()())')\n ", "\n  parsed_levels\
    \ <- str_extract_all(paren_string, \"(\\\\(+\\\\))\")\n  parsed_levels <- str_split(paste(parsed_levels,\
    \ collapse = \" \"), \"\\\\)\")\n  parsed_levels <- parsed_levels[[1]]\n  str_count(parsed_levels,\
    \ \"\\\\(\")\n}\nparse_nested_parens('(()()) ((())) () ((())()())')\n", "\n  \
    \  mapply(function(p){\n        n <- nchar(p)\n        p <- strsplit(p, split\
    \ = \"\")[[1]]\n        max.depth <- 0\n        open.paren <- 0\n        for (i\
    \ in 1:n) {\n            if (p[i] == \"(\") {\n                open.paren <- open.paren\
    \ + 1\n                max.depth <- max(max.depth, open.paren)\n            }\
    \ else if (p[i] == \")\") {\n                open.paren <- open.paren - 1\n  \
    \          }\n        }\n        return(max.depth)\n    }, strsplit(paren_string,\
    \ \" \"))\n}\n ", "\n    # Write your code here\n    return(c(0))\n}\n", "\n \
    \   # Split the string into groups based on the space separator\n    groups <-\
    \ strsplit(paren_string, ' ')[[1]]\n    # For each group, find the max depth of\
    \ parentheses\n    depths <- sapply(groups, function(g)\n        max(sapply(gregexpr('\\\
    \\(', g), length)))\n    # Return a vector of depths\n    return(depths)\n}\n",
  "\n  # YOUR CODE HERE\n  strsplit(paren_string, '\\\\s+')[[1]] %>%\n    sapply(function(str)\
    \ {\n      sum(str %>% unlist %>% as.character %>% strsplit('') %>% \n       \
    \      sapply(function(ch) ifelse(ch == '(', 1, ifelse(ch == ')', -1, 0)))) /\
    \ 2\n    })\n}\n ", "\n    # YOUR CODE HERE\n    string <- paste0(paren_string,\
    \ collapse = \"\")\n    string_length <- nchar(string)\n    open_vector <- vector(length\
    \ = string_length)\n    close_vector <- vector(length = string_length)\n    answer\
    \ <- character(0)\n    counter <- 0\n    test <- 0\n    left_paren <- 0\n    right_paren\
    \ <- 0\n    for (i in 1:string_length) {\n        if (substr(string, i, i) ==\
    \ \"(\") {\n            counter <- counter + 1\n            left_paren <- i\n\
    \            open_vector[counter] <- i\n        }\n        if (substr(string,\
    \ i, i) == \")\") {\n            counter <- counter + 1\n            right_paren\
    \ <- i\n            close_vector[counter] <- i\n        }\n        if (left_paren\
    \ > right_paren) {\n            test <- test + 1\n        }\n        if (left_paren\
    \ == right_paren) {\n            answer <- c(answer, test)\n            test <-\
    \ 0\n        }\n    }\n    return(answer)\n}\nparse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n", "\n  # Regular expression to match nested group of parentheses.\n\
    \  # (()()) matches two levels of nested parentheses, ((())) matches three, and\
    \ so on.\n  nested_parens_regex <- '\\\\(+\\\\)'\n  paren_match <- gregexpr(nested_parens_regex,\
    \ paren_string)\n  regmatches(paren_string, paren_match)[[1]]\n}\nnested_parens_counts\
    \ <- parse_nested_parens(paren_string)\nprint(nested_parens_counts)\n", "\n  \
    \  n <- nchar(paren_string)\n    ans <- c()\n    cnt <- 0\n    for (i in 1:n)\
    \ {\n        if (substr(paren_string, i, i) == \"(\") {\n            cnt <- cnt\
    \ + 1\n        } else if (substr(paren_string, i, i) == \")\") {\n           \
    \ cnt <- cnt - 1\n        } else if (substr(paren_string, i, i) == \" \") {\n\
    \            ans <- c(ans, cnt)\n            cnt <- 0\n        }\n    }\n    if\
    \ (cnt != 0) {\n        ans <- c(ans, cnt)\n    }\n    return(ans)\n}\n", "\n\
    \  nest_levels <- sapply(strsplit(paren_string, split = ''), count_nested_parens)\n\
    \  return(nest_levels)\n}\n", "\n    # TODO: Complete this function\n    r <-\
    \ strsplit(paren_string, \" \")\n    a <- sapply(r, function(x) {\n        data.frame(level\
    \ = 0,\n                   pos = numeric(0))\n    })\n    for (i in 1:length(r))\
    \ {\n        a[[i]] <- cbind(a[[i]], data.frame(rep(as.character(unlist(strsplit(r[[i]],\
    \ \"\"))), 2),\n                                          stringsAsFactors = FALSE))\n\
    \        for (j in 1:nrow(a[[i]])) {\n            if (a[[i]][j, 1] == \"(\") {\n\
    \                a[[i]][j, 2] <- a[[i]][j - 1, 2] + 1\n            } else if (a[[i]][j,\
    \ 1] == \")\") {\n                a[[i]][j, 2] <- a[[i]][j - 1, 2] - 1\n     \
    \       } else {\n                a[[i]][j, 2] <- a[[i]][j - 1, 2]\n         \
    \   }\n        }\n    }\n    b <- sapply(a, function(x) max(x[, 2]))\n    b\n\
    }\ncheckEqualsNumeric(parse_nested_parens('(()()) ((())) () ((())()())'),\n  \
    \                 c(2, 3, 1, 3),\n                   testname = 'parse_nested_parens')\n\
    \ \nprint('OK!')\n "]
stop_tokens:
- "\n#"
- "\n```"
