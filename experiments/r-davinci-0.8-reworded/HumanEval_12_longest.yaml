name: HumanEval_12_longest
language: r
prompt: "# Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n# strings of the same length. Return NULL in case the input\
  \ list is empty.\n# >>> longest(c())\n# NULL\n# >>> longest(c('a', 'b', 'c'))\n\
  # 'a'\n# >>> longest(c('a', 'bb', 'ccc'))\n# 'ccc'\nlongest <- function(strings)\
  \ {"
tests: "test_humaneval <- function() {\ncandidate <- longest\n    if(!identical(candidate(c()),\
  \ NULL)){quit('no', 1)}\n    if(!identical(candidate(c('x', 'y', 'z')), 'x')){quit('no',\
  \ 1)}\n    if(!identical(candidate(c('x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc')),\
  \ 'zzzz')){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  if (length(strings) == 0) {\n    return(NULL)\n  }\n  res <- NULL\n\
    \  for (str in strings) {\n    if (length(str) > length(res)) {\n      res <-\
    \ str\n    }\n  }\n  return(res)\n}\n", "\n  if(length(strings) == 0) return(NULL)\n\
    \  else return(strings[which.max(nchar(strings))])\n}\n", "\n  if (length(strings)\
    \ == 0) {\n    return(NULL)\n  } else {\n    strings.index <- which.max(nchar(strings))\n\
    \    return(strings[strings.index])\n  }\n}\nlongest(c())\nlongest(c('a', 'b',\
    \ 'c'))\nlongest(c('a', 'bb', 'ccc'))\n", "\n    if (length(strings) == 0) {\n\
    \        return(NULL)\n    }\n    l <- 0\n    ind <- 1\n    for (i in 1:length(strings))\
    \ {\n        if (length(strings[i]) > l) {\n            l <- length(strings[i])\n\
    \            ind <- i\n        }\n    }\n    return(strings[ind])\n}\n", "\n \
    \   if (length(strings) == 0) {\n        return(NULL)\n    }\n    if (length(strings)\
    \ == 1) {\n        return(strings)\n    }\n    ordered_strings <- sort(strings,\
    \ decreasing = TRUE, index.return = TRUE)\n    return(ordered_strings$x[1])\n\
    }\nlongest(c('a', 'bb', 'ccc'))\n", "\n  if (length(strings) == 0) {\n    return(NULL)\n\
    \  }\n  return(strings[which.max(nchar(strings))])\n}\n", "\n  ind <- which.max(nchar(strings))\n\
    \  if(is.na(ind)){\n    return(NULL)\n  } else {\n    return(strings[ind])\n \
    \ }\n}\n", "\n\tif (length(strings) == 0) {\n\t\treturn(NULL)\n\t}\n\tmaxlen <-\
    \ 0\n\tlongest <- strings[1]\n\tfor (string in strings) {\n\t\tif (nchar(string)\
    \ > maxlen) {\n\t\t\tmaxlen <- nchar(string)\n\t\t\tlongest <- string\n\t\t}\n\
    \t}\n\treturn(longest)\n}\n", "\n  if(length(strings) == 0) {\n    return(NULL)\n\
    \  }\n  max <- -1\n  max_string <- strings[1]\n  for(i in 1:length(strings)) {\n\
    \    if(nchar(strings[i]) > max) {\n      max <- nchar(strings[i])\n      max_string\
    \ <- strings[i]\n    }\n  }\n  return(max_string)\n}", "\n    if (length(strings)\
    \ == 0) {\n        return(NULL)\n    } else {\n        return(strings[which.max(nchar(strings))])\n\
    \    }\n}\n", "\n    if (length(strings) == 0) {\n        return(NULL)\n    }\
    \ else {\n        longest_string <- strings[1]\n        for (string in strings)\
    \ {\n            if (nchar(string) > nchar(longest_string)) {\n              \
    \  longest_string <- string\n            }\n        }\n        return(longest_string)\n\
    \    }\n}\n", "\n  lengths <- sapply(strings, nchar)\n  if(length(lengths) ==\
    \ 0) return(NULL)\n  strings[which.max(lengths)]\n}\n", "\n   longest_string <-\
    \ NULL\n   longest_length <- 0\n   for (string in strings) {\n      string_length\
    \ <- nchar(string)\n      if (string_length > longest_length) {\n         longest_string\
    \ <- string\n         longest_length <- string_length\n      }\n   }\n   return(longest_string)\n\
    }\n", "\n\tif (length(strings) == 0) {\n\t\treturn(NULL)\n\t}\n\t\n\tlongest_index\
    \ <- 1\n\tlongest_string <- strings[1]\n\t\n\tfor (i in 2:length(strings)) {\n\
    \t\tif (nchar(strings[i]) > nchar(longest_string)) {\n\t\t\tlongest_index <- i\n\
    \t\t\tlongest_string <- strings[i]\n\t\t}\n\t}\n\t\n\treturn(longest_string)\n\
    }\n", "\n    if(length(strings) == 0) {\n        return(NULL)\n    }\n    else\
    \ {\n        return(max(strings, key = length))\n    }\n}\n", "\n  if (length(strings)\
    \ == 0) {\n    return(NULL)\n  } else {\n    return(strings[which.max(nchar(strings))])\n\
    \  }\n}\n", "\n\t# check if input is character\n\tif(!is.character(strings)) {\n\
    \t\tstop(\"input must be a character vector.\")\n\t}\n\tif(length(strings) ==\
    \ 0) {\n\t\treturn(NULL)\n\t}\n\treturn(strings[which.max(nchar(strings))])\n\
    }\n", "\n    if (length(strings) == 0) {\n        return(NULL)\n    } else {\n\
    \        strings <- strings[order(nchar(strings), decreasing = TRUE)]\n      \
    \  return(strings[1])\n    }\n}\nlongest(c())\nlongest(c('a', 'b', 'c'))\nlongest(c('a',\
    \ 'bb', 'ccc'))\n", "\n  if (length(strings) == 0) {\n    NULL\n  } else {\n \
    \   max(strings, key = nchar)\n  }\n}", "\n  if(length(strings) == 0) return(NULL)\n\
    \  string <- strings[1]\n  for(i in strings) {\n    if(nchar(i) > nchar(string))\
    \ {\n      string <- i\n    }\n  }\n  return(string)\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
