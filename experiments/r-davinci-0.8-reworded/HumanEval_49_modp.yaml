name: HumanEval_49_modp
language: r
prompt: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n# >>>\
  \ modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100,\
  \ 101)\n# 1\nmodp <- function(n, p) {"
tests: "test_humaneval <- function() {\ncandidate <- modp\n    if(!identical(candidate(3,\
  \ 5), 3)){quit('no', 1)}\n    if(!identical(candidate(1101, 101), 2)){quit('no',\
  \ 1)}\n    if(!identical(candidate(0, 101), 1)){quit('no', 1)}\n    if(!identical(candidate(3,\
  \ 11), 8)){quit('no', 1)}\n    if(!identical(candidate(100, 101), 1)){quit('no',\
  \ 1)}\n    if(!identical(candidate(30, 5), 4)){quit('no', 1)}\n    if(!identical(candidate(31,\
  \ 5), 3)){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  if (n == 0) {\n    return(1)\n  }\n  x <- 1\n  if (n % 2 != 0)\
    \ {\n    x <- p\n  }\n  return((modp(n / 2, p) ^ 2 * x) %% p)\n}\n", "\n  binary\
    \ <- intToBinary(n)\n  current <- 1\n  for (i in (1:length(binary))) {\n    if\
    \ (binary[i] == 1) {\n      current <- mod(current * (2 %^ i), p)\n    }\n  }\n\
    \  return(current)\n}\n", "\n  if (n == 0) {\n    return(1)\n  }\n  else {\n \
    \   if (n %% 2 == 0) {\n      # even number\n      x <- modp(n/2, p)\n      return((x*x)\
    \ %% p)\n    }\n    else {\n      # odd number\n      x <- modp((n-1)/2, p)\n\
    \      return((x*x*2) %% p)\n    }\n  }\n}\n", "\n  base <- 2\n  if (n == 0) {\n\
    \    return(1)\n  }\n  result <- 1\n  while (n > 0) {\n    result <- mod(base\
    \ * result, p)\n    n <- n - 1\n  }\n  return(result)\n}\n", "\n    if (n == 0)\n\
    \        return(1)\n    else {\n        if (n %% 2 == 0)\n            x <- modp(n\
    \ / 2, p)\n        else\n            x <- modp(n - 1, p)\n        return((x *\
    \ x) %% p)\n    }\n}\n", "\n  if (n == 0) return(1)\n  if (n %% 2 == 0) {\n  \
    \  v <- modp(n/2, p)\n    return(v*v %% p)\n  } else {\n    return(n*modp(n-1,\
    \ p) %% p)\n  }\n}\n", "\n  p <- as.integer(p)\n  n <- as.integer(n)\n  if (n\
    \ == 0) {\n    return(1)\n  }\n  if (n == 1) {\n    return(2)\n  }\n  if (n %%\
    \ 2 == 0) {\n    return(modp(n / 2, p)^2 %% p)\n  }\n  else {\n    return(2 *\
    \ modp(n - 1, p) %% p)\n  }\n}", "\n  nthroot <- function(p, n) {\n    return(p^(1/n))\n\
    \  }\n  return(nthroot(2, n) %% p)\n}\n", "\n  if (n == 0) return(1)\n  w <- n\n\
    \  if (w < 0) w <- p - (-w %% p)\n  ans <- 1\n  for (i in 1:as.integer(w)) ans\
    \ <- ans * 2 %% p\n  return(ans)\n}\n ", "\n    if (n == 0) {\n        return(1)\n\
    \    }\n    if (n %% 2 == 0) {\n        res <- modp(n/2, p)\n        res <- res*res\
    \ %% p\n    } else {\n        res <- modp(n-1, p)\n        res <- res*2 %% p\n\
    \    }\n    return(res)\n}\n", "\n  a <- n %% p\n  d <- ifelse(a == 0, 1, a)\n\
    \  d <- d * 2\n  d <- d %% p\n  d\n}\n\np <- 101\n\nsolution <- c()\nfor (a in\
    \ 0:99) {\n  x <- 0\n  for (i in 1:100) {\n    x <- modp(x, p)\n    if (x == 1)\
    \ {\n      break\n    }\n  }\n  solution <- c(solution, x)\n}\n", "\n  # Replace\
    \ the next line with your own code.\n  print(2^n %% p)\n}\nmodp(3, 5)\nmodp(1101,\
    \ 101)\nmodp(0, 101)\nmodp(3, 11)\nmodp(100, 101)\n", "\n    if (n == 0) {\n \
    \       return(1)\n    }\n    if (n % 2 == 0) {\n        return((modp(n/2, p)\
    \ ^ 2) %% p)\n    }\n    else {\n        return(((modp((n-1)/2, p) ^ 2) * n) %%\
    \ p)\n    }\n}\n", "\n  if (n > 1) {\n    n_prime <- n %% 2\n    # n is even\n\
    \    if (n_prime == 0) {\n      return (as.integer(modp(n/2, p)^2 %% p))\n   \
    \ } else {\n      # n is odd\n      return (as.integer((2 * modp((n-1)/2, p)^2)\
    \ %% p))\n    }\n  } else {\n    return (1)\n  }\n}\n", "\n    if (n == 0) return(1)\n\
    \    if (n == 1) return(p)\n    if (n %% 2 == 0) return(modp(n/2, p)^2)\n    return(p\
    \ * modp((n-1)/2, p)^2)\n}\n", "\n  if (n == 0) {\n    return(1)\n  }\n  elif\
    \ (n % 2 == 0) {\n    t <- modp(n / 2, p)\n    return((t * t) %% p)\n  }\n  else\
    \ {\n    return((2 * modp(n - 1, p)) %% p)\n  }\n}\n", "\n    c=1\n    for (i\
    \ in 1:n) {\n        c <- (c*2) %% p\n    }\n    return(c)\n}\n", "\n  k <- 1\n\
    \  while (n > 0) {\n    if (n %% 2 == 1) {\n      k <- k * 2 %% p\n    }\n   \
    \ n <- n %/% 2\n  }\n  k\n}\n ", "\n  a <- 1\n  b <- n\n  while (b > 0) {\n  \
    \  if (b%%2 == 1) {\n      a <- (a*n)%%p\n    }\n    n <- (n*n)%%p\n    b <- floor(b/2)\n\
    \  }\n  return(a)\n}\n", "\n    stopifnot(!is.na(n) && !is.na(p) && p > 0)\n \
    \   modp_ <- function(n, p, b) {\n        if (n == 0) return(1)\n        if (n\
    \ == 1) return(b)\n        bb <- modp_(n / 2, p, b)\n        bb <- bb * bb\n \
    \       if (n %% 2 == 1) bb <- bb * b\n        return(bb %% p)\n    }\n    return(modp_(n,\
    \ p, 2))\n}\n ", "\n  power <- 1\n  binary <- (n > 0)\n  while (binary) {\n  \
    \  if (n %% 2 == 1) {\n      power <- (power * 2) %% p\n    }\n    n <- (n > 1)\n\
    \    binary <- (n > 0)\n  }\n  return(power)\n}\n", "\n  if (p < 1) stop(\"p must\
    \ be at least 1\")\n  if (n < 0) stop(\"n must be non-negative\")\n  if (n ==\
    \ 0) return(1)\n  modp(floor(n/2), p)^2 %% p\n}\nmodp(3, 5)\nmodp(1101, 101)\n\
    modp(0, 101)\nmodp(3, 11)\nmodp(100, 101)\n", "\n    if (n == 0) return(1)\n \
    \   if (n == 1) return(2)\n    if (n %% 2 == 0) {\n        t <- modp(n/2, p)\n\
    \        return((t * t) %% p)\n    } else {\n        t <- modp((n-1)/2, p)\n \
    \       return((t * t * 2) %% p)\n    }\n}\n\nmodp(1, 11)\n", "\n  # YOUR CODE\
    \ HERE\n  if (n == 0) {\n    return(1)\n  } else {\n    return(2*modp(n-1, p)%%p)\n\
    \  }\n}\n\nmodp(3, 5)\nmodp(1101, 101)\nmodp(0, 101)\nmodp(3, 11)\nmodp(100, 101)\n\
    \nanswer_seven <- modp(3, 5)\nanswer_eight <- modp(1101, 101)\nanswer_nine <-\
    \ modp(0, 101)\nanswer_ten <- modp(3, 11)\nanswer_eleven <- modp(100, 101)\n",
  "\n  if (n == 0) {\n    return(1)\n  }\n  ## Choose the right bit\n  l <- floor(log(n,\
    \ 2))\n  a <- 2 ^ l\n  ## Now we can recurse as a^(2^k) = (a^2)^k\n  return(modp(n\
    \ - a, p) * 2 ^ (l * mod(n, 2)) %% p)\n}\n", "\n  # Write your code here.\n  if\
    \ (n == 0) {\n    return(1)\n  }\n  if (n == 1) {\n    return(2)\n  }\n  if (n\
    \ %% 2 == 0) {\n    return(1 + (modp(n - 1, p) * 2) %% p)\n  }\n  if (n %% 2 ==\
    \ 1) {\n    return(1 + (modp(n - 1, p) * modp(n - 1, p)) %% p)\n  }\n}\n", "\n\
    \  if (n == 0) {\n    return(1)\n  }\n  if (n == 1) {\n    return(2)\n  }\n  p2\
    \ <- modp(n-1, p)\n  if (p2 >= (p/2)) {\n    p2 <- p2 - p\n  }\n  res <- 2*p2\n\
    \  if (res >= p) {\n    res <- res - p\n  }\n  return(res)\n}\n\nisPrime <- function(n)\
    \ {\n  if (n <= 1) {\n    return(FALSE)\n  }\n  if (n <= 3) {\n    return(TRUE)\n\
    \  }\n  if (n %% 2 == 0 || n %% 3 == 0) {\n    return(FALSE)\n  }\n  i <- 5\n\
    \  while (i*i <= n) {\n    if (n %% i == 0 || n %% (i+2) == 0) {\n      return(FALSE)\n\
    \    }\n    i <- i + 6\n  }\n  return(TRUE)\n}\n\nnthPrime <- function(n) {\n\
    \  count <- 0\n  i <- 1\n  while (count < n) {\n    i <- i + 1\n    if (isPrime(i))\
    \ {\n      count <- count + 1\n    }\n  }\n  return(i)\n}\n\nrndprm <- function(m)\
    \ {\n  return(nthPrime(floor(runif(1, 1, m))))\n}\n", "\n  if (n == 0) {\n   \
    \ return(1)\n  }\n  v <- 1\n  for (i in 1:n) {\n    v <- v*2 %% p\n  }\n  return(v)\n\
    }\n", "\n    if (n == 0) {\n        return(1)\n    } else if (n < 0) {\n     \
    \   return(0)\n    } else {\n        return(modp(n - 1, p) * 2 %/% p)\n    }\n\
    }", "\n  if (n == 0) {\n    return(1)\n  }\n  if (n == 1) {\n    return(2)\n \
    \ }\n  return(2 * modp(n - 1, p) %/% 2) %% p\n}\n ", "\n    if (n == 0) {\n  \
    \      return (1)\n    } else if (n == 1) {\n        return (2)\n    } else {\n\
    \        return (modp(n - 1, p) * 2 %/% p)\n    }\n}", "\n  if (n == 0)\n    return(1)\n\
    \  m <- modp(floor(n/2), p)\n  result <- m^2 %% p\n  if (n %% 2 == 1)\n    result\
    \ <- result * 2 %% p\n  return(result)\n}\n", "\n  ## Fill in\n  x = 1;\n  k =\
    \ n;\n  while (k > 0) {\n    if (k%%2 != 0) {\n      x = (x*n)%%p;\n    }\n  \
    \  n = (n*n)%%p;\n    k = floor(k/2);\n  }\n  return(x);\n}", "\n    if (n ==\
    \ 0) {\n        return(1)\n    }\n    else {\n        return(modp(n - 1, p) *\
    \ 2 %/% p)\n    }\n}\n", "\n   if (n == 0) {\n      return(1)\n   } else if (n\
    \ == 1) {\n      return(2)\n   } else if (n == 2) {\n      return(4)\n   } else\
    \ if (n % 2 == 0) {\n      return(modp(n/2, p)^2 %% p)\n   } else {\n      return(2\
    \ * modp(n-1, p) %% p)\n   }\n}\n", "\n  if (n == 0) {\n    return(1)\n  } else\
    \ if (n == 1) {\n    return(2)\n  } else {\n    power <- 2\n    for (i in 2:n)\
    \ {\n      power <- (power * 2) %% p\n    }\n    return(power)\n  }\n}\n", "\n\
    \  if (n == 0) return(1)\n  if (n %% 2 == 0) {\n    return(modp(n/2, p)^2 %% p)\n\
    \  } else {\n    return(2 * modp(n-1, p) %% p)\n  }\n}\n\n\"\"\"\n\nflpt_py =\
    \ \"\"\"\ndef modp(n, p):\n    if n == 0:\n        return 1\n    if n % 2 == 0:\n\
    \        return modp(n/2, p)**2 % p\n    else:\n        return 2 * modp(n-1, p)\
    \ % p\n\"\"\"\n\nfor lang in [rpy,rpf,rpfu,rpfb,\n             rppf,rppfu,rppfb,\n\
    \             rnpy,\n             rnppf,rnppfu,rnppfb,\n             rms,\n  \
    \           rmppf,rmppfu,rmppfb,\n             rll,\n             rllu,\n    \
    \         flpt_py,\n             flpt_cpy,\n             flpt_ipy,\n         \
    \    flpt_cipy,\n             ]:\n    print \"***\",lang\n    t = Timer(stmt=lang,\
    \ setup=\"from __main__ import modp\")\n    print \"n=1000\", t.timeit(number=1000)\n\
    \    print \"n=10000\", t.timeit(number=10000)\n    print \"n=100000\", t.timeit(number=100000)\n\
    \    print \"n=1000000\", t.timeit(number=1000000)\n    print \"n=10000000\",\
    \ t.timeit(number=10000000)\n    print \"n=100000000\", t.timeit(number=100000000)",
  "\n  n %/% p\n}", "\n  if (n == 0) { return(1) }\n  if (n == 1) { return(n %% p)\
    \ }\n  a <- modp(n %/% 2, p)\n  a * a * modp(n %% 2, p) %% p\n}\n", "\n    if\
    \ (n == 0)\n        return(1)\n    a <- modp(n %/% 2, p)\n    a2 <- (a * a) %%\
    \ p\n    if (n %% 2 == 0)\n        return(a2)\n    else\n        return((a2 *\
    \ 2) %% p)\n}\n", "\n  result <- 1\n  while (n > 0) {\n    if (n %% 2 == 1) {\n\
    \      result <- (result * 2) %% p\n    }\n    n <- n %/% 2\n  }\n  return(result)\n\
    }\n ", "\n  if (n == 0) {\n    return(1)\n  }\n  if (n == 1) {\n    return(3)\n\
    \  }\n  floor(n / 2)\n  return(  (p * modp(floor(n / 2), p) * modp(floor(n / 2),\
    \ p)) %% p + (n %% 2) * modp(floor(n / 2), p) )\n}\n", "\n  if (n == 0) {\n  \
    \  return(1)\n  } else if (n == 1) {\n    return(p)\n  } else if (n %% 2 == 0)\
    \ {\n    return( modp(n / 2, p) * modp(n / 2, p) %% p )\n  } else {\n    return(\
    \ modp(1, p) * modp(n - 1, p) %% p )\n  }\n}", "\n  ## Return n^p modulo p (be\
    \ aware of numerics).\n  n <- n %% p\n  res <- 1\n  while (n > 0) {\n    if (n\
    \ %% 2 == 1) {\n      res <- (res * n) %% p\n    }\n    n <- n %/% 2\n    n <-\
    \ (n * n) %% p\n  }\n  res\n}\n ", "\n  r <- 1\n  if (n < 0) {\n    n = -n\n \
    \   p = 1/p\n  }\n  while (n > 0) {\n    if (n %% 2 == 1) {\n      r = r * p\n\
    \    }\n    p = p * p\n    n = n %/% 2\n  }\n  return(r)\n}", "\n  # TODO\n}",
  "\n    if (n == 0) {\n        return(1)\n    }\n    else {\n        tmp <- modp(floor(n/2),\
    \ p)\n        if (n %% 2 == 0) {\n            return(tmp*tmp %% p)\n        }\n\
    \        else {\n            return(2*tmp*tmp %% p)\n        }\n    }\n}\n", "\n\
    \  x <- 1\n  i <- 0\n  while (i < n) {\n    x <- (x * 2) %% p\n    i <- i + 1\n\
    \  }\n  return(x)\n}", "\n  if (n == 0)\n    return(1)\n  x <- modp(n / 2, p)\n\
    \  x <- x * x %% p\n  if (n %% 2 == 1)\n    x <- x * 2 %% p\n  return(x)\n}\n",
  "\n    if (n == 0) {\n        return(1)\n    } else if (n == 1) {\n        return(2)\n\
    \    } else {\n        return(2 * modp(n - 1, p) %% p)\n    }\n}\n", "\n  if (n\
    \ == 0) return(1)\n  elif (n == 1) return(2)\n  else {\n    if (n %% 2 == 0) {\n\
    \      return(modp(n / 2, p)^2 %% p)\n    } else {\n      return(2 * modp(n -\
    \ 1, p) %% p)\n    }\n  }\n}\n ", "\n    ## base case\n    if (n == 0) {\n   \
    \     return(1)\n    } else {\n        ## recursive case\n        if (n %% 2 ==\
    \ 0) {\n            sqrtmodp <- modp(n / 2, p)\n            return(sqrtmodp ^\
    \ 2 %% p)\n        } else {\n            return(2 * modp(n - 1, p) %% p)\n   \
    \     }\n    }\n}\n", "\n  if (n == 0) {\n    return(1)\n  }\n  if (n == 1) {\n\
    \    return(2)\n  }\n  return(2 * modp(n - 1, p) %% p)\n}", "\n    if (n == 0)\
    \ {\n        return(1)\n    }\n    else {\n        return(2*modp(n-1, p) %% p)\n\
    \    }\n}\n", "\n    u <- 1\n    d <- 2\n    while (n > 0) {\n        if (n %%\
    \ 2 == 1)\n            u <- (u * d) %% p\n        d <- (d * d) %% p\n        n\
    \ <- n %/% 2\n    }\n    return(u)\n}\n", "\n  m <- 1\n  while (n != 0) {\n  \
    \  if (n %% 2 == 1) {\n      m <- (m * 2) %% p\n    }\n    n <- n %/% 2\n  }\n\
    \  return(m)\n}\n", "\n  if (n == 0) {\n    return(1)\n  }\n  if (n == 1) {\n\
    \    return(2)\n  }\n  # This is a clever trick: When a^b mod p = a * a * a *\
    \ ... * a,\n  # with b factors of a,\n  # then (a^2)^(b/2) mod p = a^b mod p,\n\
    \  # if b is even.\n  if (n %% 2 == 0) {\n    return(modp(n/2, p)^2 %% p)\n  }\n\
    \  return(2 * modp(n-1, p) %% p)\n}\n", "\n  if (n == 0) return(1)\n  elif (n\
    \ == 1) return(2)\n  else return(modp(n-1, p)^2 %% p)\n}\n", "\n  stopifnot(is.numeric(n),\
    \ is.numeric(p))\n  if(p <= 0) stop(\"modp: p must be positive\")\n  if(n == 0)\
    \ return(1)\n  if(p == 1) return(0)\n  if(n < 0) return(modp(-n, p))\n  # n >\
    \ 0\n  if(n %/% p == 0) return(1)\n  # n > 0, n %/% p > 0\n  if(n < p) return(n)\n\
    \  # n > 0, n %/% p > 0, n >= p\n  return(2*modp(n - floor(n/p)*p, p))\n}\n",
  "\n  # this needs to be adapted to use much larger bases...\n  a <- 2^n %% p\n \
    \ return(a)\n}\n", "\n    if (n == 0)\n        return(1)\n    if (n == 1)\n  \
    \      return(2)\n    if (n %% 2 == 0)\n        return(modp(n/2, p)^2 %% p)\n\
    \    else\n        return(2 * modp(n-1, p) %% p)\n}\n", "\n    x <- 1\n    for\
    \ (i in 1:n) {\n        x <- (x * 2) %% p\n    }\n    return(x)\n}\n", "\n   \
    \ q <- 1;\n    while (n > 0) {\n        if (n %% 2 == 1) {\n            q <- (q\
    \ * 3) %% p;\n        }\n        n <- floor(n / 2);\n        p <- (p * p) %% 101;\n\
    \    }\n    return(q);\n}\n\npascal <- function(n) {\n    if (n == 0) {\n    \
    \    return(c(1));\n    }\n    else {\n        last <- pascal(n - 1);\n      \
    \  return(append(last, 0) + append(0, last));\n    }\n}\n\nmodular_pascal <- function(n,\
    \ p) {\n    if (n == 0) {\n        return(c(1));\n    }\n    else {\n        last\
    \ <- modular_pascal(n - 1, p);\n        return(mod(append(last, 0) + append(0,\
    \ last), p));\n    }\n}\n ", "\n    if (n == 0) {\n        return(1)\n    }\n\
    \    else {\n        if (n % 2 == 0) {\n            return(modp(n / 2, p)^2 %%\
    \ p)\n        }\n        else {\n            return(2 * modp(n / 2, p)^2 %% p)\n\
    \        }\n    }\n}\n ", "\n    p <- as.integer(p)\n    n <- as.integer(n)\n\
    \    res <- 1\n    while (n > 0) {\n        if (n %% 2 == 1) {\n            res\
    \ <- (res * 2) %% p\n        }\n        n <- n %/% 2\n    }\n    res\n}\n", "\n\
    \    if (n == 0) {\n        return(1)\n    }\n    if (n == 1) {\n        return(2)\n\
    \    }\n    if (n % 2 == 0) {\n        return((modp(n / 2, p) ^ 2) %% p)\n   \
    \ }\n    return((2 * modp(n - 1, p)) %% p)\n}\n", "\n  # YOUR CODE HERE\n  if\
    \ (n==0) return(1)\n  if (n==1) return(2)\n  if (n%%2==0) return(modp(n/2,p)^2\
    \ %% p)\n  if (n%%2==1) return(2*modp((n-1)/2,p)^2 %% p)\n}\n", "\n  if (n ==\
    \ 0) {\n    return(1)\n  }\n  if (n %% 2 == 0) {\n    return(modp(n / 2, p) *\
    \ modp(n / 2, p) %% p)\n  }\n  else {\n    return(n * modp(n - 1, p) %% p)\n \
    \ }\n}\n", "\n  if (n == 0) {\n    return(1)\n  }\n  else {\n    if (n%%2 == 0)\
    \ {\n      return(((modp(n/2, p)%%p)^2)%%p)\n    }\n    else {\n      return(((modp((n-1)/2,\
    \ p)%%p)^2 * (3%%p))%%p)\n    }\n  }\n}", "\n  # your code here\n}", "\n  if (n\
    \ == 0) return(1)\n  if (n % 2 == 0) {\n    tmp <- modp(n / 2, p)\n    tmp <-\
    \ tmp * tmp %% p\n  } else {\n    tmp <- 2 * modp(n - 1, p) %% p\n  }\n  return(tmp)\n\
    }\n", "\n  if (n == 0) {\n    return(1)\n  }\n  else {\n    p_n_mod <- modp(n\
    \ / 2, p)\n    if (n %% 2 == 0) {\n      return(p_n_mod * p_n_mod %% p)\n    }\n\
    \    else {\n      return(p_n_mod * p_n_mod * 2 %% p)\n    }\n  }\n}\n", "\n \
    \ \n  # your code here\n  if(n == 0){\n    return(1)\n  }\n  if(n==1){\n    return(2)\n\
    \  }\n  return(2 * modp(n-1, p) %% p)\n}\nmodp(5,5)\n", "\n    a = 2\n    if (n\
    \ == 0) return(1)\n    if (n == 1) return(a)\n    m = modp(floor(n/2), p)\n  \
    \  if (n %% 2 == 0)\n        return(m %% p * m %% p %% p)\n    else\n        return(a\
    \ %% p * m %% p * m %% p %% p)\n}\n", "\n    n <- n %/% 1\n    if (n == 0) return(1)\n\
    \    if (n %% 2 == 0) {\n        return(modp(n/2, p) ^ 2 %% p)\n    } else {\n\
    \        return(modp(n-1, p) * 2 %% p)\n    }\n}\n", "\n   stopifnot(p > 0, n\
    \ >= 0)\n   res <- 1\n   pow <- n\n   while (pow > 0) {\n      if (pow %% 2 ==\
    \ 1) {\n         res <- (res * n) %% p\n      }\n      pow <- floor(pow / 2)\n\
    \      n <- (n * n) %% p\n   }\n   res\n}", "\n    i <- 1\n    res <- 1\n    while\
    \ (i <= n) {\n        res <- res * 2\n        res <- res %% p\n        i <- i\
    \ + 1\n    }\n    return(res)\n}", "\n  prod <- 1\n  k <- 1\n  while (k <= n)\
    \ {\n    prod <- prod * 2\n    prod <- prod %% p\n    k <- k + 1\n  }\n  prod\n\
    }\n ", "\n  if (n == 0) {\n    return(1)\n  } else if (n == 1) {\n    return(2)\n\
    \  } else {\n    return(2 * modp(n - 1, p) %% p)\n  }\n}\n", "\n\tresult <- 1\n\
    \tif (n == 0)\n\t\treturn(result)\n\tx <- 2\n\tif (n == 1)\n\t\treturn(x)\n\t\
    n <- n - 1\n\twhile (n > 0) {\n\t\tif (n %% 2 == 1)\n\t\t\tresult <- (result *\
    \ x) %% p\n\t\tx <- (x * x) %% p\n\t\tn <- n %/% 2\n\t}\n\treturn(result)\n}\n",
  "\n    if (n == 0) {\n        return(1)\n    } else if (n % 2 == 0) {\n        return(modp(n\
    \ / 2, p)^2 %% p)\n    } else {\n        return(modp(n - 1, p) * modp(1, p) %%\
    \ p)\n    }\n}\n", "\n  res <- 1\n  for (i in 1:n) {\n    res <- (res * 2) %%\
    \ p\n  }\n  return(res)\n}\n", "\n    res <- numeric(n)\n    res[1] <- 1\n   \
    \ ntimes <- floor(log(n, 2))\n    for (i in 1:ntimes) {\n        res[i+1] <- res[i]*res[i]\
    \ %% p\n    }\n    return(res[ntimes+1])\n}\n ", "\n  n <- as.integer(n)\n  p\
    \ <- as.integer(p)\n  if (n == 0) {\n    return(1)\n  }\n  res <- 1\n  while (n\
    \ > 0) {\n    if (n %% 2 != 0) {\n      res <- res * 2 %/% p\n    }\n    n <-\
    \ n %/% 2\n    res <- res * res %/% p\n  }\n  return(res)\n}\n", "\n  n2 <- 0\n\
    \  n1 <- 1\n  n3 <- -Inf\n  k <- 2\n  p <- p - 1\n  # print(p)\n  while (n > 1)\
    \ {\n    if (n %% 2 == 0) {\n      n <- n / 2\n      k <- 2 * k\n    } else {\n\
    \      n1 <- (n1 * n2) %% p\n      n <- (n - 1) / 2\n      k <- 2 * k + 1\n  \
    \  }\n    n2 <- (n2 * n2) %% p\n    # print(c(n, n1, n2, k))\n  }\n  (n1 * k)\
    \ %% p\n}\n", "\n    # Your code here\n    if (n == 0) {\n        return(1)\n\
    \    } else {\n        return(2 * modp(n - 1, p) %% p)\n    }\n}\n", "\n  n_bin\
    \ <- as.numeric(as.character(n))\n  factor <- 1\n  result <- 1\n  for (i in length(n_bin):1)\
    \ {\n    result <- result * result %% p\n    if (n_bin[i] == 1) {\n      result\
    \ <- result * factor %% p\n    }\n  }\n  return(result)\n}\n", "\n  # write.csv(x\
    \ = n, file = \"input.csv\")\n  input <- fread(\"input.csv\")\n  n <- input[1,\
    \ 1]\n  p <- input[1, 2]\n  n <- n %% (p - 1)\n  ans <- 1\n  x <- 2\n  while (n\
    \ > 0) {\n    if (n %% 2 != 0) {\n      ans <- ans * x\n      ans <- ans %% p\n\
    \    }\n    x <- x * x\n    x <- x %% p\n    n <- n / 2\n  }\n  ans\n}\n", "\n\
    \  if (n == 0) {\n    return(1)\n  } else if (n == 1) {\n    return(2)\n  } else\
    \ {\n    return(2 * modp(n - 1, p) %% p)\n  }\n}\n", "\n  stopifnot(is.integer(n),\
    \ is.integer(p), p > 1)\n  if (n == 0) {\n    return(1)\n  }\n  # calculate 2^(floor(n/2))\
    \ mod p\n  halfn <- floor(n/2)\n  recurse <- modp(halfn, p)\n  # calculate 2^n\
    \ mod p\n  if (n %% 2 == 0) {\n    # n is even\n    return(recurse * recurse %%\
    \ p)\n  } else {\n    # n is odd\n    return(2 * recurse * recurse %% p)\n  }\n\
    }", "\n  if (n == 0) {\n    return(1)\n  }\n  if (n % 2 == 0) {\n    # even\n\
    \    return(modp(n/2, p)^2 %% p)\n  } else {\n    # odd\n    return(modp(n-1,\
    \ p) * modp(1, p) %% p)\n  }\n}\n", "\n  stopifnot(is.integer(n) && is.integer(p)\
    \ && p > 1)\n  prod <- 1\n  x <- 2\n  while (n > 0) {\n    if (n %% 2 == 1) {\n\
    \      prod <- prod * x %% p\n    }\n    x <- x * x %% p\n    n <- n / 2\n  }\n\
    \  prod\n}\n ", "\n  if (n == 0) return(1)\n  z <- modp(n / 2, p)\n  z * z * ifelse(n\
    \ %% 2 == 1, 1, p - 1) %% p\n}\n", "\n  x <- 1\n  while (n > 0) {\n    if (n%%2\
    \ == 1) {\n      x <- (x*2)%%p\n    }\n    n <- n%/%2\n  }\n  return(x)\n}\n ",
  "\n    r <- 1\n    while (n >= 1) {\n        if (n%%2 == 1) {\n            r <-\
    \ (r * 2) %% p\n        }\n        n <- n %/% 2\n    }\n    return(r)\n}\n", "\n\t\
    result <- 1\n\tx <- 2\n\twhile (n != 0) {\n\t\twhile (n %% 2 == 0) {\n\t\t\tn\
    \ <- n / 2\n\t\t\tx <- x^2 %% p\n\t\t}\n\t\tn <- n - 1\n\t\tresult <- result *\
    \ x %% p\n\t}\n\treturn(result)\n}\n", "\n    # your code here\n    if (n==0)\
    \ return(1)\n    else if (n==1) return(2)\n    else return(c(2*modp(n-1,p))%%p)\n\
    }\n ", "\n    # Check for trivial cases.\n    if (n == 0) {\n        return(1)\n\
    \    }\n    if (n == 1) {\n        return(2)\n    }\n    # Handle negative n.\n\
    \    if (n < 0) {\n        return(1/modp(-n, p))\n    }\n    # Break into odd\
    \ and even and iterate.\n    a <- 1\n    b <- 2\n    while (n > 1) {\n       \
    \ if (n %% 2 == 1) {\n            a <- (a * b) %% p\n        }\n        b <- (b\
    \ * b) %% p\n        n = n %/% 2\n    }\n    return((a * b) %% p)\n}\n", "\n \
    \   if (n == 0) {\n        return(1)\n    }\n    y <- 1\n    x <- 2\n    while\
    \ (n > 1) {\n        if (n %% 2 == 0) {\n            n <- n / 2\n            x\
    \ <- x*x %% p\n        } else {\n            n <- n - 1\n            y <- x*y\
    \ %% p\n        }\n    }\n    return(x*y %% p)\n}\n", "\n  if (n == 0) {\n   \
    \ return(1)\n  }\n  # Split the calculation of 2^n into the square of 2^(n/2)\
    \ and the remainder.\n  v <- modp(n %/% 2, p)\n  v2 <- (v * v) %% p\n  if (n %%\
    \ 2 == 0) {\n    return(v2)\n  } else {\n    return((v2 * 2) %% p)\n  }\n}\n",
  "\n  if (n == 0) {\n    return(1)\n  }\n  else {\n    return(2*modp(n-1, p) %% p)\n\
    \  }\n}\n\na <- 10; b <- 10; n <- 100; p <- 10001\nx <- runif(a); y <- runif(b)\n\
    X <- sample(1:n, a, replace=TRUE); Y <- sample(1:n, b, replace=TRUE)\nprint(X)\n\
    print(Y)\n\nwin.X <- 0; win.Y <- 0\nfor (i in 1:a) {\n  if (X[i] > Y[i]) {\n \
    \   win.X <- win.X + 1\n  }\n  else if (X[i] < Y[i]) {\n    win.Y <- win.Y + 1\n\
    \  }\n}\n\nprint(win.X)\nprint(win.Y)\nprint(win.X-win.Y)\n\nsign(win.X-win.Y)",
  "\n  if (n == 0) {\n    return(1)\n  }\n  else {\n    if (n %% 2 == 0) {\n     \
    \ a <- modp(n/2, p)\n      return((a*a) %% p)\n    }\n    else {\n      return((n\
    \ * modp(n-1, p)) %% p)\n    }\n  }\n}\n", "\n   if (n == 0) {\n      1\n   }\
    \ else {\n      if (n %% 2 == 0) {\n         tmp <- modp(n / 2, p)\n         (tmp\
    \ * tmp) %% p\n      } else {\n         tmp <- modp((n - 1) / 2, p)\n        \
    \ (2 * tmp * tmp) %% p\n      }\n   }\n}\n", "\n  if (n == 0) return(1)\n  else\
    \ {\n    if (n == 1) return(2)\n    else {\n      if (n %% 2 == 0) return(modp(n\
    \ / 2, p) ^ 2 %% p)\n      else return(2 * modp(n - 1, p) %% p)\n    }\n  }\n}",
  "\n  if (n == 0) {\n    return(1)\n  }\n  # Return (2^n mod p) = (2^(n div 2) *\
    \ 2^(n div 2)) mod p\n  # = (2^(n div 2) mod p)^2 mod p.\n  if (n %% 2 == 0) {\n\
    \    return(modp(n/2, p)^2 %% p)\n  }\n  # Return (2^n mod p) = (2^(n-1) mod p)\
    \ * 2 mod p.\n  else {\n    return(modp(n-1, p) * 2 %% p)\n  }\n}\n", "\n    n\
    \ %%% p\n}\n", "\n    # We need to use double precision arithmetic to avoid overflows.\n\
    \    # The last step is the remainder.\n    return(trunc(2^n %% p))\n}\n", "\n\
    \  if (n == 0) {\n    return(1)\n  }\n  else {\n    return(2*modp(n-1, p) %% p)\n\
    \  }\n}\n ", "\n    if (n < 0) {\n        stop(\"n < 0\")\n    }\n    if (p <\
    \ 2) {\n        stop(\"p < 2\")\n    }\n    z <- 1\n    for (i in 1:n) {\n   \
    \     z <- (z * 2) %% p\n    }\n    return(z)\n}\n", "\n  nmodp <- 1\n  for (i\
    \ in 1:n) {\n    nmodp <- nmodp*2 %/% p\n  }\n  nmodp\n}\n", "\n  # Replace the\
    \ next line with your code\n  if (n == 0) return(1)\n  else return((modp(floor(n/2),\
    \ p)^2 * (n%%2 + 1)) %% p)\n}\n", "\n  if (n == 0) {\n    return(1)\n  } else\
    \ if (n % 2 == 0) {\n    return(modp(n / 2, p) * modp(n / 2, p) %% p)\n  } else\
    \ {\n    return(n * modp(n - 1, p) %% p)\n  }\n}\n", "\n  if (n == 0) return(1)\n\
    \  y <- 1\n  while (n > 1) {\n    if (n %% 2 == 0) {\n      n <- n / 2\n     \
    \ y <- y^2 %% p\n    } else {\n      n <- n - 1\n      y <- y * 2 %% p\n    }\n\
    \  }\n  return(y)\n}", "\n    n <- n %% p\n    stopifnot(n >= 0)\n    if (n ==\
    \ 0) return(1)\n    k <- 1\n    res <- 2\n    while (k < n) {\n        res <-\
    \ res * 2\n        res <- res %% p\n        k <- k + 1\n    }\n    return(res)\n\
    }\n ", "\n    if (n == 0) {\n        return(1)\n    }\n    else {\n        ans\
    \ <- 0\n        if (n%%2 == 0) {\n            # ans = (modp(n//2, p) * modp(n//2,\
    \ p)) % p\n            # Don't use modp(n//2, p) twice\n            ans <- modp(n//2,\
    \ p)\n            ans <- ans * ans\n            ans <- ans %% p\n        }\n \
    \       else {\n            # ans = ((modp(n//2, p) * modp(n//2, p)) % p) * 2\
    \ % p\n            # Don't use modp(n//2, p) twice\n            ans <- modp(n//2,\
    \ p)\n            ans <- ans * ans\n            ans <- ans %% p\n            ans\
    \ <- ans * 2\n            ans <- ans %% p\n        }\n        return(ans)\n  \
    \  }\n}\n", "\n  if (n == 0) {\n    return(1)\n  } else if (n == 1) {\n    return(2)\n\
    \  } else {\n    return(modp(n - 1, p)^2 %*% modp(1, p) %% p)\n  }\n}\n", "\n\
    \  result <- 1\n  n      <- n %% p\n  if (n < 0) n <- n + p\n  while (n > 0) {\n\
    \    if (n%%2 == 1) result <- (result * 3) %% p\n    n <- n %/% 2\n    3 <- (3\
    \ * 3) %% p\n  }\n  result\n}\n", "\n  # Check for overflow and underflow\n  if\
    \ (n > 1e10) {\n    n <- n %% p\n  }\n  if (n == 0) {\n    return(1)\n  }\n  if\
    \ (n == 1) {\n    return(2)\n  }\n  if (n %% 2 == 0) {\n    return(modp(n / 2,\
    \ p)^2 %% p)\n  }\n  return(2 * modp(n - 1, p) %% p)\n}\n", "\n  if (n == 0) {\n\
    \    return(1)\n  } else if (n % 2 == 0) {\n    b <- modp(n / 2, p)\n    return((b*b)\
    \ %% p)\n  } else {\n    b <- modp((n - 1) / 2, p)\n    return((b*b*2) %% p)\n\
    \  }\n}\n", "\n  if (n == 0) {\n    return(1)\n  }\n  if (n == 1) {\n    return(2)\n\
    \  }\n  if (n %% 2 == 0) {\n    tmp <- modp(n/2, p)\n    tmp <- (tmp * tmp) %%\
    \ p\n    return(tmp)\n  }\n  if (n %% 2 == 1) {\n    tmp <- (modp((n-1)/2, p)\
    \ * modp((n+1)/2, p)) %% p\n    return(tmp)\n  }\n}\n", "\n  # YOUR CODE HERE\n\
    \  return(1)\n}\n ", "\n    if (n == 0) {\n        return(1)\n    } else if (n\
    \ == 1) {\n        return(2)\n    } else {\n        return(power(modp(n - 1, p),\
    \ 2, p))\n    }\n}\n", "\n  result <- 1\n  if (n == 0)\n    return(result)\n \
    \ half <- n / 2\n  result <- modp(half, p)^2\n  if (n %% 2 == 1)\n    result <-\
    \ result * 2\n  return(result %% p)\n}\n", "\n  if (n == 0) {\n    return(1)\n\
    \  } else if (n == 1) {\n    return(2)\n  } else {\n    return(modp(n - 1, p)\
    \ ^ 2 %% p)\n  }\n}\n", "\n  n %/% p\n}\n", "\n  ## Your code here\n}\n ", "\n\
    \  if (n == 0)\n    1\n  else if (n == 1)\n    3\n  else if (n %% 2 == 0)\n  \
    \  mod(modp(n / 2, p) ^ 2, p)\n  else\n    mod(3 * modp((n - 1) / 2, p) ^ 2, p)\n\
    }\n\nmodp(1101, 101)\n", "\n  ## Insert your code here\n  if (n == 0) {\n    return(1)\n\
    \  } else {\n    if (n %% 2 == 0) {\n      modp(n / 2, p) ^ 2 %% p\n    } else\
    \ {\n      modp(n / 2, p) ^ 2 * 2 %% p\n    }\n  }\n}\n", "\n    if (n == 0) return(1)\n\
    \    elif (n %% 2 == 0) {\n        return(modp(n/2, p) ^ 2 %% p)\n    } else {\n\
    \        return(2 * modp(n-1, p) %% p)\n    }\n}\n", "\n    if (n == 0) {\n  \
    \      return (1)\n    }\n    if (n % 2 == 0) {\n        return (modp(n / 2, p)^2\
    \ %% p)\n    }\n    return (2 * modp(n - 1, p) %% p)\n}\n", "\n  #  binp <- function(n)\
    \ {\n  #    str <- \"\"\n  #    for (i in seq(n)) {\n  #      str <- paste(str,\
    \ substr(n, i, i))\n  #    }\n  #    str <- paste(n, \" = \")\n  #    str <- paste(str,\
    \ gsub(\"0\", \"\", str))\n  #    str <- paste(str, \" + \")\n  #    str <- paste(str,\
    \ gsub(\"1\", \"2^\", str))\n  #    return(str)\n  #  }\n  #  cat(binp(n), \"\
    \ mod \", p, \"\\n\")\n  if (n == 0)\n    return(1)\n  if (n == 1)\n    return(2)\n\
    \  if (n %% 2 == 0)\n    return(modp(n/2, p)^2 %% p)\n  return(2 * modp((n-1)/2,\
    \ p)^2 %% p)\n}\n", "\n  x <- 1\n  for (i in 1:n) {\n    x <- x * 2 %% p\n  }\n\
    \  return(x)\n}\n", "\n  if (n == 0) {\n    return(1)\n  }\n  if (n == 1) {\n\
    \    return(p)\n  }\n  if (n %% 2 == 0) {\n    return(modp(n/2, p)^2 %% p)\n \
    \ }\n  return(p * modp((n-1)/2, p)^2 %% p)\n}\n", "\n  if (n == 0) return(1)\n\
    \  x <- 1\n  while (n != 0) {\n    if (n %% 2 == 1) x <- (x * 2) %% p\n    n <-\
    \ n %/% 2\n  }\n  return(x)\n}\n", "\n  if (n == 0) {\n    return(1)\n  } else\
    \ if (n == 1) {\n    return(2)\n  } else {\n    if (n %% 2 == 0) {\n      return(modp(n\
    \ / 2, p) ^ 2 %% p)\n    } else {\n      return(2 * modp(n - 1, p) %% p)\n   \
    \ }\n  }\n}\n", "\n  sum <- 1\n  while (n > 0) {\n    sum <- sum * 2 %% p\n  \
    \  n <- n - 1\n  }\n  return(sum)\n}\n\ncat(\"Jupyter\")\n", "\n  if (n == 0)\
    \ {\n    return(1)\n  } else if (n == 1) {\n    return(p)\n  } else if (n %% 2\
    \ == 0) {\n    return(modp(n / 2, p) ^ 2 %% p)\n  } else {\n    return(p * modp(n\
    \ - 1, p) %% p)\n  }\n}\n", "\n    if (n==0) {\n        return(1)\n    }\n   \
    \ elif (n%%2 == 0) {\n        return(modp(n%%2, p)*modp(n%%2, p)%%p)\n    }\n\
    \    else {\n        return(n%%p*modp(n%%2, p)%%p*modp(n%%2, p)%%p)\n    }\n}\n\
    \ntest_modp <- function() {\n    # Test the functionality of modp\n    a = c(3,\
    \ 1101, 0, 3, 11, 100)\n    b = c(5, 101, 101, 11, 101, 101)\n    expected = c(3,\
    \ 2, 1, 8, 1, 1)\n    for (i in 1:length(a)) {\n        if (modp(a[i], b[i]) ==\
    \ expected[i]) {\n            print(\"Success\")\n        }\n        else {\n\
    \            print(\"Failure\")\n        }\n    }\n}\n", "\n    if (n==0) {\n\
    \        return(1)\n    }\n    else {\n        if (n % 2 == 0) {\n           \
    \ return(modp(n/2, p)^2 %% p)\n        }\n        else {\n            return(2*modp(n-1,\
    \ p) %% p)\n        }\n    }\n}\n", "\n  result <- 1\n  while (n != 0) {\n   \
    \ if (n %% 2 == 1)\n      result <- result * p %% 101\n    p <- p * p %% 101\n\
    \    n <- n %/% 2\n  }\n  return(result)\n}\n", "\n    if (n == 0)\n        return(1)\n\
    \    else if (n == 1)\n        return(2)\n    else {\n        if (n %% 2 == 0)\n\
    \            return(modp(n / 2, p) ^ 2 %% p)\n        else\n            return(2\
    \ * modp(n - 1, p) %% p)\n    }\n}\n", "\n  if (n == 0) {\n    return(1)\n  }\n\
    \  else {\n    return(2*modp(n-1, p) %% p)\n  }\n}\n", "\n  f<-function(n) {\n\
    \    if (n %% 2 == 0) {\n      return(1)\n    } else {\n      return(p)\n    }\n\
    \  }\n  if (n == 0) {\n    return(1)\n  } else {\n    return((f(n)*modp(floor(n/2),\
    \ p)) %% p)\n  }\n}\n", "\n  n <- n %% p\n  if (n == 0) return(1)\n  if (n ==\
    \ 1) return(2)\n  if (n == 2) return(4)\n  if (n == 3) return(8)\n  if (n == 4)\
    \ return(16)\n  if (n == 5) return(32)\n  if (n == 6) return(64)\n  if (n == 7)\
    \ return(128)\n  if (n == 8) return(29)\n  if (n == 9) return(58)\n  if (n ==\
    \ 10) return(116)\n  if (n == 11) return(232)\n  if (n == 12) return(205)\n  if\
    \ (n == 13) return(135)\n  if (n == 14) return(19)\n  if (n == 15) return(38)\n\
    \  if (n == 16) return(76)\n  if (n == 17) return(152)\n  if (n == 18) return(45)\n\
    \  if (n == 19) return(90)\n  if (n == 20) return(180)\n  if (n == 21) return(117)\n\
    \  if (n == 22) return(234)\n  if (n == 23) return(201)\n  if (n == 24) return(143)\n\
    \  if (n == 25) return(3)\n  if (n == 26) return(6)\n  if (n == 27) return(12)\n\
    \  if (n == 28) return(24)\n  if (n == 29) return(48)\n  if (n == 30) return(96)\n\
    \  if (n == 31) return(192)\n  if (n == 32) return(157)\n  if (n == 33) return(39)\n\
    \  if (n == 34) return(78)\n  if (n == 35) return(156)\n  if (n == 36) return(37)\n\
    \  if (n == 37) return(74)\n  if (n == 38) return(148)\n  if (n == 39) return(53)\n\
    \  if (n == 40) return(106)\n  if (n == 41) return(212)", "\n  if (n == 0) {\n\
    \    return(1)\n  } else if (n == 1) {\n    return(p)\n  } else if (n %% 2 ==\
    \ 0) {\n    return(modp(n / 2, p) ^ 2 %% p)\n  } else {\n    return(p * modp(n\
    \ - 1, p) %% p)\n  }\n}\n", "\n  if (n == 0) {\n    return(1)\n  }\n  # Don't\
    \ need to worry about overflow in R.\n  ans <- 1\n  for (i in 1:n) {\n    ans\
    \ *= 2\n    ans <- ans %% p\n  }\n  return(ans)\n}\n", "\n  a <- 1\n  b <- 2\n\
    \  for (i in 1:n) {\n    a <- (a * b) %% p\n  }\n  return(a)\n}\n", "\n  if (n\
    \ == 0) return(1)\n  if (n %% 2 == 0) return(modp(n / 2, p) ^ 2 %% p)\n  return(n\
    \ * modp(n - 1, p) %% p)\n}\n", "\n  # YOUR CODE HERE\n  res <- 1\n  for (i in\
    \ 1:n) {\n    res <- (res * 2) %% p\n  }\n  return(res)\n}\n", "\n  # We're doing\
    \ modulo arithmetic, so need to keep numbers in the range 0...p-1\n  # For reference:\
    \ https://en.wikipedia.org/wiki/Modular_exponentiation\n  if (n < 0) {\n    n\
    \ <- n + (1 - (n %/% p)) * p\n  }\n\n  if (n == 0) {\n    return(1)\n  }\n\n \
    \ if (n == 1) {\n    return(2)\n  }\n\n  if (n %% 2 == 0) {\n    # We use the\
    \ identity: 2^(2n) = (2^n)^2\n    return(modp(n / 2, p) ^ 2 %% p)\n  } else {\n\
    \    # We use the identity: 2^(2n+1) = 2 * (2^n)^2\n    return(2 * modp(n - 1,\
    \ p) %% p)\n  }\n}\n", "\n  result <- 1\n  while (n != 0) {\n    if (n %% 2 ==\
    \ 1) {\n      result <- (result * 2) %% p\n    }\n    n <- n %/% 2\n  }\n  return(result)\n\
    }\n", "\n  if (n == 0) {\n    1\n  } else {\n    b <- 1\n    i <- 1\n    while\
    \ (i <= n) {\n      b <- b * 2 %/% p\n      i <- i + 1\n    }\n    b\n  }\n}\n",
  "\n  res <- 1\n  while (n > 0) {\n    if (n %% 2 == 1) {\n      res <- (res * n)\
    \ %% p\n    }\n    n <- n / 2\n  }\n  return(res)\n}\n", "\n  if (n == 0) {\n\
    \    return(1)\n  }\n  if (n == 1) {\n    return(2)\n  }\n  if (n %% 2 == 0) {\n\
    \    return(modp(n / 2, p) ^ 2 %% p)\n  }\n  else {\n    return(2 * modp(n - 1,\
    \ p) %% p)\n  }\n}\n", "\n    a <- 1\n    b <- n\n    while (b > 0) {\n      \
    \  if (b%%2 == 1) {\n            a <- (a*n)%%p\n        }\n        n <- (n*n)%%p\n\
    \        b <- b%%2\n    }\n    return(a)\n}\n", "\n  result <- 1\n  for (i in\
    \ 1:n) {\n    result <- result * 2\n    if (result > p) {\n      result <- result\
    \ - p\n    }\n  }\n  return(result)\n}\n", "\n  if (n == 0) {\n    return(1)\n\
    \  } else if (n == 1) {\n    return(p)\n  } else if (n %% 2 == 0) {\n    return(\n\
    \      (modp(n %/% 2, p)^2) %% p\n    )\n  } else {\n    return(\n      (modp(n\
    \ %/% 2, p)^2 * p) %% p\n    )\n  }\n}\n", "\n  if (n == 0) return(1)\n  if (n\
    \ == 1) return(2)\n  if (n %% 2 == 0) {\n    return((modp(n / 2, p)^2) %% p)\n\
    \  } else {\n    return((2 * modp(n - 1, p)) %% p)\n  }\n}\n", "\n    if (n ==\
    \ 0) {\n        return (1)\n    } else if (n == 1) {\n        return (2)\n   \
    \ } else {\n        return (2 * modp(n - 1, p) %% p)\n    }\n}\n", "\n    base\
    \ <- n %% 2\n    if (n == 0) return(1)\n    power <- 1\n    if (base == 1) power\
    \ <- 2\n    modp(n %% 2, p) * power %% p\n}\n", "\n    if (n == 0) return(1)\n\
    \    if (n == 1) return(2)\n    return(modp(n-1, p)^2 %% p)\n}", "\n  if (n ==\
    \ 0) return(1)\n  b <- modp(n // 2, p)\n  b2 <- (b*b) %% p\n  if (n %/% 2 == 0)\
    \ return(b2)\n  else return((b2*2) %% p)\n}\n", "\n  result <- 1\n  for (i in\
    \ 1:n) {\n    result <- (result * 2) %% p\n  }\n  return(result)\n}\n", "\n  \
    \  n %/% p\n}\n", "\n    if (n == 0) {\n        return(1)\n    } else if (n ==\
    \ 1) {\n        return(2)\n    } else {\n        p_small <- modp(n - 1, p)\n \
    \       return((2 * p_small) %% p)\n    }\n}\n", "\n  b <- 1L\n  i <- 0L\n  while\
    \ (i < n) {\n    i <- i + 1L\n    b <- (b * 2L) %% p\n  }\n  b\n}\n", "\n    if\
    \ (n == 0) return(1)\n    ans <- 1\n    while (n != 0) {\n        if (n % 2 ==\
    \ 1) {\n            ans <- (ans * 2) %% p\n        }\n        n <- n %/% 2\n \
    \   }\n    return(ans)\n}\n", "\n  if (n == 0) return(1)\n  if (n % 2 == 0) {\n\
    \    return(modp(n/2, p) ^ 2)\n  } else {\n    return(n * modp(n-1, p))\n  }\n\
    }\n", "\n  if (p <= 0)\n    stop('p must be a positive integer')\n  if (n < 0)\n\
    \    return(NULL)\n  if (n == 0)\n    return(1)\n  ans <- 1\n  while (n > 0) {\n\
    \    if (n %% 2 == 1)\n      ans <- ans * 2 %% p\n    n <- n %/% 2\n  }\n  ans\n\
    }\n", "\n  if (n > 46340) stop(\"n too large\")\n  if (n == 0) return(1)\n  if\
    \ (n == 1) return(2)\n  if (n %% 2 == 0) return(modp(n-1, p)^2 %% p)\n  return(2\
    \ * modp(n-1, p)^2 %% p)\n}\nmodp(1, 1)\n\nset.seed(2)\n\nn <- 1e5\n(sim.11 <-\
    \ sample(c(0, 1), n, replace = TRUE, prob = c(1/2, 1/2)))\n\ntot.11 <- sum(sim.11)\n\
    tot.11\n\n(prop.11 <- tot.11 / n)\n\nprop.11 - 0.5\n\n(abs.err.11 <- abs(prop.11\
    \ - 0.5))\n\nset.seed(2)\n\nn <- 1e5\n(sim.12 <- sample(c(0, 1), n, replace =\
    \ TRUE, prob = c(1/3, 2/3)))\n\ntot.12 <- sum(sim.12)\ntot.12\n\n(prop.12 <- tot.12\
    \ / n)\n\nprop.12 - 2/3\n\n(abs.err.12 <- abs(prop.12 - 2/3))\n\nset.seed(2)\n\
    \nn <- 1e5\n(sim.13 <- sample(c(0, 1), n, replace = TRUE, prob = c(0.4, 0.6)))\n\
    \ntot.13 <- sum(sim.13)\ntot.13\n\n(prop.13 <- tot.13 / n)\n\nprop.13 - 0.6\n\n\
    (abs.err.13 <- abs(prop.13 - 0.6))\n\nset.seed(2)\n\nn <- 1e5\n(sim.14 <- sample(c(0,\
    \ 1), n, replace = TRUE, prob = c(0.3, 0.7)))\n\ntot.14 <- sum(sim.14)\ntot.14\n\
    \n(prop.14 <- tot.14 / n)\n\nprop.14 - 0.7\n\n(abs.err.14 <- abs", "\n  if (n\
    \ < 1) return(1)\n  if (n%%2) { # Odd\n    return((2*modp(n-1, p))%%p)\n  } else\
    \ { # Even\n    m <- modp(n/2, p)\n    return((m*m)%%p)\n  }\n}\n", "\n  # Calculates\
    \ the binary expansion of n.\n  binary_expansion <- function(n) {\n    if (n ==\
    \ 0) {\n      return(numeric(0))\n    }\n    else {\n      bin <- integer(ceiling(log(n,\
    \ 2)))\n      for (i in seq_along(bin)) {\n        bin[i] <- n %% 2\n        n\
    \ <- n %/% 2\n      }\n      return(bin)\n    }\n  }\n  if (n == 0) {\n    return(1)\n\
    \  }\n  else {\n    exp <- binary_expansion(n)\n    val <- 1\n    cur_pow <- p\n\
    \    for (i in seq_along(exp)) {\n      if (exp[i] == 1) {\n        val <- val\
    \ * cur_pow %% p\n      }\n      cur_pow <- cur_pow * cur_pow %% p\n    }\n  \
    \  return(val)\n  }\n}\n", "\n  if (n == 0) return(1)\n  if (n == 1) return(2)\n\
    \  if (n %% 2 == 0) return(modp(n/2, p)^2 %% p)\n  return(2 * modp(n-1, p) %%\
    \ p)\n}\n", "\n    if (n == 0)\n        return(1)\n    if (n == 1)\n        return(n)\n\
    \    t <- n %% 2\n    if (t == 0)\n        return(modp(n/2, p)^2 %% p)\n    else\n\
    \        return(n*modp(n-1, p) %% p)\n}\n", "\n  n %/% p\n}\n", "\n    if (n <\
    \ 0)\n        return (NA)\n    if (n == 0)\n        return (1)\n    if (n == 1)\n\
    \        return (2)\n    x <- 1\n    (i <- n)\n    while (i > 0) {\n        if\
    \ (i %% 2 == 1)\n            x <- (x * 2) %% p\n        i <- i %/% 2\n    }\n\
    \    return (x)\n}\n ", "\n  if (n == 0) return(1)\n  if (n == 1) return(2)\n\
    \  c <- modp(n-1, p)\n  return( (c*c - 2) %% p )\n}\n", "\n  if (n == 0) {\n \
    \   return(1)\n  } else if (n == 1) {\n    return(2)\n  } else {\n    z <- modp(n\
    \ / 2, p)\n    if (n %% 2 == 0) {\n      return(mod(z * z, p))\n    } else {\n\
    \      return(mod(2 * z * z, p))\n    }\n  }\n}\n", "\n  if (n == 0) return(1)\n\
    \  if (n == 1) return(2)\n  if (n == 2) return(4)\n  if (n == 3) return(8)\n \
    \ if (n == 4) return(16)\n  if (n == 5) return(32)\n  if (n == 6) return(64)\n\
    \  if (n == 7) return(128)\n  if (n == 8) return(256)\n  if (n == 9) return(512)\n\
    \  if (n == 10) return(1024)\n  if (n == 11) return(2048)\n  if (n == 12) return(4096)\n\
    \  if (n == 13) return(8192)\n  if (n == 14) return(16384)\n  if (n == 15) return(32768)\n\
    \  if (n == 16) return(65536)\n  if (n == 17) return(131072)\n  if (n == 18) return(262144)\n\
    \  if (n == 19) return(524288)\n  if (n == 20) return(1048576)\n  if (n == 21)\
    \ return(2097152)\n  if (n == 22) return(4194304)\n  if (n == 23) return(8388608)\n\
    \  if (n == 24) return(16777216)\n  if (n == 25) return(33554432)\n  if (n ==\
    \ 26) return(67108864)\n  if (n == 27) return(134217728)\n  if (n == 28) return(268435456)\n\
    \  if (n == 29) return(536870912)\n  if (n == 30) return(1073741824)\n  if (n\
    \ == 31) return(2147483648)\n  if (n == 32) return(4294967296)\n  if (n == 33)\
    \ return(8589934592)\n  if (n == 34) return(17179869184)\n  if (n == 35) return(34359738368)\n\
    \  if (n == 36) return(68719476736)\n  if (n", "\n  stopifnot(n >= 0)\n  stopifnot(p\
    \ > 0)\n  if (n == 0)\n    return(1)\n  else\n    return(modp(n-1, p)^2 %% p)\n\
    }\n ", "\n    result <- 1\n    while (n > 0) {\n        result <- (result * n)\
    \ %% p\n        n <- n - 1\n    }\n    return(result)\n}", "\n  if (n == 0) {\n\
    \    1\n  } else {\n    x <- modp(floor(n / 2), p)\n    y <- (x * x) %% p\n  \
    \  if (n %% 2 == 0) {\n      y\n    } else {\n      (y * 2) %% p\n    }\n  }\n\
    }\n", "\n    ## n is a positive integer\n    ## p is a prime number\n    ## \n\
    \    ## >>> modp(3, 5)\n    ## 3\n    ## >>> modp(1101, 101)\n    ## 2\n    ##\
    \ >>> modp(0, 101)\n    ## 1\n    ## >>> modp(3, 11)\n    ## 8\n    ## >>> modp(100,\
    \ 101)\n    ## 1\n    x <- 1\n    s <- n\n    pw <- p - 1\n    while (pw > 0)\
    \ {\n        if (pw %% 2 == 1) {\n            x <- (x * s) %% p\n        }\n \
    \       s <- (s * s) %% p\n        pw <- pw %/% 2\n    }\n    return(x)\n}\n",
  "\n  # NOTE: the following line is incorrect.  Perhaps use the scheme\n  # described\
    \ in the exercise text.\n  p^n%%p\n}\n", "\n    if (n == 0) {\n        return(1)\n\
    \    }\n    x <- modp(n %/% 2, p)\n    x <- (x * x) %% p\n    if (n %% 2 == 1)\
    \ {\n        x <- (x * 2) %% p\n    }\n    return(x)\n}\n", "\n  ##<<<\n  if (n\
    \ == 0) {\n    return(1)\n  } else if (n %% 2 == 0) {\n    prod <- modp(n/2, p)\n\
    \    prod*prod %% p\n  } else {\n    prod <- modp((n-1)/2, p)\n    (2*prod*prod)\
    \ %% p\n  }\n  ##>>>\n}\n", "\n    n <- round(n); \n    p <- round(p); \n    if\
    \ (n == 0) {\n        return(1);\n    }\n    else {\n        r <- modp(floor(n/2),\
    \ p);\n        if (n %% 2 == 0) {\n            return( (r*r) %% p);\n        }\n\
    \        else {\n            return( (2*r*r) %% p);\n        }\n    }\n}\n ",
  "\n    if (n == 0) return(1)\n    rest <- modp(floor(n/2), p)\n    rest <- (rest*rest)%%p\n\
    \    if (n%%2 == 1) return(rest*2)%%p\n    else return(rest)\n}\nmodp(3, 5)\n\
    modp(1101, 101)\nmodp(0, 101)\nmodp(3, 11)\nmodp(100, 101)", "\n  \n  # Convert\
    \ n to binary representation\n  n <- as.integer(n)\n  n_b <- as.numeric(intToBits(n))\n\
    \  \n  # Initilize a = 1\n  a <- 1\n  \n  # For i = length(n_b) down to 1\n  for\
    \ (i in length(n_b):1) {\n    a <- (a * a) %% p\n    if (n_b[i] == 1) {\n    \
    \  a <- (a * 2) %% p\n    }\n  }\n  \n  return(a)\n}\n ", "\n  if (n == 0) {\n\
    \    1\n  } else {\n    a <- modp(n %/% 2, p)\n    a <- (a*a) %% p\n    if (n\
    \ %% 2 == 1) {\n      a <- (a*2) %% p\n    }\n    a\n  }\n}\n", "\n  if (n ==\
    \ 0) {\n    return(1)\n  } else if (n == 1) {\n    return(3)\n  } else {\n   \
    \ return(mod(modp(n-1, p)^2, p))\n  }\n}\n", "\n    if (n == 0) return(1)\n  \
    \  else if (n == 1) return(2)\n    else if (n == 2) return(4)\n    else if (n\
    \ == 3) return(8)\n    else if (n == 4) return(16)\n    else if (n == 5) return(32)\n\
    \    else if (n == 6) return(64)\n    else if (n == 7) return(128)\n    else if\
    \ (n == 8) return(27)\n    else if (n == 9) return(54)\n    else if (n == 10)\
    \ return(108)\n    else if (n == 11) return(216)\n    else if (n == 12) return(89)\n\
    \    else if (n == 13) return(178)\n    else if (n == 14) return(43)\n    else\
    \ if (n == 15) return(86)\n    else if (n == 16) return(172)\n    else if (n ==\
    \ 17) return(89)\n    else if (n == 18) return(178)\n    else if (n == 19) return(43)\n\
    \    else if (n == 20) return(86)\n    else if (n == 21) return(172)\n    else\
    \ if (n == 22) return(89)\n    else if (n == 23) return(178)\n    else if (n ==\
    \ 24) return(43)\n    else if (n == 25) return(86)\n    else if (n == 26) return(172)\n\
    \    else if (n == 27) return(89)\n    else if (n == 28) return(178)\n    else\
    \ if (n == 29) return(43)\n    else if (n == 30) return(86)\n    else if (n ==\
    \ 31) return(172)\n    else if (n == 32) return(89)\n    else if (n == 33) return(178)\n\
    \    else if (n == 34) return(43)\n    else if (n == 35) return(86)\n    else\
    \ if (n == 36) return(172)\n    else if (n == 37) return(89)\n    else if (n ==\
    \ 38) return(178)\n    else if (", "\n  x <- 1\n  while (n > 0) {\n    if (n %%\
    \ 2 == 1) {\n      x <- x * 2 %/% p\n    }\n    n <- n %/% 2\n  }\n  return(x)\n\
    }\n ", "\n  if (n == 0) {\n    return(1)\n  }\n  if (n == 1) {\n    return(2)\n\
    \  }\n  x <- 2\n  z <- 1\n  while (n != 0) {\n    if (n%%2 == 1) {\n      z <-\
    \ x*z %% p\n    }\n    x <- x*x %% p\n    n <- n/2\n  }\n  return(z)\n}\n ", "\n\
    \    z <- 1\n    if (n == 0) {\n        return(z)\n    }\n    if (n > 0) {\n \
    \       while (n > 0) {\n            if (n%%2 == 1) {\n                z <- z*2\n\
    \                if (z >= p) {\n                    z <- z - p\n             \
    \   }\n            }\n            n <- n%%2\n            if (n > 0) {\n      \
    \          z <- z*z\n                if (z >= p) {\n                    z <- z\
    \ - p\n                }\n            }\n        }\n    }\n    return(z)\n}\n ",
  "\n  if (n == 0) return(1)\n  if (n == 1) return(3)\n  out <- modp(n - 1, p)\n \
    \ out * 3 %% p\n}\n", "\n  if (n == 0) {\n    return(1)\n  }\n  else {\n    return(\
    \ ( 2 * modp(n-1, p) ) %% p )\n  }\n}\n", "\n  x <- 1L\n  while (n > 0L) {\n \
    \   if (n %% 2L == 1L) {\n      x <- (x * n) %% p\n    }\n    n <- n %% 2L\n \
    \   x <- (x * x) %% p\n  }\n  return(x)\n}", "\n  if (n == 0) {\n    return(1)\n\
    \  }\n  if (n % 2 == 0) {\n    return(modp(n/2, p)^2 %% p)\n  }\n  else {\n  \
    \  return(modp(n-1, p) * n %% p)\n  }\n}\n", "\n    if (n == 0)\n        return(1)\n\
    \    else if (n == 1)\n        return(2)\n    else if (n %% 2 == 0)\n        return(modp(n\
    \ / 2, p) ^ 2 %% p)\n    else\n        return(2 * modp(n - 1, p) %% p)\n}\n "]
stop_tokens:
- "\n#"
- "\n```"
