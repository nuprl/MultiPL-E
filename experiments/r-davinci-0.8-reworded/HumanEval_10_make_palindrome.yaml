name: HumanEval_10_make_palindrome
language: r
prompt: "# Find the shortest palindrome that begins with a supplied string.\n# Algorithm\
  \ idea is simple:\n# - Find the longest postfix of supplied string that is a palindrome.\n\
  # - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n# >>> make_palindrome('')\n# ''\n# >>> make_palindrome('cat')\n\
  # 'catac'\n# >>> make_palindrome('cata')\n# 'catac'\nmake_palindrome <- function(string)\
  \ {"
tests: "test_humaneval <- function() {\ncandidate <- make_palindrome\n    if(!identical(candidate(''),\
  \ '')){quit('no', 1)}\n    if(!identical(candidate('x'), 'x')){quit('no', 1)}\n\
  \    if(!identical(candidate('xyz'), 'xyzyx')){quit('no', 1)}\n    if(!identical(candidate('xyx'),\
  \ 'xyx')){quit('no', 1)}\n    if(!identical(candidate('jerry'), 'jerryrrej')){quit('no',\
  \ 1)}\n}\ntest_humaneval()"
completions: ["\n  string <- as.character(string)\n  if (string == '') {\n    return('')\n\
    \  }\n  middle <- which.max(apply(outer(1:nchar(string), 1:nchar(string), function(i,\
    \ j) {\n    string[i:j] == rev(string[i:j])\n  }), 1, sum))\n  return(c(string,\
    \ rev(string[1:(middle - 1)])))\n}\n\n", "\n  if (nchar(string) == 0) {\n    return\
    \ (string)\n  }\n  string <- stringr::str_c(string, stringr::str_split(string,\
    \ '')[[1]][1:(nchar(string) - 1)])\n  i <- 1\n  while (i <= nchar(string)) {\n\
    \    if (is_palindrome(string[i:(nchar(string))])) {\n      break\n    }\n   \
    \ i <- i + 1\n  }\n  stringr::str_c(string[1:(nchar(string) - i + 1)], stringr::str_split(string[1:(nchar(string)\
    \ - i + 1)], '')[[1]][nchar(string) - i + 1:1])\n}\n", "\n    l <- 0\n    if (nchar(string)\
    \ == 0) {\n        return (string)\n    }\n    for (i in seq(nchar(string))) {\n\
    \        if (substr(string, 1, i) == substr(string, nchar(string)-i+1, nchar(string)))\
    \ {\n            l <- i\n        }\n    }\n    return (paste(string, substr(string,\
    \ nchar(string)-l+1, nchar(string)), sep = ''))\n}\n\ntest_that('make_palindrome\
    \ works as expected', {\n    expect_equal(make_palindrome(''), '')\n    expect_equal(make_palindrome('cat'),\
    \ 'catac')\n    expect_equal(make_palindrome('cata'), 'catac')\n})\n ", "\n  if\
    \ (string == '') return('')\n  reverse_string <- rev(string)\n  n <- nchar(string)\n\
    \  # Create a matrix where matrix[i, j] is a length of the longest palindromic\
    \ substring\n  # in string[1:i] and reverse_string[1:j].\n  palindrome_lengths\
    \ <- matrix(0, nrow = n, ncol = n)\n  for (i in 1:n) {\n    for (j in 1:n) {\n\
    \      if (i == 1 && j == 1) {\n        palindrome_lengths[i, j] <- 1\n      }\
    \ else if (i == 1) {\n        palindrome_lengths[i, j] <- max(palindrome_lengths[i,\
    \ j - 1],\n                                        substr(string, 1, 1) == substr(reverse_string,\
    \ j, j))\n      } else if (j == 1) {\n        palindrome_lengths[i, j] <- max(palindrome_lengths[i\
    \ - 1, j],\n                                        substr(string, i, i) == substr(reverse_string,\
    \ 1, 1))\n      } else {\n        palindrome_lengths[i, j] <- max(palindrome_lengths[i\
    \ - 1, j],\n                                        palindrome_lengths[i, j -\
    \ 1],\n                                        palindrome_lengths[i - 1, j - 1]\
    \ +\n                                        (substr(string, i, i) == substr(reverse_string,\
    \ j, j)))\n      }\n    }\n  }\n  # Iterate through a matrix and find a position\
    \ of the longest palindromic suffix.\n  palindrome_length <- palindrome_lengths[n,\
    \ n]\n  position <- c(n, n)\n  for (i in 1:n) {\n    for (j in 1:n) {\n      if\
    \ (palindrome_lengths[i, j] == palindrome_length) {\n        position <- c(i,\
    \ j)\n      }\n    }\n  }\n  # Create the output.\n  return(paste(string, substr(reverse_string,\
    \ n -", "\n  if (nchar(string) < 2) {\n    return(string)\n  }\n  string <- string\
    \ %>% \n    stringr::str_replace_all('\\\\s+', '') %>% \n    stringr::str_to_lower()\n\
    \  longest_palindrome <- string %>% \n    stringr::str_sub(start = nchar(string),\
    \ \n                     end = -nchar(string)) %>% \n    stringr::str_c(stringr::str_reverse(.),\
    \ .) %>% \n    stringr::str_detect(string) %>% \n    which.max\n  left_part <-\
    \ string %>% \n    stringr::str_sub(start = 1, \n                     end = length(string)\
    \ - longest_palindrome)\n  paste0(left_part, string)\n}\nmake_palindrome('')\n\
    make_palindrome('cat')\nmake_palindrome('cata')\nmake_palindrome('catac')\nmake_palindrome('racecar')\n\
    make_palindrome('abcd')\nmake_palindrome('abba')\nmake_palindrome('bobcat')\n\
    make_palindrome('bobcatcat')\nmake_palindrome('awesome')\nmake_palindrome('awesomeawesome')\n\
    make_palindrome('abacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacab",
  "\n  if (length(string) == 0) return(string)\n  # Find the longest suffix that is\
    \ a palindrome\n  for (len in 0:(length(string) - 1)) {\n    if (string[1:(length(string)\
    \ - len)] == rev(string[(length(string) - len + 1):length(string)])) break\n \
    \ }\n  # Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix\n  return(paste(string, rev(string[1:(length(string)\
    \ - len)]), sep = ''))\n}\n", "\n  prefix <- strsplit(string, \"\")[[1]]\n  suffix\
    \ <- prefix\n  for (i in 1:length(suffix)) {\n    if (prefix[i] != suffix[i])\
    \ {\n      prefix <- prefix[-i]\n    }\n  }\n  string[1:length(prefix)] <- prefix\n\
    \  string <- c(string, rev(prefix))\n  return(paste(string, collapse = \"\"))\n\
    }\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n", "\n\
    \    if(nchar(string) == 0) {\n        return(string)\n    }\n    string_length\
    \ <- nchar(string)\n    for(i in 1:string_length) {\n        if(substr(string,\
    \ string_length - i + 1, string_length) == substr(string, 1, i)) {\n         \
    \   return(paste(string, substr(string, i + 1, string_length), sep = ''))\n  \
    \      }\n    }\n}\n\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n",
  "\n  if (nchar(string) == 0) return(string)\n  palindrome <- longest_palindrome(string)\n\
    \  if (is.null(palindrome)) return(string)\n  if (palindrome == string) return(string)\n\
    \  suffix <- substring(string, nchar(palindrome) + 1)\n  prefix <- substring(string,\
    \ 1, nchar(palindrome))\n  paste(palindrome, rev(suffix), sep = '')\n}\n", "\n\
    \  return(paste(string, rev(strsplit(string, \"\")[[1]][1:(nchar(string) - which.max(sapply(seq(nchar(string)),\
    \ function(i) {is_palindrome(substr(string, 1, i))})))-1), collapse=\"\")))\n\
    }\n", "\n  prefix <- substring(string, 1, nchar(string) - find_palindrome_suffix(string))\n\
    \  paste(string, stringReverse(prefix), sep = '')\n}\n", "\n    if (string ==\
    \ '') {\n        return('')\n    }\n    for (i in seq(length(string), 1, -1))\
    \ {\n        substr <- substring(string, length(string) - i + 1, length(string))\n\
    \        if (is_palindrome(substr)) {\n            prefix <- substring(string,\
    \ 1, length(string) - i)\n            return(paste(string, rev(prefix), sep =\
    \ ''))\n        }\n    }\n}\n \nstring <- 'cata'\nmake_palindrome(string)\n",
  "\n    if (is.null(string) || nchar(string) == 0) return(string)\n    if (nchar(string)\
    \ == 1) return(string)\n    if (nchar(string) == 2) {\n        if (substr(string,\
    \ 1, 1) == substr(string, 2, 2)) return(string)\n        return(paste(string,\
    \ substr(string, 1, 1), sep = ''))\n    }\n    r <- substr(string, 1, 1)\n   \
    \ s <- substr(string, 2, nchar(string))\n    t <- substr(string, nchar(string),\
    \ nchar(string))\n    if (nchar(s) >= 2) {\n        if (t == r) {\n          \
    \  if (substr(s, 1, 1) == substr(s, nchar(s), nchar(s))) return(paste(string,\
    \ rev(s), sep = ''))\n            if (substr(s, 1, 1) == substr(s, nchar(s) -\
    \ 1, nchar(s) - 1)) return(paste(string, substr(s, 2, nchar(s)), substr(s, 1,\
    \ 1), sep = ''))\n            if (substr(s, 2, 2) == substr(s, nchar(s), nchar(s)))\
    \ return(paste(string, substr(s, 1, 1), substr(s, 2, nchar(s)), sep = ''))\n \
    \       }\n        return(paste(string, rev(s), sep = ''))\n    }\n    return(paste(string,\
    \ rev(s), sep = ''))\n}\n\nmake_palindrome <- function(string) {\n    if (is.null(string)\
    \ || nchar(string) == 0) return(string)\n    r <- substr(string, 1, 1)\n    s\
    \ <- substr(string, 2, nchar(string))\n    t <- substr(string, nchar(string),\
    \ nchar(string))\n    if (nchar(s) >= 2) {\n        if (t == r) {\n          \
    \  if (substr(s, 1, 1) == substr(s, nchar(s), nchar(s))) return(paste(string,\
    \ rev(s),", "\n    if (string == '') {\n        return('')\n    }\n    longest_palindrome_end\
    \ <- function(string) {\n        for (i in seq(1, nchar(string))) {\n        \
    \    test_string <- string[seq(1, i)]\n            if (test_string == rev(test_string))\
    \ {\n                return(i)\n            }\n        }\n        return(0)\n\
    \    }\n    n <- longest_palindrome_end(string)\n    return(paste(string, rev(string[seq(1,\
    \ nchar(string) - n)]), sep = ''))\n}\n", "\n  length_of_palindrome_suffix <-\
    \ find_longest_palindrome_length(string)\n  prefix <- substr(string, 1, nchar(string)\
    \ - length_of_palindrome_suffix)\n  suffix <- substr(string, nchar(string) - length_of_palindrome_suffix\
    \ + 1, nchar(string))\n  return(paste(string, rev(prefix), sep = ''))\n}\n\nprint(make_palindrome(''))\n\
    print(make_palindrome('cat'))\nprint(make_palindrome('cata'))\n", "\n  if (length(string)\
    \ == 0) {\n    return (string)\n  }\n  longest_palindrome_suffix <- function(string)\
    \ {\n    # Find the longest palindrome starting from the end of the string.\n\
    \    # It's a suffix of the string.\n    # We could use Regex to find palindromes\
    \ but recursion is much easier in this case.\n    # Start with a single character\
    \ palindrome.\n    # If two last characters are the same check if the remaining\
    \ string is a palindrome.\n    # Repeat until you run out of characters or find\
    \ the longest palindrome.\n    if (nchar(string) == 1) {\n      return (string)\n\
    \    }\n    if (substr(string, nchar(string), nchar(string)) == substr(string,\
    \ nchar(string) - 1, nchar(string) - 1)) {\n      return (longest_palindrome_suffix(substr(string,\
    \ 1, nchar(string) - 1)))\n    }\n    return (substr(string, nchar(string), nchar(string)))\n\
    \  }\n  return (paste(string, string[-1], sep=''))\n}\n", "\n  # Base case: return\
    \ supplied string\n  if (nchar(string) == 0) {\n    return(string)\n  }\n  # Find\
    \ the longest palindromic postfix\n  for (i in nchar(string):1) {\n    if (substr(string,\
    \ i, nchar(string)) == rev(substr(string, i, nchar(string)))) {\n      return(paste(string,\
    \ rev(substr(string, 1, i - 1)), sep = ''))\n    }\n  }\n}\nmake_palindrome('cata')\n",
  "\n  # Find a longest palindromic postfix of string.\n  suffix <- string\n  while\
    \ (suffix != '') {\n    if (is_palindrome(suffix)) {\n      break\n    }\n   \
    \ suffix <- substr(suffix, 2, nchar(suffix))\n  }\n  prefix <- substr(string,\
    \ 1, nchar(string) - nchar(suffix))\n  return(paste(string, paste(rev(unlist(strsplit(prefix,\
    \ split=''))), collapse=''), sep=''))\n}\nmake_palindrome('cat')\nmake_palindrome('cata')\n\
    make_palindrome('cataaa')\nmake_palindrome('cataaaaa')\n", "\n  # find the longest\
    \ palindromic postfix\n  longest_palindromic_postfix <- longest_palindromic_substring(string)\n\
    \  n <- nchar(string)\n  if (nchar(longest_palindromic_postfix) == n) {\n    return(string)\n\
    \  }\n  # find the suffix index within the string\n  suffix_index <- n - nchar(longest_palindromic_postfix)\n\
    \  # get the prefix up to the suffix\n  prefix <- substr(string, 1, suffix_index)\n\
    \  # reverse the prefix\n  return(paste(string, stringr::str_reverse(prefix),\
    \ sep = ''))\n}\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n",
  "\n    n <- nchar(string)\n    longest_suffix <- function(string, start_from) {\n\
    \        is_palindrome <- function(string) {\n            return(string == rev(string))\n\
    \        }\n        for (i in seq(from = start_from, to = n)) {\n            if\
    \ (is_palindrome(substr(string, start = start_from, stop = i))) {\n          \
    \      return(i)\n            }\n        }\n        return(NA)\n    }\n    end_of_suffix\
    \ <- longest_suffix(string, start_from = 1)\n    if (is.na(end_of_suffix)) {\n\
    \        return(paste0(string, rev(string)))\n    }\n    else {\n        return(paste0(string,\
    \ rev(substr(string, start = 1, stop = n - end_of_suffix))))\n    }\n}\n\nassert.that(make_palindrome('')\
    \ == '')\nassert.that(make_palindrome('cat') == 'catac')\nassert.that(make_palindrome('cata')\
    \ == 'catac')\n"]
stop_tokens:
- "\n#"
- "\n```"
