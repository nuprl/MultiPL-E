name: HumanEval_10_make_palindrome
language: r
prompt: "# Find the shortest palindrome that begins with a supplied string.\n# Algorithm\
  \ idea is simple:\n# - Find the longest postfix of supplied string that is a palindrome.\n\
  # - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n# >>> make_palindrome('')\n# ''\n# >>> make_palindrome('cat')\n\
  # 'catac'\n# >>> make_palindrome('cata')\n# 'catac'\nmake_palindrome <- function(string)\
  \ {"
tests: "test_humaneval <- function() {\ncandidate <- make_palindrome\n    if(!identical(candidate(''),\
  \ '')){quit('no', 1)}\n    if(!identical(candidate('x'), 'x')){quit('no', 1)}\n\
  \    if(!identical(candidate('xyz'), 'xyzyx')){quit('no', 1)}\n    if(!identical(candidate('xyx'),\
  \ 'xyx')){quit('no', 1)}\n    if(!identical(candidate('jerry'), 'jerryrrej')){quit('no',\
  \ 1)}\n}\ntest_humaneval()"
completions: ["\n  string <- as.character(string)\n  if (string == '') {\n    return('')\n\
    \  }\n  middle <- which.max(apply(outer(1:nchar(string), 1:nchar(string), function(i,\
    \ j) {\n    string[i:j] == rev(string[i:j])\n  }), 1, sum))\n  return(c(string,\
    \ rev(string[1:(middle - 1)])))\n}\n\n", "\n  if (nchar(string) == 0) {\n    return\
    \ (string)\n  }\n  string <- stringr::str_c(string, stringr::str_split(string,\
    \ '')[[1]][1:(nchar(string) - 1)])\n  i <- 1\n  while (i <= nchar(string)) {\n\
    \    if (is_palindrome(string[i:(nchar(string))])) {\n      break\n    }\n   \
    \ i <- i + 1\n  }\n  stringr::str_c(string[1:(nchar(string) - i + 1)], stringr::str_split(string[1:(nchar(string)\
    \ - i + 1)], '')[[1]][nchar(string) - i + 1:1])\n}\n", "\n    l <- 0\n    if (nchar(string)\
    \ == 0) {\n        return (string)\n    }\n    for (i in seq(nchar(string))) {\n\
    \        if (substr(string, 1, i) == substr(string, nchar(string)-i+1, nchar(string)))\
    \ {\n            l <- i\n        }\n    }\n    return (paste(string, substr(string,\
    \ nchar(string)-l+1, nchar(string)), sep = ''))\n}\n\ntest_that('make_palindrome\
    \ works as expected', {\n    expect_equal(make_palindrome(''), '')\n    expect_equal(make_palindrome('cat'),\
    \ 'catac')\n    expect_equal(make_palindrome('cata'), 'catac')\n})\n ", "\n  if\
    \ (string == '') return('')\n  reverse_string <- rev(string)\n  n <- nchar(string)\n\
    \  # Create a matrix where matrix[i, j] is a length of the longest palindromic\
    \ substring\n  # in string[1:i] and reverse_string[1:j].\n  palindrome_lengths\
    \ <- matrix(0, nrow = n, ncol = n)\n  for (i in 1:n) {\n    for (j in 1:n) {\n\
    \      if (i == 1 && j == 1) {\n        palindrome_lengths[i, j] <- 1\n      }\
    \ else if (i == 1) {\n        palindrome_lengths[i, j] <- max(palindrome_lengths[i,\
    \ j - 1],\n                                        substr(string, 1, 1) == substr(reverse_string,\
    \ j, j))\n      } else if (j == 1) {\n        palindrome_lengths[i, j] <- max(palindrome_lengths[i\
    \ - 1, j],\n                                        substr(string, i, i) == substr(reverse_string,\
    \ 1, 1))\n      } else {\n        palindrome_lengths[i, j] <- max(palindrome_lengths[i\
    \ - 1, j],\n                                        palindrome_lengths[i, j -\
    \ 1],\n                                        palindrome_lengths[i - 1, j - 1]\
    \ +\n                                        (substr(string, i, i) == substr(reverse_string,\
    \ j, j)))\n      }\n    }\n  }\n  # Iterate through a matrix and find a position\
    \ of the longest palindromic suffix.\n  palindrome_length <- palindrome_lengths[n,\
    \ n]\n  position <- c(n, n)\n  for (i in 1:n) {\n    for (j in 1:n) {\n      if\
    \ (palindrome_lengths[i, j] == palindrome_length) {\n        position <- c(i,\
    \ j)\n      }\n    }\n  }\n  # Create the output.\n  return(paste(string, substr(reverse_string,\
    \ n -", "\n  if (nchar(string) < 2) {\n    return(string)\n  }\n  string <- string\
    \ %>% \n    stringr::str_replace_all('\\\\s+', '') %>% \n    stringr::str_to_lower()\n\
    \  longest_palindrome <- string %>% \n    stringr::str_sub(start = nchar(string),\
    \ \n                     end = -nchar(string)) %>% \n    stringr::str_c(stringr::str_reverse(.),\
    \ .) %>% \n    stringr::str_detect(string) %>% \n    which.max\n  left_part <-\
    \ string %>% \n    stringr::str_sub(start = 1, \n                     end = length(string)\
    \ - longest_palindrome)\n  paste0(left_part, string)\n}\nmake_palindrome('')\n\
    make_palindrome('cat')\nmake_palindrome('cata')\nmake_palindrome('catac')\nmake_palindrome('racecar')\n\
    make_palindrome('abcd')\nmake_palindrome('abba')\nmake_palindrome('bobcat')\n\
    make_palindrome('bobcatcat')\nmake_palindrome('awesome')\nmake_palindrome('awesomeawesome')\n\
    make_palindrome('abacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacabacab",
  "\n  if (length(string) == 0) return(string)\n  # Find the longest suffix that is\
    \ a palindrome\n  for (len in 0:(length(string) - 1)) {\n    if (string[1:(length(string)\
    \ - len)] == rev(string[(length(string) - len + 1):length(string)])) break\n \
    \ }\n  # Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix\n  return(paste(string, rev(string[1:(length(string)\
    \ - len)]), sep = ''))\n}\n", "\n  prefix <- strsplit(string, \"\")[[1]]\n  suffix\
    \ <- prefix\n  for (i in 1:length(suffix)) {\n    if (prefix[i] != suffix[i])\
    \ {\n      prefix <- prefix[-i]\n    }\n  }\n  string[1:length(prefix)] <- prefix\n\
    \  string <- c(string, rev(prefix))\n  return(paste(string, collapse = \"\"))\n\
    }\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n", "\n\
    \    if(nchar(string) == 0) {\n        return(string)\n    }\n    string_length\
    \ <- nchar(string)\n    for(i in 1:string_length) {\n        if(substr(string,\
    \ string_length - i + 1, string_length) == substr(string, 1, i)) {\n         \
    \   return(paste(string, substr(string, i + 1, string_length), sep = ''))\n  \
    \      }\n    }\n}\n\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n",
  "\n  if (nchar(string) == 0) return(string)\n  palindrome <- longest_palindrome(string)\n\
    \  if (is.null(palindrome)) return(string)\n  if (palindrome == string) return(string)\n\
    \  suffix <- substring(string, nchar(palindrome) + 1)\n  prefix <- substring(string,\
    \ 1, nchar(palindrome))\n  paste(palindrome, rev(suffix), sep = '')\n}\n", "\n\
    \  return(paste(string, rev(strsplit(string, \"\")[[1]][1:(nchar(string) - which.max(sapply(seq(nchar(string)),\
    \ function(i) {is_palindrome(substr(string, 1, i))})))-1), collapse=\"\")))\n\
    }\n", "\n  prefix <- substring(string, 1, nchar(string) - find_palindrome_suffix(string))\n\
    \  paste(string, stringReverse(prefix), sep = '')\n}\n", "\n    if (string ==\
    \ '') {\n        return('')\n    }\n    for (i in seq(length(string), 1, -1))\
    \ {\n        substr <- substring(string, length(string) - i + 1, length(string))\n\
    \        if (is_palindrome(substr)) {\n            prefix <- substring(string,\
    \ 1, length(string) - i)\n            return(paste(string, rev(prefix), sep =\
    \ ''))\n        }\n    }\n}\n \nstring <- 'cata'\nmake_palindrome(string)\n",
  "\n    if (is.null(string) || nchar(string) == 0) return(string)\n    if (nchar(string)\
    \ == 1) return(string)\n    if (nchar(string) == 2) {\n        if (substr(string,\
    \ 1, 1) == substr(string, 2, 2)) return(string)\n        return(paste(string,\
    \ substr(string, 1, 1), sep = ''))\n    }\n    r <- substr(string, 1, 1)\n   \
    \ s <- substr(string, 2, nchar(string))\n    t <- substr(string, nchar(string),\
    \ nchar(string))\n    if (nchar(s) >= 2) {\n        if (t == r) {\n          \
    \  if (substr(s, 1, 1) == substr(s, nchar(s), nchar(s))) return(paste(string,\
    \ rev(s), sep = ''))\n            if (substr(s, 1, 1) == substr(s, nchar(s) -\
    \ 1, nchar(s) - 1)) return(paste(string, substr(s, 2, nchar(s)), substr(s, 1,\
    \ 1), sep = ''))\n            if (substr(s, 2, 2) == substr(s, nchar(s), nchar(s)))\
    \ return(paste(string, substr(s, 1, 1), substr(s, 2, nchar(s)), sep = ''))\n \
    \       }\n        return(paste(string, rev(s), sep = ''))\n    }\n    return(paste(string,\
    \ rev(s), sep = ''))\n}\n\nmake_palindrome <- function(string) {\n    if (is.null(string)\
    \ || nchar(string) == 0) return(string)\n    r <- substr(string, 1, 1)\n    s\
    \ <- substr(string, 2, nchar(string))\n    t <- substr(string, nchar(string),\
    \ nchar(string))\n    if (nchar(s) >= 2) {\n        if (t == r) {\n          \
    \  if (substr(s, 1, 1) == substr(s, nchar(s), nchar(s))) return(paste(string,\
    \ rev(s),", "\n    if (string == '') {\n        return('')\n    }\n    longest_palindrome_end\
    \ <- function(string) {\n        for (i in seq(1, nchar(string))) {\n        \
    \    test_string <- string[seq(1, i)]\n            if (test_string == rev(test_string))\
    \ {\n                return(i)\n            }\n        }\n        return(0)\n\
    \    }\n    n <- longest_palindrome_end(string)\n    return(paste(string, rev(string[seq(1,\
    \ nchar(string) - n)]), sep = ''))\n}\n", "\n  length_of_palindrome_suffix <-\
    \ find_longest_palindrome_length(string)\n  prefix <- substr(string, 1, nchar(string)\
    \ - length_of_palindrome_suffix)\n  suffix <- substr(string, nchar(string) - length_of_palindrome_suffix\
    \ + 1, nchar(string))\n  return(paste(string, rev(prefix), sep = ''))\n}\n\nprint(make_palindrome(''))\n\
    print(make_palindrome('cat'))\nprint(make_palindrome('cata'))\n", "\n  if (length(string)\
    \ == 0) {\n    return (string)\n  }\n  longest_palindrome_suffix <- function(string)\
    \ {\n    # Find the longest palindrome starting from the end of the string.\n\
    \    # It's a suffix of the string.\n    # We could use Regex to find palindromes\
    \ but recursion is much easier in this case.\n    # Start with a single character\
    \ palindrome.\n    # If two last characters are the same check if the remaining\
    \ string is a palindrome.\n    # Repeat until you run out of characters or find\
    \ the longest palindrome.\n    if (nchar(string) == 1) {\n      return (string)\n\
    \    }\n    if (substr(string, nchar(string), nchar(string)) == substr(string,\
    \ nchar(string) - 1, nchar(string) - 1)) {\n      return (longest_palindrome_suffix(substr(string,\
    \ 1, nchar(string) - 1)))\n    }\n    return (substr(string, nchar(string), nchar(string)))\n\
    \  }\n  return (paste(string, string[-1], sep=''))\n}\n", "\n  # Base case: return\
    \ supplied string\n  if (nchar(string) == 0) {\n    return(string)\n  }\n  # Find\
    \ the longest palindromic postfix\n  for (i in nchar(string):1) {\n    if (substr(string,\
    \ i, nchar(string)) == rev(substr(string, i, nchar(string)))) {\n      return(paste(string,\
    \ rev(substr(string, 1, i - 1)), sep = ''))\n    }\n  }\n}\nmake_palindrome('cata')\n",
  "\n  # Find a longest palindromic postfix of string.\n  suffix <- string\n  while\
    \ (suffix != '') {\n    if (is_palindrome(suffix)) {\n      break\n    }\n   \
    \ suffix <- substr(suffix, 2, nchar(suffix))\n  }\n  prefix <- substr(string,\
    \ 1, nchar(string) - nchar(suffix))\n  return(paste(string, paste(rev(unlist(strsplit(prefix,\
    \ split=''))), collapse=''), sep=''))\n}\nmake_palindrome('cat')\nmake_palindrome('cata')\n\
    make_palindrome('cataaa')\nmake_palindrome('cataaaaa')\n", "\n  # find the longest\
    \ palindromic postfix\n  longest_palindromic_postfix <- longest_palindromic_substring(string)\n\
    \  n <- nchar(string)\n  if (nchar(longest_palindromic_postfix) == n) {\n    return(string)\n\
    \  }\n  # find the suffix index within the string\n  suffix_index <- n - nchar(longest_palindromic_postfix)\n\
    \  # get the prefix up to the suffix\n  prefix <- substr(string, 1, suffix_index)\n\
    \  # reverse the prefix\n  return(paste(string, stringr::str_reverse(prefix),\
    \ sep = ''))\n}\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n",
  "\n    n <- nchar(string)\n    longest_suffix <- function(string, start_from) {\n\
    \        is_palindrome <- function(string) {\n            return(string == rev(string))\n\
    \        }\n        for (i in seq(from = start_from, to = n)) {\n            if\
    \ (is_palindrome(substr(string, start = start_from, stop = i))) {\n          \
    \      return(i)\n            }\n        }\n        return(NA)\n    }\n    end_of_suffix\
    \ <- longest_suffix(string, start_from = 1)\n    if (is.na(end_of_suffix)) {\n\
    \        return(paste0(string, rev(string)))\n    }\n    else {\n        return(paste0(string,\
    \ rev(substr(string, start = 1, stop = n - end_of_suffix))))\n    }\n}\n\nassert.that(make_palindrome('')\
    \ == '')\nassert.that(make_palindrome('cat') == 'catac')\nassert.that(make_palindrome('cata')\
    \ == 'catac')\n", "\n  palindrome <- function(string) {\n    sapply(1:ceiling(nchar(string)/2),\
    \ function(x) substr(string, 1, x) == substr(string, nchar(string)-x+1, nchar(string)))\n\
    \  }\n  string <- paste0(string, sapply(seq_along(palindrome(string)), function(x)\
    \ {\n    if (palindrome(string)[x]) return(NA)\n    if (x == 1) return(string)\n\
    \    rev(substr(string, 1, x))\n  }))\n  return(string)\n}\n ", "\n    string_length\
    \ <- nchar(string)\n    # Find the longest postfix that is a palindrome.\n   \
    \ longest_postfix <- 0\n    longest_prefix <- string_length\n    while (longest_prefix\
    \ > 0) {\n        # Check if current prefix is a palindrome.\n        if (is_palindrome(string[1:longest_prefix]))\
    \ {\n            longest_postfix <- longest_prefix\n            break\n      \
    \  }\n        longest_prefix <- longest_prefix - 1\n    }\n    # Add prefix to\
    \ suffix.\n    return (paste(string, rev(string[(longest_postfix + 1):string_length]),\
    \ sep = ''))\n}\n", "\n  # Init.\n  string <- gsub('\\\\s', '', string)\n  n <-\
    \ nchar(string)\n  if (n == 0) return('')\n  # Find the longest palindromic suffix.\n\
    \  if (is_palindrome(string)) return(string)\n  if (is_palindrome(substr(string,\
    \ 2, n))) return(paste(substr(string, 2, n), substr(string, 1, 1), sep = ''))\n\
    \  i <- n\n  while (!is_palindrome(substr(string, 1, i))) i <- i - 1\n  return(paste(string,\
    \ substr(string, i + 1, n), sep = ''))\n}\n", "\n  longest_palindrome_suffix <-\
    \ max(1, which.max(sapply(1:length(string), function(i) is_palindrome(substr(string,\
    \ i, length(string))))))\n  return(paste(string, substr(string, 1, length(string)\
    \ - longest_palindrome_suffix + 1), sep=''))\n}\n", "\n    if(nchar(string) ==\
    \ 0) return(string)\n    if(nchar(string) == 1) return(paste(string, string, sep\
    \ = ''))\n    i <- nchar(string)\n    while(i > 0) {\n        if(is_palindrome(substr(string,\
    \ i, nchar(string)))) break\n        i <- i - 1\n    }\n    if(i == 0) return(string)\n\
    \    return(paste(string, substr(string, 1, i - 1), sep = ''))\n}\n", "\n  if\
    \ (identical(string, '')) {\n    return('')\n  }\n  string_length <- nchar(string)\n\
    \  string_suffix <- string\n  while (string_length > 0) {\n    if (identical(string_suffix,\
    \ rev(string_suffix))) {\n      break\n    }\n    string_suffix <- substr(string_suffix,\
    \ 2, string_length)\n    string_length <- string_length - 1\n  }\n  return(paste(string,\
    \ substr(string, 1, string_length - 1), sep = ''))\n}\n", "\n  # Find the location\
    \ of the longest palindromic suffix.\n  longest_palidrome_suffix <- function(string)\
    \ {\n    rev <- stringr::str_reverse(string)\n    for (i in 1:nchar(string)) {\n\
    \      if (stringr::str_sub(string, i, nchar(string)) == stringr::str_sub(rev,\
    \ 1, nchar(string) - i + 1)) {\n        return(i)\n      }\n    }\n    return(1)\n\
    \  }\n  # Compute the result.\n  suffix_length <- longest_palidrome_suffix(string)\n\
    \  prefix <- stringr::str_sub(string, 1, nchar(string) - suffix_length + 1)\n\
    \  return(stringr::str_c(string, stringr::str_reverse(prefix)))\n}", "\n  if (nchar(string)\
    \ == 0) return (string)\n  if (nchar(string) == 1) return (string)\n  if (nchar(string)\
    \ == 2) {\n    if (substr(string, 1, 1) == substr(string, 2, 2)) return (string)\n\
    \    else return (paste(string, string[nchar(string):1], sep=''))\n  }\n  if (nchar(string)\
    \ > 2) {\n    palindrome_pos <- find_palindrome_pos(string)\n    if (palindrome_pos\
    \ == 1) return (string)\n    else {\n      substr(string, palindrome_pos, nchar(string))\
    \ <- ''\n      return (paste(string, string[nchar(string):1], sep=''))\n    }\n\
    \  }\n}\n", "\n    # Find the longest postfix of the string that is a palindrome.\n\
    \    len_str <- nchar(string)\n    # This will hold the indices of a palindromic\
    \ suffix in the string.\n    suffix_idx <- 1:len_str\n    # This will be the length\
    \ of the palindromic suffix.\n    suffix_len <- 0\n    # This will be the index\
    \ of the first letter of the palindromic suffix.\n    suffix_start <- 0\n    #\
    \ This loop will go through the string, checking if a postfix of the string up\
    \ to the current index is a palindrome.\n    for (i in 1:len_str) {\n        #\
    \ If we've already found a palindromic suffix, check if the current suffix is\
    \ longer than it.\n        if (suffix_len > 0) {\n            # Check if a substring\
    \ from the current index to the index immediately before the first letter of the\
    \ palindromic suffix is a palindrome.\n            if (string[suffix_idx[1:(i\
    \ - suffix_start)]] == rev(string[i:suffix_start])) {\n                # This\
    \ is the first letter of the palindromic suffix.\n                suffix_start\
    \ <- i\n                # This is the length of the palindromic suffix.\n    \
    \            suffix_len <- suffix_len + 1\n                # This is the indices\
    \ of the letters of the palindromic suffix.\n                suffix_idx <- i:suffix_start\n\
    \            }\n        }\n        # If we haven't found a palindromic suffix\
    \ yet, check if the suffix is a palindrome.\n        if (suffix_len == 0) {\n\
    \            # Check if a substring from the current index to the first letter\
    \ of the string is a palindrome.\n            if (string[1:i] == rev(string[i:1]))\
    \ {\n                # This is the first letter of the palindromic suffix.\n \
    \               suffix_start <- i\n                # This is the length of the\
    \ palindromic suffix.\n                suffix_len <- suffix_len + 1\n        \
    \        # This is the indices of the letters of the palindromic suffix.\n   \
    \             suffix_idx <- i:suffix_start\n            }", "\n\t\n\t# If nothing\
    \ is passed, return nothing.\n\tif(length(string) == 0) {\n\t\treturn('')\n\t\
    }\n\t\n\t# Find the longest palindromic suffix of the string.\n\tfor(j in seq(length(string),\
    \ 1, -1)) {\n\t\t\n\t\t# Find the longest prefix that is also a palindrome.\n\t\
    \tsubstring <- substr(string, 1, j)\n\t\t\n\t\t# Break if the found prefix is\
    \ a palindrome.\n\t\tif(substring == rev(substring)) {\n\t\t\tbreak\n\t\t}\n\t\
    }\n\t\n\t# Return the string with the suffix added to the end.\n\treturn(paste(string,\
    \ rev(substring), sep = ''))\n}\n", "\n    if (length(string) == 0) return(string)\n\
    \n    # Find the end of the longest palindromic suffix.\n    tail_len <- 0\n \
    \   max_len <- length(string)\n    while (tail_len < max_len) {\n        if (is_palindrome(string[max_len\
    \ - tail_len + 1:max_len])) break\n        tail_len <- tail_len + 1\n    }\n\n\
    \    # Append the reverse of the prefix before the palindromic suffix.\n    return(paste(string,\
    \ rev(string[1:(max_len - tail_len)]), sep=''))\n}\n", "\n \n  # Find the longest\
    \ postfix that is a palindrome\n  strlength <- nchar(string)\n \n  # If the supplied\
    \ string is empty, return an empty string\n  if (strlength == 0) return('')\n\
    \ \n  # If the supplied string is a palindrome, just return it\n  if (is_palindrome(string))\
    \ return(string)\n \n  # Find the longest postfix that is a palindrome\n  postfix_len\
    \ <- 0\n  for (i in 0:(strlength - 1)) {\n    substr <- substr(string, (strlength\
    \ - i), strlength)\n    if (is_palindrome(substr)) {\n      postfix_len <- i\n\
    \      break\n    }\n  }\n \n  # Return the string with appended reverse of the\
    \ prefix\n  return(paste(string, substr(string, 1, (strlength - postfix_len -\
    \ 1)), sep = ''))\n}\n ", "\n  if (is.null(string) || nchar(string) == 0) {\n\
    \    return('')\n  }\n\n  # Initialize with the full string length.\n  length\
    \ <- nchar(string)\n\n  # For a string length between 1 and n.\n  for (i in 1:length)\
    \ {\n    prefix <- substr(string, 1, length - i)\n    suffix <- substr(string,\
    \ i + 1, length)\n\n    # If suffix is a palindrome then append reverse of the\
    \ prefix.\n    if (is_palindrome(suffix)) {\n      return(paste(string, strsplit(prefix,\
    \ split = '')[[1]][length(prefix):1], sep = ''))\n    }\n  }\n\n  # If all postfixes\
    \ are not palindromes append the full reverse.\n  return(paste(string, strsplit(string,\
    \ split = '')[[1]][length:1], sep = ''))\n}\n", "\n  # get reverse of the string\n\
    \  reverse_string <- function(string) {\n    # reverse the string\n    string\
    \ <- string[nchar(string):1]\n    return(string)\n  }\n  # start with the first\
    \ half of the string\n  palindrome <- substr(string, 1, nchar(string) %/% 2)\n\
    \  # try to find a longer palindrome\n  while (TRUE) {\n    if (substr(string,\
    \ nchar(palindrome) + 1, nchar(palindrome) + nchar(palindrome)) == palindrome)\
    \ {\n      # found longer palindrome\n      break\n    }\n    palindrome <- substr(string,\
    \ 1, nchar(palindrome) + 1)\n  }\n  # append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix\n  palindrome <-\
    \ paste(string, substr(string, 1, nchar(string) - nchar(palindrome)), sep='')\n\
    \  return(palindrome)\n}", "\n    if (length(string) < 2) return(string)\n   \
    \ longest_palindrome <- function(string) {\n        # Find the longest palindrome\
    \ that begins at the beginning of the supplied string.\n        # Algorithm idea\
    \ is simple:\n        # - Take a midpoint of the string and incrementally expand\
    \ it to the left and to the right.\n        for (i in 1:(length(string) / 2))\
    \ {\n            if (substr(string, i, i) != substr(string, length(string) - i\
    \ + 1, length(string) - i + 1)) break\n        }\n        substr(string, 1, i\
    \ - 1)\n    }\n    return(paste(string, substring(string, 1, length(string) -\
    \ nchar(longest_palindrome(string))), sep = ''))\n}\n", "\n  if (string == '')\
    \ return('')\n  len <- nchar(string)\n  is_palindrome <- vector('logical', len)\n\
    \  for (i in 1:len) {\n    for (j in i:len) {\n      if (is_palindrome[j]) {\n\
    \        if (substr(string, i, j) == rev(substr(string, i, j))) {\n          is_palindrome[i]\
    \ <- TRUE\n          break\n        }\n      }\n    }\n  }\n  palindrome_len <-\
    \ max(which(is_palindrome))\n  paste(string, rev(substr(string, 1, len - palindrome_len)),\
    \ sep = '')\n}\n", "\n    if (nchar(string) <= 1) {\n        return(string)\n\
    \    }\n    string_rev <- rev(string)\n    result <- string\n    for (i in seq(1,\
    \ nchar(string), by = -1)) {\n        result <- paste(result, substr(string_rev,\
    \ 1, i), sep = '')\n        if (str_detect(result, '^(.*)' + substr(string, 1,\
    \ i) + '$')) {\n            break\n        }\n    }\n    return(result)\n}", "\n\
    \    postfix <- ''\n    longest_prefix <- ''\n    for (i in seq_along(string))\
    \ {\n        is_palindrome <- string[i] == string[1]\n        prefix <- string[1:i]\n\
    \        postfix <- string[(length(string)-i+1):length(string)]\n        if (is_palindrome\
    \ & is_palindrome_string(postfix)) {\n            longest_prefix <- prefix\n \
    \       }\n    }\n    paste(string, rev(longest_prefix), sep='')\n}\n\nrun_tests(\n\
    \    'make_palindrome',\n    make_palindrome,\n    '',\n    'cat',\n    'cata'\n\
    )\n", "\n    sub <- substring(string, 1, max(which(rev(string) == string, arr.ind\
    \ = TRUE)[1]));\n    sub <- paste(sub, rev(sub), sep = '');\n    sub\n}\n", "\n\
    \  if (identical(string, '')) {\n    return('')\n  }\n  if (string_is_palindrome(string))\
    \ {\n    return(string)\n  }\n  max_length <- length(string)\n  for (i in seq_len(max_length))\
    \ {\n    substr <- substr(string, (i + 1), max_length)\n    if (string_is_palindrome(substr))\
    \ {\n      return(paste(string, substr(string, 1, i), sep = ''))\n    }\n  }\n\
    }\n", "\n    if (nchar(string) == 0) {\n        return (string)\n    }\n    for\
    \ (i in seq(nchar(string))) {\n        substr_end <- nchar(string)\n        substr_start\
    \ <- nchar(string) - i + 1\n        substr <- substr(string, substr_start, substr_end)\n\
    \        if (is_palindrome(substr)) {\n            prefix <- substr(string, 1,\
    \ substr_start - 1)\n            return (paste(string, substr(prefix, rev(1:nchar(prefix)),\
    \ nchar(prefix)), sep = ''))\n        }\n    }\n}\nis_palindrome <- function(string)\
    \ {\n    rev(string) == string\n}\n\nmake_palindrome('cata')\n\n'''\nThe most\
    \ obvious idea that comes to mind is to choose a pivot element and\ncompare it\
    \ to all other elements. This approach is called linear search.\n\nWhich data\
    \ structure to use to store the numbers?\nThe first idea would be to use an array.\
    \ However, we would have to somehow\nmake sure that there are no duplicates. A\
    \ straightforward way to do that\nwould be to sort the array in ascending order\
    \ and then compare neighboring\nelements.\n\nWhat is the time complexity of this\
    \ algorithm?\nIn the worst case we have to examine all n numbers.\nTherefore,\
    \ the worst-case time complexity is O(n).\n\nThe best case scenario?\nIn the best\
    \ case, a duplicate element is the first one.\nTherefore, the best-case time complexity\
    \ is O(1).\n\nIs there a better way?\nYes, there is. If we had all numbers from\
    \ 1 to n stored in an array,\nwe could tell whether we have a duplicate element\
    \ or not\nby accessing the array elements in sequence.\n\nWhat is the time complexity\
    \ of this algorithm?\nThe time complexity of this algorithm is O(n).\n\nWhat is\
    \ the space complexity of this algorithm?\nThe space complexity of this algorithm\
    \ is O(n).\n'''", "\n  str_rev <- stringr::str_reverse(string)\n  longest_common_suffix\
    \ <- stringr::str_extract(string, paste(stringr::str_extract(str_rev, \".*\"),\
    \ collapse = \"$\"))\n  longest_common_prefix <- stringr::str_extract(str_rev,\
    \ paste(stringr::str_extract(longest_common_suffix, \".*\"), collapse = \"$\"\
    ))\n  paste(string, stringr::str_reverse(longest_common_prefix), sep = \"\")\n\
    }\n", "\n  if (nchar(string) == 0) {\n    return(string)\n  }\n  suffix <- substr(string,\
    \ 1, nchar(string))\n  while (suffix != ' ') {\n    suffix <- substr(string, 1,\
    \ nchar(suffix))\n    if (is_palindrome(suffix)) {\n      break\n    }\n  }\n\
    \  return(paste(string, substr(string, 1, nchar(string) - nchar(suffix)), sep\
    \ = ''))\n}\n", "\n  n <- nchar(string)\n  longest_palin_postfix <- function(n)\
    \ {\n    for (i in n:1) {\n      if (substr(string, 1, i) == rev(substr(string,\
    \ n - i + 1, n))) {\n        return(substr(string, 1, i))\n      }\n    }\n  \
    \  return(substr(string, 1, 1))\n  }\n  return(paste(string, rev(substr(string,\
    \ 1, n - nchar(longest_palin_postfix(n)))), sep = ''))\n}", "\n    if (nchar(string)\
    \ == 0) {\n        return(string)\n    }\n    for (i in seq(nchar(string), 0,\
    \ -1)) {\n        if (is_palindrome(substr(string, i, nchar(string)))) {\n   \
    \         return(paste(string, rev(substr(string, 1, i - 1)), sep = ''))\n   \
    \     }\n    }\n}\n", "\n  if (nchar(string) == 0) return(string)\n  max.suffix.length\
    \ <- 1\n  for (suffix.length in seq(nchar(string) - 1, 1, -1)) {\n    test.suffix\
    \ <- substr(string, nchar(string) - suffix.length + 1, nchar(string))\n    if\
    \ (test.suffix == rev(test.suffix)) {\n      max.suffix.length <- suffix.length\n\
    \      break\n    }\n  }\n  rev(substr(string, 1, nchar(string) - max.suffix.length))\
    \ %+% string\n}\n ", "\n    # we start with a palindrome being the longest possible\
    \ postfix of a string that is a palindrome\n    palindrome <- longest_palindrome_suffix(string)\n\
    \    # and we append to the end of the string prefix that comes before the palindromic\
    \ suffix, reversed\n    string <- paste(string, string[seq(nchar(palindrome) +\
    \ 1, nchar(string))], sep = '')\n    # and we return string\n    return(string)\n\
    }", "\n    # Find the longest palindromic suffix by comparing each character with\
    \ its mirror position.\n    len <- nchar(string)\n    suffix <- string\n    for\
    \ (i in 1:(len - 1)) {\n        if (str_sub(string, i, len) == str_sub(string,\
    \ 1, len - i + 1) %>% str_rev) {\n            suffix <- str_sub(string, i, len)\n\
    \        }\n    }\n    return(paste(string, str_sub(string, 1, len - nchar(suffix))\
    \ %>% str_rev, sep = ''))\n}", "\n  if (nchar(string) == 0) {\n    return(string)\n\
    \  }\n  suffix <- string\n  string_length <- nchar(string)\n  while (string_length\
    \ > 0) {\n    if (is_palindrome(suffix)) {\n      prefix <- substr(string, 1,\
    \ string_length)\n      return(paste(string, rev(prefix), sep = ''))\n    }\n\
    \    string_length <- string_length - 1\n    suffix <- substr(string, string_length\
    \ + 1, nchar(string))\n  }\n}\n", "\n  if (string == '') {\n    return ('')\n\
    \  }\n\n  # Find the longest postfix that is a palindrome.\n  palindrome_suffix\
    \ <- ''\n  for (i in 1:nchar(string)) {\n    if (is_palindrome(substr(string,\
    \ i, nchar(string)))) {\n      palindrome_suffix <- substr(string, i, nchar(string))\n\
    \      break\n    }\n  }\n\n  # If the string is already a palindrome, return\
    \ it.\n  if (palindrome_suffix == string) {\n    return (string)\n  }\n\n  # Otherwise,\
    \ append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n  prefix <- substr(string, 1, nchar(string) - nchar(palindrome_suffix))\n\
    \  return (paste(string, rev(prefix), sep = ''))\n}\n\nmake_palindrome('')\nmake_palindrome('cat')\n\
    make_palindrome('cata')\n", "\n  if (string == '') {\n    return('')\n  }\n\n\
    \  str_length <- nchar(string)\n  is_palindrome <- function(string) {\n    str_reversed\
    \ <- stringr::str_reverse(string)\n    return(string == str_reversed)\n  }\n\n\
    \  for (i in seq_len(str_length)) {\n    if (is_palindrome(substr(string, 1, i)))\
    \ {\n      prefix <- substr(string, i + 1, str_length)\n      return(paste(string,\
    \ stringr::str_reverse(prefix), sep = ''))\n    }\n  }\n}\n", "\n\tif(string ==\
    \ '') {\n\t\treturn('')\n\t}\n\n\tstring_length <- nchar(string)\n\tfor(i in 0:(string_length\
    \ - 1)) {\n\t\tif(is_palindrome(substr(string, i + 1, string_length))) {\n\t\t\
    \tif(i == 0) {\n\t\t\t\treturn(string)\n\t\t\t} else {\n\t\t\t\treturn(paste(string,\
    \ substr(string, 1, i), sep = ''))\n\t\t\t}\n\t\t}\n\t}\n}\n", "\n    substr(string,\
    \ 1, nchar(string) - nchar(string) %/% 2) <-\n        paste(substr(string, 1,\
    \ nchar(string) - nchar(string) %/% 2),\n              rev(substr(string, 1, nchar(string)\
    \ - nchar(string) %/% 2)),\n              sep = '')\n    return(string)\n}\n",
  "\n    # Do nothing with empty string.\n    if (nchar(string) == 0) return(string)\n\
    \    # Calculate reverse of the string.\n    reverse_string <- paste(rev(strsplit(string,\
    \ '')[[1]]), collapse = '')\n    # Find indices of strings that match the reverse\
    \ string.\n    matches <- gregexpr(paste0('(?=', reverse_string, ')'), string)\n\
    \    # Find the longest possible match.\n    max_match <- max(attr(matches, 'match.length'))\n\
    \    # Return constructed palindrome.\n    return(paste(string, substr(reverse_string,\
    \ nchar(reverse_string) - max_match + 1, nchar(reverse_string)), sep = ''))\n\
    }\nmake_palindrome('cata')\n", "\n    if (string == '') return('')\n    string\
    \ = sub('^([^a-zA-Z]+|[^a-zA-Z]+$)', '', string)\n    len = nchar(string)\n  \
    \  if (len == 1) return(string)\n    is_palindrome = function(start, end) {\n\
    \        string[start:end] == string[start:end][nchar(string[start:end]):1]\n\
    \    }\n    for (i in len:1) {\n        for (j in 1:(len - i + 1)) {\n       \
    \     if (is_palindrome(j, j + i - 1)) {\n                return(paste(string,\
    \ string[1:(j - 1)][nchar(string[1:(j - 1)]):1], sep = ''))\n            }\n \
    \       }\n    }\n}\nmake_palindrome('cat')\nmake_palindrome('cata')\nmake_palindrome('cata')\n\
    make_palindrome('cata')", "\n  if (nchar(string) == 0) {\n    return(string)\n\
    \  }\n\n  reversed_string <- strrev(string)\n  reversed_string_suffix <- sub(string,\
    \ \"\", reversed_string)\n  reversed_string_suffix <- paste(reversed_string_suffix,\
    \ string, sep=\"\")\n  return(reversed_string_suffix)\n}\n", "\n  if(string ==\
    \ '') return('')\n  string <- unlist(strsplit(string, ''))\n  string_length <-\
    \ length(string)\n  if(string_length == 1) return(string)\n  for(i in seq(string_length,\
    \ 1, -1)) {\n    if(is_palindrome(string[1:i])) {\n      if(i == string_length)\
    \ return(string)\n      return(c(string, rev(string[-(i+1):string_length])))\n\
    \    }\n  }\n}\n", "\n  # Find maximum prefix that is a palindrome (mirror the\
    \ string)\n  mirror <- string\n  while (!is_palindrome(mirror)) {\n    mirror\
    \ <- substr(mirror, 2, nchar(mirror))\n  }\n  # Append to the end of the string\
    \ reverse of the prefix\n  return(paste(string, substr(mirror, 1, nchar(mirror)\
    \ - 1), sep=''))\n}\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n",
  "\n    if (nchar(string) == 0) return(string)\n    pflen <- length(find_palindrome_postfix(string))\n\
    \    prefix <- substr(string, 1, nchar(string) - pflen)\n    return(paste(string,\
    \ strrev(prefix), sep = ''))\n}\n", "\n  is_palindrome <- function(string) {\n\
    \    n <- nchar(string)\n    if (n == 0) {\n      return(TRUE)\n    }\n    else\
    \ if (n == 1) {\n      return(TRUE)\n    }\n    else {\n      return(substr(string,\
    \ 1, 1) == substr(string, n, n) && is_palindrome(substr(string, 2, n - 1)))\n\
    \    }\n  }\n  if (is_palindrome(string)) {\n    return(string)\n  }\n  else {\n\
    \    m <- nchar(string)\n    while (m > 0) {\n      substring <- substr(string,\
    \ 1, m)\n      if (is_palindrome(substring)) {\n        break\n      }\n     \
    \ m <- m - 1\n    }\n    if (m == 0) {\n      return(string)\n    }\n    else\
    \ {\n      prefix <- substr(string, m + 1, nchar(string))\n      return(paste(string,\
    \ string, sep = ''))\n    }\n  }\n}\nmake_palindrome('')\nmake_palindrome('cat')\n\
    make_palindrome('cata')", "\n    if (nchar(string) == 0) return(string)\n    if\
    \ (nchar(string) == 1) return(paste(string, string, sep=''))\n    if (nchar(string)\
    \ == 2) {\n        if (string[1] == string[2]) return(string)\n        else return(paste(string,\
    \ string[2], string[1], sep=''))\n    }\n    # Find the longest palindromic suffix\
    \ of string.\n    for (i in seq(nchar(string), 1, -1)) {\n        if (is_palindrome(string[seq(nchar(string)-i+1,\
    \ nchar(string))])) break\n    }\n    # Return the shortest palindrome.\n    return(paste(string,\
    \ paste(rev(string[seq(1, nchar(string)-i)]), collapse=''), sep=''))\n}\n", "\n\
    \  if (nchar(string) == 0) {\n    return(string)\n  }\n  palindrome_suffix <-\
    \ function(s) {\n    if (identical(s, rev(s))) {\n      return(s)\n    }\n   \
    \ palindrome_suffix(substr(s, 2, nchar(s)))\n  }\n  return(paste(string, rev(substr(string,\
    \ 1, nchar(string) - nchar(palindrome_suffix(string)))), sep=''))\n}\nprint(make_palindrome(''))\n\
    print(make_palindrome('cat'))\nprint(make_palindrome('cata'))\n", "\n    string\
    \ <- unlist(strsplit(string, ''))\n    # find longest palindromic suffix\n   \
    \ for (i in 1:length(string)) {\n        reversed_prefix <- rev(string[1:(length(string)\
    \ - i + 1)])\n        if (string[(length(string) - i + 1):length(string)] == reversed_prefix)\
    \ {\n            break\n        }\n    }\n    # append reversed prefix to end\
    \ of string\n    cat(string, rev(string[1:(length(string) - i + 1)]), sep = '')\n\
    }\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n", "\n\
    \    longest_palindrome_suffix <- function(string) {\n        for (i in seq_along(string))\
    \ {\n            if (identical(string[1:i], rev(string[(length(string)-i+1):length(string)])))\
    \ {\n                return(string[(length(string)-i+1):length(string)])\n   \
    \         }\n        }\n        ''\n    }\n    palindrome_suffix <- longest_palindrome_suffix(string)\n\
    \    string <- paste(string, sep='', collapse='')\n    paste(string, rev(string[1:(length(string)-length(palindrome_suffix))]),\
    \ sep='', collapse='')\n}", "\n  find_palindrome_suffix <- function(string) {\n\
    \    max_suffix_length <- 0\n    for (i in seq_along(string)) {\n      candidate\
    \ <- string[(i - 1):length(string)]\n      if (identical(candidate, rev(candidate)))\
    \ {\n        max_suffix_length <- length(candidate)\n      }\n    }\n    string[1:(length(string)\
    \ - max_suffix_length)]\n  }\n  paste0(string, rev(find_palindrome_suffix(string)))\n\
    }\n", "\n    # Edge case.\n    if (string == '') {\n        return('')\n    }\n\
    \    # Find the palindromic suffix.\n    suffix <- 0\n    for (i in seq(nchar(string)))\
    \ {\n        if (string[1:i] == rev(string[nchar(string) - i + 1:nchar(string)]))\
    \ {\n            suffix <- i\n        }\n    }\n    # Append the reverse of the\
    \ prefix to the end of the string.\n    return(paste(string, rev(string[1:(nchar(string)\
    \ - suffix)]), sep = ''))\n}\n ", "\n  n <- nchar(string)\n  if (n == 0) return(string)\n\
    \  suffix <- substring(string, rev(seq_len(n)), n)\n  #print(suffix)\n  longest_palindrome\
    \ <- seq_len(n)\n  for (i in seq_len(n-1)) {\n    if (substring(string, rev(seq_len(i)),\
    \ i) == substring(string, seq_len(i), i)) {\n      longest_palindrome <- i\n \
    \   }\n  }\n  return(string %+% substring(string, rev(seq_len(n-longest_palindrome)),\
    \ n-longest_palindrome))\n}\n", "\n  if (string == '') {\n    return('')\n  }\n\
    \  string_len <- nchar(string)\n  rev_string <- rev(string)\n  if (string_len\
    \ == 1) {\n    return(string)\n  }\n  string_is_palindrome <- (string == rev_string)\n\
    \  if (string_is_palindrome) {\n    return(string)\n  }\n  rev_string_prefix <-\
    \ rev_string[1:(string_len - 1)]\n  longest_palindrome_suffix <- reduce(0:(string_len\
    \ - 1),\n                                      function(palindrome_suffix_end,\
    \ i) {\n                                        substr(string, 1, i) == substr(rev_string_prefix,\
    \ string_len - i, string_len - 1) &&\n                                       \
    \   i ||\n                                          palindrome_suffix_end\n  \
    \                                    })\n  string <- paste(string, rev_string_prefix[string_len\
    \ - longest_palindrome_suffix:string_len - 1], sep = '')\n  return(string)\n}\n",
  "\n  if (all(string == '')) {\n    string\n  } else {\n    palindrome_suffix <-\
    \ string[which.max(is_palindrome(substr(string, seq(nchar(string)), 1)))]\n  \
    \  rev(substr(string, 1, nchar(string) - nchar(palindrome_suffix))) %s+% palindrome_suffix\n\
    \  }\n}", "\n    suffix_len <- find_longest_palindrome_len(string)\n    prefix\
    \ <- substr(string, 1, nchar(string) - suffix_len)\n    suffix <- substr(string,\
    \ nchar(string) - suffix_len + 1, nchar(string))\n    return(paste(string, string(nchar(prefix),\
    \ ''), rev(prefix), sep = ''))\n}\n ", "\n    if (string == '') {\n        string\n\
    \    } else {\n        postfix <- longest_palindromic_postfix(string)\n      \
    \  string[1:(length(string) - length(postfix))] %>% rev %>% paste(string, sep\
    \ = '')\n    }\n}\n\nmake_palindrome('cata')\n", "\n  postfix <- find_longest_palindromic_suffix(string)\n\
    \  prefix <- substr(string, 1, nchar(string) - nchar(postfix))\n  rev(prefix)\
    \ %+% postfix\n}\n", "\n    suffix <- suffix_palindrome(string)\n    prefix <-\
    \ substr(string, 1, nchar(string) - nchar(suffix))\n    return(paste(string, stringReverse(prefix),\
    \ sep = ''))\n}\n", "\n  # First palindrome ends at 0, last at len(string)\n \
    \ p_idx <- find_longest_palindrome(string)\n  # Only palindrome is an empty string\
    \ or only one symbol\n  if (p_idx[1] == 0 && p_idx[2] == 0) {\n    return(string)\n\
    \  } else {\n    return(paste(string, rev(substring(string, 1, p_idx[1])), sep\
    \ = ''))\n  }\n}\n", "\n  strlen <- nchar(string)\n  longest_palindrome_length\
    \ <- 0\n  longest_palindrome_start <- 0\n  for (string_start in 1:strlen) {\n\
    \    # Expand around the center.\n    left <- string_start - 1\n    right <- string_start\n\
    \    while (left >= 0 && right < strlen && substr(string, left + 1, left + 1)\
    \ == substr(string, right + 1, right + 1)) {\n      if (right - left + 1 > longest_palindrome_length)\
    \ {\n        longest_palindrome_length <- right - left + 1\n        longest_palindrome_start\
    \ <- left\n      }\n      left <- left - 1\n      right <- right + 1\n    }\n\
    \    # Expand around the center again.\n    left <- string_start - 1\n    right\
    \ <- string_start + 1\n    while (left >= 0 && right < strlen && substr(string,\
    \ left + 1, left + 1) == substr(string, right + 1, right + 1)) {\n      if (right\
    \ - left + 1 > longest_palindrome_length) {\n        longest_palindrome_length\
    \ <- right - left + 1\n        longest_palindrome_start <- left\n      }\n   \
    \   left <- left - 1\n      right <- right + 1\n    }\n  }\n  longest_palindrome_end\
    \ <- longest_palindrome_start + longest_palindrome_length - 1\n  return(paste(string,\
    \ substr(string, 1, longest_palindrome_start), sep = ''))\n}\n", "\n  if (string\
    \ == '') return('')\n  # Find the longest palindromic postfix.\n  postfix <- string\n\
    \  while (!is_palindrome(postfix)) {\n    postfix <- postfix[-1]\n  }\n  # Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n  paste(string, rev(substring(string, 1, nchar(string) - nchar(postfix))),\
    \ sep = '')\n}\nmake_palindrome('cat')\nmake_palindrome('cata')\nmake_palindrome('aabbac')\n\
    make_palindrome('abac')\nmake_palindrome('abba')\nmake_palindrome('abo')\nmake_palindrome('abababa')\n",
  "\n    if (string == '') return('')\n    len <- nchar(string)\n    if (len == 1)\
    \ return(string)\n    result <- ''\n    for (i in seq(len)) {\n        a <- substr(string,\
    \ i, len)\n        if (is_palindrome(a)) {\n            result <- paste(string,\
    \ substr(string, 1, i - 1), sep = '')\n            break\n        }\n    }\n \
    \   return(result)\n}\n ", "\n\t# Find the longest postfix that is palindrome.\n\
    \tlongest_postfix <- function(s) {\n\t\ts <- as.character(s)\n\t\tn <- nchar(s)\n\
    \t\tv <- vector(mode='integer', length=n)\n\t\tv[1] <- 0\n\t\tk <- 0\n\t\tfor\
    \ (i in 2:n) {\n\t\t\twhile (k > 0 && substr(s, i, i) != substr(s, k+1, k+1))\
    \ {\n\t\t\t\tk <- v[k]\n\t\t\t}\n\t\t\tif (substr(s, i, i) == substr(s, k+1, k+1))\
    \ {\n\t\t\t\tk <- k + 1\n\t\t\t}\n\t\t\tv[i] <- k\n\t\t}\n\t\treturn(v)\n\t}\n\
    \tv <- longest_postfix(string)\n\tn <- nchar(string)\n\t# Longest palindromic\
    \ postfix ends at index k.\n\tk <- v[n]\n\t# Now construct a string.\n\tnew_string\
    \ <- paste(string, rev(substr(string, 1, n-k)), sep='')\n\treturn(new_string)\n\
    }\n", "\n  if (string == '') {\n    return('')\n  }\n\n  n <- nchar(string)\n\
    \  string.reverse <- unlist(strsplit(string, NULL))[n:1]\n  string.reverse <-\
    \ paste(string.reverse, collapse = '')\n\n  for (j in 1:n) {\n    if (string ==\
    \ string.reverse[j:(j+n-1)]) {\n      return(string[j:(n-1)])\n    }\n  }\n}\n",
  "\n  # If string is empty, return an empty string\n  if (nchar(string) == 0) {\n\
    \    return('')\n  }\n  # Find the longest palindromic suffix of the supplied\
    \ string.\n  # Basically we are searching for a suffix that would be a palindrome\
    \ and\n  # would be the longest at the same time.\n  pal_suffix <- string\n  while\
    \ (TRUE) {\n    # If we can't find a palindrome inside the string, then everything\
    \ before\n    # the current palindromic suffix is a palindrome itself.\n    if\
    \ (grepl(paste0('^', pal_suffix), string)) {\n      break\n    }\n    # Otherwise,\
    \ find the longest palindromic suffix of string prefix.\n    pal_suffix <- gsub(paste0('^(.*).*',\
    \ pal_suffix), '\\\\1', string)\n  }\n  # Now we reverse the prefix and append\
    \ it to the end of the string.\n  paste0(string, rev(gsub(paste0('^.*', pal_suffix),\
    \ '', string)))\n}", "\n    # Find a substring that is a longest palindrome from\
    \ the end of a string.\n    find_longest_suffix_palindrome <- function(string)\
    \ {\n        # Find out which postfix of the string is a longest palindrome.\n\
    \        # The palindrome is a string that is the same when reversed.\n      \
    \  #\n        # Strings:\n        # 'abc' -> 'cba'\n        # 'abcabc' -> 'cbaabc'\n\
    \        # 'abcabcc' -> 'cbaabcc'\n        #\n        # Algorithm idea:\n    \
    \    # Iterate over a string.\n        # For each index, check if the substring\
    \ is a palindrome by finding first and last characters.\n        # If the first\
    \ and last characters match, then check the inner substring.\n        # We do\
    \ it until the string is shorter than 2, which means it's a palindrome.\n    \
    \    # If all substrings are palindromes, then we return the longest one.\n  \
    \      #\n        # >>> find_longest_suffix_palindrome('')\n        # ''\n   \
    \     # >>> find_longest_suffix_palindrome('a')\n        # 'a'\n        # >>>\
    \ find_longest_suffix_palindrome('cat')\n        # 't'\n        # >>> find_longest_suffix_palindrome('cata')\n\
    \        # 'ata'\n        is_palindrome <- function(string) {\n            # Test\
    \ if a string is a palindrome.\n            if (length(string) <= 1) {\n     \
    \           return(TRUE)\n            }\n            if (substr(string, 1, 1)\
    \ != substr(string, length(string), length(string))) {\n                return(FALSE)\n\
    \            }\n            return(is_palindrome(substr(string, 2, length(string)\
    \ - 1)))\n        }\n        if (is_palindrome(string)) {\n            return(string)\n\
    \        }\n        for (i in 1:length(string)) {\n            substring <- substr(string,\
    \ i, length(string))\n            if (is_palindrome(substring)) {\n          \
    \      return(substring)\n            }", "\n    if (string == '') {\n       \
    \ return('')\n    }\n    for (i in 1:length(string)) {\n        prefix <- string[1:(length(string)\
    \ - i)]\n        suffix <- string[(length(string) - i + 1):length(string)]\n \
    \       if (prefix == rev(suffix)) {\n            return(paste(string, rev(prefix),\
    \ sep = ''))\n        }\n    }\n}", "\n  stopifnot(is.character(string), length(string)\
    \ > 0)\n  if (is_palindrome(string)) {\n    return(string)\n  }\n  stopifnot(string\
    \ == rev(string))\n  rev(string)\n}\n", "\n  n <- nchar(string)\n  if (n == 0)\
    \ {\n    return(string)\n  }\n  prefix_size <- 0\n  for (i in 0:(n - 1)) {\n \
    \   if (string[1:i] == rev(string[(n - i + 1):n])) {\n      prefix_size <- i\n\
    \    }\n  }\n  return(string %s+% rev(string[1:(n - prefix_size)]))\n}\nstring\
    \ <- 'cat'\nmake_palindrome(string)\n\nstring <- 'cata'\nmake_palindrome(string)\n",
  "\n  longest_palindrome_postfix <- function(string) {\n    return_char_at <- function(string,\
    \ i) {\n      substr(string, i, i)\n    }\n    string_length <- nchar(string)\n\
    \    for (i in seq(1, string_length, 1)) {\n      for (j in seq(0, string_length\
    \ - i, 1)) {\n        if (return_char_at(string, j) != return_char_at(string,\
    \ j + i)) {\n          next\n        }\n        if (j == 0) {\n          return(substr(string,\
    \ 1, i))\n        }\n      }\n    }\n    return(\"\")\n  }\n  longest_palindrome_postfix\
    \ <- longest_palindrome_postfix(string)\n  return(paste(string, substr(string,\
    \ 0, nchar(string) - nchar(longest_palindrome_postfix)), sep = \"\"))\n}\n", "\n\
    \    if (is.null(string) || string == '') {\n        string\n    } else {\n  \
    \      # Find the longest palindromic suffix.\n        suffix <- find_longest_palindromic_suffix(string)\n\
    \        if (suffix == string) {\n            # String is a palindrome.\n    \
    \        string\n        } else {\n            # Reverse the part of the string\
    \ that does not belong to palindromic suffix and append it\n            # to the\
    \ string.\n            # Note: This is no longer a palindrome, but the shortest\
    \ palindrome that begins with the\n            # supplied string.\n          \
    \  paste(string, string[1: (length(string) - length(suffix))], sep = '')\n   \
    \     }\n    }\n}\n", "\n  if (string == '') return('')\n  string <- strsplit(string,\
    \ '')[[1]]\n  if (is_palindrome(string)) return(paste(string, collapse = ''))\n\
    \  suffix <- suffix_palindrome(string)\n  prefix <- string[seq_len(length(string)\
    \ - length(suffix))]\n  paste(c(string, rev(prefix)), collapse = '')\n}\n", "\n\
    \  if (string == '') return('')\n  prefix <- longest_palindrome_suffix(string)\n\
    \  return(paste(string, rev(substr(string, 1, length(string) - length(prefix))),\
    \ sep = ''))\n}\n", "\n    if (string == '') {\n        return('')\n    }\n  \
    \  lps <- lps_palindrome(string)\n    return(string %+% substr(string, 1, nchar(string)\
    \ - lps))\n}\n", "\n  s <- unlist(strsplit(string, \"\"))\n  for (i in seq_along(s))\
    \ {\n    if (s[1:i] == rev(s[i:length(s)])) {\n      c <- rev(s[(i + 1):length(s)])\n\
    \      break\n    }\n  }\n  paste(s, c, sep = \"\")\n}\nmake_palindrome(\"\")\n\
    make_palindrome(\"cat\")\nmake_palindrome(\"cata\")\n", "\n  # Find a longest\
    \ palindromic suffix\n  i <- nchar(string)\n  while (i > 0) {\n    if (identical(substr(string,\
    \ 1, i), substr(string, i+1, nchar(string)))) {\n      break\n    }\n    i <-\
    \ i - 1\n  }\n  return(c(string, substr(string, 1, nchar(string) - i)))\n}\n",
  "\n  stopifnot(is.character(string))\n  if (string == '') {\n    return('')\n  }\n\
    \  # Reverse supplied string.\n  string_rev <- rev(string)\n  # Find the first\
    \ match of a reversed string in a supplied string.\n  # This will be the last\
    \ palindromic part of the string.\n  pal_length <- match(string_rev, string, nomatch\
    \ = -1L)\n  # If the length of the palindromic part is not equal to the length\
    \ of the supplied string\n  # then add the remainder of the supplied string to\
    \ the end of the reversed string prefix of the supplied string.\n  if (pal_length\
    \ != length(string)) {\n    string <- paste0(string, substr(string_rev, 1L, length(string)\
    \ - pal_length))\n  }\n  return(string)\n}\n", "\n    string_length <- nchar(string)\n\
    \    if (string_length == 0) {\n        return(string)\n    }\n    string_length\
    \ <- nchar(string)\n    palindrome_suffix <- longest_palindrome_suffix(string)\n\
    \    palindrome_suffix_length <- nchar(palindrome_suffix)\n    if (palindrome_suffix_length\
    \ == string_length) {\n        return(string)\n    }\n    palindrome_prefix <-\
    \ substr(string, 0, string_length - palindrome_suffix_length)\n    return(paste(string,\
    \ stringr::str_reverse(palindrome_prefix), sep = ''))\n}\n", "\n    suffix <-\
    \ longest_palindrome_suffix(string)\n    if (suffix == '') {\n        return(string)\n\
    \    }\n    prefix <- substring(string, 1, nchar(string) - nchar(suffix))\n  \
    \  return(paste(string, rev(prefix), sep=''))\n}\n", "\n    if (nchar(string)\
    \ < 2) return(string)\n    suffix <- suffix_palindrome(string)\n    rev_prefix\
    \ <- string[1:(nchar(string) - nchar(suffix))]\n    return(paste(string, rev(rev_prefix),\
    \ sep = ''))\n}\n", "\n  string_length <- nchar(string)\n  if (string_length ==\
    \ 0) {\n    return(string)\n  }\n  for (i in seq(string_length, 1, -1)) {\n  \
    \  if (substr(string, 1, i) == substr(string, i, string_length)) {\n      return(paste(string,\
    \ reverse(substr(string, 1, string_length - i)), sep = ''))\n    }\n  }\n  return(paste(string,\
    \ reverse(string), sep = ''))\n}\n", "\n    # We want to find the longest palindromic\
    \ suffix of a string\n    # s[1:i] is the longest palindromic suffix of a string\
    \ s[1:j]\n    # if and only if i == j or s[i] == s[j + 1] and s[i + 1:j] is a\
    \ palindrome.\n    #\n    # There is a trival case: s[1:0] is a palindrome.\n\
    \    #\n    # We can build a state table s[i, j] that tells if string s[i:j] is\
    \ a palindrome.\n    # We know that s[1:0] is a palindrome; s[i, i] for all i\
    \ is a palindrome as well;\n    # and s[i, j] is a palindrome if and only if s[i\
    \ + 1, j - 1] is a palindrome and s[i] == s[j].\n    #\n    # So, we can make\
    \ the following solution:\n    #\n    # Build a table s[i, j] that tells if string\
    \ s[i:j] is a palindrome\n    #\n    # s[i, j] = TRUE if i == j\n    # or s[i\
    \ + 1, j - 1] is a palindrome and s[i] == s[j].\n    #\n    # We can fill this\
    \ table starting from the diagonal (i == j) and move to bottom-right corner.\n\
    \    #   s[i, j] = s[i + 1, j - 1] and s[i] == s[j]\n    #\n    # Then we can\
    \ reverse string s[1:j] and append it to the end of s[j + 1:n].\n    #\n    #\
    \ Complexity: O(n^2).\n    if (string == '') return ''\n    len <- nchar(string)\n\
    \    s <- matrix(nrow = len, ncol = len)\n    for (i in 1:len) {\n        s[i,\
    \ i] <- TRUE\n    }\n    for (i in 1:(len - 1)) {\n        if (string[i] == string[i\
    \ + 1]) s[i, i + 1]", "\n    length <- nchar(string)\n    for (i in seq(length,\
    \ 0, -1)) {\n        if (is_palindrome(substr(string, i + 1, length))) {\n   \
    \         return(c(string, string[seq(i, 0, -1)]))\n        }\n    }\n    return(c(string,\
    \ ''))\n}\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n",
  "\n  if (is.null(string) || is.na(string) || string == '') return('')\n  if (string\
    \ == 'a') return(string)\n  prefix <- substr(string, 1, floor(nchar(string) /\
    \ 2))\n  if (suffix <- detect_palindrome(string)) {\n    return(paste(string,\
    \ substr(string, 1, nchar(prefix) - nchar(suffix)), sep = ''))\n  }\n  return(paste(string,\
    \ rev(prefix), sep = ''))\n}\n", "\n  if (is.na(string) || nchar(string) == 0)\
    \ {\n    return('')\n  }\n\n  suffix <- substr(string, 1, nchar(string))\n  while\
    \ (suffix != '') {\n    prefix <- substr(string, nchar(suffix) + 1, nchar(string))\n\
    \    if (suffix == prefix) {\n      # Substring is already a palindrome\n    \
    \  return(string)\n    }\n    suffix <- substr(suffix, 1, nchar(suffix) - 1)\n\
    \  }\n\n  return(paste(string, rev(substr(string, 1, nchar(string) - 1)), sep\
    \ = ''))\n}\n\nmake_palindrome('cat')\nmake_palindrome('cata')\n", "\n  if (string\
    \ == '') {\n    return('')\n  }\n  palindrome_suffix <- longest_palindrome_suffix(string)\n\
    \  prefix <- substr(string, 1, nchar(string) - nchar(palindrome_suffix))\n  return(paste(string,\
    \ rev(prefix), sep = ''))\n}\n", "\n  string <- string[string != '']\n  if (length(string)\
    \ == 0) return('')\n  string <- unlist(string)\n  string <- rev(string)\n  candidate\
    \ <- string\n  while (candidate == candidate[length(candidate):1]) {\n    candidate\
    \ <- candidate[-length(candidate)]\n  }\n  string <- string[(length(candidate)\
    \ + 1):length(string)]\n  candidate <- string\n  while (candidate == candidate[length(candidate):1])\
    \ {\n    candidate <- candidate[-length(candidate)]\n  }\n  string <- string[(length(candidate)\
    \ + 1):length(string)]\n  if (length(string) == 0) return(unlist(string))\n  rstring\
    \ <- rev(string)\n  return(paste(unlist(string), unlist(rstring), sep = ''))\n\
    }\n", "\n    l <- nchar(string)\n    # If a string is empty, just return it.\n\
    \    if (l == 0) {\n        return(string)\n    }\n    # If a string is of length\
    \ 1, just return it twice.\n    if (l == 1) {\n        return(paste(string, string,\
    \ sep = ''))\n    }\n    # Find a longest palindromic suffix.\n    suffix <- string\n\
    \    while (suffix != '') {\n        if (is_palindrome(suffix)) {\n          \
    \  break\n        }\n        suffix <- suffix[-1]\n    }\n    return(paste(string,\
    \ paste(rev(suffix), collapse = ''), sep = ''))\n}\n", "\n  if(nchar(string) ==\
    \ 0) {\n    return(string)\n  }\n  string_suffix <- string\n  while(string_suffix\
    \ != '') {\n    if(is_palindrome(string_suffix)) {\n      break\n    }\n    string_suffix\
    \ <- substr(string_suffix, 2, nchar(string_suffix))\n  }\n  return(paste(string,\
    \ string_suffix, sep = ''))\n}\n", "\n  stopifnot(is.character(string))\n  if\
    \ (is.na(string))\n    return(NA)\n  if (nchar(string) < 2)\n    return(string)\n\
    \  # This is the longest palindromic suffix of a string.\n  longest_palindromic_suffix\
    \ <- function(string) {\n    stopifnot(is.character(string))\n    if (is.na(string))\n\
    \      return(NA)\n    if (nchar(string) < 2)\n      return('')\n    # Make a\
    \ reversed string.\n    reversed_string <- stringi::stri_reverse(string)\n   \
    \ # Find the longest common suffix of a string and its reverse.\n    stringi::stri_match_last_regex(string,\
    \ stri_c(stringi::stri_reverse(string), collapse=''))[[1]]\n  }\n  # This is the\
    \ longest palindromic prefix of a string.\n  longest_palindromic_prefix <- function(string)\
    \ {\n    stopifnot(is.character(string))\n    if (is.na(string))\n      return(NA)\n\
    \    if (nchar(string) < 2)\n      return('')\n    # Make a reversed string.\n\
    \    reversed_string <- stringi::stri_reverse(string)\n    # Find the longest\
    \ common prefix of a string and its reverse.\n    stringi::stri_match_first_regex(string,\
    \ stri_c(stringi::stri_reverse(string), collapse=''))[[1]]\n  }\n  if (length(longest_palindromic_suffix(string))\
    \ == nchar(string))\n    return(string)\n  # Build a palindrome.\n  string %>%\
    \ stri_c(stringi::stri_reverse(stringi::stri_sub(string, nchar(longest_palindromic_suffix(string))\
    \ + 1)), collapse='')\n}\n", "\n  l <- nchar(string)\n  if (l < 2) {\n    return(string)\n\
    \  }\n  max_half_length <- ifelse(l %% 2 == 0, l / 2, (l - 1) / 2)\n  # Find the\
    \ longest palindromic suffix.\n  for (half_length in 0:max_half_length) {\n  \
    \  is_palindrome <- TRUE\n    for (i in 1:half_length) {\n      if (substr(string,\
    \ l - i + 1, l - i + 1) != substr(string, half_length - i + 1, half_length - i\
    \ + 1)) {\n        is_palindrome <- FALSE\n        break\n      }\n    }\n   \
    \ if (is_palindrome) {\n      break\n    }\n  }\n  # Concatenate the string to\
    \ palindromic suffix.\n  paste(string, paste(rev(substr(string, 1, half_length)),\
    \ collapse = ''), sep = '')\n}\n", "\n  if (nchar(string) == 0) return(string)\n\
    \  # find the longest postfix that is a palindrome\n  n <- nchar(string)\n  for\
    \ (i in (1:n)) {\n    if (is_palindrome(substr(string, n - i + 1, n))) break\n\
    \  }\n  # append reverse of the prefix to the string\n  return(paste(string, rev(substr(string,\
    \ 1, n - i)), sep = ''))\n}\n", "\n    return( paste(string, string[rev(seq_along(string))[!string\
    \ %in% rev(string)], drop=FALSE], sep=\"\"))\n}\nmake_palindrome('')\nmake_palindrome('cat')\n\
    make_palindrome('cata')\n", "\n    if (length(string) == 0) {\n        return(string)\n\
    \    }\n    len <- length(string)\n    string <- as.character(string)\n    for\
    \ (i in 1:len) {\n        if (string[1:i] == string[(len - i + 1):len]) {\n  \
    \          return(c(string, string[(len - i + 1):len]))\n        }\n    }\n  \
    \  return(NA)\n}\n", "\n  stopifnot(is.character(string))\n  if (identical(string,\
    \ '')) return('')\n  string = trimws(string)\n  # Find the longest postfix of\
    \ supplied string that is a palindrome.\n  i = (string_length(string) + 1) / 2\n\
    \  while (i > 0 && !is_palindrome(string, i, string_length(string))) i = i - 1\n\
    \  # Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n  string = paste0(string, string_reverse(string[1:(i\
    \ - 1)]))\n  return(string)\n}\n", "\n  if (nchar(string) < 2) {\n    return(string)\n\
    \  }\n  for (i in 1:ceiling(nchar(string)/2)) {\n    if (substr(string, i, i +\
    \ 1) == rev(substr(string, i, i + 1))) {\n      pass <- TRUE\n    } else {\n \
    \     pass <- FALSE\n      break\n    }\n  }\n  if (pass) {\n    return(string)\n\
    \  }\n  suffix <- rev(string)\n  suffix <- substr(suffix, 2, nchar(suffix))\n\
    \  return(paste(string, suffix, sep = ''))\n}\n", "\n  pal_suffix <- longest_palindrome_postfix(string)\n\
    \  prefix <- substr(string, 1, nchar(string) - nchar(pal_suffix))\n  return(paste(string,\
    \ strrev(prefix), sep=''))\n}\n", "\n    return(c(string, rev(string[1:(nchar(string)\
    \ - longest_palindrome_postfix(string))])))\n}\n", "\n  if (nchar(string) == 0)\
    \ {\n    return(string)\n  }\n\n  string_rev <- substr(string, 1, -1)\n  suffix\
    \ <- string\n  res <- substr(string, 1, 1)\n\n  for (i in seq(nchar(string_rev),\
    \ 1, -1)) {\n    pattern <- substr(string_rev, i, nchar(string_rev))\n    if (grepl(pattern,\
    \ suffix)) {\n      res <- c(res, paste(pattern, sep = ''))\n      break\n   \
    \ }\n  }\n\n  paste(res, collapse = '')\n}", "\n\tif (nchar(string) == 0) {\n\t\
    \treturn (string)\n\t}\n\n\tpalindrome_suffix <- longest_palindrome_suffix(string)\n\
    \tif (nchar(palindrome_suffix) == nchar(string)) {\n\t\treturn (string)\n\t}\n\
    \n\tstring_prefix <- substr(string, 1, nchar(string) - nchar(palindrome_suffix))\n\
    \treturn (paste(string, stringr::str_reverse(string_prefix), sep = ''))\n}\n",
  "\n  ind <- longest_palindrome_suffix(string)\n  suffix <- substr(string, 1, ind)\n\
    \  prefix <- gsub('.', '&', suffix)\n  prefix <- gsub('&', '\\\\1', prefix)\n\
    \  prefix <- gsub('1', '', prefix)\n  return(paste(string, prefix, sep = ''))\n\
    }\n", "\n  if (is.na(string) || length(string) == 0) {\n    stop('The supplied\
    \ string must be a nonempty character vector.')\n  }\n\n  string <- as.character(string)\n\
    \n  if (is.na(string) || length(string) == 0) {\n    return('')\n  }\n\n  string_length\
    \ <- nchar(string)\n  string_length_half <- string_length / 2\n  string_length_half_floor\
    \ <- floor(string_length_half)\n\n  string_left <- substr(string, 1, string_length_half_floor)\n\
    \  string_right <- substr(string, string_length_half_floor + 1, string_length)\n\
    \n  string_right_reverse <- rev(string_right)\n\n  if (string_right_reverse ==\
    \ string_left) {\n    return(string)\n  }\n\n  string_middle <- ''\n  found_palindrome\
    \ <- FALSE\n\n  for (i in (1:(string_length_half_floor))) {\n    string_left_prefix\
    \ <- substr(string_left, 1, string_length_half_floor - i)\n    string_right_suffix\
    \ <- substr(string_right, i + 1, string_length_half_floor)\n\n    if (string_left_prefix\
    \ == string_right_suffix) {\n      string_middle <- substr(string_right, 1, i)\n\
    \      found_palindrome <- TRUE\n      break\n    }\n  }\n\n  if (!found_palindrome)\
    \ {\n    string_middle <- string_right\n  }\n\n  string_right_reverse <- rev(string_middle)\n\
    \n  return(paste(string, string_right_reverse, sep = ''))\n}\n", "\n\tif (length(string)\
    \ == 0) return(string)\n\t# +1 to skip the last letter of a string; it is used\
    \ in a palindrome check\n\tstring_len <- length(string) + 1\n\tpalindrome_start\
    \ <- 0\n\tpalindrome_len <- 1\n\t# The palindrome check is fast in this direction\
    \ because a previous letter of a palindrome cannot become a new one\n\t# when\
    \ we add another letter.\n\t#\n\t# We also know that we will not find a palindrome\
    \ longer than half the string length and can stop our search then.\n\t# (a \"\
    dumb\" palindrome check with palindrome_len + 2 is used to allow the program to\
    \ stop just after reaching the\n\t# palindrome with len == half_string_len)\n\t\
    half_string_len <- string_len %/% 2\n\tfor (cur_palindrome_len in 2:half_string_len)\
    \ {\n\t\t# Here we get all offsets for the substring of length cur_palindrome_len.\
    \ The last element is\n\t\t# string_len - cur_palindrome_len - 1.\n\t\tpalindrome_offset\
    \ <- 0:(string_len - cur_palindrome_len - 1)\n\t\t# If the substring is palindrome,\
    \ we update the longest palindrome found and stop searching if we already\n\t\t\
    # reached half the string length.\n\t\tif (\n\t\t\tstring[\n\t\t\t\t# Here we\
    \ get the first and last letters of the substring with given length.\n\t\t\t\t\
    palindrome_offset + cur_palindrome_len\n\t\t\t] == string[\n\t\t\t\t# In order\
    \ to reverse the indexing order, we subtract the index from string_len - 1.\n\t\
    \t\t\tstring_len - 1 - palindrome_offset\n\t\t\t]\n\t\t) {\n\t\t\tpalindrome_start\
    \ <- palindrome_offset[1]\n\t\t\tpalindrome_len <- cur_palindrome_len\n\t\t\t\
    if (palindrome_len == half_string_len) break\n\t\t}\n\t}\n\tstring[palindrome_start\
    \ + (1:", "\n    # Strip the string of non-alphanumeric characters.\n    s <-\
    \ stringr::str_replace_all(string, \"[^[:alnum:]]\", \"\")\n    # If string contains\
    \ nothing, return it.\n    if (nchar(s) == 0) {\n        return(s)\n    }\n  \
    \  # Find the longest palindromic suffix.\n    ps <- sapply(seq_len(nchar(s)),\
    \ function(i) stringr::str_sub(s, 1, i) %>% is_palindrome())\n    # Find the length\
    \ of the longest palindromic suffix.\n    pl <- stringr::str_length(s[ps])\n \
    \   # Extract the prefix of the string that comes before the palindromic suffix.\n\
    \    p <- stringr::str_sub(s, 1, nchar(s) - pl)\n    # Reverse the prefix, append\
    \ it to the end of the string, then return the result.\n    return(paste0(s, stringr::str_reverse(p)))\n\
    }\n", "\n    # Find the longest palindromic substring starting at the beginning\
    \ of the string.\n    # We will call the string prefix, i.e. the substring preceding\
    \ the palindromic substring.\n    prefix <- ''\n    max_length <- floor(nchar(string)\
    \ / 2)\n    for (i in seq(1, max_length)) {\n        sub <- substr(string, i,\
    \ nchar(string))\n        length <- i\n        if (sub == rev(sub)) {\n      \
    \      prefix <- substr(string, 1, i)\n        }\n    }\n    # Return the string,\
    \ appended by reversed prefix.\n    return(paste(string, rev(prefix), sep = ''))\n\
    }\nmake_palindrome('cat')\nmake_palindrome('cata')\n", "\n  if (length(string)\
    \ < 2) return(string)\n  for (i in seq(length(string), 2, -1)) {\n    if (identical(string[1:i],\
    \ rev(string[1:i]))) {\n      return(c(string, rev(string[-(1:i)])))\n    }\n\
    \  }\n  return(string)\n}", "\n    if (string == '') return('')\n    rev_string\
    \ <- paste(rev(unlist(strsplit(string, \"\"))), collapse = \"\")\n    while (substr(string,\
    \ 1, nchar(string) - 1) != rev_string) {\n        string <- paste(substr(string,\
    \ 1, nchar(string) - 1), collapse = \"\")\n        rev_string <- paste(rev(unlist(strsplit(string,\
    \ \"\"))), collapse = \"\")\n    }\n    paste(string, rev_string, sep = \"\")\n\
    }\n", "\n  if (nchar(string) == 0) return(string)\n  # find position of the longest\
    \ palindromic suffix\n  suffix <- longest_palindromic_suffix(string)\n  return(paste(string,\
    \ paste(string[1:(nchar(string) - suffix)], collapse = ''), sep = ''))\n}\n",
  "\n    if (nchar(string) <= 1) return(string)\n    i <- nchar(string)\n    while\
    \ (i >= 1) {\n        if (substr(string, 0, i) == substr(string, i + 1, 2 * i))\
    \ break\n        i <- i - 1\n    }\n    return(paste(string, substr(string, 1,\
    \ i), sep = ''))\n}\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n",
  "\n  reverse <- function(text) {\n    ans <- character(nchar(text))\n    for (i\
    \ in seq_along(text)) {\n      ans[i] <- substr(text, nchar(text) - i + 1, nchar(text)\
    \ - i + 1)\n    }\n    return(paste(ans, collapse=''))\n  }\n  if (is.na(string)\
    \ || string == '') {\n    return('')\n  }\n  for (i in seq_len(nchar(string)))\
    \ {\n    if (substr(string, 1, i) == reverse(substr(string, nchar(string) - i\
    \ + 1, nchar(string)))) {\n      return(paste(string, reverse(substr(string, 1,\
    \ nchar(string) - i)), sep=''))\n    }\n  }\n  return(paste(string, reverse(string),\
    \ sep=''))\n}\n ", "\n  # Find the longest postfix that is a palindrome (possible\
    \ empty string)\n  palindrome_postfix <- longest_palindrome_postfix(string)\n\
    \  # Reverse the remaining part of the string (possible empty string)\n  remaining_part\
    \ <- rev(string[1L:(nchar(string) - nchar(palindrome_postfix))])\n  # Append the\
    \ remaining part to the end of the string\n  string_with_postfix <- paste0(string,\
    \ remaining_part)\n  # Return the string\n  return(string_with_postfix)\n}\n",
  "\n    max_palindrome_len <- 1\n    max_palindrome_idx <- 1\n    max_palindrome_idx_half\
    \ <- 1\n    string_len <- nchar(string)\n    string_len_half <- as.integer(string_len\
    \ / 2)\n    if (string_len > 0) {\n        for (i in 1:string_len_half) {\n  \
    \          if (string[i] == string[string_len - i + 1]) {\n                palindrome_len\
    \ <- 1\n                for (j in 1:i) {\n                    if (string[i - j\
    \ + 1] == string[string_len - i + j]) {\n                        palindrome_len\
    \ <- palindrome_len + 1\n                    } else {\n                      \
    \  break\n                    }\n                }\n                if (palindrome_len\
    \ > max_palindrome_len) {\n                    max_palindrome_len <- palindrome_len\n\
    \                    max_palindrome_idx <- i\n                    max_palindrome_idx_half\
    \ <- as.integer(palindrome_len / 2)\n                }\n            }\n      \
    \  }\n    }\n    substr(string, 1, max_palindrome_idx_half) %>% paste(., reverse(.),\
    \ sep = '')\n}\n", "\n    if (is.null(string) || nchar(string) < 2) return(string)\n\
    \    left <- string\n    right <- rev(string)\n    while (nchar(left) > 0) {\n\
    \        if (left == right) break\n        left <- substring(left, 2)\n      \
    \  right <- substring(right, 1, nchar(right) - 1)\n    }\n    sprintf('%s%s',\
    \ string, rev(substring(string, 1, nchar(string) - nchar(left))))\n}\nmake_palindrome('')\n\
    make_palindrome('cat')\nmake_palindrome('cata')\n", "\n    longest_palindrome\
    \ <- function(string) {\n        longest_palindrome_len <- c(0)\n        for (i\
    \ in seq(nchar(string))) {\n            for (j in c(1, 2)) {\n               \
    \ # Check for a substring that is a palindrome.\n                start <- i -\
    \ j + 1\n                end <- i\n                if (start > 0 && substr(string,\
    \ start, end) == rev(substr(string, start, end))) {\n                    # If\
    \ this substring is the longest so far, update the\n                    # length.\n\
    \                    if (end - start + 1 > longest_palindrome_len) {\n       \
    \                 longest_palindrome_len <<- end - start + 1\n               \
    \     }\n                }\n            }\n        }\n        return(longest_palindrome_len)\n\
    \    }\n    # Find the longest palindrome at the end of the string.\n    palindrome_len\
    \ <- longest_palindrome(string)\n    # Return the string with appended reverse\
    \ of the prefix not including\n    # the palindrome (if any).\n    return(paste(string,\
    \ rev(substr(string, 1, nchar(string) - palindrome_len)), sep = ''))\n}\nmake_palindrome('')\n\
    make_palindrome('cat')\nmake_palindrome('cata')\n", "\n  return(paste(string,\
    \ rev(substr(string, 1, nchar(string) - find_palindrome_length(string))), sep=''))\n\
    }\n", "\n    if (nchar(string) == 0) {\n        return(string)\n    }\n    string_length\
    \ <- nchar(string)\n    is_palindrome <- function(offset, length) {\n        string[offset:(offset\
    \ + length - 1)] == rev(string[(offset + length):string_length])\n    }\n    palindrome_length\
    \ <- string_length\n    for (i in 1:(string_length - 1)) {\n        if (is_palindrome(i,\
    \ string_length - i + 1)) {\n            palindrome_length <- i\n            break\n\
    \        }\n    }\n    paste(string, rev(string[1:(string_length - palindrome_length)]),\
    \ sep = '')\n}\n ", "\n  if (nchar(string) == 0) return(string)\n  reversed_string\
    \ <- rev(string)\n  prefix <- substr(string, 1, nchar(string) - nchar(reversed_string))\n\
    \  return(paste(string, prefix, sep=''))\n}", "\n  i <- nchar(string)\n  while\
    \ (i > 0) {\n    if (is_palindrome(substr(string, 1, i))) {\n      break\n   \
    \ }\n    i <- i - 1\n  }\n  if (i == 0) {\n    return(string)\n  }\n  return(paste(string,\
    \ rev(substr(string, 1, nchar(string) - i)), sep = ''))\n}\n", "\n    # Find the\
    \ longest palindromic suffix.\n    longest_palindromic_suffix <- function(string)\
    \ {\n        n <- nchar(string)\n        for (i in seq(n, 0, -1)) {\n        \
    \    prefix <- substr(string, 1, i)\n            if (is_palindrome(prefix)) {\n\
    \                return(prefix)\n            }\n        }\n        return('')\n\
    \    }\n    prefix <- substr(string, 1, nchar(string) - nchar(longest_palindromic_suffix(string)))\n\
    \    return(paste(string, rev(prefix), sep = ''))\n}\n", "\n    if (is.null(string)\
    \ || string == '') {\n        return('')\n    }\n    else {\n        # Find the\
    \ longest palindromic suffix:\n        len <- length(string)\n        max_len\
    \ <- 0\n        max_idx <- 0\n        for (i in seq(1, len)) {\n            suffix\
    \ <- substr(string, len - i + 1, len)\n            prefix <- substr(string, 1,\
    \ i)\n            if (suffix == prefix) {\n                max_len <- i\n    \
    \            max_idx <- len - i + 1\n            }\n        }\n        suffix\
    \ <- substr(string, max_idx, len)\n        prefix <- substr(string, 1, max_len)\n\
    \        rev_prefix <- sapply(seq(1, max_len), function(i) substr(prefix, max_len\
    \ - i + 1, max_len))\n        return(paste(suffix, rev_prefix, sep = ''))\n  \
    \  }\n}\n\ncat('make_palindrome\\n')\nassert_equals(make_palindrome(''), '')\n\
    assert_equals(make_palindrome('cat'), 'catac')\nassert_equals(make_palindrome('cata'),\
    \ 'catac')\nassert_equals(make_palindrome('catac'), 'catac')\nassert_equals(make_palindrome('catat'),\
    \ 'catatac')\nassert_equals(make_palindrome('catata'), 'catata')\nassert_equals(make_palindrome('catatat'),\
    \ 'catatatac')\n", "\n  if(!is.character(string))\n    stop('Input is not a string.')\n\
    \  if(length(string) == 0)\n    return(string)\n  string <- unlist(strsplit(string,\
    \ ''))\n  is_palindrome <- function(string) {\n    string <- paste(string, collapse\
    \ = '')\n    string == rev(string)\n  }\n  len <- length(string)\n  for(i in 1:len)\
    \ {\n    if(is_palindrome(string[(i + 1):len])) {\n      return(paste(string,\
    \ rev(string[1:(i - 1)]), sep = ''))\n    }\n  }\n  return(paste(string, rev(string),\
    \ sep = ''))\n}\n", "\n  string <- stringr::str_trim(string)\n  if (nchar(string)\
    \ <= 1) return(string)\n  if (stringr::str_sub(string, end = -1) == stringr::str_sub(string,\
    \ start = 2)) return(string)\n  lng <- stringr::str_length(string)\n  substr <-\
    \ stringr::str_sub(string, end = -1)\n  while (lng > 1) {\n    palindrome <- substr\
    \ == stringr::str_sub(string, start = lng)\n    if (palindrome) break\n    substr\
    \ <- stringr::str_sub(substr, end = -1)\n    lng <- lng - 1\n  }\n  if (lng >\
    \ 1) string <- stringr::str_c(string, stringr::str_sub(string, end = lng - 1))\n\
    \  string\n}\n", "\n    new_string <- string\n    if(all(string != '')) {\n  \
    \      suffix <- string\n        while(!is_palindrome(suffix)) {\n           \
    \ suffix <- substr(suffix, 2, nchar(suffix))\n        }\n        prefix <- substr(string,\
    \ 1, nchar(string) - nchar(suffix))\n        new_string <- paste(string,\n   \
    \                         substr(prefix, nchar(prefix):1, nchar(prefix)),\n  \
    \                          sep = '')\n    }\n    return(new_string)\n}\n ", "\n\
    \  if(nchar(string) == 0) {\n    return(string)\n  }\n  if(is_palindrome(string))\
    \ {\n    return(string)\n  }\n  largest_palindrome_suffix <- function(string)\
    \ {\n    for(i in 0:(nchar(string) - 1)) {\n      if(is_palindrome(substr(string,\
    \ i + 1, nchar(string)))) {\n        return(substr(string, i + 1, nchar(string)))\n\
    \      }\n    }\n  }\n  return(string %+% largest_palindrome_suffix(string) %+%\
    \ substr(string, 1, nchar(string) - nchar(largest_palindrome_suffix(string))))\n\
    }\n", "\n    if (length(string) == 0) {\n        return(string)\n    }\n    longest_palindrome\
    \ <- find_longest_palindrome(string)\n    prefix <- substr(string, 1, length(string)\
    \ - length(longest_palindrome))\n    paste(string, paste(rev(prefix), collapse=''),\
    \ sep='')\n}\n", "\n  if (nchar(string) == 0) {\n    return(string)\n  }\n  longest_palindrome_suffix\
    \ <- find_longest_palindrome_suffix(string)\n  prefix <- substr(string, 1, nchar(string)\
    \ - nchar(longest_palindrome_suffix))\n  paste(string, paste(rev(prefix), collapse\
    \ = ''), sep = '')\n}\n", "\n  end <- length(string)\n  i <- 1\n  # find longest\
    \ palindromic postfix\n  while (i <= end) {\n    if (string[i] == string[end])\
    \ {\n      end <- end - 1\n      i <- i + 1\n    } else {\n      end <- length(string)\n\
    \      i <- i + 1\n    }\n  }\n  # return a concatenation of reverse of string\
    \ prefix and original string\n  paste(rev(string[1:end]), string, sep='')\n}\n\
    sapply(c('', 'cat', 'cata'), make_palindrome)\n", "\n  string_reverse <- function(string)\
    \ {\n    rev(string)\n  }\n  string_length <- nchar(string)\n  if (string_length\
    \ == 0) {\n    return(string)\n  }\n  is_palindrome <- function(string) {\n  \
    \  string == string_reverse(string)\n  }\n  has_symmetric_part <- function(string)\
    \ {\n    lapply(seq(string_length), function(i) {\n      is_palindrome(substr(string,\
    \ 1, i))\n    })\n  }\n  longest_palindrome_suffix <- which(has_symmetric_part(string))[1]\n\
    \  prefix <- substr(string, 1, longest_palindrome_suffix - 1)\n  return(paste(string,\
    \ string_reverse(prefix), sep = ''))\n}\nassert.Equal(''               , make_palindrome(''\
    \               ))\nassert.Equal('catac'          , make_palindrome('cat'    \
    \        ))\nassert.Equal('catac'          , make_palindrome('cata'          \
    \ ))\nassert.Equal('catac'          , make_palindrome('catac'          ))\nassert.Equal('abcdeedcba'\
    \     , make_palindrome('abcdeedc'       ))\nassert.Equal('abcdeedcba'     , make_palindrome('abcdeedcb'\
    \      ))\nassert.Equal('abcdeedcba'     , make_palindrome('abcdeedcba'     ))\n\
    assert.Equal('abcdeedcbadcba' , make_palindrome('abcdeedcbadcb'  ))\nassert.Equal('abcdeedcbadcba'\
    \ , make_palindrome('abcdeedcbadcba' ))\nassert.Equal('abcdefghijjjihgfedcba'\
    \ , make_palindrome('abcdefghijjjihgfedcb'  ))\nassert.Equal('abcdefghijjjihgfedcba'\
    \ , make_palindrome('abcdefghijjjihgfedcba' ))\nassert.Equal('abcdefghijjjihgfedcba",
  "\n  if (nchar(string) == 0) return(string)\n\n  i <- nchar(string)\n  j <- 1\n\
    \  is_palindrome <- FALSE\n  while (!is_palindrome && i >= j) {\n    is_palindrome\
    \ <- string[j:(i)] == rev(string[j:(i)])\n    i <- i - 1\n  }\n\n  return(paste(string,\
    \ rev(string[1:(nchar(string) - i - 1)]), sep=''))\n}", "\n  begin_string <- paste(string,\
    \ collapse = '')\n  begin_string_length <- nchar(begin_string)\n  longest_possible_palindrome_length\
    \ <- 2 * begin_string_length - 1\n  for (i in seq(from = longest_possible_palindrome_length,\
    \ to = 0, by = -1)) {\n    if (i %% 2 == 0) {\n      compare_index <- ceiling(i\
    \ / 2)\n      if (strsplit(begin_string, '')[[1]][1:compare_index] == strsplit(begin_string,\
    \ '')[[1]][compare_index:i]) {\n        end_string <- strsplit(begin_string, '')[[1]][(compare_index\
    \ + 1):begin_string_length]\n        return(paste(begin_string, paste(end_string,\
    \ collapse = ''), sep = ''))\n      }\n    } else {\n      compare_index <- ceiling(i\
    \ / 2)\n      if (strsplit(begin_string, '')[[1]][1:compare_index] == strsplit(begin_string,\
    \ '')[[1]][(compare_index + 1):i]) {\n        end_string <- strsplit(begin_string,\
    \ '')[[1]][(compare_index + 1):begin_string_length]\n        return(paste(begin_string,\
    \ paste(end_string, collapse = ''), sep = ''))\n      }\n    }\n  }\n  return(begin_string)\n\
    }\nmake_palindrome('cat')\n", "\n  if (length(string) == 0) {\n    return(string)\n\
    \  }\n  reversed_string <- paste(rev(string), collapse='')\n  longest_common_substring\
    \ <- LCS(string, reversed_string)\n  prefix <- substr(string, 1, nchar(string)\
    \ - nchar(longest_common_substring))\n  return(paste(string, prefix, sep=''))\n\
    }\n\nexample <- paste(sample(LETTERS, 10), collapse='')\nprint(make_palindrome(example))\n",
  "\n  if (nchar(string) == 0) return(string)\n  if (nchar(string) == 1) return(paste(string,\
    \ string, sep = ''))\n  is_palindrome <- function(string) {\n    return(string\
    \ == rev(string))\n  }\n  for (i in seq(nchar(string), 1, -1)) {\n    sub <- substr(string,\
    \ nchar(string) - i + 1, nchar(string))\n    if (is_palindrome(sub)) {\n     \
    \ return(paste(string, rev(substr(string, 1, nchar(string) - i)), sep = ''))\n\
    \    }\n  }\n}\n", "\n  palindrome_suffix <- function(string) {\n    if (nchar(string)\
    \ <= 1) {\n      string\n    } else {\n      longest_palindrome <- palindrome_suffix(string[-nchar(string)])\n\
    \      if (string[nchar(string)] == string[1]) {\n        palindrome <- string[1]\n\
    \        string_suffix <- string[-1]\n        while (grepl(paste0(palindrome,\
    \ collapse = ''), string_suffix)) {\n          palindrome <- paste0(palindrome,\
    \ string[1])\n          string_suffix <- string_suffix[-1]\n        }\n      \
    \  palindrome\n      } else {\n        longest_palindrome\n      }\n    }\n  }\n\
    \  paste0(string, rev(string[-seq(nchar(palindrome_suffix(string)))]))\n}\n",
  "\n  string <- strsplit(string, NULL)[[1]]\n  if (length(string) == 0) {\n    return('')\n\
    \  }\n  if (length(string) == 1) {\n    return(string)\n  }\n  palindrome_suffix\
    \ <- get_longest_palindrome_suffix(string)\n  prefix <- string[1:length(string)\
    \ - length(palindrome_suffix)]\n  prefix <- rev(prefix)\n  return(paste(string,\
    \ prefix, sep = ''))\n}\nmake_palindrome('cat')\nmake_palindrome('cata')\nmake_palindrome('a')\n\
    make_palindrome('ab')\nmake_palindrome('abc')\nmake_palindrome('abba')\nmake_palindrome('abbbab')\n\
    make_palindrome('abbbabb')\n", "\n\tif (nchar(string) == 0) return(string)\n\t\
    # Find the longest palindromic suffix of the string.\n\tk <- 1\n\tpal_suffix <-\
    \ substr(string, k, nchar(string))\n\twhile (FALSE == (pal_suffix == reverse(pal_suffix)))\
    \ {\n\t\tk <- k + 1\n\t\tpal_suffix <- substr(string, k, nchar(string))\n\t}\n\
    \t# Create prefix of the string up to the palindromic suffix.\n\tpref <- substr(string,\
    \ 1, k - 1)\n\trev_pref <- reverse(pref)\n\treturn(paste(string, rev_pref, sep\
    \ = ''))\n}\nmake_palindrome('cata')\n", "\n  string_len <- nchar(string)\n  longest_palindrome_suffix\
    \ <- find_longest_palindrome_suffix(string)\n  return(paste(string, substr(string,\
    \ start = 0, stop = string_len - nchar(longest_palindrome_suffix)), sep = ''))\n\
    }\n\nfind_longest_palindrome_suffix <- function(string) {\n  string_len <- nchar(string)\n\
    \  if (string_len == 0) {\n    return('')\n  }\n  if (string_len == 1) {\n   \
    \ return(string)\n  }\n  if (substr(string, 1, 1) == substr(string, string_len,\
    \ string_len)) {\n    return(paste(substr(string, 1, 1), find_longest_palindrome_suffix(substr(string,\
    \ 2, string_len - 1)), sep = ''))\n  }\n  return('')\n}\n", "\n  string <- strsplit(string,\
    \ split = \"\")[[1]]\n  reversed_string <- rev(string)\n  ## Find the longest\
    \ postfix of the string that is a palindrome.\n  if (string == reversed_string)\
    \ {\n    return(string)\n  }\n  palindrome_suffix <- integer(length(string))\n\
    \  for (i in seq_along(string)) {\n    if (string[i] == reversed_string[1]) {\n\
    \      palindrome_suffix[i] <- 1\n    } else {\n      palindrome_suffix[i] <-\
    \ 0\n    }\n  }\n  (p <- max(cumsum(palindrome_suffix)))\n  ## Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \  c(string, rev(string[1:(length(string) - p)]))\n}\n", "\n    if (nchar(string)\
    \ == 0) {\n        return(string)\n    }\n    is_palindrome <- function(string)\
    \ {\n        return(string == rev(string))\n    }\n    rev_string <- function(string)\
    \ {\n        return(rev(string))\n    }\n    chars <- strsplit(string, '')[[1]]\n\
    \    prefix <- ''\n    suffix <- chars\n    while (!is_palindrome(suffix)) {\n\
    \        prefix <- paste(prefix, suffix[1], sep='')\n        suffix <- suffix[-1]\n\
    \    }\n    #print(paste('prefix:', prefix, 'suffix:', suffix, sep=' '))\n   \
    \ return(paste(string, rev_string(prefix), sep=''))\n}", "\n  if (nchar(string)\
    \ == 0) {\n    return(string)\n  }\n  suffix_size <- longest_palindrome_size(string)\n\
    \  prefix <- substring(string, 1, nchar(string) - suffix_size)\n  paste(string,\
    \ rev(prefix), sep = '')\n}\n", "\n  string <- stringr::str_extract(string, \"\
    .*cata.*\")\n  prefix <- stringr::str_sub(string, 1, -6)\n  suffix <- stringr::str_sub(string,\
    \ 6)\n  paste0(string, stringr::str_reverse(prefix))\n}", "\n  longest_palindrome\
    \ <- function(string) {\n    if (string == '') {\n      return ('')\n    } else\
    \ {\n      first_char <- substr(string, 1, 1)\n      rest <- substr(string, 2,\
    \ nchar(string))\n      if (first_char == rest) {\n        return (string)\n \
    \     } else {\n        return (longest_palindrome(rest))\n      }\n    }\n  }\n\
    \  prefix <- substring(string, 1, nchar(string) - nchar(longest_palindrome(string)))\n\
    \  return (paste(string, rev(prefix), sep = ''))\n}\nmake_palindrome('cata')\n",
  "\n  n <- nchar(string)\n  if (n == 0) return(string)\n  suffix <- lapply(seq(n,\
    \ 1, -1), function(x) substr(string, x, n))\n  palindromes <- which(suffix ==\
    \ sapply(suffix, rev))\n  longest_postfix <- substr(string, seq(n, palindromes[1],\
    \ -1), n)\n  substr(string, 1, n - nchar(longest_postfix)) %>% rev %>% append(string)\n\
    }\n", "\n  return(string)\n}\n", "\n    strlen <- nchar(string)\n    if (strlen\
    \ == 0) return(string)\n    n <- strlen\n    while (n > 0) {\n        if (is_palindrome(substr(string,1,n)))\
    \ {\n            break\n        }\n        n <- n - 1\n    }\n    return(paste(string,\
    \ rev(substr(string,1,n-1)), sep=''))\n}\n\nmake_palindrome('cat')\n", "\n  if\
    \ (nchar(string) == 0) {\n    return(string)\n  }\n  if (string == string[nchar(string):1])\
    \ {\n    return(string)\n  }\n  i <- nchar(string)\n  while (i > 0) {\n    if\
    \ (string[1:i] == string[i:1]) {\n      return(paste(string, string[(i+1):nchar(string)],\
    \ sep = ''))\n    }\n    i <- i - 1\n  }\n}", "\n  if (nchar(string) < 2) return(string)\n\
    \  palindrome_length <- find_palindrome_length(string)\n  paste0(string, string[1:((nchar(string)\
    \ - palindrome_length) - 1):-1])\n}\n\nfind_palindrome_length <- function(string)\
    \ {\n  n <- nchar(string)\n  m <- matrix(0, nrow = n, ncol = n)\n  for (l in 1:n)\
    \ {\n    for (i in 1:(n - l + 1)) {\n      j <- i + l - 1\n      if (string[i]\
    \ == string[j]) {\n        if (l == 1) m[i, j] <- 1\n        else if (l == 2)\
    \ m[i, j] <- 2\n        else m[i, j] <- m[i + 1, j - 1] + 2\n      } else {\n\
    \        m[i, j] <- max(m[i, j - 1], m[i + 1, j])\n      }\n    }\n  }\n  m[1,\
    \ n]\n}\n\nmake_palindrome('')\nmake_palindrome('cat')\nmake_palindrome('cata')\n\
    make_palindrome('catac')\n", "\n  # guard against empty string\n  if(length(string)==0)\
    \ {\n    return(string)\n  }\n  # find the longest palindromic suffix in the string.\n\
    \  longest_palindromic_suffix <- function(string) {\n    if(length(string)==1)\
    \ {\n      return(string)\n    }\n    i <- 0\n    # find the next i such that\
    \ string[i] == string[-i]\n    while(string[i+1]!=string[length(string)-i]) {\n\
    \      i <- i+1\n    }\n    i <- i+1\n    # return a string that starts from position\
    \ i in the string and ends at the end.\n    return(string[i:length(string)])\n\
    \  }\n  p <- longest_palindromic_suffix(string)\n  # return a concatenation of\
    \ the palindromic suffix, the reverse of the prefix that goes before the palindromic\
    \ suffix and the palindromic suffix again.\n  return(paste(p,rev(string[1:(length(string)-length(p))]),p,sep=''))\n\
    }\n", "\n    if (nchar(string) == 0) {\n        return(string)\n    }\n    longest_suffix\
    \ <- 0\n    for (i in (1:nchar(string))) {\n        substr(string, i, nchar(string))\n\
    \        if (substr(string, i, nchar(string)) == substr(string, i, nchar(string))\
    \ %>% rev() &&\n            nchar(substr(string, i, nchar(string))) > longest_suffix)\
    \ {\n            longest_suffix <- nchar(substr(string, i, nchar(string)))\n \
    \       }\n    }\n    return(paste(string, substr(string, 1, nchar(string) - longest_suffix)\
    \ %>% rev(), sep = ''))\n}", "\n  string_len <- nchar(string)\n  # If the string\
    \ is empty return an empty string.\n  if (string_len == 0) {\n    return('')\n\
    \  }\n  # Find the longest palindromic suffix of the string.\n  suffix_start <-\
    \ string_len\n  while (suffix_start > 0) {\n    if (is_palindrome(string[1:suffix_start]))\
    \ {\n      break\n    }\n    suffix_start <- suffix_start - 1\n  }\n  # Append\
    \ to the end of the string the reverse of a string prefix that comes before the\
    \ palindromic suffix.\n  return(paste(string,\n               string[1:(string_len\
    \ - suffix_start)],\n               sep = ''))\n}\n", "\n    longest_postfix <-\
    \ longest_postfix_palindrome(string)\n    prefix <- substr(string, 1, nchar(string)\
    \ - nchar(longest_postfix))\n    string <- paste(string, paste(strsplit(prefix,\
    \ '')[[1]], collapse=''), sep='')\n    return(string)\n}", "\n  substring <- substr(string,\
    \ rev(seq_along(string)), seq_along(string))\n  suffix <- find_longest_palindrome(substring)\n\
    \  prefix <- substr(string, length(suffix) + 1, length(string))\n  cat(string,\
    \ rev(prefix), sep='')\n}\n", "\n    if (nchar(string) == 0) {\n        return(string)\n\
    \    }\n\n    length <- nchar(string)\n    for (i in length:1) {\n        if (is_palindrome(substr(string,\
    \ i, length))) {\n            return(paste(string, rev(substr(string, 1, i - 1)),\
    \ sep=''))\n        }\n    }\n}\n\nmake_palindrome('cata')\n", "\n    # Initialize\
    \ KMP table\n    kmp_table <- vector(mode = 'integer', length = length(string))\n\
    \    kmp_table[1] <- 0\n    kmp_table[2] <- 0\n    for (i in 3:length(string))\
    \ {\n        prefix_len <- kmp_table[i - 1]\n        while (prefix_len > 0 &&\
    \ string[prefix_len + 1] != string[i]) {\n            prefix_len <- kmp_table[prefix_len]\n\
    \        }\n        if (string[prefix_len + 1] == string[i]) {\n            kmp_table[i]\
    \ <- prefix_len + 1\n        } else {\n            kmp_table[i] <- 0\n       \
    \ }\n    }\n    # Find the longest suffix that is also a prefix\n    longest_suffix_prefix\
    \ <- tail(kmp_table, 1)\n    # If the longest suffix is the same as the prefix,\
    \ the suffix is a palindrome\n    if (longest_suffix_prefix == 0) {\n        #\
    \ If there is no such palindrome, return the string with an appended reverse of\
    \ the prefix\n        return(paste(string, rev(string), sep = ''))\n    } else\
    \ {\n        # Find the prefix that comes before the palindromic suffix\n    \
    \    prefix <- string[(longest_suffix_prefix + 1):length(string)]\n        # Append\
    \ reverse of the prefix\n        return(paste(string, rev(prefix), sep = ''))\n\
    \    }\n}\nmake_palindrome('cata')\n", "\n  longest_palindrome_suffix <- function(string)\
    \ {\n    N <- nchar(string)\n    result <- \"\"\n    for (n in 0:N) {\n      if\
    \ (N-n == 0) {\n        break\n      }\n      if (any(string[1:(N-n)] != string[(N-n+1):N]))\
    \ {\n        continue\n      }\n      result <- string[(N-n+1):N]\n      break\n\
    \    }\n    return(result)\n  }\n  longest_palindrome_suffix <- Vectorize(longest_palindrome_suffix)\n\
    \  suffix <- longest_palindrome_suffix(string)\n  return(paste(string, paste(rev(string[1:(nchar(string)-nchar(suffix))]),\
    \ collapse=\"\"), sep=\"\"))\n}\n", "\n    if (nchar(string) == 0) {\n       \
    \ return(string)\n    }\n    prefix <- string\n    suffix <- ''\n    while (nchar(prefix)\
    \ > 0) {\n        if (is_palindrome(paste(prefix, suffix, sep=''))) {\n      \
    \      return(paste(string, rev(string[1:(nchar(string) - nchar(prefix))]), sep=''))\n\
    \        }\n        prefix <- substring(prefix, 1, nchar(prefix) - 1)\n      \
    \  suffix <- paste(substring(string, nchar(prefix) + 1, nchar(string)), suffix,\
    \ sep='')\n    }\n    return(paste(string, rev(string), sep=''))\n}\n", "\n  string_prefix\
    \ <- substr(string, 0, nchar(string) - 1)\n  string_postfix <- substr(string,\
    \ 2, nchar(string))\n  if (is_palindrome(string)) {\n    return(string)\n  } else\
    \ if (is_palindrome(string_postfix)) {\n    return(c(string, substr(string_prefix,\
    \ nchar(string_prefix), nchar(string_prefix))))\n  } else {\n    return(c(string,\
    \ substr(string_prefix, nchar(string_prefix) - nchar(string_postfix), nchar(string_prefix))))\n\
    \  }\n}\n\ntest_function(make_palindrome)\n", "\n  string <- string[rev(seq_along(string))]\n\
    \  longest_common_substring <- function(string1, string2) {\n    cbind(table(mapply(`:`,\
    \ string1, string2)), 1)\n  }\n  substring_index <- function(table) {\n    max(table)\n\
    \  }\n  palindrome_length <- substring_index(longest_common_substring(string,\
    \ string))\n  c(string, substr(string, seq(palindrome_length), palindrome_length))\n\
    }", "\n\tsuffix_palindrome <- function(s) {\n\t\ts <- strsplit(s, \"\")[[1]]\n\
    \t\tfor (i in seq_along(s)) {\n\t\t\tif (identical(s[seq_len(i)], rev(s[seq_len(i)])))\
    \ {\n\t\t\t\treturn(unlist(strsplit(paste(s[seq_len(i)], collapse = \"\"), \"\"\
    )));\n\t\t\t}\n\t\t}\n\t\treturn(NULL);\n\t}\n\tsuffix <- suffix_palindrome(string);\n\
    \treturn(paste(string, paste(rev(suffix), collapse = \"\"), sep = \"\"));\n}\n",
  "\n    suffix <- string\n    prefix <- substring(string, 1, nchar(string) - 1)\n\
    \    while (suffix != '') {\n        # Empty string is a palindrome\n        if\
    \ (is_palindrome(suffix)) {\n            return(paste(string, string(prefix),\
    \ sep = ''))\n        }\n        suffix <- substr(suffix, 2, nchar(suffix))\n\
    \        prefix <- substring(prefix, 1, nchar(prefix) - 1)\n    }\n    return(string)\n\
    }\n", "\n  if (is.null(string) || nchar(string) == 0) {\n    return ('')\n  }\n\
    \n  suffix <- string[rev(1:nchar(string))]\n  prefix <- substr(string, 1, nchar(string)\
    \ - match(suffix, string))\n  return (paste(string, rev(prefix), sep = ''))\n\
    }\n ", "\n  if (nchar(string) == 0) {\n    return(string)\n  }\n  max_suffix_pos\
    \ <- longest_suffix_palindrome(string)\n  prefix <- substring(string, 1, max_suffix_pos)\n\
    \  return(paste(string, reverse(prefix), sep = ''))\n}\n", "\n\tif (nzchar(string))\
    \ {\n\t\ti <- 2\n\t\twhile (i <= length(string)) {\n\t\t\tif (string[1:(length(string)\
    \ - i + 1)] == rev(string[i:length(string)])) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t\
    i <- i + 1\n\t\t}\n\t\treturn(paste(string, rev(string[1:(length(string) - i +\
    \ 1)]), sep=''))\n\t} else {\n\t\treturn(string)\n\t}\n}\n", "\n    if (length(string)\
    \ == 0) {\n        return(string)\n    }\n    palindrome_suffix <- is_palindrome(string)\n\
    \    return(paste(string, substr(string, 1, nchar(string) - nchar(palindrome_suffix)),\
    \ sep = ''))\n}\nmake_palindrome('cata')\n", "\n  if (nchar(string) == 0) {\n\
    \    string\n  } else {\n    prefix <- substr(string, 1, nchar(string) - nchar(substr(string,\
    \ nchar(string):1, nchar(string):1)))\n    string <- paste(string, gsub(pattern\
    \ = prefix, replacement = '', x = string, fixed = TRUE), sep = '')\n  }\n  string\n\
    }\n", "\n    if (string == '') {\n        return('')\n    }\n    string_length\
    \ <- length(string)\n    for (i in 1:string_length) {\n        if (string[1:i]\
    \ == rev(string[(string_length - i + 1):string_length])) {\n            return(c(string,\
    \ rev(string[1:(string_length - i)])))\n        }\n    }\n}\n ", "\n  if (is.na(string)\
    \ || (string == '')) return('')\n  x <- string\n  if (string[nchar(string)] ==\
    \ 'a') x <- paste0(string, 'a')\n  suffix <- lps(x, nchar(x))\n  if (suffix ==\
    \ x) return(string)\n  prefix <- substring(x, 1, nchar(x) - nchar(suffix))\n \
    \ return(paste0(prefix, suffix, rev(prefix)))\n}\n", "\n  if (string == '') {\n\
    \    return('')\n  }\n  longest_palindrome <- function(str, offset = 0) {\n  \
    \  for (i in (1:nchar(str) - offset)) {\n      if (substr(str, 0 + offset, i +\
    \ offset) == substr(str, nchar(str), nchar(str) - i + 1)) {\n        return(substr(str,\
    \ 1 + offset, i + offset))\n      }\n    }\n    return('')\n  }\n  longest_palindrome(string)\n\
    \  longest_palindrome(rev(string), nchar(string) - nchar(longest_palindrome(string)))\n\
    \  c(string, rev(string[seq(nchar(string) - nchar(longest_palindrome(string)),\
    \ nchar(string))]))\n}\n", "\n  # Find the longest palindromic postfix of supplied\
    \ string.\n  palindromic_postfix <- function(string) {\n    string_length <- nchar(string)\n\
    \    for (cutoff in seq_len(string_length)) {\n      if (identical(strsplit(string,\
    \ '')[[1]][cutoff:string_length],\n                    rev(strsplit(string, '')[[1]][cutoff:string_length])))\
    \ {\n        return(string[(cutoff + 1):string_length])\n      }\n    }\n    return('')\n\
    \  }\n  return(string %+% palindromic_postfix(string))\n}\n", "\n  if (length(string)\
    \ == 0) return(string)\n  substring <- string[rev(seq_along(string))]\n  i <-\
    \ gregexpr(substring, string, fixed = TRUE)[[1]]\n  rest <- substring[-seq_len(i)]\n\
    \  return(c(string, rev(rest)))\n}", "\n  string_length <- nchar(string)\n  palindrome_length\
    \ <- get_palindrome_length(string)\n  if (palindrome_length == string_length)\
    \ {\n    return(string)\n  } else {\n    return(paste(string, rev(string[1:(string_length\
    \ - palindrome_length)]), sep = ''))\n  }\n}", "\n\t# If empty string, return\
    \ it.\n\tif(nchar(string) == 0) {\n\t\treturn(string)\n\t}\n\t# Find the longest\
    \ palindromic postfix of the supplied string.\n\tlongest_palindromic_postfix <-\
    \ function(string) {\n\t\tfor(i in 1:nchar(string)) {\n\t\t\t# Break if the string\
    \ is a palindrome.\n\t\t\tif(substr(string, 1, i) == substr(string, i + 1, 2 *\
    \ i)) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t# Return the palindromic suffix.\n\
    \t\treturn(substr(string, i + 1, 2 * i))\n\t}\n\tpalindromic_postfix <- longest_palindromic_postfix(string)\n\
    \tprefix <- substr(string, 1, nchar(string) - nchar(palindromic_postfix))\n\t\
    suffix <- substr(string, nchar(string) - nchar(palindromic_postfix) + 1, nchar(string))\n\
    \treturn(paste(string, stringr::str_reverse(prefix), sep = ''))\n}\nprint(make_palindrome(''))\n\
    print(make_palindrome('cat'))\nprint(make_palindrome('cata'))", "\n\tsuffix <-\
    \ lpp(string)\n\tpaste(string, string[1:(nchar(string) - nchar(suffix))], sep\
    \ = \"\")\n}\n", "\n\tlongest_palindrome_index <- lpi(string)\n\tprefix <- substr(string,\
    \ 1, longest_palindrome_index)\n\tpaste(string, strreverse(prefix), sep = '')\n\
    }\n", "\n  string_rev <- rev(string)\n  stopifnot(string != string_rev)\n  if\
    \ (string_rev != string) {\n    stopifnot(string_rev == rev(string))\n    for\
    \ (i in 1:length(string)) {\n      if (string[i] == string_rev[i]) {\n       \
    \ if (string[seq(i, length(string))] == string_rev[seq(1, length(string) - i +\
    \ 1)]) {\n          return(paste(string, string_rev[seq(1, length(string) - i)],\
    \ sep = ''))\n        }\n      }\n    }\n  }\n  string\n}\n", "\n    if (is.null(string)\
    \ || string == '') {\n        return('')\n    }\n    prefix <- sub('(.*)$', '\\\
    \\1', string)\n    if (prefix == '') {\n        return(string)\n    }\n    suffix\
    \ <- sub('^(.*)', '\\\\1', string)\n    rev_prefix <- strreverse(prefix)\n   \
    \ make_palindrome(paste(prefix, suffix, sep=''))\n}\n", "\n  get_palindrome_suffix\
    \ <- function(string) {\n    if (string == '') {\n      return(string)\n    }\n\
    \    is_palindrome <- function(string) {\n      half_length <- floor(nchar(string)\
    \ / 2)\n      first_half <- substr(string, 1, half_length)\n      second_half\
    \ <- substr(string, nchar(string) - half_length + 1, nchar(string))\n      return(first_half\
    \ == rev(second_half))\n    }\n    for (i in 0:nchar(string)) {\n      if (is_palindrome(substr(string,\
    \ i + 1, nchar(string)))) {\n        return(substr(string, i + 1, nchar(string)))\n\
    \      }\n    }\n  }\n  if (string == '') {\n    return(string)\n  }\n  return(paste(string,\
    \ get_palindrome_suffix(rev(string)), sep = ''))\n}\n", "\n  suffix <- suffix_palindrome(string)\n\
    \  prefix <- substring(string, 1, nchar(string) - nchar(suffix))\n  paste(string,\
    \ rev(prefix), sep = '')\n}\n", "\n    if (is.na(string) || nchar(string) == 0)\
    \ {\n        return(string)\n    }\n\n    for (i in seq(nchar(string), 1, -1))\
    \ {\n        if (is_palindrome(substr(string, i, nchar(string)))) {\n        \
    \    return(paste(string, substring(string, 1, i - 1), sep = ''))\n        }\n\
    \    }\n}\n", "\n  string_length <- nchar(string)\n  for (end_suffix in seq(string_length,\
    \ 1, -1)) {\n    if (is_palindrome(substr(string, 1, end_suffix))) {\n      prefix\
    \ <- substr(string, end_suffix + 1, string_length)\n      return(paste(string,\
    \ rev(prefix), sep = ''))\n    }\n  }\n  return(string)\n}\n\nmake_palindrome('')\n\
    make_palindrome('cat')\nmake_palindrome('cata')\n", "\n  if (nchar(string) ==\
    \ 0) {\n    return(string)\n  }\n  p <- longest_palindrome_postfix(string)\n \
    \ prefix <- substr(string, 1, nchar(string) - nchar(p))\n  return(paste(string,\
    \ substr(prefix, nchar(prefix):1, 1), sep=''))\n}\n", "\n  if (nchar(string) <=\
    \ 1) {\n    return(string)\n  }\n  retval <- as.character(string)\n  # For example,\
    \ if string is 'cata'\n  prefix <- substr(string, 1, nchar(string) - 1)\n  reverse_prefix\
    \ <- paste(rev(strsplit(prefix, '')[[1]]), collapse = '')\n  reverse_suffix <-\
    \ strsplit(prefix, '')[[1]]\n  # Keep decreasing the length of suffix that is\
    \ searched for palindromicness.\n  for (length in seq(nchar(string), 1, -1)) {\n\
    \    suffix <- substr(string, nchar(string) - length + 1, nchar(string))\n   \
    \ if (all(suffix == reverse_suffix[1:length])) {\n      retval <- paste(string,\
    \ reverse_prefix[length:nchar(string)], sep = '')\n      break\n    }\n  }\n \
    \ return(retval)\n}", "\n  string_reverse <- rev(string)\n  make_palindrome_impl(string,\
    \ string_reverse)\n}\n\nmake_palindrome_impl <- function(string, string_reverse)\
    \ {\n  if (string == string_reverse) {\n    return(string)\n  }\n\n  longest_postfix\
    \ <- find_longest_palindromic_postfix(string, string_reverse)\n  reverse_prefix\
    \ <- rev(substr(string, 1, nchar(string) - nchar(longest_postfix)))\n  return(paste(string,\
    \ reverse_prefix, sep = ''))\n}\n\nfind_longest_palindromic_postfix <- function(string,\
    \ string_reverse) {\n  for (length in nchar(string):1) {\n    postfix <- substr(string,\
    \ start = nchar(string) - length + 1, stop = nchar(string))\n    if (postfix ==\
    \ substr(string_reverse, start = 1, stop = length)) {\n      return(postfix)\n\
    \    }\n  }\n  return('')\n}", "\n  if (string == '') return('')\n  string_len\
    \ <- nchar(string)\n  for (suffix_len in 0:(string_len - 1)) {\n    if (is_palindrome(substr(string,\n\
    \      ((string_len - suffix_len) + 1), string_len))) {\n      return(paste(string,\
    \ substr(string, 1, (string_len - suffix_len)), sep = ''))\n    }\n  }\n  return(string)\n\
    }\n", "\n  if (nchar(string) == 0) {\n    return(string)\n  }\n\n  # Make a list\
    \ of all prefixes of supplied string.\n  prefixes <- list()\n  for (i in seq_len(nchar(string)))\
    \ {\n    prefixes[[i]] <- substr(string, 1, i)\n  }\n\n  # Make a list of all\
    \ postfixes of supplied string.\n  postfixes <- list()\n  for (i in seq_len(nchar(string)))\
    \ {\n    postfixes[[i]] <- substr(string, i, nchar(string))\n  }\n\n  # Find the\
    \ longest palindromic postfix.\n  palindromic_postfix <- list()\n  for (postfix\
    \ in postfixes) {\n    if (is_palindrome(postfix)) {\n      palindromic_postfix\
    \ <- postfix\n    }\n  }\n\n  # Find the string prefix that comes before the longest\
    \ palindromic postfix.\n  prefix <- prefixes[[nchar(palindromic_postfix)]]\n\n\
    \  # Return appended reverse of the prefix to the original string.\n  return(paste(string,\
    \ reverse(prefix), sep=''))\n}\nmake_palindrome('')\nmake_palindrome('cat')\n\
    make_palindrome('cata')\n", "\n  if (nchar(string) == 0) return(string)\n\n  for\
    \ (i in seq(nchar(string), 1, -1)) {\n    if (is_palindrome(string[1:i])) {\n\
    \      return(c(string, rev(string[-(1:i)])))\n    }\n  }\n}\n"]
stop_tokens:
- "\n#"
- "\n```"
