name: HumanEval_136_largest_smallest_integers
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Create a function that returns a tuple (a, b), where 'a' is\n\
  \    // the largest of negative integers, and 'b' is the smallest\n    // of positive\
  \ integers in a list.\n    // If there is no negative or positive integers, return\
  \ them as None.\n    // Examples:\n    // largest_smallest_integers([2, 4, 1, 3,\
  \ 5, 7]) == (None, 1)\n    // largest_smallest_integers([]) == (None, None)\n  \
  \  // largest_smallest_integers([0]) == (None, None)\n    public static Tuple<Nullable<long>,\
  \ Nullable<long>> LargestSmallestIntegers(List<long> lst) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(LargestSmallestIntegers((new\
  \ List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L}))).Equals(Tuple.Create((Nullable<long>)null,\
  \ 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L,\
  \ (long)4L, (long)1L, (long)3L, (long)5L, (long)7L, (long)0L}))).Equals(Tuple.Create((Nullable<long>)null,\
  \ 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)1L,\
  \ (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)-2L}))).Equals(Tuple.Create(-2L,\
  \ 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)4L,\
  \ (long)5L, (long)3L, (long)6L, (long)2L, (long)7L, (long)-7L}))).Equals(Tuple.Create(-7L,\
  \ 2L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)7L,\
  \ (long)3L, (long)8L, (long)4L, (long)9L, (long)2L, (long)5L, (long)-9L}))).Equals(Tuple.Create(-9L,\
  \ 2L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>())).Equals(Tuple.Create((Nullable<long>)null,\
  \ (Nullable<long>)null)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new\
  \ long[]{(long)0L}))).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L,\
  \ (long)-3L, (long)-5L, (long)-6L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L,\
  \ (long)-3L, (long)-5L, (long)-6L, (long)0L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L,\
  \ (long)-4L, (long)-4L, (long)-3L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L,\
  \ (long)-4L, (long)-4L, (long)-3L, (long)-100L, (long)1L}))).Equals(Tuple.Create(-3L,\
  \ 1L)));\n    }\n\n}\n"
completions: ["        long largest = lst.Max();\n        long smallest = lst.Min();\n\
    \        if (largest < smallest)\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        else\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(largest, smallest);", "        if (lst.Count == 0) return new\
    \ Tuple<Nullable<long>, Nullable<long>>(null, null);\n        var largest = lst.Max();\n\
    \        var smallest = lst.Min();\n        if (largest < smallest) return new\
    \ Tuple<Nullable<long>, Nullable<long>>(null, null);\n        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(largest, smallest);", "        long largest = lst.Max();\n \
    \       long smallest = lst.Min();\n        if (largest < smallest) {\n      \
    \      return new Tuple<Nullable<long>, Nullable<long>>(null, null);\n       \
    \ }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest, smallest);",
  "        if (lst.Count == 0)\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        var largest = lst.Max();\n        var smallest = lst.Min();\n\
    \        if (largest < smallest)\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        return new Tuple<Nullable<long>, Nullable<long>>(largest,\
    \ smallest);", "        if (lst.Count == 0) {\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n        long largest = lst.Max();\n\
    \        long smallest = lst.Min();\n        if (largest < smallest) {\n     \
    \       return new Tuple<Nullable<long>, Nullable<long>>(null, null);\n      \
    \  }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest, smallest);",
  "        if (lst.Count == 0) {\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n        long largest = lst.Max();\n        long smallest\
    \ = lst.Min();\n        if (largest < smallest) {\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n        long a = lst.FindIndex(x =>\
    \ x < 0);\n        long b = lst.FindIndex(x => x >= 0);\n        if (a<b) {\n\
    \            return new Tuple<Nullable<long>, Nullable<long>>(null, null);\n \
    \       }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest, smallest);",
  "        long largest = lst.Max();\n        long smallest = lst.Min();\n       \
    \ if (largest < smallest) {\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest,\
    \ smallest);", "        long largest = lst.Max();\n        long smallest = lst.Min();\n\
    \        if (largest < smallest)\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        else\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(largest, smallest);", "        long largest = lst.Max();\n \
    \       long smallest = lst.Min();\n        if (largest < smallest)\n        \
    \    return new Tuple<Nullable<long>, Nullable<long>>(null, null);\n        return\
    \ new Tuple<Nullable<long>, Nullable<long>>(largest, smallest);", "        long\
    \ largest = lst.Max();\n        long smallest = lst.Min();\n        if (largest\
    \ < smallest) {\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest,\
    \ smallest);", "        var largest = lst.Max();\n        var smallest = lst.Min();\n\
    \        if (largest < smallest) {\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(largest, smallest);", "        long largest = lst.Max();\n \
    \       long smallest = lst.Min();\n        if (largest < smallest) {\n      \
    \      return new Tuple<Nullable<long>, Nullable<long>>(null, null);\n       \
    \ }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest, smallest);",
  "        long largest = lst.Max();\n        long smallest = lst.Min();\n       \
    \ if (largest < smallest) {\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest,\
    \ smallest);", "        if (lst.Count == 0) {\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n        long largest = lst.Max();\n\
    \        long smallest = lst.Min();\n        if (largest < smallest) {\n     \
    \       return new Tuple<Nullable<long>, Nullable<long>>(null, null);\n      \
    \  }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest, smallest);",
  "        long largest = lst.Max();\n        long smallest = lst.Min();\n       \
    \ if (largest < smallest) {\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest,\
    \ smallest);", "        long largest = lst.Max();\n        long smallest = lst.Min();\n\
    \        if (largest < smallest) {\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(largest, smallest);", "        var largest = lst.Max();\n  \
    \      var smallest = lst.Min();\n        if (largest < smallest)\n          \
    \  return new Tuple<Nullable<long>, Nullable<long>>(null, null);\n        return\
    \ new Tuple<Nullable<long>, Nullable<long>>(largest, smallest);", "        long\
    \ largest = lst.Max();\n        long smallest = lst.Min();\n        if (largest\
    \ < smallest)\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        return new Tuple<Nullable<long>, Nullable<long>>(largest, smallest);",
  "        long largest = lst.Max();\n        long smallest = lst.Min();\n       \
    \ if (largest < smallest) {\n            return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(largest,\
    \ smallest);", "        long largest = lst.Max();\n        long smallest = lst.Min();\n\
    \        if (largest < smallest) {\n            return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }\n        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(largest, smallest);"]
stop_tokens:
- "\n    }\n"
