name: HumanEval_104_unique_digits
language: sh
prompt: "#!/bin/bash\n# Given a list of positive integers x. return a sorted list\
  \ of all \n# elements that hasn't any even digit.\n# Note: Returned list should\
  \ be sorted in increasing order.\n# For example:\n# >>> $(unique_digits \"15 33\
  \ 1422 1\")\n# ['\"1\"', '\"15\"', '\"33\"']\n# >>> $(unique_digits \"152 323 1422\
  \ 10\")\n# []\n#\n# $1 is a space-separated list\nunique_digits() {\n"
tests: "}\n\ncandidate() {\n    unique_digits \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"15 33 1422 1\") = \"1 15 33\" ]]\n    [[ $(candidate \"152\
  \ 323 1422 10\") = \"\" ]]\n    [[ $(candidate \"12345 2033 111 151\") = \"111 151\"\
  \ ]]\n    [[ $(candidate \"135 103 31\") = \"31 135\" ]]\n}\n\nrun_test"
completions: ["    local x=\"$1\"\n    local output\n    output=$(echo \"$x\" | tr\
    \ \" \" \"\\n\" | sort -u | tr \"\\n\" \" \")\n    echo \"$output\"", "    local\
    \ x=\"$1\"\n    local output\n    output=$(echo \"$x\" | sed 's/\\([0-9]*\\)$/\\\
    1/' | sort -u)\n    echo \"$output\"", "    local x=\"$1\"\n    local output\n\
    \    output=$(echo \"$x\" | tr \" \" \"\\n\" | sort -n | uniq -d)\n    echo \"\
    $output\"", "    local x=\"$1\"\n    local output\n    output=$(echo \"$x\" |\
    \ tr \" \" \"\\n\" | sort | uniq -d)\n    echo \"$output\"", "    local x=\"$1\"\
    \n    local output\n    output=$(echo \"$x\" | tr \" \" \"\\n\" | sort | uniq\
    \ -d)\n    echo \"$output\"", "    local x=\"$1\"\n    local output\n    output=$(echo\
    \ \"$x\" | tr \" \" \"\\n\" | sort -u | tr \"\\n\" \" \")\n    echo \"$output\"",
  "    local x=\"$1\"\n    local output\n    output=$(echo \"$x\" | tr \" \" \"\\\
    n\" | sort -u | tr \"\\n\" \" \")\n    echo \"$output\"", "    local x=\"$1\"\n\
    \    local output\n    output=$(echo \"$x\" | tr \" \" \"\\n\" | sort -u | tr\
    \ \"\\n\" \" \")\n    echo \"$output\"", "    local x=\"$1\"\n    local output\n\
    \    output=$(echo \"$x\" | sed 's/\\([0-9]*\\)$/\\1/' | sort -u)\n    echo \"\
    $output\"", "    local x=\"$1\"\n    local output\n    output=$(echo \"$x\" |\
    \ tr \" \" \"\\n\" | sort -u | tr \"\\n\" \" \")\n    echo \"$output\"", "   \
    \ local x=\"$1\"\n    local output\n    output=$(echo \"$x\" | sed 's/ //g' |\
    \ sort -u)\n    echo \"$output\"", "    local x=\"$1\"\n    local output\n   \
    \ output=$(echo \"$x\" | tr \" \" \"\\n\" | sort -u | tr \"\\n\" \" \")\n    echo\
    \ \"$output\"", "    local x=\"$1\"\n    local output\n    output=$(echo \"$x\"\
    \ | sed 's/\\([0-9]*\\)$/\\1/')\n    while [ -n \"$output\" ]; do\n        local\
    \ digit=$(echo \"$output\" | sed 's/\\([0-9]*\\)$/\\1/')\n        if [ \"$digit\"\
    \ -eq \"0\" ]; then\n            echo \"$output\"\n        fi\n        output=$(echo\
    \ \"$output\" | sed \"s/$digit//g\")\n    done", "    local x=\"$1\"\n    local\
    \ output\n    output=$(echo \"$x\" | tr \" \" \"\\n\" | sort | uniq -d)\n    echo\
    \ \"$output\"", "    local x=\"$1\"\n    local output\n    output=$(echo \"$x\"\
    \ | sed 's/\\([0-9]*\\)$/\\1/' | sort -u)\n    echo \"$output\"", "    local x=\"\
    $1\"\n    local output\n    output=$(echo \"$x\" | tr \" \" \"\\n\" | sort -u\
    \ | tr \"\\n\" \" \")\n    echo \"$output\"", "    local x=\"$1\"\n    local output\n\
    \    output=$(echo \"$x\" | sed 's/\\([0-9]*\\)$/\\1/')\n    local i\n    for\
    \ (( i=0; i<${#output}; i++ )); do\n        if [[ ${output[$i]} -eq 0 ]]; then\n\
    \            echo \"$output[$i]\"\n        fi\n    done", "    local x=\"$1\"\n\
    \    local output\n    output=$(echo \"$x\" | tr \" \" \"\\n\" | sort -n | uniq\
    \ -d)\n    echo \"$output\"", "    local x=\"$1\"\n    local output\n    local\
    \ i\n    local digit\n    local count\n    local j\n    local k\n    local digit\n\
    \    local tmp\n    \n    output=()\n    \n    for ((i=0; i<${#x}; i++)); do\n\
    \        digit=${x:$i:1}\n        count=$(echo \"$digit\" | wc -c)\n        if\
    \ [ \"$count\" -eq \"0\" ]; then\n            output+=(\"$digit\")\n        fi\n\
    \    done\n    \n    for ((j=0; j<${#output[@]}; j++)); do\n        tmp=${output[$j]}\n\
    \        for ((k=0; k<${#tmp}; k++)); do\n            digit=${tmp:$k:1}\n    \
    \        count=$(echo \"$digit\" | wc -c)\n            if [ \"$count\" -eq \"\
    0\" ]; then\n                output[$j]=$digit\n            fi\n        done\n\
    \    done\n    \n    IFS=' ' read -r -a output <<< \"${output[*]}\"\n    IFS='\
    \ ' read -r -a output <<< \"${output[*]}\"\n    IFS=' ' read -r -a output <<<\
    \ \"${output[*]}\"\n    IFS=' ' read -r -a output <<< \"${output[*]}\"\n    IFS='\
    \ ' read -r -a output <<< \"${output[*]}\"\n    IFS=' ' read -r -a output <<<\
    \ \"${output[*]}\"\n    IFS=' ' read -r -a output <<< \"${output[*]}\"\n    IFS='\
    \ ' read -r -a output <<< \"${output[*]}\"\n    IFS=' ' read -r -a output <<<\
    \ \"${output[*]}\"\n    IFS=' ' read -r -a output <<< \"${output[*]}\"\n    IFS='\
    \ ' read -r -a output <<< \"${output[*]}\"\n    IFS=' ' read -r -a output <<<\
    \ \"${output[*]}\"\n    IFS=' ' read -r -a output <<< \"${output[*]}\"\n    IFS='\
    \ ' read -r -a output <<< \"${output[*]}\"\n    IFS=' ' read -r -a output <<<\
    \ \"${output[*]}\"\n    IFS=' ' read -r -a output <<< \"${output[*]}\"\n    IFS='\
    \ ' read -r -a output <<< \"${output[*]}\"", "    local x=\"$1\"\n    local output\n\
    \    output=$(echo \"$x\" | tr ' ' '\\n' | sort -u | tr '\\n' ' ')\n    echo \"\
    $output\""]
stop_tokens:
- "\n}"
