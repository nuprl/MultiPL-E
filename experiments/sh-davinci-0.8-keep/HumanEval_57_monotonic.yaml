name: HumanEval_57_monotonic
language: sh
prompt: "#!/bin/bash\n# Return True is list elements are monotonically increasing\
  \ or decreasing.\n# >>> monotonic([1, 2, 4, 20])\n# True\n# >>> monotonic([1, 20,\
  \ 4, 10])\n# False\n# >>> monotonic([4, 1, 0, -10])\n# True\n#\n# $1 is a space-separated\
  \ list\nmonotonic() {\n"
tests: "}\n\ncandidate() {\n    monotonic \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"1 2 4 10\") = \"true\" ]]\n    [[ $(candidate \"1 2 4 20\") = \"\
  true\" ]]\n    [[ $(candidate \"1 20 4 10\") = \"false\" ]]\n    [[ $(candidate\
  \ \"4 1 0 -10\") = \"true\" ]]\n    [[ $(candidate \"4 1 1 0\") = \"true\" ]]\n\
  \    [[ $(candidate \"1 2 3 2 5 60\") = \"false\" ]]\n    [[ $(candidate \"1 2 3\
  \ 4 5 60\") = \"true\" ]]\n    [[ $(candidate \"9 9 9 9\") = \"true\" ]]\n}\n\n\
  run_test"
completions: ["    declare -a my_array=(${1// / })\n    increasing=false\n    decreasing=false\n\
    \    if [ \"${my_array[0]}\" -lt \"${my_array[1]}\" ]; then\n        increasing=true\n\
    \    elif [ \"${my_array[0]}\" -gt \"${my_array[1]}\" ]; then\n        decreasing=true\n\
    \    fi\n    for ((i=0; i<${#my_array[@]}-1; i++)); do\n        if [[ \"${my_array[$i]}\"\
    \ -lt \"${my_array[$i+1]}\" && \"$decreasing\" == true ]]; then\n            return\
    \ 1\n        elif [[ \"${my_array[$i]}\" -gt \"${my_array[$i+1]}\" && \"$increasing\"\
    \ == true ]]; then\n            return 1\n        fi\n    done\n    return 0",
  "    arr=(\"$@\")\n    local n=${#arr[@]}\n    [[ $n -le 1 ]] && echo True && return\n\
    \    is_increasing=0\n    is_decreasing=0\n    for i in $(seq 1 $((n-1))); do\n\
    \        if [[ \"${arr[$i]}\" -gt \"${arr[$((i-1))]}\" ]]; then\n            is_increasing=1\n\
    \        elif [[ \"${arr[$i]}\" -lt \"${arr[$((i-1))]}\" ]]; then\n          \
    \  is_decreasing=1\n        fi\n    done\n    [[ $is_increasing -eq 1 && $is_decreasing\
    \ -eq 0 ]] && echo True && return\n    [[ $is_increasing -eq 0 && $is_decreasing\
    \ -eq 1 ]] && echo True && return\n    echo False", "    [[ $# -gt 1 ]] || return\
    \ 0\n    typeset -i x1=$1 x2\n    shift\n    while (( $# > 0 )); do\n        x2=$1\n\
    \        if (( x1 >= x2 )); then\n            x1=$x2\n            shift\n    \
    \    else\n            return 1\n        fi\n    done\n    return 0", "    if\
    \ [ $# -lt 1 ]; then\n        echo $FUNCNAME: usage: $FUNCNAME \\<list\\>\n  \
    \      return 1\n    fi\n    local prev=$1\n    for x in $@; do\n        if [\
    \ $x -gt $prev ]; then\n            prev=$x\n        else\n            return\
    \ 1\n        fi\n    done\n    return 0", "  declare -a arr=(\"$@\")\n  local\
    \ -i i=0\n  local -i direction=${arr[1]}\n  local -i base=${arr[0]}\n  local -i\
    \ current=0\n  for ((i=1; i<${#arr[@]}; i++)); do\n    current=${arr[i]}\n   \
    \ if ((current - base)); then\n      if ((direction)); then\n        if ((current*direction\
    \ < base*direction)); then\n          return 1\n        fi\n      else\n     \
    \   direction=$((current - base))\n      fi\n    fi\n    base=$current\n  done\n\
    \  return 0", "    local IFS=$'\\n'\n    local -a a=($1)\n    ((a[1]>a[0])) &&\
    \ for((i=1;i<${#a[@]};i++)); do ((a[i]<a[i-1]) && return 1); done\n    ((a[1]<a[0]))\
    \ && for((i=1;i<${#a[@]};i++)); do ((a[i]>a[i-1]) && return 1); done\n    return\
    \ 0", "    local __d=$(echo \"$@\" | sed 's/\\s\\+/ /g' | awk 'BEGIN {\n     \
    \ FS=\" \";\n      prev=-1;\n      OFS=\"\\n\";\n      print \"BEGIN { prev=\"\
    prev\"; incr=1; OFS=\\\"\\n\\\" }\";\n      print \"{ if ($1 > prev) { prev=$1;\
    \ } else { incr=0 } }\";\n      print \"END { print incr }\";\n    }')\n    echo\
    \ \"$@\" | sed 's/\\s\\+/ /g' | awk \"$__d\"", "    a=( $1 )\n    if (( ${#a[@]}\
    \ == 1 )); then\n        echo \"True\"\n        return\n    fi\n    for (( i=0;\
    \ i<${#a[@]}-1; i++ )); do\n        (( a[i] > a[i+1] )) && break\n        (( a[i]\
    \ < a[i+1] )) && break\n    done\n    case $i in\n        0) echo \"True\" ;;\n\
    \        ${#a[@]}-1) echo \"True\" ;;\n        *) echo \"False\" ;;\n    esac",
  "    local newstr=\" \"\n    local chr=\"\"\n    local res=\"\"\n    local ar=($1)\n\
    \    local i=\"\"\n    local in=\"\"\n    local inc=1\n    local ni=\"\"\n   \
    \ local cmp=\"\"\n    local arr=\"\"\n    for (( i=0; i<${#ar[@]}; i++ )); do\n\
    \        chr=${ar[$i]}\n        #echo $chr\n        if [ \"$chr\" -eq \"$chr\"\
    \ ] 2>/dev/null; then\n            newstr=\"$newstr $chr\"\n        fi\n    done\n\
    \    arr=($newstr)\n    #echo ${arr[@]}\n    #echo ${#arr[@]}\n    if [ ${#arr[@]}\
    \ -eq 0 ]; then\n        res=False\n    else\n        cmp=${arr[0]}\n        for\
    \ (( i=1; i<${#arr[@]}; i++ )); do\n            in=${arr[$i]}\n            if\
    \ [ \"$in\" -eq \"$in\" ] 2>/dev/null; then\n                if [ \"$in\" -gt\
    \ \"$cmp\" ]; then\n                    inc=1\n                elif [ \"$in\"\
    \ -lt \"$cmp\" ]; then\n                    inc=0\n                fi\n      \
    \          cmp=$in\n            fi\n        done\n        if [ $inc -eq 1 ]; then\n\
    \            res=True\n        else\n            res=False\n        fi\n    fi\n\
    \    echo $res", "    [ $# -eq 0 ] && return 0\n    local element1=$1\n    while\
    \ [ $# -gt 0 ]; do\n        local element2=$1\n        [ $element1 -eq $element2\
    \ ] && return 0\n        if [ $element1 -lt $element2 ]; then\n            local\
    \ increasing=1\n        else\n            local increasing=0\n        fi\n   \
    \     shift\n        if [ $# -eq 0 ]; then\n            return 0\n        fi\n\
    \        element1=$1\n        if [ $increasing -eq 1 ]; then\n            [ $element1\
    \ -gt $element2 ] || return 1\n        else\n            [ $element1 -lt $element2\
    \ ] || return 1\n        fi\n    done", "    (( $(echo $1 | wc -w) == 1 )) &&\
    \ return 0\n    i=0\n    for n in $1; do\n        if (( i > 0 )); then\n     \
    \       (( $n == $p )) && return 1\n            (( $n > $p )) && dir=1 || dir=-1\n\
    \            (( $dir != $prev_dir )) && return 1\n        fi\n        prev_dir=$dir\n\
    \        p=$n\n        i=$(( i + 1 ))\n    done\n    return 0", "    local prev=`echo\
    \ $1 | cut -d ' ' -f 1`\n    local last=$prev\n    local len=`echo $1 | wc -w`\n\
    \    for i in `seq 2 $len`; do\n        elem=`echo $1 | cut -d ' ' -f $i`\n  \
    \      [ $elem -gt $last ] || [ $elem -lt $last ] && return 1\n        [ $elem\
    \ -gt $prev ] && prev=$elem\n        [ $elem -lt $prev ] && prev=$elem\n    done\n\
    \    return 0", "    local list=\"$1\"\n    local ret=$(python -c \"\nimport sys\n\
    def monotonic(t):\n    return all(x<=y for x, y in zip(t, t[1:])) or all(x>=y\
    \ for x, y in zip(t, t[1:]))\nfor i in sys.stdin.read().split():\n    try:\n \
    \       print(monotonic([float(x) for x in i.split()]))\n    except:\n       \
    \ print(False)\n\" <<< \"$list\")\n    local ret2=True\n    for i in $ret; do\n\
    \        if [ \"$i\" == \"False\" ]; then\n            ret2=False\n          \
    \  break\n        fi\n    done\n    echo $ret2", "    local vals=($@)\n    local\
    \ -i a=${vals[0]}\n    local -i d=0\n    local -i e=0\n    local -i i=0\n    local\
    \ -i n=${#vals[@]}\n    local result=true\n    for ((i=1; i<n; i++)); do\n   \
    \     e=${vals[i]}\n        if ((d==0)); then\n            ((e>a)) && d=1 || ((e<a))\
    \ && d=-1\n        else\n            ((e>a)) && ((d!=1)) && result=false && break\n\
    \            ((e<a)) && ((d!=-1)) && result=false && break\n        fi\n     \
    \   a=$e\n    done\n    echo $result", "    local -a arr\n    IFS=\" \" read -r\
    \ -a arr <<< \"$1\"\n    local len=\"${#arr[@]}\"\n    # -1 --> descending\n \
    \   # 1 --> ascending\n    local direction=0\n    local curr=0\n    local prev=0\n\
    \    local i=0\n    while [[ $i -lt $len ]]; do\n        curr=\"${arr[$i]}\"\n\
    \        if [[ $i -ne 0 ]]; then\n            if [[ $direction -eq 0 ]]; then\n\
    \                if [[ $curr -gt $prev ]]; then\n                    direction=1\n\
    \                elif [[ $curr -lt $prev ]]; then\n                    direction=-1\n\
    \                fi\n            elif [[ $direction -eq 1 ]]; then\n         \
    \       if [[ $curr -lt $prev ]]; then\n                    return 1\n       \
    \         fi\n            elif [[ $direction -eq -1 ]]; then\n               \
    \ if [[ $curr -gt $prev ]]; then\n                    return 1\n             \
    \   fi\n            fi\n        fi\n        prev=$curr\n        ((i++))\n    done\n\
    \    return 0", "    [[ $1 =~ ^[0-9]+([\\ ]+[0-9]+)*$ ]] || {\n        echo -e\
    \ \"${YELLOW}WARNING:${NORMAL} The argument $1 contains non-integer elements.\"\
    \n        echo -e \"${YELLOW}WARNING:${NORMAL} Space separated values will be\
    \ interpreted as integers.\"\n        echo -e \"${YELLOW}WARNING:${NORMAL} The\
    \ output may be wrong.\"\n    }\n    local arr=($1)\n    local arr_length=${#arr[@]}\n\
    \    (( arr_length <= 1 )) && {\n        echo -e \"${YELLOW}WARNING:${NORMAL}\
    \ The length of the argument $1 is too short\"\n        echo -e \"${YELLOW}WARNING:${NORMAL}\
    \ The output may be wrong.\"\n    }\n    # Check if all elements are same\n  \
    \  local first=${arr[0]}\n    for n in ${arr[@]}; do\n        [[ $n != $first\
    \ ]] && break\n    done\n    # If all elements are same, return False.\n    [[\
    \ $n == $first ]] && return 1\n    # Check if elements are monotonically increasing.\n\
    \    first=${arr[0]}\n    for n in ${arr[@]}; do\n        (( n >= first )) ||\
    \ return 1\n        first=$n\n    done\n    return 0", "    declare -a a=(${1})\n\
    \    local sum=0\n    local sum_p=0\n    local sum_n=0\n    local len=\"${#a[@]}\"\
    \n    local i=0\n    while [[ \"${i}\" -lt \"${len}\" ]]; do\n        if [[ \"\
    ${i}\" -lt \"$((len-1))\" ]]; then\n            let sum_p+=\"${a[$((i+1))]}\"\
    -\"${a[${i}]}\"\n            let sum_n+=\"${a[${i}]}\"-\"${a[$((i+1))]}\"\n  \
    \      fi\n        let i+=1\n    done\n    if [[ \"${sum_p}\" -gt 0 && \"${sum_n}\"\
    \ -eq 0 ]]; then\n        echo true\n    elif [[ \"${sum_p}\" -eq 0 && \"${sum_n}\"\
    \ -gt 0 ]]; then\n        echo true\n    else\n        echo false\n    fi", " \
    \   declare -a numbers\n    local i\n    read -ra numbers <<< \"$1\"\n\n    if\
    \ [ ${#numbers[@]} -lt 2 ]; then\n        echo \"true\"\n        return\n    fi\n\
    \n    local a=${numbers[0]}\n    local increasing=${numbers[1]} -ge $a\n    for\
    \ ((i=1; i<${#numbers[@]}; i++)); do\n        local b=${numbers[i]}\n        if\
    \ (( increasing && b < a )) || (( !increasing && b > a )); then\n            echo\
    \ \"false\"\n            return\n        fi\n        a=$b\n    done\n    echo\
    \ \"true\"", "    local arr=\"$1\"\n    local dir\n    local last=$(echo \"$arr\"\
    \ | head -n 1)\n    echo \"$arr\" | while read curr; do\n        [[ \"$last\"\
    \ -gt \"$curr\" ]] && dir=\"-1\"\n        [[ \"$last\" -lt \"$curr\" ]] && dir=\"\
    1\"\n        [[ -z \"$dir\" ]] && return 1\n        [[ \"$dir\" != \"-1\" && \"\
    $dir\" != \"1\" ]] && return 1\n        [[ \"$dir\" == \"1\" && \"$last\" -gt\
    \ \"$curr\" ]] && return 1\n        [[ \"$dir\" == \"-1\" && \"$last\" -lt \"\
    $curr\" ]] && return 1\n        last=\"$curr\"\n    done\n    return 0", "   \
    \ arr=($1)\n    if [ ${#arr[@]} -le 1 ]; then\n        echo 1\n        return\n\
    \    fi\n    if [ \"${arr[0]}\" -lt \"${arr[1]}\" ]; then\n        for i in $(seq\
    \ 0 $((${#arr[@]}-2))); do\n            if [ \"${arr[$i]}\" -gt \"${arr[$i+1]}\"\
    \ ]; then\n                echo 0\n                return\n            fi\n  \
    \      done\n    else\n        for i in $(seq 0 $((${#arr[@]}-2))); do\n     \
    \       if [ \"${arr[$i]}\" -lt \"${arr[$i+1]}\" ]; then\n                echo\
    \ 0\n                return\n            fi\n        done\n    fi\n    echo 1"]
stop_tokens:
- "\n}"
