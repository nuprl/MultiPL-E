name: HumanEval_95_check_dict_case
language: sh
prompt: "#!/bin/bash\n# Given a dictionary, return True if all keys are strings in\
  \ lower \n# case or all keys are strings in upper case, else return False.\n# The\
  \ function should return False is the given dictionary is empty.\n# Examples:\n\
  # check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n# check_dict_case({\"\
  a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n# check_dict_case({\"\
  a\":\"apple\", \"8\":\"banana\", \"a\":\"apple\"}) should return False.\n# check_dict_case({\"\
  Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n#\
  \ check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n\
  #\n# $1 is a two column CSV in key,value order\ncheck_dict_case() {\n"
tests: "}\n\ncandidate() {\n    check_dict_case \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"p,pineapple\\nb,banana\") = \"true\" ]]\n    [[ $(candidate\
  \ \"p,pineapple\\nA,banana\\nB,banana\") = \"false\" ]]\n    [[ $(candidate \"p,pineapple\\\
  n5,banana\\na,apple\") = \"false\" ]]\n    [[ $(candidate \"Name,John\\nAge,36\\\
  nCity,Houston\") = \"false\" ]]\n    [[ $(candidate \"STATE,NC\\nZIP,12345\") =\
  \ \"true\" ]]\n    [[ $(candidate \"fruit,Orange\\ntaste,Sweet\") = \"true\" ]]\n\
  \    [[ $(candidate \"\") = \"false\" ]]\n}\n\nrun_test"
completions: ["    [ -z \"$1\" ] && return 1\n    [ ! -r \"$1\" ] && return 1\n  \
    \  awk -F, '{\n        gsub(/[^[:alnum:]]/, \"\", $1)\n        gsub(/[^[:alnum:]]/,\
    \ \"\", $2)\n        if (NR == 1) {\n            if (tolower($1) == $1)\n    \
    \            flag=0\n            else if (toupper($1) == $1)\n               \
    \ flag=1\n            else\n                exit\n        }\n        else {\n\
    \            if (flag == 0 && tolower($1) != $1)\n                exit\n     \
    \       else if (flag == 1 && toupper($1) != $1)\n                exit\n     \
    \   }\n    }\n    END {\n        if (NR == 0)\n            exit 1\n        print\
    \ flag\n    }' \"$1\"", "\tif [ $# -ne 1 ]; then\n\t\techo \"Usage: check_dict_case\
    \ key,value\" >&2\n\t\treturn 1\n\tfi\n\tif [ ! -e \"$1\" ]; then\n\t\techo \"\
    Could not find file '$1'\" >&2\n\t\treturn 1\n\tfi\n\tif [ ! -s \"$1\" ]; then\n\
    \t\techo \"File '$1' is empty\" >&2\n\t\treturn 1\n\tfi\n\tkeys=$(head -n 1 \"\
    $1\" | cut -d , -f 1)\n\tif [[ $keys =~ ^[a-z]$ ]]; then\n\t\ttr '[:upper:]' '[:lower:]'\
    \ <\"$1\" | grep -v '^[a-z],.*$' >/dev/null\n\t\tif [ $? -eq 0 ]; then\n\t\t\t\
    echo 'false'\n\t\telse\n\t\t\techo 'true'\n\t\tfi\n\telif [[ $keys =~ ^[A-Z]$\
    \ ]]; then\n\t\ttr '[:lower:]' '[:upper:]' <\"$1\" | grep -v '^[A-Z],.*$' >/dev/null\n\
    \t\tif [ $? -eq 0 ]; then\n\t\t\techo 'false'\n\t\telse\n\t\t\techo 'true'\n\t\
    \tfi\n\telse\n\t\techo 'false'\n\tfi", "    local -A input\n    local -a upper_keys\n\
    \    local -a lower_keys\n    local -a mixed_keys\n    local key value\n    local\
    \ line\n    local lower_count=0\n    local upper_count=0\n    local mixed_count=0\n\
    \    local -i rc=0\n\n    while read line; do\n        IFS=',' read key value\
    \ <<< \"$line\"\n        input[$key]=$value\n    done < <(cat \"$1\")\n\n    for\
    \ key in \"${!input[@]}\"; do\n        if [[ \"$key\" =~ ^[A-Z]+$ ]]; then\n \
    \           upper_keys+=(\"$key\")\n            upper_count=$(($upper_count +\
    \ 1))\n        elif [[ \"$key\" =~ ^[a-z]+$ ]]; then\n            lower_keys+=(\"\
    $key\")\n            lower_count=$(($lower_count + 1))\n        else\n       \
    \     mixed_keys+=(\"$key\")\n            mixed_count=$(($mixed_count + 1))\n\
    \        fi\n    done\n\n    local -i total_keys=$(($upper_count + $lower_count\
    \ + $mixed_count))\n\n    if [[ $total_keys -gt 0 ]]; then\n        if [[ $upper_count\
    \ -eq $total_keys ]]; then\n            echo \"All keys are in upper case.\"\n\
    \        elif [[ $lower_count -eq $total_keys ]]; then\n            echo \"All\
    \ keys are in lower case.\"\n        else\n            echo \"Keys are a mix of\
    \ upper and lower case.\"\n            rc=1\n        fi\n    else\n        echo\
    \ \"No keys found.\"\n        rc=1\n    fi\n\n    return $rc", "\tlocal key=\"\
    \"\n\tlocal val=\"\"\n\tlocal upper=0\n\tlocal lower=0\n\tlocal num=0\n\tlocal\
    \ cnt=0\n\tlocal total=0\n\tlocal ret=0\n\t\n\t[ -z \"$1\" ] && echo \"0\" &&\
    \ return 0\n\t\n\ttotal=$(wc -l \"$1\" | awk '{print $1}')\n\t[ \"$total\" -eq\
    \ 0 ] && echo \"0\" && return 0\n\t\n\tfor l in $(cat \"$1\"); do\n\t\tkey=$(echo\
    \ \"$l\" | cut -d',' -f1)\n\t\tval=$(echo \"$l\" | cut -d',' -f2)\n\t\t[ \"$key\"\
    \ = \"$val\" ] && continue\n\t\tfor (( cnt=0; cnt<${#key}; cnt++ )); do\n\t\t\t\
    [[ \"${key:$cnt:1}\" =~ [A-Z] ]] && upper=$((upper+1))\n\t\t\t[[ \"${key:$cnt:1}\"\
    \ =~ [a-z] ]] && lower=$((lower+1))\n\t\t\t[[ \"${key:$cnt:1}\" =~ [0-9] ]] &&\
    \ num=$((num+1))\n\t\tdone\n\tdone\n\t\n\tif [ \"$upper\" -eq \"$total\" ]; then\n\
    \t\tret=1\n\telif [ \"$lower\" -eq \"$total\" ]; then\n\t\tret=1\n\telif [ \"\
    $num\" -eq \"$total\" ]; then\n\t\tret=1\n\tfi\n\t\n\techo \"$ret\"", "  for arg\
    \ in $1; do\n    case $arg in\n      *:*)\n        IFS=':'\n        set $arg\n\
    \        case $1 in\n          [a-z]*)\n            if [[ \"$1\" != [a-z]* ]];\
    \ then\n              echo False\n              return\n            fi\n     \
    \       ;;\n          [A-Z]*)\n            if [[ \"$1\" != [A-Z]* ]]; then\n \
    \             echo False\n              return\n            fi\n            ;;\n\
    \          *)\n            echo False\n            return\n            ;;\n  \
    \      esac\n        ;;\n    esac\n  done\n  echo True", "    IFS=,\n    if [\
    \ -s \"$1\" ]; then\n        cat \"$1\" | while read key value; do\n         \
    \   if [ \"$key\" != \"${key,,}\" ] && [ \"$key\" != \"${key^^}\" ]; then\n  \
    \              return 0\n            fi\n        done\n        return 1\n    else\n\
    \        return 0\n    fi", "    key_col=\"$(get_column.sh \"$1\" 1 | get_unique_values.sh)\"\
    \n    value_col=\"$(get_column.sh \"$1\" 2 | get_unique_values.sh)\"\n    if [\
    \ \"$key_col\" == \"\" ]; then\n        return 1\n    fi\n    key_case_mode=\"\
    $(echo \"$key_col\" | grep -v '[a-z]' | grep -c '[A-Z]')\"\n    if [ \"$key_case_mode\"\
    \ -gt 0 ]; then\n        key_case_mode=\"uppercase\"\n    else\n        key_case_mode=\"\
    lowercase\"\n    fi\n    output=\"true\"\n    # Check value_col for any keys that\
    \ don't match key_case_mode\n    if [ \"$value_col\" != \"\" ]; then\n       \
    \ echo \"$value_col\" | while read -r line; do\n            if [ \"$(echo \"$line\"\
    \ | grep -v '[a-z]' | grep -c '[A-Z]')\" -gt 0 ]; then\n                if [ \"\
    $key_case_mode\" == \"lowercase\" ]; then\n                    output=\"false\"\
    \n                fi\n            else\n                if [ \"$key_case_mode\"\
    \ == \"uppercase\" ]; then\n                    output=\"false\"\n           \
    \     fi\n            fi\n        done\n    fi\n    echo \"$output\"", "  [ $#\
    \ -ne 1 ] && return 1\n  [ ! -r \"$1\" ] && return 1\n  declare -A mydict\n  while\
    \ IFS=, read k v; do\n    mydict[$k]=$v\n  done < \"$1\"\n  if [ ${#mydict[@]}\
    \ -eq 0 ]; then\n    echo \"False\"\n    return 0\n  fi\n  for k in \"${!mydict[@]}\"\
    ; do\n    [[ $k =~ [A-Z]+ ]] && return 1\n  done\n  echo \"True\"\n  return 0",
  "   if [[ $# -ne 1 ]]; then\n      echo \"Error: Usage: $0 <CSV of Key,Value pairs>\"\
    \n      exit 1\n   fi\n   if [[ ! -f $1 ]]; then\n      echo \"Error: CSV file\
    \ $1 does not exist\"\n      exit 1\n   fi\n   local num_records=$(cat $1 | wc\
    \ -l)\n   if [[ $num_records -eq 0 ]]; then\n      echo \"False\"\n      exit\
    \ 0\n   fi\n   # First check to see if all strings in first column are lower case\n\
    \   local all_lower_case=$(awk -F, '{ print tolower($1) }' $1 | diff $1 - | wc\
    \ -l)\n   if [[ $all_lower_case -eq 0 ]]; then\n      echo \"True\"\n      exit\
    \ 0\n   fi\n   # Next check to see if all strings in first column are upper case\n\
    \   local all_upper_case=$(awk -F, '{ print toupper($1) }' $1 | diff $1 - | wc\
    \ -l)\n   if [[ $all_upper_case -eq 0 ]]; then\n      echo \"True\"\n      exit\
    \ 0\n   fi\n   # Neither lower nor upper case\n   echo \"False\"\n   exit 0",
  "\t[ $# -eq 0 ] && return 1\n\t\n\tlower=1\t\t# True\n\tupper=1\t\t# True\n\t\n\t\
    while IFS=',' read key value; do\n\t\t[ \"$(echo \"$key\" | tr '[:upper:]' '[:lower:]')\"\
    \ = \"$key\" ] || lower=0\t# False\n\t\t[ \"$(echo \"$key\" | tr '[:lower:]' '[:upper:]')\"\
    \ = \"$key\" ] || upper=0\t# False\n\tdone < <(echo \"$1\")\n\t\n\tif [ $lower\
    \ -eq 1 ] || [ $upper -eq 1 ]; then\n\t\techo 'True'\n\telse\n\t\techo 'False'\n\
    \tfi", "  awk -F, '\n    {\n      # key \n      k = $1\n      # value\n      v\
    \ = $2\n      # key is uppercase?\n      if (k == toupper(k))\n        up=1\n\
    \      # key is lowercase?\n      if (k == tolower(k))\n        lo=1\n      #\
    \ reset flags if necessary\n      if (up == 1 && lo == 1) {\n        print \"\
    False\"\n        exit 0\n      }\n    }\n    END {\n      if (NR == 0)\n     \
    \   print \"False\"\n      else\n        print \"True\"\n    }\n  ' ${1}", " \
    \   # awk '{print toupper($1)}' $1 | sort | uniq\n    awk '{print $1}' $1 | sort\
    \ | uniq", "  read_dict_file \"$1\"\n  local UPPER_COUNT=0\n  local LOWER_COUNT=0\n\
    \  local DUP_COUNT=0\n  local CASE_ERROR=0\n  local TOTAL_KEYS=${#DICT_KEYS[@]}\n\
    \  if [ $TOTAL_KEYS -eq 0 ]; then\n    CASE_ERROR=1\n  else\n    for key in \"\
    ${DICT_KEYS[@]}\"; do\n      if [ \"$key\" == \"${key^^}\" ]; then\n        ((UPPER_COUNT++))\n\
    \      elif [ \"$key\" == \"${key,,}\" ]; then\n        ((LOWER_COUNT++))\n  \
    \    else\n        ((CASE_ERROR++))\n      fi\n    done\n    if [ $TOTAL_KEYS\
    \ -ne $UPPER_COUNT ] && [ $TOTAL_KEYS -ne $LOWER_COUNT ]; then\n      ((CASE_ERROR++))\n\
    \    fi\n  fi\n  if [ $CASE_ERROR -eq 0 ]; then\n    echo \"True\"\n  else\n \
    \   echo \"False\"\n  fi", "  local OLDIFS=$IFS\n  IFS=,\n  [ $# -eq 0 ] && {\
    \ IFS=$OLDIFS; return 1; }\n  while read -r key value; do\n    echo \"$key\" |\
    \ grep -q '[^a-z]' && { IFS=$OLDIFS; return 1; }\n  done < \"$1\"\n  IFS=$OLDIFS\n\
    \  return 0", "    # read the input CSV into the given shell variables\n    echo\
    \ \"Input CSV is $1\"\n    while IFS=, read -r key value\n    do\n        echo\
    \ \"$key is $value\"\n    done < $1", "    local key value\n    local all_lower_case=0\n\
    \    local all_upper_case=0\n    #Read in CSV, save first column to key, save\
    \ second column to value\n    while IFS=, read -r key value; do\n        #For\
    \ each key, check upper and lower case conditionals\n        [[ $key =~ ^[a-z]+$\
    \ ]] && all_lower_case=1 || all_lower_case=0\n        [[ $key =~ ^[A-Z]+$ ]] &&\
    \ all_upper_case=1 || all_upper_case=0\n    done < <(echo \"$1\")\n    #If the\
    \ key is all lower or all upper, return true. else false.\n    if [ $all_lower_case\
    \ -eq 1 ] || [ $all_upper_case -eq 1 ]; then\n        echo \"True\"\n    else\n\
    \        echo \"False\"\n    fi", "\tlocal IFS=\",\"\n\tlocal key=\"\"\n\tlocal\
    \ value=\"\"\n\tlocal dict=\"\"\n\tlocal upper=\"\"\n\tlocal lower=\"\"\n\tlocal\
    \ counter=\"\"\n\twhile read -r key value; do\n\t\t# If the key is already in\
    \ the dict, then the dict is not OK.\n\t\t[[ -z $dict ]] || { [[ \"$dict\" ==\
    \ *${key}* ]] && echo false && return; }\n\t\tdict+=\"${key}${value}\"\n\t\t#\
    \ Try to see if the key is a number.\n\t\tif [[ $key =~ ^-?[0-9]+$ ]]; then\n\t\
    \t\techo false\n\t\t\treturn\n\t\tfi\n\t\t# If this key is upper case, add a uppercase\
    \ char to the upper str.\n\t\tif [[ $key =~ ^[A-Z]+$ ]]; then\n\t\t\tupper+=\"\
    U\"\n\t\telse\n\t\t\tlower+=\"L\"\n\t\tfi\n\t\tcounter=\"${counter}1\"\n\tdone\
    \ < <(echo \"$1\")\n\t# If all keys were upper case, then upper str should be\
    \ exactly as long\n\t# as the counter and lower str should be empty.  Likewise,\
    \ if all keys\n\t# were lower case, then the lower str should be exactly as long\
    \ as the\n\t# counter and the upper str should be empty.\n\tif [[ \"${#upper}\"\
    \ == \"${#counter}\" ]] && [[ -z \"$lower\" ]]; then\n\t\techo true\n\telif [[\
    \ \"${#lower}\" == \"${#counter}\" ]] && [[ -z \"$upper\" ]]; then\n\t\techo true\n\
    \telse\n\t\techo false\n\tfi", "  [[ $# -eq 0 ]] && return 2\n  local dictfile=\"\
    $1\"\n  local dict=()\n  while IFS=',' read -r k v; do\n    dict[k]=$v\n  done\
    \ < $dictfile\n  echo \"Dict: ${dict[@]}\"\n  local key\n  for key in \"${!dict[@]}\"\
    ; do\n    [[ $key =~ [a-z] ]] && local lowkeys=1 || local uppkeys=1\n  done\n\
    \  if [[ -n $lowkeys && -n $uppkeys ]]; then\n    return 1\n  else\n    return\
    \ 0\n  fi", "    # If the input has rows, then ...\n    if [ $# -eq 1 ] && [ -f\
    \ $1 ]; then\n        # Convert the two column CSV to a Python dictionary\n  \
    \      input_dict=$(awk -F, '{print $1, $2}' $1 | python -c \"import sys; print\
    \ '{' + ','.join(','.join(i.split()) for i in sys.stdin.readlines()) + '}'\")\n\
    \        # If all the keys are lower case ...\n        if [ \"$input_dict\" ==\
    \ \"$(echo \"$input_dict\" | tr '[:upper:]' '[:lower:]')\" ]; then\n         \
    \   echo True\n        # If all the keys are upper case ...\n        elif [ \"\
    $input_dict\" == \"$(echo \"$input_dict\" | tr '[:lower:]' '[:upper:]')\" ]; then\n\
    \            echo True\n        else\n            echo False\n        fi\n   \
    \ else\n        echo False\n    fi", "\ttypeset k v\n\ttypeset -a upper lower\n\
    \ttypeset -i upper_count=0 lower_count=0\n\ttypeset -i lower_defined=0 upper_defined=0\n\
    \ttypeset -i upper_space=0 lower_space=0\n\n\twhile read k v; do\n\t\t[[ \"$k\"\
    \ =~ ^[[:upper:]] ]] && upper[upper_count++]=\"$k\" && upper_defined=1\n\t\t[[\
    \ \"$k\" =~ ^[[:lower:]] ]] && lower[lower_count++]=\"$k\" && lower_defined=1\n\
    \t\t[[ \"$k\" =~ [[:space:]] ]] && upper_space=1\n\t\t[[ \"$k\" =~ [[:space:]]\
    \ ]] && lower_space=1\n\tdone < <(tr , ' ' <<< \"$1\")\n\n\tif (( (upper_defined\
    \ && lower_defined) || upper_space || lower_space )); then\n\t\treturn 1\n\telif\
    \ (( upper_defined && lower_count == 0 )); then\n\t\treturn 0\n\telif (( lower_defined\
    \ && upper_count == 0 )); then\n\t\treturn 0\n\telse\n\t\treturn 1\n\tfi"]
stop_tokens:
- "\n}"
