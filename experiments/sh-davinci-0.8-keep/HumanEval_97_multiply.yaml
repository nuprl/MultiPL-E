name: HumanEval_97_multiply
language: sh
prompt: "#!/bin/bash\n# Complete the function that takes two integers and returns\
  \ \n# the product of their unit digits.\n# Assume the input is always valid.\n#\
  \ Examples:\n# multiply(148, 412) should return 16.\n# multiply(19, 28) should return\
  \ 72.\n# multiply(2020, 1851) should return 0.\n# multiply(14,-15) should return\
  \ 20.\n#\n# $1 is an integer\n# $2 is an integer\nmultiply() {\n"
tests: "}\n\ncandidate() {\n    multiply \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"148\" \"412\") = \"16\" ]]\n    [[ $(candidate \"19\" \"28\") =\
  \ \"72\" ]]\n    [[ $(candidate \"2020\" \"1851\") = \"0\" ]]\n    [[ $(candidate\
  \ \"14\" \"-15\") = \"20\" ]]\n    [[ $(candidate \"76\" \"67\") = \"42\" ]]\n \
  \   [[ $(candidate \"17\" \"27\") = \"49\" ]]\n    [[ $(candidate \"0\" \"1\") =\
  \ \"0\" ]]\n    [[ $(candidate \"0\" \"0\") = \"0\" ]]\n}\n\nrun_test"
completions: ["  local num1=$1\n  local num2=$2\n  local ans=1\n  if [[ $num1 -lt\
    \ 0 ]]; then\n    num1=$(( $num1 * -1 ))\n  fi\n  if [[ $num2 -lt 0 ]]; then\n\
    \    num2=$(( $num2 * -1 ))\n  fi\n  for i in {1..10}; do\n    if [[ $num1 -eq\
    \ $i ]]; then\n      num1=$i\n    fi\n    if [[ $num2 -eq $i ]]; then\n      num2=$i\n\
    \    fi\n  done\n  (( ans = num1 * num2 ))\n  echo $ans", "  local str=$(echo\
    \ $1 $2 | tr -d -c '[:digit:]')\n  echo $str | sed 's/./&\\n/g' | awk '{s*=$1}\
    \ END {print s}'", "  local -i n=$1 m=$2\n  n=${n#${n%%[!0]*}}\n  m=${m#${m%%[!0]*}}\n\
    \  (( n * m ))", "    integer1=${1//-/}\n    integer2=${2//-/}\n    echo $(( integer1\
    \ % 10 * integer2 % 10 ))", "    local units\n    units=$(( $1 % 10 ))\n    units=$((\
    \ units * ( $2 % 10 ) ))\n    echo $units", "  # your code goes here\n  local\
    \ num1=$1\n  local num2=$2\n  if [ $num1 -lt 0 ]; then\n    num1=$(( -num1 ))\n\
    \  fi\n  if [ $num2 -lt 0 ]; then\n    num2=$(( -num2 ))\n  fi\n  local res=$((\
    \ num1%10 * num2%10 ))\n  echo $res", "  local a=$1\n  local b=$2\n  local a_unit=$(echo\
    \ $a|sed 's/^[^0-9]*//'|sed 's/[^0-9]*$//')\n  local b_unit=$(echo $b|sed 's/^[^0-9]*//'|sed\
    \ 's/[^0-9]*$//')\n  echo $((a_unit*b_unit))", "\t# we need to eliminate the plus\
    \ and minus signs first\n\targ1=${1//-/}\n\targ2=${2//-/}\n\t# the multiplication\
    \ can be done by chaining the \n\t# last digits together, then adding a 0 for\
    \ every\n\t# position of the answer\n\techo $((arg1 % 10 * arg2 % 10))$(perl -E\
    \ \"say '0' x ($# - $#)\")", "  if [[ $1 -eq 0 || $2 -eq 0 ]]; then\n    echo\
    \ 0\n  else\n    echo $(( $(echo $1 | tail -c1) * $(echo $2 | tail -c1) ))\n \
    \ fi", "    # Write code here\n    # 4. if the number is negative, print the number\
    \ with a negative sign\n    if [ $1 -lt 0 ]; then\n        let \"num1=0-$1\"\n\
    \    else\n        let \"num1=$1\"\n    fi\n    if [ $2 -lt 0 ]; then\n      \
    \  let \"num2=0-$2\"\n    else\n        let \"num2=$2\"\n    fi\n    # 1. get\
    \ the last digit\n    let \"last1=$num1%10\"\n    let \"last2=$num2%10\"\n   \
    \ # 2. get the product of the digits\n    let \"result=$last1*$last2\"\n    #\
    \ 3. print the product\n    echo $result", "  # Fill me in\n  # Write your code\
    \ here...\n  echo $(( ($1 % 10) * ($2 % 10) ))", "    echo $(( $(echo $1 | grep\
    \ -o '[0-9]$') * $(echo $2 | grep -o '[0-9]$') ))", '  expr $1 \* $2;', "\t# get\
    \ the last number\n\tlet a=${1: -1}\n\tlet b=${2: -1}\n\t# multiply\n\tlet result=$a*$b\n\
    \t# return result\n\techo $result", "  # Insert your code here\n  echo -n $((\
    \ $1%10 * $2%10 ))", "  local product=$(($1 * $2))\n  if [[ $product -gt 0 ]];\
    \ then\n    echo $(echo $product | grep -o .)\n  else\n    echo $product | grep\
    \ -o . | sed -e 's/^-//' | tac | tr -d '\\n'\n  fi", '  echo $(( ($1 % 10) * ($2
    % 10) ))', "\tlocal a=$1\n\tlocal b=$2\n\techo $(($a % 10 * $b % 10))", "  #your\
    \ code here\n  echo $1 | grep -q \"-\"\n  if [ $? -eq 0 ]; then\n    num1=${1//-/}\n\
    \    sign=\"-\"\n  else\n    num1=$1\n    sign=\"\"\n  fi\n  echo $2 | grep -q\
    \ \"-\"\n  if [ $? -eq 0 ]; then\n    num2=${2//-/}\n    sign2=\"-\"\n  else\n\
    \    num2=$2\n    sign2=\"\"\n  fi\n  echo $num1 | grep -q \".\"\n  if [ $? -eq\
    \ 0 ]; then\n    num1=${num1//./}\n  fi\n  echo $num2 | grep -q \".\"\n  if [\
    \ $? -eq 0 ]; then\n    num2=${num2//./}\n  fi\n  unit_digit1=${num1: -1}\n  unit_digit2=${num2:\
    \ -1}\n  echo \"$sign$sign2$((unit_digit1 * unit_digit2))\"", '    echo $(( $1%10
    * $2%10 ))']
stop_tokens:
- "\n}"
