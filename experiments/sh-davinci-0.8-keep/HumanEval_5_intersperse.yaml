name: HumanEval_5_intersperse
language: sh
prompt: "#!/bin/bash\n# Insert a number 'delimeter' between every two consecutive\
  \ elements of input list `numbers'\n# >>> intersperse([], 4)\n# []\n# >>> intersperse([1,\
  \ 2, 3], 4)\n# [1, 4, 2, 4, 3]\n#\n# $1 is a space-separated list\n# $2 is an integer\n\
  intersperse() {\n"
tests: "}\n\ncandidate() {\n    intersperse \"$@\"\n}\n\nset -e\nrun_test() {\n  \
  \  [[ $(candidate \"\" \"7\") = \"\" ]]\n    [[ $(candidate \"5 6 3 2\" \"8\") =\
  \ \"5 8 6 8 3 8 2\" ]]\n    [[ $(candidate \"2 2 2\" \"2\") = \"2 2 2 2 2\" ]]\n\
  }\n\nrun_test"
completions: ["    if [ $# -ne 2 ]; then\n        echo \"Usage: intersperse [<list>\
    \ <delimeter>]\"\n        return 1\n    fi\n\n    delim=$2\n    first=true\n \
    \   output=\"\"\n    for n in $1; do\n        if $first; then\n            first=false\n\
    \        else\n            output=\"$output $delim\"\n        fi\n        output=\"\
    $output $n\"\n    done\n    echo $output", "    if [ $# -ne 2 ]; then\n      \
    \  echo \"You must input two arguments to function intersperse\"\n        exit\
    \ 1\n    fi\n    n=$(echo $1 | wc -w)\n    if [ $n -lt 1 ]; then\n        echo\
    \ $1\n        return\n    fi\n    if [ $n -eq 1 ]; then\n        echo $1 $2\n\
    \        return\n    fi\n    for i in $(seq 1 $(($n-1))); do\n        echo -n\
    \ $(echo $1 | cut -d' ' -f$i) ' '\n        echo -n $2 ' '\n    done\n    echo\
    \ $(echo $1 | cut -d' ' -f$n)", "    local numbers=$1\n    local delimeter=$2\n\
    \    if [ -z \"$numbers\" ]; then\n        echo \"\"\n    else\n        local\
    \ first=$(echo \"$numbers\" | head -n 1)\n        local rest=$(echo \"$numbers\"\
    \ | tail -n +2)\n        local rest_interspersed=$(intersperse \"$rest\" \"$delimeter\"\
    )\n        echo -n \"$first $delimeter $rest_interspersed\"\n    fi", "  if [\
    \ -z \"$1\" ]; then\n    echo \"[]\"\n  else\n    # Append 4 to each element of\
    \ [1, 2, 3]\n    echo \"$1\" | sed -E \"s/[[:digit:]]+/$& $2/g\" | sed -E \"s/\
    \ $2$//\"\n  fi", "    # `sort -n' sorts the input numerically. The output, however,\
    \ is not separated by spaces\n    sorted=`sort -n <<< $1`\n    # `fold -s' is\
    \ used to fold the input at each space, turning the list into a single line\n\
    \    folded=`fold -s <<< $sorted`\n    # `tr -s' deletes every space in the input,\
    \ leaving just the numbers\n    list=`tr -s ' ' <<< $folded`\n    result=''\n\
    \    for number in $list; do\n        if [ -z \"$result\" ]; then\n          \
    \  result=$number\n        else\n            result=$result' '$2' '$number\n \
    \       fi\n    done\n    echo $result", "    list=()\n    for n in $1; do\n \
    \       list+=($n)\n        list+=($2)\n    done\n    echo ${list[@]}", "    if\
    \ [ $# -ne 2 ]; then\n        echo \"Need exactly two arguments\"\n        return\
    \ 1\n    fi\n    local numbers=\"$1\"\n    local delimeter=\"$2\"\n    local result=\"\
    \"\n    for n in $numbers; do\n        if [ -z \"$result\" ]; then\n         \
    \   result=\"$n\"\n        else\n            result=\"$result $delimeter $n\"\n\
    \        fi\n    done\n    echo \"$result\"", "  numbers=$1\n  delimeter=$2\n\
    \  if [ -z \"$numbers\" ]; then\n    echo \"\"\n  else\n    echo -n \"${numbers%%\
    \ *}\"\n    rest=$(echo \"$numbers\" | cut -d' ' -f2-)\n    if [ -n \"$rest\"\
    \ ]; then\n      for n in $rest; do\n        echo -n \" $delimeter $n\"\n    \
    \  done\n    fi\n  fi", "    local numbers=\"$1\"\n    local delimiter=\"$2\"\n\
    \    if [ -z \"$numbers\" ]; then\n        echo \"$numbers\"\n    else\n     \
    \   echo -n \"${numbers%% *}\"\n        local rest=\"${numbers#* }\"\n       \
    \ while [ \"$rest\" != \"$numbers\" ]; do\n            echo -n \"$delimiter\"\n\
    \            echo -n \"${rest%% *}\"\n            numbers=\"$rest\"\n        \
    \    rest=\"${rest#* }\"\n        done\n    fi", "    local list=$1; shift\n \
    \   local delim=$1; shift\n    echo -n \"$list\" | sed \"s/\\([0-9]\\+\\)/\\1\
    \ $delim /g\" | sed \"s/\\($delim \\)\\+$//\"", "    local list=$1\n    local\
    \ n=$2\n    local result=\"\"\n    for e in $list; do\n        if [ -z \"$result\"\
    \ ]; then\n            result=$e\n        else\n            result=$result' '$n'\
    \ '$e\n        fi\n    done\n    echo $result", "  local delim=\"$2\"\n  local\
    \ numbers=\"$1\"\n  local new_numbers=\"\"\n  for number in $numbers; do\n   \
    \ new_numbers=\"$new_numbers $number $delim\"\n  done\n  echo \"${new_numbers%\
    \ $delim}\"", "    local numbers=$1\n    local delimeter=$2\n    if [ -z \"$numbers\"\
    \ ]; then\n        echo \"\"\n    else\n        echo -n \"${numbers%% *}\"\n \
    \       numbers=${numbers#* }\n        while [ \"$numbers\" != \"${numbers#* }\"\
    \ ]; do\n            echo -n \"$delimeter${numbers%% *}\"\n            numbers=${numbers#*\
    \ }\n        done\n        echo\n    fi", "  if [ \"$1\" != \"\" ]; then\n   \
    \ echo -n \"${1%% *}\"\n    shift\n    for i in \"$@\"; do\n      echo -n \" $2\
    \ $i\"\n    done\n  fi", "    local numbers=(\"$@\")\n    local delimeter=${numbers[-1]}\n\
    \    numbers=(\"${numbers[@]:0:${#numbers[@]}-1}\")\n\n    local string\n    for\
    \ num in \"${numbers[@]}\"; do\n        if [ -z \"$string\" ]; then\n        \
    \    string=\"$num\"\n        else\n            string=\"$string$delimeter$num\"\
    \n        fi\n    done\n\n    echo \"$string\"", "    numbers=\"$1\"\n    delimeter=\"\
    $2\"\n    output=\"\"\n    # don't add delimeter if numbers is empty\n    if [\
    \ -z \"$numbers\" ]; then\n        echo \"\"\n        return\n    fi\n    for\
    \ number in $numbers; do\n        if [ -z \"$output\" ]; then\n            output=$number\n\
    \        else\n            output=\"$output $delimeter $number\"\n        fi\n\
    \    done\n    echo \"$output\"", "    numbers=($1)\n    delimeter=$2\n    if\
    \ [ ${#numbers[@]} -le 1 ]; then\n        echo \"${numbers[@]}\"\n    else\n \
    \       for i in \"${numbers[@]}\"; do\n            echo -n \"$i $delimeter \"\
    \n        done\n        echo \"${numbers[-1]}\"\n    fi", "    local numbers\n\
    \    local i\n    numbers=($1)\n    i=0\n    while [ $i -lt ${#numbers[@]} ];\
    \ do\n        echo ${numbers[$i]}\n        ((i++))\n        if [ $i -lt ${#numbers[@]}\
    \ ]; then\n            echo $2\n        fi\n    done", "    local numbers=($1)\n\
    \    local delimeter=$2\n    for i in $(seq 1 $((${#numbers[@]} - 1))); do\n \
    \       numbers[$i]=${numbers[$i]}${delimeter}\n    done\n    echo ${numbers[@]}",
  "    IFS=\"$1\" read -r -a array <<< \"$2\"\n    result=()\n    for (( i=0; i<${#array[@]};\
    \ i++ )); do\n        if [[ $i -ne 0 ]]; then\n            result+=($3)\n    \
    \    fi\n        result+=(${array[$i]})\n    done\n    echo \"${result[@]}\""]
stop_tokens:
- "\n}"
