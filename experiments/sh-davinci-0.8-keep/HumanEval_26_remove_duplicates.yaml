name: HumanEval_26_remove_duplicates
language: sh
prompt: "#!/bin/bash\n# From a list of integers, remove all elements that occur more\
  \ than once.\n# Keep order of elements left the same as in the input.\n# >>> remove_duplicates([1,\
  \ 2, 3, 2, 4])\n# [1, 3, 4]\n#\n# $1 is a space-separated list\nremove_duplicates()\
  \ {\n"
tests: "}\n\ncandidate() {\n    remove_duplicates \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"1 2 3 4\") = \"1 2\
  \ 3 4\" ]]\n    [[ $(candidate \"1 2 3 2 4 3 5\") = \"1 4 5\" ]]\n}\n\nrun_test"
completions: ["    local dict\n    for x in $1; do\n        dict[$x]=0\n    done\n\
    \    for x in $1; do\n        dict[$x]=$(( dict[$x] + 1 ))\n    done\n    for\
    \ x in $1; do\n        if [ ${dict[$x]} -eq 1 ]; then\n            echo -n \"\
    $x \"\n        fi\n    done\n    echo", "   awk 'BEGIN {split(\"'\"$1\"'\", a,\
    \ \" \")} {if (!duplicates[$1]) duplicates[$1] = 1; else duplicates[$1] = duplicates[$1]\
    \ + 1} END {for (k in duplicates) if (duplicates[k] == 1) print k}'", "\t# If\
    \ a non-unique value is in the current value of the string,\n\t# filter it out\n\
    \tfor i in $1; do\n\t\tgrep -v $i <<< $2 | grep -q $i &&\n\t\t\tcontinue\n\t\t\
    if [ -z \"$result\" ]; then\n\t\t\tresult=$i\n\t\telse\n\t\t\tresult=\"$result\
    \ $i\"\n\t\tfi\n\tdone\n\techo $result", "    for number in $1; do\n        echo\
    \ $number\n    done | sort | uniq -u", "    echo $1 | tr ' ' '\\n' | awk '!x[$0]++'",
  "  declare -A visited\n  result=''\n  for word in $1; do\n    if [[ -z ${visited[$word]}\
    \ ]]; then\n      result=\"$result $word\"\n      visited[$word]=1\n    fi\n \
    \ done\n  echo $result", '    echo $1 | tr " " "\n" | sort | uniq -u | tr "\n"
    " "', '  echo $1 | tr " " "\n" | uniq -u | tr "\n" " "', "    echo \"$1\" | awk\
    \ '\n        {\n            for (i = 1; i <= NF; i++) {\n                if (!a[$i]++)\
    \ {\n                    printf(\"%s%s\", $i, (i == NF ? \"\" : \" \"))\n    \
    \            }\n            }\n        }\n    '", "  echo $(echo $1 | tr ' ' '\\\
    n' | sort | uniq -u | tr '\\n' ' ')", "    if [[ \"$1\" ]]; then\n        local\
    \ -a array=(${@// / })\n        local index=0\n        while (( ${#array[@]} >\
    \ index )); do\n            local target_item=${array[$index]}\n            local\
    \ count=0\n            local tmp_index=0\n            while (( ${#array[@]} >\
    \ tmp_index )); do\n                local current_item=${array[$tmp_index]}\n\
    \                if [[ \"$target_item\" == \"$current_item\" ]]; then\n      \
    \              (( count++ ))\n                fi\n                (( tmp_index++\
    \ ))\n            done\n            if (( $count > 1 )); then\n              \
    \  unset array[$index]\n            fi\n            (( index++ ))\n        done\n\
    \        printf \"%s \" \"${array[@]}\"\n    fi", '  printf "%s\n" $1 | sort |
    uniq -u', "\tlocal a=($1)\n\tlocal out=($(echo \"${a[@]}\" | tr ' ' '\\n' | sort\
    \ -u))\n\techo \"${out[@]}\"", "\tlocal values=(${1// / })\n\tlocal unique_values=()\n\
    \tfor value in \"${values[@]}\"; do\n\t\tif [[ ! \" ${unique_values[@]} \" =~\
    \ \" ${value} \" ]]; then\n\t\t\tunique_values+=($value)\n\t\tfi\n\tdone\n\techo\
    \ \"${unique_values[@]}\"", "  awk '!(x[$0]++)'", "    local -n array=$1\n   \
    \ local result=()\n    local is_new=true\n    for element in \"${array[@]}\";\
    \ do\n        for item in \"${result[@]}\"; do\n            if [[ \"$item\" -eq\
    \ \"$element\" ]]; then\n                is_new=false\n                break\n\
    \            fi\n        done\n        if [[ \"$is_new\" == true ]]; then\n  \
    \          result+=(\"$element\")\n        fi\n        is_new=true\n    done\n\
    \    echo \"${result[@]}\"", "  eval \"a=($1)\"\n\n  new_a=()\n  unique_array=()\n\
    \  for num in \"${a[@]}\"; do\n    # If not in the unique array, add to it and\
    \ to the new array\n    if ! is_in \"$num\" \"${unique_array[@]}\"; then\n   \
    \   unique_array+=(\"$num\")\n      new_a+=(\"$num\")\n    # Otherwise just add\
    \ it to the new array to keep order\n    else\n      new_a+=(\"$num\")\n    fi\n\
    \  done\n\n  echo \"${new_a[@]}\"", "  local list=$1\n  local newlist=$(echo $list\
    \ | tr ' ' '\\n' | sort | uniq -u | sort -n | tr '\\n' ' ')\n  echo $newlist",
  "  echo \"$1\" | awk '{print $1}' | awk 'BEGIN {RS=\" \";} {!i[$0]++}' | awk '{print\
    \ $1}'", "\tlocal -a arr=($1)\n\tlocal elem\n\tlocal index\n\tfor elem in \"${arr[@]}\"\
    ; do\n\t\tif [ \"$elem\" == \"0\" ]; then\n\t\t\tcontinue\n\t\tfi\n\t\tindex=$(\
    \ index_of \"$elem\" \"${arr[@]}\" )\n\t\tarr[$index]=0\n\tdone\n\tprint_nums\
    \ \"${arr[@]}\""]
stop_tokens:
- "\n}"
