name: HumanEval_131_digits
language: sh
prompt: "#!/bin/bash\n# Given a positive integer n, return the product of the odd\
  \ digits.\n# Return 0 if all digits are even.\n# For example:\n# digits(1)  == 1\n\
  # digits(4)  == 0\n# digits(235) == 15\n#\n# $1 is an integer\ndigits() {\n"
tests: "}\n\ncandidate() {\n    digits \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"5\") = \"5\" ]]\n    [[ $(candidate \"54\") = \"5\" ]]\n    [[ $(candidate \"\
  120\") = \"1\" ]]\n    [[ $(candidate \"5014\") = \"5\" ]]\n    [[ $(candidate \"\
  98765\") = \"315\" ]]\n    [[ $(candidate \"5576543\") = \"2625\" ]]\n    [[ $(candidate\
  \ \"2468\") = \"0\" ]]\n}\n\nrun_test"
completions: ["  local n=$1\n  local res=1\n  local digit\n\n  until [[ $n -eq 0 ]];\
    \ do\n    digit=$(( n % 10 ))\n    if [[ $(( digit % 2 )) -eq 1 ]]; then\n   \
    \   res=$(( res * digit ))\n    fi\n    n=$(( n / 10 ))\n  done\n\n  echo $res",
  "  local -i arg=$1 num=0 prod=1\n  (( arg < 0 )) && arg=-arg\n  while (( arg ));\
    \ do\n    (( num = arg % 10 ))\n    (( num & 1 )) && (( prod *= num ))\n    ((\
    \ arg /= 10 ))\n  done\n  echo $prod", "  local sum=1\n  local mod=0\n  local\
    \ num=$1\n  local pos=0\n  for ((i=10; i<=$num; i*=10)); do\n    pos=$(($num%$i))\n\
    \    if [ $pos -ne 0 ]; then\n      num=$(($num-$pos))\n      mod=$(($pos%10))\n\
    \      if [ $mod -ne 0 ]; then\n        if [ $(($mod%2)) -ne 0 ]; then\n     \
    \     sum=$(($sum*$mod))\n        fi\n      fi\n    fi\n  done\n  echo $sum",
  "    n=$1\n    (( n < 0 )) && n=$((-n))\n    echo $n | sed 's/[02468]//g' | tr -d\
    \ '\\n' | sed 's/^0*//' | awk '{if (length($0)>0) {print $0} else {print 0}}'",
  "    local -i n=$1\n    local -i prod=1\n    for (( i=0; i<${#n}; i++ )); do\n \
    \       if (( ${n:$i:1} % 2 != 0 )); then\n            (( prod *= ${n:$i:1} ))\n\
    \        fi\n    done\n    echo $prod", "  local digits=$1\n  local sum=1\n  #\
    \ strip the minus sign\n  if [ $digits -lt 0 ]; then\n    digits=$(( -digits ))\n\
    \  fi\n  # iterate over each digit\n  for digit in $(echo $digits | sed 's/./&\
    \ /g'); do\n    # skip even digits\n    if [ $(( digit % 2 )) -eq 0 ]; then\n\
    \      continue\n    fi\n    # multiply by odd digits\n    sum=$(( sum * digit\
    \ ))\n  done\n  echo $sum", "  local n=$1\n  local product=1\n  local digit\n\
    \  while [ $n -gt 0 ]; do\n    digit=$(( n % 10 ))\n    [ $(( digit % 2 )) -eq\
    \ 1 ] && product=$(( product * digit ))\n    n=$(( n / 10 ))\n  done\n  echo $product",
  "    local num=${1//[^13579]/}\n    local result=1\n    for i in $(echo ${num//\
    \ /}); do\n        let result*=$i\n    done\n    echo $result", "    local -i\
    \ result=1\n    for (( i=0; i<${#1}; i++ )); do\n        (( ${1:$i:1} % 2 == 1\
    \ )) && result=$((result * ${1:$i:1}))\n    done\n    echo $result", "  local\
    \ s=$(echo $1 | grep -o . | grep -v 0 | grep -v 2 | grep -v 4 | grep -v 6 | grep\
    \ -v 8 | tr -d \"\\n\")\n  echo ${s:-0} | awk '{for(i=1;i<=NF;i++)p*=$i}END{print\
    \ p}'", "  local product=1\n  if [ $1 -eq 0 ]; then\n    echo 0\n  else\n    for\
    \ i in `echo $1 | sed 's/./& /g'`; do\n      if [ `expr $i % 2` -ne 0 ]; then\n\
    \        product=`expr $product \\* $i`\n      fi\n    done\n    echo $product\n\
    \  fi", "    sum=1\n    for ((i=0; i<${#1}; i++)); do\n        c=${1:$i:1}\n \
    \       if ((c % 2)); then\n            sum=$((sum * c))\n        fi\n    done\n\
    \    echo $sum", "    local -i num=\"$1\"   # integer only\n    local -i sum=1\n\
    \    local -i even=0\n    while (( num )); do\n        local -i i=$(( num % 10\
    \ ))\n        if (( i % 2 == 0 )); then\n            (( even++ ))\n        else\n\
    \            (( sum *= i ))\n        fi\n        (( num /= 10 ))\n    done\n \
    \   (( even == 0 )) && return $sum || return 0", "    if [[ $1 =~ ^[0-9]+$ ]];\
    \ then\n        local sum=1\n        while [[ $1 -gt 0 ]]; do\n            local\
    \ digit=$(( $1 % 10 ))\n            if [[ $digit -ne 0 && $digit%2 -ne 0 ]]; then\n\
    \                sum=$(( $sum * $digit ))\n            fi\n            local n=$((\
    \ $1 / 10 ))\n            let 1=$n\n        done\n        echo $sum\n    else\n\
    \        echo \"error: $1 is not an integer\" >&2\n        return 1\n    fi",
  "  re='^[0-9]+$'\n  if ! [[ $1 =~ $re ]] ; then\n    echo \"error: Not a number\"\
    \ >&2; exit 1\n  fi\n  local -i q=0\n  while [[ $1 -gt 0 ]]; do\n    local -i\
    \ r=$(( $1 % 10 ))\n    (( $r % 2 != 0 )) && (( q = q * 10 + r ))\n    (( $1 /=\
    \ 10 ))\n  done\n  echo $q", "  nums=$(echo \"$1\" | grep -o . | grep -Eo '[13579]')\n\
    \  total=1\n  for num in ${nums[@]}; do\n    total=$((total * num))\n  done\n\
    \  echo $total", "  local a\n  local product=1\n  a=$(echo \"$1\" | sed 's/\\\
    (.\\)/\\1 /g')\n  for i in $a; do\n    if [ $((i % 2)) -ne 0 ]; then\n      product=$((product\
    \ * i))\n    fi\n  done\n  echo $product", "  # Your code goes here:\n  \n  local\
    \ input=\"$1\"\n  local sum=1\n  local mod=0\n  while [ $input -gt 0 ]; do\n \
    \  mod=$((input%10))\n   if [ $((mod%2)) -ne 0 ]; then\n     ((sum*=mod))\n  \
    \ fi\n   input=$((input/10))\n  done\n  echo $sum", "  echo $1 | grep -Eo [13579]\
    \ | paste -sd'*' | bc", "    local -i n=$1\n    local -i prod=1\n    local -i\
    \ digit\n    while (( n > 0 )); do\n        digit=$(( n % 10 ))\n        if ((\
    \ digit % 2 )); then\n            (( prod *= digit ))\n        fi\n        ((\
    \ n /= 10 ))\n    done\n    echo $prod"]
stop_tokens:
- "\n}"
