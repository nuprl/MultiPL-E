name: HumanEval_115_max_fill
language: sh
prompt: "#!/bin/bash\n# You are given a rectangular grid of wells. Each row represents\
  \ a single well,\n# and each 1 in a row represents a single unit of water.\n# Each\
  \ well has a corresponding bucket that can be used to extract water from it, \n\
  # and all buckets have the same capacity.\n# Your task is to use the buckets to\
  \ empty the wells.\n# Output the number of times you need to lower the buckets.\n\
  # Example 1:\n# Input: \n# grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n# bucket_capacity\
  \ : 1\n# Output: 6\n# Example 2:\n# Input: \n# grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]]\n# bucket_capacity : 2\n# Output: 5\n# Example 3:\n# Input: \n# grid\
  \ : [[0,0,0], [0,0,0]]\n# bucket_capacity : 5\n# Output: 0\n# Constraints:\n# *\
  \ all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
  \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\n#\n# $1 is a newline-separated,\
  \ space-separated list\n# $2 is an integer\nmax_fill() {\n"
tests: "}\n\ncandidate() {\n    max_fill \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"0 0 1 0\\n0 1 0 0\\n1 1 1 1\" \"1\") = \"6\" ]]\n    [[ $(candidate\
  \ \"0 0 1 1\\n0 0 0 0\\n1 1 1 1\\n0 1 1 1\" \"2\") = \"5\" ]]\n    [[ $(candidate\
  \ \"0 0 0\\n0 0 0\" \"5\") = \"0\" ]]\n    [[ $(candidate \"1 1 1 1\\n1 1 1 1\"\
  \ \"2\") = \"4\" ]]\n    [[ $(candidate \"1 1 1 1\\n1 1 1 1\" \"9\") = \"2\" ]]\n\
  }\n\nrun_test"
completions: ["    local -i max=0 i\n    local arr=( $1 )\n    for ((i=0; i<${#arr[@]};\
    \ i++)); do\n        (( max < arr[i] )) && max=${arr[i]}\n    done\n    echo $max",
  "    local bucket_capacity=$2\n    local bucket_fill=0\n    local output=0\n   \
    \ local max_fill=0\n    local row\n    local col\n    for row in $1; do\n    \
    \    col=0\n        for col in $row; do\n            bucket_fill=$((bucket_fill\
    \ + col))\n            if [[ $bucket_fill -gt $bucket_capacity ]]; then\n    \
    \            output=$((output + 1))\n                max_fill=$((max_fill - bucket_capacity))\n\
    \                bucket_fill=$max_fill\n            fi\n        done\n       \
    \ max_fill=$bucket_fill\n        bucket_fill=0\n    done\n    if [[ $max_fill\
    \ -ne 0 ]]; then\n        output=$((output + 1))\n    fi\n    echo $output", " \
    \   local grid=$1\n    local bucket_capacity=$2\n    local width=$(echo \"$grid\"\
    \ | head -n 1 | wc -w)\n    local height=$(echo \"$grid\" | wc -l)\n    local\
    \ fill_level=0\n    local num_fills=0\n    while true; do\n        # Find the\
    \ row with the max fill level\n        local max_fill_level=0\n        local row_with_max_fill=0\n\
    \        local idx=0\n        while read -r line; do\n            local fill_level_in_row=$(echo\
    \ \"$line\" | grep -o 1 | wc -l)\n            if ((fill_level_in_row > max_fill_level));\
    \ then\n                max_fill_level=$fill_level_in_row\n                row_with_max_fill=$idx\n\
    \            fi\n            idx=$((idx+1))\n        done <<< \"$grid\"\n    \
    \    # Fill the bucket up to the max fill level\n        local fill_amount=$((max_fill_level\
    \ - fill_level))\n        local bucket_to_fill=$((fill_amount > bucket_capacity\
    \ ? bucket_capacity : fill_amount))\n        fill_level=$((fill_level + bucket_to_fill))\n\
    \        num_fills=$((num_fills + 1))\n        # Redistribute the water\n    \
    \    local new_grid=\"\"\n        local row_idx=0\n        while read -r line;\
    \ do\n            local new_line=\"\"\n            for ((i=0; i<width; i++));\
    \ do\n                local val=$(echo \"$line\" | cut -d' ' -f$((i+1)))\n   \
    \             if ((row_idx == row_with_max_fill)); then\n                    if\
    \ ((i < max_fill_level)); then\n                        val=0\n              \
    \      fi\n                else\n                    if ((i < fill_level)); then\n\
    \                        val=1\n                    fi\n                fi\n \
    \               new_line=\"$new_line $val\"\n            done\n            new_grid=\"\
    $new_grid$new_line\\n\"\n            row_idx=$((row_idx+1))\n        done <<<\
    \ \"$grid\"\n        grid=$(echo", "    readarray -t grid <<< \"$1\"\n    capacity=$2\n\
    \    if [ ${#grid[@]} -eq 0 ]; then\n        echo 0\n        return\n    fi\n\
    \    n_col=${#grid[0]}\n    fill_array $n_col\n    # fill all holes without further\
    \ drops\n    for ((i=0; i<n_col; i++)); do\n        # init to top row\n      \
    \  array[$i]=${grid[0]:$i:1}\n        for ((j=1; j<${#grid[@]}; j++)); do\n  \
    \          if [[ ${grid[$j]:$i:1} -eq 1 ]]; then\n                array[$i]=1\n\
    \            fi\n        done\n    done\n    for ((i=0; i<n_col; i++)); do\n \
    \       if [[ ${array[$i]} -eq 0 ]]; then\n            if [[ $capacity -eq 0 ]];\
    \ then\n                echo 0\n                return\n            fi\n     \
    \       # well is empty, fill it\n            array[$i]=1\n            capacity=$((capacity-1))\n\
    \        fi\n    done\n    n_drops=0\n    # we have filled all wells at least\
    \ to the first row\n    # go backwards, dropping as needed\n    for ((i=${#grid[@]}-1;\
    \ i>0; i--)); do\n        for ((j=0; j<n_col; j++)); do\n            # bucket\
    \ is empty\n            if [[ ${array[$j]} -eq 0 ]]; then\n                # only\
    \ drop the bucket if the well is full\n                if [[ ${grid[$i]:$j:1}\
    \ -eq 1 ]]; then\n                    array[$j]=1\n                    ((n_drops++))\n\
    \                fi\n            fi\n        done\n    done\n    echo $n_drops",
  "  local row=$1\n  local last\n  local fill=0\n  local count=0\n  local capacity=$2\n\
    \  for last in $row; do\n    (( last == 1 )) && (( fill++ ));\n    (( fill ==\
    \ capacity )) && (( count++ ));\n    (( fill == capacity )) && (( fill = 0 ));\n\
    \  done\n  echo $count", "    local fill=0\n    local row=\"\"\n    local col=\"\
    \"\n    local max_fill=0\n    local i=0\n    local j=0\n    while read row\n \
    \   do\n        if [[ ${#row} -gt $max_fill ]]\n        then\n            max_fill=${#row}\n\
    \        fi\n    done <<<\"$1\"\n    echo $max_fill", "  local grid=$1\n  local\
    \ capacity=$2\n  local width=`echo \"$grid\" | head -n 1 | wc -w`\n  local height=`echo\
    \ \"$grid\" | wc -l`\n  local depth=0\n  local line\n  for ((i=0; i<width; i++));\
    \ do\n    for ((j=0; j<height; j++)); do\n      line=`echo \"$grid\" | head -n\
    \ $(($j+1)) | tail -n 1`\n      if [[ `echo \"$line\" | cut -d ' ' -f $(($i+1))`\
    \ == '1' ]]; then\n        depth=$(($depth+1))\n      fi\n    done\n  done\n \
    \ # Scale down the depth based on the bucket capacity.\n  depth=$(($depth/$capacity))\n\
    \  if [[ $(($depth*$capacity)) -lt $depth ]]; then\n    depth=$(($depth+1))\n\
    \  fi\n  # As we drain each well, the minimum depth decreases by the well height.\n\
    \  echo $depth", "  local -n grid=$1\n  local bucket_capacity=$2\n  local w=0\
    \ e=0\n  local max_fill=0\n  local fill=0\n  local j=0\n  local p=0\n  local len=${#grid[@]}\n\
    \  # east-boundary\n  for (( j=0; j<len; j++ )); do\n    [[ ${grid[$j]} == 1 ]]\
    \ && e=$(( $e + 1 ))\n  done\n  # west-boundary\n  for (( j=0; j<len; j++ ));\
    \ do\n    [[ ${grid[$j]} == 1 ]] && fill=$(( $fill + 1 ))\n    if [[ $fill -eq\
    \ $bucket_capacity ]]; then\n      fill=0\n      p=$(( $p + 1 ))\n    elif [[\
    \ $fill -gt $bucket_capacity ]]; then\n      fill=0\n      w=$(( $w + 1 ))\n \
    \   fi\n  done\n  # north-boundary\n  for (( j=0; j<len; j++ )); do\n    fill=0\n\
    \    for (( k=0; k<len; k++ )); do\n      [[ ${grid[$k]:$j:1} == 1 ]] && fill=$((\
    \ $fill + 1 ))\n      if [[ $fill -eq $bucket_capacity ]]; then\n        fill=0\n\
    \        p=$(( $p + 1 ))\n      elif [[ $fill -gt $bucket_capacity ]]; then\n\
    \        fill=0\n        w=$(( $w + 1 ))\n      fi\n    done\n  done\n  # south-boundary\n\
    \  for (( j=0; j<len; j++ )); do\n    fill=0\n    for (( k=len-1; k>=0; k-- ));\
    \ do\n      [[ ${grid[$k]:$j:1} == 1 ]] && fill=$(( $fill + 1 ))\n      if [[\
    \ $fill -eq $bucket_capacity ]]; then\n        fill=0\n        p=$(( $p + 1 ))\n\
    \      elif [[ $fill -gt $bucket_capacity ]]; then\n        fill=0\n        w=$((\
    \ $w + 1 ))\n      fi\n    done\n ", "    local a;\n    local max=0;\n    while\
    \ read -r line; do\n        a=($line);\n        for v in \"${a[@]}\"; do\n   \
    \         if [[ $v -gt $max ]]; then\n                max=$v;\n            fi\n\
    \        done\n    done;\n    echo $max;", "  local capacity=\"$2\"\n  local -i\
    \ max_fill=0\n  local -i i=0\n  while read -r -a line\n  do\n    local -i fill=0\n\
    \    while [ $i -lt ${#line[@]} ]\n    do\n      (( fill += line[i] ))\n     \
    \ if [ $fill -ge $capacity ]\n      then\n        break\n      fi\n      (( i++\
    \ ))\n    done\n    if [ $fill -gt $max_fill ]\n    then\n      max_fill=$fill\n\
    \    fi\n    (( i = 0 ))\n  done <<< \"$1\"\n  echo $max_fill", "  local row_max=0\n\
    \  local row_sum=0\n  local row_len=0\n  local well=\n  while read line; do\n\
    \    row_len=${#line}\n    row_sum=0\n    for ((i=0; i<row_len; i++)); do\n  \
    \    well=${line:i:1}\n      ((row_sum+=well))\n    done\n    if ((row_sum>row_max));\
    \ then\n      row_max=$row_sum\n    fi\n  done\n  echo $row_max", "    local grid=${1//\
    \ /}\n    local cap=$2\n    local num_rows=$(wc -l <<< \"$grid\")\n    local num_cols=$(wc\
    \ -L <<< \"$grid\")\n    local row=0\n    local col=0\n    local fill_count=0\n\
    \    local num_dropped=0\n    while true; do\n        # find the next filled well\n\
    \        local next_col=$col\n        while (( next_col < num_cols )); do\n  \
    \          local l=${grid:row*num_cols+next_col:1}\n            if (( l )); then\n\
    \                break\n            fi\n            next_col=$(( next_col + 1\
    \ ))\n        done\n        # fill buckets at the top of the column\n        if\
    \ (( next_col >= num_cols )); then\n            break\n        fi\n        for\
    \ (( i = 0; i < cap; i++ )); do\n            (( grid[row*num_cols+next_col] ))\
    \ && (( fill_count++ ))\n            row=$(( row + 1 ))\n            (( row >=\
    \ num_rows )) && row=0\n        done\n        # drop buckets at the bottom of\
    \ the column\n        col=$next_col\n        for (( i = 0; i < cap; i++ )); do\n\
    \            (( grid[row*num_cols+col] )) && (( num_dropped++ ))\n           \
    \ row=$(( row - 1 ))\n            (( row < 0 )) && row=$(( num_rows - 1 ))\n \
    \       done\n        (( num_dropped == 0 )) && break\n        num_dropped=0\n\
    \    done\n    echo $fill_count", "    local grid=($1)\n    local bucket_capacity=$2\n\
    \    local total_fills=0\n    local min_fill=0\n    for row in ${grid[@]}; do\n\
    \        local fill=0\n        for cell in ${row[@]}; do\n            if [[ $cell\
    \ == \"1\" ]]; then\n                fill=$((fill+1))\n            fi\n      \
    \  done\n        if [[ $fill -gt $min_fill ]]; then\n            min_fill=$fill\n\
    \        fi\n    done\n    if [[ $min_fill -gt 0 ]]; then\n        total_fills=$((total_fills+min_fill))\n\
    \    fi\n    if [[ $min_fill -gt $bucket_capacity ]]; then\n        total_fills=$((total_fills+$min_fill-$bucket_capacity))\n\
    \    fi\n    echo \"$total_fills\"", "    echo \"$1\" | {\n        v=0\n     \
    \   max=0\n        while read -r line; do\n            echo $line | {\n      \
    \          v=0\n                while read -r num; do\n                    if\
    \ [[ $num == 1 ]]; then\n                        v=$((v+1))\n                \
    \    else\n                        if [[ $v -gt $max ]]; then\n              \
    \              max=$v\n                        fi\n                        v=0\n\
    \                    fi\n                done\n            }\n        done\n \
    \       if [[ $v -gt $max ]]; then\n            max=$v\n        fi\n        echo\
    \ $max\n    }", "    N=${#1}\n    B=$2\n    # use first line to create output\
    \ array of 0's\n    O=${1% *}\n    for ((i=1; i<${#O}; i++)); do\n        O+=\"\
    \ 0\"\n    done\n    # iterate over each row\n    for i in $(seq 1 $N); do\n \
    \       # split the row into an array\n        R=(${1%% *})\n        # calculate\
    \ the fill amount for this row\n        F=$((${R[0]}*$B))\n        # if the fill\
    \ amount is non-zero, update the output\n        if [ $F -gt 0 ]; then\n     \
    \       O=(${O//${R[0]}/$F})\n        fi\n        # shift the input array, discarding\
    \ the first item\n        I=${1#* }\n        # shift the output array, discarding\
    \ the first item\n        O=${O#* }\n        # prepare the row array for the next\
    \ iteration\n        R=()\n        # shift the input array, discarding the first\
    \ item\n        I=${I#* }\n        # iterate over the remaining values in the\
    \ row\n        for j in $(seq 1 $((${#I}+1))); do\n            # split the current\
    \ item into an array\n            C=(${I%% *})\n            # calculate the fill\
    \ amount for this well\n            F=$((${C[0]}*$B))\n            # if the fill\
    \ amount is non-zero, update the output\n            if [ $F -gt 0 ]; then\n \
    \               O=(${O//${C[0]}/$F})\n            fi\n            # if any of\
    \ the surrounding wells are empty, add a single unit of water\n            if\
    \ [ $((($F+${R[0]}+${C[0]})/$B)) -eq 0 ]; then\n                O[$(($j-1))]=$((${O[$(($j-1))]}+1))\n\
    \            fi\n            # shift the input array, discarding the first item\n\
    \            I=${I#* }\n            # shift the output array, discarding the first\
    \ item\n            O=${O#* }\n            # update the row array\n          \
    \  R=(${C[0]})\n", "    local -a grid=(\"$@\")\n    local grid_height=${#grid[@]}\n\
    \    local -a max_fill=( $(for r in ${grid[@]}; do\n                         \
    \   local -a r=(\"$r\")\n                            local r_len=${#r[@]}\n  \
    \                          local -a fill=( $(for i in $(seq 1 $r_len); do\n  \
    \                                              local j=$((i - 1))\n          \
    \                                      local left=$((i - 1))\n               \
    \                                 local right=$((i + 1))\n                   \
    \                             local max=0\n                                  \
    \              while [[ $left -ge 0 && $right -lt $r_len ]]; do\n            \
    \                                        left=$((left - 1))\n                \
    \                                    right=$((right + 1))\n                  \
    \                                  if [[ ${r[$left]} == 0 && ${r[$right]} == 0\
    \ ]]; then\n                                                        max=$((max\
    \ + 1))\n                                                    else\n          \
    \                                              break\n                       \
    \                             fi\n                                           \
    \     done\n                                                echo $max\n      \
    \                                      done) )\n                            echo\
    \ ${fill[@]}\n                        done) )\n    echo ${max_fill[@]}", "   \
    \ local max=0\n    local lines=`echo \"$1\" | wc -l`\n    local l=0\n    while\
    \ read line; do\n        let l=l+1\n        local row_max=0\n        local row=`echo\
    \ \"$line\" | sed 's/^ *//;s/ *$//'`\n        for i in `echo \"$row\"`; do\n \
    \           local n=`echo \"$i\" | sed 's/^0*//'`\n            [[ \"$n\" -gt \"\
    $row_max\" ]] && row_max=\"$n\"\n        done\n        [[ \"$row_max\" -gt \"\
    $max\" ]] && max=\"$row_max\"\n    done <<< \"$1\"\n    echo \"$max\"", "    #\
    \ read in $1 as a matrix\n    m=()\n    read -r -a m\n    # keep track of total\
    \ amount of water pumped\n    pumped=0\n    # keep track of water pumped from\
    \ each well\n    well_totals=()\n    for well in \"${m[@]}\"; do\n        well_sum=0\n\
    \        well_totals+=(\"$well_sum\")\n    done\n    # perform pumping until all\
    \ well_totals are >= $2\n    while [ 1 = 1 ]; do\n        # determine the best\
    \ well to pump from\n        well_to_pump=\"\"\n        best_well=\"\"\n     \
    \   # get the smallest value of ${well_totals[@]} that is less than $2\n     \
    \   for well in \"${well_totals[@]}\"; do\n            if [[ \"$well\" -lt \"\
    $2\" ]]; then\n                well_to_pump=\"$well\"\n                break\n\
    \            fi\n        done\n        if [[ -z \"$well_to_pump\" ]]; then\n \
    \           break\n        fi\n        # if the difference between $well_to_pump\
    \ and $2 is the smallest, then pump from that well\n        min_diff=0\n     \
    \   for well in \"${well_totals[@]}\"; do\n            if [[ \"$well\" -lt \"\
    $2\" ]]; then\n                diff=$(( $2 - $well ))\n                if [[ \"\
    $diff\" -lt \"$min_diff\" ]]; then\n                    min_diff=\"$diff\"\n \
    \                   best_well=\"$well\"\n                fi\n            fi\n\
    \        done\n        # add $2 - $best_well to $pumped\n        pumped=$(( $pumped\
    \ + $2 - $best_well ))\n        # in the well corresponding to $best_well, replace\
    \ all 1s with $2\n        # this implicitly makes that well_total = $2\n     \
    \   row=0\n        for well in \"${m[@]}\"; do\n            if [[ \"$well\" -eq\
    \ \"$best_well\" ]]; then\n                col=0\n                for cell in\
    \ \"${well[@]}\"; do\n                    if [[ \"$cell\" -eq \"1\" ]]; then\n\
    \                        m[$row][$col]=\"$2\"", "  max_fill=0\n  for i in $1;\
    \ do\n    ((i>max_fill)) && max_fill=$i\n  done\n  echo $max_fill", "    if [\
    \ \"$1\" == \"\" ]\n    then\n        echo \"\"\n        return\n    fi\n    if\
    \ [ \"$2\" == \"\" ]\n    then\n        echo \"\"\n        return\n    fi\n  \
    \  local x;\n    local y;\n    local in\n    local out\n    local index\n    x=$1\n\
    \    y=$2\n    in=$(echo \"$x\" | sed 's/ /|/g')\n    out=$(echo $x | sed 's/\
    \ /\\n/g' | sort -n | tail -n 1)\n    index=$(echo $x | sed 's/ /\\n/g' | awk\
    \ -v var=\"$out\" '{if ($1==var) print NR}')\n    if [ \"$index\" == \"\" ]\n\
    \    then\n        echo \"\"\n        return\n    fi\n    local result\n    local\
    \ row\n    result=$(echo $x | sed 's/ /\\n/g' | awk -v var=\"$out\" '{if ($1<var)\
    \ print var-$1}')\n    if [ \"$result\" == \"\" ]\n    then\n        echo \"$x\"\
    \n        return\n    fi\n    row=$(echo $result | sed 's/ /|/g')\n    echo $row"]
stop_tokens:
- "\n}"
