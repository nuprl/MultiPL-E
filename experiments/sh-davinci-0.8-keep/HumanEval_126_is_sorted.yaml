name: HumanEval_126_is_sorted
language: sh
prompt: "#!/bin/bash\n# Given a list of numbers, return whether or not they are sorted\n\
  # in ascending order. If list has more than 1 duplicate of the same\n# number, return\
  \ False. Assume no negative numbers and only integers.\n# Examples\n# is_sorted([5])\
  \ \u279E True\n# is_sorted([1, 2, 3, 4, 5]) \u279E True\n# is_sorted([1, 3, 2, 4,\
  \ 5]) \u279E False\n# is_sorted([1, 2, 3, 4, 5, 6]) \u279E True\n# is_sorted([1,\
  \ 2, 3, 4, 5, 6, 7]) \u279E True\n# is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279E False\n\
  # is_sorted([1, 2, 2, 3, 3, 4]) \u279E True\n# is_sorted([1, 2, 2, 2, 3, 4]) \u279E\
  \ False\n#\n# $1 is a space-separated list\nis_sorted() {\n"
tests: "}\n\ncandidate() {\n    is_sorted \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"5\") = \"true\" ]]\n    [[ $(candidate \"1 2 3 4 5\") = \"true\"\
  \ ]]\n    [[ $(candidate \"1 3 2 4 5\") = \"false\" ]]\n    [[ $(candidate \"1 2\
  \ 3 4 5 6\") = \"true\" ]]\n    [[ $(candidate \"1 2 3 4 5 6 7\") = \"true\" ]]\n\
  \    [[ $(candidate \"1 3 2 4 5 6 7\") = \"false\" ]]\n    [[ $(candidate \"\")\
  \ = \"true\" ]]\n    [[ $(candidate \"1\") = \"true\" ]]\n    [[ $(candidate \"\
  3 2 1\") = \"false\" ]]\n    [[ $(candidate \"1 2 2 2 3 4\") = \"false\" ]]\n  \
  \  [[ $(candidate \"1 2 3 3 3 4\") = \"false\" ]]\n    [[ $(candidate \"1 2 2 3\
  \ 3 4\") = \"true\" ]]\n    [[ $(candidate \"1 2 3 4\") = \"true\" ]]\n}\n\nrun_test"
completions: ["  declare -i sorted\n  declare -a arr=(\"$@\")\n  sorted=1\n  for i\
    \ in ${arr[@]}; do\n    if [ ${arr[i+1]} -lt $i ]; then\n      sorted=0\n    fi\n\
    \  done\n  echo $sorted", "  local IFS=$' ' arr=($1) len=${#arr[@]}\n  [[ $len\
    \ -eq 1 ]] && echo 'True' && return\n  local -i sorted=1 dup=0\n  for (( i=0;\
    \ i<len-1; i++ )); do\n    if [[ ${arr[i]} -gt ${arr[i+1]} ]]; then\n      sorted=0\n\
    \      break\n    elif [[ ${arr[i]} -eq ${arr[i+1]} ]]; then\n      dup=1\n  \
    \  fi\n  done\n  [[ $sorted -eq 1 && $dup -eq 0 ]] && echo 'True' || echo 'False'",
  "   sorted=$(echo $1 | tr ' ' '\\n' | sort -n | tr '\\n' ' ')\n   if [ \"$1\" =\
    \ \"$sorted\" ]; then\n      echo True\n   else\n      echo False\n   fi", " \
    \  if [[ $1 == '' ]]; then\n      return 0\n   fi\n   result=1\n   current=0\n\
    \   old=0\n   for i in $1; do\n      current=$i\n      if [[ $current -eq $old\
    \ ]]; then\n         result=0\n         break\n      fi\n      if [[ $current\
    \ -lt $old ]]; then\n         result=0\n         break\n      fi\n      old=$current\n\
    \   done\n   return $result", "\tlist=($1)\n\tif [[ ${#list[@]} -lt 2 ]]; then\n\
    \t\techo True\n\t\treturn\n\tfi\n\tfor i in \"${list[@]}\"; do\n\t\tif [[ ${list[$((\
    \ $i - 1 ))]} -gt $i ]]; then\n\t\t\techo False\n\t\t\treturn\n\t\tfi\n\tdone\n\
    \techo True", "    local prev=0\n    local -i count=0\n    local curr\n    local\
    \ out\n\n    for curr in $1; do\n        if (( prev == curr )); then\n       \
    \     (( count++ ))\n        else\n            (( count = 0 ))\n        fi\n \
    \       if (( count > 1 )); then\n            out=false\n            break\n \
    \       fi\n        if (( prev > curr )); then\n            out=false\n      \
    \      break\n        fi\n        prev=$curr\n    done\n    echo $out", '  echo
    "$1" | tr " " "\n" | sort -n | tr "\n" " " | grep -q "$1"', "  local -r array=($1)\n\
    \  local i=0\n  while [[ $i -lt $((${#array[@]} - 1)) ]]; do\n    local current=${array[$i]}\n\
    \    local next=${array[$(($i + 1))]}\n    if [[ $current -gt $next ]]; then\n\
    \      echo False\n      return\n    fi\n    ((i++))\n  done\n  echo True", "\t\
    local prev=$1\n\tfor i in $1; do\n\t\tif [[ $i -lt $prev ]]; then\n\t\t\techo\
    \ 'False'\n\t\t\treturn\n\t\tfi\n\t\tprev=$i\n\tdone\n\techo 'True'", "    arr=($1)\n\
    \    for i in `seq 0 $((${#arr[@]} - 2))`; do\n        if [[ ${arr[$i]} -gt ${arr[$(($i\
    \ + 1))]} ]]; then\n            echo \"False\"\n            return\n        fi\n\
    \    done\n    echo \"True\"", "    set -f\n    local -a ary\n    local i\n\n\
    \    IFS=' ' read -r -a ary <<< \"$1\"\n    for ((i = 0; i < ${#ary[@]} - 1; i++));\
    \ do\n        if [[ ${ary[i]} -ge ${ary[i + 1]} ]]; then\n            set +f\n\
    \            return 1\n        fi\n    done\n    set +f\n    return 0", "    a=(\"\
    $@\")\n    j=0\n    for ((i=0; i<${#a[@]}; i++)); do\n        if [[ ${a[i]} -gt\
    \ ${a[j]} ]]; then\n            j=$i\n        fi\n    done\n    if [[ $j -eq $((${#a[@]}-1))\
    \ ]]; then\n        echo True\n    else\n        echo False\n    fi", "    echo\
    \ \"$1\" | tr ' ' '\\n' | sort -n | tr '\\n' ' '", "  if [[ $1 =~ [[:blank:]]\
    \ ]]; then\n    echo False\n  else\n    echo True\n  fi", '  # put code here',
  "  echo \"$1\"\n  echo \"This is not finished\"", "    echo $1 | tr ' ' '\\n' |\
    \ sort -g | tr '\\n' ' ' | grep -q -v \"^$1$\" && echo \"False\" || echo \"True\"",
  "  echo \"is_sorted $1\"\n  if [ $# -lt 2 ]; then\n    echo true\n    return\n \
    \ fi\n  declare -i previous=$1\n  for i in \"$@\"; do\n    if [ $i -lt $previous\
    \ ]; then\n      echo false\n      return\n    fi\n    previous=$i\n  done\n \
    \ echo true", "\tif [ $# -eq 1 ]; then\n\t\tif [ $1 -eq 1 ]; then\n\t\t\techo\
    \ \"True\"\n\t\telse\n\t\t\techo \"False\"\n\t\tfi\n\telse\n\t\tfor i in $(seq\
    \ 1 $(( $# - 1 ))); do\n\t\t\tif [ ${!i} -gt ${!(i+1)} ]; then\n\t\t\t\techo \"\
    False\"\n\t\t\t\treturn\n\t\t\tfi\n\t\tdone\n\t\techo \"True\"\n\tfi", "  if [\
    \ $# -eq 1 ]; then\n    local line_array=($1)\n    local len=${#line_array[@]}\n\
    \    local i=0\n    local count=0\n    local index=$((len - 1))\n    local result=0\n\
    \    while [ $i -lt $index ]; do\n      let \"result=${line_array[$i]} - ${line_array[$((i\
    \ + 1))]}\"\n      if [ $result -ge 0 ]; then\n        echo $result\n        let\
    \ \"count++\"\n      fi\n      let \"i++\"\n    done\n    if [ $count -ne $index\
    \ ]; then\n      echo \"False\"\n    else\n      echo \"True\"\n    fi\n  else\n\
    \    echo \"Usage: $0 'num_list'\"\n  fi"]
stop_tokens:
- "\n}"
