name: HumanEval_9_rolling_max
language: sh
prompt: "#!/bin/bash\n# From a given list of integers, generate a list of rolling\
  \ maximum element found until given moment\n# in the sequence.\n# >>> rolling_max([1,\
  \ 2, 3, 2, 3, 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\n#\n# $1 is a space-separated list\n\
  rolling_max() {\n"
tests: "}\n\ncandidate() {\n    rolling_max \"$@\"\n}\n\nset -e\nrun_test() {\n  \
  \  [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"1 2 3 4\") = \"1 2 3 4\"\
  \ ]]\n    [[ $(candidate \"4 3 2 1\") = \"4 4 4 4\" ]]\n    [[ $(candidate \"3 2\
  \ 3 100 3\") = \"3 3 3 100 100\" ]]\n}\n\nrun_test"
completions: ["\tIFS=\" \"\n\tmax_so_far=0\n\tfor n in $1; do\n\t\tif [[ $n -gt $max_so_far\
    \ ]]; then\n\t\t\tmax_so_far=$n\n\t\tfi\n\t\techo $max_so_far\n\tdone", "\techo\
    \ \"$1\" | sed 's/ /\\n/g' | awk 'BEGIN { max = 0 }\n\t{\n\t\tif ($1 > max) {\n\
    \t\t\tmax = $1\n\t\t}\n\t\tprint max\n\t}'", "  input=( $1 )\n  len=${#input[@]}\n\
    \  output=( )\n  for (( i=0; i<$len; i++ )); do\n    current=${input[$i]}\n  \
    \  if (( $i == 0 )); then\n      prev=$current\n    else\n      prev=${output[$((\
    \ $i - 1 ))]}\n    fi\n    if (( $current >= $prev )); then\n      output[$i]=$current\n\
    \    else\n      output[$i]=$prev\n    fi\n  done\n  echo ${output[@]}", "   \
    \ awk '\n        {m=$1}\n        {m=m>$1?m:$1}\n        {print m}\n    ' <<< \"\
    $1\"", "  local -i n i max\n  local -a nums=($1)\n\n  for ((i=0; i<${#nums[@]};\
    \ i++)); do\n    n=${nums[i]}\n    [ $n -gt $max ] && max=$n\n    echo -n \"$max\
    \ \"\n  done\n  echo", "    if (( $# == 0 )); then\n        return 0\n    fi\n\
    \    local max=\"$1\"\n    echo \"$max\"\n    shift\n    rolling_max \"$@\" |\
    \ (while read x; do\n        if (( x > max )); then\n            max=\"$x\"\n\
    \        fi\n        echo \"$max\"\n    done)", "\tlocal rolling_max=0\n\tlocal\
    \ -a arr=(\"$@\")\n\tfor ((i=0; i<${#arr[@]}; i++)); do\n\t\trolling_max=$((rolling_max\
    \ > arr[i] ? rolling_max : arr[i]))\n\t\techo -n \"$rolling_max \"\n\tdone\n\t\
    echo", "\tlocal input_int_list=\"$1\"\n\t#max_int=$(echo $input_int_list | tr\
    \ \" \" \"\\n\" | sort -n | tail -n 1)\n\tmax_int=${input_int_list// /$'\\n'}\n\
    \tmax_int=$(echo $max_int | sort -n | tail -n 1)\n\tprintf \"Checking if $input_int_list\
    \ contains more than 1 element...\\n\"\n\tlist_length=$(echo $input_int_list |\
    \ wc -w)\n\tif [ $list_length -le 1 ]; then\n\t\tprintf \"$input_int_list\\n\"\
    \n\telse\n\t\tprintf \"Checking if $input_int_list contains more than 1 element...OK\\\
    n\"\n\t\tprintf \"Checking if $input_int_list contains at least one number...\\\
    n\"\n\t\tnumbers_found=$(echo $input_int_list | tr \" \" \"\\n\" | sed '/^[[:alpha:]]*$/d'\
    \ | wc -l)\n\t\tif [ $numbers_found -le 0 ]; then\n\t\t\tprintf \"No number found\
    \ in input list, will exit.\\n\"\n\t\t\texit 1\n\t\telse\n\t\t\tprintf \"Checking\
    \ if $input_int_list contains at least one number...OK\\n\"\n\t\t\tprintf \"Checking\
    \ if $input_int_list contains at least one integer...\\n\"\n\t\t\tints_found=$(echo\
    \ $input_int_list | tr \" \" \"\\n\" | sed '/^[[:alpha:]]*$/d' | sed '/^[0-9]*[.][0-9]*$/d'\
    \ | wc -l)\n\t\t\tif [ $ints_found -le 0 ]; then\n\t\t\t\tprintf \"No integer\
    \ found in input list, will exit.\\n\"\n\t\t\t\texit 1\n\t\t\telse\n\t\t\t\tprintf\
    \ \"Checking if $input_int_list contains at least one integer...OK\\n\"\n\t\t\t\
    \tprintf \"Checking if $input_int_list contains at least one element larger than\
    \ $max_int...\\n\"\n\t\t", "  local max=1;\n  for ((i=1; i<=${#1}; i++)); do\n\
    \    max=$(max ${max} ${1:i:1});\n    echo -n \"${max} \";\n  done\n  echo", " \
    \ local arr=()\n  local max=0\n  local value\n  for i in $1; do\n    if [[ \"\
    $i\" -gt \"$max\" ]]; then\n      max=\"$i\"\n    fi\n    arr+=(\"$max\")\n  done\n\
    \  echo \"${arr[@]}\"", "    local list=\"$1\"\n    local -a arr=()\n    local\
    \ max\n    local num\n    for num in $list; do\n        max=$num\n        if [[\
    \ ${#arr[@]} -gt 0 ]]; then\n            if [[ ${arr[-1]} -gt $max ]]; then\n\
    \                max=${arr[-1]}\n            fi\n        fi\n        arr+=($max)\n\
    \    done\n    echo \"${arr[@]}\"", "    local IFS=\" \"\n    local max=$1\n \
    \   shift\n    local array=($*)\n    echo \"$max\"\n    for i in \"${array[@]}\"\
    ; do\n        if [[ $i -gt $max ]]; then\n            max=$i\n        fi\n   \
    \     echo \"$max\"\n    done", "    local max\n    while [ \"$1\" ]; do\n   \
    \     if [[ -z \"$max\" || \"$1\" -gt \"$max\" ]]; then\n            max=\"$1\"\
    \n        fi\n        echo \"$max\"\n        shift\n    done", "    local max=0\n\
    \    local curr\n    local -a seq\n    local -i i=0\n\n    IFS=' ' read -r -a\
    \ seq <<< \"$1\"\n    for curr in \"${seq[@]}\"; do\n        if [[ \"$curr\" -gt\
    \ \"$max\" ]]; then\n            max=\"$curr\"\n        fi\n        seq[$i]=\"\
    $max\"\n        ((++i))\n    done\n    printf '%s\\n' \"${seq[@]}\"", "    for\
    \ element in $1; do\n        if [[ $element -gt $max ]]; then\n            max=$element\n\
    \        fi\n        echo -n \"$max \"\n    done\n    echo", "    # split $1 by\
    \ space into an array, then iterate over each element\n    for item in $1; do\n\
    \        # if item is bigger than last_item, save item as last_item\n        if\
    \ [ -z \"$last_item\" ] || [ $item -gt $last_item ]; then\n            last_item=$item\n\
    \        fi\n        # print last_item\n        echo $last_item\n    done", " \
    \ local IN=\"$1\"\n  local OUT=\"$(echo \"$IN\" | tr ' ' '\\n' | awk '{ print\
    \ $1 }')\"\n  for n in $(echo \"$IN\" | tr ' ' '\\n' | awk '{ print $1 }' | tail\
    \ -n +2); do\n    local max=\"$(echo \"$OUT\" | tail -n 1)\"\n    if [[ \"$n\"\
    \ -gt \"$max\" ]]; then\n      OUT=\"$OUT $n\"\n    else\n      OUT=\"$OUT $max\"\
    \n    fi\n  done\n  echo \"$OUT\"", "    local input=$1\n    local list=($(echo\
    \ $input))\n    local result=()\n    for elem in ${list[@]}; do\n        if [\
    \ ${#result[@]} -eq 0 ]; then\n            result+=($elem)\n        else\n   \
    \         local last=${result[-1]}\n            if [ $elem -ge $last ]; then\n\
    \                result+=($elem)\n            else\n                result+=($last)\n\
    \            fi\n        fi\n    done\n    echo ${result[@]}", "    local -a list=$1\n\
    \    local current_max=0\n    for i in ${list[@]}; do\n        if [[ $i -gt $current_max\
    \ ]]; then\n            current_max=$i\n        fi\n        echo $current_max\n\
    \    done", "    local max;\n    for n in $1; do\n        if [ -z \"$max\" ] ||\
    \ [ \"$n\" -gt \"$max\" ]; then\n            max=\"$n\";\n        fi;\n      \
    \  echo \"$max\";\n    done;"]
stop_tokens:
- "\n}"
