name: HumanEval_12_longest
language: sh
prompt: "#!/bin/bash\n# Out of list of strings, return the longest one. Return the\
  \ first one in case of multiple\n# strings of the same length. Return None in case\
  \ the input list is empty.\n# >>> longest([])\n# >>> longest(['a', 'b', 'c'])\n\
  # 'a'\n# >>> longest(['a', 'bb', 'ccc'])\n# 'ccc'\n#\n# $1 is a space-separated\
  \ list\nlongest() {\n"
tests: "}\n\ncandidate() {\n    longest \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"\") = \"None\" ]]\n    [[ $(candidate \"x y z\") = \"x\" ]]\n  \
  \  [[ $(candidate \"x yyy zzzz www kkkk abc\") = \"zzzz\" ]]\n}\n\nrun_test"
completions: ["  input=\"$1\"\n  # initialize an array with first string\n  array=(${input%\
    \ *})\n  while [[ -n \"$input\" ]]; do\n    # pop the last string from the variable\n\
    \    string=${input##* }\n    input=${input% *}\n    len=${#string}\n    len_arr=${#array[@]}\n\
    \    if [[ $len -gt $len_arr ]]; then\n      array=(${string})\n    elif [[ $len\
    \ -eq $len_arr ]]; then\n      array+=(${string})\n    fi\n  done\n  echo ${array[0]}",
  "    longest=\"\"\n    for item in $1; do\n        if [ -z \"$longest\" ]; then\n\
    \            longest=\"$item\"\n        else\n            if [ ${#item} -gt ${#longest}\
    \ ]; then\n                longest=\"$item\"\n            fi\n        fi\n   \
    \ done\n    echo \"$longest\"", "    MAX_LEN=0\n    LONGEST=\n    for str in $1;\
    \ do\n        if [ ${#str} -gt $MAX_LEN ]; then\n            MAX_LEN=${#str}\n\
    \            LONGEST=$str\n        fi\n    done\n    echo $LONGEST", "    local\
    \ strings=($1)\n    local max_length=0\n    local longest_string=\"\"\n    for\
    \ s in \"${strings[@]}\"; do\n        local length=${#s}\n        if [ $length\
    \ -gt $max_length ]; then\n            max_length=$length\n            longest_string=$s\n\
    \        fi\n    done\n    if [ $max_length -gt 0 ]; then\n        echo $longest_string\n\
    \    fi", "  eval echo \"$1\" | xargs -n1 | sort -z | tr '\\0' '\\n' | sort -u\
    \ -n -k1.2,1.2 | tail -n1", "    local input=$1\n    if [ -z \"${input}\" ]; then\n\
    \        echo None\n    else\n        local string_list=$(echo \"${input}\" |\
    \ tr ' ' '\\n')\n        local longest=$(echo \"${string_list}\" | sort -r | head\
    \ -n 1)\n        echo \"${longest}\"\n    fi", "\t# The longest string should\
    \ have the maximum length\n\tmax_len=-1\n\t# Initialize the max_string with the\
    \ first value of $1\n\tmax_string=`echo $1 | cut -d \" \" -f 1`\n\t# For each\
    \ string in the list\n\tfor string in $1; do\n\t\t# Find the length of each string\n\
    \t\tstr_len=`echo ${#string}`\n\t\t# If the length of current string is greater\
    \ than the length of the longest\n\t\t# string found so far, update max_len and\
    \ max_string\n\t\tif [ $str_len -gt $max_len ]; then\n\t\t\tmax_len=$str_len\n\
    \t\t\tmax_string=$string\n\t\tfi\n\tdone\n\techo $max_string", "  local max=0\n\
    \  local longest_word\n  for i in $*\n  do\n    if [ \"${#i}\" -gt \"$max\" ]\n\
    \    then\n      max=${#i}\n      longest_word=$i\n    fi\n  done\n  if [ -z \"\
    $longest_word\" ]\n  then\n    echo -n\n  else\n    echo -n \"$longest_word\"\n\
    \  fi", "  [[ -z \"$1\" ]] && echo None || (echo \"$1\" | awk 'BEGIN {\n    max\
    \ = 0\n  } {\n    if (length($1) > max) {\n      max = length($1)\n      max_word\
    \ = $1\n    }\n  } END {\n    print max_word\n  }')", "    input=$1\n    max=0\n\
    \    ret=\"\"\n    for i in $input; do\n        len=${#i}\n        if [ $len -gt\
    \ $max ]; then\n            max=$len\n            ret=$i\n        fi\n    done\n\
    \    echo $ret", "  local arg=$1\n  local max=0\n  local maxlen=0\n  local curlen=0\n\
    \  local res=None\n  for w in $arg; do\n    curlen=${#w}\n    if [[ \"$curlen\"\
    \ -gt \"$maxlen\" ]]; then\n      maxlen=$curlen\n      max=$w\n    fi\n  done\n\
    \  echo $max", "    local len\n    local maxLen\n    local longest\n    for i\
    \ in $1\n    do\n        len=${#i}\n        [ \"$len\" -gt \"$maxLen\" ] && {\n\
    \            maxLen=$len\n            longest=$i\n        }\n    done\n    echo\
    \ $longest", "    longest_len=-1\n    longest_word=\"\"\n    for word in $1; do\n\
    \        word_len=${#word}\n        if [ $word_len -gt $longest_len ]; then\n\
    \            longest_len=$word_len\n            longest_word=$word\n        fi\n\
    \    done\n    echo $longest_word", "  local maxlen=0\n  local str\n  local maxstr=''\n\
    \  for str in $1; do\n    len=${#str}\n    if [ $len -gt $maxlen ]; then\n   \
    \   maxlen=$len\n      maxstr=$str\n    fi\n  done\n  echo $maxstr", "  echo \"\
    $1\" | awk 'BEGIN {max = 0} { for (i = 1; i <= NF; i++) { if (length($i) > max)\
    \ { max = length($i); v = $i } } } END { print v }'", "  local str=''\n  local\
    \ max_len=0\n  for s in $1; do\n    if [[ ${#s} -gt $max_len ]]; then\n      max_len=${#s}\n\
    \      str=$s\n    fi\n  done\n  [[ $max_len -gt 0 ]] && echo $str", "  [ -z \"\
    $1\" ] && return\n\n  # The trick here is to preserve the spaces in the strings\
    \ (e.g. \"this is a string\" instead of \"thisisastring\")\n  # so that we can\
    \ easily separate the words later on. We do this by adding \"^\" to the beginning\
    \ of the string\n  # (e.g. \"^this is a string\") and then just replace all spaces\
    \ in the string with \"^\" (e.g. \"^this^is^a^string\").\n  # This way we can\
    \ split the list by spaces, but the strings will still be separated by \"^\".\n\
    \  local args_with_start_symbol=\"$(echo \"$1\" | sed 's/.*/^&/g')\"\n  local\
    \ longest_so_far=\"$(echo \"$args_with_start_symbol\" | head -n 1)\"\n  local\
    \ current_arg=\"\"\n\n  while read current_arg; do\n    if [[ \"${#current_arg}\"\
    \ -gt \"${#longest_so_far}\" ]]; then\n      longest_so_far=\"$current_arg\"\n\
    \    fi\n  done <<< \"$(echo \"$args_with_start_symbol\" | sed 's/ /^/g')\"\n\n\
    \  # Remove the start symbol, which is \"^\", so that we're left with just the\
    \ string.\n  echo \"$longest_so_far\" | sed 's/^.//'", "  [ $# -eq 0 ] && echo\
    \ \"None\" && return\n  local longest=\"\"\n  for arg in $@; do\n    [ ${#arg}\
    \ -gt ${#longest} ] && longest=\"$arg\"\n  done\n  echo \"$longest\"", "  sed\
    \ 's/^ *//; s/ *$//' <<< \"$1\" | sort -nr | head -n 1", "    case $# in\n   \
    \     0) echo \"None\";;\n        1) echo \"$1\";;\n        *) local IFS=$'\\\
    n'\n           echo \"$@\" | sort -r -k1,1 -t' ' | head -n1;;\n    esac"]
stop_tokens:
- "\n}"
