name: HumanEval_94_skjkasdkd
language: sh
prompt: "#!/bin/bash\n# You are given a list of integers.\n# You need to find the\
  \ largest prime value and return the sum of its digits.\n# Examples:\n# For lst\
  \ = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n\
  # For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n\
  # For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should\
  \ be 13\n# For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be\
  \ 11\n# For lst = [0,81,12,3,1,21] the output should be 3\n# For lst = [0,8,1,2,1,7]\
  \ the output should be 7\n#\n# $1 is a space-separated list\nskjkasdkd() {\n"
tests: "}\n\ncandidate() {\n    skjkasdkd \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"0 3 2 1 3 5 7 4 5 5 5 2 181 32 4 32 3 2 32 324 4 3\") = \"10\" ]]\n\
  \    [[ $(candidate \"1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1\") = \"25\" ]]\n \
  \   [[ $(candidate \"1 3 1 32 5107 34 83278 109 163 23 2323 32 30 1 9 3\") = \"\
  13\" ]]\n    [[ $(candidate \"0 724 32 71 99 32 6 0 5 91 83 0 5 6\") = \"11\" ]]\n\
  \    [[ $(candidate \"0 81 12 3 1 21\") = \"3\" ]]\n    [[ $(candidate \"0 8 1 2\
  \ 1 7\") = \"7\" ]]\n    [[ $(candidate \"8191\") = \"19\" ]]\n    [[ $(candidate\
  \ \"8191 123456 127 7\") = \"19\" ]]\n    [[ $(candidate \"127 97 8192\") = \"10\"\
  \ ]]\n}\n\nrun_test"
completions: ['    echo $1', "  local -a local_array\n  IFS=' ' read -r -a local_array\
    \ <<< \"$1\"\n  declare -p local_array", "cat <<EOF\n0 3 2 1 3 5 7 4 5 5 5 2 181\
    \ 32 4 32 3 2 32 324 4 3\n1 0 1 8 2 4597 2 1 3 40 1 2 1 2 4 2 5 1\n1 3 1 32 5107\
    \ 34 83278 109 163 23 2323 32 30 1 9 3\n0 724 32 71 99 32 6 0 5 91 83 0 5 6\n\
    0 81 12 3 1 21\n0 8 1 2 1 7\nEOF", "\n# \uCD08\uAE30\uD654\nRESULT=0\n\n# \uC785\
    \uB825 \uAC12 \uAC80\uC99D\nif [ -z \"$1\" ]; then\n  echo \"ERROR] input data\
    \ is empty.\"\n  exit 1\nfi\n\n# \uC785\uB825 \uAC12\uC744 \uCC98\uB9AC\uD558\uAE30\
    \ \uC704\uD574\uC11C \uAC12\uC744 \uBD84\uB9AC\uD55C\uB2E4.\nfor VALUE in $@\n\
    do\n    # \uAC01 \uAC12\uC5D0 \uB300\uD574\uC11C prime number \uB97C \uAD6C\uD55C\
    \uB2E4.\n    PRIME_NUM=`isPrimeNumber $VALUE`\n    \n    # prime number \uC774\
    \uBA74 \uAC12\uC744 \uC800\uC7A5\uD55C\uB2E4.\n    if [ $PRIME_NUM -eq 1 ]; then\n\
    \      PRIME_LIST+=($VALUE)\n    fi\ndone\n\n# \uC22B\uC790 \uAC12\uC774 \uC874\
    \uC7AC\uD558\uBA74 \uACB0\uACFC\uB97C \uAD6C\uD55C\uB2E4.\nif [ ${#PRIME_LIST[@]}\
    \ -gt 0 ]; then\n    # prime number \uC911\uC5D0\uC11C \uAC00\uC7A5 \uD070 \uAC12\
    \uC744 \uAD6C\uD55C\uB2E4.\n    LARGEST_PRIME=`getLargestPrime ${PRIME_LIST[@]}`\n\
    \    \n    # \uAC00\uC7A5 \uD070 prime number \uC758 \uC790\uB9BF\uC218\uB97C\
    \ \uAD6C\uD55C\uB2E4.\n    RESULT=`calculateNumber $LARGEST_PRIME`\nfi\n\n# \uCD5C\
    \uC885 \uACB0\uACFC\uB97C \uCD9C\uB825\uD55C\uB2E4.\necho $RESULT", "    n=100\n\
    \    for ((i=2;i<=n;i++))\n    do\n        for ((j=2;j<i;j++))\n        do\n \
    \           if [ $(($i%$j)) -eq 0 ]\n            then\n                flag=1\n\
    \                break\n            else\n                flag=0\n           \
    \ fi\n        done\n        if [ $flag -eq 0 ]\n        then\n            echo\
    \ -n \"$i \"\n        fi\n    done\n    echo", "    # Remove all non-prime numbers\n\
    \    local RESULT=( $(echo \"$1\" | tr \" \" \"\\n\" | while read v; do echo $v;\
    \ if is_prime $v; then echo $v; fi; done) )\n    # Find the largest prime number\n\
    \    local LARGEST=( $(echo \"${RESULT[@]}\" | tr \" \" \"\\n\" | sort -n | tail\
    \ -n 1) )\n    # Get the digits of the largest prime number\n    local DIGITS=(\
    \ $(echo \"$LARGEST\" | sed 's/\\(.\\)/\\1 /g') )\n    # Sum up all the digits\n\
    \    echo $((${DIGITS[@]}))", '  echo $@', "    local e=0 t=0 n\n    for n in\
    \ $(echo $1 | tr ' ' '\\n' | sort -nr)\n    do\n        for e in $(seq 2 $n)\n\
    \        do\n            [ $((n%e)) -eq 0 ] && break\n        done\n        [\
    \ $e -eq $n ] && { echo -n $n; break; }\n    done", "  local -i lst=$1\n  echo\
    \ $lst", '    echo $1', "  echo '$1'", "  echo $(echo $1 | sed 's/,/ /g')", " \
    \   echo $1 | tr ' ' '\\n' | sort -rn | head -n1 | rev | grep -Eo '[0-9]' | paste\
    \ -sd+ | bc", "  local list=\"$1\"\n  local max=0\n\n  while IFS=' ' read -ra\
    \ array; do\n    for i in \"${array[@]}\"; do\n      if (( $i > $max )) && is_prime\
    \ $i; then\n        max=$i\n      fi\n    done\n  done <<< \"$list\"\n\n  sum_digits\
    \ $max", "    a=3\n    for b in $1; do\n        until (( $b % $a == 0 )); do\n\
    \            (( a++ ))\n        done\n        if (( a == $b )); then\n       \
    \     echo -n $b\n        fi\n        a=3\n    done", "  # 100% random parsing,\
    \ because why not\n  echo \"$1\" | tr ' ' '\\n' | grep -E '^[1-9]\\d*$' | sort\
    \ -nr | head -n1 | tr -d '\\n' | rev | grep -E -o '[1-9]' | tr -d '\\n' | rev\
    \ | sed 's/./&+/g' | sed 's/+$//' | bc -l", "\t# convert to array\n\tIFS=' ' read\
    \ -r -a lst <<< $1\n\t# find largest value\n\tmax_value=$(printf \"%s\\n\" \"\
    ${lst[@]}\" | sort -nr | head -n1)\n\t# find all primes <= max_value\n\tprimes=$(echo\
    \ ${max_value} | factor | cut -d: -f2 | tr ' ' '\\n' | tr '\\n' ' ')\n\t# convert\
    \ to array\n\tIFS=' ' read -r -a prime_lst <<< $primes\n\t# find greatest prime\
    \ <= max_value\n\tprime_max=$(printf \"%s\\n\" \"${prime_lst[@]}\" | sort -nr\
    \ | head -n1)\n\t# sum digits of greatest prime\n\techo $prime_max | sed 's/\\\
    (.\\)/\\1\\n/g' | paste -sd+ | bc", "    lst=$(echo $1 | sed -e 's/\\s/,/g')\n\
    \    echo $lst | python -c \"\nfrom sympy import isprime\nimport sys\n\nprimes\
    \ = []\nfor i in map(int, sys.stdin.read().split(',')):\n    if isprime(i):\n\
    \        primes.append(i)\n\nprint(str(sum(map(int, list(str(max(primes)))))))\n\
    \"", "\techo $1 | tr ' ' '\\n' | sort -n -r | sed -n -E 's/^.*([0-9]{1,}).*$/\\\
    1/p' | sort -n -r | grep -E '^[0-9]{1,}$' | sort -n -r | sed -n -E '1p'", "  \
    \  LARGEST_PRIME=$(echo ${1//[^0-9]/ } | xargs -n1 | sort -nr | awk '!($1 in a)\
    \ {a[$1]; print}' | head -n1)\n    echo ${LARGEST_PRIME//./} | grep -o . | paste\
    \ -sd+ | bc"]
stop_tokens:
- "\n}"
