name: HumanEval_99_closest_integer
language: sh
prompt: "#!/bin/bash\n# Create a function that takes a value (string) representing\
  \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
  # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
  10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
  \ zero means that if the given number is equidistant\n# from two integers, the one\
  \ you should return is the one that is the\n# farthest from zero. For example closest_integer(\"\
  14.5\") should\n# return 15 and closest_integer(\"-14.5\") should return -15.\n\
  #\n# $1 is a string\nclosest_integer() {\n"
tests: "}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
  \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\"\
  \ ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
completions: ['  printf "%.0f\n" $1', '    echo "${1} 0.5 + p" | dc', "  printf \"\
    %s\\n\" \"${1}\" | bc -l | sed -e 's/\\.[0-9]*//g'", '    # your code here', " \
    \   echo \"$1\" | awk '{print (int($1 > 0) ? int($1 + 0.5) : int($1 - 0.5))}'",
  "    # Your code here\n    echo \"Not yet implemented\"", "  # echo $1\n  # echo\
    \ \"(( $1 + 0.5 ))\"\n  # echo \"echo $1 | awk '{ print int($1 + 0.5)}'\"\n  echo\
    \ $1 | awk '{ print int($1 + 0.5)}'", "    i=${1%.*}\n    j=${1#*.}\n    if [\
    \ $j -ge 5 ]; then\n        ((i++))\n    fi\n    echo $i", "    echo $1 | perl\
    \ -pe 's/\\.\\d+//;'", '    echo ${1} | xargs printf "%.0f"', '  echo "scale=0;$1/1"
    | bc -l', "  if (( $(echo \"$1 > 0\" | bc -l) )); then\n    echo $(( $1 + 0.5\
    \ | bc -l ))\n  else\n    echo $(( $1 - 0.5 | bc -l ))\n  fi", '  printf "%.0f\n"
    "$1"', '    printf %.0f $1', "    local -i N=10 M=15\n    local -i n=$(echo \"\
    scale=0; $1/1\" | bc)\n    local -i m=$(echo \"scale=0; $1/1\" | bc)\n    local\
    \ -i n_r=$(echo \"$1 - $n\" | bc)\n    local -i m_r=$(echo \"$m - $1\" | bc)\n\
    \    local -i N_M=$(echo \"$n - $M\" | bc)\n    local -i M_N=$(echo \"$M - $n\"\
    \ | bc)\n    # if the number is equidistant from two integers\n    if [ $n_r -eq\
    \ $m_r ]; then\n        # round it away from zero\n        [ $N_M -lt $M_N ] &&\
    \ echo $n || echo $m\n    # if the number is closer to N\n    elif [ $n_r -lt\
    \ $m_r ]; then\n        echo $n\n    # if the number is closer to M\n    else\n\
    \        echo $m\n    fi", '  # your code here', "  local -i base=$1 floor\n \
    \ base=${base#-}\n  # check if $1 contains a decimal\n  if [[ $1 == *.* ]]; then\n\
    \    floor=${1%.*}\n    # check if $1 is negative\n    if [[ $1 != \"$base\" ]];\
    \ then\n      base=${base%.*}\n      # check if $1 is equidistant from the two\
    \ integers\n      if ((base > floor + 0.5)); then\n        echo $base\n      else\n\
    \        echo $(($base - 1))\n      fi\n    else\n      # if $1 is not negative,\
    \ check if it is equidistant from the two integers\n      if ((base > floor +\
    \ 0.5)); then\n        echo $base\n      else\n        echo $(($base - 1))\n \
    \     fi\n    fi\n  else\n    echo $1\n  fi", "  echo $1 | awk '{ printf(\"%d\\\
    n\", ($1 < 0) ? int($1 - 0.5) : int($1 + 0.5)) }'", '  echo "${1/.*}"', "    echo\
    \ $1 | awk '{print int($1+0.5)}'"]
stop_tokens:
- "\n}"
