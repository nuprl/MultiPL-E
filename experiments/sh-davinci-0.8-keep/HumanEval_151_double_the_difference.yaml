name: HumanEval_151_double_the_difference
language: sh
prompt: "#!/bin/bash\n# Given a list of numbers, return the sum of squares of the\
  \ numbers\n# in the list that are odd. Ignore numbers that are negative or not integers.\n\
  # double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n# double_the_difference([-1,\
  \ -2, 0]) == 0\n# double_the_difference([9, -2]) == 81\n# double_the_difference([0])\
  \ == 0  \n# If the input list is empty, return 0.\n#\n# $1 is a space-separated\
  \ list\ndouble_the_difference() {\n"
tests: "}\n\ncandidate() {\n    double_the_difference \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"\") = \"0\" ]]\n    [[ $(candidate \"5.0 4.0\") = \"25\"\
  \ ]]\n    [[ $(candidate \"0.1 0.2 0.3\") = \"0\" ]]\n    [[ $(candidate \"-10.0\
  \ -20.0 -30.0\") = \"0\" ]]\n    [[ $(candidate \"-1.0 -2.0 8.0\") = \"0\" ]]\n\
  \    [[ $(candidate \"0.2 3.0 5.0\") = \"34\" ]]\n    [[ $(candidate \"-9.0 -7.0\
  \ -5.0 -3.0 -1.0 1.0 3.0 5.0 7.0 9.0\") = \"165\" ]]\n}\n\nrun_test"
completions: ["  local numbers=( $1 )\n  local sum=0\n  for n in \"${numbers[@]}\"\
    ; do\n    if [[ ! $n =~ ^[0-9]+$ ]]; then\n      continue\n    fi\n    local remainder=$((\
    \ n % 2 ))\n    local squared=$(( n * n ))\n    if [[ $remainder -ne 0 ]]; then\n\
    \      sum=$(( sum + squared ))\n    fi\n  done\n  echo $sum", "  if [[ $# -eq\
    \ 0 ]]; then\n    echo 0\n    return\n  fi\n  #printf \"%d\\n\" $1 | tr ' ' '\\\
    n' | grep -E '[0-9]+' | grep -v '^[0]$' | awk '{sum+=$1*$1} END {print sum}'\n\
    \  printf \"%d\\n\" $1 | tr ' ' '\\n' | grep -E '[0-9]+' | grep -v '^[0]$' | awk\
    \ '{sum+=$1*$1} END {print sum}'", "    sum=0\n    for i in $1; do\n        if\
    \ [[ \"$i\" =~ ^[0-9]+$ ]]; then\n            if [[ \"$(( $i % 2 ))\" == 1 ]];\
    \ then\n                sum=$(( $sum + ($i*$i) ))\n            fi\n        fi\n\
    \    done\n    echo $sum", "    echo $1 | sed 's/ /\\n/g' | # split on spaces\n\
    \    grep -v -E '^[-]?0*$' | # ignore numbers that are 0 or negative 0\n    grep\
    \ -E '^[-]?[1-9][0-9]*$' | # ignore numbers that are floating point\n    awk '{print\
    \ $1*$1}' | # square each number\n    paste -sd+ - | # add together on a single\
    \ line\n    bc", "  # YOUR CODE HERE\n  # Use bash list processing.\n  # Use string\
    \ processing.\n  # Use arithmetic processing.\n  # http://mywiki.wooledge.org/ArithmeticExpression",
  "    echo \"$1\" | awk '{ sum = 0; for (i = 1; i <= NF; i++) if ($i > 0 && $i %\
    \ 2 == 1) sum += $i * $i; print sum }'", "  double_the_difference=0\n  for i in\
    \ $1; do\n  \tif [ $i -gt 0 ] && [ $(expr $i % 2) -eq 1 ]; then\n    \t((double_the_difference+=i*i))\n\
    \  \tfi\n  done\n  echo $double_the_difference", "    local n\n    local -i sum=0\n\
    \n    for n in $1; do\n        if [[ $n =~ ^[0-9]+$ ]]; then\n            if [[\
    \ $((n % 2)) -eq 1 ]]; then\n                sum+=$((n * n))\n            fi\n\
    \        fi\n    done\n\n    echo $sum", "  LIST=$1\n  local sum=0\n  for i in\
    \ $LIST; do\n    if [ $i -lt 0 ]; then\n      continue\n    fi\n    if [ $(( $i\
    \ % 2 )) -eq 1 ]; then\n      sum=$(( $sum + $i * $i ))\n    fi\n  done\n  echo\
    \ $sum", "\techo \"$1\" | tr ' ' '\\n' | grep -E '^[0-9]+$' | grep -vE '^-1$'\
    \ | awk '{print $1*$1}' | awk '{s+=$1} END {print s}'", "  if [ \"$#\" -eq 0 ];\
    \ then\n    echo 0\n    return\n  fi\n  sum=0\n  for i in $1; do\n    # Check\
    \ if i is an integer\n    # http://stackoverflow.com/questions/806906/how-do-i-test-if-a-variable-is-a-number-in-bash\n\
    \    re='^[0-9]+$'\n    if ! [[ $i =~ $re ]] ; then\n      continue\n    fi\n\
    \    if [ $(($i % 2)) -eq 1 ]; then\n      sum=$(($sum + $i*$i))\n    fi\n  done\n\
    \  echo $sum", "    list=( $1 )\n    res=0\n    for i in ${list[@]}; do\n    \
    \    if [[ \"$i\" =~ ^[0-9]+$ ]]; then\n            if [[ $((i%2)) -eq 1 ]]; then\n\
    \                res=$((res+i*i))\n            fi\n        fi\n    done\n    echo\
    \ $res", "    local args=($1)\n    local sum=0\n    for arg in ${args[@]}; do\n\
    \        if ! [[ $arg =~ ^[0-9]+$ ]]; then\n            continue\n        fi\n\
    \        if [ $(( arg % 2 )) -eq 1 ]; then\n            sum=$(( sum + arg * arg\
    \ ))\n        fi\n    done\n    echo $sum", "    # your code goes here\n    #\
    \ Hint 1: you can use a for loop\n    # Hint 2: you can use `bc` to convert strings\
    \ to numbers\n    # Hint 3: you can use `bc` to do arithmetic\n\n    sum=0\n \
    \   #Your answer goes here\n    for i in $1\n    do\n        if [[ $i =~ ^-?[0-9]+$\
    \ ]]\n        then\n            if (( $i % 2 == 1 ))\n            then\n     \
    \           sum=$(bc <<< \"$sum + ($i * $i)\")\n            fi\n        fi\n \
    \   done\n    echo $sum", "    if [[ $# -lt 1 ]]; then\n        echo \"usage:\
    \ $0 nums\" >&2\n        return 1\n    fi\n    return 0", "  for n in $1\n  do\n\
    \    if [[ \"$n\" =~ ^[0-9]+$ ]]\n    then\n      if [ $((n % 2)) -ne 0 ]\n  \
    \    then\n        (( sum += (n*n) ))\n      fi\n    fi\n  done\n  echo $sum",
  "    echo $@ | awk '{total=0; for (i=1; i<=NF; i++) {\n      n=$i; if (n > 0 &&\
    \ n == int(n)) { if (n % 2 == 1) { total += n*n; } } \n    } print total; }'",
  "  echo $1 | awk '{\n      for (i = 1; i <= NF; i++) {\n        if ($i >= 0 && $i\
    \ ~ /^[0-9]+$/) {\n          if ($i % 2 != 0) {\n            sum += $i * $i;\n\
    \          }\n        }\n      }\n      print sum;\n  }'", "\t# YOUR CODE HERE\n\
    \tif [ -z \"$1\" ]; then\n\t\techo 0\n\telse\n\t\tfor i in \"$@\"; do\n\t\t\t\
    if [ -z \"$i\" ]; then\n\t\t\t\tcontinue\n\t\t\telif [ $i -lt 0 ]; then\n\t\t\t\
    \tcontinue\n\t\t\telif [ $(($i % 2)) -eq 0 ]; then\n\t\t\t\tcontinue\n\t\t\telse\n\
    \t\t\t\tprintf \"%s\\n\" $(( $i * $i ))\n\t\t\tfi\n\t\tdone | paste -sd+ - | bc\n\
    \tfi", "    # Using  $(seq 1 10) to generate number sequence\n    for i in $1;\
    \ do\n        # If it's negative, ignore it\n        if [[ $i -lt 0 ]]; then\n\
    \            echo -n\n        # If it's not an integer, ignore it\n        elif\
    \ [[ $i =~ [.] ]]; then\n            echo -n\n        # Check if it's odd, then\
    \ print its square\n        elif [[ $(( $i % 2 )) -ne 0 ]]; then\n           \
    \ echo -n \"$(( $i ** 2 )) \"\n        fi\n    done"]
stop_tokens:
- "\n}"
