name: HumanEval_156_int_to_mini_roman
language: sh
prompt: "#!/bin/bash\n# Given a positive integer, obtain its roman numeral equivalent\
  \ as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n\
  # Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152)\
  \ == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\n#\n# $1 is an integer\nint_to_mini_roman()\
  \ {\n"
tests: "}\n\ncandidate() {\n    int_to_mini_roman \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"19\") = \"xix\" ]]\n    [[ $(candidate \"152\") = \"clii\"\
  \ ]]\n    [[ $(candidate \"251\") = \"ccli\" ]]\n    [[ $(candidate \"426\") = \"\
  cdxxvi\" ]]\n    [[ $(candidate \"500\") = \"d\" ]]\n    [[ $(candidate \"1\") =\
  \ \"i\" ]]\n    [[ $(candidate \"4\") = \"iv\" ]]\n    [[ $(candidate \"43\") =\
  \ \"xliii\" ]]\n    [[ $(candidate \"90\") = \"xc\" ]]\n    [[ $(candidate \"94\"\
  ) = \"xciv\" ]]\n    [[ $(candidate \"532\") = \"dxxxii\" ]]\n    [[ $(candidate\
  \ \"900\") = \"cm\" ]]\n    [[ $(candidate \"994\") = \"cmxciv\" ]]\n    [[ $(candidate\
  \ \"1000\") = \"m\" ]]\n}\n\nrun_test"
completions: ["    # Call 'num' for number\n    local num=\"$1\"\n    # 'mini_roman'\
    \ is the output\n    local mini_roman=''\n    # the 'num' value is the number\
    \ to be converted to roman numeral\n    while [ \"$num\" -gt 0 ]; do\n       \
    \ if [ \"$num\" -ge 1000 ]; then\n            mini_roman=\"$mini_roman\"'m'\n\
    \            num=$((num - 1000))\n        elif [ \"$num\" -ge 900 ]; then\n  \
    \          mini_roman=\"$mini_roman\"'cm'\n            num=$((num - 900))\n  \
    \      elif [ \"$num\" -ge 500 ]; then\n            mini_roman=\"$mini_roman\"\
    'd'\n            num=$((num - 500))\n        elif [ \"$num\" -ge 400 ]; then\n\
    \            mini_roman=\"$mini_roman\"'cd'\n            num=$((num - 400))\n\
    \        elif [ \"$num\" -ge 100 ]; then\n            mini_roman=\"$mini_roman\"\
    'c'\n            num=$((num - 100))\n        elif [ \"$num\" -ge 90 ]; then\n\
    \            mini_roman=\"$mini_roman\"'xc'\n            num=$((num - 90))\n \
    \       elif [ \"$num\" -ge 50 ]; then\n            mini_roman=\"$mini_roman\"\
    'l'\n            num=$((num - 50))\n        elif [ \"$num\" -ge 40 ]; then\n \
    \           mini_roman=\"$mini_roman\"'xl'\n            num=$((num - 40))\n  \
    \      elif [ \"$num\" -ge 10 ]; then\n            mini_roman=\"$mini_roman\"\
    'x'\n            num=$((num - 10))\n        elif [ \"$num\" -ge 9 ]; then\n  \
    \          mini_roman=\"$mini_roman\"'ix'\n            num=$((num - 9))\n    \
    \    elif [ \"$num\" -ge 5 ]; then\n            mini_roman=\"$mini_roman\"'v'\n\
    \            num=$((num - 5))\n        elif [ \"$num\" -ge 4 ]; then\n       \
    \     mini_roman=\"$mini_roman\"'iv'\n            num=$((num - 4))\n        elif\
    \ [ \"$num\" -ge 1 ]; then\n            mini_roman=\"$mini_roman\"'i", "    local\
    \ test_string=\"^[1-9][0-9]{0,2}$\"\n    if [[ $1 =~ $test_string ]]; then\n \
    \       case $1 in\n            [1-9]) echo -n \"${ROMAN_MINI_ONES[$1]}\";;\n\
    \            [1-9][0-9]) echo -n \"${ROMAN_MINI_TENS[${1:0:1}]}${ROMAN_MINI_ONES[${1:1:1}]}\"\
    ;;\n            [1-9][0-9][0-9]) echo -n \"${ROMAN_MINI_HUNDREDS[${1:0:1}]}${ROMAN_MINI_TENS[${1:1:1}]}${ROMAN_MINI_ONES[${1:2:1}]}\"\
    ;;\n        esac\n    else\n        error \"Invalid input $1\"\n    fi", "  printf\
    \ \"%-4s\" \"$1\" | sed '\n    s/^1000/m/; s/^900/cm/; s/^500/d/; s/^400/cd/;\
    \ s/^100/c/; s/^90/xc/;\n    s/^50/l/; s/^40/xl/; s/^10/x/; s/^9/ix/; s/^5/v/;\
    \ s/^4/iv/; s/^1/i/;\n    s/^0//'", "    if [ $1 -lt 1 -o $1 -gt 1000 ]; then\n\
    \        echo 'Out of range.' >&2\n        return 1\n    fi\n    num=$1\n    n=0\n\
    \    while [ $num -gt 0 ]; do\n        digit=$((num % 10))\n        num=$((num\
    \ / 10))\n        case $n in\n            0)\n                if [ $digit -lt\
    \ 4 ]; then\n                    i=0\n                    while [ $i -lt $digit\
    \ ]; do\n                        echo -n 'i'\n                        i=$((i +\
    \ 1))\n                    done\n                elif [ $digit -eq 4 ]; then\n\
    \                    echo -n 'iv'\n                elif [ $digit -eq 5 ]; then\n\
    \                    echo -n 'v'\n                elif [ $digit -lt 9 ]; then\n\
    \                    echo -n 'v'\n                    i=0\n                  \
    \  while [ $i -lt $((digit - 5)) ]; do\n                        echo -n 'i'\n\
    \                        i=$((i + 1))\n                    done\n            \
    \    else\n                    echo -n 'ix'\n                fi\n            \
    \    ;;\n            1)\n                if [ $digit -lt 4 ]; then\n         \
    \           i=0\n                    while [ $i -lt $digit ]; do\n           \
    \             echo -n 'x'\n                        i=$((i + 1))\n            \
    \        done\n                elif [ $digit -eq 4 ]; then\n                 \
    \   echo -n 'xl'\n                elif [ $digit -eq 5 ]; then\n              \
    \      echo -n 'l'\n                elif [ $digit -lt 9 ]; then\n            \
    \        echo -n 'l'\n                    i=0\n                    while [ $i\
    \ -lt $((digit - 5)) ]; do\n                        echo -n 'x'\n            \
    \            i=$((i + 1))\n                    done\n                else\n  \
    \                  echo -n 'xc'\n                fi\n                ;;\n    \
    \        2)\n                if [ $digit -lt 4 ]; then\n                    i=0\n\
    \                    while [ $i -lt $digit ]; do\n                        echo\
    \ -n 'c'\n                        i=$((i + 1))\n                    done\n   \
    \             elif [ $digit -eq 4 ]; then\n                    echo -n 'cd'\n\
    \                elif [ $digit -eq 5 ]; then\n                    echo -n '",
  "    local minirom='mcmxcviii'\n\n    # Input validation\n    if [ $# -ne 1 ]; then\n\
    \        return 1\n    fi\n    if ! [[ $1 =~ ^[0-9]+$ ]]; then\n        return\
    \ 1\n    fi\n    if [ $1 -le 0 ] || [ $1 -gt 1000 ]; then\n        return 1\n\
    \    fi\n\n    echo $minirom | cut -c1-$1", "    local num=$1\n    local result=''\n\
    \    local -A roman=(\n        [M]=1000 [CM]=900 [D]=500 [CD]=400 [C]=100 [XC]=90\
    \ [L]=50 [XL]=40 [X]=10\n        [IX]=9 [V]=5 [IV]=4 [I]=1)\n    for k in \"${!roman[@]}\"\
    ; do\n        while (( num >= roman[$k] )); do\n            result+=$k\n     \
    \       (( num -= roman[$k] ))\n        done\n    done\n    echo \"$result\"",
  "    local num=\"$1\"\n    [ \"$num\" -lt 1 ] && echo \"Error: argument must be\
    \ a positive integer (1 <= num <= 1000)\" && return 1\n    [ \"$num\" -gt 1000\
    \ ] && echo \"Error: argument must be a positive integer (1 <= num <= 1000)\"\
    \ && return 1\n    local num_len=\"${#num}\"\n    local num_part # a sub-part\
    \ of num. Ex: '152' = '1', '52' = '2', '2' = '2'\n    local num_part_len\n   \
    \ local num_part_digit # digit of the sub-part. Ex: '152' = '1', '52' = '5', '2'\
    \ = '2'\n    local num_part_digit_len\n    local roman_part\n    local roman\n\
    \    local i=1 # count of num_part\n    local j # count of num_part_digit\n  \
    \  local k\n    local I=0 V=0 X=0 L=0 C=0 D=0 M=0\n    local IIII=0 VV=0 XXX=0\
    \ LL=0 CCCC=0 DDD=0 MMMM=0\n    local ii=0 vv=0 xxx=0 ll=0 cccc=0 ddd=0 mmmm=0\n\
    \    local iii=0 vvv=0 xxxx=0 lll=0 ccccc=0 dddd=0 mmmmm=0\n    local iiiii=0\
    \ vvvv=0 xxxxx=0 llll=0 cccccc=0 ddddd=0 mmmmmm=0\n    while [ \"$i\" -le \"$num_len\"\
    \ ]; do\n        num_part=\"${num:$((i-1)):1}\"\n        num_part_len=\"${#num_part}\"\
    \n        num_part_digit=\"${num_part:$((num_part_len-1)):1}\"\n        num_part_digit_len=\"\
    ${#num_part_digit}\"\n        case \"$num_part_digit\" in\n            \"1\")\n\
    \                for j in $(seq 1 \"$num_part_digit_len\"); do\n             \
    \       if [ \"$i\" -eq 1 ]; then\n                        I=\"$((I", "    local\
    \ int=\"$1\"\n    local result=''\n    declare -A numeral\n    numeral=([1]='i'\
    \ [5]='v' [10]='x' [50]='l' [100]='c' [500]='d' [1000]='m')\n    [ \"$int\" -gt\
    \ 0 ] || return\n    [ \"$int\" -le 1000 ] || return\n    while [ \"$int\" -gt\
    \ 0 ]; do\n        local unit=$(( $int % 10 ))\n        local tens=$(( $int %\
    \ 100 / 10 ))\n        local huns=$(( $int % 1000 / 100 ))\n        local thou=$((\
    \ $int / 1000 ))\n        if [ \"$thou\" -ne 0 ]; then\n            result+=\"\
    ${numeral[1000]}\"\n            int=$(( $int - 1000 ))\n        elif [ \"$huns\"\
    \ -ne 0 ]; then\n            if [ \"$huns\" -eq 9 ]; then\n                result+=\"\
    ${numeral[100]}${numeral[1000]}\"\n                int=$(( $int - 900 ))\n   \
    \         elif [ \"$huns\" -ge 5 ]; then\n                result+=\"${numeral[500]}\"\
    \n                int=$(( $int - 500 ))\n                while [ \"$huns\" -gt\
    \ 5 ]; do\n                    result+=\"${numeral[100]}\"\n                 \
    \   int=$(( $int - 100 ))\n                    huns=$(( $huns - 1 ))\n       \
    \         done\n            elif [ \"$huns\" -eq 4 ]; then\n                result+=\"\
    ${numeral[100]}${numeral[500]}\"\n                int=$(( $int - 400 ))\n    \
    \        else\n                while [ \"$huns\" -gt 0 ]; do\n               \
    \     result+=\"${numeral[100]}\"\n                    int=$(( $int - 100 ))\n\
    \                    huns=$(( $huns - 1 ))\n                done\n           \
    \ fi\n        elif [ \"$tens\" -ne 0 ]; then\n            if [ \"$tens\" -eq 9\
    \ ]; then\n                result+=\"${numeral[10]}${numeral[100]}\"\n       \
    \         int=$(( $int - 90 ))\n            elif [ \"$tens\" -ge 5 ]; then\n \
    \               result+=\"${numeral[50]}\"\n                int=$", "    input=$1\n\
    \    x=0\n    if [ $input -eq 0 ]; then\n        printf \"\"\n    fi\n    while\
    \ [ $input -gt 0 ]; do\n        roman=$(int_to_mini_roman_digit $((input % 10))\
    \ $x)\n        printf \"%s\" \"$roman\"\n        input=$((input / 10))\n     \
    \   x=$((x + 1))\n    done\n    printf \"\\n\"", "    local num=$1 rom=\"\"\n\
    \    for ((i=0; i<4; i++)); do\n        local digit=${num:$i:1}\n        [[ $digit\
    \ -gt 0 ]] &&\n            rom+=\"$(printf '%s' \"${DIGIT_TO_NUMERAL[$digit]}\"\
    )\"\n    done\n    echo \"${rom,,}\"", "    # TODO: your code here\n    # Hint:\
    \ use div and mod\n    # Hint: 0 to 9 is written as I II III IV V VI VII VIII\
    \ IX X\n    # Hint: repeat the pattern to the next order of magnitude.\n    #\
    \ Hint: check the Bash table at http://tldp.org/LDP/abs/html/arithexp.html\n\n\
    \    local n=$1\n    local nb=${#n}\n    local i=0\n    local s=\"\"\n    local\
    \ rmn=\"\"\n    local rmn_tab=(\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\"\
    \ \"VIII\" \"IX\")\n    local rmc_tab=(\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\"\
    \ \"LXX\" \"LXXX\" \"XC\")\n    local rmm_tab=(\"C\" \"CC\" \"CCC\" \"CD\" \"\
    D\" \"DC\" \"DCC\" \"DCCC\" \"CM\")\n    local rmmm_tab=(\"M\" \"MM\" \"MMM\"\
    )\n\n    while [ $i -lt $nb ]; do\n        local d=$((10**i))\n        local digit=$((n/d))\n\
    \        local reminder=$((n%d))\n        local int_i=$((digit-1))\n        local\
    \ rmn_tab=(\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\")\n\
    \        case $i in\n            0)\n                if [ $digit -gt 0 ]; then\n\
    \                    rmn=${rmn_tab[$int_i]}\n                fi\n            \
    \    ;;\n            1)\n                if [ $digit -gt 0 ]; then\n         \
    \           rmn=${rmc_tab[$int_i]}${rmn}\n                fi\n               \
    \ ;;\n            2)\n                if [ $digit -gt 0 ]; then\n            \
    \        rmn=${rmm_tab[$int_i]}${rmn}\n                fi\n                ;;\n\
    \            3)\n                if [ $digit -gt 0 ]; then\n                 \
    \   rmn=${rmmm_tab[$int_i]}${rmn}\n                fi\n                ;;\n  \
    \      es", "\tlocal -a NUMERALS=(\n\t\t[1]='i' [5]='v' [10]='x' [50]='l' [100]='c'\
    \ [500]='d' [1000]='m'\n\t)\n\tlocal -a INTEGERS=(\n\t\t[0]=1 [1]=5 [2]=10 [3]=50\
    \ [4]=100 [5]=500 [6]=1000\n\t)\n\tlocal i j n str int dec\n\tdec=0\n\tstr=''\n\
    \tn=\"$1\"\n\tfor ((i=${#INTEGERS[@]}-1; i>0; i--)); do\n\t\tfor ((j=0; j<i; j++));\
    \ do\n\t\t\tif ((n < INTEGERS[j])) && ((n >= INTEGERS[j+1])); then\n\t\t\t\tstr+=\"\
    ${NUMERALS[INTEGERS[j+1]]}\"\n\t\t\t\t((n -= INTEGERS[j+1]))\n\t\t\tfi\n\t\tdone\n\
    \t\tif ((n == INTEGERS[i])); then\n\t\t\tstr+=\"${NUMERALS[INTEGERS[i]]}\"\n\t\
    \t\t((n -= INTEGERS[i]))\n\t\tfi\n\t\tif ((n > INTEGERS[i])); then\n\t\t\tstr+=\"\
    ${NUMERALS[INTEGERS[i]]}\"\n\t\t\t((n -= INTEGERS[i]))\n\t\t\tdec=1\n\t\tfi\n\t\
    \tif ((n == INTEGERS[i-1])); then\n\t\t\tstr+=\"${NUMERALS[INTEGERS[i-1]]}\"\n\
    \t\t\t((n -= INTEGERS[i-1]))\n\t\tfi\n\t\tif ((n > INTEGERS[i-1])); then\n\t\t\
    \tstr+=\"${NUMERALS[INTEGERS[i-1]]}\"\n\t\t\t((n -= INTEGERS[i-1]))\n\t\t\tdec=1\n\
    \t\tfi\n\t\tif ((dec == 1)); then\n\t\t\tdec=0\n\t\t\tif ((n == 4)); then\n\t\t\
    \t\t", "  local result=\"\"\n  local num=\"$1\"\n  # -s: sort by string length\n\
    \  for i in $(echo \"M D C L X V I\" | tr ' ' '\\n' | sort -s); do\n    # -g:\
    \ ignore the decimal part, -i: the radix is decimal\n    local div=$((num/(${#i})))\n\
    \    local remainder=$((num%(${#i})))\n    if [ $div -ge 1 ]; then\n      result+=$(printf\
    \ \"%${div}s\" \"$i\")\n    fi\n    num=$remainder\n  done\n  echo \"$result\"",
  "  local TEN=('x' 'xx' 'xxx' 'xl' 'l' 'lx' 'lxx' 'lxxx' 'xc')\n  local ONE=('i'\
    \ 'ii' 'iii' 'iv' 'v' 'vi' 'vii' 'viii' 'ix')\n  if [ -z \"$1\" ]; then\n    echo\
    \ 'input is empty'\n    return 1\n  fi\n  if ! [[ \"$1\" =~ ^[0-9]+$ ]]; then\n\
    \    echo 'input is not an integer'\n    return 1\n  fi\n  if (( $1 < 1 || $1\
    \ > 1000 )); then\n    echo 'input is out of range'\n    return 1\n  fi\n  local\
    \ input_len=${#1}\n  local result=''\n  local count=0\n  while (( input_len >\
    \ 0 )); do\n    local num=$(( $1 % 10 ))\n    local index=$(( $num - 1 ))\n  \
    \  if (( input_len == 4 )); then\n      result=${result}'m'\n    elif (( input_len\
    \ == 3 )); then\n      result=${TEN[$index]}${result}\n    elif (( input_len ==\
    \ 2 )); then\n      result=${ONE[$index]}${result}\n    elif (( input_len == 1\
    \ )); then\n      result=${result}$num\n    fi\n    input_len=$(( input_len -\
    \ 1 ))\n    count=$(( count + 1 ))\n    if (( count == 3 )); then\n      local\
    \ divider=$(( 10 ** $input_len ))\n      num=$(( $1 / divider ))\n      index=$((\
    \ $num - 1 ))\n      if (( num > 0 )); then\n        result=${TEN[$index]}${result}\n\
    \      fi\n      count=0\n    fi\n    local divider=$(( 10 ** $input_len ))\n\
    \    if (( divider > 0 )); then\n      num=$(( $1 / divider ))\n      result=${result}$num\n\
    \    fi\n    if (( divider > 0 )); then\n      num=$(( $1 / divider ))\n     \
    \ result=${result}$num\n    fi\n    input_len=$(( input_len - 1 ))\n", "    local\
    \ -i i=$1\n    local -i remaining\n    local -a result\n    remaining=$i\n   \
    \ while (( remaining > 0 )); do\n        case $remaining in\n            1)  \
    \   result+=('i'); ((remaining-=1));;\n            2)     result+=('ii'); ((remaining-=2));;\n\
    \            3)     result+=('iii'); ((remaining-=3));;\n            4)     result+=('iv');\
    \ ((remaining-=4));;\n            5)     result+=('v'); ((remaining-=5));;\n \
    \           6)     result+=('vi'); ((remaining-=6));;\n            7)     result+=('vii');\
    \ ((remaining-=7));;\n            8)     result+=('viii'); ((remaining-=8));;\n\
    \            9)     result+=('ix'); ((remaining-=9));;\n            10)    result+=('x');\
    \ ((remaining-=10));;\n            20)    result+=('xx'); ((remaining-=20));;\n\
    \            30)    result+=('xxx'); ((remaining-=30));;\n            40)    result+=('xl');\
    \ ((remaining-=40));;\n            50)    result+=('l'); ((remaining-=50));;\n\
    \            60)    result+=('lx'); ((remaining-=60));;\n            70)    result+=('lxx');\
    \ ((remaining-=70));;\n            80)    result+=('lxxx'); ((remaining-=80));;\n\
    \            90)    result+=('xc'); ((remaining-=90));;\n            100)   result+=('c');\
    \ ((remaining-=100));;\n            200)   result+=('cc'); ((remaining-=200));;\n\
    \            300)   result+=('ccc'); ((remaining-=300));;\n            400)  \
    \ result+=('cd'); ((remaining-=400));;\n            500)   result+=('d'); ((remaining-=500));;\n\
    \            600)   result+=('dc'); ((remaining-=600));;\n            700)   result+=('dcc');\
    \ ((remaining-=700));;\n            800)   result+=('dccc'); ((", "    local num=$1\n\
    \    local res=\"\"\n    local arr=(\"\" \"i\" \"ii\" \"iii\" \"iv\" \"v\" \"\
    vi\" \"vii\" \"viii\" \"ix\")\n    res+=${arr[$(($num % 10))]}\n    num=$(($num\
    \ / 10))\n    local arr=(\"\" \"x\" \"xx\" \"xxx\" \"xl\" \"l\" \"lx\" \"lxx\"\
    \ \"lxxx\" \"xc\")\n    res=${arr[$(($num % 10))]}$res\n    num=$(($num / 10))\n\
    \    local arr=(\"\" \"c\" \"cc\" \"ccc\" \"cd\" \"d\" \"dc\" \"dcc\" \"dccc\"\
    \ \"cm\")\n    res=${arr[$(($num % 10))]}$res\n    num=$(($num / 10))\n    local\
    \ arr=(\"\" \"m\" \"mm\" \"mmm\")\n    res=${arr[$(($num % 10))]}$res\n    echo\
    \ $res", "  MINI_ROMAN=()\n  NUMBER=$1\n  NUMBER_LEFT=$NUMBER\n  while [[ $NUMBER_LEFT\
    \ -gt 0 ]]; do\n    if [[ $NUMBER_LEFT -ge 1000 ]]; then\n      ROMAN=M\n    \
    \  NUMBER_LEFT=$(( NUMBER_LEFT - 1000 ))\n    elif [[ $NUMBER_LEFT -ge 900 ]];\
    \ then\n      ROMAN=CM\n      NUMBER_LEFT=$(( NUMBER_LEFT - 900 ))\n    elif [[\
    \ $NUMBER_LEFT -ge 500 ]]; then\n      ROMAN=D\n      NUMBER_LEFT=$(( NUMBER_LEFT\
    \ - 500 ))\n    elif [[ $NUMBER_LEFT -ge 400 ]]; then\n      ROMAN=CD\n      NUMBER_LEFT=$((\
    \ NUMBER_LEFT - 400 ))\n    elif [[ $NUMBER_LEFT -ge 100 ]]; then\n      ROMAN=C\n\
    \      NUMBER_LEFT=$(( NUMBER_LEFT - 100 ))\n    elif [[ $NUMBER_LEFT -ge 90 ]];\
    \ then\n      ROMAN=XC\n      NUMBER_LEFT=$(( NUMBER_LEFT - 90 ))\n    elif [[\
    \ $NUMBER_LEFT -ge 50 ]]; then\n      ROMAN=L\n      NUMBER_LEFT=$(( NUMBER_LEFT\
    \ - 50 ))\n    elif [[ $NUMBER_LEFT -ge 40 ]]; then\n      ROMAN=XL\n      NUMBER_LEFT=$((\
    \ NUMBER_LEFT - 40 ))\n    elif [[ $NUMBER_LEFT -ge 10 ]]; then\n      ROMAN=X\n\
    \      NUMBER_LEFT=$(( NUMBER_LEFT - 10 ))\n    elif [[ $NUMBER_LEFT -ge 9 ]];\
    \ then\n      ROMAN=IX\n      NUMBER_LEFT=$(( NUMBER_LEFT - 9 ))\n    elif [[\
    \ $NUMBER_LEFT -ge 5 ]]; then\n      ROMAN=V\n      NUMBER_LEFT=$(( NUMBER_LEFT\
    \ - 5 ))\n    elif [[ $NUMBER_LEFT -ge 4 ]]; then\n      ROMAN=IV\n      NUMBER_LEFT=$",
  "  local roman=(\n    [1]='i' [2]='ii' [3]='iii' [4]='iv' [5]='v' [6]='vi' [7]='vii'\
    \ [8]='viii'\n    [9]='ix' [10]='x' [20]='xx' [30]='xxx' [40]='xl' [50]='l' [60]='lx'\n\
    \    [70]='lxx' [80]='lxxx' [90]='xc' [100]='c' [200]='cc' [300]='ccc'\n    [400]='cd'\
    \ [500]='d' [600]='dc' [700]='dcc' [800]='dccc' [900]='cm'\n    [1000]='m'\n \
    \ )\n  local num=\"$1\"\n  local n=1\n  local r\n  local i\n  local num_set=0\n\
    \  local num_str\n  local num_str_num=0\n  local IFS=''\n\n  if [[ ${roman[$num]}\
    \ ]]; then\n    echo \"${roman[$num]}\"\n    return 0\n  fi\n\n  # Number is not\
    \ in roman[] array\n  while [[ $n -lt $num ]]; do\n    n=\"$((n * 10))\"\n  done\n\
    \  while [[ $n -gt 0 ]]; do\n    r=\"$((num / n))\"\n    num=\"$((num % n))\"\n\
    \    if [[ $r -ne 0 ]]; then\n      num_set=\"$((num_set + 1))\"\n      num_str=\"\
    $num_str${roman[$((\"$r\" * \"$n\"))]}\"\n    fi\n    n=\"$((n / 10))\"\n  done\n\
    \  for ((i=0; i<${#num_str}; i++)); do\n    if [[ ${num_str:$i:1} =~ [ivxlcdm]\
    \ ]]; then\n      num_str_num=\"$((num_str_num + 1))\"\n    fi\n  done\n  if [[\
    \ $num_set -eq $num_str_num ]]; then", "    local res=\n    local n=$1\n    local\
    \ n1000=$(( n / 1000 ))\n    n=$(( n % 1000 ))\n    local n100=$(( n / 100 ))\n\
    \    n=$(( n % 100 ))\n    local n10=$(( n / 10 ))\n    n=$(( n % 10 ))\n    for\
    \ (( i=0; i<n1000; i++ )); do\n        res+='m'\n    done\n    for (( i=0; i<n100;\
    \ i++ )); do\n        if (( i == 4 )); then\n            res+='cm'\n        elif\
    \ (( i == 9 )); then\n            res+='mcm'\n        elif (( i < 4 )); then\n\
    \            res+='c'\n        else\n            res+='d'\n        fi\n    done\n\
    \    for (( i=0; i<n10; i++ )); do\n        if (( i == 4 )); then\n          \
    \  res+='xc'\n        elif (( i == 9 )); then\n            res+='mx'\n       \
    \ elif (( i < 4 )); then\n            res+='x'\n        else\n            res+='l'\n\
    \        fi\n    done\n    for (( i=0; i<n; i++ )); do\n        if (( i == 4 ));\
    \ then\n            res+='ix'\n        elif (( i == 9 )); then\n            res+='mx'\n\
    \        elif (( i < 4 )); then\n            res+='i'\n        else\n        \
    \    res+='v'\n        fi\n    done\n    echo \"$res\"", "\t[[ $1 -le 0 || $1\
    \ -gt 1000 ]] && return\n\tlocal ones tens hundreds thousands\n\tlocal s\n\t#\
    \ Separate each digit in the input\n\tthousands=$(( $1 / 1000 ))\n\thundreds=$((\
    \ $1 / 100 % 10 ))\n\ttens=$(( $1 / 10 % 10 ))\n\tones=$(( $1 % 10 ))\n\t# Convert\
    \ each digit to its roman numeral equivalent,\n\t# concatenate, and return\n\t\
    s=\"$( mini_roman_digit $thousands 'M' )\"\n\ts+=\"$( mini_roman_digit $hundreds\
    \ 'C' 'D' 'M' )\"\n\ts+=\"$( mini_roman_digit $tens 'X' 'L' 'C' )\"\n\ts+=\"$(\
    \ mini_roman_digit $ones 'I' 'V' 'X' )\"\n\techo \"$s\""]
stop_tokens:
- "\n}"
