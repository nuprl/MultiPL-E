name: HumanEval_49_modp
language: sh
prompt: "#!/bin/bash\n# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3,\
  \ 5)\n# 3\n# >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n\
  # 8\n# >>> modp(100, 101)\n# 1\n#\n# $1 is an integer\n# $2 is an integer\nmodp()\
  \ {\n"
tests: "}\n\ncandidate() {\n    modp \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"3\" \"5\") = \"3\" ]]\n    [[ $(candidate \"1101\" \"101\") = \"2\" ]]\n   \
  \ [[ $(candidate \"0\" \"101\") = \"1\" ]]\n    [[ $(candidate \"3\" \"11\") = \"\
  8\" ]]\n    [[ $(candidate \"100\" \"101\") = \"1\" ]]\n    [[ $(candidate \"30\"\
  \ \"5\") = \"4\" ]]\n    [[ $(candidate \"31\" \"5\") = \"3\" ]]\n}\n\nrun_test"
completions: ["    num=\"$1\"\n    p=\"$2\"\n    i=0\n    res=1\n    while [ \"$i\"\
    \ -lt \"$num\" ]; do\n        res=$(( $res * 2 ))\n        res=$(( $res % $p ))\n\
    \        i=$(( $i + 1 ))\n    done\n    echo \"$res\"", "    if (( $1 == 0 ));\
    \ then\n        echo 1\n    else\n        echo \"$(( ($1 * $1) % $2 ))\"\n   \
    \ fi", "    local value=$1\n    local mod=$2\n    local res=1\n    for ((i=0;\
    \ i<$value; i++)); do\n        ((res *= 2))\n        ((res %= mod))\n    done\n\
    \    echo $res", '    local arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10
    arg11 arg12 arg13 arg14 arg15 arg16 arg17 arg18 arg19 arg20 arg21 arg22 arg23
    arg24 arg25 arg26 arg27 arg28 arg29 arg30 arg31 arg32 arg33 arg34 arg35 arg36
    arg37 arg38 arg39 arg40 arg41 arg42 arg43 arg44 arg45 arg46 arg47 arg48 arg49
    arg50 arg51 arg52 arg53 arg54 arg55 arg56 arg57 arg58 arg59 arg60 arg61 arg62
    arg63 arg64 arg65 arg66 arg67 arg68 arg69 arg70 arg71 arg72 arg73 arg74 arg75
    arg76 arg77 arg78 arg79 arg80 arg81 arg82 arg83 arg84 arg85 arg86 arg87 arg88
    arg89 arg90 arg91 arg92 arg93 arg94 arg95 arg96 arg97 arg98 arg99 arg100 arg101
    arg102 arg103 arg104 arg105 arg106 arg107 arg108 arg109 arg110 arg111 arg112 arg113
    arg114 arg115 arg116 arg117 arg118 arg119 arg120 arg121 arg122 arg123 arg124 arg125
    arg126 arg127 arg128 arg129 arg130 arg131 arg132 arg133 arg134 arg135 arg136 arg137
    arg138 arg139 arg140 arg141 arg142 arg143 arg144 arg145 arg146 arg147 arg148 arg149
    arg150 arg151 arg152 arg153 arg154 arg155 arg156 arg157 arg158 arg159 arg160 arg161
    arg162 arg163 arg164 arg165 arg166 arg167 arg168 arg169 arg170 arg171 arg172 arg173
    arg174 arg175 arg176 arg177 arg178 arg179 arg180 arg181 arg182 arg183 arg184 arg185
    arg186 arg187 arg188 arg189 arg190 arg191 arg192 arg193 arg194 arg195 arg196 arg197
    arg198 arg199 arg200 arg201 arg202 arg203 arg204 arg205 arg206 arg207 arg208 arg209
    arg210 arg211 arg212 arg213 arg214 arg215 arg216 arg217 arg218 arg219 arg220 arg221
    arg222 arg223 arg224 arg225 arg226 arg227 arg228 arg229 arg230 arg231 arg232 arg233
    arg234 arg235 arg236 arg237 arg238 arg239 arg240 arg241 arg242 arg243 arg244 arg245
    arg246 arg247 arg248 arg249 arg250 arg251 arg252 arg253 arg254 arg', "    if [[\
    \ $1 -eq 0 ]]; then\n        echo 1\n        return\n    fi\n    if [[ $1 -eq\
    \ 1 ]]; then\n        echo $1\n        return\n    fi\n    a=$1\n    r=2\n   \
    \ while [[ $a -ne 0 ]]; do\n        case $((a & 1)) in\n            1)\n     \
    \           r=$(((r * r) % $2))\n                ;;\n            0)\n        \
    \        r=$((r * r))\n                ;;\n        esac\n        a=$((a >> 1))\n\
    \    done\n    echo $r", "    #echo \"bc -l <<< \\\"2^$1 % $2\\\"\"\n    bc -l\
    \ <<< \"2^$1 % $2\"", "    echo $1 $2 | awk '{print 2**$1 % $2}'", "  local n=$1\n\
    \  local p=$2\n  local result=1\n  local i=0\n  while [[ $i -lt $n ]]; do\n  \
    \  result=$(((result * 2) % p))\n    i=$((i + 1))\n  done\n  echo $result", " \
    \   local n=\"$1\"\n    local p=\"$2\"\n    # We raise the number by the binomial\
    \ exp of p\n    # E.g., for p=5, that would be 101.\n    # The result of the **\
    \ operation is 2^n mod p.\n    #\n    # NOTE: bash does not support arbitrary\
    \ precision numbers\n    #       so we use a trick, which is to evaluate the result\
    \ of\n    #       the ** operation in bc with the -l option, which gives\n   \
    \ #       us access to arbitrary precision numbers.\n    #\n    #       Note that\
    \ there is a danger here: if n is too large,\n    #       we risk overflowing\
    \ bc's memory.  For our purposes,\n    #       this should not happen, and if\
    \ it does, it is *very*\n    #       unlikely that that happens before the evaluation\n\
    \    #       of the expression gives us the right result.\n    #\n    #      \
    \ We use printf with a \"%b\" format to get the binary\n    #       representation\
    \ of the given p.\n    printf \"%d\\n\" \"obase=10; ibase=2; $n ** $(printf '%b'\
    \ \"$p\")\" | bc -l", "  local n=$1\n  local p=$2\n  # Check if n is 0 or p is\
    \ 1\n  if [ $n -eq 0 ] || [ $p -eq 1 ]; then\n    echo 1\n    return\n  fi\n \
    \ # Initialize result\n  local res=1\n  # Calculate value of 2^n mod p\n  # Keep\
    \ multiplying res with 2 mod p\n  # till n becomes 0.\n  local n=$n\n  while [\
    \ $n -gt 0 ]; do\n    # If n is odd, multiply res with 2\n    if [ $((n % 2))\
    \ -eq 1 ]; then\n      res=$((res * 2))\n      res=$((res % p))\n    fi\n    n=$((n\
    \ / 2))\n  done\n  echo $res", "    local n=$1\n    local p=$2\n    if [ $n -eq\
    \ 0 ]; then\n        echo 1\n    else\n        local r=$(modp $(($n/2)) $p)\n\
    \        if [ $(( $n % 2 )) -eq 0 ]; then\n            echo $(( ($r * $r) % $p\
    \ ))\n        else\n            echo $(( ($r * $r * 2) % $p ))\n        fi\n \
    \   fi", '    python3 -c "print(pow($1, $2, $3))"', "  local n=$1\n  local p=$2\n\
    \  if [ \"$n\" -eq 0 ]; then\n    echo 1\n  else\n    echo $(( ($n * $(( $(modp\
    \ $((n-1)) $p) ))) % $p ))\n  fi", "    echo \"$1\" | awk -v p=\"$2\" '\n    function\
    \ modp(x, p) {\n        if (x < p) {\n            return x\n        }\n      \
    \  if (x == 0) {\n            return 1\n        }\n        if (x % 2 == 0) {\n\
    \            return 2 * modp(x / 2, p) % p\n        }\n        return (2 * modp(x\
    \ / 2, p) + 1) % p\n    }\n    { print modp($1, p) }'", "    local n=$1\n    local\
    \ p=$2\n    local base=2\n    local result=1\n    while [ $n -gt 0 ]; do\n   \
    \     if (( $n & 1 )); then\n            result=$(( (result * base) % p ))\n \
    \       fi\n        n=$(( n >> 1 ))\n        base=$(( (base * base) % p ))\n \
    \   done\n    echo $result", "    if (( $1 < 0 )); then\n        echo \"Please\
    \ supply a positive number.\"\n        return -1\n    fi\n    if (( $2 < 0 ));\
    \ then\n        echo \"Please supply a positive number.\"\n        return -1\n\
    \    fi\n    if (( $1 == 0 )); then\n        echo 1\n        return 0\n    fi\n\
    \    # The idea is that we perform the multiplications modulo p.\n    # This will\
    \ cause inaccuracies with large exponents,\n    # but for our purpose this is\
    \ not an issue.\n    p=$2\n    n=$1\n    result=1\n    while (( n > 0 )); do\n\
    \        if (( (n & 1) == 1 )); then\n            result=$(((result * $3) % $p))\n\
    \        fi\n        n=$((n >> 1))\n        if (( n > 0 )); then\n           \
    \ $3=$((($3 * $3) % $p))\n        fi\n    done\n    echo $result", "    # p ==\
    \ 0 or n == 0\n    if [ $2 -eq 0 ] || [ $1 -eq 0 ]; then\n        echo \"1\"\n\
    \        return\n    fi\n\n    # p == 1 or n == 1\n    if [ $2 -eq 1 ] || [ $1\
    \ -eq 1 ]; then\n        echo \"0\"\n        return\n    fi\n\n    # n == p\n\
    \    if [ $1 -eq $2 ]; then\n        echo \"1\"\n        return\n    fi\n\n  \
    \  # n < p\n    if [ $1 -lt $2 ]; then\n        local remainder=`expr $1 % $2`\n\
    \        echo \"$remainder\"\n        return\n    fi\n\n    # n > p\n    local\
    \ div=`expr $1 / $2`\n    local remainder=`expr $1 % $2`\n    if [ $remainder\
    \ -eq 0 ]; then\n        echo \"0\"\n        return\n    fi\n\n    local a=`modp\
    \ $div $2`\n    local b=`modp $a $2`\n    local c=`expr $a \\* $2`\n    local\
    \ d=`expr $b \\* $remainder`\n    local e=`expr $c + $d`\n    local remainder=`expr\
    \ $e % $2`\n    echo \"$remainder\"", "\tlocal x=$1 y=$2\n\tprintf \"%d\\n\" $((y\
    \ ** (($x % ($y - 1)) + 1) % $y))", '    expr \( $1 \) \^ \( $2 \) % \( $2 \)',
  '    echo "print pow($1,$2,$3)" | python']
stop_tokens:
- "\n}"
