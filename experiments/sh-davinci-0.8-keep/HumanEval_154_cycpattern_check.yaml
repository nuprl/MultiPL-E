name: HumanEval_154_cycpattern_check
language: sh
prompt: "#!/bin/bash\n# You are given 2 words. You need to return True if the second\
  \ word or any of its rotations is a substring in the first word\n# cycpattern_check(\"\
  abcd\",\"abd\") => False\n# cycpattern_check(\"hello\",\"ell\") => True\n# cycpattern_check(\"\
  whassup\",\"psus\") => False\n# cycpattern_check(\"abab\",\"baa\") => True\n# cycpattern_check(\"\
  efef\",\"eeff\") => False\n# cycpattern_check(\"himenss\",\"simen\") => True\n#\n\
  # $1 is a string\n# $2 is a string\ncycpattern_check() {\n"
tests: "}\n\ncandidate() {\n    cycpattern_check \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"xyzw\" \"xyw\") = \"false\" ]]\n    [[ $(candidate \"yello\"\
  \ \"ell\") = \"true\" ]]\n    [[ $(candidate \"whattup\" \"ptut\") = \"false\" ]]\n\
  \    [[ $(candidate \"efef\" \"fee\") = \"true\" ]]\n    [[ $(candidate \"abab\"\
  \ \"aabb\") = \"false\" ]]\n    [[ $(candidate \"winemtt\" \"tinem\") = \"true\"\
  \ ]]\n}\n\nrun_test"
completions: ["  local pattern=\"$1\"\n  local word=\"$2\"\n  local pattern_len=\"\
    ${#pattern}\"\n  local word_len=\"${#word}\"\n  local i\n  local j\n  local tmp_str1\n\
    \  local tmp_str2\n  if [ \"$word_len\" -gt \"$pattern_len\" ]; then\n    for\
    \ ((i=0; i<word_len; i++)); do\n      tmp_str1=\"${word:0:$i}\"\n      tmp_str2=\"\
    ${word:$i}\"\n      if [ \"${pattern:0:$pattern_len}\" == \"${tmp_str2}${tmp_str1}\"\
    \ ]; then\n        return 0\n      fi\n    done\n  fi\n  return 1", "  #if [ $#\
    \ -ne 2 ]; then\n  #  echo \"Usage: cycpattern_check.sh <string1> <string2>\"\n\
    \  #  exit 1\n  #fi\n  s1=$1\n  s2=$2\n  for (( i=0; i<${#s2}; i++ )); do\n  \
    \  s2=$s2:${s2:0:${#s2}-1}\n    echo \"s2:$s2\"\n    [[ $s1 =~ .*$s2.* ]] && return\
    \ 0\n  done\n  return 1", "    # write your code here\n    echo \"not implemented\"",
  "  local str1=$1 str2=$2 l2=${#2}\n  local res=1\n  local str2a=${str2:0:$l2}\n\
    \  local str2b=${str2:$l2}\n  if [ \"${str1/$str2}\" == \"$str1\" ]; then\n  \
    \  local str2a=${str2:0:$((l2-1))}\n    local str2b=${str2:$((l2-1))}\n    res=`cycpattern_check\
    \ \"$str1\" \"$str2b$str2a\"`\n  fi\n  echo $res", "    local word=\"$1\"\n  \
    \  local pattern=\"$2\"\n    local len=${#pattern}\n    local begin=0\n    local\
    \ end=$len\n\n    if [ $len -eq 0 ]; then\n        echo True\n        return\n\
    \    fi\n\n    for (( i=0; i<len; i++ )); do\n        local rotated_pattern=${pattern:$begin:$end}\n\
    \        if [[ $word =~ $rotated_pattern ]]; then\n            echo True\n   \
    \         return\n        fi\n        ((begin++))\n        ((end++))\n    done\n\
    \n    echo False", "  if (( $# != 2 )); then\n    usage \"cycpattern_check\" \"\
    Not enough arguments\"\n  fi\n  local pattern=$1\n  local w=$2\n  if (( ${#w}\
    \ < 3 )); then\n    usage \"cycpattern_check\" \"String needs to be at least 3\
    \ chars long\"\n  fi\n  local len=${#w}\n  local rotated=$(echo \"$w\" | sed 's/\\\
    (.\\)/\\1\\n/g' | tail -n +2 | tr -d '\\n' | sed 's/./&\\n/g' | tac | tr -d '\\\
    n' | sed 's/./&\\n/g' | tac)\n  local tmp=\"$rotated\"\n  while [[ -n \"$tmp\"\
    \ ]]; do\n    if [[ \"$pattern\" =~ \"$tmp\" ]]; then\n      echo \"True\"\n \
    \     return 0\n    fi\n    tmp=\"${tmp:1}${tmp:0:1}\"\n  done\n  echo \"False\"\
    \n  return 1", "  word=\"$1\"\n  pattern=\"$2\"\n  # echo \"word: $word\"\n  #\
    \ echo \"pattern: $pattern\"\n  if [[ ${#word} < ${#pattern} ]]; then\n    return\
    \ 1\n  else\n    len=$((${#pattern} - 1))\n    first_letter=${pattern:0:1}\n \
    \   # echo \"first_letter: $first_letter\"\n    pos=$(awk -v a=\"$word\" -v b=\"\
    $first_letter\" 'BEGIN{print index(a,b)}')\n    if [[ $pos -gt 0 ]]; then\n  \
    \    # echo \"first letter found at $pos\"\n      for (( i=1; i<=$len; i++ ));\
    \ do\n        new_pattern=${pattern:$i:$len}\n        # echo \"new_pattern: $new_pattern\"\
    \n        new_pattern+=${pattern:0:$i}\n        # echo \"new_pattern: $new_pattern\"\
    \n        end_pos=$((pos + len))\n        # echo \"end_pos: $end_pos\"\n     \
    \   part=${word:$pos:$len}\n        # echo \"part: $part\"\n        if [[ $part\
    \ == $new_pattern ]]; then\n          return 0\n        fi\n      done\n    fi\n\
    \  fi\n  return 1", "  # your code here\n  return 0", "    local this_string=$1;\n\
    \    local substring=$2;\n    local original_string=$this_string;\n    local temp_string=$this_string;\n\
    \    local first_char=${temp_string:0:1};\n    local temp_string=${temp_string:1}${first_char};\n\
    \    while [ \"$this_string\" != \"$temp_string\" ]; do\n        if [[ \"$this_string\"\
    \ =~ $substring ]]; then\n            echo \"True\";\n            return 0;\n\
    \        fi\n        first_char=${temp_string:0:1};\n        temp_string=${temp_string:1}${first_char};\n\
    \    done\n    echo \"False\";\n    return 0;", "    local string=\"$1\"\n   \
    \ local substring=\"$2\"\n    # correct\n    local length=$((${#string}-1))\n\
    \    local to_check=${string:0:$length}\n\n    for ((i=0; i<$length; i++)); do\n\
    \        if [[ $to_check == *$substring* ]]; then\n            echo True\n   \
    \         return\n        fi\n        to_check=${to_check:1:$length}\n       \
    \ to_check+=${string:0:1}\n    done\n    echo False", "  local pattern\n  for\
    \ (( i=0; i<${#2}; i++ )); do\n    pattern=\"${2:i}${2:0:i}\"\n    if [[ $1 =~\
    \ $pattern ]]; then\n      echo \"True\"\n      return\n    fi\n  done\n  echo\
    \ \"False\"", "  # echo \"cycpattern_check\"\n  # input:\n  # abcd\n  # abd\n\
    \  # ----\n  # output:\n  # False\n  local first_word=\"$1\"\n  local second_word=\"\
    $2\"\n  local first_word_length=${#first_word}\n  local second_word_length=${#second_word}\n\
    \  # echo \"first_word_length: $first_word_length\"\n  # echo \"second_word_length:\
    \ $second_word_length\"\n  if [ \"$first_word_length\" -eq \"$second_word_length\"\
    \ ]; then\n    # echo \"first_word_length == second_word_length\"\n    local is_second_word_in_first_word=false\n\
    \    local i\n    local first_char\n    local first_char_index\n    local rest_of_first_word\n\
    \    local second_word_rotation\n    local is_second_word_rotation_in_first_word\n\
    \    local first_word_at_index\n    for (( i=0; i<first_word_length; i++ )); do\n\
    \      # echo \"i: $i\"\n      first_char=${first_word:$i:1}\n      # echo \"\
    first_char: $first_char\"\n      first_char_index=$(index_of \"$second_word\"\
    \ \"$first_char\")\n      # echo \"first_char_index: $first_char_index\"\n   \
    \   rest_of_first_word=${first_word:$((i+1))}\n      # echo \"rest_of_first_word:\
    \ $rest_of_first_word\"\n      if [ \"$first_char_index\" -ne -1 ]; then\n   \
    \     second_word_rotation=${second_word:$first_char_index}${second_word:0:$first_char_index}\n\
    \        # echo \"second_word_rotation: $second_word_rotation\"\n        is_second_word_rotation_in_first_word=$(string_contains\
    \ \"$first_word\" \"$second_word_rotation\")\n        # echo \"is_second_word_rotation_in_first",
  "  if [ $# -ne 2 ]; then\n    return\n  fi\n  first_arg=$1\n  second_arg=$2\n  for\
    \ ((i=0; i<${#second_arg}; i++)); do\n    tmp=${second_arg:0:$i}\n    new_arg=${second_arg:$i}${tmp}\n\
    \    if [ $first_arg == $new_arg ]; then\n      echo 'True'\n      return\n  \
    \  fi\n  done\n  echo 'False'", "    if [[ ${#1} -lt ${#2} ]]; then\n        return\
    \ 1\n    fi\n    if [[ \"$1\" =~ (.*).*$2(.*) ]]; then\n        return 0\n   \
    \ fi\n    return 1", "  local string=$1\n  local sub=$2\n  local strlen=${#string}\n\
    \  local sublen=${#sub}\n  local i=0\n  local new_string\n  # guard against empty\
    \ strings\n  if [[ -z $sub ]]; then\n    echo \"False\"\n    return\n  fi\n  #\
    \ check for exact match\n  if [[ $string == $sub ]]; then\n    echo \"True\"\n\
    \    return\n  fi\n  # guard against substrings longer than strings\n  if [[ $sublen\
    \ -gt $strlen ]]; then\n    echo \"False\"\n    return\n  fi\n  while [[ $i -lt\
    \ $strlen ]]; do\n    # get new strings\n    new_string=${string:$i:$sublen}\n\
    \    if [[ $new_string == $sub ]]; then\n      echo \"True\"\n      return\n \
    \   fi\n    let i+=1\n  done\n  echo \"False\"", "\tlocal pattern=${1}\n\tlocal\
    \ text=${2}\n\tlocal pattern_length=${#pattern}\n\tlocal text_length=${#text}\n\
    \tlocal first_char=${text:0:1}\n\tfor ((i=0; i<text_length; i++)); do\n\t\tif\
    \ [[ ${text:i:1} == ${first_char} ]]; then\n\t\t\ttest_str=${text:i:text_length}\n\
    \t\t\t#echo test_str=${test_str}\n\t\t\tif [[ ${pattern} == ${test_str} ]]; then\n\
    \t\t\t\techo 1\n\t\t\t\treturn\n\t\t\tfi\n\t\tfi\n\tdone\n\techo 0", '  # write
    your code here', "  if (( ${#1} < ${#2} )); then\n    echo \"False\"\n    return\n\
    \  fi\n  local l1=${#1}\n  local l2=${#2}\n  for (( i=0; i<${l1}; i++ )); do\n\
    \    sub1=${1:0:$i}\n    sub2=${1:$i:$l1}\n    if [[ \"$sub1$sub2\" == *\"$2\"\
    * ]]; then\n      echo \"True\"\n      return\n    fi\n  done\n  echo \"False\"",
  "  if [ $# -ne 2 ]; then\n    echo \"error: cycpattern_check takes 2 strings\"\n\
    \    return 1\n  fi\n  local string=$1\n  local pattern=$2\n  if [ ${#pattern}\
    \ -ge ${#string} ]; then\n    echo \"error: cycpattern_check requires pattern\
    \ to be shorter than string\"\n    return 1\n  fi\n  local pattern_start=${pattern:0:1}\n\
    \  local pattern_end=${pattern:(-1)}\n  local pattern_trimmed=${pattern:1:-1}\n\
    \  local pattern_rotated=\"$pattern_end$pattern_trimmed\"\n  if [[ \"$string\"\
    \ == *\"$pattern\"* ]]; then\n    echo true\n    return 0\n  fi\n  while [ $pattern_rotated\
    \ != $pattern ]; do\n    if [[ \"$string\" == *\"$pattern_rotated\"* ]]; then\n\
    \      echo true\n      return 0\n    fi\n    pattern_rotated=\"$pattern_rotated${pattern_rotated:0:1}\"\
    \n    pattern_rotated=${pattern_rotated:1}\n  done\n  echo false\n  return 0",
  "  local -i i l\n  local r a\n  l=$((${#2}-1))\n  for ((i=0;i<$l;i++)); do\n   \
    \ ((a=l-i))\n    r=${2:$i:$a}${2:0:$i}\n    if [[ $1 =~ ${r} ]]; then\n      echo\
    \ \"True\"\n      return 0\n    fi\n  done\n  echo \"False\""]
stop_tokens:
- "\n}"
