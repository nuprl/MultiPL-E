name: HumanEval_30_get_positive
language: sh
prompt: "#!/bin/bash\n# Return only positive numbers in the list.\n# >>> get_positive([-1,\
  \ 2, -4, 5, 6])\n# [2, 5, 6]\n# >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123,\
  \ 1, -10])\n# [5, 3, 2, 3, 9, 123, 1]\n#\n# $1 is a space-separated list\nget_positive()\
  \ {\n"
tests: "}\n\ncandidate() {\n    get_positive \"$@\"\n}\n\nset -e\nrun_test() {\n \
  \   [[ $(candidate \"-1 -2 4 5 6\") = \"4 5 6\" ]]\n    [[ $(candidate \"5 3 -5\
  \ 2 3 3 9 0 123 1 -10\") = \"5 3 2 3 3 9 123 1\" ]]\n    [[ $(candidate \"-1 -2\"\
  ) = \"\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n}\n\nrun_test"
completions: ["  echo \"$@\" | sed 's/-\\([0-9]\\+\\)/\\1/g' | sed '/^$/d'", "   \
    \ local -a input=(${1})\n    echo \"${input[@]}\" | grep -E \"^[0-9]*[1-9][0-9]*$\"",
  "  echo \"$1\" | sed -r 's/-\\d+//g'", "    python3 -c \"\nimport sys\ndef is_positive(n):\n\
    \    return n > 0\n\ndef is_number(s):\n    try:\n        float(s)\n        return\
    \ True\n    except ValueError:\n        return False\n\nnumbers = sys.argv[1].split()\n\
    \n# Filter only positive and number-like strings\npositive_numbers = filter(lambda\
    \ x: is_positive(float(x)), numbers)\n\n# Print out only positive numbers\nfor\
    \ number in positive_numbers:\n    print(number)\n\" \"$1\"", "    echo $1 | sed\
    \ 's/-/0/g' | sed 's/[[:blank:]]/\\n/g' | sort -n | grep -E '^[1-9]+$'", "\tif\
    \ (( $# == 0 )); then\n\t\techo \"Usage: get_positive <list of numbers>\"\n\t\t\
    return 1\n\tfi\n\n\tlocal filtered\n\tfiltered=$(grep -E '^[0-9]+$' <<<\"$*\"\
    )\n\techo \"$filtered\"", "    # write your solution here\n    list=$@\n    i=0\n\
    \    while [ $i -lt ${#list[@]} ]\n    do\n        check=${list[$i]}\n       \
    \ if [ $check -lt 0 ]\n        then\n            unset list[$i]\n        fi\n\
    \        let i=$i+1\n    done\n    echo ${list[@]}", "  # put your code here\n\
    \  local -n lst=$1\n  local res=()\n  for var in \"${lst[@]}\"; do\n    if [[\
    \ $var -gt 0 ]]; then\n      res+=($var)\n    fi\n  done\n  echo \"${res[@]}\"",
  "    list=($1)\n    result=\"\"\n    for i in ${list[@]}; do\n        if [[ $i -gt\
    \ 0 ]]; then\n            result=\"$result $i\"\n        fi\n    done\n    echo\
    \ $result", "    echo \"$1\" | awk '{print $1}'", "    if [ $# -lt 1 ]; then\n\
    \        echo \"usage: get_positive <list>\"\n        return 1\n    fi\n\n   \
    \ for i in $@; do\n        if [ $i -gt 0 ]; then\n            echo $i\n      \
    \  fi\n    done", "  local -a arr=(\"$@\")\n  local -a pos_arr\n  for i in \"\
    ${arr[@]}\"; do\n    if [[ $i -gt 0 ]]; then\n      pos_arr+=(\"$i\")\n    fi\n\
    \  done\n  echo \"${pos_arr[@]}\"", "    local list=$1\n    local res=()\n   \
    \ for el in $list; do\n        if [[ $el -gt 0 ]]; then\n            res+=($el)\n\
    \        fi\n    done\n    echo ${res[@]}", "    echo \"$1\" | tr ' ' '\\n' |\
    \ grep '^[0-9]*$' | tr '\\n' ' '", "\t# TODO\n\tfor num in $1; do\n\t\tif (( num\
    \ > 0 )); then\n\t\t\techo $num\n\t\tfi\n\tdone", "    local list=$1\n    local\
    \ pos_list=()\n    for num in $list; do\n        if [ $num -gt 0 ]; then\n   \
    \         pos_list+=($num)\n        fi\n    done\n    echo \"${pos_list[@]}\"",
  "  local res=()\n  for i in $1; do\n    if [ $i -gt 0 ]; then\n      res+=($i)\n\
    \    fi\n  done\n  echo ${res[@]}", "  local input_list=\"$1\"\n  local result=()\n\
    \  for i in $input_list; do\n    if [[ $i -gt 0 ]]; then\n      result+=($i)\n\
    \    fi\n  done\n  printf \"${result[@]}\"", "    printf '%s\\n' \"$1\" | awk\
    \ '$1 > 0 {print $1}'", "  echo ${@} | awk '{for(i=1;i<=NF;i++) if($i>0) printf(\"\
    %d \",$i)}'"]
stop_tokens:
- "\n}"
