name: HumanEval_18_how_many_times
language: sh
prompt: "#!/bin/bash\n# Find how many times a given substring can be found in the\
  \ original string. Count overlaping cases.\n# >>> how_many_times('', 'a')\n# 0\n\
  # >>> how_many_times('aaa', 'a')\n# 3\n# >>> how_many_times('aaaa', 'aa')\n# 3\n\
  #\n# $1 is a string\n# $2 is a string\nhow_many_times() {\n"
tests: "}\n\ncandidate() {\n    how_many_times \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"\" \"x\") = \"0\" ]]\n    [[ $(candidate \"xyxyxyx\" \"x\"\
  ) = \"4\" ]]\n    [[ $(candidate \"cacacacac\" \"cac\") = \"4\" ]]\n    [[ $(candidate\
  \ \"john doe\" \"john\") = \"1\" ]]\n}\n\nrun_test"
completions: ['  echo -n "${1}" | awk "{print gsub(/$2/, \"&\")}"', "    if [[ $1\
    \ == *$2* ]]; then\n\techo $1 | grep -o $2 | wc -l\n    else\n\techo 0\n    fi",
  "    _OCCURENCES=$(grep -o \"$2\" <<< \"$1\" | wc -l)\n    if [[ $_OCCURENCES -gt\
    \ 0 ]]; then\n        echo $_OCCURENCES\n    else\n        echo 0\n    fi", " \
    \ local string=$1\n  local substring=$2\n  [[ -z $string || -z $substring ]] &&\
    \ return 0\n  local count=0\n  local offset=0\n  for (( i=0; i<${#string}; i++\
    \ )); do\n    [[ ${string:$i:${#substring}} == $substring ]] && (( count++ ))\n\
    \  done\n  echo $count", "    string=$1\n    substring=$2\n    count=0\n    i=0\n\
    \    while [ $i -lt ${#string} ]; do\n        if [ \"${string:$i:${#substring}}\"\
    \ == \"$substring\" ]; then\n            let count++\n            let i++\n  \
    \      else\n            let i++\n        fi\n    done\n    echo $count", "\t\
    local str_len=${#1}\n\tlocal sub_len=${#2}\n\tlocal k=0\n\tlocal answer=0\n\t\
    for((i=0; i<str_len; i++)); do\n\t\tfor((j=0; j<sub_len; j++)); do\n\t\t\tif [[\
    \ \"${1:$i:1}\" == \"${2:$j:1}\" ]]; then\n\t\t\t\tk=$(($k+1))\n\t\t\telse\n\t\
    \t\t\tk=0\n\t\t\tfi\n\t\t\tif [[ $k -eq $sub_len ]]; then\n\t\t\t\tanswer=$(($answer+1))\n\
    \t\t\t\tk=0\n\t\t\tfi\n\t\tdone\n\tdone\n\techo $answer", "  re='^[0-9]$'\n  if\
    \ ! [[ $1 =~ $re ]] ; then\n    echo \"Error: $1 is not a number\" >&2; exit 1\n\
    \  fi\n  if ! [[ $2 =~ $re ]] ; then\n    echo \"Error: $2 is not a number\" >&2;\
    \ exit 1\n  fi\n  let result=$1+$2\n  echo $result", "    if [ -z \"$1\" ]; then\n\
    \        echo \"0\"\n        return\n    fi\n    if [ -z \"$2\" ]; then\n    \
    \    echo \"0\"\n        return\n    fi\n    local str=$1\n    local substr=$2\n\
    \    local times=$(echo \"$str\" | sed -n \"s/.*$substr//p\" | wc -c)\n    echo\
    \ \"$times\"", "    case $1 in\n        *$2*) how_many_times ${1#$2} $2 $(( ${3:-0}\
    \ + 1 )) ;;\n        *)    echo ${3:-0} ;;\n    esac", "    local string=\"$1\"\
    \n    local substring=\"$2\"\n    local index=0\n    local counter=0\n    local\
    \ max_len_string=${#string}\n    local max_len_substring=${#substring}\n    if\
    \ [ \"$max_len_string\" -lt \"$max_len_substring\" ]; then\n        echo \"0\"\
    \n        return 0\n    fi\n    # Loop over all indexes\n    while [ \"$index\"\
    \ -lt \"$max_len_string\" ]; do\n        # Find where is the substring\n     \
    \   index=$(($index+1))\n        if [ \"${string:$index:$max_len_substring}\"\
    \ == \"$substring\" ]; then\n            counter=$(($counter+1))\n           \
    \ index=$(($index+$max_len_substring-1))\n        fi\n    done\n    echo \"$counter\"",
  "    if [[ $1 == \"\" ]] || [[ $2 == \"\" ]]; then\n        echo 0\n    else\n \
    \       echo \"${1//$2/++}\" | tr -d '[:alpha:]' | wc -c\n    fi", "    local\
    \ original=$1\n    local sub=$2\n    local n=0\n    local offset=0\n    while\
    \ true; do\n        local new_offset=$(grep -ob $sub <<< $original | cut -d ':'\
    \ -f 1)\n        if [ -z \"$new_offset\" ]; then\n            break\n        fi\n\
    \        n=$((n+1))\n        offset=$((new_offset+1))\n        original=${original:$offset}\n\
    \    done\n    echo $n", "    len_str=$(len \"$1\")\n    len_substr=$(len \"$2\"\
    )\n    [[ len_str -lt len_substr ]] && return 0\n\n    times=0\n    i=0\n    while\
    \ [ $i -lt $len_str ]; do\n        j=0\n        while [ $j -lt $len_substr ];\
    \ do\n            if [ \"${1:$i:1}\" != \"${2:$j:1}\" ]; then\n              \
    \  break\n            fi\n            j=$(( j + 1 ))\n        done\n        [[\
    \ $j -eq $len_substr ]] && times=$(( times + 1 ))\n        i=$(( i + 1 ))\n  \
    \  done\n    echo $times", "  local -i count=0\n  local pattern=$2\n  local string=$1\n\
    \  while [[ -n $string ]]; do\n    if [[ $string = $pattern ]]; then\n      let\
    \ count+=1\n      break\n    else\n      if [[ $string = ${string#*$pattern} ]];\
    \ then\n        break\n      else\n        let count+=1\n        string=${string#*$pattern}\n\
    \      fi\n    fi\n  done\n  echo $count", "    [[ $1 =~ $2 ]]\n    if [[ $? -eq\
    \ 0 ]]; then\n        echo \"${#BASH_REMATCH[*]}\"\n    else\n        echo 0\n\
    \    fi", '    echo $1 | grep -o $2 | wc -l', "    [[ -z $1 ]] && { echo 0; return;\
    \ }\n    echo \"$1\" | grep -o \"$2\" | wc -l", "  local given_string=$1\n  local\
    \ substring=$2\n  echo $given_string | grep -o $substring | wc -l", "    if [[\
    \ \"$#\" -ne 2 ]]; then\n        echo \"Invalid number of arguments. Expected\
    \ 2 got $#\"\n        exit 1\n    fi\n    if [[ -z \"$1\" ]]; then\n        echo\
    \ 0\n        exit 0\n    fi\n    if [[ -z \"$2\" ]]; then\n        echo 0\n  \
    \      exit 0\n    fi\n    if [[ \"${#1}\" -lt \"${#2}\" ]]; then\n        echo\
    \ 0\n        exit 0\n    fi\n    if [[ ! \"$1\" =~ [a-zA-Z] ]]; then\n       \
    \ echo 0\n        exit 0\n    fi\n    if [[ ! \"$2\" =~ [a-zA-Z] ]]; then\n  \
    \      echo 0\n        exit 0\n    fi\n    if [[ \"${#1}\" -eq \"${#2}\" ]]; then\n\
    \        if [[ \"$1\" == \"$2\" ]]; then\n            echo 1\n            exit\
    \ 0\n        else\n            echo 0\n            exit 0\n        fi\n    fi\n\
    \    i=0\n    counter=0\n    while [ \"$i\" -lt \"${#1}\" ]; do\n        substr=\"\
    ${1:$i:${#2}}\"\n        if [[ \"$substr\" == \"$2\" ]]; then\n            counter=$((counter+1))\n\
    \        fi\n        i=$((i+1))\n    done\n    echo $counter", "\tcount=0\n\t\
    str=\"$1\"\n\tsubstr=\"$2\"\n\twhile [[ \"$str\" =~ $substr ]]; do\n\t\tcount=$((count+1))\n\
    \t\tstr=\"${str/$substr}\"\n\tdone\n\techo $count"]
stop_tokens:
- "\n}"
