language: sh
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  printf \"%.0f\\\
    n\" $1\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    echo \"${1}\
    \ 0.5 + p\" | dc\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\"\
    ) = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  printf \"%s\\\
    n\" \"${1}\" | bc -l | sed -e 's/\\.[0-9]*//g'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    # your code\
    \ here\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp8wtjg7m2.sh: line 19: syntax error near unexpected token `}''

    /tmp/tmp8wtjg7m2.sh: line 19: `}''

    '
  stdout: ''
  timestamp: 1660020296
- exit_code: 0
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    echo \"$1\"\
    \ | awk '{print (int($1 > 0) ? int($1 + 0.5) : int($1 - 0.5))}'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    # Your code\
    \ here\n    echo \"Not yet implemented\"\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # echo $1\n\
    \  # echo \"(( $1 + 0.5 ))\"\n  # echo \"echo $1 | awk '{ print int($1 + 0.5)}'\"\
    \n  echo $1 | awk '{ print int($1 + 0.5)}'\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    i=${1%.*}\n\
    \    j=${1#*.}\n    if [ $j -ge 5 ]; then\n        ((i++))\n    fi\n    echo $i\n\
    }\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n  \
    \  [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n\
    \    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"\
    15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    echo $1 |\
    \ perl -pe 's/\\.\\d+//;'\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    echo ${1}\
    \ | xargs printf \"%.0f\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo \"scale=0;$1/1\"\
    \ | bc -l\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  if (( $(echo\
    \ \"$1 > 0\" | bc -l) )); then\n    echo $(( $1 + 0.5 | bc -l ))\n  else\n   \
    \ echo $(( $1 - 0.5 | bc -l ))\n  fi\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp1w83xg4t.sh: line 19: 10 + 0.5 | bc -l : syntax error: invalid
    arithmetic operator (error token is ".5 | bc -l ")

    '
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  printf \"%.0f\\\
    n\" \"$1\"\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    printf %.0f\
    \ $1\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    local -i N=10\
    \ M=15\n    local -i n=$(echo \"scale=0; $1/1\" | bc)\n    local -i m=$(echo \"\
    scale=0; $1/1\" | bc)\n    local -i n_r=$(echo \"$1 - $n\" | bc)\n    local -i\
    \ m_r=$(echo \"$m - $1\" | bc)\n    local -i N_M=$(echo \"$n - $M\" | bc)\n  \
    \  local -i M_N=$(echo \"$M - $n\" | bc)\n    # if the number is equidistant from\
    \ two integers\n    if [ $n_r -eq $m_r ]; then\n        # round it away from zero\n\
    \        [ $N_M -lt $M_N ] && echo $n || echo $m\n    # if the number is closer\
    \ to N\n    elif [ $n_r -lt $m_r ]; then\n        echo $n\n    # if the number\
    \ is closer to M\n    else\n        echo $m\n    fi\n}\n\ncandidate() {\n    closest_integer\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n\
    \    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"\
    -16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\")\
    \ = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmprovuwchm.sh: line 21: local: .5: syntax error: operand expected
    (error token is ".5")

    '
  stdout: ''
  timestamp: 1660020296
- exit_code: 2
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  # your code\
    \ here\n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"\
    15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmprb532tcs.sh: line 19: syntax error near unexpected token `}''

    /tmp/tmprb532tcs.sh: line 19: `}''

    '
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  local -i base=$1\
    \ floor\n  base=${base#-}\n  # check if $1 contains a decimal\n  if [[ $1 == *.*\
    \ ]]; then\n    floor=${1%.*}\n    # check if $1 is negative\n    if [[ $1 !=\
    \ \"$base\" ]]; then\n      base=${base%.*}\n      # check if $1 is equidistant\
    \ from the two integers\n      if ((base > floor + 0.5)); then\n        echo $base\n\
    \      else\n        echo $(($base - 1))\n      fi\n    else\n      # if $1 is\
    \ not negative, check if it is equidistant from the two integers\n      if ((base\
    \ > floor + 0.5)); then\n        echo $base\n      else\n        echo $(($base\
    \ - 1))\n      fi\n    fi\n  else\n    echo $1\n  fi\n}\n\ncandidate() {\n   \
    \ closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\"\
    ) = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate \"\
    -15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpjz0bitvw.sh: line 18: local: 14.5: syntax error: invalid arithmetic
    operator (error token is ".5")

    '
  stdout: ''
  timestamp: 1660020296
- exit_code: 0
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo $1 | awk\
    \ '{ printf(\"%d\\n\", ($1 < 0) ? int($1 - 0.5) : int($1 + 0.5)) }'\n}\n\ncandidate()\
    \ {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\" ]]\n    [[ $(candidate\
    \ \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\") = \"15\" ]]\n    [[ $(candidate\
    \ \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n  echo \"${1/.*}\"\
    \n}\n\ncandidate() {\n    closest_integer \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate \"14.5\") = \"15\"\
    \ ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate \"15.3\"\
    ) = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
- exit_code: 1
  program: "#!/bin/bash\n# Create a function that takes a value (string) representing\
    \ a number\n# and returns the closest integer to it. If the number is equidistant\n\
    # from two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\n#\n# $1 is a string\nclosest_integer() {\n    echo $1 |\
    \ awk '{print int($1+0.5)}'\n}\n\ncandidate() {\n    closest_integer \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"10\") = \"10\" ]]\n    [[ $(candidate\
    \ \"14.5\") = \"15\" ]]\n    [[ $(candidate \"-15.5\") = \"-16\" ]]\n    [[ $(candidate\
    \ \"15.3\") = \"15\" ]]\n    [[ $(candidate \"0\") = \"0\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020296
