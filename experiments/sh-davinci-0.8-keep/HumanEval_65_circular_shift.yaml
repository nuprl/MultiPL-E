name: HumanEval_65_circular_shift
language: sh
prompt: "#!/bin/bash\n# Circular shift the digits of the integer x, shift the digits\
  \ right by shift\n# and return the result as a string.\n# If shift > number of digits,\
  \ return digits reversed.\n# >>> circular_shift(12, 1)\n# \"21\"\n# >>> circular_shift(12,\
  \ 2)\n# \"12\"\n#\n# $1 is an integer\n# $2 is an integer\ncircular_shift() {\n"
tests: "}\n\ncandidate() {\n    circular_shift \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"100\" \"2\") = \"001\" ]]\n    [[ $(candidate \"12\" \"2\"\
  ) = \"12\" ]]\n    [[ $(candidate \"97\" \"8\") = \"79\" ]]\n    [[ $(candidate\
  \ \"12\" \"1\") = \"21\" ]]\n    [[ $(candidate \"11\" \"101\") = \"11\" ]]\n}\n\
  \nrun_test"
completions: ["  # check that $1 is an integer\n  if [[ \"$1\" =~ ^[0-9]+$ ]]; then\n\
    \    # if $2 isn't an integer, it defaults to 0\n    if [[ \"$2\" =~ ^[0-9]+$\
    \ ]]; then\n      shift=$2\n    else\n      shift=0\n    fi\n    # check that\
    \ $shift is greater than the number of digits\n    if [[ $shift -ge ${#1} ]];\
    \ then\n      # reverse the digits\n      echo $1 | rev\n    else\n      # shift\
    \ the digits right $shift times\n      echo \"$1\" | cut -c$((shift+1))-${#1}\
    \ | tr -d '\\n'\n      echo \"$1\" | cut -c-$shift | tr -d '\\n'\n    fi\n  else\n\
    \    echo \"circular_shift() requires \\$1 to be an integer\"\n  fi", "    local\
    \ digits=$(expr length \"$1\")\n    local result=\"\"\n    local shift=$2\n  \
    \  while [ $shift -gt $digits ]; do\n        shift=$(expr $shift - $digits)\n\
    \    done\n    if [ $shift -eq 0 ]; then\n        echo \"$1\"\n    else\n    \
    \    result=$(echo \"$1\" | rev | cut -c -$shift | rev)\n        result=$result$(echo\
    \ \"$1\" | rev | cut -c $(expr $shift + 1)- | rev)\n        echo \"$result\"\n\
    \    fi", "  local shift=$2; local -i length=${#1}; local -i count=1\n  [ $shift\
    \ -gt $length ] && shift=$length\n  while ((count < length)); do\n    echo -n\
    \ \"${1:$((length - shift)):$shift}\"\n    shift=$((length - shift))\n    [ $shift\
    \ -eq 0 ] && break\n    echo -n \"${1:0:$shift}\"\n    count=$((count + 1))\n\
    \  done\n  echo", "    if [ -z \"$1\" ]\n    then\n        echo \"ERROR: Must\
    \ pass an integer to circular_shift().\"\n        exit 1\n    fi\n    if [ -z\
    \ \"$2\" ]\n    then\n        echo \"ERROR: Must pass an integer to circular_shift().\"\
    \n        exit 1\n    fi\n    local n=$1\n    local shift=$2\n    local digits=$(get_digits\
    \ $n)\n    local num_digits=$(get_num_digits $n)\n    if [ $shift -gt $num_digits\
    \ ]\n    then\n        local result=$(echo $digits | rev)\n    else\n        local\
    \ num_digits_to_shift=$(expr $num_digits - $shift)\n        local last_digits=$(echo\
    \ $digits | cut -c 1-$num_digits_to_shift)\n        local first_digits=$(echo\
    \ $digits | cut -c $num_digits_to_shift- | rev)\n        local result=$(echo $first_digits$last_digits)\n\
    \    fi\n    echo $result", "    local x=\"$1\"\n    local shift=\"$2\"\n    local\
    \ length=\"${#x}\"\n    if (( shift > length )); then\n        echo \"${x::-1}\"\
    \ | rev\n    else\n        echo \"${x::shift}${x:0:$((length - shift))}\"\n  \
    \  fi", "    if (( $1 == 0 )); then\n        echo 0\n        return\n    fi\n\
    \    local digits_length\n    digits_length=$(trim_zeros \"$1\" | wc -c)\n   \
    \ local result\n    result=$(( $1 / 10 ** (digits_length - $2) ))\n    result=$((\
    \ 10 ** ($2 - 1) * ($1 % 10 ** (digits_length - $2)) + result ))\n    trim_zeros\
    \ \"$result\"", "  x=$1\n  shift=$2\n  if [[ \"$shift\" -gt ${#x} ]]; then\n \
    \   y=$(echo $x | rev)\n  else\n    y=$(echo $x | cut -c $shift- | rev)$(echo\
    \ $x | cut -c -$shift | rev)\n  fi\n  echo $y", "  local number=$1\n  local shift=$2\n\
    \  local length=\"${#number}\"\n  local shifted_number=$number\n  if [ $shift\
    \ -lt $length ]; then\n    shifted_number=${number:$shift}${number:0:$shift}\n\
    \  else\n    shifted_number=$(reverse $number)\n  fi\n  echo $shifted_number",
  "    local x=\"$1\"\n    local shift=\"$2\"\n    local count=$(echo $x | awk '{print\
    \ length($0)}')\n    if [[ $shift -lt $count ]]; then\n        echo $x | cut -c\
    \ $shift- | cut -c -$(($count-$shift))\n    else\n        echo $x | rev\n    fi",
  "    declare -i x=$1\n    declare -i shift=$2\n    declare -i len=${#x}\n    declare\
    \ -i remainder=$(( len - shift ))\n    if (( remainder < 0 )); then\n        remainder=0\n\
    \    fi\n    echo $(( x % 10**shift ))$(( x / 10**remainder ))", "  local n=$1\n\
    \  local shift=$2\n  local base=1\n  local temp=0\n  local string=\"\"\n  while\
    \ (( n )); do\n    temp=$(( n % 10 ))\n    string=$(( temp * base ))\n    (( base\
    \ *= 10 ))\n    (( n /= 10 ))\n  done\n  if (( shift > base )); then\n    temp=$((\
    \ shift / base ))\n    shift=$(( shift % base ))\n    while (( temp )); do\n \
    \     (( shift += base ))\n      (( temp-- ))\n    done\n  fi\n  shift=$(( base\
    \ - shift ))\n  while (( shift )); do\n    temp=$(( string % 10 ))\n    (( string\
    \ /= 10 ))\n    (( string += temp * base ))\n    (( shift-- ))\n  done\n  echo\
    \ $string", "    local result\n    result=$(echo $1 | rev)\n    if [ $2 -gt ${#result}\
    \ ]; then\n        result=$(echo $result | rev)\n    else\n        result=$(echo\
    \ $result | cut -c 1-$2 | rev)$(echo $result | cut -c $((2 + $2))-)\n    fi\n\
    \    echo $result", "    if [[ -z $1 ]]; then\n        echo \"Argument missing\"\
    \n        exit 1\n    fi\n    if [[ -z $2 ]]; then\n        echo \"Argument missing\"\
    \n        exit 1\n    fi\n    echo \"${1: -$2}${1:0:${#1} - $2}\"", "  if (( $2\
    \ > ${#1} )); then\n    echo $1 | rev\n  else\n    echo $1 | cut -c $(($2+1))-${#1}\
    \ $(($2+1))-${#1} | rev\n  fi", "    local -i x=${1}\n    local -i shift=${2}\n\
    \    local -i pow=10\n    local -i r\n    local -i s\n    local -i m\n    local\
    \ -i t\n    local -i z\n    local -i digits=1\n    local -i x_copy=${x}\n    local\
    \ result\n    r=0\n    s=1\n    m=1\n    t=1\n    z=0\n    x_copy=${x}\n    while\
    \ (( m <= x_copy )); do\n        (( m *= 10 ))\n        (( digits++ ))\n    done\n\
    \    if (( x == 0 )); then\n        echo ${x}\n        return 0\n    fi\n    while\
    \ (( shift-- )); do\n        while (( x > 0 )); do\n            (( r = x % 10\
    \ ))\n            (( x /= 10 ))\n            (( r *= s ))\n            (( z +=\
    \ r ))\n            (( s *= 10 ))\n        done\n        x=${z}\n        (( z\
    \ = 0 ))\n        (( s = 1 ))\n    done\n    while (( digits-- )); do\n      \
    \  (( t *= 10 ))\n    done\n    result=$(( z * t + x ))\n    echo ${result}",
  "    local -i x=${1}\n    local -i shift=${2}\n    if (( shift > ${#x} )); then\n\
    \        # Reverse the input string.\n        # lc    convert uppercase to lowercase\n\
    \        # tr    translate characters\n        # rev   reverse the input string\n\
    \        # dc    desktop calculator\n        echo ${x} | lc | tr 'a-z' 'A-Z' |\
    \ rev | dc -e '?si1+xnrs'\n    else\n        # Put $shift characters starting\
    \ at the end of the string\n        # at the beginning of the string.\n      \
    \  echo ${x} | rev | cut -c ${shift}- | rev\n    fi", "    local x=$1\n    local\
    \ shift=$2\n    local n_digits=$(printf \"%s\" \"$x\" | wc -c)\n    local rest=$(printf\
    \ \"%0${n_digits}d\" $((x % $((${10}**$(($n_digits - 1)))))))\n    if (( $n_digits\
    \ > $shift )); then\n        printf \"%0${n_digits}d\" $((x / $((${10}**$(($n_digits\
    \ - 1)))))))$rest\n    else\n        printf \"%0${n_digits}d\" $((rest / $((${10}**$(($n_digits\
    \ - 1)))))))$(printf \"%0${n_digits}d\" $((rest % $((${10}**$(($n_digits - 1)))))))\n\
    \    fi", "    local number=\"$1\"\n    local shift=\"$2\"\n    local number_len=${#number}\n\
    \    local result=\"\"\n    if [ \"$shift\" -gt \"$number_len\" ]; then\n    \
    \    for ((i=$number_len-1; i>=0; i--)); do\n            result+=\"${number:$i:1}\"\
    \n        done\n    else\n        for ((i=$shift; i<$number_len; i++)); do\n \
    \           result+=\"${number:$i:1}\"\n        done\n        for ((i=0; i<$shift;\
    \ i++)); do\n            result+=\"${number:$i:1}\"\n        done\n    fi\n  \
    \  echo \"$result\"", "    local x=$1\n    local shift=$2\n    local digits=$(echo\
    \ $x | rev | grep -o . | tr -d '\\n')\n    local result=$(echo $digits | cut -c-$shift)\n\
    \    if [ -z \"$result\" ]; then\n        echo $digits\n    else\n        echo\
    \ $result\n    fi", "  x=\"$1\"\n  shift=\"$2\"\n  x=\"${x//[^0-9]/}\" # remove\
    \ non-digits\n  if [[ ${#x} -lt $shift ]]; then\n    x=\"${x//[0-9]/}\" # remove\
    \ digits\n    x=\"$(echo -n \"$x\" | rev)\" # reverse\n  else\n    x=\"${x:$shift}${x:0:$shift}\"\
    \n  fi\n  echo -n \"$x\""]
stop_tokens:
- "\n}"
