language: sh
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n    local max_depth=0\n    local curr_depth=0\n    local len=${#1}\n    local\
    \ index=0\n    local max_array=()\n    local tmp_array=()\n    local final_array=()\n\
    \    #echo \"len: $len\"\n    #echo \"string: $1\"\n    while [[ $index -lt $len\
    \ ]]; do\n        local curr=${1:$index:1}\n        #echo \"curr: $curr\"\n  \
    \      if [[ $curr == \"(\" ]]; then\n            curr_depth=$((curr_depth+1))\n\
    \            #echo \"curr_depth: $curr_depth\"\n            if [[ $curr_depth\
    \ -gt $max_depth ]]; then\n                max_depth=$curr_depth\n           \
    \ fi\n        elif [[ $curr == \")\" ]]; then\n            curr_depth=$((curr_depth-1))\n\
    \            #echo \"curr_depth: $curr_depth\"\n        fi\n        tmp_array[$index]=$curr_depth\n\
    \        index=$((index+1))\n    done\n    #echo \"tmp_array: ${tmp_array[@]}\"\
    \n    max_array=(${tmp_array[@]})\n    #echo \"max_array: ${max_array[@]}\"\n\
    \    len=${#max_array[@]}\n    index=0\n    while [[ $index -lt $len ]]; do\n\
    \        local curr=${max_array[$index]}\n        if [[ $curr -eq $max_depth ]];\
    \ then\n            final_array+=(\"$curr\")\n        fi\n        index=$((index+1))\n\
    \    done\n    echo \"${final_array[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n  # Write your code here\n  #return\n  parens=$1\n  if [[ $parens == \"\"\
    \ ]]; then\n    echo \"No input\"\n    return\n  fi\n  level=0\n  maxlevel=0\n\
    \  levels=()\n  for (( i=0; i<${#parens}; i++ )); do\n    if [[ ${parens:$i:1}\
    \ == \"(\" ]]; then\n      ((level++))\n      if [[ $level -gt $maxlevel ]]; then\n\
    \        maxlevel=$level\n      fi\n    elif [[ ${parens:$i:1} == \")\" ]]; then\n\
    \      ((level--))\n    elif [[ ${parens:$i:1} == \" \" ]]; then\n      levels+=($maxlevel)\n\
    \      maxlevel=0\n      level=0\n    fi\n  done\n  levels+=($maxlevel)\n  echo\
    \ ${levels[@]}\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n    #\n    # Your code here.\n    #\n    maxDepth=0\n    local tempDepth=0\n\
    \    local tempIndex=0\n    local lenth=0\n    local result=()\n    lenth=${#1}\n\
    \    for((i=0;i<lenth;i++))\n    do\n        case ${1:i:1} in\n            \"\
    (\")\n                tempDepth=$(($tempDepth+1))\n                if [ $tempDepth\
    \ -gt $maxDepth ]\n                then\n                    maxDepth=$tempDepth\n\
    \                fi\n                ;;\n            \")\")\n                tempDepth=$(($tempDepth-1))\n\
    \                ;;\n            \" \")\n                result=(${result[@]}\
    \ $maxDepth)\n                maxDepth=0\n                tempDepth=0\n      \
    \          ;;\n        esac\n    done\n    result=(${result[@]} $maxDepth)\n \
    \   echo ${result[@]}\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") =\
    \ \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\"\
    \ ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n    # Create an array with an element for each group.\n    local parens_strs=()\n\
    \    local n=0\n    local group=\"\"\n    local i\n    for ((i=0; i<${#1}; i++));\
    \ do\n        # Starting a new group.\n        if [[ ${1:$i:1} == \"(\" ]]; then\n\
    \            if [[ $n -eq 0 ]]; then\n                group=\"($\"\n         \
    \   else\n                group=\"$group($\"\n            fi\n            n=$((n+1))\n\
    \        elif [[ ${1:$i:1} == \")\" ]]; then\n            n=$((n-1))\n       \
    \     if [[ $n -eq 0 ]]; then\n                group=\"$group)\"\n           \
    \     parens_strs+=($group)\n                group=\"\"\n            else\n  \
    \              group=\"$group)\"\n            fi\n        fi\n    done\n\n   \
    \ # Iterate through each group and count the level of nesting.\n    local parens_depths=()\n\
    \    for group in \"${parens_strs[@]}\"; do\n        local max=0\n        local\
    \ d=0\n        for ((i=0; i<${#group}; i++)); do\n            if [[ ${group:$i:1}\
    \ == \"(\" ]]; then\n                d=$((d+1))\n                if [[ $d -gt\
    \ $max ]]; then\n                    max=$d\n                fi\n            elif\
    \ [[ ${group:$i:1} == \")\" ]]; then\n                d=$((d-1))\n           \
    \ fi\n        done\n        parens_depths+=($max)\n    done\n\n    echo ${parens_depths[@]}\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n  local input=$1\n  local result=()\n  # INSERT CODE HERE\n\n  # -------------\n\
    \n  echo ${result[@]}\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") =\
    \ \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\"\
    \ ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n  echo \"Input string: $1\"\n  local result=()\n  while [[ \"$1\" != \"\"\
    \ ]]; do\n    local count=0\n    local char=\"\"\n    for (( i=0; i<${#1}; i++\
    \ )); do\n      char=\"${1:$i:1}\"\n      #echo \"char: $char\"\n      if [[ \"\
    $char\" == \"(\" ]]; then\n        ((count++))\n      elif [[ \"$char\" == \"\
    )\" ]]; then\n        ((count--))\n      fi\n    done\n    if [[ \"$count\" !=\
    \ 0 ]]; then\n      echo \"Input string is invalid\"\n      exit 1\n    fi\n \
    \   result+=(\"$count\")\n    shift\n  done\n  echo \"Result: ${result[@]}\"\n\
    }\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[\
    \ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n    res=()\n    for g in $1; do\n        depth=0\n        depth_max=0\n \
    \       for c in $(echo \"$g\" | sed 's/./& /g'); do\n            if [ \"$c\"\
    \ == \"(\" ]; then\n                ((depth++))\n                if [ \"$depth\"\
    \ -gt \"$depth_max\" ]; then\n                    depth_max=$depth\n         \
    \       fi\n            else\n                ((depth--))\n            fi\n  \
    \      done\n        res=(\"${res[@]}\" \"$depth_max\")\n    done\n    echo \"\
    ${res[@]}\"\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\"\
    \ ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[\
    \ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n  echo $1 | awk '{\n    for (i=1; i<=NF; i++) {\n      printf \" %d\", (length($i)\
    \ - length(gensub(/\\(|\\)/, \"\", \"g\", $i)) + 1)/2\n    }\n    printf \"\\\
    n\"\n  }'\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n  \
    \  [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate\
    \ \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 2
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n    # YOUR CODE HERE\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpl6fw394s.sh: line 11: syntax error near unexpected token `}''

    /tmp/tmpl6fw394s.sh: line 11: `}''

    '
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n  # Write your code here\n  count=0\n  result=()\n  input=$1\n  while [[\
    \ $input ]]; do\n    i=${input:0:1}\n    input=${input:1}\n    if [[ $i == \"\
    (\" ]]; then\n      count=$((count+1))\n    elif [[ $i == \")\" ]]; then\n   \
    \   count=$((count-1))\n    fi\n    if [[ $i == \" \" ]]; then\n      result+=($count)\n\
    \      count=0\n    fi\n  done\n  echo ${result[@]}\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n  IFS=' ' read -r -a array <<< \"$1\"\n  for elem in \"${array[@]}\"; do\n\
    \    echo $elem | awk '\n    BEGIN {max=0}\n    {\n      for (i=1; i<=NF; i++)\
    \ {\n        if (match($i, /\\(/)) {\n          depth++\n        }\n        if\
    \ (match($i, /\\)/)) {\n          depth--\n        }\n        if (depth > max)\
    \ {\n          max = depth\n        }\n      }\n    }\n    END {\n      print\
    \ max\n    }'\n  done\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") =\
    \ \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\"\
    \ ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n  # nested_depth keeps track of the deepest nesting of parentheses.\n  local\
    \ nested_depth=0\n\n  # num_left_paren is the count of left parentheses.\n  local\
    \ num_left_paren=0\n\n  # num_right_paren is the count of right parentheses.\n\
    \  local num_right_paren=0\n\n  # max_nesting is the maximum depth of nested parentheses\
    \ of each string.\n  local max_nesting=()\n\n  # For each character of each string,\n\
    \  for (( i=0; i<${#1}; i++ )); do\n    if [[ ${1:$i:1} == \"(\" ]]; then\n  \
    \    # increment the count of left parentheses,\n      ((num_left_paren++))\n\n\
    \      # if the left parentheses is 1 more than the right,\n      if ((num_left_paren\
    \ > num_right_paren)); then\n        # increment the nested depth.\n        ((nested_depth++))\n\
    \      fi\n    elif [[ ${1:$i:1} == \")\" ]]; then\n      # increment the count\
    \ of right parentheses,\n      ((num_right_paren++))\n\n      # if the left parentheses\
    \ is equal to the right,\n      if ((num_left_paren == num_right_paren)); then\n\
    \        # append the current depth of nested parentheses to the max_nesting array,\n\
    \        max_nesting+=($nested_depth)\n\n        # reset the nested depth to 0.\n\
    \        nested_depth=0\n      fi\n    fi\n  done\n\n  # Print the max_nesting\
    \ array.\n  echo ${max_nesting[@]}\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n    declare -a res=()\n    local arr\n    arr=$(echo $1 | tr \" \" \"\\n\"\
    )\n\n    for i in ${arr[@]}; do\n        local counter=0\n        local max=0\n\
    \        for (( j=0; j<${#i}; j++ )); do\n            case ${i:$j:1} in\n    \
    \            \"(\")\n                    ((counter++))\n                    ((max=counter))\n\
    \                    ;;\n                \")\")\n                    ((counter--))\n\
    \                    ;;\n            esac\n        done\n        res+=($max)\n\
    \    done\n    echo ${res[@]}\n}\n\ncandidate() {\n    parse_nested_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n    local seq=$1\n    local maxlevel=0 # global maximum\n    local parens=0\
    \   # track the current level\n    local result=()  # save the results\n\n   \
    \ # Loop over each char in the string\n    for (( i=0; i<${#seq}; i++ )); do\n\
    \        char=${seq:$i:1}\n\n        # Increment if we see an open parens\n  \
    \      if [[ $char == \"(\" ]]; then\n            (( parens++ ))\n           \
    \ (( maxlevel < parens )) && maxlevel=$parens\n        # Reset if we see a close\
    \ parens\n        elif [[ $char == \")\" ]]; then\n            parens=0\n    \
    \    # Otherwise, we must have hit a space, so record our result\n        else\n\
    \            result+=($maxlevel)\n            maxlevel=0\n        fi\n    done\n\
    \n    # Output our result. We don't want to quote the array in the echo\n    #\
    \ because then the output will be a space-separated string of numbers\n    # instead\
    \ of a proper array.\n    echo ${result[@]}\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n  echo \"$1\" |\n  {\n    while read -r line; do\n      # Go thru each character\
    \ in line\n      while read -n 1 char; do\n        # Push the characters on the\
    \ stack as they are in the order as they are seen\n        echo \"$char\" >> stack\n\
    \n        # If the character is \")\", pop a character from the stack\n      \
    \  # Continue popping from the stack and compare the popped character with \"\
    (\"\n        # Increment the depth of nesting for every \"(\" found\n        #\
    \ If stack gets empty or if the popped character is not \"(\" then break from\
    \ the loop\n        if [ \"$char\" == \")\" ]; then\n          stack_length=$(wc\
    \ -l < stack)\n          while true; do\n            if [ \"$stack_length\" ==\
    \ 0 ]; then\n              break\n            fi\n            popped_char=$(sed\
    \ -n \"$stack_length p\" stack)\n            if [ \"$popped_char\" == \"(\" ];\
    \ then\n              ((++nesting_level))\n            else\n              break\n\
    \            fi\n            ((--stack_length))\n          done\n        fi\n\
    \      done\n      echo \"$nesting_level\"\n      unset nesting_level\n      rm\
    \ stack\n    done\n  }\n}\n\ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\") =\
    \ \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3 4\"\
    \ ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'rm: cannot remove ''stack'': No such file or directory

    '
  stdout: ''
  timestamp: 1660020311
- exit_code: 0
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n    local maxdepth=0;\n    local tdepth=0;\n    #current input\n    local\
    \ curinput=$1;\n    #tokenized input\n    local curinput_tokens=$(echo $curinput\
    \ | sed 's/\\([()]\\)/ \\1 /g');\n    #result output\n    local maxdepths=\"\"\
    ;\n    #for each token\n    for token in $curinput_tokens; do\n        #if token\
    \ is '('\n        if [ \"$token\" == \"(\" ]; then\n            #increase depth\n\
    \            tdepth=$((tdepth+1));\n            #if current depth is deeper than\
    \ max depth\n            if [ $tdepth -gt $maxdepth ]; then\n                #set\
    \ max depth to current depth\n                maxdepth=$tdepth;\n            fi\n\
    \        #if token is ')'\n        elif [ \"$token\" == \")\" ]; then\n      \
    \      #decrease depth\n            tdepth=$((tdepth-1));\n            #if depth\
    \ is zero\n            if [ $tdepth -eq 0 ]; then\n                #add current\
    \ max depth to output\n                maxdepths=\"$maxdepths $maxdepth\";\n \
    \               #reset max depth\n                maxdepth=0;\n            fi\n\
    \        fi\n    done\n    #echo output\n    echo $maxdepths;\n}\n\ncandidate()\
    \ {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n  if [ $# -eq 0 ]; then\n    echo \"Error! No args given.\"\n    exit\n \
    \ fi\n  regex='(?<!\\\\)(?>\\((?<D>)|\\)(?<-D>)|.)*?(?(D)(?!))'\n  for string\
    \ in $@; do\n    printf \"$string: \"\n    # Match all non-escaped open and close\
    \ parens, checking\n    # the length of the longest match.\n    max_match=0\n\
    \    while read match; do\n      len=${#match}\n      if [ $len -gt $max_match\
    \ ]; then\n        max_match=$len\n      fi\n    done <<< \"$(echo \"$string\"\
    \ | grep -oP $regex)\"\n    echo $max_match\n  done\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: 'grep: unrecognized character after (?<

    grep: unrecognized character after (?<

    grep: unrecognized character after (?<

    grep: unrecognized character after (?<

    '
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n    # Write your code here\n    #BFS to traverse the tree\n    local var=$1\n\
    \    #echo $var\n    local strs=()\n    local count=0\n    local top=0\n    local\
    \ bottom=0\n    local result=()\n    local level=0\n    local len=${#var}\n  \
    \  local i=0\n    local j=0\n    #local t=0\n    local temp=''\n    for (( i=0;\
    \ i<${len}; i++ ))\n    do\n    \tif [[ ${var:$i:1} == '(' ]]\n    \tthen\n  \
    \  \t\tstrs[$((count++))]=${var:$i:1}\n    \t\t#echo $count\n    \t\ttop=$((top+1))\n\
    \    \telif [[ ${var:$i:1} == ')' ]]\n    \tthen\n    \t\ttemp=\"${strs[$((top-1))]}${var:$i:1}\"\
    \n    \t\ttop=$((top-1))\n    \t\tstrs[$((bottom++))]=$temp\n    \tfi\n    done\n\
    \    #echo ${strs[@]}\n    #echo ${#strs[@]}\n    local size=${#strs[@]}\n   \
    \ local c=0\n    local s=0\n    local templen=0\n    for (( i=0; i<${size}; i++\
    \ ))\n    do\n    \ttemp=${strs[$i]}\n    \ttemplen=${#temp}\n    \tfor (( j=0;\
    \ j<${templen}; j++ ))\n    \tdo\n    \t\tif [[ ${temp:$j:1} == '(' ]]\n    \t\
    \tthen\n    \t\t\tc=$((c+1))\n    \t\telif [[ ${temp:$j:1} == ')' ]]\n    \t\t\
    then\n    \t\t\tc=$((c-1))\n    \t\tfi\n    \tdone\n    \tresult[$i]=$c\n    \t\
    c=0\n    done\n    echo ${result[@]}\n}\n\ncandidate() {\n    parse_nested_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"(()()) ((())) () ((())()())\"\
    ) = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (()) ((())) (((())))\") = \"1 2 3\
    \ 4\" ]]\n    [[ $(candidate \"(()(())((())))\") = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n  #write your solution here\n    result=()\n    while read -r line; do\n\
    \      max=0\n      tmp=0\n      for (( i=0; i<${#line}; i++ )); do\n        if\
    \ [[ ${line:$i:1} == \"(\" ]]; then\n          ((tmp++))\n          ((tmp>max\
    \ && (max=$tmp)))\n        else\n          ((tmp--))\n        fi\n      done\n\
    \      result+=(\"$max\")\n    done <<< \"$1\"\n    echo \"${result[@]}\"\n}\n\
    \ncandidate() {\n    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n \
    \   [[ $(candidate \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate\
    \ \"() (()) ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\"\
    ) = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020311
- exit_code: 1
  program: "#!/bin/bash\n# Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n# For each of the group,\
    \ output the deepest level of nesting of parentheses.\n# E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.\n# >>> parse_nested_parens('(()())\
    \ ((())) () ((())()())')\n# [2, 3, 1, 3]\n#\n# $1 is a string\nparse_nested_parens()\
    \ {\n    # Fill in this function!\n    declare -a paren=($1)\n    #echo \"${paren[@]}\"\
    \n    local i\n    declare -a depth\n    for ((i=0; i<${#paren[@]}; i++)); do\n\
    \        #echo \"${paren[$i]}\"\n        local cur=0\n        declare -a stack\n\
    \        local j\n        for ((j=0; j<${#paren[$i]}; j++)); do\n            if\
    \ [[ ${paren[$i]:$j:1} == \"(\" ]]; then\n                stack+=(1)\n       \
    \         let cur++\n            elif [[ ${paren[$i]:$j:1} == \")\" ]]; then\n\
    \                if [[ $cur -gt 0 ]]; then\n                    stack+=(-1)\n\
    \                    let cur--\n                else\n                    depth+=(0)\n\
    \                    break\n                fi\n            fi\n        done\n\
    \        depth+=($cur)\n    done\n    echo \"${depth[@]}\"\n}\n\ncandidate() {\n\
    \    parse_nested_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"(()()) ((())) () ((())()())\") = \"2 3 1 3\" ]]\n    [[ $(candidate \"() (())\
    \ ((())) (((())))\") = \"1 2 3 4\" ]]\n    [[ $(candidate \"(()(())((())))\")\
    \ = \"4\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660020311
