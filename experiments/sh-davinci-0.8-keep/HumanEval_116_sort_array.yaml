name: HumanEval_116_sort_array
language: sh
prompt: "#!/bin/bash\n# In this Kata, you have to sort an array of non-negative integers\
  \ according to\n# number of ones in their binary representation in ascending order.\n\
  # For similar number of ones, sort based on decimal value.\n# It must be implemented\
  \ like this:\n# >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n# >>> sort_array([-2,\
  \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n# >>> sort_array([1, 0, 2, 3, 4]) [0,\
  \ 1, 2, 3, 4]\n#\n# $1 is a space-separated list\nsort_array() {\n"
tests: "}\n\ncandidate() {\n    sort_array \"$@\"\n}\n\nset -e\nrun_test() {\n   \
  \ [[ $(candidate \"1 5 2 3 4\") = \"1 2 4 3 5\" ]]\n    [[ $(candidate \"-2 -3 -4\
  \ -5 -6\") = \"-4 -2 -6 -5 -3\" ]]\n    [[ $(candidate \"1 0 2 3 4\") = \"0 1 2\
  \ 4 3\" ]]\n    [[ $(candidate \"\") = \"\" ]]\n    [[ $(candidate \"2 5 77 4 5\
  \ 3 5 7 2 3 4\") = \"2 2 4 4 3 3 5 5 5 7 77\" ]]\n    [[ $(candidate \"3 6 44 12\
  \ 32 5\") = \"32 3 5 6 12 44\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8\
  \ 16 32\" ]]\n    [[ $(candidate \"2 4 8 16 32\") = \"2 4 8 16 32\" ]]\n}\n\nrun_test"
completions: ["  for i in $(echo $1 | tr ' ' '\\n' | sort -n)\n  do\n    str=`echo\
    \ \"obase=2;$i\" | bc`\n    echo $str | grep -o 1 | wc -l >> $2\n  done\n  array=(`echo\
    \ $1 | tr ' ' '\\n'`)\n  array+=(`cat $2 | tr '\\n' ' '`)\n  echo ${array[@]}\
    \ | tr ' ' '\\n' | sort -k 2 -n -k 3 -n | sed 's/\\s.*//'", "  length=${#1}\n\
    \  if [ $length == 0 ]; then\n    echo \"\"\n    return 0\n  fi\n  list=$(echo\
    \ $1 | tr \" \" \"\\n\")\n  ordered_list=$(echo \"$list\" | sort -n)\n  result=$(echo\
    \ \"$ordered_list\" | sort -k1,1 -k2,2r)\n  echo \"$result\" | tr \"\\n\" \" \"",
  '  echo "Please write me!"', "  echo \"$1\" | tr ' ' '\\n' | sed -e 's/^0*//' |\
    \ sort -n -k1 -t'1' -k2 -t'0' -b", "  printf '%s\\n' $1 | awk '{printf \"%08d\
    \ %08d\\n\", $1, $1}' | awk '{printf \"%08d %04d %08d\\n\", $1, gsub(\"1\", \"\
    \"), $2}' | sort -n | awk '{printf \"%d \", $3}'", "    local array=()\n    local\
    \ tmp_array=()\n    local array_bin=()\n    local nb_bin=()\n    local i=0\n \
    \   local j=0\n    local k=0\n    local tmp=\"\"\n    local nb=\"\"\n    local\
    \ nb_len=0\n    local input_array=($1)\n    local len=${#input_array[@]}\n   \
    \ for ((i=0; i<len; i++)); do\n        nb=${input_array[$i]}\n        if [ $nb\
    \ -lt 0 ]; then\n            ((nb = nb * -1))\n        fi\n        tmp=$(dec_to_bin\
    \ $nb)\n        array_bin[$i]=$tmp\n        nb_bin[$i]=$(get_nb_bin $tmp)\n  \
    \  done\n    for ((i=0; i<len; i++)); do\n        nb_len=${#array_bin[$i]}\n \
    \       if [ $nb_len -lt 8 ]; then\n            array_bin[$i]=$(pad_bin ${array_bin[$i]})\n\
    \        fi\n    done\n    for ((i=0; i<len; i++)); do\n        tmp_array[$i]=${input_array[$i]}\n\
    \    done\n    for ((i=0; i<len; i++)); do\n        j=$i\n        for ((k=i+1;\
    \ k<len; k++)); do\n            if [[ ${nb_bin[$k]} -lt ${nb_bin[$j]} ]]; then\n\
    \                j=$k\n            elif [[ ${nb_bin[$k]} -eq ${nb_bin[$j]} ]];\
    \ then\n                if [[ ${tmp_array[$k]} -lt ${tmp_array[$j]} ]]; then\n\
    \                    j=$k\n                fi\n            fi\n        done\n\
    \        if [[ $j -ne $i ]]; then\n            tmp=${tmp_array[$i]}\n        \
    \    tmp_array[$i]=${tmp_array[$j]}\n            tmp_array[$j]=$tmp\n        \
    \    tmp=${array_bin[$i]}\n            array_bin[$i]=${", "  # Space separated\
    \ list of input\n  local INPUT=$1\n  # Space-separated list of number converted\
    \ to their binary representation\n  local BINARY_LIST\n  # Space-separated list\
    \ of number sorted by number of ones in their binary\n  # representation\n  local\
    \ ORDERED_LIST\n  local COUNT_ONE\n  local RETURN\n  local NUMBER\n  # Array of\
    \ ordered binary list\n  local ORDERED_BINARY_LIST\n  local BINARY_STRING\n  #\
    \ Variables to handle input\n  local ARRAY_INPUT=($INPUT)\n  local I=0\n  local\
    \ J\n  local TEMP\n  local SIZE\n  for NUMBER in ${ARRAY_INPUT[@]}; do\n    BINARY_STRING=$(echo\
    \ \"obase=2;$NUMBER\" | bc)\n    COUNT_ONE=$(echo \"$BINARY_STRING\" | tr -cd\
    \ '1' | wc -c)\n    ORDERED_BINARY_LIST[$I]=\"$COUNT_ONE $NUMBER $BINARY_STRING\"\
    \n    ((I++))\n  done\n  # Sorting by the number of ones\n  SIZE=${#ORDERED_BINARY_LIST[@]}\n\
    \  for ((I=0; I<$SIZE; I++)); do\n    for ((J=I+1; J<$SIZE; J++)); do\n      #\
    \ Split binary list by space\n      ARRAY_I=(${ORDERED_BINARY_LIST[$I]})\n   \
    \   ARRAY_J=(${ORDERED_BINARY_LIST[$J]})\n      if [ ${ARRAY_I[0]} -gt ${ARRAY_J[0]}\
    \ ]; then\n        TEMP=${ORDERED_BINARY_LIST[$I]}\n        ORDERED_BINARY_LIST[$I]=${ORDERED_BINARY_LIST[$J]}\n\
    \        ORDERED_BINARY_LIST[$J]=$TEMP\n      fi\n    done\n  done\n  # Sorting\
    \ by decimal value if the number of ones is the same\n  SIZE=${#ORDERED_BINARY_LIST[@",
  "  local -a arr\n  IFS=' ' read -r -a arr <<< \"$1\"\n  local -i -a counts\n  local\
    \ -i max\n  local -i i j\n\n  max=0\n  for i in \"${arr[@]}\"; do\n    if [[ \"\
    $i\" -ge \"$max\" ]]; then\n      max=\"$i\"\n    fi\n  done\n\n  j=0\n  while\
    \ [[ \"$j\" -le \"$max\" ]]; do\n    if [[ $(( j & 1 )) -eq 1 ]]; then\n     \
    \ counts[$j]=1\n    else\n      counts[$j]=0\n    fi\n    (( ++j ))\n  done\n\n\
    \  j=0\n  while [[ \"$j\" -le \"$max\" ]]; do\n    i=1\n    while [[ \"$i\" -le\
    \ \"$j\" ]]; do\n      if [[ $(( j & i )) -eq \"$i\" ]]; then\n        (( ++counts[j]\
    \ ))\n      fi\n      (( ++i ))\n    done\n    (( ++j ))\n  done\n\n  for i in\
    \ \"${!arr[@]}\"; do\n    arr[$i]=\"${counts[${arr[$i]}]} ${arr[$i]}\"\n  done\n\
    \n  echo \"${arr[*]}\" | tr ' ' '\\n' | sort -nk1 | sed -e 's/^[0-9]* //'", " \
    \ local num=\"\"\n  local zero=\"\"\n  local tmp=\"\"\n  local array_of_binary=\"\
    \"\n  local sorted_array=\"\"\n  local zero_bit=\"\"\n  local one_bit=\"\"\n \
    \ local zero_decimal=\"\"\n  local one_decimal=\"\"\n  local zero_length=\"\"\n\
    \  local one_length=\"\"\n  local i=\"\"\n  for num in $1; do\n    tmp=$num\n\
    \    zero=\"\"\n    zero_decimal=\"\"\n    for i in $(seq 1 32); do\n      if\
    \ [ $tmp -eq 0 ]; then\n        zero_decimal=$tmp\n        break\n      fi\n \
    \     zero_decimal=$(($tmp % 2))\n      tmp=$(($tmp / 2))\n      zero=$zero_decimal$zero\n\
    \    done\n    zero_length=${#zero}\n    if [ $zero_length -lt 32 ]; then\n  \
    \    zero=$(printf \"%0.s0\" $(seq $((32 - $zero_length))))$zero\n    fi\n   \
    \ array_of_binary=\"$array_of_binary$zero \"\n  done\n  for i in $(seq 1 32);\
    \ do\n    sorted_array=\"\"\n    zero_bit=1\n    one_bit=1\n    one_decimal=0\n\
    \    for num in $array_of_binary; do\n      zero=$num\n      zero_decimal=${zero:(-1)}\n\
    \      if [ $zero_decimal -eq $zero_bit ]; then\n        one_decimal=$(($one_decimal\
    \ + 1))\n        one_length=${#one_decimal}\n        if [ $one_length -eq 1 ];\
    \ then\n          one_decimal=0$one_decimal\n        fi\n        zero=${zero:0:(-1)}\n\
    \        zero=$zero$one_decimal\n        one_decimal=0\n      else\n        one_decimal=0\n\
    \      fi\n      sorted_array=\"$sorted_array$zero \"\n    done\n    array_of_binary=$sorted_array\n\
    \  done\n  sorted_array=\"\"\n  for num in $array_of_binary; do\n    one_decimal=0\n\
    \    zero=$num\n    zero_decimal=${zero:(-", "  local array=()\n  for number in\
    \ $1; do\n    bits=$(echo \"obase=2; $number\" | bc)\n    array+=(\"$number $bits\"\
    )\n  done\n  array=($(for element in \"${array[@]}\"; do echo \"$element\"; done\
    \ | sort -k 2 -n -k 1 -n))\n  array=($(for element in \"${array[@]}\"; do echo\
    \ \"$element\"; done | cut -d' ' -f1))\n  echo \"${array[@]}\"", "    # Assume\
    \ that most arguments have n < 8 ones, so 2^n will be small\n    bin_array=( $(echo\
    \ \"$1\" |\n        sed -e 's/\\([0-9]\\)/\\1\\n/g' |\n        sort -n |\n   \
    \     tr '\\n' ' ') )\n    # 2>/dev/null suppresses useless info from bc\n   \
    \ # echo \"$(echo \"obase=2; $1\" | bc)\"\n    bin_array=( $(echo \"${bin_array[@]}\"\
    \ |\n        sed -e 's/\\([0-9]\\)/\\1\\n/g' |\n        sort -n |\n        tr\
    \ '\\n' ' ') )\n    echo \"${bin_array[@]}\"", "  declare -a array=()\n  local\
    \ i\n  local j\n  for i in $1; do\n    array+=($i)\n  done\n  local len=${#array[@]}\n\
    \  local k\n  local tmp\n  local m\n  for (( i=0; i<len; i++ ))\n  do\n    for\
    \ (( j=0; j<len-i-1; j++ ))\n    do\n      k=${array[$j]}\n      m=${array[$j+1]}\n\
    \      if [[ $(count_ones \"$k\") -gt $(count_ones \"$m\") ]]; then\n        tmp=${array[$j]}\n\
    \        array[$j]=${array[$j+1]}\n        array[$j+1]=$tmp\n      elif [[ $(count_ones\
    \ \"$k\") -eq $(count_ones \"$m\") ]]; then\n        if [[ $k -gt $m ]]; then\n\
    \          tmp=${array[$j]}\n          array[$j]=${array[$j+1]}\n          array[$j+1]=$tmp\n\
    \        fi\n      fi\n    done\n  done\n  printf \"%s \" \"${array[@]}\"", " \
    \ #\n  # Write your code here\n  #", "  echo $1 | tr ' ' '\\n' | sort -n | tr\
    \ '\\n' ' '", "    echo \"$1\" | sort -n -t ' ' -k 1.0,1.0 -k 2,2g", "    local\
    \ arr\n    arr=(\"$@\")\n    local num\n    local len=${#arr[@]}\n    local bin\n\
    \    local res\n    local tmp\n\n    for((i=0; i<len; i++)); do\n        num=${arr[$i]}\n\
    \        bin=$(echo \"obase=2; $num\" | bc)\n        arr[$i]=\"$(printf \"%06d\"\
    \ \"$bin\") $num\"\n    done\n\n    IFS=$'\\n' sorted=($(sort <<<\"${arr[*]}\"\
    ))\n    unset IFS\n\n    for((i=0; i<len; i++)); do\n        tmp=(${sorted[$i]})\n\
    \        res[$i]=${tmp[1]}\n    done\n\n    printf \"%s \" \"${res[@]}\"", " \
    \ echo \"$1\" | \\\n    tr ' ' '\\n' | \\\n    sort -n | \\\n    awk '{\n    \
    \  count[NR] = $1\n      bitcount[NR] = sprintf(\"%064d\", $1)\n      bitcount[NR]\
    \ = gensub(/0/, \"\", \"g\", bitcount[NR])\n    }\n    END {\n      for (i = 1;\
    \ i <= NR; i++) {\n        for (j = 1; j <= NR; j++) {\n          if (length(bitcount[j])\
    \ == i) {\n            printf \"%d \", count[j]\n          }\n        }\n    \
    \  }\n    }'", "  local array=`echo $1 | tr ' ' '\\n' | sort -n`\n  echo $array",
  '    printf "%s\n" "$1" | sort -n -k1,1 -k2,2 -t.', "    local -a a=( $1 )\n   \
    \ local len=$((${#a[@]} - 1))\n    for ((i=0; i<$len; i++)); do\n        local\
    \ min=$i\n        for ((j=i+1; j<=len; j++)); do\n            local tmp=${a[min]}\n\
    \            local tmp2=${a[j]}\n            if [[ $tmp =~ ^-?[0-9]+$ ]] && [[\
    \ $tmp2 =~ ^-?[0-9]+$ ]]; then\n                local count1=$(echo \"obase=2;${tmp#-}\"\
    \ | bc | grep -o 1 | wc -l)\n                local count2=$(echo \"obase=2;${tmp2#-}\"\
    \ | bc | grep -o 1 | wc -l)\n                if [[ $count1 -lt $count2 ]]; then\n\
    \                    min=$j\n                elif [[ $count1 -eq $count2 ]]; then\n\
    \                    if [[ $tmp -gt $tmp2 ]]; then\n                        min=$j\n\
    \                    fi\n                fi\n            else\n              \
    \  return 1\n            fi\n        done\n        local tmp=${a[i]}\n       \
    \ a[i]=${a[min]}\n        a[min]=$tmp\n    done\n    echo \"${a[@]}\""]
stop_tokens:
- "\n}"
