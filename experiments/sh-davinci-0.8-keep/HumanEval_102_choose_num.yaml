name: HumanEval_102_choose_num
language: sh
prompt: "#!/bin/bash\n# This function takes two positive numbers x and y and returns\
  \ the\n# biggest even integer number that is in the range [x, y] inclusive. If \n\
  # there's no such number, then the function should return -1.\n# For example:\n\
  # choose_num(12, 15) = 14\n# choose_num(13, 12) = -1\n#\n# $1 is an integer\n# $2\
  \ is an integer\nchoose_num() {\n"
tests: "}\n\ncandidate() {\n    choose_num \"$@\"\n}\n\nset -e\nrun_test() {\n   \
  \ [[ $(candidate \"12\" \"15\") = \"14\" ]]\n    [[ $(candidate \"13\" \"12\") =\
  \ \"-1\" ]]\n    [[ $(candidate \"33\" \"12354\") = \"12354\" ]]\n    [[ $(candidate\
  \ \"5234\" \"5233\") = \"-1\" ]]\n    [[ $(candidate \"6\" \"29\") = \"28\" ]]\n\
  \    [[ $(candidate \"27\" \"10\") = \"-1\" ]]\n    [[ $(candidate \"7\" \"7\")\
  \ = \"-1\" ]]\n    [[ $(candidate \"546\" \"546\") = \"546\" ]]\n}\n\nrun_test"
completions: ["  if [ $1 -gt $2 ]; then\n    echo \"Error: \\$1 cannot be greater\
    \ than \\$2.\"\n    return 1\n  fi\n  echo \"$1\"\n  while [ $1 -lt $2 ]; do\n\
    \    let \"1++\"\n    if [ $(($1 % 2)) -eq 0 ]; then\n      echo \"$1\"\n    fi\n\
    \  done", '  echo ""', "\tif [[ -z \"$1\" || -z \"$2\" ]]; then\n\t\techo \"Usage:\
    \ choose_num {firstNum} {secondNum}\"\n\t\treturn 1\n\tfi\n\tlocal first=${1}\n\
    \tlocal second=${2}\n\t# change if needed\n\techo \"firstNum: $first, secondNum:\
    \ $second\"\n\t# Add code here\n\t\n\t\n\t\n\t\n\treturn", "    num=$1\n    if\
    \ [ $(($1%2)) -eq 0 ]; then\n        while [ $num -le $2 ]; do\n            num=$(($num+2))\n\
    \        done\n        echo $(($num-2))\n    else\n        while [ $num -le $2\
    \ ]; do\n            num=$(($num+2))\n        done\n        echo $(($num-4))\n\
    \    fi", "    num=$1\n    while [ $num -le $2 ]; do\n        if [ $((num % 2))\
    \ == 0 ]; then\n            echo $num\n            break\n        fi\n       \
    \ num=$((num + 1))\n    done\n    if [ $num -gt $2 ]; then\n        echo -1\n\
    \    fi", "  x=$1\n  y=$2\n  for i in $(seq $x $y); do\n    if (( $i % 2 == 0\
    \ )); then\n      echo $i\n      break\n    fi\n  done", "  if [[ $1 -gt $2 ]];\
    \ then\n    echo -1\n  else\n    for num in `seq $1 $2`; do\n      if [[ $((num\
    \ % 2)) == 0 ]]; then\n        echo $num\n        return\n      fi\n    done\n\
    \    echo -1\n  fi", "  # fill in the commands here to compute the number\n  #\
    \ if no number can be chosen, set num to -1\n  num=\n  # fill in the code here\
    \ to end the loop\n  for ((i=$1; i <= $2; i++))\n  do\n    if (( ($i % 2) == 0\
    \ ))\n    then\n      if (( $i > $num ))\n      then\n        num=$i\n      fi\n\
    \    fi\n  done\n  echo \"$num\"", "    # The output should be an integer.\n \
    \   #\n    # The parameters $1 and $2 are guaranteed to be positive integer \n\
    \    # numbers.\n    #\n    # The range [x, y] is inclusive, i.e. x, y are both\
    \ included.\n    #\n    # If there's no such number, then the function should\
    \ return -1.\n    #\n    # Write your code here.\n    if (( (($1&1)) | (($2&1))\
    \ )); then\n        echo -1\n    else\n        for i in $(seq $1 2 $2); do\n \
    \           if [[ $((i%2)) -eq 0 ]]; then\n                echo $i\n         \
    \       return\n            fi\n        done\n    fi", "    for i in $(seq $1\
    \ $2); do\n        if [[ $((i % 2)) -eq 0 ]]; then\n            return $i\n  \
    \      fi\n    done\n    return -1", "  if [ $1 -gt $2 ]; then\n    echo \"-1\"\
    \n  else\n    even=$(($2%2))\n    if [ $even -eq 0 ]; then\n      echo \"$2\"\n\
    \    else\n      ((num = $2 - 1))\n      echo \"$num\"\n    fi\n  fi", "\tnum1=$1\n\
    \tnum2=$2\n\tbiggest=-1\n\tfor ((i=num1; i<=num2; i++))\n\tdo\n\t\tif [ $((i%2))\
    \ -eq 0 ] && [ $i -gt $biggest ]\n\t\tthen\n\t\t\tbiggest=$i\n\t\tfi\n\tdone\n\
    \techo $biggest", "  for n in $(seq $1 $2); do\n    if [ $(($n % 2)) -eq 0 ];\
    \ then\n      echo $n\n      return\n    fi\n  done\n  echo -1", "    if [ $1\
    \ -gt $2 ]; then\n        declare -i x=$2\n        declare -i y=$1\n    else\n\
    \        declare -i x=$1\n        declare -i y=$2\n    fi\n    declare -i count=$x\n\
    \    while [ $count -le $y ]; do\n        if [ $((count % 2)) -eq 0 ]; then\n\
    \            echo $count\n            break\n        fi\n        count=$((count\
    \ + 1))\n    done\n    if [ $count -gt $y ]; then\n        echo -1\n    fi", " \
    \ if [[ $1 -le $2 ]]; then\n    num=$1\n    while [[ $num -le $2 ]]; do\n    \
    \  if [[ $((num % 2)) -eq 0 ]]; then\n        echo $num\n        break\n     \
    \ fi\n      ((num++))\n    done\n  fi\n  if [[ $num -gt $2 ]]; then\n    echo\
    \ -1\n  fi", "    if [[ $1 -gt $2 ]]; then\n        return -1\n    fi\n    for\
    \ i in `seq $1 $2`; do\n        if [[ $((i % 2)) -eq 0 ]]; then\n            return\
    \ $i\n        fi\n    done\n    return -1", "  int num = -1\n  for(i = $1; i <=\
    \ $2; i++){\n    if(i % 2 == 0){\n      num = i\n    }\n  }\n  return num", " \
    \ if [[ $1 -lt $2 ]]; then\n    lower=$1\n    upper=$2\n  else\n    lower=$2\n\
    \    upper=$1\n  fi\n  while [[ $lower -le $upper ]]; do\n    if [[ $lower -eq\
    \ $upper ]]; then\n      if [[ $lower%2 -eq 0 ]]; then\n        return $lower\n\
    \      else\n        return -1\n      fi\n    elif [[ $lower%2 -eq 0 ]]; then\n\
    \      return $lower\n    fi\n    (( lower+=1 ))\n  done", "  for i in $(seq $1\
    \ $2); do\n    if (( $i % 2 == 0 )); then\n      echo $i\n      return\n    fi\n\
    \  done\n  echo -1", "\tlocal res=-1\n\tfor (( i=$1; i<=$2; i++ )); do\n\t\tif\
    \ ((i%2==0)); then\n\t\t\tres=$i\n\t\tfi\n\tdone\n\techo $res"]
stop_tokens:
- "\n}"
