name: HumanEval_104_unique_digits
language: sh
prompt: "#!/bin/bash\n# Given a list of positive integers x. return a sorted list\
  \ of all \n# elements that hasn't any even digit.\n# Note: Returned list should\
  \ be sorted in increasing order.\n# For example:\n# >>> unique_digits([15, 33, 1422,\
  \ 1])\n# [1, 15, 33]\n# >>> unique_digits([152, 323, 1422, 10])\n# []\n#\n# $1 is\
  \ a space-separated list\nunique_digits() {\n"
tests: "}\n\ncandidate() {\n    unique_digits \"$@\"\n}\n\nset -e\nrun_test() {\n\
  \    [[ $(candidate \"15 33 1422 1\") = \"1 15 33\" ]]\n    [[ $(candidate \"152\
  \ 323 1422 10\") = \"\" ]]\n    [[ $(candidate \"12345 2033 111 151\") = \"111 151\"\
  \ ]]\n    [[ $(candidate \"135 103 31\") = \"31 135\" ]]\n}\n\nrun_test"
completions: ["  for element in $1; do\n    if [[ $element =~ ^[^02468]+$ ]]; then\n\
    \      echo $element\n    fi\n  done | sort -n", "    # 1. Convert to array\n\
    \    local __ar=\"$1\"\n    local __a\n    __a=( $__ar )\n    # 2. Remove the\
    \ 0s, then remove all even digits\n    local __even\n    local __num\n    local\
    \ __result\n    __result=()\n    for __num in \"${__a[@]}\"; do\n        __even=$(is_even\
    \ \"$__num\")\n        if [ \"$__even\" -eq 0 ]; then\n            __result+=(\
    \ \"$__num\" )\n        fi\n    done\n    echo \"${__result[@]}\"", "\tlocal result=()\n\
    \tfor x in $1; do\n\t\tlocal even=0\n\t\twhile [ $x -gt 0 ]; do\n\t\t\tif [ $((x\
    \ % 2)) -eq 0 ]; then\n\t\t\t\teven=1\n\t\t\t\tbreak\n\t\t\tfi\n\t\t\tx=$((x /\
    \ 10))\n\t\tdone\n\t\tif [ $even -eq 0 ]; then\n\t\t\tresult+=($x)\n\t\tfi\n\t\
    done\n\techo ${result[@]} | tr ' ' '\\n' | sort -n", "  for a in $1; do\n    b=`echo\
    \ $a | tr -d '0 2 4 6 8'`\n    if [ \"$a\" == \"$b\" ]; then\n      echo -n \"\
    $a \"\n    fi\n  done\n  echo", "    for num in $1; do\n        local -i count=0\n\
    \        for i in ${num//?/ }; do\n            if (( i % 2 == 0 )); then\n   \
    \             (( count += 1 ))\n            fi\n        done\n        if (( count\
    \ == 0 )); then\n            echo -n \"$num \"\n        fi\n    done\n    echo",
  "  # YOUR CODE HERE\n  #egrep -v $1\n  echo $1 | egrep -v [02468]", '   echo $1
    | tr " " "\n" | egrep "^[13579]*$" | sort -g', "\tarr=($1)\n\tret_arr=()\n\tfor\
    \ i in ${arr[@]}; do\n\t\tif [[ $i =~ ^[13579]+$ ]]; then\n\t\t\tret_arr+=($i)\n\
    \t\tfi\n\tdone\n\techo \"${ret_arr[@]}\" | tr ' ' '\\n' | sort -n", "    echo\
    \ $1 | tr ' ' '\\n' | grep -v '.*[02468].*' | sort -n", "    # write your code\
    \ here\n    # store the numbers with even digits in array $evens\n    # store\
    \ the numbers with odd digits in array $odds\n    # sort the array $odds and output\
    \ it\n    #\n    # for sorting, you can use the sort command in bash\n    # for\
    \ example, sort -n -r is reverse numeric sort\n    #\n    evens=()\n    odds=()\n\
    \    for x in $1; do\n        digit_even=0\n        while [ $x -gt 0 ]; do\n \
    \           if [ $((x % 2)) -eq 0 ]; then\n                digit_even=1\n    \
    \            break\n            fi\n            x=$((x / 10))\n        done\n\
    \        if [ $digit_even -eq 1 ]; then\n            evens+=($x)\n        else\n\
    \            odds+=($x)\n        fi\n    done\n    echo ${odds[@]} | tr ' ' '\\\
    n' | sort -n", "  for x in $1; do\n    if [[ $x =~ ^[0-9]+$ ]]; then \n      if\
    \ [[ $x =~ ^[1-9]+$ ]]; then \n        #echo $x\n        out=\"$out $x\"\n   \
    \   else\n        for((i=0; i<${#x}; i++)); do\n          if [[ ${x:$i:1} -eq\
    \ 0 ]]; then \n            #echo $x\n            out=\"$out $x\"\n           \
    \ break\n          fi\n        done\n      fi\n    fi\n  done\n  echo $out | tr\
    \ ' ' '\\n' | sort -n | uniq", "    echo \"$1\" | tr ' ' '\\n' | grep -E '^[13579]+$'\
    \ | sort -n", "\t# Write your code here\n\t# --------------------------------------------------------------------------\n\
    \t#\n\t# --------------------------------------------------------------------------",
  "    # one-liner for that outputs a space-separated list of numbers\n    # using\
    \ the test -e option\n    # Example:\n    #   >>> unique_digits([15, 33, 1422,\
    \ 1])\n    #   [1, 15, 33]\n    local list=$1\n    echo $list | tr ' ' '\\n' |\
    \ egrep -v '[02468]' | sort -n", "    # Enter your code here.\n    # Remove the\
    \ following line to pass all test cases\n    echo 'Not yet implemented'", "  #\
    \ TODO: your solution here\n  # https://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash\n\
    \  # https://www.tutorialspoint.com/unix/unix-string-operators.htm\n  local input=($1)\n\
    \  for num in \"${input[@]}\"; do\n    # https://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash\n\
    \    IFS='' read -r -a array <<< $(echo $num | sed 's/\\(.\\)/\\1 /g')\n    local\
    \ is_all_odd=1\n    for digit in \"${array[@]}\"; do\n      if [ $(($digit % 2))\
    \ -eq 0 ]; then\n        is_all_odd=0\n        break\n      fi\n    done\n   \
    \ if [ $is_all_odd -eq 1 ]; then\n      # https://www.tutorialspoint.com/unix/unix-basic-operators.htm\n\
    \      # ${array[@]}: like $* but with proper quoting\n      # https://www.tutorialspoint.com/unix/unix-special-variables.htm\n\
    \      result=\"$result $num\"\n    fi\n  done\n  echo $result", "    declare\
    \ -i sum=0\n    for num in $1; do\n        [ $(( num % 2 )) -eq 0 ] && {\n   \
    \         sum+=1\n            continue\n        }\n        for i in $(seq 0 $((${#num}-1)));\
    \ do\n            (( $((${num:$i:1} % 2)) == 0 )) && {\n                sum+=1\n\
    \                break\n            }\n        done\n    done\n    [ $sum -eq\
    \ 0 ] && echo \"$1\" || echo \"\"", "    awk '{for(i=1;i<=NF;i++)\n        if(!match($i,/2|4|6|8|0/))\
    \ printf \"%s \",$i}\n        END{print \"\"}'", "  # your solution here\n  echo\
    \ \"Not yet implemented\"", "    grep -v '.*[02468].*' <(echo $1) | sort -n"]
stop_tokens:
- "\n}"
