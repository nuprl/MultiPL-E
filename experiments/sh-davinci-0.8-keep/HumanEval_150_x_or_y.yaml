name: HumanEval_150_x_or_y
language: sh
prompt: "#!/bin/bash\n# A simple program which should return the value of x if n is\
  \ \n# a prime number and should return the value of y otherwise.\n# Examples:\n\
  # for x_or_y(7, 34, 12) == 34\n# for x_or_y(15, 8, 5) == 5\n#\n# $1 is an integer\n\
  # $2 is an integer\n# $3 is an integer\nx_or_y() {\n"
tests: "}\n\ncandidate() {\n    x_or_y \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"7\" \"34\" \"12\") = \"34\" ]]\n    [[ $(candidate \"15\" \"8\" \"5\") = \"\
  5\" ]]\n    [[ $(candidate \"3\" \"33\" \"5212\") = \"33\" ]]\n    [[ $(candidate\
  \ \"1259\" \"3\" \"52\") = \"3\" ]]\n    [[ $(candidate \"7919\" \"-1\" \"12\")\
  \ = \"-1\" ]]\n    [[ $(candidate \"3609\" \"1245\" \"583\") = \"583\" ]]\n    [[\
  \ $(candidate \"91\" \"56\" \"129\") = \"129\" ]]\n    [[ $(candidate \"6\" \"34\"\
  \ \"1234\") = \"1234\" ]]\n    [[ $(candidate \"1\" \"2\" \"0\") = \"0\" ]]\n  \
  \  [[ $(candidate \"2\" \"2\" \"0\") = \"2\" ]]\n}\n\nrun_test"
completions: ["\tif [[ $1 -eq 1 ]]; then\n\t\techo $3\n\telif [[ $(( $1 % 2 )) -eq\
    \ 0 ]]; then\n\t\techo $2\n\telif [[ $(( $1 % 3 )) -eq 0 ]]; then\n\t\techo $2\n\
    \telif [[ $(( $1 % 5 )) -eq 0 ]]; then\n\t\techo $2\n\telif [[ $(( $1 % 7 )) -eq\
    \ 0 ]]; then\n\t\techo $2\n\telse\n\t\techo $3\n\tfi", "  if [ $# -eq 3 ]; then\n\
    \    if [ $(is_prime $1) -eq 1 ]; then\n      echo \"$2\"\n    else\n      echo\
    \ \"$3\"\n    fi\n  else\n    echo \"Usage: x_or_y x y z\"\n  fi", "\ti=2\n\t\
    while [ $i -lt $1 ]\n\tdo\n\t\tr=$(($1 % $i))\n\t\tif [ $r -eq 0 ]\n\t\tthen\n\
    \t\t\techo $3\n\t\t\tbreak\n\t\telse\n\t\t\techo $2\n\t\t\tbreak\n\t\tfi\n\t\t\
    i=$(($i + 1))\n\tdone", "  if [ $1 -eq 2 ]; then\n    echo $2\n  elif [ $1 -eq\
    \ 3 ]; then\n    echo $2\n  elif [ $1 -eq 5 ]; then\n    echo $2\n  elif [ $1\
    \ -eq 7 ]; then\n    echo $2\n  elif [ $1 -eq 11 ]; then\n    echo $2\n  elif\
    \ [ $1 -eq 13 ]; then\n    echo $2\n  elif [ $1 -eq 17 ]; then\n    echo $2\n\
    \  elif [ $1 -eq 19 ]; then\n    echo $2\n  elif [ $1 -eq 23 ]; then\n    echo\
    \ $2\n  elif [ $1 -eq 29 ]; then\n    echo $2\n  elif [ $1 -eq 31 ]; then\n  \
    \  echo $2\n  elif [ $1 -eq 37 ]; then\n    echo $2\n  elif [ $1 -eq 41 ]; then\n\
    \    echo $2\n  elif [ $1 -eq 43 ]; then\n    echo $2\n  elif [ $1 -eq 47 ]; then\n\
    \    echo $2\n  elif [ $1 -eq 53 ]; then\n    echo $2\n  elif [ $1 -eq 59 ]; then\n\
    \    echo $2\n  elif [ $1 -eq 61 ]; then\n    echo $2\n  elif [ $1 -eq 67 ]; then\n\
    \    echo $2\n  elif [ $1 -eq 71 ]; then\n    echo $2\n  elif [ $1 -eq 73 ]; then\n\
    \    echo $2\n  elif [ $1 -eq 79 ]; then\n    echo $2\n  elif [ $1 -eq 83 ]; then\n\
    \    echo $2\n  elif [ $1 -eq 89 ]; then\n    echo $2\n  elif [ $1 -eq 97 ]; then\n\
    \    echo $2\n  else\n    echo $3\n  fi", "  if (( $1 > 0 )); then\n    if [ $3\
    \ -eq 1 ]; then\n      echo $2\n    elif [ $3 -eq 2 ]; then\n      echo $2\n \
    \   elif [ $3 -eq 3 ]; then\n      echo $2\n    elif [ $3 -eq 5 ]; then\n    \
    \  echo $2\n    elif [ $3 -eq 7 ]; then\n      echo $2\n    elif [ $3 -eq 11 ];\
    \ then\n      echo $2\n    elif [ $3 -eq 13 ]; then\n      echo $2\n    elif [\
    \ $3 -eq 17 ]; then\n      echo $2\n    elif [ $3 -eq 19 ]; then\n      echo $2\n\
    \    elif [ $3 -eq 23 ]; then\n      echo $2\n    elif [ $3 -eq 29 ]; then\n \
    \     echo $2\n    elif [ $3 -eq 31 ]; then\n      echo $2\n    elif [ $3 -eq\
    \ 37 ]; then\n      echo $2\n    elif [ $3 -eq 41 ]; then\n      echo $2\n   \
    \ elif [ $3 -eq 43 ]; then\n      echo $2\n    elif [ $3 -eq 47 ]; then\n    \
    \  echo $2\n    elif [ $3 -eq 53 ]; then\n      echo $2\n    elif [ $3 -eq 59\
    \ ]; then\n      echo $2\n    elif [ $3 -eq 61 ]; then\n      echo $2\n    elif\
    \ [ $3 -eq 67 ]; then\n      echo $2\n    elif [ $3 -eq 71 ]; then\n      echo\
    \ $2\n    elif [ $3 -eq 73 ]; then\n      echo $2\n    elif [ $3 -eq 79 ]; then\n\
    \      echo $2\n    elif [ $3 -eq 83 ]; then\n      echo $2\n    elif [ $3 -eq\
    \ 89 ]; then\n      echo $2\n    elif [ $3 -eq 97 ]; then\n      echo $2\n   \
    \ elif [ $3 -eq 101 ]; then\n      echo $2\n    elif [ $3 -eq 103 ]; then\n  \
    \    echo $2\n    elif [ $3 -eq 107 ]; then\n      echo $2\n    elif [ $3 -eq\
    \ 109", "    if [[ \"${1}\" -eq 0 ]]; then\n        echo \"Error: ${1} is not\
    \ an integer\"\n        exit 1\n    fi\n    if [[ \"${2}\" -eq 0 ]]; then\n  \
    \      echo \"Error: ${2} is not an integer\"\n        exit 1\n    fi\n    if\
    \ [[ \"${3}\" -eq 0 ]]; then\n        echo \"Error: ${3} is not an integer\"\n\
    \        exit 1\n    fi\n    if [[ $(factor ${1} | grep ${1} | wc -l) -eq 1 ]];\
    \ then\n        echo ${2}\n    else\n        echo ${3}\n    fi", "\tlocal n=\"\
    $1\"\n\tlocal x=\"$2\"\n\tlocal y=\"$3\"\n\tlocal counter=2\n\tlocal is_prime=0\n\
    \t#loop from 2 to $1-1 and increment the counter if the\n\t#remainder of $1 divided\
    \ by counter is zero\n\twhile [ $counter -lt $n ]\n\tdo\n\t\tif [ $(($n % $counter))\
    \ -eq 0 ]\n\t\tthen\n\t\t\tis_prime=1\n\t\t\tbreak\n\t\tfi\n\t\tcounter=$(($counter\
    \ + 1))\n\tdone\n\tif [ $is_prime -eq 0 ]\n\tthen\n\t\techo $x\n\telse\n\t\techo\
    \ $y\n\tfi", "\tif [ $1 -eq 0 ] || [ $1 -eq 1 ]; then\n\t\techo $3\n\telif [ $1\
    \ -eq 2 ]; then\n\t\techo $2\n\telif [ $(expr $1 % 2) -eq 0 ]; then\n\t\techo\
    \ $3\n\telse\n\t\tfor i in `seq 3 2 $(expr $1 - 1)`; do\n\t\t\tif [ $(expr $1\
    \ % $i) -eq 0 ]; then\n\t\t\t\techo $3\n\t\t\t\tbreak\n\t\t\telif [ $i -eq $(expr\
    \ $1 - 1) ]; then\n\t\t\t\techo $2\n\t\t\tfi\n\t\tdone\n\tfi", "\t# Check if $1\
    \ is a prime number.\n\t# If it is, return $2.\n\t# If it is not, return $3.\n\
    \t#\n\t# Hint: See the function is_prime_number() in \n\t#       this directory.\n\
    \t#\n\t# Hint: Use \"if\" and \"return\" to implement this function.", "    #\
    \ Write your code here\n    # If the first argument is an integer, check whether\
    \ the number\n    # is prime. If it is a prime number, return the second argument,\n\
    \    # else return the third argument.", "\tinteger=$1\n\tx=$2\n\ty=$3\n\tfor((i=2;i<integer;i++))\n\
    \tdo\n\t\tif [ $((integer%i)) -eq 0 ]\n\t\tthen\n\t\t\treturn $y\n\t\tfi\n\tdone\n\
    \treturn $x", '  if [ $1 -eq 3 ] || [ $1 -eq 5 ] || [ $1 -eq 7 ] || [ $1 -eq 11
    ] || [ $1 -eq 13 ] || [ $1 -eq 17 ] || [ $1 -eq 19 ] || [ $1 -eq 23 ] || [ $1
    -eq 29 ] || [ $1 -eq 31 ] || [ $1 -eq 37 ] || [ $1 -eq 41 ] || [ $1 -eq 43 ] ||
    [ $1 -eq 47 ] || [ $1 -eq 53 ] || [ $1 -eq 59 ] || [ $1 -eq 61 ] || [ $1 -eq 67
    ] || [ $1 -eq 71 ] || [ $1 -eq 73 ] || [ $1 -eq 79 ] || [ $1 -eq 83 ] || [ $1
    -eq 89 ] || [ $1 -eq 97 ] || [ $1 -eq 101 ] || [ $1 -eq 103 ] || [ $1 -eq 107
    ] || [ $1 -eq 109 ] || [ $1 -eq 113 ] || [ $1 -eq 127 ] || [ $1 -eq 131 ] || [
    $1 -eq 137 ] || [ $1 -eq 139 ] || [ $1 -eq 149 ] || [ $1 -eq 151 ] || [ $1 -eq
    157 ] || [ $1 -eq 163 ] || [ $1 -eq 167 ] || [ $1 -eq 173 ] || [ $1 -eq 179 ]
    || [ $1 -eq 181 ] || [ $1 -eq 191 ] || [ $1 -eq 193 ] || [ $1 -eq 197 ] || [ $1
    -eq 199 ] || [ $1 -eq 211 ] || [ $1 -eq 223 ] || [ $1 -eq 227 ] || [ $1 -eq 229
    ] || [ $1 -eq 233 ] || [ $1 -eq 239 ] || [ $1 -eq 241 ] || [ $1 -eq 251 ] || [
    $1 -eq 257 ] || [ $1 -eq 263 ] || [ $1 -eq 269 ] || [ $1 -eq 271 ] || [ $1 -eq
    277 ] || [ $1 -eq 281 ] || [ $1 -eq 283 ] || [ $1 -eq 293 ] || [ $1 -eq 307 ]
    || [ $1 -eq 311 ] || [ $1 -eq', "  if (($(is_prime $1) == 1)); then\n    echo\
    \ $2\n  else\n    echo $3\n  fi", "\tif [[ `is_prime $1` -eq 0 ]]; then\n\t\t\
    echo $2\n\telse\n\t\techo $3\n\tfi", "    if [ $# -eq 3 ]; then\n        for ((i=2;\
    \ i<=$3; i++)); do\n            if [ $(( $3 % $i )) -eq 0 ]; then\n          \
    \      if [ $i -eq $3 ]; then\n                    echo $1\n                else\n\
    \                    echo $2\n                fi\n                return\n   \
    \         fi\n        done\n    else\n        echo \"Something's wrong with the\
    \ input!\"\n    fi", "    # your code here\n    if [ $1 -eq 0 ]\n    then\n  \
    \      echo $3\n    elif [ $1 -eq 1 ]\n    then\n        echo $2\n    else\n \
    \       x_or_y $(( $1 - 1 )) $2 $3\n    fi", "\tif [ $1 -lt 2 ]; then\n\t\techo\
    \ $3\n\telif [ $1 -eq 2 ]; then\n\t\techo $2\n\telif [ $(($1 % 2)) -eq 0 ]; then\n\
    \t\techo $3\n\telse\n\t\tlocal i\n\t\tfor i in `seq 3 2 $(($1 / 2))`; do\n\t\t\
    \tif [ $(($1 % $i)) -eq 0 ]; then\n\t\t\t\techo $3\n\t\t\t\treturn\n\t\t\tfi\n\
    \t\tdone\n\t\techo $2\n\tfi", "\tfor i in $(seq 2 $1)\n\tdo\n\t\tif [[ $1 % $i\
    \ -eq 0 ]]\n\t\tthen\n\t\t\techo $3\n\t\t\treturn\n\t\tfi\n\tdone\n\techo $2",
  '  if [[ $1 -eq 2 ]] || [[ $1 -eq 3 ]] || [[ $1 -eq 5 ]] || [[ $1 -eq 7 ]] || [[
    $1 -eq 11 ]] || [[ $1 -eq 13 ]] || [[ $1 -eq 17 ]] || [[ $1 -eq 19 ]] || [[ $1
    -eq 23 ]] || [[ $1 -eq 29 ]] || [[ $1 -eq 31 ]] || [[ $1 -eq 37 ]] || [[ $1 -eq
    41 ]] || [[ $1 -eq 43 ]] || [[ $1 -eq 47 ]] || [[ $1 -eq 53 ]] || [[ $1 -eq 59
    ]] || [[ $1 -eq 61 ]] || [[ $1 -eq 67 ]] || [[ $1 -eq 71 ]] || [[ $1 -eq 73 ]]
    || [[ $1 -eq 79 ]] || [[ $1 -eq 83 ]] || [[ $1 -eq 89 ]] || [[ $1 -eq 97 ]] ||
    [[ $1 -eq 101 ]] || [[ $1 -eq 103 ]] || [[ $1 -eq 107 ]] || [[ $1 -eq 109 ]] ||
    [[ $1 -eq 113 ]] || [[ $1 -eq 127 ]] || [[ $1 -eq 131 ]] || [[ $1 -eq 137 ]] ||
    [[ $1 -eq 139 ]] || [[ $1 -eq 149 ]] || [[ $1 -eq 151 ]] || [[ $1 -eq 157 ]] ||
    [[ $1 -eq 163 ]] || [[ $1 -eq 167 ]] || [[ $1 -eq 173 ]] || [[ $1 -eq 179 ]] ||
    [[ $1 -eq 181 ]] || [[ $1 -eq 191 ]] || [[ $1 -eq 193 ]] || [[ $1 -eq 197 ]] ||
    [[ $1 -eq 199 ]] || [[ $1 -eq 211 ]] || [[ $1 -eq 223 ]] || [[ $1 -eq 227 ]] ||
    [[ $1 -eq 229 ]] || [[ $1 -eq 233 ]] || [[ $1 -eq 239 ]] || [[ $1 -eq 241 ]] ||
    [[ $1 -eq 251 ]] || [[ $1 -eq 257 ]] || [[ $1 -eq 263 ]] || [[ $1 -eq', "    \
    \    local number=$1\n        local x=$2\n        local y=$3\n        if [ $number\
    \ -le 0 ]; then\n                echo \"Error: number cannot be negative\"\n \
    \               exit 1\n        fi\n        is_prime \"$number\"\n        if [\
    \ $? -eq 0 ]; then\n                echo $x\n        else\n                echo\
    \ $y\n        fi"]
stop_tokens:
- "\n}"
