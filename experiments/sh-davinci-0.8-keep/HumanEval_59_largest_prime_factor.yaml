name: HumanEval_59_largest_prime_factor
language: sh
prompt: "#!/bin/bash\n# Return the largest prime factor of n. Assume n > 1 and is\
  \ not a prime.\n# >>> largest_prime_factor(13195)\n# 29\n# >>> largest_prime_factor(2048)\n\
  # 2\n#\n# $1 is an integer\nlargest_prime_factor() {\n"
tests: "}\n\ncandidate() {\n    largest_prime_factor \"$@\"\n}\n\nset -e\nrun_test()\
  \ {\n    [[ $(candidate \"15\") = \"5\" ]]\n    [[ $(candidate \"27\") = \"3\" ]]\n\
  \    [[ $(candidate \"63\") = \"7\" ]]\n    [[ $(candidate \"330\") = \"11\" ]]\n\
  \    [[ $(candidate \"13195\") = \"29\" ]]\n}\n\nrun_test"
completions: ["  local -i n=$1 p=2 max_p\n  while (( n > 1 )); do\n    if (( n % p\
    \ == 0 )); then\n      n /= p\n      max_p=$p\n    else\n      (( p++ ))\n   \
    \ fi\n  done\n  echo $max_p", "    if [ $1 -lt 1 ]; then\n        echo \"Input\
    \ must be an integer greater than 1\"\n        return 1\n    fi\n    if [ $1 -eq\
    \ 1 ]; then\n        echo \"1 has no prime factors\"\n        return 1\n    fi\n\
    \    if [ $1 -lt 4 ]; then\n        echo $1\n        return\n    fi\n    n=$1\n\
    \    p=2\n    while [ $n -gt 1 ]; do\n        while [ $((n % p)) -eq 0 ]; do\n\
    \            n=$((n / p))\n        done\n        p=$((p + 1))\n    done\n    echo\
    \ $((p - 1))", "  local n=$1\n  local i=2\n  local max=$((n/2))\n  while [[ i\
    \ -le max ]]; do\n    if [[ $((n%i)) -eq 0 ]]; then\n      n=$((n/i))\n      max=$((n/2))\n\
    \    else\n      ((i++))\n    fi\n  done\n  echo $n", "  local n=$1\n  # Find\
    \ the smallest factor of n.\n  local factor=2\n  while (( $n % $factor != 0 ));\
    \ do\n    (( ++factor ))\n  done\n  # If factor is the same as n, then n is prime.\n\
    \  if (( $factor == $n )); then\n    printf \"%d\\n\" $n\n  else\n    # Recurse\
    \ on the largest factor of n to find the largest prime factor.\n    largest_prime_factor\
    \ $(($n / $factor))\n  fi", "    n=\"$1\"\n    last_factor=2\n    while [ $n -gt\
    \ 1 ]; do\n        factor=$(factor $n | awk '{print $2}')\n        if [ $n -eq\
    \ $factor ]; then\n            return $n\n        else\n            last_factor=$factor\n\
    \            n=$(expr $n / $factor)\n        fi\n    done\n    return $last_factor",
  "    local n=$1\n    local f=2\n    local m=$(( $n - 1 ))\n    local c=1\n    for\
    \ (( f = 2; f <= $m; f++ )); do\n        if (( $n % $f == 0 )); then\n       \
    \     n=$(( $n / $f ))\n            m=$(( $n - 1 ))\n            c=$f\n      \
    \  fi\n    done\n    echo $c", "  local n=\"$1\"\n\n  # If n is even, then the\
    \ largest prime factor must be even as well.\n  # Divide out all 2s, and then\
    \ proceed.\n  while [ $(($n % 2)) -eq 0 ]; do\n    n=$(($n / 2))\n  done\n\n \
    \ # Now, n is an odd number, and we can begin looking for the largest prime factor.\n\
    \  # Loop over all odd numbers.  Break when we reach the square root of n.\n \
    \ local i=3\n  while [ $i -le $((n ** 0.5)) ]; do\n    while [ $(($n % $i)) -eq\
    \ 0 ]; do\n      n=$(($n / $i))\n    done\n    i=$(($i + 2))\n  done\n\n  echo\
    \ $n", "    if [ $1 -lt 1 ]; then\n        echo \"argument must be greater than\
    \ 1\";\n        return 1;\n    fi\n    # figure out which two numbers when multiplied\
    \ give us $1.\n    # then find the largest prime factor of those two numbers.\n\
    \    # then replace those numbers with the largest prime factor of each.\n   \
    \ # continue until you find a prime factor larger than $1.\n    for ((j=2; j<=$1;\
    \ j++)); do\n        if [ $(( $1 % $j )) -eq 0 ]; then\n            for ((k=2;\
    \ k<=$1; k++)); do\n                if [ $(( $1 % $k )) -eq 0 ]; then\n      \
    \              largest_prime_factor_aux $j $k\n                    return 0\n\
    \                fi\n            done\n        fi\n    done", "    local n=$1\n\
    \    # Try all numbers from 2 to n/2 to see if they divide n.\n    for (( i=2;\
    \ i<=n/2; i++ )); do\n        # If i divides n evenly, divide n by i and try the\
    \ same thing again.\n        if (( n % i == 0 )); then\n            n=$(( n /\
    \ i ))\n            # Continue to the next iteration of the loop, i.e. don't increment\
    \ i.\n            continue\n        fi\n        # If i doesn't divide n evenly,\
    \ try the next value of i, i.e. increment i.\n        (( i++ ))\n    done\n  \
    \  # If i is greater than n/2, then n is the largest prime factor.\n    echo $n",
  "  local N=$1 M=$2\n  if (( $N % $M == 0 )); then\n    local Q=$(( N / M ))\n  \
    \  if (( $Q > 1 )); then\n      largest_prime_factor $Q $M\n    else\n      echo\
    \ $M\n    fi\n  else\n    (( M += 1 ))\n    largest_prime_factor $N $M\n  fi",
  "    local number=$1\n    local i=2\n    local largest_prime=1\n    while [ $i -lt\
    \ $number ]; do\n        if [ $(is_divisible $number $i) -eq 1 ]; then\n     \
    \       local q=$((number / i))\n            if [ $(is_prime $q) -eq 1 ]; then\n\
    \                largest_prime=$q\n                break\n            fi\n   \
    \     fi\n        i=$((i + 1))\n    done\n    echo $largest_prime", "  if [ $1\
    \ -eq 2 ]; then\n    echo $1\n    return\n  fi\n  # Primes > 2 are odd.\n  if\
    \ [ $(( $1 % 2 )) -eq 0 ]; then\n    largest_prime_factor $(( $1 / 2 ))\n    return\n\
    \  fi\n  for i in $(seq 3 2 $(( $1 / 2 ))); do\n    if [ $(( $1 % $i )) -eq 0\
    \ ]; then\n      largest_prime_factor $(( $1 / $i ))\n      return\n    fi\n \
    \ done\n  echo $1", "    local n=$1; shift\n\n    local largest=2\n    local p=2\n\
    \    local quotient=$n\n    local remainder=0\n\n    # Keep finding smallest prime\
    \ factor until the prime factor is the largest\n    # factor.\n    while ((p <\
    \ n))\n    do\n        ((remainder = quotient % p))\n        if ((remainder ==\
    \ 0))\n        then\n            largest=$p\n            ((quotient = quotient\
    \ / p))\n        else\n            ((p = p + 1))\n        fi\n    done\n\n   \
    \ echo $largest", "  local n=$1\n  local largest_factor=2\n  for i in $(seq 2\
    \ $(($n / 2))); do\n    if [ $((n % i)) -eq 0 ]; then\n      largest_factor=$i\n\
    \      while [ $((n % largest_factor)) -eq 0 ]; do\n        n=$((n / largest_factor))\n\
    \      done\n    fi\n  done\n  echo $largest_factor", "  # Get the even factors:\n\
    \  factor=$(($1 / 2))\n  while [ $(($1 % $factor)) -ne 0 ]; do\n    factor=$(($factor\
    \ - 1))\n  done\n  # Factor is now the largest even factor of $1.\n  if [ $(($factor\
    \ % 2)) -eq 0 ]; then\n    # Factor is even.\n    factor=$(($factor / 2))\n  else\n\
    \    # Factor is odd.\n    factor=$(($factor / 3))\n  fi\n  while [ $(($1 % $factor))\
    \ -ne 0 ]; do\n    factor=$(($factor - 1))\n  done\n  # Factor is now the largest\
    \ prime factor of $1.\n  echo $factor", "  N=$1\n  ## declare a local array to\
    \ collect all the prime factor\n  declare -a prime_factor\n  for((i=2;i<=N;i++));do\n\
    \    if [ $((N%i)) -eq 0 ];then\n      N=$((N/i))\n      prime_factor+=($i)\n\
    \      i=$((i-1))\n    fi\n  done\n  echo \"${prime_factor[@]}\" | tr ' ' '\\\
    n' | sort -n | tail -n 1", "    local n=$1\n    local i=2\n    local largest=1\n\
    \    # keep dividing until we reach a number that is prime\n    until [ $i -gt\
    \ $n ]; do\n        # if $n is divisible by $i, keep dividing by $i until we\n\
    \        # reach a number that isn't divisible by $i\n        if [ $((n % i))\
    \ -eq 0 ]; then\n            n=$((n / i))\n            largest=$i\n        else\n\
    \            i=$((i + 1))\n        fi\n    done\n    echo $largest", "  local\
    \ target=$1\n  local primes=()\n  # First collect all the primes less than target\n\
    \  for ((i=2; i <= target; i++)); do\n    if is_prime $i; then\n      primes+=($i)\n\
    \    fi\n  done\n  # Then test them in reverse order\n  local n=${#primes[@]}\n\
    \  while (($n > 0)); do\n    if ((target % ${primes[$((n-1))]} == 0)); then\n\
    \      echo ${primes[$((n-1))]}\n      return\n    fi\n    ((n--))\n  done", " \
    \   echo -n \"Input: $1. Largest prime factor: \"\n    factor $1 | awk '\n   \
    \     /^[0-9]+:$/ { next }\n        { print $NF }\n        END { print \".\" }\n\
    \    '", "    n=$1\n    i=2\n    while [[ $n -gt 1 ]]; do\n        if [[ $(( n\
    \ % i )) -eq 0 ]]; then\n            n=$(( n / i ))\n        else\n          \
    \  i=$(( i + 1 ))\n        fi\n    done\n    echo $i"]
stop_tokens:
- "\n}"
