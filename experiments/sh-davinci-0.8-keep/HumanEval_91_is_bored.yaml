name: HumanEval_91_is_bored
language: sh
prompt: "#!/bin/bash\n# You'll be given a string of words, and your task is to count\
  \ the number\n# of boredoms. A boredom is a sentence that starts with the word \"\
  I\".\n# Sentences are delimited by '.', '?' or '!'.\n# For example:\n# >>> is_bored(\"\
  Hello world\")\n# 0\n# >>> is_bored(\"The sky is blue. The sun is shining. I love\
  \ this weather\")\n# 1\n#\n# $1 is a string\nis_bored() {\n"
tests: "}\n\ncandidate() {\n    is_bored \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
  \ $(candidate \"Hello world\") = \"0\" ]]\n    [[ $(candidate \"Is the sky blue?\"\
  ) = \"0\" ]]\n    [[ $(candidate \"I love It \\!\") = \"1\" ]]\n    [[ $(candidate\
  \ \"bIt\") = \"0\" ]]\n    [[ $(candidate \"I feel good today. I will be productive.\
  \ will kill It\") = \"2\" ]]\n    [[ $(candidate \"You and I are going for a walk\"\
  ) = \"0\" ]]\n}\n\nrun_test"
completions: ["    local count=0\n    local flag=0\n    for ((i=0; i<${#1}; i++));\
    \ do\n        if [[ \"${1:$i:1}\" == 'I' ]]; then\n            count=$((count+1))\n\
    \            flag=1\n        elif [[ \"${1:$i:1}\" == '.' || \"${1:$i:1}\" ==\
    \ '?' || \"${1:$i:1}\" == '!' ]]; then\n            flag=0\n        elif [[ $flag\
    \ -eq 1 && \"${1:$i:1}\" != ' ' ]]; then\n            count=$((count-1))\n   \
    \         flag=0\n        fi\n    done\n    echo $count", "  echo \"$1\" | grep\
    \ -io '^i' | wc -l", "    echo $1 | grep -E '^I' | grep -oE '[!?.]' | wc -l",
  "  echo \"$1\" | tr -cd '.!?\\n' | tr '\\n' ' ' | sed -e 's/\\.\\|!\\|?/\\n/g' |\
    \ grep -c -e '^I '", "  echo $1 | tr -s '[:space:]' '\\n' | grep \"^I\" | wc -l",
  "  # YOUR CODE HERE\n  echo \"$1\" | grep -c \"^I\"", "  wc -l < <(echo $1 | sed\
    \ -e 's/[?.!]/\\n/g' | grep -E '^I')", "    local tmpfile\n    tmpfile=$(mktemp)\n\
    \    echo $1 | sed -r 's/([.?!])/\\1\\n/g' > ${tmpfile}\n    grep -x \"I\" ${tmpfile}\
    \ | wc -l\n    rm ${tmpfile}", "    echo $1 | awk '{\n        gsub(/[.]/, \" \"\
    );\n        gsub(/[?]/, \" \");\n        gsub(/[!]/, \" \");\n        print gsub(/\\\
    bI\\b/, \"\")\n    }'", "  echo $1 | grep -o -i -w -c '\\bi\\b'", '  echo "$1"
    | grep -c "^I "', "  grep -o -i '^[i]' | wc -l", "\techo \"$1\" | grep -o -E 'I\
    \ [a-zA-Z]*(.|!|\\?)' | wc -l", "    # Use a regex to find all matches of 'I',\
    \ and set the match to \\1\n    # Then replace the 'I' with '' and concatenate\
    \ the remaining string with\n    # '.' and use grep -c to count all the lines.\n\
    \    echo $1 | sed 's/I \\(.*\\)/\\1/g' | tr -d '\\n' | sed 's/\\./\\.\\n/g' |\
    \ grep -c 'I'", "    echo \"$1\" | awk -F \"[.?!]\" 'BEGIN {boredoms=0} {for (i=1;\
    \ i<=NF; i++) {if ($i~/^\\s*I/) {boredoms++}}} END {print boredoms}'", "\techo\
    \ $1 | grep -o -E '(^|[\\.?!])\\s*I' | wc -l", '  echo "$1" | grep -o "I" | wc
    -l', "  echo \"$1\" | grep -c -e '^I'", "    echo $1 | grep -o 'I[^\\.!?]*[\\\
    .!?]' | wc -l", "\techo \"$1\" | grep -o \"I[^.!?]*[.!?]\" | wc -l"]
stop_tokens:
- "\n}"
