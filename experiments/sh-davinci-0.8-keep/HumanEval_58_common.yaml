name: HumanEval_58_common
language: sh
prompt: "#!/bin/bash\n# Return sorted unique common elements for two lists.\n# >>>\
  \ common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n#\
  \ >>> common([5, 3, 2, 8], [3, 2])\n# [2, 3]\n#\n# $1 is a space-separated list\n\
  # $2 is a space-separated list\ncommon() {\n"
tests: "}\n\ncandidate() {\n    common \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
  \ \"1 4 3 34 653 2 5\" \"5 7 1 5 9 653 121\") = \"1 5 653\" ]]\n    [[ $(candidate\
  \ \"5 3 2 8\" \"3 2\") = \"2 3\" ]]\n    [[ $(candidate \"4 3 2 8\" \"3 2 4\") =\
  \ \"2 3 4\" ]]\n    [[ $(candidate \"4 3 2 8\" \"\") = \"\" ]]\n}\n\nrun_test"
completions: ["    echo \"$1\" \"$2\" | tr ' ' '\\n' | sort | uniq -d", "    # sort\
    \ and get unique elements from each list\n    local list_a=\"$(echo $1 | tr '\
    \ ' '\\n' | sort -n | uniq)\"\n    local list_b=\"$(echo $2 | tr ' ' '\\n' | sort\
    \ -n | uniq)\"\n\n    # Print common elements.\n    grep -Fx -f <(echo \"$list_a\"\
    ) <(echo \"$list_b\")", "    if [[ $# == 0 ]]; then\n        printf '%s\\n' \"\
    common: Invalid number of arguments. Usage: common [list1] [list2]\"\n       \
    \ return 1\n    fi\n    local list1=($1)\n    local list2=($2)\n    declare -A\
    \ h1\n    for i in \"${list1[@]}\"; do\n        h1[$i]=1\n    done\n    for i\
    \ in \"${list2[@]}\"; do\n        if [[ ${h1[$i]} ]]; then\n            printf\
    \ '%s\\n' \"$i\"\n        fi\n    done | sort -n", "    local -a A=(\"${!1}\"\
    )\n    local -a B=(\"${!2}\")\n    local -A map\n    local i item\n    for i in\
    \ \"${A[@]}\"; do\n        map[$i]=1\n    done\n    for i in \"${B[@]}\"; do\n\
    \        [[ -n ${map[$i]} ]] && item+=($i)\n    done\n    if [[ ${#item[@]} -gt\
    \ 0 ]]; then\n        printf \"%s\\n\" \"${item[@]}\" | sort -u\n    fi", "  echo\
    \ \"$1\" \"$2\" | tr ' ' '\\n' | sort | uniq -d", "    local in1=\"$1\"\n    local\
    \ in2=\"$2\"\n    local out=\"\"\n    local l=\"\"\n    for l in $in1; do\n  \
    \      grep -w $l <<< $in2 > /dev/null && out=\"$out $l\"\n    done\n    echo\
    \ $out | awk '{for(i=1;i<=NF;i++)a[$i]++}END{for(i in a)print i}'", "  if [ -z\
    \ \"$1\" ] || [ -z \"$2\" ]; then\n    echo \"$1$2\"\n  else\n    declare -a array1\n\
    \    declare -a array2\n    declare -a result\n\n    IFS=' ' read -a array1 <<<\
    \ \"$1\"\n    IFS=' ' read -a array2 <<< \"$2\"\n\n    for (( i=0; i<${#array1[@]};\
    \ i++ )); do\n      for (( j=0; j<${#array2[@]}; j++ )); do\n        if [ \"${array1[$i]}\"\
    \ = \"${array2[$j]}\" ]; then\n          result+=(\"${array1[$i]}\")\n       \
    \ fi\n      done\n    done\n\n    echo \"${result[@]}\"\n  fi", "    lst=$(printf\
    \ '%s\\n' \"$1\" \"$2\" | sort | uniq -d)\n    echo $lst", "\tprintf \"%s\\n\"\
    \ $1 $2 | sort | uniq -d", "    local result line1 line2\n    IFS=$' \\t\\n'\n\
    \    for line1 in $1; do\n        for line2 in $2; do\n            if [[ $line1\
    \ = $line2 ]]; then\n                result=\"$result $line1\"\n            fi\n\
    \        done\n    done\n    echo $result", "    local f=\"$(mktemp)\"\n    local\
    \ s=\"$(mktemp)\"\n    local r=\"$(mktemp)\"\n    local list1 list2\n\n    for\
    \ list1 in $1; do\n        echo \"$list1\" >> \"$f\"\n    done\n    for list2\
    \ in $2; do\n        echo \"$list2\" >> \"$s\"\n    done\n\n    sort \"$f\" \"\
    $s\" | uniq -d > \"$r\"\n    < \"$r\" tr '\\n' ' ' | sed 's/ $//'\n    rm \"$f\"\
    \ \"$s\" \"$r\"", "  local _string1=\"${1}\"\n  local _string2=\"${2}\"\n  local\
    \ _result=\"\"\n  local _tmp=\"\"\n\n  # Sort list1.\n  _tmp=$(printf '%s\\n'\
    \ ${_string1} | sort -n)\n  _string1=$(echo \"${_tmp}\" | tr '\\n' ' ')\n\n  #\
    \ Sort list2.\n  _tmp=$(printf '%s\\n' ${_string2} | sort -n)\n  _string2=$(echo\
    \ \"${_tmp}\" | tr '\\n' ' ')\n\n  # Find common elements.\n  _tmp=$(comm -12\
    \ <(echo \"${_string1}\") <(echo \"${_string2}\"))\n  _result=$(echo \"${_tmp}\"\
    \ | tr '\\n' ' ')\n\n  # Print results.\n  printf '%s\\n' \"${_result}\" | sort\
    \ -n", "    local items=()\n    for x in $1; do\n        for y in $2; do\n   \
    \         [[ $x == $y ]] && items+=($x)\n        done\n    done\n    echo \"${items[@]}\"\
    \ | sort -u", "    local xs ys common\n    xs=$(trim \"$1\")\n    ys=$(trim \"\
    $2\")\n    common=$(comm -12 <(echo \"$xs\" | sort -u) <(echo \"$ys\" | sort -u))\n\
    \    echo \"$common\"", "    local l1=($1)\n    local l2=($2)\n    local common=()\n\
    \    local unique=()\n    local i=\n    local j=\n    local k=\n    local l=\n\
    \    for i in \"${l1[@]}\"; do\n        for j in \"${l2[@]}\"; do\n          \
    \  if [[ \"$i\" == \"$j\" ]]; then\n                common+=(\"$i\")\n       \
    \     fi\n        done\n    done\n    # now we have the common elements,\n   \
    \ # get unique by applying \"unique\"\n    for k in \"${common[@]}\"; do\n   \
    \     for l in \"${unique[@]}\"; do\n            if [[ \"$k\" == \"$l\" ]]; then\n\
    \                break\n            fi\n        done\n        if [[ \"$k\" !=\
    \ \"$l\" ]]; then\n            unique+=(\"$k\")\n        fi\n    done\n    echo\
    \ \"${unique[@]}\"", "    local a=\"$1\" b=\"$2\"\n    if [[ -z \"$a\" || -z \"\
    $b\" ]]; then\n        echo \"$a\"\n        return 0\n    fi\n    local b_sorted\n\
    \    sort_unique \"$b\" && b_sorted=\"$(< /tmp/sort_unique)\"\n    local a_sorted\n\
    \    sort_unique \"$a\" && a_sorted=\"$(< /tmp/sort_unique)\"\n    local result\n\
    \    while IFS= read -r line; do\n        if [[ -z \"$result\" ]]; then\n    \
    \        if echo \"$b_sorted\" | grep -qw \"$line\"; then\n                result=\"\
    $line\"\n            fi\n        else\n            if echo \"$b_sorted\" | grep\
    \ -qw \"$line\"; then\n                result=\"$result $line\"\n            fi\n\
    \        fi\n    done <<< \"$a_sorted\"\n    sort_unique \"$result\"", "  local\
    \ IFS=$'\\n'\n  a1=($1)\n  a2=($2)\n  declare -A i2\n  for e in \"${a2[@]}\";\
    \ do i2[$e]=1; done\n  out=()\n  for e in \"${a1[@]}\"; do\n    if [[ ${i2[$e]}\
    \ ]]; then\n      out=(${out[@]} $e)\n    fi\n  done\n  echo ${out[@]}", '    sort
    -u <<<"$1 $2" | uniq -d', "    local l1=\"$1\"\n    local l2=\"$2\"\n    local\
    \ array1=( ${l1} )\n    local array2=( ${l2} )\n    declare -A arr_counts\n  \
    \  declare -a arr_commons\n    # iterate first array, updating hash with counts\
    \ of each item\n    for item in \"${array1[@]}\"; do\n        if [ \"${arr_counts[$item]}\"\
    \ ]; then\n            arr_counts[$item]=$((arr_counts[$item] + 1))\n        else\n\
    \            arr_counts[$item]=1\n        fi\n    done\n    # iterate second array,\
    \ outputting any item which appears in both\n    for item in \"${array2[@]}\"\
    ; do\n        if [ \"${arr_counts[$item]}\" ]; then\n            arr_commons+=(\"\
    $item\")\n        fi\n    done\n    # sort and de-dupe\n    printf \"%s\\n\" \"\
    ${arr_commons[@]}\" | sort -n | uniq", "    arr1=(\"$@\")\n    arr2=(\"$@\")\n\
    \    i=0\n    j=0\n    common=()\n    while [ \"$i\" -lt \"${#arr1[@]}\" ]; do\n\
    \        v1=\"${arr1[$i]}\"\n        j=0\n        while [ \"$j\" -lt \"${#arr2[@]}\"\
    \ ]; do\n            v2=\"${arr2[$j]}\"\n            if [ \"$v1\" == \"$v2\" ];\
    \ then\n                common+=($v1)\n                break\n            fi\n\
    \            j=$((j+1))\n        done\n        i=$((i+1))\n    done\n    result=$(\
    \ printf \"%s\\n\" \"${common[@]}\" | sort -u )\n    printf \"%s\\n\" \"$result\""]
stop_tokens:
- "\n}"
