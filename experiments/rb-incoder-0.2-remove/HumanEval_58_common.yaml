name: HumanEval_58_common
language: rb
prompt: "# Return sorted unique common elements for two lists.\ndef common(l1, l2)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n\
  \    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5,\
  \ 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3,\
  \ 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"
completions: ["  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n  \
    \  end\n  end\n  nil\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work.\
    \ Try it with `[1,2,3]` and `[1,2,4]`.\n<|/ c |>\n<| c |>\nYes, it does. I tested\
    \ it before posting it. I just added a comment to the code explaining why it doesn't.\n\
    <|/ c |>\n<| c |>\nI see what you mean. My bad.\n<|/ c |>\n<| c |>\nI added a\
    \ comment to the code explaining why it doesn't.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<code>", "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n\
    \    end\n  end\n  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return\
    \ x if x == y\n    end\n  end\nend", "  l1.each do |e|\n    l2.each do |f|\n \
    \     return e if e == f\n    end\n  end\nend", "  l1.each do |e|\n    l2.each\
    \ do |f|\n      return e if e == f\n    end\n  end\n  nil\nend", "  l1.each do\
    \ |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend",
  "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    end", "  l1.zip(l2).to_a.sort.uniq.map(&:first)\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the lists.\n<|/ c\
    \ |>\n<| c |>\nI added a version that works with duplicates.\n<|/ c |>\n<| c |>\n\
    I added a version that works with duplicates.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l1.each do |i|\n    l2.each do |j|\n      return i if i == j\n\
    \    end\n  end\nend", "  l1.each do |x|\n    l2.each do |y|\n      return x if\
    \ x == y\n    end\n  end\n  nil\nend", "  l1.each do |e|\n    l2.each do |f|\n\
    \      return e if e == f\n    end\n  end\n  nil\nend", "  l1.each do |e|\n  \
    \  l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend", "  l1.each\
    \ do |i|\n    l2.each do |j|\n      return i if i == j\n    end\n  end\n  nil\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like the idea of using Enumerable#inject\
    \ to iterate over the arrays. But this doesn't work if you have duplicate elements\
    \ in your arrays. For example, `common([1,2,3], [1,2,3])` returns `nil` instead\
    \ of `[1,2,3]`.\n<|/ c |>\n<| c |>\n: Yes, I didn't consider that. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| c |>\n: I added a version that doesn't have that\
    \ problem.\n<|/ c |>\n<| c |>\n: I added a version that doesn't have that problem.\n\
    <|/ c |>\n<| c |>\n: I added a version that doesn't have that problem.\n<|/ c\
    \ |>\n<| a dscore=5 |>\n<code>", "  l1.each do |x|\n    l2.each do |y|\n     \
    \ return x if x == y\n    end\n  end\n  nil\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI didn't know about `Enumerable#uniq`. Thanks for sharing.\n<|/ c |>\n\
    <| c |>\nThanks for sharing, but this doesn't work. `common([1,2,3], [1,2,3])`\
    \ returns `nil`, while `common([1,2,3], [1,2,4])` returns `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nOops, I missed the fact that `common` should return `nil` when given\
    \ two empty lists. I updated my answer.\n<|/ c |>\n<| c |>\nThanks for your help.\
    \ I ended up using your first solution, since it seemed more efficient to me.\
    \ Thanks again!\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  l1.each do |e|\n    l2.each\
    \ do |f|\n      return e if e == f\n    end\n  end\nend", "  l1.each do |e|\n\
    \    l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis is not the most efficient solution. `Array#uniq`\
    \ does a linear search for each element in the array. `Array#sort` does a linear\
    \ search for each element in the array. `Array#uniq` also does a linear search\
    \ for each element in the array. `Array#sort` does a linear search for each element\
    \ in the array. `Array#uniq` does a linear search for each element in the array.\
    \ `Array#sort` does a linear search for each element in the array. `Array#uniq`\
    \ does a linear search for each element in the array. `Array#sort` does a linear\
    \ search for each element in the array. `Array#uniq` does a linear search for\
    \ each element in the array. `Array#sort` does a linear search for each element\
    \ in the array. `Array#uniq` does a linear search for each element in the array.\
    \ `Array#sort` does a linear search for each element in the array. `Array#uniq`\
    \ does a linear search for each element in the array. `Array#sort` does a linear\
    \ search for each element in the array. `Array#uniq` does a linear search for\
    \ each element in the array. `Array#sort` does a linear search for each element\
    \ in the array. `Array#uniq` does a linear search for each element in the array.\
    \ `Array#sort` does a linear search for each element in the array. `Array#uniq`\
    \ does a linear search for each element in the array. `Array#sort` does a linear\
    \ search for each element in the array. `Array#uniq` does a linear search for\
    \ each element in the array. `Array#sort` does a linear search for each element\
    \ in the array. `Array#uniq` does a linear search for each element in the array.\
    \ `Array#sort` does a linear search for each element in the array. `Array#uniq`\
    \ does a linear search for each element in the array. `Array#sort` does a linear\
    \ search for each element in the array. `Array#uniq` does a linear search for\
    \ each element in the array. `Array#sort` does a linear search for each element\
    \ in the array. `Array#uniq` does a linear search for each element in the array.\
    \ `Array#sort` does a linear search for each element in the array. `Array#uniq`\
    \ does a linear search for each element in the array. `Array#sort` does a linear\
    \ search for each element in the array. `Array#uniq` does a linear search ", " \
    \ l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n\
    end", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n\
    \  end\n  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return x if\
    \ x == y\n    end\n  end\n  nil\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ doesn't work if there are duplicates in the lists.\n<|/ c |>\n<| c |>\nIt does\
    \ work if there are duplicates in the lists. I tested it before posting.\n<|/\
    \ c |>\n<| c |>\nYes, it does work. Try it out with your example lists. I tested\
    \ it before posting.\n<|/ c |>\n<| c |>\nYes, it does work. Try it out with your\
    \ example lists. I tested it before posting.\n<|/ c |>\n<| c |>\nI tested it before\
    \ posting. And it does work. Try it out with your example lists. I tested it before\
    \ posting.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l1.each do |x|\n    l2.each\
    \ do |y|\n      return x if x == y\n    end\n  end\n  nil\nend", "  l1.each do\
    \ |i|\n    l2.each do |j|\n      return i if i == j\n    end\n  end\nend", " \
    \ l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n\
    \  nil\nend", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n\
    \    end\n  end\n  return nil\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ doesn't work. Try it with `common([1,2,3], [1,2,4])`.\n<|/ c |>\n<| c |>\nThanks,\
    \ I fixed it.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l1.each do |x|\n    l2.each\
    \ do |y|\n      return x if x == y\n    end\n  end\nend", "  l1.each do |e|\n\
    \    l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend", " \
    \ l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  nil\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThanks so much! This\
    \ was very helpful.\n<|/ c |>\n<| c |>\nThis code doesn't work if there are duplicates\
    \ in the arrays. For example, `[1,2,2,3]` returns `[2,3]` instead of `[2,3]`.\n\
    <|/ c |>\n<| c |>\nI added a fix for that case.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n   \
    \ end\n  end\n  nil\nend", "  l1.each do |e|\n    l2.each do |f|\n      return\
    \ e if e == f\n    end\n  end\n  return nil\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis is not the correct answer. `common([1,2,3], [1,2,4])` returns\
    \ `nil`, while `common([1,2,3], [1,2,3])` returns `[3]`.\n<|/ c |>\n<| c |>\n\
    I see what you mean. I've updated my answer to fix the bug. Thanks!\n<|/ c |>\n\
    <| c |>\n`common([1,2,3], [1,2,4])` returns `nil`, while `common([1,2,3], [1,2,3])`\
    \ returns `[3]`.\n<|/ c |>\n<| c |>\nYes, I see what you mean. I've updated my\
    \ answer to fix the bug. Thanks!\n<|/ c |>\n<| c |>\nI believe that `common([1,2,3],\
    \ [1,2,4])` returns `nil` because `[1,2,4]` does not contain `1`.\n<|/ c |>\n\
    <| a |>\n<code>", "  l1.each do |e|\n    l2.each do |f|\n      return e if e ==\
    \ f\n    end\n  end\nend", "  l1.each do |e|\n    l2.each do |f|\n      return\
    \ e if e == f\n    end\n  end\n  nil\nend", "  l1.zip(l2).find { |e| e[0] == e[1]\
    \ }\nend", "  l1.each do |i|\n    l2.each do |j|\n      return i if i == j\n \
    \   end\n  end\n  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return\
    \ x if x == y\n    end\n  end\n  nil\nend", "  l1.each do |x|\n    l2.each do\
    \ |y|\n      return x if x == y\n    end\n  end\nend", "  l1.each do |e|\n   \
    \ l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "  l1.each do |e|\n    l2.each do\
    \ |f|\n      return e if e == f\n    end\n  end\n  nil\nend", "  l1.each do |x|\n\
    \    l2.each do |y|\n      return x if x == y\n    end\n  end\n  nil\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis is not the fastest solution, since it\
    \ does a lot of unnecessary comparisons.\n<|/ c |>\n<| c |>\nYes, I agree. I've\
    \ added a faster solution that doesn't require any comparisons.\n<|/ c |>\n<|\
    \ c |>\nThis is not the fastest solution, since it does a lot of unnecessary comparisons.\n\
    <|/ c |>\n<| c |>\nI agree. I've added a faster solution that doesn't require\
    \ any comparisons.\n<|/ c |>\n<| c |>\nThis is not the fastest solution, since\
    \ it does a lot of unnecessary comparisons.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    a = [1,2,3,4,5]\nb = [2,4,6,8,10]\na.zip(b).select { |x, y| x == y }\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis is not the fastest solution, since it\
    \ does a lot of unnecessary comparisons.\n<|/ c |>\n<| c |>\nThis is not the fastest\
    \ solution, since it does a lot of unnecessary comparisons.\n<|/ c |>\n<| c |>\n\
    This is not the fastest solution, since it does a lot of unnecessary comparisons.\n\
    <|/ c |>\n<| c |>\nThis is not the fastest solution, since it does a lot of unnecessary\
    \ comparisons.\n<|/ c |>\n<| c |>\nThis is not the fastest solution, since it\
    \ does a lot of unnecessary comparisons.\n<|/ c |>\n<| a |>\n<code>\na = [1,2,3,4,5]\n\
    b = [2,4,6,8,10]\na.zip(b).select { |x, y| x == y }\n</code>\n<|/ a dscore=5 tags=ruby,arrays\
    \ |>\n<| c |>\nThis is not the fastest solution, since it does a lot of unnecessary\
    \ comparisons.\n<|/ c |>\n<| c |>\nThis is not the fastest solution, since it\
    \ does a lot of unnecessary comparisons.\n<|/ c |>\n<| c |>\nThis is not the fastest\
    \ solution, since it does a lot of unnecessary comparisons.\n<|/ c |>\n<| c |>\n\
    This is not the fastest solution, since it ", "  l1.each do |x|\n    l2.each do\
    \ |y|\n      return x if x == y\n    end\n  end\n  nil\nend", "  l1.each do |x|\n\
    \    l2.each do |y|\n      return x if x == y\n    end\n  end\nend", "  l1.each\
    \ do |item1|\n    l2.each do |item2|\n      return item1 if item1 == item2\n \
    \   end\n  end\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks\
    \ for your answer. Can you please explain what this line is doing?\n<|/ c |>\n\
    <| c |>\n`l1.each do |item1|` iterates over `l1` and assigns its value to `item1`.\
    \ `l2.each do |item2|` iterates over `l2` and assigns its value to `item2`. `return\
    \ item1 if item1 == item2` returns `item1` if the two values are equal, otherwise\
    \ it returns `nil`.\n<|/ c |>\n<| c |>\nThanks for your explanation. Can you please\
    \ explain what this line is doing?\n<|/ c |>\n<| c |>\n`l1.each do |item1|` iterates\
    \ over `l1` and assigns its value to `item1`. `l2.each do |item2|` iterates over\
    \ `l2` and assigns its value to `item2`. `return item1 if item1 == item2` returns\
    \ `item1` if the two values are equal, otherwise it returns `nil`.\n<|/ c |>\n\
    <| c |>\nThanks for your explanation. Can you please explain what this line is\
    \ doing?\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  l1.each do |i|\n    l2.each\
    \ do |j|\n      return i if i == j\n    end\n  end\nend", "  l1.each do |e|\n\
    \    l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend", " \
    \ l1.zip(l2).to_a.sort.uniq.map(&:first)\nend\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThis doesn't work for me. `common([1,2], [1,2])` returns `[1,2]` instead\
    \ of `[1]`.\n<|/ c |>\n<| c |>\nI tested it on ruby 2.4.0 and it works. Are you\
    \ sure you copied the code correctly?\n<|/ c |>\n<| c |>\nYes, I copied the code\
    \ exactly. I'm using ruby 2.4.0 on OSX.\n<|/ c |>\n<| c |>\nI tested it on ruby\
    \ 2.4.0 and it works. Are you sure you copied the code correctly?\n<|/ c |>\n\
    <| c |>\nI tested it on ruby 2.4.0 and it works. Are you sure you copied the code\
    \ correctly?\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l1.each do |i|\n\
    \    l2.each do |j|\n      return i if i == j\n    end\n  end\nend", "  l1.each\
    \ do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\n\
    end", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n\
    \  end\n  nil\nend", "  l1.each do |i|\n    l2.each do |j|\n      return i if\
    \ i == j\n    end\n  end\n  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n\
    \      return x if x == y\n    end\n  end\n  nil\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| c |>\nThis doesn't work if you have a list like `[1,2,3]` and `[1,2,4]`\n\
    <|/ c |>\n<| c |>\nIt works, because `common` returns `nil` if the two lists are\
    \ the same.\n<|/ c |>\n<| c |>\nI guess I misunderstood your question. My bad.\n\
    <|/ c |>\n<| c |>\nI guess I misunderstood your question. My bad.\n<|/ c |>\n\
    <| c |>\nI guess I misunderstood your question. My bad.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n\
    \    end\n  end\n  nil\nend", "  l1.each do |item|\n    l2.each do |item2|\n \
    \     return item if item == item2\n    end\n  end\nend", "  l1.each do |x|\n\
    \    l2.each do |y|\n      return x if x == y\n    end\n  end\nend", "  l1.each\
    \ do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n  nil\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis is not the most efficient solution.\
    \ `common` can be implemented as a single `each` loop. `common` can be implemented\
    \ as a single `map` loop. `common` can be implemented as a single `select` loop.\
    \ `common` can be implemented as a single `each_with_object` loop. `common` can\
    \ be implemented as a single `each_with_object` loop. `common` can be implemented\
    \ as a single `inject` loop. `common` can be implemented as a single `inject`\
    \ loop. `common` can be implemented as a single `reduce` loop. `common` can be\
    \ implemented as a single `reduce` loop. `common` can be implemented as a single\
    \ `reduce` loop. `common` can be implemented as a single `reduce` loop. `common`\
    \ can be implemented as a single `reduce` loop. `common` can be implemented as\
    \ a single `reduce` loop. `common` can be implemented as a single `reduce` loop.\
    \ `common` can be implemented as a single `reduce` loop. `common` can be implemented\
    \ as a single `reduce` loop. `common` can be implemented as a single `reduce`\
    \ loop. `common` can be implemented as a single `reduce` loop. `common` can be\
    \ implemented as a single `reduce` loop. `common` can be implemented as a single\
    \ `reduce` loop. `common` can be implemented as a single `reduce` loop. `common`\
    \ can be implemented as a single `reduce` loop. `common` can be implemented as\
    \ a single `reduce` loop. `common` can be implemented as a single `reduce` loop.\
    \ `common` can be implemented as a single `reduce` loop. `common` can be implemented\
    \ as a single `reduce` loop. `common` can be implemented as a single `reduce`\
    \ loop. `common` can be implemented as a single `reduce` loop. `common` can be\
    \ implemented as a single `reduce` loop. `common` can be implemented as a single\
    \ `reduce` loop. `common` can be implemented as a single `reduce` loop. `common`\
    \ can be implemented as a single `reduce` loop. `common` can be implemented as\
    \ a single `reduce` loop. `common` can be implemented as a single `reduce` loop.\
    \ `common` can be implemented as a single `reduce` loop. `common` can be implemented\
    \ as a single `reduce` loop. `common` can be implemented as a single `reduce`\
    \ loop. `common` can be implemented as a single `reduce` loop. ", "  l1.each do\
    \ |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n  return\
    \ nil\nend", "  l1.each do |i|\n    l2.each do |j|\n      return i if i == j\n\
    \    end\n  end\nend", "  l1.each do |item|\n    l2.each do |item2|\n      return\
    \ item if item == item2\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis is not the most efficient solution. `common` will have to\
    \ iterate over the entire second array for each element of the first array. Also,\
    \ `common` will have to iterate over the entire first array for each element of\
    \ the second array. Thus, this solution will require O(n^2) time complexity. Also,\
    \ `common` will have to iterate over the entire first array for each element of\
    \ the second array. Thus, this solution will require O(n^2) time complexity. Also,\
    \ `common` will have to iterate over the entire first array for each element of\
    \ the second array. Thus, this solution will require O(n^2) time complexity. Also,\
    \ `common` will have to iterate over the entire first array for each element of\
    \ the second array. Thus, this solution will require O(n^2) time complexity. Also,\
    \ `common` will have to iterate over the entire first array for each element of\
    \ the second array. Thus, this solution will require O(n^2) time complexity.\n\
    <|/ c |>\n<| c |>\nI agree with your comments. I edited my answer to include a\
    \ more efficient solution. Thanks for pointing that out.\n<|/ c |>\n<| c |>\n\
    I agree with your comments. I edited my answer to include a more efficient solution.\
    \ Thanks for pointing that out.\n<|/ c |>\n<| c |>\nI agree with your comments.\
    \ I edited my answer to include a more efficient solution. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nI agree with your comments. I edited my answer\
    \ to include a more efficient solution. Thanks for pointing that out.\n<|/ c |>\n\
    <| a tags=ruby,arrays |>\n<code>", "  l1.zip(l2).to_a.sort.uniq.map(&:first)\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this solution, but I wonder if\
    \ there is a way to do this without having to call `to_a` on the array. Maybe\
    \ `to_a` could be a method on `Enumerable`?\n<|/ c |>\n<| c |>\nI guess you could\
    \ do `l1.zip(l2).to_a.sort.uniq.map(&:first)` but that would require a lot of\
    \ memory and be slower.\n<|/ c |>\n<| c |>\nI guess you could do `l1.zip(l2).sort.uniq.map(&:first)`\
    \ but that would require a lot of memory and be slower.\n<|/ c |>\n<| c |>\n`to_a`\
    \ doesn't allocate any memory for you, it just creates a new array with the contents\
    \ of the two arrays. So it does exactly what you want.\n<|/ c |>\n<| c |>\nI guess\
    \ `to_a` does allocate memory for you, but it's just not as big as you think.\
    \ `to_a` allocates memory for the new array and copies the contents of the old\
    \ array into it. The old array is garbage collected after `to_a` returns. So `to_a`\
    \ allocates memory for the new array and copies the contents of the old array\
    \ into it. The old array is garbage collected after `to_a` returns. So `to_a`\
    \ allocates memory for the new array and copies the contents of the old array\
    \ into it. The old array is garbage collected after `to_a` returns. So `to_a`\
    \ allocates memory for the new array and copies the contents of the old array\
    \ into it. The old array is garbage collected after `to_a` returns. So `to_a`\
    \ allocates memory for the new array and copies the contents of the old array\
    \ into it. The old array is garbage collected after `to_a` returns. So `to_a`\
    \ allocates memory for the new array and copies the contents of the old array\
    \ into it. The old array is garbage collected after `to_a` returns. So `to_a`\
    \ allocates memory for the new array and copies the contents of the old array\
    \ into it. The old array is garbage collected after `to_a` returns. So `to_a`\
    \ allocates memory for the new array and copies the contents of the old array\
    \ into it. The old array is garbage collected after `to_a` returns. So `to_a` ",
  "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  nil\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  l1.each\
    \ do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\nend\n\
    </code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\nI believe this would\
    \ return duplicates, e.g. `[1,2,3].common [1,2,3]` would return `[1,2,3]`.\n<|/\
    \ c |>\n<| c |>\nYes, you are right. I fixed the code by adding `uniq` at the\
    \ end. Thanks.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails |>\n<code>", " \
    \ l1.each do |item|\n    l2.each do |item2|\n      return item if item == item2\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if\
    \ there are duplicates in the lists.\n<|/ c |>\n<| c |>\nYes, it does. I tested\
    \ it before posting it. What do you mean by \"doesn't work\"? It returns an empty\
    \ array if there are duplicates.\n<|/ c |>\n<| c |>\nIt returns an empty array\
    \ if there are duplicates in the lists.\n<|/ c |>\n<| c |>\nI tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty array if there are duplicates. I tested it before\
    \ posting it. It returns an empty ", "  l1.each do |e|\n    l2.each do |f|\n \
    \     return e if e == f\n    end\n  end\n  nil\nend", "  l1.each do |item|\n\
    \    l2.each do |item2|\n      return item if item == item2\n    end\n  end\n\
    end", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n\
    \  end\nend", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n\
    \    end\n  end\n  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return\
    \ x if x == y\n    end\n  end\n  nil\nend", "  l1.each do |x|\n    l2.each do\
    \ |y|\n      return x if x == y\n    end\n  end\nend", "  l1.each do |e|\n   \
    \ l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend", "  l1.each\
    \ do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\n\
    end", "  l1.zip(l2).to_a.sort.uniq\nend", "  l1.zip(l2).find { |e| e[0] == e[1]\
    \ }\nend", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n \
    \   end\n  end\n  nil\nend", "  l1.each do |i|\n    l2.each do |j|\n      return\
    \ i if i == j\n    end\n  end\nend", "  l1.each do |x|\n    l2.each do |y|\n \
    \     return x if x == y\n    end\n  end\nend", "  l1.each do |item|\n    l2.each\
    \ do |item2|\n      return item if item == item2\n    end\n  end\n  nil\nend",
  "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n\
    \  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n\
    \    end\n  end\nend", "  l1.each do |e|\n    l2.each do |f|\n      return e if\
    \ e == f\n    end\n  end\nend", "  l1.each do |x|\n    l2.each do |y|\n      return\
    \ x if x == y\n    end\n  end\nend", "  l1.each do |item|\n    l2.each do |item2|\n\
    \      return item if item == item2\n    end\n  end\nend", "  l1.each do |e|\n\
    \    l2.each do |f|\n      return e if e == f\n    end\n  end\nend", "  l1.each\
    \ do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n  nil\n\
    end", "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n\
    \  end\nend", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n\
    \    end\n  end\nend", "  l1.each do |e|\n    l2.each do |f|\n      return e if\
    \ e == f\n    end\n  end\n  nil\nend", "  l1.each do |e|\n    l2.each do |f|\n\
    \      return e if e == f\n    end\n  end\n  nil\nend", "  l1.each do |i|\n  \
    \  l2.each do |j|\n      return i if i == j\n    end\n  end\nend", "  l1.each\
    \ do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\nend",
  "  l1.each do |i|\n    l2.each do |j|\n      return i if i == j\n    end\n  end\n\
    \  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n\
    \    end\n  end\n  nil\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis\
    \ is not the fastest solution. Try it on `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,25",
  "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n\
    \  nil\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if you have\
    \ a list with duplicates.\n<|/ c |>\n<| c |>\n: It does work if you have a list\
    \ with duplicates. I tested it before posting it.\n<|/ c |>\n<| c |>\n: I tested\
    \ it before posting it. I tested it before posting it.\n<|/ c |>\n<| c |>\n: I\
    \ tested it before posting it. I tested it before posting it.\n<|/ c |>\n<| c\
    \ |>\n: I tested it before posting it. I tested it before posting it.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\n<code>", "  l1.each do |x|\n    l2.each do |y|\n\
    \      return x if x == y\n    end\n  end\nend", "  l1.each do |e|\n    l2.each\
    \ do |f|\n      return e if e == f\n    end\n  end\n  return nil\nend", "  l1.zip(l2).to_a.sort.uniq\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't work if\
    \ you have duplicates in either list.\n<|/ c |>\n<| c |>\nIt does work if you\
    \ don't have duplicates in either list. Try it out and see.\n<|/ c |>\n<| c |>\n\
    Yes, it does. Try it out and see.\n<|/ c |>\n<| c |>\nIt doesn't work if you have\
    \ duplicates in either list. Try it out and see.\n<|/ c |>\n<| c |>\nIt does work\
    \ if you don't have duplicates in either list. Try it out and see.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\n<code>", "  l1.each do |i|\n    l2.each do |j|\n\
    \      return i if i == j\n    end\n  end\n  nil\nend", "  l1.each do |e|\n  \
    \  l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nI like your answer but I think it could be\
    \ improved a little bit. `common` could be written as `l1.uniq.intersect(l2)`\n\
    <|/ c |>\n<| c |>\nYes, that would work as well. Thanks for the suggestion.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l1.each do |x|\n    l2.each do\
    \ |y|\n      return x if x == y\n    end\n  end\nend", "  l1.each do |item1|\n\
    \    l2.each do |item2|\n      return item1 if item1 == item2\n    end\n  end\n\
    \  nil\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. `common([1,2,3],\
    \ [1,2,3])` returns `nil`, not `[1,2,3]`.\n<|/ c |>\n<| c |>\n: Yes, I missed\
    \ that. Thanks for pointing that out. I've updated my answer.\n<|/ c |>\n<| c\
    \ |>\n: I've updated my answer with a more efficient solution.\n<|/ c |>\n<| c\
    \ |>\n: I've updated my answer with a more efficient solution.\n<|/ c |>\n<| c\
    \ |>\n: I've updated my answer with a more efficient solution.\n<|/ c |>\n<| a\
    \ dscore=1 |>\n<code>", "  l1.each do |e|\n    l2.each do |f|\n      return e\
    \ if e == f\n    end\n  end\n  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n\
    \      return x if x == y\n    end\n  end\n  nil\nend", "  l1.each do |e|\n  \
    \  l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend", "  l1.each\
    \ do |i|\n    l2.each do |j|\n      return i if i == j\n    end\n  end\nend",
  "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    end", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n\
    \  end\n  nil\nend", "  l1.each do |e|\n    l2.each do |f|\n      return e if\
    \ e == f\n    end\n  end\nend", "  l1.each do |x|\n    l2.each do |y|\n      return\
    \ x if x == y\n    end\n  end\nend", "  l1.each do |i|\n    l2.each do |j|\n \
    \     return i if i == j\n    end\n  end\nend", "  l1.each do |e|\n    l2.each\
    \ do |f|\n      return e if e == f\n    end\n  end\n  nil\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a tags=ruby,arrays |>\n<code>", "  l1.each do |item|\n    l2.each\
    \ do |item2|\n      return item if item == item2\n    end\n  end\nend", "  l1.each\
    \ do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\n\
    end", "  l1.each do |i|\n    l2.each do |j|\n      return i if i == j\n    end\n\
    \  end\nend", "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n\
    \    end\n  end\n  nil\nend\n</code>\n<|/ a |>\n<| c |>\nThis is not the fastest\
    \ solution. Try it with a list of 10000 elements and compare the execution time.\
    \ Also, your solution doesn't return the common elements. Try it with a list of\
    \ 10 elements and compare the execution time.\n<|/ c |>\n<| c |>\nI tested it\
    \ with a list of 10000 elements and it took about 0.2 seconds. I agree that it's\
    \ not the fastest solution, but it's fast enough for my needs.\n<|/ c |>\n<| c\
    \ |>\nI tested it with a list of 10 elements and it took about 0.2 seconds. I\
    \ agree that it's not the fastest solution, but it's fast enough for my needs.\n\
    <|/ c |>\n<| c |>\nI tested it with a list of 10000 elements and it took about\
    \ 0.2 seconds. I agree that it's not the fastest solution, but it's fast enough\
    \ for my needs.\n<|/ c |>\n<| c |>\nI tested it with a list of 10000 elements\
    \ and it took about 0.2 seconds. I agree that it's not the fastest solution, but\
    \ it's fast enough for my needs.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<code>", "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n\
    \    end\n  end\nend", "  l1.each do |i|\n    l2.each do |j|\n      return i if\
    \ i == j\n    end\n  end\nend", "  l1.each do |x|\n    l2.each do |y|\n      return\
    \ x if x == y\n    end\n  end\nend", "  l1.each do |item1|\n    l2.each do |item2|\n\
    \      return item1 if item1 == item2\n    end\n  end\n  nil\nend", "  l1.each\
    \ do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\nend",
  "  l1.zip(l2).to_a.sort.uniq.map(&:first)\nend", "  l1.each do |x|\n    l2.each\
    \ do |y|\n      return x if x == y\n    end\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI believe this would only return the first common element. OP wants\
    \ all common elements.\n<|/ c |>\n<| c |>\nYes, I missed that part. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l1.each do |e|\n \
    \   l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend", " \
    \ l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  nil\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\nThis is\
    \ not the most efficient solution. `Array#uniq` does a linear search for each\
    \ element in the second array. `Array#intersect` does a linear search for each\
    \ element in the first array. `Array#merge` does a linear search for each element\
    \ in the first array. `Array#difference` does a linear search for each element\
    \ in the first array. `Array#&` does a linear search for each element in the first\
    \ array. `Array#|` does a linear search for each element in the first array. `Array#|`\
    \ does a linear search for each element in the first array. `Array#|` does a linear\
    \ search for each element in the first array. `Array#|` does a linear search for\
    \ each element in the first array. `Array#|` does a linear search for each element\
    \ in the first array. `Array#|` does a linear search for each element in the first\
    \ array. `Array#|` does a linear search for each element in the first array. `Array#|`\
    \ does a linear search for each element in the first array. `Array#|` does a linear\
    \ search for each element in the first array. `Array#|` does a linear search for\
    \ each element in the first array. `Array#|` does a linear search for each element\
    \ in the first array. `Array#|` does a linear search for each element in the first\
    \ array. `Array#|` does a linear search for each element in the first array. `Array#|`\
    \ does a linear search for each element in the first array. `Array#|` does a linear\
    \ search for each element in the first array. `Array#|` does a linear search for\
    \ each element in the first array. `Array#|` does a linear search for each element\
    \ in the first array. `Array#|` does a linear search for each element in the first\
    \ array. `Array#|` does a linear search for each element in the first array. `Array#|`\
    \ does a linear search for each element in the first array. `Array#|` does a linear\
    \ search for each element in the first array. `Array#|` does a linear search for\
    \ each element in the first array. `Array#|` does a linear search for each element\
    \ in the first array. `Array#|` does a linear search for each element in the first\
    \ array. `Array#|` does a linear search for each element in the first array. `Array",
  "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n\
    \  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n\
    \    end\n  end\n  nil\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is not\
    \ the right answer. `common([1,2,3], [1,2,4])` returns `[1,2,3]` instead of `[2,3]`.\n\
    <|/ c |>\n<| c |>\nYes, I missed that. Thanks for pointing it out. I've updated\
    \ the answer.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l1.each do |item1|\n\
    \    l2.each do |item2|\n      return item1 if item1 == item2\n    end\n  end\n\
    end", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n\
    \  end\n  nil\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer.\
    \ I've tried it and it works but it's very slow for my purposes. I need a solution\
    \ that is faster than O(n^2)\n<|/ c |>\n<| c |>\nI updated my answer with a faster\
    \ solution. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your answer. I've tried\
    \ it and it works but it's very slow for my purposes. I need a solution that is\
    \ faster than O(n^2)\n<|/ c |>\n<| c |>\nI updated my answer with a faster solution.\
    \ Hope it helps.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l1.each do |x|\n\
    \    l2.each do |y|\n      return x if x == y\n    end\n  end\nend", "  l1.each\
    \ do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n  nil\n\
    end", "  l1.each do |i|\n    l2.each do |j|\n      return i if i == j\n    end\n\
    \  end\n  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return x if\
    \ x == y\n    end\n  end\n  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n\
    \      return x if x == y\n    end\n  end\n  nil\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks for your answer. Your code works but it is very slow for\
    \ my purpose. I need to find all common elements in two arrays of size 10^6 and\
    \ 10^7. My code takes about 1 minute to complete the task. Is there any way to\
    \ make it faster?\n<|/ c |>\n<| c |>\nI updated my answer to include a faster\
    \ solution that uses `Set`\n<|/ c |>\n<| c |>\nThanks for your answer. Your code\
    \ works but it is very slow for my purpose. I need to find all common elements\
    \ in two arrays of size 10^6 and 10^7. My code takes about 1 minute to complete\
    \ the task. Is there any way to make it faster?\n<|/ c |>\n<| c |>\nI updated\
    \ my answer to include a faster solution that uses `Set`\n<|/ c |>\n<| c |>\n\
    Thanks for your answer. Your code works but it is very slow for my purpose. I\
    \ need to find all common elements in two arrays of size 10^6 and 10^7. My code\
    \ takes about 1 minute to complete the task. Is there any way to make it faster?\n\
    <|/ c |>\n<| a |>\n<code>", "  l1.each do |i|\n    l2.each do |j|\n      return\
    \ i if i == j\n    end\n  end\n  nil\nend", "  l1.each do |x|\n    l2.each do\
    \ |y|\n      return x if x == y\n    end\n  end\nend", "  l1.each do |x|\n   \
    \ l2.each do |y|\n      return x if x == y\n    end\n  end\nend", "  l1.each do\
    \ |i|\n    l2.each do |j|\n      return i if i == j\n    end\n  end\n  return\
    \ nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n\
    \    end\n  end\n  nil\nend", "  l1.each do |item|\n    l2.each do |item2|\n \
    \     return item if item == item2\n    end\n  end\nend", "  l1.each do |i|\n\
    \    l2.each do |j|\n      return i if i == j\n    end\n  end\n  nil\nend", " \
    \ l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  nil\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays |>\n<code>", " \
    \ l1.zip(l2).to_a.sort.uniq.map(&:first)\nend", "  l1.each do |x|\n    l2.each\
    \ do |y|\n      return x if x == y\n    end\n  end\n  nil\nend", "  l1.each do\
    \ |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n  return\
    \ nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n\
    \    end\n  end\n  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return\
    \ x if x == y\n    end\n  end\n  return nil\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work if `l1` is longer than `l2`\n<|/ c |>\n<| c |>\n\
    Yes, it does. I tested it before posting it. The OP didn't specify what should\
    \ happen if they were different lengths.\n<|/ c |>\n<| c |>\nI guess I missed\
    \ the part where you said \"return nil if l1.length < l2.length\". My bad.\n<|/\
    \ c |>\n<| c |>\nThis doesn't work if l1 and l2 are different lengths.\n<|/ c\
    \ |>\n<| c |>\nYes, it does. I tested it before posting it. The OP didn't specify\
    \ what should happen if they were different lengths.\n<|/ c |>\n<| a |>\n<code>",
  "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  return nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return x if\
    \ x == y\n    end\n  end\nend", "  l1.each do |e|\n    l2.each do |f|\n      return\
    \ e if e == f\n    end\n  end\n  nil\nend", "  l1.each do |e|\n    l2.each do\
    \ |f|\n      return e if e == f\n    end\n  end\nend", "  l1.each do |e|\n   \
    \ l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work for `[1,2,3]` and `[1,2,4]`\n\
    <|/ c |>\n<| c |>\n: Yes, it does. I tested it before posting it. The OP didn't\
    \ specify what should happen if two arrays have the same elements. I assumed that\
    \ they should return an empty array. I'll clarify.\n<|/ c |>\n<| c |>\n: I added\
    \ a version that returns an empty array if two arrays have the same elements.\n\
    <|/ c |>\n<| c |>\n: I added a version that returns an empty array if two arrays\
    \ have the same elements.\n<|/ c |>\n<| c |>\n: I added a version that returns\
    \ an empty array if two arrays have the same elements.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n\
    \    end\n  end\n  nil\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work if you have a list with duplicates.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if you have a list with duplicates.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ you have a list with duplicates.\n<|/ c |>\n<| c |>\nThis doesn't work if you\
    \ have a list with duplicates.\n<|/ c |>\n<| c |>\nThis doesn't work if you have\
    \ a list with duplicates.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l1.each do\
    \ |i|\n    l2.each do |j|\n      return i if i == j\n    end\n  end\nend", " \
    \ l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  nil\nend", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n\
    \    end\n  end\n  nil\nend", "  l1.each do |e|\n    l2.each do |f|\n      return\
    \ e if e == f\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=0\
    \ |>\n<code>", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n\
    \    end\n  end\nend", "  l1.each do |e|\n    l2.each do |f|\n      return e if\
    \ e == f\n    end\n  end\n  nil\nend", "  l1.each do |i|\n    l2.each do |j|\n\
    \      return i if i == j\n    end\n  end\n  nil\nend", "  l1.each do |e|\n  \
    \  l2.each do |f|\n      return e if e == f\n    end\n  end\nend", "  l1.zip(l2).to_a.sort.uniq.map(&:first)\n\
    end", "  l1.zip(l2).to_a.sort.uniq.map { |e| e[0] }\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work if `l1` and `l2` have different lengths.\n<|/\
    \ c |>\n<| c |>\nI agree, this is why I added the comment \"Return sorted unique\
    \ common elements for two lists.\" to the answer.\n<|/ c |>\n<| c |>\nI added\
    \ a solution that does work if `l1` and `l2` have different lengths.\n<|/ c |>\n\
    <| c |>\nI added a solution that does work if `l1` and `l2` have different lengths.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l1.each do |e|\n    l2.each do\
    \ |f|\n      return e if e == f\n    end\n  end\n  nil\nend", "  l1.each do |i|\n\
    \    l2.each do |j|\n      return i if i == j\n    end\n  end\n  nil\nend", " \
    \ l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  nil\nend", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n\
    \    end\n  end\n  nil\nend", "  l1.each do |e|\n    l2.each do |f|\n      return\
    \ e if e == f\n    end\n  end\n  nil\nend", "  l1.each do |i|\n    l2.each do\
    \ |j|\n      return i if i == j\n    end\n  end\n  nil\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't answer the question. OP wants to know which elements\
    \ are common to both lists.\n<|/ c |>\n<| c |>\nI thought he wanted to know which\
    \ elements are common to both lists. I edited my answer to show how to do that.\n\
    <|/ c |>\n<| c |>\nThis doesn't answer the question. OP wants to know which elements\
    \ are common to both lists.\n<|/ c |>\n<| c |>\nI edited my answer to show how\
    \ to do that. Does it answer your question?\n<|/ c |>\n<| c |>\nNo, OP wants to\
    \ know which elements are common to both lists. Your code returns which elements\
    \ are common to one list. OP wants to know which elements are common to both lists.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l1.each do |x|\n    l2.each do\
    \ |y|\n      return x if x == y\n    end\n  end\n  nil\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. `common([1,2,3], [1,2,4])` returns `nil`, but\
    \ `common([1,2,3], [1,2,3])` returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nYes, I realized\
    \ that after I posted it. I fixed it now.\n<|/ c |>\n<| c |>\nThis doesn't work.\
    \ `common([1,2,3], [1,2,4])` returns `nil`, but `common([1,2,3], [1,2,3])` returns\
    \ `[1,2,3]`.\n<|/ c |>\n<| c |>\nYes, I realized that after I posted it. I fixed\
    \ it now.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l1.each do |i|\n  \
    \  l2.each do |j|\n      return i if i == j\n    end\n  end\n  nil\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there are duplicates in the lists.\n\
    <|/ c |>\n<| c |>\n: It does. `common([1,2],[1,2,3])` returns `[1,2,3]`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. But it also returns `[1,2,3]` for `common([1,2,3],[1,2])`.\n\
    <|/ c |>\n<| c |>\n: Yes, it does. But it also returns `[1,2,3]` for `common([1,2,3],[1,2])`.\n\
    <|/ c |>\n<| c |>\n: Yes, it does. But it also returns `[1,2,3]` for `common([1,2,3],[1,2])`.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  l1.each do |e|\n    l2.each do |f|\n \
    \     return e if e == f\n    end\n  end\n  nil\nend", "  l1.each do |i|\n   \
    \ l2.each do |j|\n      return i if i == j\n    end\n  end\nend", "  l1.zip(l2).to_a.sort.uniq.map(&:first)\n\
    end", "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n\
    \  end\n  nil\nend", "  l1.each do |e|\n    l2.each do |f|\n      return e if\
    \ e == f\n    end\n  end\n  nil\nend", "  l1.each do |i|\n    l2.each do |j|\n\
    \      return i if i == j\n    end\n  end\n  nil\nend", "  l1.each do |e|\n  \
    \  l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend", "  l1.each\
    \ do |i|\n    l2.each do |j|\n      return i if i == j\n    end\n  end\nend",
  "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  nil\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. `common([1,2,3],[1,2,4])`\
    \ returns `[1,2,3]`, not `[2,3]`.\n<|/ c |>\n<| c |>\nYes, I missed that case.\
    \ Thanks for pointing it out. I've updated my answer.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n\
    \    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=0 |>\n<code>",
  "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  nil\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like your solution, but I\
    \ believe it can be optimized a little more. For example, you can avoid the inner\
    \ loop if you use [Enumerable#each_cons](http://ruby-doc.org/core-2.3.0/Enumerable.html#method-i-each_cons)\
    \ to iterate over both lists simultaneously.\n<|/ c |>\n<| c |>\nI agree with\
    \ you, `each_cons` is definitely a better solution. I've updated my answer to\
    \ include it.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l1.each do |x|\n\
    \    l2.each do |y|\n      return x if x == y\n    end\n  end\n  nil\nend", " \
    \ l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  nil\nend", "  l1.each do |i|\n    l2.each do |j|\n      return i if i == j\n\
    \    end\n  end\nend", "  l1.each do |x|\n    l2.each do |y|\n      return x if\
    \ x == y\n    end\n  end\nend", "  l1.each do |i|\n    l2.each do |j|\n      return\
    \ i if i == j\n    end\n  end\nend", "  l1.each do |x|\n    l2.each do |y|\n \
    \     return x if x == y\n    end\n  end\n  nil\nend", "  l1.each do |x|\n   \
    \ l2.each do |y|\n      return x if x == y\n    end\n  end\nend", "  l1.each do\
    \ |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`common` could be written as `l1.zip(l2).map(&:first).uniq`\n\
    <|/ c |>\n<| c |>\n: Yes, but that would return an array of arrays, not an array\
    \ of strings. I thought the OP wanted an array of strings.\n<|/ c |>\n<| c |>\n\
    : I thought the OP wanted an array of strings. I thought the OP wanted an array\
    \ of strings. I thought the OP wanted an array of strings. I thought the OP wanted\
    \ an array of strings. I thought the OP wanted an array of strings. I thought\
    \ the OP wanted an array of strings. I thought the OP wanted an array of strings.\
    \ I thought the OP wanted an array of strings. I thought the OP wanted an array\
    \ of strings. I thought the OP wanted an array of strings. I thought the OP wanted\
    \ an array of strings. I thought the OP wanted an array of strings. I thought\
    \ the OP wanted an array of strings. I thought the OP wanted an array of strings.\
    \ I thought the OP wanted an array of strings. I thought the OP wanted an array\
    \ of strings. I thought the OP wanted an array of strings. I thought the OP wanted\
    \ an array of strings. I thought the OP wanted an array of strings. I thought\
    \ the OP wanted an array of strings. I thought the OP wanted an array of strings.\
    \ I thought the OP wanted an array of strings. I thought the OP wanted an array\
    \ of strings. I thought the OP wanted an array of strings. I thought the OP wanted\
    \ an array of strings. I thought the OP wanted an array of strings. I thought\
    \ the OP wanted an array of strings. I thought the OP wanted an array of strings.\
    \ I thought the OP wanted an array of strings. I thought the OP wanted an array\
    \ of strings. I thought the OP wanted an array of strings. I thought the OP wanted\
    \ an array of strings. I thought the OP wanted an array of strings. I thought\
    \ the OP wanted an array of strings. I thought the OP wanted an array of strings.\
    \ I thought the OP wanted an array of strings. I thought the OP wanted an array\
    \ of strings. I thought the OP wanted an array of strings. I thought the OP wanted\
    \ an array of strings. I thought the OP wanted an array of strings. I thought\
    \ the OP wanted an array of strings. I thought the OP wanted an array of strings.\
    \ I thought the OP wanted an array of strings. I thought the OP wanted an array\
    \ of strings. I thought the OP ", "  l1.each do |x|\n    l2.each do |y|\n    \
    \  return x if x == y\n    end\n  end\n  nil\nend", "  l1.each do |i|\n    l2.each\
    \ do |j|\n      return i if i == j\n    end\n  end\n  nil\nend", "  l1.each do\
    \ |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n  nil\nend",
  "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  nil\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\nThis doesn't\
    \ work if there are duplicates in the arrays. Try it with `[1,1,2,3]` and `[1,2,2,3]`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if there are duplicates in the arrays. Try\
    \ it with `[1,1,2,3]` and `[1,2,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicates in the arrays. Try it with `[1,1,2,3]` and `[1,2,2,3]`.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if there are duplicates in the arrays. Try\
    \ it with `[1,1,2,3]` and `[1,2,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are duplicates in the arrays. Try it with `[1,1,2,3]` and `[1,2,2,3]`.\n\
    <|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails |>\n<code>", "  l1.each do |x|\n\
    \    l2.each do |y|\n      return x if x == y\n    end\n  end\nend", "  l1.each\
    \ do |item1|\n    l2.each do |item2|\n      return item1 if item1 == item2\n \
    \   end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\n\
    This is not the fastest solution. `Array#uniq` does a linear search for each element\
    \ in the array and compares them to the other elements in the array. `Array#sort`\
    \ does a linear search for each element in the array and compares them to the\
    \ other elements in the array. `Array#uniq` does a linear search for each element\
    \ in the array and compares them to the other elements in the array. `Array#sort`\
    \ does a linear search for each element in the array and compares them to the\
    \ other elements in the array. `Array#uniq` does a linear search for each element\
    \ in the array and compares them to the other elements in the array. `Array#sort`\
    \ does a linear search for each element in the array and compares them to the\
    \ other elements in the array. `Array#uniq` does a linear search for each element\
    \ in the array and compares them to the other elements in the array. `Array#sort`\
    \ does a linear search for each element in the array and compares them to the\
    \ other elements in the array. `Array#uniq` does a linear search for each element\
    \ in the array and compares them to the other elements in the array. `Array#sort`\
    \ does a linear search for each element in the array and compares them to the\
    \ other elements in the array. `Array#uniq` does a linear search for each element\
    \ in the array and compares them to the other elements in the array. `Array#sort`\
    \ does a linear search for each element in the array and compares them to the\
    \ other elements in the array. `Array#uniq` does a linear search for each element\
    \ in the array and compares them to the other elements in the array. `Array#sort`\
    \ does a linear search for each element in the array and compares them to the\
    \ other elements in the array. `Array#uniq` does a linear search for each element\
    \ in the array and compares them to the other elements in the array. `Array#sort`\
    \ does a linear search for each element in the array and compares them to the\
    \ other elements in the array. `Array#uniq` does a linear search for each element\
    \ in the array and compares them to the other elements in the array. `Array#sort`\
    \ does a linear search for each element in the array and compares them to the\
    \ other elements in the array. `Array#uniq` does a linear search for each element\
    \ in the array and compares them to the other elements in the array. `Array#sort`\
    \ does a linear search for each element in the array and ", "  l1.each do |e|\n\
    \    l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend", " \
    \ l1.each do |x|\n    l2.each do |y|\n      return x if x == y\n    end\n  end\n\
    end", "  l1.each do |i|\n    l2.each do |j|\n      return i if i == j\n    end\n\
    \  end\n  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n      return x if\
    \ x == y\n    end\n  end\n  nil\nend", "  l1.each do |x|\n    l2.each do |y|\n\
    \      return x if x == y\n    end\n  end\nend", "  l1.each do |x|\n    l2.each\
    \ do |y|\n      return x if x == y\n    end\n  end\n  nil\nend", "  l1.each do\
    \ |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n  nil\nend",
  "  l1.each do |e|\n    l2.each do |f|\n      return e if e == f\n    end\n  end\n\
    \  nil\nend", "  l1.each do |item1|\n    l2.each do |item2|\n      return item1\
    \ if item1 == item2\n    end\n  end\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<| c |>\nThis doesn't work if there are duplicate items in the lists.\n\
    <|/ c |>\n<| c |>\nIt does work if there are duplicate items in the lists. I tested\
    \ it before posting.\n<|/ c |>\n<| c |>\nIt doesn't work if there are duplicate\
    \ items in the lists. I tested it before posting.\n<|/ c |>\n<| c |>\nIt does\
    \ work if there are duplicate items in the lists. I tested it before posting.\n\
    <|/ c |>\n<| c |>\nIt does work if there are duplicate items in the lists. I tested\
    \ it before posting.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails |>\n<code>",
  "  l1.each do |i|\n    l2.each do |j|\n      return i if i == j\n    end\n  end\n\
    \  nil\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
