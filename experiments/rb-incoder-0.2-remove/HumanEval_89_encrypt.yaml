name: HumanEval_89_encrypt
language: rb
prompt: "# Create a function encrypt that takes a string as an argument and\n# returns\
  \ a string encrypted with the alphabet being rotated. \n# The alphabet should be\
  \ rotated in a manner such that the letters \n# shift down by two multiplied to\
  \ two places.\n# For example:\ndef encrypt(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n\
  \    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"\
  ))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"\
  kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n\
  \    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"\
  lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
  , candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"\
  e\", candidate.call(\"a\"))\n  end\nend\n"
completions: ["  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.zip(alphabet).map\
    \ { |c,a| a.rotate! if c == :A }\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c.upcase) + alphabet.index(c.downcase) }\n\
    end", "  alphabet = %w{a b c d e f g h i j k l m n o p q r s t u v w x y z}\n\
    \  s.chars.map { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "    alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    rotated_alphabet = alphabet[alphabet.index(alphabet)\
    \ + 2] + alphabet[alphabet.index(alphabet) - 2]\n    rotated_s = \"\"\n    for\
    \ c in s\n        rotated_s += rotated_alphabet[alphabet.index(c)]\n    return\
    \ rotated_s\n</code>\n<|/ a tags=python,encryption,string |>\n<| c |>\nThis doesn't\
    \ work. `alphabet[alphabet.index(alphabet) + 2]` will give you `'Z'` when `alphabet`\
    \ is `\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"`.\n<|/ c |>\n<| c |>\nI didn't know that\
    \ `index` would return the first index that it finds. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| c |>\nThis doesn't work. `alphabet[alphabet.index(alphabet)\
    \ + 2]` will give you `'Z'` when `alphabet` is `\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    `.\n<|/ c |>\n<| c |>\nI didn't know that `index` would return the first index\
    \ that it finds. Thanks for pointing that out.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work. `alphabet[alphabet.index(alphabet) + 2]` will give you `'Z'` when `alphabet`\
    \ is `\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"`.\n<|/ c |>\n<| a dscore=2 |>\n<code>", " \
    \ alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  result = ''\n  s.split('').each do\
    \ |char|\n    result += alphabet.index(char).chr\n  end\n  result\nend", "  s.chars.map\
    \ { |c| c.ord % 26 + 2 }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.split(\"\").map { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }\nend", "  alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  result = ''\n  s.each_byte\
    \ do |c|\n    index = alphabet.index(c)\n    result << alphabet[(index+2)%alphabet.length]\n\
    \  end\n  result\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map\
    \ { |c| alphabet.index(c.upcase) + alphabet.index(c.downcase) }\nend", "  s.each_char\
    \ do |c|\n    alphabet = ROTATE_ALPHABET\n    alphabet[alphabet.index(c) + 1]\n\
    \  end\nend", "  alphabet = %w[a b c d e f g h i j k l m n o p q r s t u v w x\
    \ y z]\n  s.chars.map { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.chr)\
    \ + 2 }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map\
    \ { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  s.split('').map { |c|\
    \ c.ord % 26 + 2 }.join\nend", "  alphabet = %w{a b c d e f g h i j k l m n o\
    \ p q r s t u v w x y z}\n  s.chars.map { |c| alphabet.index(c.downcase) + 2 }.join\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for the answer! I appreciate\
    \ it. I was wondering if you could explain why you used `s.chars.map { |c| alphabet.index(c.downcase)\
    \ + 2 }.join` instead of `s.chars.map { |c| alphabet.index(c.upcase) + 2 }.join`?\
    \ I understand that `upcase` would return the uppercase version of the letter,\
    \ but why would you use `downcase` instead of `upcase`?\n<|/ c |>\n<| c |>\n`downcase`\
    \ would return the lowercase version of the letter. `upcase` would return the\
    \ uppercase version of the letter. `upcase` would return the uppercase version\
    \ of the letter. `downcase` would return the lowercase version of the letter.\n\
    <|/ c |>\n<| c |>\nAh, I see. Thanks again!\n<|/ c |>\n<| a |>\n<code>", "  s.chars.map\
    \ { |c| c.ord % 26 + 2 }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c.chr) + 2 }\nend\n</code>\n<|/ a tags=ruby,encryption,string\
    \ |>\n<| c |>\nThis doesn't seem to work. `encrypt(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )` returns `[\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"\
    J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"\
    U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]`\n<|/ c |>\n<| c |>\nI missed the fact\
    \ that he wanted the letters to shift down by two places. I edited my answer to\
    \ reflect this.\n<|/ c |>\n<| c |>\nI added a more efficient solution that doesn't\
    \ require the alphabet to be a string.\n<|/ c |>\n<| a |>\nHere's a solution using\
    \ each_char and each_cons:\n<code>", "  s.chars.map { |c| c.ord % 26 + 2 }.join\n\
    end", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\").map { |c|\
    \ alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet = %w{a b c d e f g\
    \ h i j k l m n o p q r s t u v w x y z}\n  s.chars.map { |c| alphabet[alphabet.index(c)\
    \ + 2] }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map\
    \ { |c| alphabet.index(c.upcase) }\nend", "  alphabet = %w[a b c d e f g h i j\
    \ k l m n o p q r s t u v w x y z]\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }.inject(:*)\nend", "  alphabet = %w[a b c d e f g h i j k l m n o p q r s t\
    \ u v w x y z]\n  s.chars.map { |c| alphabet.index(c.upcase) }.inject(:*)\nend",
  "  alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ + 2] + alphabet[alphabet.index(alphabet) - 2]\n  new_alphabet\nend", "  alphabet\
    \ = %w[a b c d e f g h i j k l m n o p q r s t u v w x y z]\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) + 2 }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  alphabet = alphabet[1..-1]\n  s.split(\"\").map { |c| alphabet.index(c) }.join\n\
    end", "  s.gsub!(/./) do |c|\n    alphabet.index(c) << 2\n    alphabet.index(c)\
    \ << 2\n  end\n  s\nend", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n   \
    \ rotated_alphabet = alphabet[alphabet.index(alphabet) + 2] + alphabet[alphabet.index(alphabet)\
    \ - 2]\n    rotated_s = \"\"\n    for c in s\n        rotated_s += rotated_alphabet[alphabet.index(c)]\n\
    \    return rotated_s\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer!\
    \ I understand your solution, but I cannot use any loops. I should use only recursion\
    \ and conditional statements.\n<|/ c |>\n<| c |>\nI added a recursive solution\
    \ to my answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c.upcase) }\nend", "  alphabet = %w{a b c\
    \ d e f g h i j k l m n o p q r s t u v w x y z}\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }.inject(:*)\nend", "  alphabet = %w{a b c d e f g h i j k l m n o p q r s t\
    \ u v w x y z}\n  s.chars.map { |c| alphabet.index(c.upcase) + 2 }.join\nend",
  "  alphabet = %w{a b c d e f g h i j k l m n o p q r s t u v w x y z}\n  s.split(\"\
    \").map { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c) }.rotate(2).join\nend\n</code>\n<|/ a\
    \ tags=ruby,encryption |>\n<| c |>\nI like your solution, but I believe that `s.chars.map\
    \ { |c| alphabet.index(c) }.rotate(2).join` can be simplified to `s.chars.rotate(2).join`\n\
    <|/ c |>\n<| c |>\nYes, it can be simplified, thanks. I wanted to keep it close\
    \ to the OP's original code as much as possible.\n<|/ c |>\n<| a tags=ruby,encryption\
    \ |>\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) + alphabet.index(c.downcase) }\nend", "  alphabet =\
    \ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\").map { |c| alphabet.index(c)\
    \ }.inject(:*)\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  rotated_alphabet\
    \ = alphabet.chars.rotate(2)\n  s.chars.zip(rotated_alphabet).map { |c,r| c +\
    \ r }.join(\"\")\nend", "  alphabet = %w{a b c d e f g h i j k l m n o p q r s\
    \ t u v w x y z}\n  s.chars.map { |c| alphabet.index(c.upcase) + 2 }.join\nend",
  "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.zip(alphabet).map { |c,a|\
    \ a.chars.zip(alphabet).map { |a,b| b.chars.zip(alphabet).map { |b,c| c+a }}.join\
    \ }.join \nend\n</code>\n<|/ a tags=ruby,encryption,string |>\n<| c |>\nI like\
    \ the idea of rotating the alphabet, but I don't think it works. Try encrypting\
    \ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" with your method. You'll get \"BCDGFIJKLNOPQRSTUVWXYZAB\"\
    . That's not what OP wants.\n<|/ c |>\n<| c |>\nI see what you mean. I'll have\
    \ to think about it some more.\n<|/ c |>\n<| c |>\nI see what you mean. I'll have\
    \ to think about it some more.\n<|/ c |>\n<| c |>\nI see what you mean. I'll have\
    \ to think about it some more.\n<|/ c |>\n<| c |>\nI see what you mean. I'll have\
    \ to think about it some more.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution\
    \ using recursion:\n<code>", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer. I am not allowed\
    \ to use any gems. I should only use basic ruby methods. I edited my question\
    \ to reflect this.\n<|/ c |>\n<| c |>\nI added a solution that doesn't use any\
    \ gems.\n<|/ c |>\n<| c |>\nThank you so much! I really appreciate it!\n<|/ c\
    \ |>\n<| a tags=ruby,encryption |>\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet\
    \ = %w[a b c d e f g h i j k l m n o p q r s t u v w x y z]\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  result = ''\n  s.each_char do |c|\n    result\
    \ += alphabet[(alphabet.index(c) + 2) % alphabet.length]\n  end\n  return result\n\
    end", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }.inject(:*)\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\
    \").map { |c| alphabet.index(c) }.join\nend", "  alphabet = %w{a b c d e f g h\
    \ i j k l m n o p q r s t u v w x y z}\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ + 2 }.join\nend", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2)\n\
    \  ", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  s.chars.map { |c| c.ord\
    \ % 26 + 2 }.join\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI appreciate your\
    \ help but I am not allowed to use any methods that would require a loop or a\
    \ recursive call. I am only allowed to use .chars, .ord and .join\n<|/ c |>\n\
    <| c |>\nI added a solution that uses only `.chars`, `.ord` and `.join`\n<|/ c\
    \ |>\n<| c |>\nThank you so much for your help. I really appreciate it. I was\
    \ able to get it working with your help.\n<|/ c |>\n<| a tags=ruby,encryption\
    \ |>\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) + alphabet.index(c.downcase) }\nend", "  alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\"\n  s.each_char do |c|\n    alphabet = alphabet[alphabet.index(c)\
    \ + 2]\n  end\n  alphabet\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n\
    \  new_alphabet = alphabet.chars.rotate(2).chars.rotate(2)", "  s.chars.map {\
    \ |c| c.ord % 26 + 2 }.join\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks\
    \ for your answer. Your code works fine but i want to know how can i use my code\
    \ with my code because i want to learn how can i use my code with my code.\n<|/\
    \ c |>\n<| c |>\nI added a section to my answer that shows how to use your code.\n\
    <|/ c |>\n<| c |>\nThanks for your answer but i want to know how can i use my\
    \ code with my code because i want to learn how can i use my code with my code.\n\
    <|/ c |>\n<| c |>\nI added a section to my answer that shows how to use your code.\n\
    <|/ c |>\n<| a tags=ruby,encryption,ruby-on-rails,ruby-on-rails-4 |>\n<code>",
  "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    rotated_alphabet = alphabet[alphabet.index(alphabet)\
    \ + 2] + alphabet[alphabet.index(alphabet) - 2]\n    return rotated_alphabet[alphabet.index(s)]\
    \ + rotated_alphabet[alphabet.index(s) - 1]\n</code>\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThis doesn't work. Try encrypting \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n<|/ c\
    \ |>\n<| c |>\nIt does work. Try it out yourself. It gives the correct output\
    \ for \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n<|/ c |>\n<| c |>\nIt doesn't work. Try\
    \ it out yourself. It gives the correct output for \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    .\n<|/ c |>\n<| c |>\nIt doesn't work. Try it out yourself. It gives the correct\
    \ output for \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n<|/ c |>\n<| c |>\nIt doesn't work.\
    \ Try it out yourself. It gives the correct output for \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    .\n<|/ c |>\n<| a tags=python,encryption |>\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c.chr) + 2 }.join(\"\")\nend", "  alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ + alphabet.index(c.downcase) }\nend", "  alphabet = %w[a b c d e f g h i j k\
    \ l m n o p q r s t u v w x y z]\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\").map\
    \ { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.split(\"\").map { |c| alphabet.index(c.upcase) }.join\nend", "  s.chars.map\
    \ do |c|\n    c + (c.ord - c.ord % 26)\n  end.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c.upcase) + alphabet.index(c.downcase) }\n\
    end", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  s.chars.map { |c| c.ord\
    \ % 26 }.join\nend", "  alphabet = %w{a b c d e f g h i j k l m n o p q r s t\
    \ u v w x y z}\n  s.chars.map { |c| alphabet.index(c.upcase) + 2 }.join\nend",
  "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  s.each_char do |c|\n    alphabet\
    \ = alphabet[alphabet.index(c) + 2]\n  end\n  alphabet\nend", "  alphabet = \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.gsub(/./, alphabet[alphabet.index(s.first)..alphabet.index(s.last)].to_s)\n\
    end", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  s.chars.map { |c| c.ord\
    \ % 26 + 2 }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map\
    \ { |c| alphabet.index(c.upcase) + alphabet.index(c.downcase) }\nend", "  alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\").map do |c|\n    alphabet.index(c.upcase)\
    \ + alphabet.index(c.downcase)\n  end.join\nend", "  s.chars.map { |c| c.ord %\
    \ 26 + 2 }.join\nend", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    rotated_alphabet\
    \ = \"NOPQRSTUVWXYZABCDEFGHIJKLM\"\n    rotated_s = \"\"\n    \n    # Iterate\
    \ through each character in the string\n    for c in s\n        # Shift the character\
    \ down by two and add it to the new string\n        rotated_s += rotated_alphabet[(alphabet.index(c)\
    \ + 2) % 26]\n    \n    # Return the new string\n    return rotated_s\n</code>\n\
    <|/ a |>\n<| c |>\nThank you so much! This was really helpful!\n<|/ c |>\n<| c\
    \ |>\nNo problem! If this answer was helpful, please consider marking it as accepted\
    \ (by clicking the check mark next to it). That way other people who visit this\
    \ page in the future will know that this is the correct answer and can see that\
    \ it is helpful. Thanks!\n<|/ c |>\n<| c |>\nI tried to upvote but I don't have\
    \ enough reputation to do so. Thanks again!\n<|/ c |>\n<| c |>\nNo problem! Glad\
    \ I could help!\n<|/ c |>\n<| a tags=python,encryption,string |>\n<code>", " \
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.gsub(/./) do |c|\n\
    \    alphabet.index(c.upcase) + alphabet.index(c.downcase) * 2\n  end\nend", " \
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  s.split(\"\").map { |c| alphabet.index(c)\
    \ }.inject(:*)\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  result =\
    \ ''\n  s.split('').each do |char|\n    result += alphabet.index(char).to_s <<\
    \ alphabet.index(char).to_s\n  end\n  result\nend", "  alphabet = %w[a b c d e\
    \ f g h i j k l m n o p q r s t u v w x y z]\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }.inject(:*)\nend", "  alphabet = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\
    , \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"\
    , \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphab", "  alphabet = %w{a b c d e f g h i j\
    \ k l m n o p q r s t u v w x y z}\n  s.split(//).map { |c| alphabet.index(c)\
    \ }.rotate(2).join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map\
    \ { |c| alphabet.index(c.upcase) }.rotate(2).join\nend", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  result = ''\n  s.split('').each do |c|\n    result += alphabet[(alphabet.index(c)\
    \ + 2) % alphabet.length]\n  end\n  result\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.split(\"\").map { |c| alphabet.index(c) }.rotate(2).join\nend", "  alphabet\
    \ = %w[a b c d e f g h i j k l m n o p q r s t u v w x y z]\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.split(\"\").map { |c| alphabet.index(c.upcase) + 2 }.join\nend", "  alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }.inject(:*)\nend", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  s.chars.map\
    \ { |c| c.ord % 26 }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\
    \  s.chars.map { |c| alphabet.index(c.upcase) }\nend\n</code>\n<|/ a tags=ruby,encryption,string\
    \ |>\n<| c |>\nThis doesn't work if the input string is \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    , because `alphabet` has 26 letters, but the 26 letters aren't consecutive.\n\
    <|/ c |>\n<| c |>\n: You're right. I didn't think about that. I'll fix it.\n<|/\
    \ c |>\n<| c |>\n: I fixed the bug, thanks for pointing it out. Now it works.\n\
    <|/ c |>\n<| c |>\n: I added a more efficient solution that doesn't require the\
    \ alphabet to be a string.\n<|/ c |>\n<| c |>\n: I added a more efficient solution\
    \ that doesn't require the alphabet to be a string.\n<|/ c |>\n<| a tags=ruby,encryption,string\
    \ |>\n<code>", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    rotated_alphabet\
    \ = alphabet[alphabet.index(alphabet) + 2] + alphabet[alphabet.index(alphabet)\
    \ - 2]\n    return rotated_alphabet[alphabet.index(s)] + rotated_alphabet[alphabet.index(s)\
    \ - 1]\n</code>\n<|/ a tags=python,encryption |>\n<| c |>\nThis doesn't seem to\
    \ work. `encrypt(\"abc\")` returns `'cba'` instead of `'abc'`.\n<|/ c |>\n<| c\
    \ |>\nThe code I posted is for encrypting strings. If you want it to be decrypting\
    \ strings, just change the `encrypt` function name to `decrypt`.\n<|/ c |>\n<|\
    \ c |>\nOh, I see what you mean. Yes, I do want it to be decrypting strings. I\
    \ didn't realize that `encrypt` was a built-in function. I thought it was a user-defined\
    \ function.\n<|/ c |>\n<| c |>\nI edited my answer to include a function that\
    \ will decrypt a string.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `encrypt(\"\
    abc\")` returns `'cba'` instead of `'abc'`.\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  alphabet = %w{a b c d e f g h i j k l m n o p q r s t u v w x y z}\n  s.chars.map\
    \ { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  s.each_char do |c|\n \
    \   alphabet = [*0..25]\n    alphabet.rotate(2).each do |i|\n      alphabet[i]\
    \ = alphabet[i].next\n    end\n    alphabet = alphabet.reverse\n    alphabet =\
    \ alphabet.to_a\n    alphabet = alphabet.join\n    alphabet = alphabet[alphabet.index(c.chr)]\n\
    \    alphabet = alphabet[0].chr + alphabet[1].chr + alphabet[2].chr + alphabet[3].chr\
    \ + alphabet[4].chr + alphabet[5].chr + alphabet[6].chr + alphabet[7].chr + alphabet[8].chr\
    \ + alphabet[9].chr + alphabet[10].chr + alphabet[11].chr + alphabet[12].chr +\
    \ alphabet[13].chr + alphabet[14].chr + alphabet[15].chr + alphabet[16].chr +\
    \ alphabet[17].chr + alphabet[18].chr + alphabet[19].chr + alphabet[20].chr +\
    \ alphabet[21].chr + alphabet[22].chr + alphabet[23].chr + alphabet[24].chr\n\
    \    alphabet = alphabet[0].chr + alphabet[1].chr + alphabet[2].chr + alphabet[3].chr\
    \ + alphabet[4].chr + alphabet[5].chr + alphabet[6].chr + alphabet[7].chr + alphabet[8].chr\
    \ + alphabet[9].chr + alphabet[10].chr + alphabet[11].chr + alphabet[12].chr +\
    \ alphabet[13].chr + alphabet[14].chr + alphabet[15].chr + alphabet[16].chr +\
    \ alphabet[17].chr + alphabet[18].chr + alphabet[19].chr + alphabet[20].chr +\
    \ alphabet[21].chr + alphabet[22].chr + alphabet[23].chr + alphabet[24].chr +\
    \ alphabet[25].chr\n    alphabet = alphabet[0].chr + alphabet[1].chr + alphabet[2].chr\
    \ + alphabet[3].chr + alphabet[4].chr + alphabet[5].chr + alphabet[6].chr + alphabet[7].chr\
    \ + alphabet[8].chr + alphabet[9].chr + alphabet[10].chr + alphabet[11].chr +\
    \ alphabet[12].chr + alphabet[13].chr + alphabet[14].chr + alphabet[15].chr +\
    \ alphabet[16].chr + alphabet[17].chr + alphabet[18].chr + alphabet[19].chr +\
    \ alphabet[20].chr + alphabet[21].chr + alphabet[22].chr + alphabet[23].chr +\
    \ alphabet[24].chr + alphabet[25].chr\n    alphabet = alphabet[0].chr + alphabet[1].chr\
    \ + alphabet[2].chr + alphabet[3].chr + alphabet", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c.upcase) + alphabet.index(c.downcase) }\n\
    end\n</code>\n<|/ a tags=ruby,encryption,string |>\n<| c |>\nThis doesn't seem\
    \ to work. `encrypt(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")` returns `[\"A\", \"B\", \"\
    C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"\
    N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"\
    Y\", \"Z\"]`\n<|/ c |>\n<| c |>\n: It works fine for me. Did you copy and paste\
    \ it correctly? It returns `[\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\",\
    \ \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\"\
    , \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]` when I run it on Ruby\
    \ 1.9.3p194.\n<|/ c |>\n<| c |>\n: I see what you mean. Yes, I did copy and paste\
    \ it correctly. I'm using Ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-darwin10.8.0].\
    \ I'll try it on 1.9.3p194 too.\n<|/ c |>\n<| c |>\n: I tested it on 1.9.3p194\
    \ and it works fine. I'll update my answer to show you the code I used.\n<|/ c\
    \ |>\n<| c |>\n: Thanks for your help. I appreciate it.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  result = ''\n \
    \ s.each_char do |c|\n    result += alphabet[(alphabet.index(c) + 2) % 26]\n \
    \ end\n  result\nend", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  s.split(\"\").map { |c| alphabet.index(c)\
    \ }.inject(:*)\nend\n</code>\n<|/ a tags=ruby,encryption |>\n<| c |>\nThanks so\
    \ much for this! I really appreciate it!\n<|/ c |>\n<| c |>\nNo problem! Glad\
    \ I could help.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.gsub(/./) do |c|\n    alphabet.index(c.upcase) + 2\n  end\nend", "  s.chars.map\
    \ { |c| c.ord % 26 + 2 }.join\nend", "    alphabet = [\"a\", \"b\", \"c\", \"\
    d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"\
    z\"]\n    rotated_alphabet = alphabet[alphabet.index(alphabet[0]) + 2:] + alphabet[:alphabet.index(alphabet[0])\
    \ + 2]\n    rotated_s = \"\"\n    for letter in s:\n        rotated_s += rotated_alphabet[alphabet.index(letter)]\n\
    \    return rotated_s\n    ", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend",
  "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.chr)\
    \ + 2 }\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) }.inject(:*)\nend", "  s.chars.map { |c| c.ord % 26\
    \ + 2 }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map\
    \ { |c| alphabet.index(c.upcase) }.rotate(2).join\nend\n</code>\n<|/ a tags=ruby,encryption,ruby-on-rails\
    \ |>\n<| c |>\nThanks for your answer. I'm getting this error when running your\
    \ code: `undefined method 'chars' for nil:NilClass`\n<|/ c |>\n<| c |>\nSorry,\
    \ I forgot to add `s` to the `map` call. I've edited my answer.\n<|/ c |>\n<|\
    \ c |>\nThanks for your answer. I'm getting this error when running your code:\
    \ `undefined method 'chars' for nil:NilClass`\n<|/ c |>\n<| c |>\nSorry, I forgot\
    \ to add `s` to the `map` call. I've edited my answer.\n<|/ c |>\n<| a tags=ruby,encryption,ruby-on-rails\
    \ |>\n<code>", "  alphabet = %w{a b c d e f g h i j k l m n o p q r s t u v w\
    \ x y z}\n  s.chars.map { |c| alphabet[alphabet.index(c) + 2] }.join\nend", " \
    \ alphabet = %w{a b c d e f g h i j k l m n o p q r s t u v w x y z}\n  s.split(//).map\
    \ { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c) }.rotate(2).join\nend", "  alphabet =\
    \ [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"\
    , \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"]\n  new_alphabet = alphabet[alphabet.index(alphabet[0])\
    \ + 2] + alphabet[alphabet.index(alphabet[1]) - 2] + alphabet[alphabet.index(alphabet[2])\
    \ - 2] + alphabet[alphabet.index(alphabet[3]) - 2] + alphabet[alphabet.index(alphabet[4])\
    \ - 2] + alphabet[alphabet.index(alphabet[5]) - 2] + alphabet[alphabet.index(alphabet[6])\
    \ - 2] + alphabet[alphabet.index(alphabet[7]) - 2] + alphabet[alphabet.index(alphabet[8])\
    \ - 2] + alphabet[alphabet.index(alphabet[9]) - 2] + alphabet[alphabet.index(alphabet[10])\
    \ - 2] + alphabet[alphabet.index(alphabet[11]) - 2] + alphabet[alphabet.index(alphabet[12])\
    \ - 2] + alphabet[alphabet.index(alphabet[13]) - 2] + alphabet[alphabet.index(alphabet[14])\
    \ - 2] + alphabet[alphabet.index(alphabet[15]) - 2] + alphabet[alphabet.index(alphabet[16])\
    \ - 2] + alphabet[alphabet.index(alphabet[17]) - 2] + alphabet[alphabet.index(alphabet[18])\
    \ - 2] + alphabet[alphabet.index(alphabet[19]) - 2] + alphabet[alphabet.index(alphabet[20])\
    \ - 2] + alphabet[alphabet.index(alphabet[21]) - 2] + alphabet[alphabet.index(alphabet[22])\
    \ - 2] + alphabet[alphabet.index(alphabet[23]) - 2] + alphabet[alphabet.index(alphabet[24])\
    \ - 2] + alphabet[alphabet.index(alphabet[25]) - 2] + alphabet[alphabet.index(alphabet[26])\
    \ - 2] + alphabet[alphabet.index(alphabet[27]) - 2] + alphabet[alphabet.index(alphabet[28])\
    \ - 2] + alphabet[alphabet.index(alphabet[29]) - 2] + alphabet[alphabet.index(alphabet[30])\
    \ - 2] + alphabet[alphabet.index(alphabet[31]) - 2] + alphabet[alphabet.index(alphabet[32])\
    \ - 2] + alphabet[alphabet.index(alphabet[33]) - 2] + alphabet[alphabet.index(alphabet[34])\
    \ - 2] + alphabet[alphabet.index(alphabet[35]) - 2] + alphabet[alphabet.index(alphabet[36])\
    \ - 2] + alphabet[alphabet.index(alphabet[37]) - 2] + alphabet[alphabet.index(alphabet[38])\
    \ - 2] + alphabet[alphabet.index(alphabet[39]) - 2] + alphabet[alphab", "  alphabet\
    \ = %w{a b c d e f g h i j k l m n o p q r s t u v w x y z}\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet = %w{a b c d e f g\
    \ h i j k l m n o p q r s t u v w x y z}\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }.inject(:*)\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\
    \").map { |c| alphabet.index(c) }.inject(0) { |sum, index| sum + index }\nend",
  "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  s.gsub(/./) do |c|\n    alphabet.index(c.chr).chr\
    \ + alphabet.index(c.chr).chr\n  end\nend", "  s.chars.map { |c| c.ord % 26 +\
    \ 2 }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\"\
    ).map { |c| alphabet.index(c) }.rotate(2).join\nend", "  s.chars.map { |c| c.ord\
    \ % 26 + 2 }.join\nend", "  s.each_char do |c|\n    alphabet = ('A'..'Z').to_a\n\
    \    alphabet = alphabet.rotate(2)\n    alphabet.each { |a| puts c.chr + a }\n\
    \  end\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) + alphabet.index(c.downcase) }.join(\"\")\nend", " \
    \ s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  alphabet = %w{a b c d e f\
    \ g h i j k l m n o p q r s t u v w x y z}\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ + 2 }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map\
    \ { |c| alphabet.index(c.chr) + 2 }.join\nend", "  s.chars.map do |c|\n    alphabet\
    \ = ('A'..'Z').to_a\n    alphabet.rotate(c.ord - 'A').first\n  end.join\nend",
  "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    rotated_alphabet = alphabet[alphabet.index(alphabet[0])\
    \ + 2:] + alphabet[:alphabet.index(alphabet[0]) + 2]\n    return rotated_alphabet[alphabet.index(s)]\
    \ + rotated_alphabet[alphabet.index(s) + 1]\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c.upcase) }\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nI added a comment to the question asking why this was downvoted.\n\
    <|/ c |>\n<| c |>\nI didn't downvote it, but I suspect that it's because you didn't\
    \ explain what was wrong with OP's code. Also, your solution doesn't actually\
    \ do what the OP asked for, which is to rotate the alphabet by two places.\n<|/\
    \ c |>\n<| c |>\nI added a comment to the question asking why this was downvoted.\n\
    <|/ c |>\n<| c |>\nI added a comment to the question asking why this was downvoted.\n\
    <|/ c |>\n<| c |>\nI added a comment to the question asking why this was downvoted.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    rotated_alphabet = alphabet[alphabet.index(alphabet)-1:0:-1]\n    return\
    \ rotated_alphabet[alphabet.index(s)] + rotated_alphabet[alphabet.index(s)+1]",
  "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  alphabet = [\"a\", \"b\", \"\
    c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\
    y\", \"z\"]\n  new_alphabet = alphabet.reverse\n  new_alphabet = alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten\n  new_alphabet = new_alphabet.zip(new_alphabet).map\
    \ {|pair| pair.reverse}.flatten", "  alphabet = [\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n \
    \ s.split(\"\").map { |c| alphabet.index(c) }.inject(:*)\nend", "  alphabet =\
    \ [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"\
    , \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\"\
    , \"w\", \"x\", \"y\", \"z\"]\n  new_alphabet = alphabet.reverse\n  new_alphabet\
    \ = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet = alphabet.unshift(new_alphabet.pop)\n  new_alphabet = alphabet.unshift(new_alphabet.pop)\n\
    \  new_alphabet", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend", "  alphabet\
    \ = %w[a b c d e f g h i j k l m n o p q r s t u v w x y z]\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) }.inject(:*)\nend", "  s.gsub(/./) do |c|\n    alphabet\
    \ = ('A'..'Z').to_a\n    alphabet.rotate(c.ord) - alphabet.rotate(c.ord + 2)\n\
    \  end\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\").map\
    \ do |char|\n    alphabet.index(char) + 2\n  end.join\nend", "  alphabet = \"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase) + alphabet.index(c.downcase)\
    \ }\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  result = ''\n  s.each_byte\
    \ do |c|\n    index = alphabet.index(c)\n    result << alphabet[(index+2)%alphabet.length]\n\
    \  end\n  result\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\
    \").map { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c) }.rotate(2).join\nend", "  s.chars.map\
    \ { |c| c.ord % 26 + 2 }.join\nend", "  alphabet = %w[a b c d e f g h i j k l\
    \ m n o p q r s t u v w x y z]\n  s.chars.map { |c| alphabet[alphabet.index(c)\
    \ + 2] }.join\nend", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend\n</code>\n\
    <|/ a tags=ruby,encryption,string |>\n<| c |>\nThis doesn't work. `encrypt(\"\
    hello\")` returns `\"hjl\"`, not `\"hlj\"`.\n<|/ c |>\n<| c |>\n: Thanks for pointing\
    \ that out. I've fixed it.\n<|/ c |>\n<| c |>\n: Thanks for pointing that out.\
    \ I've fixed it.\n<|/ c |>\n<| c |>\n: Thanks for pointing that out. I've fixed\
    \ it.\n<|/ c |>\n<| c |>\n: Thanks for pointing that out. I've fixed it.\n<|/\
    \ c |>\n<| a dscore=2 |>\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.split(\"\").map { |c| alphabet.index(c) }.rotate(2).join\nend", "  alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.zip(alphabet).map { |c| c.rotate(2)\
    \ }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.zip(alphabet).map\
    \ { |c,a| a.rotate((c-'A').abs) * 2 }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c.chr) + 2 }.join\nend", "  s.chars.map {\
    \ |c| c.ord % 26 + 2 }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  rotated_alphabet = alphabet.chars.rotate(2).chars.rotate(2)\n  s.chars.zip(rotated_alphabet).map\
    \ { |c,r| c + r }.join(\"\")\nend", "  alphabet = %w{a b c d e f g h i j k l m\
    \ n o p q r s t u v w x y z}\n  s.chars.map { |c| alphabet[alphabet.index(c) +\
    \ 2] }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map\
    \ { |c| alphabet.index(c.upcase) + 2 }\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  alphabet = alphabet[alphabet.size - 2..-1] + alphabet[0..alphabet.size - 2]\n\
    \  s.chars.map { |c| alphabet.index(c) }.join\nend\n</code>\n<|/ a tags=ruby,encryption,string\
    \ |>\n<| c |>\nI like your solution, but I believe it would be more efficient\
    \ to just do `alphabet = alphabet.chars.reverse.join` instead of `alphabet = alphabet[alphabet.size\
    \ - 2..-1] + alphabet[0..alphabet.size - 2]`.\n<|/ c |>\n<| c |>\nI agree, that's\
    \ a better solution. I'll edit my answer to include it.\n<|/ c |>\n<| c |>\nI\
    \ like your solution, but I believe it would be more efficient to just do `alphabet\
    \ = alphabet.chars.reverse.join` instead of `alphabet = alphabet[alphabet.size\
    \ - 2..-1] + alphabet[0..alphabet.size - 2]`.\n<|/ c |>\n<| c |>\nI like your\
    \ solution, but I believe it would be more efficient to just do `alphabet = alphabet.chars.reverse.join`\
    \ instead of `alphabet = alphabet[alphabet.size - 2..-1] + alphabet[0..alphabet.size\
    \ - 2]`.\n<|/ c |>\n<| c |>\nI like your solution, but I believe it would be more\
    \ efficient to just do `alphabet = alphabet.chars.reverse.join` instead of `alphabet\
    \ = alphabet[alphabet.size - 2..-1] + alphabet[0..alphabet.size - 2]`.\n<|/ c\
    \ |>\n<| a dscore=3 |>\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\
    \  s.gsub(/./) do |c|\n    alphabet.index(c.upcase) + alphabet.index(c.downcase)\
    \ * 2\n  end\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map\
    \ { |c| alphabet.index(c.upcase) }\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  new_alphabet = alphabet[alphabet.index(alphabet) + 2]\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ - 2]\n  new_alphabet = alphabet[alphabet.index(alphabet) + 1]\n  new_alphabet\
    \ = alphabet[alphabet.index(alphabet) - 1]\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ + 3]\n  new_alphabet = alphabet[alphabet.index(alphabet) - 3]\n  new_alphabet\
    \ = alphabet[alphabet.index(alphabet) + 4]\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ - 4]\n  new_alphabet = alphabet[alphabet.index(alphabet) + 5]\n  new_alphabet\
    \ = alphabet[alphabet.index(alphabet) - 5]\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ + 6]\n  new_alphabet = alphabet[alphabet.index(alphabet) - 6]\n  new_alphabet\
    \ = alphabet[alphabet.index(alphabet) + 7]\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ - 7]\n  new_alphabet = alphabet[alphabet.index(alphabet) + 8]\n  new_alphabet\
    \ = alphabet[alphabet.index(alphabet) - 8]\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ + 9]\n  new_alphabet = alphabet[alphabet.index(alphabet) - 9]\n  new_alphabet\
    \ = alphabet[alphabet.index(alphabet) + 10]\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ - 10]\n  new_alphabet = alphabet[alphabet.index(alphabet) + 11]\n  new_alphabet\
    \ = alphabet[alphabet.index(alphabet) - 11]\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ + 12]\n  new_alphabet = alphabet[alphabet.index(alphabet) - 12]\n  new_alphabet\
    \ = alphabet[alphabet.index(alphabet) + 13]\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ - 13]\n  new_alphabet = alphabet[alphabet.index(alphabet) + 14]\n  new_alphabet\
    \ = alphabet[alphabet.index(alphabet) - 14]\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ + 15]\n  new_alphabet = alphabet[alphabet.index(alphabet) - 15]\n  new_alphabet\
    \ = alphabet[alphabet.index(alphabet) + 16]\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ - 16]\n  new_alphabet = alphabet[alphabet.index(alphabet) + 17]\n  new_alphabet\
    \ = alphabet[alphabet.index(alphabet) - 17]\n  new_alphabet = alphabet[alphabet.index(alphabet)\
    \ + 18]\n  new_alphabet = alphabet[alphabet.index(alphabet) - 18]\n  new_alphabet\
    \ = alphabet[alphabet.index(alphabet", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  encrypted_string = \"\"\n  s.each_char do |char|\n    encrypted_string <<\
    \ alphabet[alphabet.index(char) + 2]\n  end\n  encrypted_string\nend", "  alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }.rotate(2).join\nend\n</code>\n<|/ a tags=ruby,encryption,ruby-on-rails |>\n\
    <| c |>\nThanks for your answer. Can you please explain me the code you wrote\
    \ above? I mean the part where you wrote alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c.upcase) }.rotate(2).join\nend\n<|/ c |>\n\
    <| c |>\nThe code above is just an example of how you can rotate the alphabet.\
    \ `alphabet` is just a string that contains the letters of the alphabet. `s.chars`\
    \ returns an array of characters in the string. `s.chars.map { |c| alphabet.index(c.upcase)\
    \ }` returns an array of integers where the integers are the indexes of the letters\
    \ in the alphabet. `alphabet.index(c.upcase)` returns the index of the letter\
    \ in the alphabet. `alphabet.rotate(2)` rotates the alphabet by 2 places. `alphabet.rotate(2).join`\
    \ returns the rotated alphabet as a string.\n<|/ c |>\n<| c |>\nThanks again.\
    \ Can you please explain me the code you wrote above? I mean the part where you\
    \ wrote alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }.rotate(2).join\nend\n<|/ c |>\n<| c |>\nI added some comments to the code\
    \ above. Hope that helps.\n<|/ c |>\n<| c |>\nThanks for your explanation. Can\
    \ you please explain me the code you wrote above? I mean the part where you wrote\
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }.rotate(2).join\nend\n<|/ c |>\n<| a |>\n<code>", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    rotated_alphabet = alphabet[alphabet.index(alphabet) + 2] + alphabet[alphabet.index(alphabet)\
    \ - 2]\n    return rotated_alphabet[alphabet.index(s)] + rotated_alphabet[alphabet.index(s)+1]\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. `alphabet[alphabet.index(alphabet)\
    \ + 2]` will give you `'Z'` instead of `'A'`.\n<|/ c |>\n<| c |>\nYes, I noticed\
    \ that and fixed it now. Thanks.\n<|/ c |>\n<| a tags=python,encryption,python-3.x\
    \ |>\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\").map\
    \ { |c| alphabet.index(c) }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.gsub(/./) do |c|\n    alphabet.index(c.chr) + 2\n  end\nend", "  alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\").map {\
    \ |c| alphabet.index(c) }.join\nend", "  s.chars.map do |c|\n    alphabet.index(c.chr)\
    \ + 2\n  end.join\nend", "  alphabet = %w{a b c d e f g h i j k l m n o p q r\
    \ s t u v w x y z}\n  s.split(//).map { |c| alphabet.index(c.upcase) }.inject(:*)\n\
    end", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    rotated_alphabet = alphabet[alphabet.index(alphabet)-2:]+alphabet[:alphabet.index(alphabet)-2]\n\
    \    rotated_s = \"\"\n    for c in s:\n        rotated_s += rotated_alphabet[alphabet.index(c)+2]\n\
    \    return rotated_s\n</code>\n<|/ a tags=python,encryption |>\n<| c |>\nThis\
    \ doesn't work. Try encrypting \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" with your code.\n\
    <|/ c |>\n<| c |>\nIt does work. Try it out. `encrypt(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )` returns `'QEDCBA'`.\n<|/ c |>\n<| c |>\nYes, it does. Try it out yourself.\
    \ `encrypt(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")` returns `'QEDCBA'`.\n<|/ c |>\n<|\
    \ c |>\nYes, it does. Try it out yourself. `encrypt(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    )` returns `'QEDCBA'`.\n<|/ c |>\n<| c |>\nYes, it does. Try it out yourself.\
    \ `encrypt(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")` returns `'QEDCBA'`.\n<|/ c |>\n<|\
    \ a dscore=2 |>\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map\
    \ { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  s.chars.map { |c| alphabet.index(c.chr) + 2 }\nend\n</code>\n<|/ a tags=ruby,encryption,string,arrays\
    \ |>\n<| c |>\nThanks for the help! I appreciate it.\n<|/ c |>\n<| c |>\nI added\
    \ a solution that uses `rotate` instead of `map`.\n<|/ c |>\n<| c |>\nThanks for\
    \ the help! I appreciate it.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    rotated_alphabet = alphabet[alphabet.index(alphabet)-alphabet.index(alphabet)%26:alphabet.index(alphabet)+alphabet.index(alphabet)%26]\n\
    \    return rotated_alphabet[alphabet.index(s)+alphabet.index(s)%26]\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work. `alphabet[alphabet.index(alphabet)-alphabet.index(alphabet)%26:alphabet.index(alphabet)+alphabet.index(alphabet)%26]`\
    \ returns `alphabet[26:27]` which is not in the alphabet and so `rotated_alphabet[alphabet.index(s)+alphabet.index(s)%26]`\
    \ returns `rotated_alphabet[27]` which is not in the rotated alphabet and so `rotated_alphabet[alphabet.index(s)+alphabet.index(s)%26]`\
    \ returns `rotated_alphabet[27]` which is not in the rotated alphabet and so `rotated_alphabet[alphabet.index(s)+alphabet.index(s)%26]`\
    \ returns `rotated_alphabet[27]` which is not in the rotated alphabet and so `rotated_alphabet[alphabet.index(s)+alphabet.index(s)%26]`\
    \ returns `rotated_alphabet[27]` which is not in the rotated alphabet and so `rotated_alphabet[alphabet.index(s)+alphabet.index(s)%26]`\
    \ returns `rotated_alphabet[27]` which is not in the rotated alphabet and so `rotated_alphabet[alphabet.index(s)+alphabet.index(s)%26]`\
    \ returns `rotated_alphabet[27]` which is not in the rotated alphabet and so `rotated_alphabet[alphabet.index(s)+alphabet.index(s)%26]`\
    \ returns `rotated_alphabet[27]` which is not in the rotated alphabet and so `rotated_alphabet[alphabet.index(s)+alphabet.index(s)%26]`\
    \ returns `rotated_alphabet[27]` which is not in the rotated alphabet and so `rotated_alphabet[alphabet.index(s)+alphabet.index(s)%26]`\
    \ returns `rotated_alphabet[27]` which is not in the rotated alphabet and so `rotated_alphabet[alphabet.index(s)+alphabet.index(s)%26]`\
    \ returns `rotated_alphabet[27]` which is not in the rotated alphabet and so `rotated_alphabet[alphabet.index(s)+alphabet.index(s)%26]`\
    \ returns ", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) + alphabet.index(c.downcase) }\nend", "  alphabet =\
    \ \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\").map {\
    \ |c| alphabet.index(c) }.inject(0) { |sum, index| sum + index }\nend", "  alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ + alphabet.index(c.downcase) }.join(\"\")\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.split(\"\").map { |c| alphabet.index(c) }.rotate(2).join\nend", "  alphabet\
    \ = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"\
    k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"\
    v\", \"w\", \"x\", \"y\", \"z\"]\n  alphabet = alphabet.rotate(2)\n  alphabet\
    \ = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n\
    \  alphabet = alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet =\
    \ alphabet.reverse\n  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n\
    \  alphabet = alphabet.rotate(2)\n  alphabet = alphabet.reverse\n  alphabet =\
    \ alphab", "  alphabet = %w{a b c d e f g h i j k l m n o p q r s t u v w x y\
    \ z}\n  s.chars.map { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet\
    \ = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.split(\"\").map do |c|\n    alphabet.index(c.upcase)\
    \ + 2\n  end.join\nend", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend", " \
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map { |c| alphabet.index(c.upcase)\
    \ }\nend", "  s.chars.map { |c| c.ord % 26 + 2 }.join\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI appreciate your help and I understand that my question was a\
    \ bit vague. Thank you for taking the time to answer my question. I will try this\
    \ out and see if it works.\n<|/ c |>\n<| c |>\nI added some more information to\
    \ my original question. I am still having trouble with this. I appreciate your\
    \ help and I understand that my question was a bit vague. Thank you for taking\
    \ the time to answer my question. I will try this out and see if it works.\n<|/\
    \ c |>\n<| c |>\nI added some more information to my original question. I am still\
    \ having trouble with this. I appreciate your help and I understand that my question\
    \ was a bit vague. Thank you for taking the time to answer my question. I will\
    \ try this out and see if it works.\n<|/ c |>\n<| c |>\nI added some more information\
    \ to my original question. I am still having trouble with this. I appreciate your\
    \ help and I understand that my question was a bit vague. Thank you for taking\
    \ the time to answer my question. I will try this out and see if it works.\n<|/\
    \ c |>\n<| c |>\nI added some more information to my original question. I am still\
    \ having trouble with this. I appreciate your help and I understand that my question\
    \ was a bit vague. Thank you for taking the time to answer my question. I will\
    \ try this out and see if it works.\n<|/ c |>\n<| a tags=ruby,encryption,ruby-on-rails\
    \ |>\nI believe this is what you are looking for:\n<code>", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.split(\"\").map do |c|\n    alphabet.index(c.upcase) + alphabet.index(c.downcase)\n\
    \  end.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map\
    \ { |c| alphabet.index(c.upcase) }\nend", "  s.each_char do |c|\n    alphabet\
    \ = ('A'..'Z').to_a\n    alphabet.rotate!\n    alphabet.each { |a| puts c if a.eql?(c)}\n\
    \  end\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) }\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work\
    \ for me. `encrypt(\"hello\")` returns `[5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,\
    \ 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, ", "  alphabet\
    \ = %w[a b c d e f g h i j k l m n o p q r s t u v w x y z]\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) }.inject(:*)\nend", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    rotated_alphabet = alphabet[alphabet.index(alphabet)-2:]+alphabet[:alphabet.index(alphabet)-2]\n\
    \    return rotated_alphabet[alphabet.index(s)+2]\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThanks so much for this! I really appreciate it. I will try this out\
    \ and let you know how it goes.\n<|/ c |>\n<| c |>\nI got this error when I tried\
    \ running your code: TypeError: string indices must be integers, not str\n<|/\
    \ c |>\n<| c |>\nI fixed the error by changing \"alphabet\" to \"alphabet = string.ascii_uppercase\"\
    \n<|/ c |>\n<| c |>\nI ran the code and it works perfectly. Thanks so much!\n\
    <|/ c |>\n<| c |>\nGlad I could help! If this answer was helpful, please consider\
    \ marking it as accepted by clicking the check mark next to it. This helps other\
    \ people who may have a similar problem in the future know that the answer worked\
    \ for you.\n<|/ c |>\n<| a tags=python,encryption,python-3.x |>\n<code>", "  alphabet\
    \ = %w[a b c d e f g h i j k l m n o p q r s t u v w x y z]\n  s.split(\"\").map\
    \ { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet = %w{a b c d\
    \ e f g h i j k l m n o p q r s t u v w x y z}\n  s.chars.map { |c| alphabet.index(c.downcase)\
    \ }.inject(:*)\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  s.chars.map\
    \ { |c| alphabet.index(c.upcase) }.rotate(2).join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c) }.rotate(2).join\nend", "  alphabet =\
    \ %w{a b c d e f g h i j k l m n o p q r s t u v w x y z}\n  s.chars.map { |c|\
    \ alphabet[alphabet.index(c) + 2] }.join\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.split(\"\").map do |c|\n    alphabet.index(c.upcase) + alphabet.index(c.downcase)\
    \ * 2\n  end.join\nend", "  alphabet = %w{a b c d e f g h i j k l m n o p q r\
    \ s t u v w x y z}\n  s.chars.map { |c| alphabet.index(c.upcase) }.rotate(2).join\n\
    end", "  alphabet = %w[a b c d e f g h i j k l m n o p q r s t u v w x y z]\n\
    \  s.chars.map { |c| alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet\
    \ = %w{a b c d e f g h i j k l m n o p q r s t u v w x y z}\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) }.inject(:*)\nend", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  s.chars.map { |c| alphabet.index(c.upcase) + alphabet.index(c.downcase) }\n\
    end", "  alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  result = ''\n  s.split(\"\
    \").each do |char|\n    index = alphabet.index(char)\n    result += alphabet[(index+2)%26]\n\
    \  end\n  return result\nend", "  alphabet = %w{a b c d e f g h i j k l m n o\
    \ p q r s t u v w x y z}\n  s.chars.map { |c| alphabet.index(c.upcase) + 2 }.join\n\
    end", "  alphabet = %w{a b c d e f g h i j k l m n o p q r s t u v w x y z}\n\
    \  s.chars.map { |c| alphabet.index(c.upcase) + 2 }.join\nend", "  alphabet =\
    \ %w{a b c d e f g h i j k l m n o p q r s t u v w x y z}\n  s.chars.map { |c|\
    \ alphabet.index(c.upcase) + 2 }.join\nend", "    alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n    rotated_alphabet = alphabet[alphabet.index(alphabet) + 2] + alphabet[alphabet.index(alphabet)\
    \ + 1] + alphabet[alphabet.index(alphabet) - 2] + alphabet[alphabet.index(alphabet)\
    \ - 1]\n    return rotated_alphabet[alphabet.index(s)] + rotated_alphabet[alphabet.index(s)\
    \ - 1] + rotated_alphabet[alphabet.index(s) - 2] + rotated_alphabet[alphabet.index(s)\
    \ - 3]\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  s.split(\"\").map\
    \ { |c| alphabet.index(c) }.inject(:*)\nend", "  s.chars.map { |c| c.ord % 26\
    \ + 2 }.join\nend", "  alphabet = %w[a b c d e f g h i j k l m n o p q r s t u\
    \ v w x y z]\n  s.chars.map { |c| alphabet.index(c.upcase) }.inject(:*)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
