name: HumanEval_40_triples_sum_to_zero
language: rb
prompt: "# triples_sum_to_zero takes a list of integers as an input.\n# it returns\
  \ True if there are three distinct elements in the list that\n# sum to zero, and\
  \ False otherwise.\ndef triples_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_triples_sum_to_zero\n\
  \    candidate = method(:triples_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, 5, -1]))\n    assert_equal(true,\
  \ candidate.call([1, 3, -2, 1]))\n    assert_equal(false, candidate.call([1, 2,\
  \ 3, 7]))\n    assert_equal(false, candidate.call([1, 2, 5, 7]))\n    assert_equal(true,\
  \ candidate.call([2, 4, -5, 3, 9, 7]))\n    assert_equal(false, candidate.call([1]))\n\
  \    assert_equal(false, candidate.call([1, 3, 5, -100]))\n    assert_equal(false,\
  \ candidate.call([100, 3, 5, -100]))\n  end\nend\n"
completions: ["  l.sort!\n  return l.inject(true) { |sum, el| sum && el == 0 }\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis solution will fail for `[1,1,1]`\n<|/\
    \ c |>\n<| c |>\n: I believe that `[1,1,1]` should return `false` because there\
    \ are no three distinct elements that sum to zero.\n<|/ c |>\n<| c |>\nYes, but\
    \ `[1,1,1]` returns `true` because there are three distinct elements that sum\
    \ to zero.\n<|/ c |>\n<| c |>\n: Yes, but `[1,1,1]` returns `false` because there\
    \ are no three distinct elements that sum to zero.\n<|/ c |>\n<| c |>\n: I believe\
    \ that `[1,1,1]` should return `false` because there are no three distinct elements\
    \ that sum to zero.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.sort!\n  for i in 0..(l.length-1)\n    for j in (i+1)..l.length\n\
    \      if l[i] + l[j] == 0\n        return true\n      end\n    end\n  end\n \
    \ return false\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n\
    \  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend",
  "  l.sort\n  l.each_with_index do |n,i|\n    next if i == 0\n    l.slice!(0,i+1)\n\
    \    return false if l.inject(:+) == 0\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are three or more zeroes in the array.\n\
    <|/ c |>\n<| c |>\nIt does work if there are three or more zeroes in the array.\
    \ Try it out with [1,1,1,0,0,0]\n<|/ c |>\n<| c |>\nYes, it works. But it also\
    \ works with [1,1,1,0,0,0]\n<|/ c |>\n<| c |>\nIt works with [1,1,1,0,0,0] because\
    \ there are three zeroes in the array. Try it out with [1,1,1,0,0,0]\n<|/ c |>\n\
    <| c |>\nYes, it works with [1,1,1,0,0,0] because there are three zeroes in the\
    \ array. Try it out with [1,1,1,0,0,0]\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>",
  "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n  l.length\
    \ == 3\nend", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n     \
    \   return true if x + y + z == 0\n      end\n    end\n  end\n  return false\n\
    end", "  l.sort!\n  return l.inject(true) do |sum, el|\n    el == 0 || sum &&\
    \ el + el == sum\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like your\
    \ solution, but I wonder how it compares to other solutions posted so far.\n<|/\
    \ c |>\n<| c |>\nI like your solution as well, but I wonder how it compares to\
    \ other solutions posted so far.\n<|/ c |>\n<| c |>\nI like your solution as well,\
    \ but I wonder how it compares to other solutions posted so far.\n<|/ c |>\n<|\
    \ c |>\nI like your solution as well, but I wonder how it compares to other solutions\
    \ posted so far.\n<|/ c |>\n<| c |>\nI like your solution as well, but I wonder\
    \ how it compares to other solutions posted so far.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>", "  l.sort\n  l.each_with_index do |e, i|\n    next if i == 0\n    prev\
    \ = l[i-1]\n    next if prev == e\n    next if e + prev == prev\n    next if e\
    \ + prev + 1 == prev\n    false\n  end\n  true\nend\n</code>\n<|/ a |>\n<| c |>\n\
    I like your solution, but I believe it can be optimized a little more. For example,\
    \ `l[i-1]` can be replaced with `l[i - 1]`, since `i` will always be less than\
    \ `l.length`. Also, you don't need to sort the list before iterating over it.\
    \ And finally, you can just use `each_cons(3)` instead of `each_with_index`.\n\
    <|/ c |>\n<| c |>\nThanks for the suggestions. I agree that `each_cons` would\
    \ be more efficient. I'll update the answer.\n<|/ c |>\n<| c |>\nI like the idea\
    \ of using each_cons(3). Thanks!\n<|/ c |>\n<| a |>\n<code>", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.uniq!\n  l.sort!\n  l.each_cons(3) do |a,b,c|\n \
    \   return true if a == 0 && b == 0 && c == 0 \n  end\n  false\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if there are more than three\
    \ elements that sum to zero.\n<|/ c |>\n<| c |>\n: I didn't say it didn't. I said\
    \ it didn't work if there are more than three elements that sum to zero.\n<|/\
    \ c |>\n<| c |>\n: I didn't say it didn't. I said it didn't work if there are\
    \ more than three elements that sum to zero.\n<|/ c |>\n<| c |>\n: I didn't say\
    \ it didn't. I said it didn't work if there are more than three elements that\
    \ sum to zero.\n<|/ c |>\n<| c |>\n: I didn't say it didn't. I said it didn't\
    \ work if there are more than three elements that sum to zero.\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n\
    \  l.uniq!\n  l.length == 3\nend", "  l.uniq!\n  l.sort!\n  l.each_cons(3).all?\
    \ { |a,b,c| a+b+c == 0 }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis\
    \ doesn't work. Try `[1,1,2,3,5,8,13]`\n<|/ c |>\n<| c |>\n: I see what you mean.\
    \ Fixed it.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder if there is\
    \ a way to do it without using each_cons. I guess it would be more efficient to\
    \ sort the array first and then use each_cons.\n<|/ c |>\n<| c |>\n: Yes, that\
    \ would be more efficient. I'll add that to my answer.\n<|/ c |>\n<| c |>\n: I\
    \ added a version that doesn't use `each_cons`.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n\
    \  return l.inject(true) do |sum,x|\n    sum and (sum + x == 0)\n  end\nend",
  "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n        if i + j + k ==\
    \ 0 \n          return true\n        end\n      end\n    end\n  end\n  return\
    \ false\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.sort\n  l.each_with_index do |n,i|\n    next if i\
    \ == 0\n    l.slice!(i..i+2)\n    return false if l.uniq.size == 3\n  end\n  true\n\
    end", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort\n  l.each_cons(3)\
    \ do |triple|\n    return false if triple.inject(0) {|sum, e| sum + e != 0}\n\
    \  end\n  true\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like\
    \ your solution, however it only works for integers. I need a solution that works\
    \ for any type of number. For example, `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,24",
  "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  return l.inject(true)\
    \ do |sum, el|\n    sum and (sum + el == 0)\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    Yes, it does. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nI guess you meant `[1,2,3]`\
    \ instead of `[1,2,3]`.\n<|/ c |>\n<| c |>\nYes, I did. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| c |>\nI guess you meant `[1,2,3]` instead of `[1,2,3]`.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  l.sort!\n  l.uniq!\n  l.length == 3\n\
    end", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  return l.inject(true)\
    \ do |sum,x|\n    sum and (x.to_i + x.to_i + x.to_i) == 0 \n  end\nend\n</code>\n\
    <|/ a tags=ruby,arrays,algorithm |>\n<| c |>\nThis solution doesn't work for `[1,1,1,1]`\n\
    <|/ c |>\n<| c |>\nIt does work, try it out. `[1,1,1,1].inject(true) do |sum,x|\n\
    \    sum and (x.to_i + x.to_i + x.to_i) == 0 \n  end` returns `true`.\n<|/ c |>\n\
    <| c |>\nYes, it does. I tested it out. `[1,1,1,1].inject(true) do |sum,x|\n \
    \   sum and (x.to_i + x.to_i + x.to_i) == 0 \n  end` returns `true`.\n<|/ c |>\n\
    <| c |>\nYes, it does. I tested it out. `[1,1,1,1].inject(true) do |sum,x|\n \
    \   sum and (x.to_i + x.to_i + x.to_i) == 0 \n  end` returns `true`.\n<|/ c |>\n\
    <| c |>\nYes, it does. I tested it out. `[1,1,1,1].inject(true) do |sum,x|\n \
    \   sum and (x.to_i + x.to_i + x.to_i) == 0 \n  end` returns `true`.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "  l.sort!\n  return l.inject(true) do |sum,x|\n  \
    \  sum and (x.to_i + x.to_i + x.to_i) == 0 \n  end\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt does\
    \ work. Try it with `[1,2,3]`. `[1,2,3]` returns `[false, true, false]`, which\
    \ is what we want.\n<|/ c |>\n<| c |>\nI see what you mean. My bad.\n<|/ c |>\n\
    <| c |>\nI added a more efficient solution.\n<|/ c |>\n<| c |>\nI added a more\
    \ efficient solution.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l.each do |i|\n\
    \    l.each do |j|\n      l.each do |k|\n        return true if i + j + k == 0\n\
    \      end\n    end\n  end\n  return false\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis is not correct. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nI didn't\
    \ say it was correct, I said it was an improvement. :)\n<|/ c |>\n<| c |>\nI didn't\
    \ say it was correct, I said it was an improvement. :)\n<|/ c |>\n<| c |>\nI didn't\
    \ say it was correct, I said it was an improvement. :)\n<|/ c |>\n<| c |>\nI didn't\
    \ say it was correct, I said it was an improvement. :)\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.sort!\n  l.each_cons(3).all? { |a,b,c| a + b + c == 0 }\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like your solution, but I\
    \ wonder if there is a way to do it without sorting the array. Maybe using some\
    \ kind of hash table?\n<|/ c |>\n<| c |>\n: Yes, you can use a hash table to keep\
    \ track of which elements have already been seen. I'll add an example to my answer.\n\
    <|/ c |>\n<| c |>\n: I added a hash table solution to my answer.\n<|/ c |>\n<|\
    \ c |>\n: I added a hash table solution to my answer.\n<|/ c |>\n<| c |>\n: I\
    \ added a hash table solution to my answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  l.uniq!\n  l.sort!\n  l.each_cons(3).any? { |a,b,c| a+b+c == 0 }\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nI like your solution, but I wonder how it\
    \ compares to mine. My solution has two loops, while yours has three. Which one\
    \ is faster?\n<|/ c |>\n<| c |>\nI added a benchmark test to my answer. Your solution\
    \ is faster, but only by a factor of about 1.\n<|/ c |>\n<| c |>\nI added a benchmark\
    \ test to my answer. Your solution is faster, but only by a factor of about 1.\n\
    <|/ c |>\n<| c |>\nI added a benchmark test to my answer. Your solution is faster,\
    \ but only by a factor of about 1.\n<|/ c |>\n<| c |>\nI added a benchmark test\
    \ to my answer. Your solution is faster, but only by a factor of about 1.\n<|/\
    \ c |>\n<| a dscore=1 |>\n<code>", "  l.sort!\n  l.uniq!\n  l.length == 3\nend",
  "  l.sort!\n  return l.inject(true) do |sum,x|\n    sum and (sum + x == 0) or (sum\
    \ + x == -3)\n  end\nend", "  l.sort!\n  return l.inject(true) do |sum,i|\n  \
    \  sum and (sum - l[i] + l[i+1] + l[i+2] == 0)\n  end\nend", "  l.sort!\n  return\
    \ l.inject(true) do |sum, el|\n    sum and (el == l[0] + l[1] + l[2])\n  end\n\
    end", "  l.sort!\n  l.reduce(0) { |sum, el| sum + el if el > 0 && el < 3 }\nend",
  "  l.sort!\n  return l.inject(true) do |sum,i|\n    sum and (sum - l[i] + l[i+1]\
    \ + l[i+2] == 0)\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis solution doesn't\
    \ work for me. `triples_sum_to_zero([1,0,1])` returns `true` instead of `false`\n\
    <|/ c |>\n<| c |>\nI tested it on ruby 2.4.0 and it works. I suspect that your\
    \ input is not what you think it is. Can you post the exact code you are using\
    \ and the exact input you give it?\n<|/ c |>\n<| c |>\nI added the exact code\
    \ I used and the exact input I gave it\n<|/ c |>\n<| c |>\nI added the exact code\
    \ I used and the exact input I gave it\n<|/ c |>\n<| c |>\nI added the exact code\
    \ I used and the exact input I gave it\n<|/ c |>\n<| a dscore=1 |>\n<code>", " \
    \ l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.each do |i|\n    l.each do |j|\n\
    \      l.each do |k|\n        return true if i+j+k == 0\n      end\n    end\n\
    \  end\n  return false\nend", "  l.each do |i|\n    l.each do |j|\n      l.each\
    \ do |k|\n        if i + j + k == 0 \n          return true\n        end\n   \
    \   end\n    end\n  end\n  return false\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI like the idea of using inject but this doesn't work if there\
    \ are multiple zeros in the list. For example, `[0,0,0]` returns `true` but `[0,0,1]`\
    \ returns `false`.\n<|/ c |>\n<| c |>\nI agree, that is a good point. I will edit\
    \ my answer to include a solution that will work for multiple zeros in the list.\n\
    <|/ c |>\n<| c |>\nI added a solution that will work for multiple zeros in the\
    \ list.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  l.sort!\n  return\
    \ l.inject(true) { |sum, el| sum && el == l.last - l.first }\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "  l.sort!\n  for i in 0..(l.length-1)\n\
    \    for j in (i+1)..l.length\n      if l[i]+l[j]+l[j] == 0\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "  l.each do |i|\n    l.each\
    \ do |j|\n      l.each do |k|\n        return true if i+j+k == 0\n      end\n\
    \    end\n  end\n  return false\nend\n</code>\n<|/ a |>\n<| c |>\nThis is not\
    \ the correct solution. Try it out with [1,1,1,1]. Your solution returns true.\n\
    <|/ c |>\n<| c |>\n: I see what you mean. Thanks for pointing that out. I've updated\
    \ my answer to account for that.\n<|/ c |>\n<| c |>\n: Thanks for pointing that\
    \ out. I've updated my answer to account for that.\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>", "  l.uniq!\n  l.sort!\n  l.each_cons(3).any? { |x, y, z| x + y + z ==\
    \ 0 }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI like your solution, but I believe\
    \ it can be improved. `l.uniq!` will remove duplicates, `l.sort!` will sort the\
    \ array in-place, `l.each_cons(3)` will iterate over every 3 elements in the array,\
    \ and `any?` will stop iterating as soon as it finds three elements that sum to\
    \ zero. `l.each_cons(3).any? { |x, y, z| x + y + z == 0 }` will iterate over every\
    \ 3 elements in the array and check if any of them sum to zero. `l.each_cons(3).any?\
    \ { |x, y, z| x + y + z == 0 }` will iterate over every 3 elements in the array\
    \ and check if any of them sum to zero. `l.each_cons(3).any? { |x, y, z| x + y\
    \ + z == 0 }` will iterate over every 3 elements in the array and check if any\
    \ of them sum to zero. `l.each_cons(3).any? { |x, y, z| x + y + z == 0 }` will\
    \ iterate over every 3 elements in the array and check if any of them sum to zero.\
    \ `l.each_cons(3).any? { |x, y, z| x + y + z == 0 }` will iterate over every 3\
    \ elements in the array and check if any of them sum to zero. `l.each_cons(3).any?\
    \ { |x, y, z| x + y + z == 0 }` will iterate over every 3 elements in the array\
    \ and check if any of them sum to zero. `l.each_cons(3).any? { |x, y, z| x + y\
    \ + z == 0 }` will iterate over every 3 elements in the array and check if any\
    \ of them sum to zero. `l.each_cons(3).any? { |x, y, z| x + y + z == 0 }` will\
    \ iterate over every 3 elements in the array and check if any of them sum to zero.\
    \ `l.each_cons(3).any? { |x, y, z| x + y + z == 0 }` will iterate over every 3\
    \ elements in the array and check if any of them sum to zero. `l.each_cons(3).any?\
    \ { |x, y, z| x + y + z == 0 }` will iterate over every 3 elements in the array\
    \ and check if any of them sum to zero. `l.each_cons(3).any? { |x, y, z| x + y\
    \ + z == 0 }` will iterate over every 3 elements in the array and check if any\
    \ of them sum to zero. `l.each_cons(3).any? { |x, y, z| x + y + ", "  l.sort\n\
    \  l.each_with_index do |x, i|\n    next if i == 0\n    l.slice!(i)\n    break\
    \ if l.sum == x\n  end\n  l.size == 3\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nThis doesn't work if there are more than 3 elements that sum to zero.\n\
    <|/ c |>\n<| c |>\nIt does work if there are more than 3 elements that sum to\
    \ zero. Try it yourself.\n<|/ c |>\n<| c |>\nIt does work if there are more than\
    \ 3 elements that sum to zero. Try it yourself. `triples_sum_to_zero([1,2,3,4,5,6,7,8,9,0])`\
    \ returns `true`.\n<|/ c |>\n<| c |>\nIt does work if there are more than 3 elements\
    \ that sum to zero. Try it yourself. `triples_sum_to_zero([1,2,3,4,5,6,7,8,9,0])`\
    \ returns `true`.\n<|/ c |>\n<| c |>\nIt does work if there are more than 3 elements\
    \ that sum to zero. Try it yourself. `triples_sum_to_zero([1,2,3,4,5,6,7,8,9,0])`\
    \ returns `true`.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n \
    \ l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend",
  "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.each_with_index do |x, i|\n \
    \   l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n        return\
    \ false if i == j && j == k && x + y + z == 0\n      end\n    end\n  end\n  true\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if there are\
    \ multiple triples that sum to zero.\n<|/ c |>\n<| c |>\n: I thought that was\
    \ the case from the question. I'll add an explanation to the answer.\n<|/ c |>\n\
    <| c |>\n: I added a solution that works with multiple triples that sum to zero.\n\
    <|/ c |>\n<| c |>\n: I added a solution that works with multiple triples that\
    \ sum to zero.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.each_with_index\
    \ do |n,i|\n    l.delete_at(i)\n    break if l.length < 3\n  end\n  l.length ==\
    \ 0\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\nThis doesn't\
    \ work. Try it with `[1,1,1]`.\n<|/ c |>\n<| c |>\n: It does work. Try it with\
    \ `[1,1,1]`.\n<|/ c |>\n<| c |>\n: It does work. Try it with `[1,1,1]`.\n<|/ c\
    \ |>\n<| c |>\n: It does work. Try it with `[1,1,1]`.\n<|/ c |>\n<| c |>\n: It\
    \ does work. Try it with `[1,1,1]`.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  l.sort\n\
    \  l.each_with_index do |n,i|\n    next if i == 0\n    return false if n == l[i-1]\
    \ + l[i-2] + l[i-3]\n  end\n  true\nend", "  l.sort!\n  l.uniq!\n  l.length ==\
    \ 3\nend", "  l.sort!\n  return l.inject(true) { |sum,x| sum && x==0 || sum &&\
    \ x==x+1  }\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n\
    \  return l.inject(true) do |sum,x|\n    sum and (x.to_i + x.to_i + x.to_i) ==\
    \ 0 \n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>", "  l.sort!\n \
    \ l.uniq!\n  l.length == 3\nend", "  l.sort!\n  return l.inject(true) do |sum,x|\n\
    \    sum && x == 3\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    This solution doesn't work for me. `[1,2,3].inject(true) do |sum,x|\n    sum &&\
    \ x == 3\n  end` returns `false` when it should return `true`.\n<|/ c |>\n<| c\
    \ |>\nI tested it and it works. Are you sure you copied the code correctly? I\
    \ tested it on Ruby 1.8.7 and 1.9.2\n<|/ c |>\n<| c |>\nYes, I copied it correctly.\
    \ I'm using Ruby 1.8.7 and 1.9.2. I don't know why it's not working for me.\n\
    <|/ c |>\n<| c |>\nI tested it on Ruby 1.8.7 and 1.9.2 and it works. Are you sure\
    \ you copied the code correctly? I tested it on Ruby 1.8.7 and 1.9.2\n<|/ c |>\n\
    <| c |>\nI tested it on Ruby 1.8.7 and 1.9.2 and it works. Are you sure you copied\
    \ the code correctly? I tested it on Ruby 1.8.7 and 1.9.2\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>", "  l.sort!\n  l.uniq!\n  l.each_cons(3).all? { |triplet| triplet.reduce(:+)\
    \ == 0 }\nend", "  l.sort!\n  return l.inject(true) do |sum, el|\n    sum and\
    \ (el + el + el) == sum\n  end\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\n\
    end", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.each_cons(3) do |triple|\n\
    \    triple.inject(true) do |sum, e|\n      sum && e == 0\n    end\n  end\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nI like this solution, but I wonder if there\
    \ is a way to do this without using inject or each_cons?\n<|/ c |>\n<| c |>\n\
    : I added a version that doesn't use inject or each_cons.\n<|/ c |>\n<| c |>\n\
    : I added a version that doesn't use inject or each_cons.\n<|/ c |>\n<| c |>\n\
    : I added a version that doesn't use inject or each_cons.\n<|/ c |>\n<| c |>\n\
    : I added a version that doesn't use inject or each_cons.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort\n  l.each_cons(3).any?\
    \ { |a,b,c| a+b+c == 0 }\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend",
  "  l.sort!\n  i = 0\n  while i < l.length\n    j = i + 1\n    while j < l.length\n\
    \      k = j + 1\n      while k < l.length\n        if l[i] + l[j] + l[k] == 0\n\
    \          return true\n        k += 1\n      j += 1\n    i += 1\n  end\n  return\
    \ false\nend", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n    \
    \    return true if x+y+z == 0 and x+y+z != 0\n      end\n    end\n  end\n  return\
    \ false\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work. Try it with `[1,1,1]`\n\
    <|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing that out. I updated\
    \ my answer to fix it.\n<|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing\
    \ that out. I updated my answer to fix it.\n<|/ c |>\n<| c |>\nI see what you\
    \ mean. Thanks for pointing that out. I updated my answer to fix it.\n<|/ c |>\n\
    <| c |>\nI see what you mean. Thanks for pointing that out. I updated my answer\
    \ to fix it.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n  return\
    \ l.inject(true) do |sum,x|\n    sum and (x.to_i + x.to_i + x.to_i) == 0 \n  end\n\
    end", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  return l.inject(true)\
    \ do |sum,x|\n    sum and (x.to_i + x.to_i + x.to_i) == 0 \n  end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for your answer. I am not very familiar with\
    \ inject method. Could you please explain how it works?\n<|/ c |>\n<| c |>\n`inject`\
    \ will iterate over the array and return the last value that evaluates to true.\
    \ `inject` will return the last value that evaluates to true. `inject` will return\
    \ the last value that evaluates to true. `inject` will return the last value that\
    \ evaluates to true. `inject` will return the last value that evaluates to true.\
    \ `inject` will return the last value that evaluates to true. `inject` will return\
    \ the last value that evaluates to true. `inject` will return the last value that\
    \ evaluates to true. `inject` will return the last value that evaluates to true.\
    \ `inject` will return the last value that evaluates to true. `inject` will return\
    \ the last value that evaluates to true. `inject` will return the last value that\
    \ evaluates to true. `inject` will return the last value that evaluates to true.\
    \ `inject` will return the last value that evaluates to true. `inject` will return\
    \ the last value that evaluates to true. `inject` will return the last value that\
    \ evaluates to true. `inject` will return the last value that evaluates to true.\
    \ `inject` will return the last value that evaluates to true. `inject` will return\
    \ the last value that evaluates to true. `inject` will return the last value that\
    \ evaluates to true. `inject` will return the last value that evaluates to true.\
    \ `inject` will return the last value that evaluates to true. `inject` will return\
    \ the last value that evaluates to true. `inject` will return the last value that\
    \ evaluates to true. `inject` will return the last value that evaluates to true.\
    \ `inject` will return the last value that evaluates to true. `inject` will return\
    \ the last value that evaluates to true. `inject` will return the last value that\
    \ evaluates to true. `inject` will return the last value that evaluates to true.\
    \ `inject` will return the last value that evaluates to true. `inject` will return\
    \ the last value that evaluates to true. `inject` will return the last value that\
    \ evaluates to true. `inject` will return the last value that evaluates to true.\
    \ `inject` will return the last value that evaluates to true. `inject` will return\
    \ the last value that evaluates to true. `", "  l.sort!\n  l.uniq!\n  l.length\
    \ == 3\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.sort\n  l.each_with_index do |x, i|\n    next if\
    \ i == 0\n    next if l[i-1] == x\n    next if l[i-2] == x\n    return false if\
    \ l[i-1] + l[i-2] + l[i] == 0\n  end\n  true\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nI like your solution, but I believe it can be done in O(n) time by using\
    \ a hash table. I'll post my answer shortly.\n<|/ c |>\n<| c |>\nYes, it can be\
    \ done in O(n) time using a hash table. I'll post my answer shortly.\n<|/ c |>\n\
    <| a dscore=1 |>\nI believe this can be done in O(n) time using a hash table.\
    \ I'll post my answer shortly.\n<code>", "  l.sort!\n  l.uniq!\n  l.length ==\
    \ 3\nend", "  l.sort!\n  l.reduce(0) {|sum, el| sum + el == 0 ? true : false}\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI believe this would return true for\
    \ [1,1,1,1]\n<|/ c |>\n<| c |>\nYes, I believe it does. I tested it on [1,1,1,1]\
    \ and it returned true.\n<|/ c |>\n<| c |>\nI believe it returns true for [1,1,1,1]\n\
    <|/ c |>\n<| c |>\nYes, I believe it does. I tested it on [1,1,1,1] and it returned\
    \ true.\n<|/ c |>\n<| c |>\nI believe it returns true for [1,1,1,1]\n<|/ c |>\n\
    <| a tags=ruby,arrays |>\n<code>", "  l.sort!\n  l.uniq!\n  l.length == 3\nend",
  "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  return l.inject(true)\
    \ { |sum,x| sum && x==0 || sum && x==x-1}\nend", "  l.sort!\n  l.uniq!\n  l.length\
    \ == 3\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  return\
    \ l.inject(true) do |sum,x|\n    sum and (x.to_i + x.to_i + x.to_i) == 0 \n  end\n\
    end", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n  l.length\
    \ == 3\nend", "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n     \
    \   return true if i+j+k == 0\n      end\n    end\n  end\n  return false\nend",
  "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n        next if i == j\
    \ && j == k\n        return false if i == j && j == k\n      end\n    end\n  end\n\
    \  return true\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n\
    \  l.uniq!\n  l.length == 3\nend", "  l.uniq!\n  l.sort!\n  l.each_cons(3).all?\
    \ { |a,b,c| a+b+c == 0 }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI like the\
    \ idea of using each_cons, but this doesn't work if there are duplicate elements\
    \ in the list. For example, `[1,1,2,3]` returns `false` instead of `true`.\n<|/\
    \ c |>\n<| c |>\nI added a version that doesn't use each_cons.\n<|/ c |>\n<| c\
    \ |>\nThanks for your answer. I'm going to accept the other answer because it\
    \ was posted first, but I appreciate your effort.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  l.sort!\n  return l.inject(true) do |sum,x|\n    sum and (x.to_i +\
    \ x.to_i + x.to_i) == 0 \n  end\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return true if x+y+z ==\
    \ 0 && i != j && j != k && k != i\n      end\n    end\n  end\n  false\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis solution has O(n^3) complexity, which\
    \ is very inefficient.\n<|/ c |>\n<| c |>\nYes, I know. But I thought that maybe\
    \ the OP was interested in an efficient solution. Anyway, I added a solution that\
    \ is O(n^2) complexity and that uses `each_with_index` instead of `each_with_index.to_a`.\n\
    <|/ c |>\n<| c |>\nYes, I know. But I thought that maybe the OP was interested\
    \ in an efficient solution. Anyway, I added a solution that is O(n^2) complexity\
    \ and that uses `each_with_index` instead of `each_with_index.to_a`.\n<|/ c |>\n\
    <| c |>\nI added a solution that is O(n^2) complexity and that uses `each_with_index`\
    \ instead of `each_with_index.to_a`.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ is O(n^2) complexity and that uses `each_with_index` instead of `each_with_index.to_a`.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  l.each_cons(3) do |triples|\n    triples.all?\
    \ { |t| t.reduce(:+) == 0 }\n  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nI like your solution, but I believe that `each_cons` will create more\
    \ objects than necessary (at least in Ruby 1.9.2). Try `[1,2,3,4,5].each_cons(3).to_a`\
    \ and see how many objects you have.\n<|/ c |>\n<| c |>\n: I believe that `each_cons`\
    \ will create only as many objects as it needs. Try `[1,2,3,4,5].each_cons(3).to_a`\
    \ and see how many objects you have.\n<|/ c |>\n<| c |>\n: I believe that `each_cons`\
    \ will create only as many objects as it needs. Try `[1,2,3,4,5].each_cons(3).to_a`\
    \ and see how many objects you have.\n<|/ c |>\n<| c |>\n: I believe that `each_cons`\
    \ will create only as many objects as it needs. Try `[1,2,3,4,5].each_cons(3).to_a`\
    \ and see how many objects you have.\n<|/ c |>\n<| c |>\n: I believe that `each_cons`\
    \ will create only as many objects as it needs. Try `[1,2,3,4,5].each_cons(3).to_a`\
    \ and see how many objects you have.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>",
  "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.each do |i|\n    l.each do |j|\n\
    \      l.each do |k|\n        return true if i+j+k == 0\n      end\n    end\n\
    \  end\n  return false\nend", "  l.sort\n  l.each_with_index do |x, i|\n    next\
    \ if i == 0\n    l.slice!(i)\n    break if l.sum != 0\n  end\n  l.size == 3\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis fails for `[1,1,1]`\n<|/\
    \ c |>\n<| c |>\nIt fails for `[1,1,1,1]` as well\n<|/ c |>\n<| c |>\nI thought\
    \ the question was about three distinct elements in the list that sum to zero.\
    \ I'll fix the answer.\n<|/ c |>\n<| c |>\nI fixed the answer. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nI added a more efficient solution that doesn't\
    \ require sorting.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.sort!\n  return l.inject(true) { |sum,x| sum && x==0\
    \ }\nend", "  l.sort!\n  return l.inject(true) do |sum,x|\n    sum and (sum +\
    \ x == 0)\n  end\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.each\
    \ do |i|\n    l.each do |j|\n      l.each do |k|\n        if i + j + k == 0 \n\
    \          return true\n        end\n      end\n    end\n  end\n  return false\n\
    end", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  return l.inject(true)\
    \ do |sum,x|\n    sum and (x.to_i + x.to_i + x.to_i) == 0 \n  end\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if there are multiple zeroes\
    \ in the array.\n<|/ c |>\n<| c |>\nIt does work. Try it out and see for yourself.\n\
    <|/ c |>\n<| c |>\nIt doesn't work if there are multiple zeroes in the array.\
    \ Try it out and see for yourself.\n<|/ c |>\n<| c |>\nIt does work. Try it out\
    \ and see for yourself.\n<|/ c |>\n<| c |>\nIt does work. Try it out and see for\
    \ yourself.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.", "  l.sort!\n  return l.inject(true) do |sum, el|\n    el ==\
    \ 0 || sum && el + sum == el\n  end\nend", "  l.sort\n  l.each_with_index do |x,\
    \ i|\n    break if i == 0\n    break if l[i] - l[i - 1] == l[i - 1]\n  end\n \
    \ l[0] == l[1] && l[1] == l[2]\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return true if x+y+z ==\
    \ 0 && (i != j) && (i != k) && (j != k)\n      end\n    end\n  end\n  false\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI didn't downvote, but this doesn't\
    \ answer the question. You're just reiterating what the OP already knows.\n<|/\
    \ c |>\n<| c |>\nI added a solution that uses `each_with_index` which I believe\
    \ is what the OP was looking for.\n<|/ c |>\n<| c |>\nI didn't downvote, but this\
    \ doesn't answer the question. You're just reiterating what the OP already knows.\n\
    <|/ c |>\n<| c |>\nI added a solution that uses `each_with_index` which I believe\
    \ is what the OP was looking for.\n<|/ c |>\n<| c |>\nI didn't downvote, but this\
    \ doesn't answer the question. You're just reiterating what the OP already knows.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  l.sort!\n  i = 0\n  while i < l.length\n\
    \    if l[i] + l[i+1] + l[i+2] == 0\n      return true\n    i += 1\n  end\n  return\
    \ false\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.each_with_index\
    \ do |n,i|\n    l.each_with_index do |m,j|\n      l.each_with_index do |o,k|\n\
    \        if n == m && m == o && n == 0\n          return true\n        end\n \
    \     end\n    end\n  end\n  return false\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nThis code doesn't work. `triples_sum_to_zero([1,2,3])` returns `true`\
    \ but `triples_sum_to_zero([1,2,4])` returns `false`.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing that out. I fixed the code by adding an additional condition to\
    \ the `if` statement. Now it works.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l.sort!\n\
    \  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.reverse!\n  l[0] = 0\n  l[1]\
    \ = 0\n  l[2] = 0\n  l.reduce(0) { |sum, e| sum + e } == 0 \nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis is not the correct solution. Try it with `[1,1,1]`.\n\
    <|/ c |>\n<| c |>\n: I see what you mean. I'll fix it.\n<|/ c |>\n<| c |>\n: I\
    \ fixed it. I had a bug in the `triples_sum_to_zero` method. Now it should work.\n\
    <|/ c |>\n<| c |>\n: I added a solution that uses `reduce`.\n<|/ c |>\n<| c |>\n\
    : I added a solution that uses `reduce`.\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  return l.inject(true)\
    \ do |sum,i|\n    sum and (sum - l[i] + l[i+1] + l[i+2] == 0)\n  end\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis solution doesn't work for `[1,2,3]`. It returns\
    \ `true` instead of `false`\n<|/ c |>\n<| c |>\nI added a solution that works\
    \ for any number of elements in the list\n<|/ c |>\n<| c |>\nI added a solution\
    \ that works for any number of elements in the list\n<|/ c |>\n<| c |>\nI added\
    \ a solution that works for any number of elements in the list\n<|/ c |>\n<| a\
    \ tags=ruby,algorithm |>\n<code>", "  l.sort\n  l.each_with_index do |x,i|\n \
    \   next if i == 0\n    next if i == 1\n    next if i == 2\n    return false if\
    \ x == l[i-1] + l[i-2] + l[i-3]\n  end\n  true\nend", "  l.each_with_index do\
    \ |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x+y+z == 0 && i != j && j != k && k != i\n      end\n\
    \    end\n  end\n  return false\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\n\
    end", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.each do |x|\n    l.each\
    \ do |y|\n      l.each do |z|\n        return true if x+y+z == 0\n      end\n\
    \    end\n  end\n  return false\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n\
    <| c |>\nThe OP wants to know if there are three distinct elements in the list\
    \ that sum to zero, not if there are three distinct elements in the list that\
    \ sum to zero.\n<|/ c |>\n<| c |>\nYes, I missed that. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| c |>\nThis is not the fastest solution, since it requires\
    \ three nested loops. A better solution would be to sort the list and then iterate\
    \ over it three times. But this requires more memory and requires more CPU time.\n\
    <|/ c |>\n<| c |>\nYes, I agree with you. Sorting would be the best solution.\
    \ But the OP didn't specify what he wants to do with the solution, so I didn't\
    \ want to complicate the answer too much.\n<|/ c |>\n<| c |>\nI agree with you\
    \ that sorting would be the best solution. But I wanted to point out that sorting\
    \ is O(n log n), while this solution is O(n^3). Also, sorting is more complicated\
    \ than it needs to be. Just sort once, iterate over it three times, and you're\
    \ done.\n<|/ c |>\n<| a tags=ruby,algorithm |>\n<code>", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return false if x == y\
    \ && y == z && z == 0\n      end\n    end\n  end\n  true\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nI tested it on `[1,2,3]` and it returns `true`.\n<|/ c |>\n<| c |>\n\
    Yes, but that's not what the OP asked for. He asked for three distinct elements\
    \ that sum to zero.\n<|/ c |>\n<| c |>\nI see what you mean. I'll update my answer.\n\
    <|/ c |>\n<| c |>\nThis still doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n\
    \  return l.inject(true) do |sum,i|\n    sum and (sum - l[i] + l[i+1] + l[i+2]\
    \ == 0)\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer.\
    \ Your solution is O(n^2) but I was looking for O(n). Thanks anyway\n<|/ c |>\n\
    <| c |>\nI thought you were looking for O(n). But I see that you are looking for\
    \ O(n^2). My solution doesn't take that into account. I'll update my answer in\
    \ a minute.\n<|/ c |>\n<| c |>\nThanks again. Your solution is O(n^2) but I was\
    \ looking for O(n). Thanks anyway\n<|/ c |>\n<| c |>\nI updated my answer with\
    \ a solution that is O(n).\n<|/ c |>\n<| a tags=ruby,arrays,algorithm |>\n<code>",
  "  l.sort!\n  return l.inject(true) do |sum,x|\n    sum and (x.to_i == 0 || x.to_i\
    \ == x.to_i + 1)\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work. Try it with `[1, 1, 1]`.\n<|/ c |>\n<| c |>\nI see what you mean. Thanks\
    \ for pointing that out. I've edited my answer to fix it.\n<|/ c |>\n<| a |>\n\
    <code>", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.sort!\n  i = 0\n  while i < l.length\n    if l[i]\
    \ == l[i+1] and l[i] == l[i+2]\n      return false\n    i += 1\n  end\n  return\
    \ true\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  return\
    \ l.inject(true) do |sum,i|\n    sum and (sum - l[i] + l[i+1] + l[i+2] == 0)\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like your solution.\
    \ Very elegant. Thanks!\n<|/ c |>\n<| c |>\nI like your solution as well. Very\
    \ elegant. Thanks!\n<|/ c |>\n<| c |>\nI like your solution as well. Very elegant.\
    \ Thanks!\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  l.sort!\n  l.uniq!\n  l.length\
    \ == 3\nend", "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n     \
    \   return true if i+j+k == 0\n      end\n    end\n  end\n  return false\nend",
  "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n        return true if\
    \ i+j+k == 0\n      end\n    end\n  end\n  return false\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "  l.sort!\n  l.uniq!\n  l.length == 3\nend",
  "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n  l.length\
    \ == 3\nend", "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n     \
    \   return true if i+j+k == 0\n      end\n    end\n  end\n  return false\nend",
  "  l.each do |i|\n    l.each do |j|\n      l.each do |k|\n        return true if\
    \ i+j+k == 0\n      end\n    end\n  end\n  return false\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI like your solution. I'm going to try it out and see how it works.\
    \ Thanks!\n<|/ c |>\n<| c |>\nI like your solution. I'm going to try it out and\
    \ see how it works. Thanks!\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n\
    \  l.uniq!\n  l.each_cons(3).all? { |triple| triple.inject(:+) == 0 }\nend", " \
    \ l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.each_with_index do |n,i|\n \
    \   l.each_with_index do |m,j|\n      l.each_with_index do |o,k|\n        return\
    \ true if n == m && m == o && n == 0\n      end\n    end\n  end\n  false\nend",
  "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n\
    \  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n  l.sort!\n  l.uniq!\n\
    \  l.sort!\n  l.", "  l.uniq!\n  l.sort!\n  l.each_cons(3) do |triplet|\n    return\
    \ false if triplet.reduce(:+) == 0\n  end\n  true\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,arrays,algorithm |>\n<code>", "  l.sort!\n  l.uniq!\n  l.length\
    \ == 3\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.each_with_index\
    \ do |n,i|\n    l.slice!(i..i+2)\n    break if l.uniq.size == 3\n  end\n  l.size\
    \ == 0\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>", "  l.sort!\n\
    \  i = 0\n  while i < l.length\n    j = i + 1\n    while j < l.length\n      if\
    \ l[i] + l[j] + l[j] == 0\n        return true\n      j += 1\n    end\n    i +=\
    \ 1\n  end\n  return false\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      l.each_with_index do |z, k|\n        return false if i == j\
    \ && j == k\n      end\n    end\n  end\n  true\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't work. Try `[1,2,3].each_with_index.all? { |x, i| x.zero?\
    \ }`.\n<|/ c |>\n<| c |>\n: I didn't say it wouldn't.  I said it wouldn't work.\
    \  I said it wouldn't be efficient.  I said it wouldn't be readable.  I said it\
    \ wouldn't be maintainable.  I said it wouldn't be readable.  I said it wouldn't\
    \ be maintainable.  I said it wouldn't be readable.  I said it wouldn't be maintainable.\
    \  I said it wouldn't be readable.  I said it wouldn't be maintainable.  I said\
    \ it wouldn't be readable.  I said it wouldn't be maintainable.  I said it wouldn't\
    \ be readable.  I said it wouldn't be maintainable.  I said it wouldn't be readable.\
    \  I said it wouldn't be maintainable.  I said it wouldn't be readable.  I said\
    \ it wouldn't be maintainable.  I said it wouldn't be readable.  I said it wouldn't\
    \ be maintainable.  I said it wouldn't be readable.  I said it wouldn't be maintainable.\
    \  I said it wouldn't be readable.  I said it wouldn't be maintainable.  I said\
    \ it wouldn't be readable.  I said it wouldn't be maintainable.  I said it wouldn't\
    \ be readable.  I said it wouldn't be maintainable.  I said it wouldn't be readable.\
    \  I said it wouldn't be maintainable.  I said it wouldn't be readable.  I said\
    \ it wouldn't be maintainable.  I said it wouldn't be readable.  I said it wouldn't\
    \ be maintainable.  I said it wouldn't be readable.  I said it wouldn't be maintainable.\
    \  I said it wouldn't be readable.  I said it wouldn't be maintainable.  I said\
    \ it wouldn't be readable.  I said it wouldn't be maintainable.  I said it wouldn't\
    \ be readable.  I said it wouldn't be maintainable.  I said it wouldn't be readable.\
    \  I said it wouldn't be maintainable.  I said it wouldn't be readable.  I said\
    \ it wouldn't be maintainable.  I said it wouldn't ", "  l.sort\n  l.each_with_index\
    \ do |x, i|\n    next if i == 0\n    next if i == 1\n    next if i == 2\n    return\
    \ false if x == l[i-1] + l[i-2] + l[i-3]\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI like the idea of using each_with_index, but this doesn't work\
    \ if there are more than three elements in the array.\n<|/ c |>\n<| c |>\nI agree,\
    \ that's why I added the comment about using each_with_index.\n<|/ c |>\n<| c\
    \ |>\nI added a solution that uses each_with_index.\n<|/ c |>\n<| a dscore=1 |>\n\
    Here's a solution using each_with_index:\n<code>", "  l.sort!\n  l.each_cons(3)\
    \ do |triples|\n    triples\n      .each_cons(2)\n      .all? { |a| a.sum == 0\
    \ }\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. `[1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155]`\
    \ returns `[true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, true, true, true, true, true, true, true, true,\
    \ true, true, true, true, true, ", "  l.sort!\n  l.uniq!\n  l.length == 3\nend",
  "  l.sort\n  l.each_cons(3).any? { |a,b,c| a+b+c == 0 }\nend", "  l.sort!\n  return\
    \ l.inject(true) do |sum,i|\n    sum and (sum - l[i] + l[i+1] + l[i+2] == 0)\n\
    \  end\nend", "  l.each do |x|\n    l.each do |y|\n      l.each do |z|\n     \
    \   return true if x + y + z == 0\n      end\n    end\n  end\n  return false\n\
    end", "  l.sort\n  l.each_with_index do |x,i|\n    next if i == 0\n    next if\
    \ l[i-1] == x\n    next if l[i-2] == x\n    next if l[i-3] == x\n    return false\
    \ if i == l.size-1\n  end\n  true\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This doesn't work. Try it on `[1,2,3]`.\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ I've edited my answer to fix the bug.\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ I've edited my answer to fix the bug.\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ I've edited my answer to fix the bug.\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ I've edited my answer to fix the bug.\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.each_with_index do |n,i|\n  \
    \  l.each_with_index do |m,j|\n      l.each_with_index do |k,l|\n        if n\
    \ == m && m == k && k == i && i != j && i != l && j != l\n          return false\n\
    \        end\n      end\n    end\n  end\n  return true\nend", "  l.sort!\n  return\
    \ l.inject(true) { |sum, e| sum && e == 0 }\nend", "  l.sort!\n  return l.inject(true)\
    \ do |sum, el|\n    sum and (el == l[0] + l[1] + l[2])\n  end\nend", "  l.sort!\n\
    \  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend",
  "  l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index\
    \ do |z, k|\n        return false if i == j && j == k\n      end\n    end\n  end\n\
    \  true\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like the idea of\
    \ using each_with_index to avoid the nested loops. I wonder if there is a way\
    \ to avoid the nested loops altogether though.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that avoids nested loops.\n<|/ c |>\n<| c |>\nI like your solution. I'm going\
    \ to give it a try and see how it works. Thanks!\n<|/ c |>\n<| c |>\nI added a\
    \ solution that avoids nested loops.\n<|/ c |>\n<| c |>\nI like the idea of using\
    \ each_with_index to avoid the nested loops. I wonder if there is a way to avoid\
    \ the nested loops altogether though.\n<|/ c |>\n<| a dscore=1 |>\n<code>", " \
    \ l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n  l.length\
    \ == 3\nend", "  l.sort!\n  return l.inject(true) do |sum,x|\n    sum and (x.to_i\
    \ + x.to_i + x.to_i) == 0 \n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This doesn't work. Try it with `[1,1,1,1]`.\n<|/ c |>\n<| c |>\nIt does work.\
    \ Try it with `[1,1,1,1]`. `[1,1,1,2]` returns `true`, but `[1,1,1,3]` returns\
    \ `false`.\n<|/ c |>\n<| c |>\nYes, it does. Try it with `[1,1,1,3]`.\n<|/ c |>\n\
    <| c |>\nIt does work. Try it with `[1,1,1,3]`. `[1,1,1,2]` returns `true`, but\
    \ `[1,1,1,3]` returns `false`.\n<|/ c |>\n<| c |>\nYes, it does. Try it with `[1,1,1,3]`.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  l.uniq!\n  l.sort!\n  l.each_cons(3) do\
    \ |triplet|\n    return false if triplet.inject(:+) == 0 \n  end\n  true\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like your solution, but I wonder\
    \ how it compares to mine. My solution takes O(n^2) time, yours takes O(n) time.\
    \ I'm wondering if mine is faster.\n<|/ c |>\n<| c |>\n: I doubt that mine is\
    \ faster, but it's certainly more concise. My solution takes O(n) time because\
    \ I used `each_cons`, which takes O(n) time on average. Your solution takes O(n^2)\
    \ time because I used `uniq`, which takes O(n^2) time on average. My solution\
    \ takes O(n) time because I used `sort`, which takes O(n) time on average. Your\
    \ solution takes O(n^2) time because I used `each_cons`, which takes O(n) time\
    \ on average. My solution takes O(n) time because I used `inject`, which takes\
    \ O(n) time on average. My solution takes O(n) time because I used `uniq`, which\
    \ takes O(n) time on average.\n<|/ c |>\n<| c |>\n: I added a benchmark to my\
    \ answer. My solution takes O(n) time because I used `each_cons`, which takes\
    \ O(n) time on average. Your solution takes O(n^2) time because I used `uniq`,\
    \ which takes O(n^2) time on average. My solution takes O(n) time because I used\
    \ `sort`, which takes O(n) time on average. Your solution takes O(n^2) time because\
    \ I used `each_cons`, which takes O(n) time on average. My solution takes O(n)\
    \ time because I used `inject`, which takes O(n) time on average. My solution\
    \ takes O(n) time because I used `uniq`, which takes O(n) time on average.\n<|/\
    \ c |>\n<| c |>\n: I added a benchmark to my answer. My solution takes O(n) time\
    \ because I used `each_cons`, which takes O(n) time on average. Your solution\
    \ takes O(n^2) time because I used `uniq`, which takes O(n^2) time on average.\
    \ My solution takes O(n) time because I used `sort`, which takes O(n) time on\
    \ average. Your solution takes O", "  l.sort!\n  return l.inject(true) do |sum,x|\n\
    \    sum and (sum + x == 0)\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ work for `[1, 1, 1]`\n<|/ c |>\n<| c |>\nIt works for me. `triples_sum_to_zero([1,\
    \ 1, 1])` returns `true`.\n<|/ c |>\n<| c |>\nYeah, it works for me too. Maybe\
    \ it's because I'm running Ruby 1.8.7? I haven't upgraded yet to 1.9.\n<|/ c |>\n\
    <| c |>\nI believe that `inject` was introduced in 1.8.7. 1.9.2 has it though.\n\
    <|/ c |>\n<| c |>\nI believe that `inject` was introduced in 1.8.7. 1.9.2 has\
    \ it though.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.sort!\n\
    \  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend",
  "  l.sort!\n  i = 0\n  while i < l.length\n    j = i + 1\n    while j < l.length\n\
    \      k = j + 1\n      while k < l.length\n        if l[i] + l[j] + l[k] == 0\n\
    \          return true\n        k += 1\n      j += 1\n    i += 1\n  end\n  return\
    \ false\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work. Try it with\
    \ `[1,2,3]`. It returns `true` when it should be `false`.\n<|/ c |>\n<| c |>\n\
    It returns true for me. Are you sure you copied it correctly?\n<|/ c |>\n<| c\
    \ |>\nYes, I copied it correctly. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    Ah, I see what you mean. You're right. I misunderstood the question. I'll edit\
    \ my answer.\n<|/ c |>\n<| c |>\nI edited my answer. Sorry for the confusion.\n\
    <|/ c |>\n<| a dscore=2 |>\nThe algorithm is pretty simple:", "  l.uniq!\n  l.sort!\n\
    \  l.each_cons(3) do |triple|\n    return false if triple.inject(:+) == 0\n  end\n\
    \  true\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`each_cons` doesn't\
    \ guarantee that all elements are visited before returning. It will stop when\
    \ it finds the first element that doesn't meet the criteria.\n<|/ c |>\n<| c |>\n\
    : It does. `each_cons` will stop when it finds the first element that doesn't\
    \ meet the criteria.\n<|/ c |>\n<| c |>\n: I didn't know that. Thanks for pointing\
    \ that out. I've updated my answer to reflect that.\n<|/ c |>\n<| c |>\n: I updated\
    \ my answer to include a solution that uses `each_cons`.\n<|/ c |>\n<| c |>\n\
    : I updated my answer to include a solution that uses `each_cons`.\n<|/ c |>\n\
    <| a tags=ruby,arrays |>\n<code>", "  l.each do |i|\n    l.each do |j|\n     \
    \ l.each do |k|\n        return true if i+j+k == 0\n      end\n    end\n  end\n\
    \  return false\nend", "  l.sort!\n  i = 0\n  while i < l.length\n    j = i +\
    \ 1\n    while j < l.length\n      k = j + 1\n      while k < l.length\n     \
    \   if l[i] + l[j] + l[k] == 0\n          return true\n        k += 1\n      j\
    \ += 1\n    i += 1\n  end\n  return false\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis solution does not work if there are multiple triples that\
    \ sum to zero, e.g. `[0,0,0]`\n<|/ c |>\n<| c |>\nYes, you are right. I've updated\
    \ my answer to take that into account.\n<|/ c |>\n<| a dscore=2 |>\n<code>", " \
    \ l.sort!\n  l.uniq!\n  l.length == 3\nend", "  l.uniq!\n  l.sort!\n  l.each_cons(3)\
    \ do |triple|\n    return false if triple.inject(:+) == 0\n  end\n  true\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like your use of inject to sum\
    \ up the triples. I didn't know about that method.\n<|/ c |>\n<| c |>\nI like\
    \ your use of inject to sum up the triples. I didn't know about that method.\n\
    <|/ c |>\n<| c |>\nI like your use of inject to sum up the triples. I didn't know\
    \ about that method.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.uniq!\n  l.sort!\n  l.each_cons(3).any? { |a,b,c|\
    \ a + b + c == 0 }\nend", "  l.uniq!\n  l.sort!\n  l.each_cons(3).all? { |a,b,c|\
    \ a+b+c == 0 }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like\
    \ your solution, but I believe it would be more efficient to sort before iterating\
    \ over it.\n<|/ c |>\n<| c |>\nI agree with you. I've edited my answer to include\
    \ your suggestion.\n<|/ c |>\n<| c |>\nI like your solution, but I believe it\
    \ would be more efficient to sort before iterating over it.\n<|/ c |>\n<| c |>\n\
    I agree with you. I've edited my answer to include your suggestion.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails |>\n<code>", "  l.sort!\n  return l.inject(true)\
    \ do |sum, el|\n    sum and (el + el + el) == sum\n  end\nend", "  l.sort!\n \
    \ l.uniq!\n  l.length == 3\nend", "  l.sort!\n  l.uniq!\n  l.length == 3\nend",
  "  l.sort!\n  l.each_cons(3).all? { |a,b,c| a+b+c == 0 }\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    I see what you mean. Thanks for pointing that out. I fixed the code so that it\
    \ works with `[1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nI see what you mean. Thanks for pointing that out. I fixed\
    \ the code so that it works with `[1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work.\
    \ Try it with `[1,2,3]`.\n<|/ c |>\n<| a |>\n<code>", "  l.sort!\n  l.uniq!\n\
    \  l.length == 3\nend", "  l.uniq!\n  l.sort!\n  l.each_cons(3).any? { |a,b,c|\
    \ a+b+c == 0 }\nend\n</code>\n<|/ a |>\n<| c |>\nI like your solution, but I wonder\
    \ if there is a way to do it without using uniq and sort.\n<|/ c |>\n<| c |>\n\
    : I added a solution without `uniq` and `sort`.\n<|/ c |>\n<| c |>\n: I added\
    \ a solution without `uniq` and `sort`.\n<|/ c |>\n<| c |>\n: I added a solution\
    \ without `uniq` and `sort`.\n<|/ c |>\n<| c |>\n: I added a solution without\
    \ `uniq` and `sort`.\n<|/ c |>\n<| a tags=ruby,algorithm |>\n<code>", "  l.sort!\n\
    \  l.uniq!\n  l.length == 3\nend", "  l.sort!\n  return l.inject(true) do |sum,\
    \ el|\n    sum and (el + el + el == 0)\n  end\nend", "  l.sort!\n  l.uniq!\n \
    \ l.length == 3\nend", "  l.sort!\n  return l.inject(true) do |sum,i|\n    sum\
    \ and (sum - l[i] + l[i+1] + l[i+2] == 0)\n  end\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI like your solution, but I wonder why you use `inject` instead\
    \ of `each_cons(3)`?\n<|/ c |>\n<| c |>\nI didn't know about each_cons. I guess\
    \ it's because I didn't know about inject until I saw your answer. Thanks!\n<|/\
    \ c |>\n<| c |>\nI didn't know about each_cons. I guess it's because I didn't\
    \ know about inject until I saw your answer. Thanks!\n<|/ c |>\n<| c |>\nI didn't\
    \ know about each_cons. I guess it's because I didn't know about inject until\
    \ I saw your answer. Thanks!\n<|/ c |>\n<| c |>\nI didn't know about each_cons.\
    \ I guess it's because I didn't know about inject until I saw your answer. Thanks!\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  l.each do |i|\n    l.each do |j|\n   \
    \   l.each do |k|\n        if i + j + k == 0 \n          return true\n       \
    \ end\n      end\n    end\n  end\n  return false\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    It does work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try\
    \ it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nIt does work. Try it with `[1,2,3]`.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  l.each_with_index do |e, i|\n    l.each_with_index do |e2, j|\n\
    \      l.each_with_index do |e3, k|\n        return true if e + e2 + e3 == 0\n\
    \      end\n    end\n  end\n  return false\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to do this\
    \ without using each_with_index.\n<|/ c |>\n<| c |>\nI added a solution without\
    \ each_with_index.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder if there\
    \ is a way to do this without using each_with_index.\n<|/ c |>\n<| c |>\nI added\
    \ a solution without each_with_index.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to do this without using each_with_index.\n<|/\
    \ c |>\n<| a dscore=1 |>\n<code>", "  l.uniq!\n  l.sort!\n  l.each_cons(3).all?\
    \ { |a,b,c| a+b+c == 0 }\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work.\
    \ Try `[1,2,2,3,4].uniq!; [1,2,2,3,4].sort!; [1,2,2,3,4].each_cons(3).all? { |a,b,c|\
    \ a+b+c == 0 }`\n<|/ c |>\n<| c |>\nI guess I misunderstood the question. I'll\
    \ edit the answer.\n<|/ c |>\n<| c |>\nI guess I misunderstood the question. I'll\
    \ edit the answer.\n<|/ c |>\n<| c |>\nI guess I misunderstood the question. I'll\
    \ edit the answer.\n<|/ c |>\n<| c |>\nI guess I misunderstood the question. I'll\
    \ edit the answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      l.each_with_index do |z, k|\n\
    \        return true if x+y+z == 0 && i != j && j != k && k != i\n      end\n\
    \    end\n  end\n  false\nend", "  l.sort\n  l.uniq\n  l.length == 3\n  l.each\
    \ do |x|\n    next if x == 0\n    next if x == 1\n    next if x == 2\n    return\
    \ false\n  end\n  return true\nend", "  l.uniq!\n  l.sort!\n  l.each_cons(3).any?\
    \ { |a,b,c| a+b+c == 0 }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI\
    \ like your solution, but I believe it can be made more efficient by not sorting\
    \ the array. Sorting takes O(n log n) time, and you only need to check three elements\
    \ to determine if there are three distinct elements that sum to zero.\n<|/ c |>\n\
    <| c |>\nYes, I agree. Sorting takes O(n log n) time, but only three elements\
    \ to determine if there are three distinct elements that sum to zero. Sorting\
    \ takes O(n log n) time for each element in the array, so the overall time complexity\
    \ is O(n log n).\n<|/ c |>\n<| c |>\nI believe this solution is O(n^2) since it\
    \ requires two passes over the array. Sorting takes O(n log n) time for each element\
    \ in the array, so the overall time complexity is O(n log n).\n<|/ c |>\n<| c\
    \ |>\nYes, I agree. Sorting takes O(n log n) time, but only three elements to\
    \ determine if there are three distinct elements that sum to zero. Sorting takes\
    \ O(n log n) time for each element in the array, so the overall time complexity\
    \ is O(n log n).\n<|/ c |>\n<| c |>\nI believe this solution is O(n^2) since it\
    \ requires two passes over the array. Sorting takes O(n log n) time for each element\
    \ in the array, so the overall time complexity is O(n log n).\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
