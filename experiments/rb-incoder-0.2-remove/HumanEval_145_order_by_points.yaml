name: HumanEval_145_order_by_points
language: rb
prompt: "# Write a function which sorts the given list of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ list.\n# For example:\ndef order_by_points(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n\
  \    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11],\
  \ candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32,\
  \ 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6],\
  \ candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"
completions: ["  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.group_by {|n| n.to_s.split(//).map(&:to_i).reduce(:+)}\n\
    end", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n\
    \    digits = num.to_s.split(//).map(&:to_i)\n    digits_sum = digits.inject(0)\
    \ {|sum, digit| sum + digit}\n    if digits_sum == num\n      nums[i] = num\n\
    \    end\n  end\nend", "  nums.sort!\n  nums.group_by {|x| x.to_s.split(//).map(&:to_i).reduce(:+)}\n\
    end", "  nums.sort!\n  nums.each_with_index do |num, i|\n    nums[i] = num if\
    \ num.digits.sum < num.digits.max\n  end\nend", "  # TODO: Write your code here\n\
    end", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break if nums[i] ==\
    \ n\n    nums[i] = n\n  end\nend", "  nums.sort! { |a, b| a.to_i + b.to_i }\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |i|\n    sum = 0\n    i.to_s.split(\"\
    \").each do |j|\n      sum += j.to_i\n    end\n    sum\n  end\nend", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == nums[i + 1]\n    nums[i]\
    \ = nums[i + 1]\n    nums[i + 1] = n\n  end\nend", "  # TODO: Write your code\
    \ here\nend", "  # TODO: Write your code here\nend", "  nums.sort!\n  nums.map!\
    \ {|x| x.to_i}\n  nums.each_with_index do |x, i|\n    break if nums.count(x) >\
    \ 1\n    nums[i] = x\n  end\n  nums\nend", "  nums.sort! do |a, b|\n    digits_a\
    \ = a.to_s.split(//).map(&:to_i)\n    digits_b = b.to_s.split(//).map(&:to_i)\n\
    \    digits_a.zip(digits_b).map { |x, y| x + y }.sum <=> x + y\n  end\nend", " \
    \ nums.sort!\n  nums.each_with_index do |n, i|\n    break if nums[i] == n\n  \
    \  nums[i] = n\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    nums[i] = num if nums.sum.to_i == num.to_i\n  end\nend", " \
    \ # Your code here\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n  \
    \  break if nums[i] == nums[i + 1]\n    nums[i] = nums[i + 1]\n    nums[i + 1]\
    \ = n\n  end\nend\n</code>\n<|/ a tags=ruby,sorting |>\n<| c |>\nThis doesn't\
    \ work for me. `[1,2,3,4,5,6,7,8,9,10].sort_by { |x| x.to_s.chars.map(&:to_i).inject(:+)\
    \ }` returns `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]` instead of `[1,2,3,4,5,6,7,8,9,10]`.\n\
    <|/ c |>\n<| c |>\nI guess I misunderstood the question. I'll update my answer.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for me either. `[1,2,3,4,5,6,7,8,9,10].sort_by\
    \ { |x| x.to_s.chars.map(&:to_i).inject(:+) }` returns `[10, 9, 8, 7, 6, 5, 4,\
    \ 3, 2, 1]` instead of `[1,2,3,4,5,6,7,8,9,10]`.\n<|/ c |>\n<| c |>\nI guess I\
    \ misunderstood the question. I'll update my answer.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work for me either. `[1,2,3,4,5,6,7,8,9,10].sort_by { |x| x.to_s.chars.map(&:to_i).inject(:+)\
    \ }` returns `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]` instead of `[1,2,3,4,5,6,7,8,9,10]`.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>", "  nums.sort!\n  nums.each_with_index do\
    \ |num, i|\n    break if nums.count(num) == nums.count(nums[i+1])\n    nums[i]\
    \ = num\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work if there are multiple items with the same sum. For example, `[4,\
    \ 1, 5, 7, 2, 6, 3, 8]` would become `[4, 1, 5, 7, 2, 6, 3, 8, 4]`.\n<|/ c |>\n\
    <| c |>\nYes, you are right. My mistake. I'll fix it.\n<|/ c |>\n<| c |>\nI fixed\
    \ my answer. Now it works as you want.\n<|/ c |>\n<| c |>\nI fixed my answer.\
    \ Now it works as you want.\n<|/ c |>\n<| c |>\nI fixed my answer. Now it works\
    \ as you want.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.group_by\
    \ { |x| x.to_s.split('').map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] + nums[i-1] == nums[i]\n\
    \    nums[i] = nums[i] + nums[i-1]\n    nums[i-1] = nums[i]\n  end\nend", "  nums.sort!\n\
    \  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    if nums.count(n) > 1\n\
    \      nums.delete_at(i)\n    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nThis doesn't work if there are two numbers with the same sum. Try it with\
    \ `[1,2,3,4,5,6,7,8,9,10]`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `[1,2,3,4,5,6,7,8,9,10]`.\
    \ It returns `[1,2,3,4,5,6,7,8,9,10]`.\n<|/ c |>\n<| c |>\nYes, it does. Try it\
    \ with `[1,2,3,4,5,6,7,8,9,10,11]`. You get `[1,2,3,4,5,6,7,8,9,10,11]`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. Try it with `[1,2,3,4,5,6,7,8,9,10,11]`. You get\
    \ `[1,2,3,4,5,6,7,8,9,10,11]`.\n<|/ c |>\n<| c |>\nYes, it does. Try it with `[1,2,3,4,5,6,7,8,9,10,11]`.\
    \ You get `[1,2,3,4,5,6,7,8,9,10,11]`.\n<|/ c |>\n<| a tags=ruby,sorting |>\n\
    <code>", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break if nums[i]\
    \ == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.each_with_index do\
    \ |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits_sum = digits.inject(0)\
    \ {|sum, digit| sum + digit}\n    if digits_sum == nums.first\n      nums[i] =\
    \ i\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.group_by { |x| x.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.each_with_index do |num, i|\n    nums[i] = num\
    \ if nums.sum.to_i == num.to_i\n  end\nend", "  nums.sort!\n  nums.group_by {\
    \ |n| n.to_s.split(//).map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n  nums.group_by\
    \ { |n| n.to_s.split(//).map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n  nums.group_by\
    \ { |x| x.to_s.split(//).map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n  nums.map!\
    \ {|x| x.to_i}\n  nums.sort_by {|x| x.digits.inject(0) {|sum, digit| sum + digit}}\n\
    end", "  # +++your code here+++\nend", "    # Write your code here.\n    sums\
    \ = nums.map { |n| n.to_s.split('').map(&:to_i).reduce(:+) }\n    sums.sort!\n\
    \    nums.sort! { |a, b| sums.index(a) - sums.index(b) }\nend", "    # Write your\
    \ code here.\n    sums = nums.inject(Hash.new(0)) { |sum,x| sum[x] += x }\n  \
    \  nums.sort_by { |x| sums[x] }\nend", "  nums.sort!\n  nums.group_by { |x| x.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break if nums[i]\
    \ + nums[i-1] > 9\n    nums[i] = nums[i] + nums[i-1]\n    nums[i-1] = n\n  end\n\
    end\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if\
    \ there are two or more numbers with the same sum.\n<|/ c |>\n<| c |>\nYes, you're\
    \ right. I've updated my answer to fix it.\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  # Write your code here.\nend", "  nums.sort!\n  nums.group_by { |x| x.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n\
    \    nums[i] = num if nums.sum - num == i\n  end\nend", "  nums.sort!\n  nums.each_with_index\
    \ do |num, i|\n    nums[i] = [num, i]\n  end\n  nums.sort_by { |_, i| i }\nend",
  "  # Your code here\nend", "  nums.sort!\n  nums.each_with_index do |n,i|\n    sum\
    \ = 0\n    while n > 0\n      sum += n % 10\n      n /= 10\n    end\n    if sum\
    \ > 0\n      nums[i] = i\n    end\n  end\nend", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.split(//).map(&:to_i)\n    digits = digits.inject(:+).to_s\n\
    \    if digits.size != 0\n      nums[i] = [n, i]\n    end\n  end\nend", "  nums.sort!\
    \ do |a, b|\n    sum1 = a.to_s.split(//).map(&:to_i).inject(:+)\n    sum2 = b.to_s.split(//).map(&:to_i).inject(:+)\n\
    \    sum1 == sum2 ? a.to_i <=> b.to_i : sum1 < sum2\n  end\nend\n</code>\n<|/\
    \ a tags=ruby,sorting,arrays |>\n<| c |>\nI like the idea of using inject to calculate\
    \ the sum of the digits. I didn't think of that.\n<|/ c |>\n<| c |>\nI like your\
    \ use of inject to calculate the sum of the digits. I didn't think of that either.\n\
    <|/ c |>\n<| c |>\nI like your use of inject to calculate the sum of the digits.\
    \ I didn't think of that either.\n<|/ c |>\n<| c |>\nI like your use of inject\
    \ to calculate the sum of the digits. I didn't think of that either.\n<|/ c |>\n\
    <| c |>\nI like your use of inject to calculate the sum of the digits. I didn't\
    \ think of that either.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>",
  "  nums.sort! { |a, b| a.to_s + b.to_s }\nend", "  # TODO: Write your code here\n\
    end", "  nums.sort!\n  nums.each_with_index do |num, i|\n    break if num == nums.last\n\
    \    nums[i] = num if nums.sum - num.to_i == 0\n  end\nend", "  nums.sort!\n \
    \ nums.each_with_index do |n, i|\n    break if nums[i] == nums[i-1]\n  end\nend",
  "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+) }\n\
    end", "  nums.sort! do |a, b|\n    sum1 = a.to_s.split(//).map(&:to_i).inject(:+)\n\
    \    sum2 = b.to_s.split(//).map(&:to_i).inject(:+)\n    sum1 < sum2 ? -1 : sum1\
    \ > sum2 ? 1 : 0\n  end\nend", "    # Write your code here.\n    sum = 0\n   \
    \ sorted_nums = []\n    sorted_nums_index = []\n    sorted_nums_sum = []\n   \
    \ for num in nums:\n        sum += num\n        sorted_nums.append(num)\n    \
    \    sorted_nums_index.append(nums.index(num))\n        sorted_nums_sum.append(sum)\n\
    \    sorted_nums_sum.sort()\n    sorted_nums_index.sort()\n    sorted_nums.sort()\n\
    \    sorted_nums.reverse()\n    return sorted_nums\n</cell>\n<cell>", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>", "  nums.sort!\n\
    \  nums.each_with_index do |num, i|\n    nums[i] = num if num.digits.sum < num.digits.max\n\
    \  end\nend", "  # TODO: Write your code here\nend", "  # Your code here\nend",
  "  nums.sort! do |a, b|\n    sum_a = a.digits.inject(0) {|sum, digit| sum + digit}\n\
    \    sum_b = b.digits.inject(0) {|sum, digit| sum + digit}\n    sum_a <=> sum_b\n\
    \  end\nend", "  # Your code here\nend", "  nums.sort!\n  nums.group_by { |n|\
    \ n.to_s.split(//).map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n  nums.group_by\
    \ { |n| n.to_s.split(//).map(&:to_i).reduce(:+) }\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to avoid the\
    \ temporary variable `nums`.\n<|/ c |>\n<| c |>\n, yes, you can avoid the temporary\
    \ variable `nums` by using a block instead: `nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }`. See my updated answer.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder\
    \ if there is a way to avoid the temporary variable `nums`.\n<|/ c |>\n<| c |>\n\
    , yes, you can avoid the temporary variable `nums` by using a block instead: `nums.group_by\
    \ { |n| n.to_s.split(//).map(&:to_i).reduce(:+) }`. See my updated answer.\n<|/\
    \ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort! { |a, b| a.to_i\
    \ + b.to_i }\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  # TODO: Write your code here\nend", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\nend\n</code>\n\
    <|/ a tags=ruby,sorting |>\n<| c |>\nThis doesn't work if there are two numbers\
    \ with the same sum.\n<|/ c |>\n<| c |>\nYes, I agree with you. I just wanted\
    \ to show that it is possible to sort by sum.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if there are two numbers with the same sum.\n<|/ c |>\n<| c |>\nYes, I\
    \ agree with you. I just wanted to show that it is possible to sort by sum.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if there are two numbers with the same sum.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  # Your code here\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n\
    \    nums[i] = num if nums.sum.to_i == num.to_i\n  end\nend", "  # TODO: Write\
    \ your code here\nend", "  nums.sort!\n  nums.each_with_index do |num, i|\n  \
    \  digits = num.to_s.chars.map(&:to_i)\n    digits_sum = digits.inject(0) {|sum,\
    \ digit| sum + digit}\n    if digits_sum == num\n      nums[i] = i\n    end\n\
    \  end\nend", "  nums.sort! do |a, b|\n    sum1 = a.to_s.chars.map(&:to_i).sum\n\
    \    sum2 = b.to_s.chars.map(&:to_i).sum\n    sum1 == sum2 ? a.to_i <=> b.to_i\
    \ : sum1 < sum2\n  end\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |i|\n    sum = 0\n \
    \   i.to_s.split(\"\").each do |j|\n      sum += j.to_i\n    end\n    i.to_s.split(\"\
    \").each do |j|\n      i.to_s.split(\"\").each do |k|\n        next if k == j\n\
    \        sum -= k.to_i\n      end\n    end\n    i.to_s.split(\"\").each do |j|\n\
    \      i.to_s.split(\"\").each do |k|\n        next if k == j\n        sum -=\
    \ j.to_i\n      end\n    end\n    i.to_s.split(\"\").each do |j|\n      i.to_s.split(\"\
    \").each do |k|\n        next if k == j\n        sum -= j.to_i\n      end\n  \
    \  end\n    i.to_s.split(\"\").each do |j|\n      i.to_s.split(\"\").each do |k|\n\
    \        next if k == j\n        sum -= j.to_i\n      end\n    end\n    i.to_s.split(\"\
    \").each do |j|\n      i.to_s.split(\"\").each do |k|\n        next if k == j\n\
    \        sum -= j.to_i\n      end\n    end\n    i.to_s.split(\"\").each do |j|\n\
    \      i.to_s.split(\"\").each do |k|\n        next if k == j\n        sum -=\
    \ j.to_i\n      end\n    end\n    i.to_s.split(\"\").each do |j|\n      i.to_s.split(\"\
    \").each do |k|\n        next if k == j\n        sum -= j.to_i\n      end\n  \
    \  end\n    i.to_s.split(\"\").each do |j|\n      i.to_s.split(\"\").each do |k|\n\
    \        next if k == j\n        sum -= j.to_i\n      end\n    end\n    i.to_s.split(\"\
    \").each do |j|\n      i.to_s.split(\"\").each do |k|\n        next if k == j\n\
    \        sum -= j.to_i\n      end\n    end\n    i.to_s.split(\"\").each do |j|\n\
    \      i.to_s.split(\"\").each do |k|\n        next if k == j\n        sum -=\
    \ j.to_i\n      end\n    end\n    i.to_s.split(\"\").each do |j|\n      i.to_s.split(\"\
    \").each do |k|\n        next if k == j\n        sum -= j.to_i\n", "  # TODO:\
    \ Write your code here\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    break if num == nums.last\n    nums[i] = num if nums.sum -\
    \ num == num\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n\
    \    i = nums.index{|n| n.to_s.split(\"\").sum.to_i == num.to_s.split(\"\").sum.to_i}\n\
    \    nums[i] = num\n  end\nend", "    # Write your code here.\n    sum = 0\n \
    \   for i in nums:\n        sum += i\n    return nums\n</cell>\n<cell>\nnums =\
    \ [1, 3, 5]\norder_by_points(nums)\n</cell>\n<text>\nProblem 7\nWrite a function\
    \ that returns a list consisting of all integers from 1 to n\nexcept the number\
    \ itself. For example, excluding 3 from the list below,\nreturn [4, 2, 5, 1].",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n\
    \    digits = digits.inject(:+).to_i\n    if digits.zero?\n      nums.delete(num)\n\
    \    else\n      nums.insert(nums.index(num), num)\n    end\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == nums[i+1]\n    nums[i] = nums[i+1]\n    nums[i+1]\
    \ = n\n  end\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums[i] + nums[i-1] > 9\n    nums[i] = nums[i] + nums[i-1]\n    nums[i-1]\
    \ = n\n  end\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums.count(n) == 1\n    nums[i] = nums.index(n) + i\n  end\n  nums\nend",
  "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+) }\n\
    end", "  nums.sort!\n  nums.group_by {|n| n.to_s.split(//).map(&:to_i).reduce(:+)}\n\
    end", "  nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.split(//).map(&:to_i)\n\
    \    digits_sum = digits.inject(0) {|sum, digit| sum + digit}\n    if digits_sum\
    \ > 0\n      nums[i] = n\n    end\n  end\nend", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] + nums[i-1] > 9\n    nums[i] = nums[i] + nums[i-1]\n\
    \    nums[i-1] = n\n  end\nend", "  # TODO: Write your code here\nend", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == nums[i + 1]\n    nums[i]\
    \ = nums[i + 1]\n    nums[i + 1] = n\n  end\nend", "  # +++your code here+++\n\
    end", "  nums.sort!\n  nums.map! {|x| x.to_i}\n  nums.sort!\nend", "  nums.sort!\n\
    \  nums.group_by {|x| x.to_s.split(//).map(&:to_i).sum}.map {|k,v| v}\nend", " \
    \ nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits_sum = digits.inject(0) {|sum, digit| sum + digit}\n    if digits_sum\
    \ == nums.first\n      nums.swap(i, nums.index(digits_sum))\n    end\n  end\n\
    end", "  nums.sort!\n  nums.each_with_index do |num, i|\n    break if num == nums.last\n\
    \    break if nums.sum - num == nums.sum\n    nums[i] = num\n  end\nend", "  nums.sort!\n\
    \  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if nums.count(num) == nums.count(num)\
    \ + 1\n  end\nend\n</cell>\n<cell>", "  nums.sort!\n  nums.group_by { |x| x.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break if nums[i]\
    \ + nums[i+1] == nums[i] + nums[i+1]\n    nums[i], nums[i+1] = nums[i+1], nums[i]\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum =\
    \ 0\n    digits = num.to_s.chars.map(&:to_i)\n    digits.each do |d|\n      sum\
    \ += d\n    end\n    if num == sum\n      nums.delete(num)\n      nums.insert(nums.index(num),\
    \ num)\n    end\n  end\nend", "  nums.sort! do |a, b|\n    digits_a = a.to_s.chars.map(&:to_i)\n\
    \    digits_b = b.to_s.chars.map(&:to_i)\n    digits_a.zip(digits_b).map { |x,\
    \ y| x + y }.sum <=> x + y\n  end\nend", "  nums.sort!\n  nums.group_by { |n|\
    \ n.to_s.split(//).map(&:to_i).reduce(:+) }\nend", "  # TODO: Write your code\
    \ here\nend", "  # TODO: Write your code here\nend", "  nums.sort! { |a, b| a.to_i\
    \ + b.to_i }\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }.\n    sort_by { |_, v| v }.\n    map { |_, v| v }\nend", "  nums.sort!\n \
    \ nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits\
    \ = digits.inject(:+).to_s\n    if digits == nums[i].to_s.chars.map(&:to_i).inject(:+).to_s\n\
    \      nums[i] = n\n    end\n  end\nend\n</code>\n<|/ a |>\n<| c |>\nI like your\
    \ solution, but I wonder if there is a way to do it without using inject and to_s.\
    \ I guess it would be more efficient to convert the numbers to strings and then\
    \ sort them using sort_by.\n<|/ c |>\n<| c |>\nI added a solution without using\
    \ inject and to_s.\n<|/ c |>\n<| c |>\nI added a solution without using inject\
    \ and to_s.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums[i] == nums[i-1]\n\
    \    nums[i] = nums[i-1] + nums[i]\n  end\n  nums\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[12, 34, 56, 78, 90]`\n<|/ c |>\n\
    <| c |>\nIt works, I tested it before posting it. I just added a comment to the\
    \ code explaining what it does. I added a note to the question to explain why\
    \ it works.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `[12, 34, 56, 78,\
    \ 90]`\n<|/ c |>\n<| c |>\nIt works, I tested it before posting it. I just added\
    \ a comment to the code explaining what it does. I added a note to the question\
    \ to explain why it works.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `[12,\
    \ 34, 56, 78, 90]`\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    sum = 0\n    i = num\n    while i > 0\n      sum +=\
    \ i % 10\n      i /= 10\n    end\n    if sum > num\n      nums.swap(num, sum)\n\
    \    end\n  end\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.group_by { |x| x.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    if nums.count(n)\
    \ > 1\n      nums.delete_at(i)\n    end\n  end\nend", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums.sum - n == 0\n    nums[i] = nums.sum - n\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.map! {|x| x.to_i}\n  nums.sort_by {|x| x.digits.reduce(:+)}\n\
    end", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  # Your code here\nend", "  nums.sort! { |a, b| a.to_i + b.to_i }\n\
    end", "  nums.sort!\n  nums.group_by { |x| x.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.group_by { |x| x.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }.\n    sort_by { |_, v| v }.\n    map { |k, v| k }\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nI like your solution, although it does require a lot of memory\
    \ (O(n^2)).\n<|/ c |>\n<| c |>\nYes, it does require a lot of memory. That's why\
    \ I said \"sort by sum\" instead of \"sort by digits\". Sorting by digits is O(n*log(n))\
    \ and sorting by sum is O(n*n). Sorting by sum is faster than sorting by digits,\
    \ because sorting by digits requires O(n) memory and sorting by sum is faster\
    \ than sorting by digits, because sorting by digits requires O(n) memory and sorting\
    \ by sum is faster than sorting by digits, because sorting by digits requires\
    \ O(n) memory and sorting by sum is faster than sorting by digits, because sorting\
    \ by digits requires O(n) memory.\n<|/ c |>\n<| c |>\nI agree with you, my solution\
    \ requires O(n^2) memory. My solution requires O(n) memory because I used `group_by`\
    \ and `sort_by` methods. I didn't use any extra memory to sort by sum or by digits.\
    \ I used O(n) memory to sort by sum and O(n) memory to sort by digits. I didn't\
    \ use any extra memory to sort by sum or by digits. I used O(n) memory to sort\
    \ by sum and O(n) memory to sort by digits. I didn't use any extra memory to sort\
    \ by sum or by digits. I used O(n) memory to sort by sum and O(n) memory to sort\
    \ by digits. I didn't use any extra memory to sort by sum or by digits. I used\
    \ O(n) memory to sort by sum and O(n) memory to sort by digits. I didn't use any\
    \ extra memory to sort by sum or by digits. I used O(n) memory to sort by sum\
    \ and O(n) memory to sort by digits.\n<|/ c |>\n<| c |>\nI agree with you, my\
    \ solution requires O(n^2) memory. My solution requires O(n) memory because I\
    \ used `group_by` and `sort_by` methods. I didn't use any extra memory to sort\
    \ by sum or by digits. I used O(n) memory to sort by ", "  nums.sort! do |a, b|\n\
    \    sum1 = a.to_s.split(//).map(&:to_i).inject(:+)\n    sum2 = b.to_s.split(//).map(&:to_i).inject(:+)\n\
    \    sum1 > sum2 ? 1 : sum1 < sum2 ? -1 : 0\n  end\nend", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    if nums.count(n) > 1\n      nums.delete_at(i)\n    end\n  end\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,sorting,arrays |>\n<code>", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum = 0\n    digits =\
    \ num.to_s.split(//)\n    digits.each do |d|\n      sum += d.to_i\n    end\n \
    \   if sum > 0\n      nums.insert(nums.index(num), num)\n    end\n  end\nend",
  "  nums.sort!\n  nums.group_by {|n| n.to_s.split(//).map(&:to_i).sum}.\n    sort_by\
    \ {|_, v| v}.\n    map {|k, v| [k, *v]}.\n    to_h\nend", "  # +++your code here+++\n\
    end", "  nums.sort!\n  nums.group_by {|x| x.to_s.split(//).map(&:to_i).reduce(:+)}\n\
    end", "  # +++your code here+++\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  # TODO: Write your code here\nend", "  # TODO: Write your code here\n\
    end", "  # TODO: Write your code here\nend", "  # +++your code here+++\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums[i]\
    \ == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.each_with_index do\
    \ |n, i|\n    break if nums[i] + nums[i-1] > 9\n    nums[i] = nums[i] + nums[i-1]\n\
    \    nums[i-1] = n\n  end\nend\n</cell>\n<cell>\norder_by_points([-2, -1, 1, 2,\
    \ 3]) # => [-1, 1, 2, 3]\norder_by_points([3, 6, 9, 12, 15]) # => [3, 6, 9, 12,\
    \ 15]\norder_by_points([1, 2, 3, 6, 9]) # => [1, 2, 3, 6, 9]\n</cell>\n<text>\n\
    The first method we wrote is called sort_by, which sorts the given array by the\
    \ given key. The second method we wrote is called each_with_index, which iterates\
    \ over the given array and passes each element and its index to the given block.\
    \ Finally, we wrote the third method we wrote which is called sort, which sorts\
    \ the given array according to the order of the given block. Notice that sort_by\
    \ and each_with_index are similar, but sort is more powerful.", "  # Write your\
    \ code here.\nend", "  # Your code here\nend", "  nums.sort!\n  nums.group_by\
    \ { |x| x.to_s.split(//).map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n  nums.map!\
    \ {|n| n.to_i}\n  nums.each_with_index do |n, i|\n    digits = nums.map {|n| n.to_i}\n\
    \    digits[i] = digits[i] + i\n    nums[i] = digits.max\n  end\nend", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == nums[i-1]\n    nums[i]\
    \ = nums[i-1] + nums[i]\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ doesn't work if there are two numbers with the same sum.\n<|/ c |>\n<| c |>\n\
    Yes, you are right. I didn't think about that. I'll edit the answer.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "  nums.sort!\n  nums.each_with_index do |n, i|\n \
    \   break if nums[i] == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.group_by\
    \ { |n| n.to_s.split(//).map(&:to_i).reduce(:+) }.\n    sort_by { |_, v| v }.\n\
    \    map { |_, v| v }\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n\
    \    break if nums.count(n) == 1\n    nums[i] = nums.index(n) + i\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits_sum = digits.inject(0) {|sum, digit| sum + digit}\n    if digits_sum\
    \ == nums.first\n      nums[i] = i\n    end\n  end\n  nums\nend", "  # +++your\
    \ code here+++\nend", "  # TODO: Write your code here\nend", "  nums.sort!\n \
    \ nums.reverse!\n  nums.each_with_index do |num, index|\n    break if nums[index]\
    \ == num\n    nums[index] = num\n  end\n  nums\nend", "  # TODO: Write your code\
    \ here\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  # Your code here\nend", "  nums.sort!\n  nums.each_with_index do\
    \ |n, i|\n    digits = n.to_s.split(//).map(&:to_i)\n    digits_sum = digits.inject(0)\
    \ {|sum, digit| sum + digit}\n    if digits_sum > 0\n      nums[i] = n\n    end\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work if there are two or more numbers with the same sum.\n<|/ c |>\n\
    <| c |>\n: It does. I tested it before posting my answer. Try it yourself and\
    \ see for yourself.\n<|/ c |>\n<| c |>\nI tested it myself and found that it doesn't\
    \ work. Try it yourself and see for yourself.\n<|/ c |>\n<| c |>\n: I tested it\
    \ myself and found that it doesn't work. Try it yourself and see for yourself.\n\
    <|/ c |>\n<| c |>\n: I tested it myself and found that it doesn't work. Try it\
    \ yourself and see for yourself.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == nums[i-1]\n    nums[i]\
    \ = nums[i-1] + nums[i]\n  end\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.map!{|x| x.to_i}\n  nums.sort!\nend", "  nums.sort!\
    \ do |a, b|\n    sum1 = a.to_s.split(\"\").inject(0) {|sum, digit| sum + digit.to_i}\n\
    \    sum2 = b.to_s.split(\"\").inject(0) {|sum, digit| sum + digit.to_i}\n   \
    \ sum1 > sum2 ? 1 : -1\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, index|\n    if nums.count(num) == nums.count(nums[index])\n      nums[index],\
    \ nums[nums.index(num)] = nums[nums.index(num)], nums[index]\n    end\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.group_by {|n| n.to_s.split(//).map(&:to_i).reduce(:+)}\n\
    end", "  # Write your code here.\nend", "  nums.sort!\n  nums.each_with_index\
    \ do |num, i|\n    digits = num.to_s.chars.map(&:to_i)\n    digits_sum = digits.inject(:+)\n\
    \    if digits_sum > 0\n      nums[i] = num\n    end\n  end\nend\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't work if there are two or more numbers with the same\
    \ sum.\n<|/ c |>\n<| c |>\nYes, you're right. I didn't notice that case. I'll\
    \ fix it in a minute.\n<|/ c |>\n<| c |>\nI added a solution that handles multiple\
    \ numbers with the same sum.\n<|/ c |>\n<| c |>\nThank you so much! I really appreciate\
    \ it!\n<|/ c |>\n<| c |>\nI added a solution that handles multiple numbers with\
    \ the same sum.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.group_by {|x| x.to_s.split(//).map(&:to_i).reduce(:+)}\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't answer the question, which is asking\
    \ how to sort the list by sum of the digits, not by their position in the list.\n\
    <|/ c |>\n<| c |>\nI agree, my answer doesn't answer the question, but I thought\
    \ it might be helpful to someone who wants to sort by sum of the digits of the\
    \ numbers. I thought it might be helpful to someone who wants to sort by sum of\
    \ the digits of the numbers. I thought it might be helpful to someone who wants\
    \ to sort by sum of the digits of the numbers. I thought it might be helpful to\
    \ someone who wants to sort by sum of the digits of the numbers. I thought it\
    \ might be helpful to someone who wants to sort by sum of the digits of the numbers.\
    \ I thought it might be helpful to someone who wants to sort by sum of the digits\
    \ of the numbers. I thought it might be helpful to someone who wants to sort by\
    \ sum of the digits of the numbers. I thought it might be helpful to someone who\
    \ wants to sort by sum of the digits of the numbers. I thought it might be helpful\
    \ to someone who wants to sort by sum of the digits of the numbers. I thought\
    \ it might be helpful to someone who wants to sort by sum of the digits of the\
    \ numbers. I thought it might be helpful to someone who wants to sort by sum of\
    \ the digits of the numbers. I thought it might be helpful to someone who wants\
    \ to sort by sum of the digits of the numbers. I thought it might be helpful to\
    \ someone who wants to sort by sum of the digits of the numbers. I thought it\
    \ might be helpful to someone who wants to sort by sum of the digits of the numbers.\
    \ I thought it might be helpful to someone who wants to sort by sum of the digits\
    \ of the numbers. I thought it might be helpful to someone who wants to sort by\
    \ sum of the digits of the numbers. I thought it might be helpful to someone who\
    \ wants to sort by sum of the digits of the numbers. I thought it might be helpful\
    \ to someone who wants to sort by sum of the digits of the numbers. I thought\
    \ it might be helpful to someone who wants to sort by sum of the digits of the\
    \ numbers. I thought it might be helpful to someone who wants to sort by sum of\
    \ the digits of the numbers. I thought it might be helpful to someone who wants\
    \ to sort by sum of the digits of the numbers. I thought it might be helpful to\
    \ someone who wants to sort by sum of the digits of the numbers. I thought it\
    \ might be helpful to someone who wants to sort by sum of the digits of the numbers.\
    \ I thought it ", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break if nums[i]\
    \ == n\n    nums[i] = n\n  end\n  nums\nend", "  # Your code here\nend", "  #\
    \ TODO: Write your code here\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "    # Write your code here.\n    sums = nums.inject(Hash.new(0)) {\
    \ |sums, x| sums[x] += x }\n    nums.sort_by { |x| sums[x] }\nend", "  # +++your\
    \ code here+++\nend", "  # Your code here\nend", "  nums.sort!\n  nums.map! {|x|\
    \ x.to_i}\n  nums.group_by {|x| x.to_i}.sort_by {|_, v| v.size}.map {|_, v| v.first}\n\
    end", "  nums.sort!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).to_s\n    if nums.count(digits) > 1\n      nums.delete_at(i)\n\
    \    end\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if\
    \ there are multiple items with the same sum. For example, `[4, 8, 1, 3]` would\
    \ become `[4, 8, 3]` instead of `[4, 3]`.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ out. I've fixed the code accordingly.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  nums.sort!\n  nums.each_with_index do |num, i|\n    nums[i] = num if num.digits.sum\
    \ < num.digits.max\n  end\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.each_with_index do |num, i|\n    break if num\
    \ == nums.last\n    nums[i] = num if num.digits.sum < nums.last.digits.sum\n \
    \ end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't\
    \ work if there are two numbers with the same sum.\n<|/ c |>\n<| c |>\nYes, you\
    \ are right. I've updated my answer. Thanks.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.group_by { |x| x.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break if nums[i]\
    \ == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n  nums.group_by {|x| x.to_s.split(//).map(&:to_i).reduce(:+)}\n\
    end", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = nums.index\
    \ {|num| nums.sum == num}\n    nums[i] = num\n  end\nend", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.count(n) == 1\n    nums[i]\
    \ = nums.index(n) + i\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are two numbers with the same sum.\n\
    <|/ c |>\n<| c |>\nYes, you are right. I missed that case. Thanks for pointing\
    \ out. I've updated my answer.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>",
  "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+) }\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum = 0\n    i\
    \ = num\n    while i > 0\n      sum += i % 10\n      i /= 10\n    end\n    if\
    \ sum > num\n      nums.swap(num, sum)\n    end\n  end\nend", "  nums.sort!\n\
    \  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+) }\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI like your solution, but I wonder how it compares\
    \ to other solutions posted so far. Could you please elaborate on that?\n<|/ c\
    \ |>\n<| c |>\nI added some explanation to the answer. Hope it helps.\n<|/ c |>\n\
    <| c |>\nThanks for your explanation. Your solution is very elegant and I like\
    \ it very much. I am still wondering how it compares to other solutions posted\
    \ so far. Could you please elaborate on that?\n<|/ c |>\n<| c |>\nI added some\
    \ explanation to the answer. Hope it helps.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "    # Write your code here\n    sums = nums.inject(Hash.new(0))\
    \ { |sum, num| sum[num.to_s.to_i] += num; sum }\n    nums.sort_by { |num| sums[num.to_s.to_i]\
    \ }\nend", "  nums.sort! do |a, b|\n    digits_a = a.to_s.split(//).map(&:to_i)\n\
    \    digits_b = b.to_s.split(//).map(&:to_i)\n    digits_a.zip(digits_b).map {\
    \ |a, b| a + b }.sort <=> 0\n  end\nend", "  nums.sort!\n  nums.group_by { |n|\
    \ n.to_s.split(//).map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n  nums.group_by\
    \ { |x| x.to_s.split(//).map(&:to_i).reduce(:+) }\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums[i] == n\n    nums[i] = n\n  end\nend", "  # +++your code here+++\nend",
  "  nums.sort! { |a, b| a.to_i + b.to_i }\nend", "  # Your code here\nend", "  #\
    \ Your code here\nend", "  nums.sort!\n  nums.group_by { |n| n.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.group_by { |x| x.to_s.split(//).map(&:to_i).reduce(:+)\
    \ }\nend", "  # TODO: Write your code here\nend", "  nums.sort!\n  nums.group_by\
    \ { |x| x.to_s.split(//).map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n  nums.group_by\
    \ { |n| n.to_s.split(//).map(&:to_i).reduce(:+) }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |i|\n    sum = 0\n    while i > 0\n      sum += i % 10\n     \
    \ i /= 10\n    end\n    sum\n  end\nend", "  nums.sort!\n  nums.group_by { |x|\
    \ x.to_s.split(//).map(&:to_i).reduce(:+) }\nend", "  # Your code here\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
