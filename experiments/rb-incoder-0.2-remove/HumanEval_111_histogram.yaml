name: HumanEval_111_histogram
language: rb
prompt: "# Given a string representing a space separated lowercase letters, return\
  \ a dictionary\n# of the letter with the most repetition and containing the corresponding\
  \ count.\n# If several letters have the same occurrence, return all of them.\n#\
  \ Example:\ndef histogram(test)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_histogram\n\
  \    candidate = method(:histogram)\n    assert_equal({\"a\" => 2, \"b\" => 2},\
  \ candidate.call(\"a b b a\"))\n    assert_equal({\"a\" => 2, \"b\" => 2}, candidate.call(\"\
  a b c a b\"))\n    assert_equal({\"a\" => 1, \"b\" => 1, \"c\" => 1, \"d\" => 1,\
  \ \"g\" => 1}, candidate.call(\"a b c d g\"))\n    assert_equal({\"r\" => 1, \"\
  t\" => 1, \"g\" => 1}, candidate.call(\"r t g\"))\n    assert_equal({\"b\" => 4},\
  \ candidate.call(\"b b b b a\"))\n    assert_equal({\"r\" => 1, \"t\" => 1, \"g\"\
  \ => 1}, candidate.call(\"r t g\"))\n    assert_equal({}, candidate.call(\"\"))\n\
  \    assert_equal({\"a\" => 1}, candidate.call(\"a\"))\n  end\nend\n"
completions: ["  result = {}\n  test.split(' ').each do |letter|\n    result[letter]\
    \ = result[:letter] || 0\n    result[letter] += 1\n  end\n  result\nend", "  test.split('\
    \ ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=ruby,arrays |>\n<code>", "    letters = test.split(' ')\n    letters.map!\
    \ { |letter| letter = letter.downcase }\n    letters.group_by{|letter| letter}.map{|letter,\
    \ occurrences| [letter, occurrences.count]}\nend\n</code>\n<|/ a tags=ruby,arrays,hash\
    \ |>\n<| c |>\n`letters.group_by{|letter| letter}.map{|letter, occurrences| [letter,\
    \ occurrences.count]}` can be simplified to `letters.group_by{|letter| letter}.map{|letter,\
    \ occurrences| [letter, occurrences.size]}`.\n<|/ c |>\n<| c |>\nThanks, I didn't\
    \ know that. I've updated the answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", " \
    \ result = {}\n  test.split(' ').each do |letter|\n    result[letter] ||= 0\n\
    \    result[letter] += 1\n  end\n  result\nend", "  letters = test.split\n  counts\
    \ = Hash.new(0)\n  letters.each do |letter|\n    counts[letter] += 1\n  end\n\
    \  counts.max_by { |k, v| v }\nend", "  result = {}\n  test.split(' ').each do\
    \ |letter|\n    if result[letter] == nil\n      result[letter] = 1\n    else\n\
    \      result[letter] += 1\n    end\n  end\n  result\nend", "  test.split(' ').inject(Hash.new(0)){|h,x|\
    \ h[x] += 1; h}.max_by {|k,v| v}\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend", "  test.split(' ').inject(Hash.new(0)){|h,x| h[x]\
    \ += 1; h}\nend", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h\
    \ }\nend", "  result = {}\n  test.split(' ').each do |letter|\n    letter = letter.downcase\n\
    \    result[letter] = result[:letter] || 0\n    result[letter] += 1\n  end\n \
    \ result\nend\n</code>\n<|/ a tags=ruby,arrays,hash |>\n<| c |>\nI like your solution,\
    \ but I believe that `result[:letter]` should be `result[letter]`\n<|/ c |>\n\
    <| c |>\nYes, you are right. Thanks for pointing that out. Fixed now.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x]\
    \ += 1 }\nend", "  result = {}\n  test.split(' ').each do |letter|\n    letter\
    \ = letter.downcase\n    if result.has_key?(letter)\n      result[letter] += 1\n\
    \    else\n      result[letter] = 1\n    end\n  end\n  result\nend", "  letters\
    \ = test.split(' ')\n  letters.each do |letter|\n    letter = letter.downcase\n\
    \    letters[letter] = letters[letter].to_i + 1\n  end\n  letters.max_by {|k,\
    \ v| v}\nend", "  result = {}\n  test.split(' ').each do |letter|\n    if result.has_key?(letter)\n\
    \      result[letter] += 1\n    else\n      result[letter] = 1\n    end\n  end\n\
    \  result\nend", "    letters = test.split(' ') \n    letters.each do |letter|\n\
    \        letters[letter] = letters[letter].to_i\n    end\n    letters.sort_by{|k,\
    \ v| v}.reverse.to_h\nend", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x]\
    \ += 1; h }\nend", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1 }\n\
    end", "  result = {}\n  test.split(' ').each do |letter|\n    letter = letter.downcase\n\
    \    result[letter] = result[:letter] || 0\n    result[letter] += 1\n  end\n \
    \ result\nend", "  result = {}\n  test.split(' ').each do |letter|\n    result[letter]\
    \ = result[:letter] || 0\n    result[letter] += 1\n  end\n  result\nend", "  result\
    \ = {}\n  test.split(' ').each do |letter|\n    result[letter] = result[:letter]\
    \ || 0\n    result[letter] += 1\n  end\n  result\nend", "  result = {}\n  test.split('\
    \ ').each do |letter|\n    result[letter] = result[:letter] || 0\n    result[letter]\
    \ += 1\n  end\n  result\nend", "  letters = test.split(' ')\n  letters.map! {\
    \ |letter| letter = letter.downcase }\n  letters.group_by{|letter| letter}.map{|letter,\
    \ occurrences| [letter, occurrences.count] }.sort_by{|letter, occurrences| -occurrences.count}.first\n\
    end", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1; h }\nend", " \
    \   count = {}\n    letters = test.split\n    letters.each do |letter|\n     \
    \   count[letter] = count[letter].to_i + 1 if count.has_key?(letter)\n    end\n\
    \    count.sort_by {|k, v| v}.reverse.each do |k, v|\n        puts \"#{k} : #{v}\"\
    \n    end\nend", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n\
    end", "  result = {}\n  test.split(' ').each do |letter|\n    letter = letter.downcase\n\
    \    result[letter] ||= 0\n    result[letter] += 1\n  end\n  result\nend", " \
    \ letters = test.split('')\n  result = {}\n  letters.each do |letter|\n    letter\
    \ = letter.downcase\n    if result.has_key?(letter)\n      result[letter] += 1\n\
    \    else\n      result[letter] = 1\n    end\n  end\n  result\nend", "  result\
    \ = {}\n  test.split(' ').each do |letter|\n    letter = letter.downcase\n   \
    \ if result.has_key?(letter)\n      result[letter] += 1\n    else\n      result[letter]\
    \ = 1\n    end\n  end\n  result\nend", "  letters = test.split('').map(&:downcase)\n\
    \  letters.group_by { |letter| letter }.max_by { |letter, count| count }.map {\
    \ |letter, count| [letter, count] }\nend", "    letters = {}\n    letters.merge!(Hash.new(0))\
    \ # initialize a new hash\n    test.split(' ').each do |letter|\n        letters[letter]\
    \ += 1\n    end\n    letters.max_by { |k, v| v }\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c\
    \ |>\nI like this solution, but I believe it would be more efficient to just use\
    \ `Hash.new(0)` instead of `Hash.new{|h,k| h[k] = 0}`\n<|/ c |>\n<| c |>\n: Yes,\
    \ that's a good point. I was just trying to keep it close to the OP's original\
    \ code.\n<|/ c |>\n<| c |>\nI like this solution as well, but I believe it would\
    \ be more efficient to just use `Hash.new(0)` instead of `Hash.new{|h,k| h[k]\
    \ = 0}`\n<|/ c |>\n<| c |>\n: Yes, that's a good point. I was just trying to keep\
    \ it close to the OP's original code.\n<|/ c |>\n<| a dscore=2 |>\n<code>", " \
    \ result = {}\n  test.split(' ').each do |letter|\n    result[letter] ||= 0\n\
    \    result[letter] += 1\n  end\n  result\nend", "  letters = test.split\n  letters.each\
    \ do |letter|\n    letters[letter] = letters[letter].to_i\n  end\n  letters.sort_by\
    \ {|k, v| v}.reverse.group_by(&:first).map {|k, v| [k, v.size]}\nend", "  test.split('\
    \ ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inje", "  test.split(' ').group_by{|x| x}.map{|k,v| [k, v.count]}.max_by{|k,v|\
    \ v}\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  test.split('\
    \ ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\nend", "  result = {}\n  test.split('\
    \ ').each do |letter|\n    result[letter] = result[:letter] || 0\n    result[letter]\
    \ += 1\n  end\n  result\nend", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    result[letter] = result[:letter] || 0\n    result[letter] += 1\n  end\n \
    \ result\nend", "  test.split(' ').group_by{|x| x}.map{|k, v| [k, v.size]}.max_by{|k,\
    \ v| v}\nend", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\nend",
  "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThanks so much for the help! I really appreciate it!\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>", "  letters\
    \ = test.split(' ')\n  letters.each do |letter|\n    letters[letter] = letters[letter].to_i\n\
    \  end\n  letters.sort.reverse.inject({}) do |memo, letter|\n    memo[letter]\
    \ ||= 0\n    memo[letter] += 1\n    memo\n  end\nend", "  result = {}\n  test.split('\
    \ ').each do |letter|\n    result[letter] = result[:letter] || 0\n    result[letter]\
    \ += 1\n  end\n  result\nend", "  letters = test.split\n  hash = {}\n  letters.each\
    \ do |letter|\n    hash[letter] = hash[letter].to_i + 1\n  end\n  hash\nend",
  "  hash = {}\n  test.split(' ').each do |letter|\n    hash[letter] ||= 0\n    hash[letter]\
    \ += 1\n  end\n  hash\nend", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    if result[letter]\n      result[letter] += 1\n    else\n      result[letter]\
    \ = 1\n    end\n  end\n  result\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inje", "  hash = {}\n  test.split(' ').each do |letter|\n    hash[letter]\
    \ ||= 0\n    hash[letter] += 1\n  end\n  hash\nend", "  test.split(' ').inject(Hash.new(0)){|h,x|\
    \ h[x] += 1; h}\nend", "  test.split(' ').group_by{|x| x}.map{|k, v| [k, v.size]}.max_by{|k,\
    \ v| v}\nend", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1; h }\n\
    end", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inje", "  result = {}\n  test.split('\
    \ ').each do |letter|\n    result[letter] ||= 0\n    result[letter] += 1\n  end\n\
    \  result\nend", "  letters = test.split(' ').map { |l| l.downcase }\n  letters.group_by\
    \ { |l| l }.map { |k, v| [k, v.count] }.max_by { |k, v| v }\nend", "  test.split('\
    \ ').inject(Hash.new(0)) { |h, x| h[x] += 1 }\nend", "  hash = {}\n  test.split('\
    \ ').each do |letter|\n    hash[letter] ||= 0\n    hash[letter] += 1\n  end\n\
    \  hash\nend", "  test.split(' ').group_by{|x| x}.map{|k, v| [k, v.size]}.max_by{|k,\
    \ v| v}\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. `group_by`\
    \ returns a hash, which doesn't have a `max_by` method.\n<|/ c |>\n<| c |>\nYes,\
    \ I realized that after I posted it. I edited my answer to fix it.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  result = Hash.new(0)\n  test.split(' ').each do\
    \ |letter|\n    result[letter] += 1 if result.has_key?(letter)\n  end\n  result\n\
    end", "  result = {}\n  test.split(' ').each do |letter|\n    letter = letter.downcase\n\
    \    if result.has_key?(letter)\n      result[letter] += 1\n    else\n      result[letter]\
    \ = 1\n    end\n  end\n  result\nend", "  result = {}\n  test.split(' ').each\
    \ do |letter|\n    result[letter] = result[:letter] || 0\n    result[letter] +=\
    \ 1\n  end\n  result\nend", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x]\
    \ += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1\
    \ }\n  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\n  test.split(' ').inje", "  test.split('\
    \ ').inject(Hash.new(0)) { |h, x| h[x] += 1 }\nend", "    letters = test.split('\
    \ ')\n    count = {}\n    letters.each do |letter|\n        if letter in count\n\
    \            count[letter] += 1\n        else\n            count[letter] = 1\n\
    \        end\n    end\n    count.sort_by {|k, v| v}.reverse.each do |k, v|\n \
    \       puts \"#{k} : #{v}\"\n    end\nend", "  hash = {}\n  test.split(' ').each\
    \ do |letter|\n    hash[letter] ||= 0\n    hash[letter] += 1\n  end\n  hash\n\
    end", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\nend", " \
    \ test.split(' ').inject(Hash.new(0)){|h, x| h[x] += 1; h}\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=ruby,arrays,hash |>\n<code>", "  result = {}\n  test.split('\
    \ ').each do |letter|\n    result[letter] = result[:letter] || 0\n    result[letter]\
    \ += 1\n  end\n  result\nend", "  hash = {}\n  test.split.each do |letter|\n \
    \   hash[letter] ||= 0\n    hash[letter] += 1\n  end\n  hash\nend", "  test.split('\
    \ ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,string |>\n<code>", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    if result[letter] == nil\n      result[letter] = 1\n    else\n      result[letter]\
    \ += 1\n    end\n  end\n  result\nend", "  result = {}\n  test.split(' ').each\
    \ do |letter|\n    letter = letter.downcase\n    if result.has_key?(letter)\n\
    \      result[letter] += 1\n    else\n      result[letter] = 1\n    end\n  end\n\
    \  result\nend", "  test.split(' ').inject(Hash.new(0)){|h,x| h[x] += 1; h}.max_by\
    \ {|k,v| v}\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nI like the\
    \ inject method but you might want to use each_with_object instead of inject.\
    \ inject is more efficient for small arrays but each_with_object is more efficient\
    \ for large arrays.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I had forgotten\
    \ about each_with_object.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>",
  "  letters = test.split('').sort\n  counts = Hash.new(0)\n  letters.each do |letter|\n\
    \    counts[letter] += 1 if counts[letter].zero?\n  end\n  counts\nend", "  letters\
    \ = test.split('')\n  frequencies = Hash.new(0)\n  letters.each do |letter|\n\
    \    frequencies[letter] += 1\n  end\n  frequencies.sort_by { |k, v| v }.reverse.to_h\n\
    end", "  result = {}\n  test.split(' ').each do |letter|\n    if result[letter]\
    \ == nil\n      result[letter] = 1\n    else\n      result[letter] += 1\n    end\n\
    \  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,hash |>\n<| c |>\n`test.split('\
    \ ').group_by{|x| x}.max_by{|k,v| v}` would be more concise.\n<|/ c |>\n<| c |>\n\
    Thanks, I didn't know about `group_by` method. Updated my answer.\n<|/ c |>\n\
    <| c |>\n`group_by` was introduced in Ruby 2.2. For older versions, you can do\
    \ `test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1; h }`.\n<|/ c |>\n<|\
    \ c |>\nThanks, I didn't know about `inject` method. Updated my answer.\n<|/ c\
    \ |>\n<| a dscore=0 |>\n<code>", "  letters = test.split(' ')\n  letters.each\
    \ do |letter|\n    letters[letter] = letters[letter].to_i\n  end\n  letters.sort_by{|k,\
    \ v| v}.reverse.group_by{|k, v| k}.map{|k, v| [k, v.length]}\nend", "  letters\
    \ = test.split('').map { |c| c.downcase }\n  letters.group_by { |c| c }.map {\
    \ |k, v| [k, v.count] }.max_by { |k, v| v }\nend", "  result = {}\n  test.split('\
    \ ').each do |letter|\n    letter = letter.downcase\n    if result.has_key?(letter)\n\
    \      result[letter] += 1\n    else\n      result[letter] = 1\n    end\n  end\n\
    \  result\nend", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h\
    \ }\nend", "  result = {}\n  test.split(' ').each do |letter|\n    result[letter]\
    \ ||= 0\n    result[letter] += 1\n  end\n  result\nend", "  result = Hash.new(0)\n\
    \  test.split(' ').each do |letter|\n    result[letter] += 1\n  end\n  result\n\
    end", "  letters = test.split(' ')\n  letters.map!{|x| x.downcase}\n  letters.map!{|x|\
    \ x.count('a')}\n  letters.map!{|x| x.count('e')}\n  letters.map!{|x| x.count('i')}\n\
    \  letters.map!{|x| x.count('o')}\n  letters.map!{|x| x.count('u')}\n  letters.map!{|x|\
    \ x.count('y')}\n  letters.map!{|x| x.count('h')}\n  letters.map!{|x| x.count('l')}\n\
    \  letters.map!{|x| x.count('o')}\n  letters.map!{|x| x.count('r')}\n  letters.map!{|x|\
    \ x.count('d')}\n  letters.map!{|x| x.count('s')}\n  letters.map!{|x| x.count('t')}\n\
    \  letters.map!{|x| x.count('c')}\n  letters.map!{|x| x.count('k')}\n  letters.map!{|x|\
    \ x.count('g')}\n  letters.map!{|x| x.count('p')}\n  letters.map!{|x| x.count('f')}\n\
    \  letters.map!{|x| x.count('v')}\n  letters.map!{|x| x.count('b')}\n  letters.map!{|x|\
    \ x.count('n')}\n  letters.map!{|x| x.count('m')}\n  letters.map!{|x| x.count('q')}\n\
    \  letters.map!{|x| x.count('j')}\n  letters.map!{|x| x.count('x')}\n  letters.map!{|x|\
    \ x.count('z')}\n  letters.map!{|x| x.count('r')}\n  letters.map!{|x| x.count('w')}\n\
    \  letters.map!{|x| x.count('v')}\n  letters.map!{|x| x.count('u')}\n  letters.map!{|x|\
    \ x.count('t')}\n  letters.map!{|", "  letters = test.split\n  letters.map! {\
    \ |letter| letter = letter.downcase }\n  letters.group_by { |letter| letter }.max_by\
    \ { |letter, count| count }.map { |letter, count| [letter, count] }\nend", " \
    \ test.split(' ').inject(Hash.new(0)){|h,x| h[x] += 1; h}\nend\n</code>\n<|/ a\
    \ tags=ruby,hash,arrays |>\n<| c |>\nI like this solution, although I wouldn't\
    \ use inject for this. I'd use each_with_object instead. Also, I'd use map instead\
    \ of inject for this. I'd also use each_with_object instead of inject for this.\
    \ I'd also use each_with_object instead of inject for this. I'd also use each_with_object\
    \ instead of inject for this. I'd also use each_with_object instead of inject\
    \ for this. I'd also use each_with_object instead of inject for this. I'd also\
    \ use each_with_object instead of inject for this. I'd also use each_with_object\
    \ instead of inject for this. I'd also use each_with_object instead of inject\
    \ for this. I'd also use each_with_object instead of inject for this. I'd also\
    \ use each_with_object instead of inject for this. I'd also use each_with_object\
    \ instead of inject for this. I'd also use each_with_object instead of inject\
    \ for this. I'd also use each_with_object instead of inject for this. I'd also\
    \ use each_with_object instead of inject for this. I'd also use each_with_object\
    \ instead of inject for this. I'd also use each_with_object instead of inject\
    \ for this. I'd also use each_with_object instead of inject for this. I'd also\
    \ use each_with_object instead of inject for this. I'd also use each_with_object\
    \ instead of inject for this. I'd also use each_with_object instead of inject\
    \ for this. I'd also use each_with_object instead of inject for this. I'd also\
    \ use each_with_object instead of inject for this. I'd also use each_with_object\
    \ instead of inject for this. I'd also use each_with_object instead of inject\
    \ for this. I'd also use each_with_object instead of inject for this. I'd also\
    \ use each_with_object instead of inject for this. I'd also use each_with_object\
    \ instead of inject for this. I'd also use each_with_object instead of inject\
    \ for this. I'd also use each_with_object instead of inject for this. I'd also\
    \ use each_with_object instead of inject for this. I'd also use each_with_object\
    \ instead of inject for this. I'd also use each_with_object instead of inject\
    \ for this. I'd also use each_with_object instead of inject for this. I'd also\
    \ use each_with_object instead of inject for this. I'd also use each_with_object\
    \ instead of inject for this. I'd also use each_with_object instead of inject\
    \ for this. I'd also use each_with_object instead of inject for this. I'd also\
    \ use each_with_object instead of inject for this. I'd also use each_with_object\
    \ instead of inject for this. I'd also use each_with_object instead of inject\
    \ for this. ", "  result = {}\n  test.split(' ').each do |letter|\n    result[letter]\
    \ = result[:letter] || 0\n    result[letter] += 1\n  end\n  result\nend", "  letters\
    \ = test.split(' ')\n  letters.each do |letter|\n    letters[letter] = letters[letter].to_i\n\
    \  end\n  letters.sort_by { |k, v| v }.reverse.inject({}) do |memo, pair|\n  \
    \  memo[pair[0]] = pair[1]\n    memo\n  end\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend", "  test.split(' ').group_by{|x| x}.map{|k, v|\
    \ [k, v.count]}.max_by{|k, v| v}\nend\n</code>\n<|/ a tags=ruby,arrays,hash,ruby-on-rails\
    \ |>\n<| c |>\nThanks for your answer. I am getting an error when running this\
    \ code: undefined method `group_by' for #<String:0x0000000529fcc8>\n<|/ c |>\n\
    <| c |>\nI forgot to add `split` before `group_by`. Try it now.\n<|/ c |>\n<|\
    \ c |>\nThanks again. Now I am getting this error: undefined method `group_by'\
    \ for #<String:0x0000000529fcc8>\n<|/ c |>\n<| c |>\nI forgot to add `split` before\
    \ `group_by`. Try it now.\n<|/ c |>\n<| c |>\nThanks again. Now I am getting this\
    \ error: undefined method `group_by' for #<String:0x0000000529fcc8>\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  letters = test.split\n  letters.each do |letter|\n\
    \    letters[letter] = letters[letter].to_i\n  end\n  letters.sort_by{|k, v| v}.reverse.inject({})\
    \ do |memo, pair|\n    memo[pair[0]] = pair[1]\n    memo\n  end\nend", "  result\
    \ = {}\n  test.split(' ').each do |letter|\n    letter = letter.downcase\n   \
    \ result[letter] = result[:letter] || 0\n    result[letter] += 1\n  end\n  result\n\
    end", "  test.split(' ').inject(Hash.new(0)){|h,x| h[x] += 1; h}\nend", "  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=0 |>\n<code>", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    result[letter] ||= 0\n    result[letter] += 1\n  end\n  result\nend", " \
    \ letters = test.split(' ')\n  letters.map! { |letter| letter = letter.downcase\
    \ }\n  letters.group_by{|letter| letter}.map{|letter, occurrences| [letter, occurrences.count]}\n\
    end", "  letters = test.split('').sort\n  counts = Hash.new(0)\n  letters.each\
    \ do |letter|\n    counts[letter] += 1\n  end\n  counts\nend", "  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    letter = letter.downcase\n    if result[letter].nil?\n      result[letter]\
    \ = 1\n    else\n      result[letter] += 1\n    end\n  end\n  result\nend", " \
    \ result = {}\n  test.split(' ').each do |letter|\n    result[letter] = result[:letter]\
    \ || 0\n    result[letter] += 1\n  end\n  result\nend", "  result = {}\n  test.split('\
    \ ').each do |letter|\n    letter = letter.downcase\n    result[letter] ||= 0\n\
    \    result[letter] += 1\n  end\n  result\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend", "  letters = test.split('').sort\n  frequencies\
    \ = Hash.new(0)\n  letters.each do |letter|\n    frequencies[letter] += 1\n  end\n\
    \  frequencies.max_by { |letter, count| count }\nend", "  letters = test.split('\
    \ ').map(&:downcase).uniq.sort\n  counts = letters.inject(Hash.new(0)) { |h,l|\
    \ h[l] += 1; h }\n  letters.map { |l| [l, counts[l]] }.sort_by { |l| -counts[l]}.first(10)\n\
    end", "    letters = test.split(' ')\n    letters.map!{|letter| letter}\n    letters.group_by{|letter|\
    \ letter}.map{|letter, occurrences| [letter, occurrences.count]}.sort_by{|letter,\
    \ occurrences| -occurrences}.reverse\nend\n</code>\n<|/ a tags=ruby,arrays,string\
    \ |>\n<| a tags=ruby,arrays,string |>\n<code>", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    result[letter] = result[:letter] || 0\n    result[letter] += 1\n  end\n \
    \ result\nend", "  result = {}\n  test.split(' ').each do |letter|\n    letter\
    \ = letter.downcase\n    if result.has_key?(letter)\n      result[letter] += 1\n\
    \    else\n      result[letter] = 1\n    end\n  end\n  result\nend", "    letters\
    \ = test.split(' ')\n    letters.map! { |l| l.downcase }\n    letters.group_by{|l|\
    \ l}.map{|k, v| [k, v.count]}.sort_by{|k, v| v}.last\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend", "  test.split(' ').group_by{|x| x}.max_by{|x|\
    \ x.count}\nend", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1 }\n\
    end", "  hash = {}\n  test.split(' ').each do |letter|\n    hash[letter] ||= 0\n\
    \    hash[letter] += 1\n  end\n  hash\nend", "  result = {}\n  test.split(' ').each\
    \ do |letter|\n    result[letter] = result[:letter] || 0\n    result[letter] +=\
    \ 1\n  end\n  result\nend", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    result[letter] = result[:letter] || 0\n    result[letter] += 1\n  end\n \
    \ result\nend", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\n\
    end", "    hash = {}\n    test.split(' ').each do |letter|\n        hash[letter]\
    \ = hash[letter].to_i + 1 if hash[letter].nil?\n        hash[letter] = hash[letter].to_i\
    \ + 1 if hash[letter].to_i > hash[letter]\n    end\n    hash.sort_by {|k, v| v}.reverse.to_h\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  test.split(' ').inject(Hash.new(0)){|h,x|\
    \ h[x] += 1; h}\nend", "  letters = test.split(' ').map { |letter| letter[0].downcase\
    \ }\n  letters.inject(Hash.new(0)) { |memo, letter| memo[letter] += 1 }\n  letters.sort_by\
    \ { |letter| -memo[letter] }\nend", "  test.split(' ').inject(Hash.new(0)) { |h,x|\
    \ h[x] += 1; h }\nend", "  result = {}\n  test.split(' ').each do |letter|\n \
    \   if result[letter] == nil\n      result[letter] = 1\n    else\n      result[letter]\
    \ += 1\n    end\n  end\n  result\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h, x| h[x] += 1; h }\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like this\
    \ solution, but I wonder if there's a way to do it without having to use inject\
    \ (which I haven't learned yet).\n<|/ c |>\n<| c |>\nI added a solution without\
    \ `inject`\n<|/ c |>\n<| a tags=ruby,hash |>\n<code>", "  result = {}\n  test.split('\
    \ ').each do |letter|\n    result[letter] ||= 0\n    result[letter] += 1\n  end\n\
    \  result\nend", "  result = {}\n  test.split(' ').each do |letter|\n    result[letter]\
    \ = result[:letter] || 0\n    result[letter] += 1\n  end\n  result\nend", "  result\
    \ = {}\n  test.split(' ').each do |letter|\n    letter = letter.downcase\n   \
    \ if result.has_key?(letter)\n      result[letter] += 1\n    else\n      result[letter]\
    \ = 1\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\nI like your solution. One thing though, `each_with_object` returns an enumerator,\
    \ so you might want to call `to_a` on it before returning it.\n<|/ c |>\n<| c\
    \ |>\n: Thanks, I didn't know about `each_with_object`. I added a note about it.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "    count = {}\n    test.split(' ').each\
    \ do |letter|\n        if count.has_key?(letter)\n            count[letter] +=\
    \ 1\n        else\n            count[letter] = 1\n        end\n    end\n    count.sort_by{|k,\
    \ v| v}.reverse.first\nend", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    result[letter] = result[:letter] || 0\n    result[letter] += 1\n  end\n \
    \ result\nend", "  result = {}\n  test.split(' ').each do |letter|\n    if result[letter]\
    \ == nil\n      result[letter] = 1\n    else\n      result[letter] += 1\n    end\n\
    \  end\n  result\nend", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] +=\
    \ 1; h }\nend", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1; h }\n\
    end", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\n`inject(Hash.new(0)) { |h, x| h[x] += 1; h }` can\
    \ be written as `inject(Hash.new(0)) { |h, x| h[x] += 1 }`.\n<|/ c |>\n<| c |>\n\
    Thanks, I didn't know that. I've updated my answer.\n<|/ c |>\n<| a tags=ruby,hash,arrays\
    \ |>\n<code>", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1; h }\n\
    end", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nI like your solution, but I believe it can be simplified\
    \ to `test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }`. Also, I think\
    \ `inject` can be replaced with `each_with_object`.\n<|/ c |>\n<| c |>\nI agree,\
    \ `each_with_object` would be better. I've edited my answer.\n<|/ c |>\n<| c |>\n\
    `each_with_object` would also work, but I find it less readable. `inject` makes\
    \ it more readable and more concise.\n<|/ c |>\n<| a tags=ruby |>\n<code>", " \
    \ result = Hash.new(0)\n  test.split(' ').each do |letter|\n    result[letter]\
    \ += 1 unless result.has_key?(letter)\n  end\n  result\nend", "  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1; h }\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI like this solution, however it seems that it only works with\
    \ strings. I tried to modify it so that it works with arrays, but I couldn't get\
    \ it to work. Do you know how I could modify it to work with arrays?\n<|/ c |>\n\
    <| c |>\n: I added a version that works with arrays. I hope it helps.\n<|/ c |>\n\
    <| c |>\nThanks for the help! I really appreciate it!\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  result = {}\n  test.split(' ').each do |letter|\n    result[letter]\
    \ = result[:letter] || 0\n    result[letter] += 1\n  end\n  result\nend", "  result\
    \ = Hash.new(0)\n  test.split(' ').each do |letter|\n    result[letter] += 1 if\
    \ result[:letter] == 0\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThanks for the help. I understand what you are saying but I am not able\
    \ to get it to work. I tried the code you provided but I am getting an error \"\
    undefined method `each' for nil:NilClass\" when I run it. I am not sure what I\
    \ am doing wrong. I am new to Ruby so I am not really sure what I am doing wrong.\n\
    <|/ c |>\n<| c |>\nI edited my answer to include a full working example. Let me\
    \ know if that helps.\n<|/ c |>\n<| c |>\nThanks for the help. I understand what\
    \ you are saying but I am not able to get it to work. I tried the code you provided\
    \ but I am getting an error \"undefined method `each' for nil:NilClass\" when\
    \ I run it. I am not sure what I am doing wrong. I am new to Ruby so I am not\
    \ really sure what I am doing wrong.\n<|/ c |>\n<| c |>\nI edited my answer to\
    \ include a full working example. Let me know if that helps.\n<|/ c |>\n<| c |>\n\
    Thanks for the help. I understand what you are saying but I am not able to get\
    \ it to work. I tried the code you provided but I am getting an error \"undefined\
    \ method `each' for nil:NilClass\" when I run it. I am not sure what I am doing\
    \ wrong. I am new to Ruby so I am not really sure what I am doing wrong.\n<|/\
    \ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI\
    \ like your use of inject and Hash.new(0). Very clever!\n<|/ c |>\n<| c |>\nI\
    \ like your use of inject and Hash.new(0). Very clever!\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  letters = test.split('')\n  letters.map! { |letter| letter =\
    \ letter.downcase }\n  letters.group_by{|letter| letter}.map{|letter, occurrences|\
    \ [letter, occurrences.count] }.max_by{|k, v| v}\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like this\
    \ solution, but I wonder why you used `inject` instead of `each_with_object`?\n\
    <|/ c |>\n<| c |>\n`each_with_object` would not work, since it returns an object\
    \ that would need to be collected into an array. `inject` would work fine, since\
    \ it returns the same object as its receiver.\n<|/ c |>\n<| c |>\nI see, thanks.\
    \ I didn't know about `each_with_object`.\n<|/ c |>\n<| a tags=ruby |>\n<code>",
  "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\nend\n</code>\n<|/ a\
    \ tags=ruby,ruby-on-rails |>\n<| c |>\nThanks for your answer. I am new to ruby,\
    \ so I appreciate your help. I tried to run your code, but I got an error saying\
    \ \"undefined method `split' for nil:NilClass\". Any idea why this happened?\n\
    <|/ c |>\n<| c |>\nI figured it out. I had to put a space between the two strings.\
    \ Thanks again!\n<|/ c |>\n<| c |>\nI added a space between the two strings and\
    \ it worked. Thanks again!\n<|/ c |>\n<| c |>\nI added a space between the two\
    \ strings and it worked. Thanks again!\n<|/ c |>\n<| a dscore=0 |>\n<code>", " \
    \ result = {}\n  test.split(' ').each do |letter|\n    if result[letter] == nil\n\
    \      result[letter] = 1\n    else\n      result[letter] += 1\n    end\n  end\n\
    \  result\nend", "  letters = test.split(' ')\n  letters.map!{|letter| letter}\n\
    \  letters.group_by{|letter| letter}.map{|letter, occurrences| [letter, occurrences.count]}\n\
    end\n</code>\n<|/ a tags=ruby,arrays,hash |>\n<| a tags=ruby,arrays,hash |>\n\
    <code>", "  result = {}\n  test.split(' ').each do |letter|\n    result[letter]\
    \ ||= 0\n    result[letter] += 1\n  end\n  result\nend", "  result = {}\n  test.split('\
    \ ').each do |letter|\n    if result[letter] == nil\n      result[letter] = 1\n\
    \    else\n      result[letter] += 1\n    end\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nI like your solution, but I believe it would\
    \ be better to use a hash to store the counts rather than an array. `counts =\
    \ test.split(' ').inject(Hash.new(0)) { |h,c| h[c] += 1; h }`.\n<|/ c |>\n<| c\
    \ |>\nYes, I agree with you. I just wanted to show a possible solution with an\
    \ array. Thanks for your comment.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  letters\
    \ = test.split(' ')\n  letters.each do |letter|\n    letters[letter] = letters[letter].to_i\n\
    \  end\n  letters.group_by {|k, v| k}.max_by {|k, v| v}.map {|k, v| [k, v]}\n\
    end", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\nend", " \
    \ letters = test.split(' ')\n  letters.map!{|letter| letter}\n  letters.sort!\n\
    \  letters.uniq!\n  letters.map!{|letter| [letter, letters.count(letter)]}\n \
    \ letters.max_by{|letter, count| count}\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend\n</code>\n<|/ a tags=ruby,arrays,hash,ruby-on-rails\
    \ |>\n<| c |>\nThanks so much for the help. I really appreciate it!\n<|/ c |>\n\
    <| c |>\nNo problem. Glad I could help.\n<|/ c |>\n<| a tags=ruby,arrays,hash,ruby-on-rails\
    \ |>\n<code>", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\n\
    end\n</code>\n<|/ a tags=ruby,arrays,hash |>\n<| c |>\nI like your solution, but\
    \ I wonder why you chose to split on spaces instead of just splitting on newlines?\n\
    <|/ c |>\n<| c |>\n: I chose to split on spaces because I thought that would give\
    \ me the most flexibility in terms of what was considered a word. For example,\
    \ `'a b c'.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }` would give\
    \ me `{\"a\"=>1, \"b\"=>1, \"c\"=>1}` instead of `{\"a\"=>1, \"b\"=>2, \"c\"=>1}`.\n\
    <|/ c |>\n<| c |>\n: I added an explanation to the answer.\n<|/ c |>\n<| c |>\n\
    I like the idea of using inject to count the occurrences. I didn't know about\
    \ that method.\n<|/ c |>\n<| c |>\n: I added an explanation to the answer.\n<|/\
    \ c |>\n<| a tags=ruby,arrays,hash |>\n<code>", "  test.split(' ').inject(Hash.new(0))\
    \ { |h, x| h[x] += 1; h }\nend", "  test.split(' ').inject(Hash.new(0)) { |h,\
    \ x| h[x] += 1; h }\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your\
    \ answer! I didn't know about inject and Hash.new. I'll look into it right now.\
    \ :)\n<|/ c |>\n<| c |>\nI added a solution that uses inject and Hash.new. :)\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  letters = test.split('').map\
    \ { |c| c.downcase }\n  letters.group_by { |c| c }.map { |k, v| [k, v.count] }.max_by\
    \ { |k, v| v }\nend", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1;\
    \ h }\nend", "  result = {}\n  test.split(' ').each do |letter|\n    letter =\
    \ letter.downcase\n    if result.has_key?(letter)\n      result[letter] += 1\n\
    \    else\n      result[letter] = 1\n    end\n  end\n  result\nend", "  letters\
    \ = test.split\n  frequencies = Hash.new(0)\n  letters.each do |letter|\n    frequencies[letter]\
    \ += 1\n  end\n  frequencies.max_by {|k, v| v}\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h, x| h[x] += 1; h }\nend", "  letters = test.split('')\n  counts = Hash.new(0)\n\
    \  letters.each do |letter|\n    counts[letter] += 1\n  end\n  letters.sort.reverse.inject(counts)\
    \ do |result, letter|\n    result[letter] ? result : result.merge(letter => 1)\n\
    \  end\nend", "  test.split(' ').group_by{|x| x}.map{|k, v| [k, v.count]}.max_by{|k,\
    \ v| v}\nend", "  test.split(' ').inject(Hash.new(0)){|h,x| h[x] += 1; h}\nend",
  "  result = {}\n  test.split(' ').each do |letter|\n    letter = letter.downcase\n\
    \    if result.has_key?(letter)\n      result[letter] += 1\n    else\n      result[letter]\
    \ = 1\n    end\n  end\n  result\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h, x| h[x] += 1; h }\nend", "  test.split(' ').inject(Hash.new(0)){|h,x|\
    \ h[x] += 1; h}\nend", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] +=\
    \ 1; h }\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>", "  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1; h }\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    result[letter] ||= 0\n    result[letter] += 1\n  end\n  result\nend", " \
    \ result = {}\n  test.split(' ').each do |letter|\n    letter = letter.downcase\n\
    \    result[letter] ||= 0\n    result[letter] += 1\n  end\n  result\nend", " \
    \ test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\nend", "    letters\
    \ = test.split(' ') # Split string into array of letters\n    count = {}\n   \
    \ letters.each do |letter|\n        if count[letter] == nil\n            count[letter]\
    \ = 1\n        else\n            count[letter] += 1\n        end\n    end\n  \
    \  count.sort_by { |k, v| v }.reverse.to_h\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| c |>\nThis doesn't work. `'a b c a b c a b c a b c a b c a b c a b c\
    \ a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b\
    \ c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a\
    \ b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c\
    \ a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b\
    \ c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a\
    \ b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c\
    \ a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b\
    \ c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a\
    \ b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c\
    \ a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c a b\
    \ c a b c a b c a b c a b c ", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    result[letter] = result[:letter] || 0\n    result[letter] += 1\n  end\n \
    \ result\nend", "  test.split(' ').inject(Hash.new(0)) { |h,x| h[x] += 1 }\nend\n\
    </code>\n<|/ a |>\n<| a tags=ruby,arrays |>\n<code>", "  hash = {}\n  test.split('\
    \ ').each do |letter|\n    hash[letter] ||= 0\n    hash[letter] += 1\n  end\n\
    \  hash\nend", "  result = {}\n  test.split(' ').each do |letter|\n    result[letter]\
    \ = result[:letter] || 0\n    result[letter] += 1\n  end\n  result\nend", "  result\
    \ = {}\n  test.split(' ').each do |letter|\n    letter = letter.downcase\n   \
    \ if result.has_key?(letter)\n      result[letter] += 1\n    else\n      result[letter]\
    \ = 1\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,hash |>\n\
    <| a dscore=1 |>\n<code>", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    result[letter] = result[:letter] || 0\n    result[letter] += 1\n  end\n \
    \ result\nend", "  result = {}\n  test.split(' ').each do |letter|\n    letter\
    \ = letter.downcase\n    if result.has_key?(letter)\n      result[letter] += 1\n\
    \    else\n      result[letter] = 1\n    end\n  end\n  result\nend", "  result\
    \ = Hash.new(0)\n  test.split(' ').each do |letter|\n    result[letter] += 1 if\
    \ result[:letter] > result[letter]\n  end\n  result\nend", "  hash = {}\n  test.split('\
    \ ').each do |letter|\n    hash[letter] = hash[letter].to_i + 1 if hash[letter].nil?\n\
    \    hash[letter] = hash[letter].to_i + 1 if hash[letter] >= hash[letter].to_i\n\
    \  end\n  hash\nend", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] +=\
    \ 1; h }\nend", "  test.split(' ').inject(Hash.new(0)) { |h, x| h[x] += 1; h }\n\
    end", "  result = {}\n  test.split(' ').each do |letter|\n    result[letter] ||=\
    \ 0\n    result[letter] += 1\n  end\n  result\nend", "  result = Hash.new(0)\n\
    \  test.split(' ').each do |letter|\n    result[letter] += 1 if result[:letter]\
    \ > result[letter]\n  end\n  result\nend", "  result = {}\n  test.split(' ').each\
    \ do |letter|\n    result[letter] = result[:letter] || 0\n    result[letter] +=\
    \ 1\n  end\n  result\nend", "  test.split(' ').inject(Hash.new(0)){|h,x| h[x]\
    \ += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x|\
    \ h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x|\
    \ h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x|\
    \ h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x|\
    \ h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x|\
    \ h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x|\
    \ h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split('\
    \ ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x|\
    \ h[x] += 1 }\n  test.split(' ').inject(Hash.new(0)){|h,x| h[x] += 1 }\n  test.split('\
    \ ').inje", "  result = {}\n  test.split(' ').each do |letter|\n    result[letter]\
    \ = result[:letter] || 0\n    result[letter] += 1\n  end\n  result\nend", "  test.split('\
    \ ').inject(Hash.new(0)){|h,x| h[x] += 1; h}\nend", "  letters = test.split\n\
    \  frequencies = Hash.new(0)\n  letters.each do |letter|\n    frequencies[letter]\
    \ += 1 if frequencies[letter] > 0\n  end\n  frequencies.sort_by { |k, v| v }.reverse\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like your answer, but I think\
    \ it would be better to use a `Hash` rather than a `HashWithIndifferentAccess`\
    \ - `HashWithIndifferentAccess.new` will give you a `Hash` with indifferent access,\
    \ which means you can do `frequencies.each { |k, v| puts \"#{k} occurs #{v} times\"\
    \ }` and it will print out all the keys and values nicely for you.\n<|/ c |>\n\
    <| c |>\nThanks I didn't know about that one. I've updated my answer.\n<|/ c |>\n\
    <| c |>\nI like your answer, but I think it would be better to use a `Hash` rather\
    \ than a `HashWithIndifferentAccess` - `HashWithIndifferentAccess.new` will give\
    \ you a `Hash` with indifferent access, which means you can do `frequencies.each\
    \ { |k, v| puts \"#{k} occurs #{v} times\" }` and it will print out all the keys\
    \ and values nicely for you.\n<|/ c |>\n<| c |>\nThanks, I've updated my answer\
    \ with your suggestion.\n<|/ c |>\n<| c |>\nThanks guys. I appreciate all the\
    \ help.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  result = {}\n  test.split('\
    \ ').each do |letter|\n    result[letter] ||= 0\n    result[letter] += 1\n  end\n\
    \  result\nend", "    count = {}\n    test.split(' ').each do |letter|\n     \
    \   if count.has_key?(letter)\n            count[letter] += 1\n        else\n\
    \            count[letter] = 1\n        end\n    end\n    count\nend", "  test.split('\
    \ ').inject(Hash.new(0)){|h,x| h[x] += 1; h}\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=0 |>\n<code>", "  result = {}\n  test.split(' ').each do |letter|\n\
    \    result[letter] = result[:letter] || 0\n    result[letter] += 1\n  end\n \
    \ result\nend", "  result = {}\n  test.split(' ').each do |letter|\n    letter\
    \ = letter.downcase\n    if result.has_key?(letter)\n      result[letter] += 1\n\
    \    else\n      result[letter] = 1\n    end\n  end\n  result\nend", "  test.split('\
    \ ').inject(Hash.new(0)) { |h,x| h[x] += 1; h }\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h, x| h[x] += 1; h }\nend", "  letters = test.split(' ')\n  letters.each\
    \ do |letter|\n    letter = letter.downcase\n    letters[letter] = letters[letter].to_i\
    \ + 1\n  end\n  letters.max_by {|k, v| v}\nend", "  test.split(' ').inject(Hash.new(0))\
    \ { |h,x| h[x] += 1; h }\nend", "    letters = test.split\n    letters.each do\
    \ |letter|\n        letters[letter] = letters[letter].to_i\n    end\n    letters.sort_by{|k,\
    \ v| v}.reverse.to_h\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
