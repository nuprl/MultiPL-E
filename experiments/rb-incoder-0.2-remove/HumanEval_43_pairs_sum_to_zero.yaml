name: HumanEval_43_pairs_sum_to_zero
language: rb
prompt: "# pairs_sum_to_zero takes a list of integers as an input.\n# it returns True\
  \ if there are two distinct elements in the list that\n# sum to zero, and False\
  \ otherwise.\ndef pairs_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n\
  \    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5,\
  \ 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true,\
  \ candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3,\
  \ 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n\
  \    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"
completions: ["  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if a.sum !=\
    \ 0 && b.sum != 0\n  end\n  true\nend", "    l.sort!\n    return l.inject(true)\
    \ { |sum, el| sum && el == 0 }\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\n<code>", "  l.sort!\n  return true if l[0] == l[-1]\n  for i in 0..(l.length-1)\n\
    \    return true if l[i] + l[i+1] == 0 \n  end\n  return false\nend", "  l.sort!\n\
    \  return false if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  l[0] > l[1] ? l.reverse!\
    \ : nil\n  l.each do |i|\n    next if l[i] == 0\n    return false if l[i+1] ==\
    \ 0\n    l[i+1] = l[i]\n  end\n  true\nend\n</code>\n<|/ a |>\n<| c |>\nI like\
    \ this solution, but I believe it can be improved by using recursion to solve\
    \ the problem in linear time.\n<|/ c |>\n<| c |>\n: Yes, it can be improved by\
    \ using recursion to solve the problem in linear time. I'll post an answer in\
    \ a few minutes.\n<|/ c |>\n<| c |>\n: I added a recursive solution that runs\
    \ in linear time.\n<|/ c |>\n<| c |>\n: I added a recursive solution that runs\
    \ in linear time.\n<|/ c |>\n<| a |>\n<code>", "  l.sort!\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  return false if l[0] == l[1]\n  l[0] > l[1]\nend", "  l.sort!\n\
    \  return true if l[0] == 0 && l[1] == 0\n  for i in 0...l.length-1\n    return\
    \ true if l[i] + l[i+1] == 0 \n  end\n  return false\nend", "  l.each_cons(2)\
    \ do |a,b|\n    return false if a.sum != 0 && b.sum != 0\n  end\n  true\nend",
  "  l.sort!\n  return true if l[0] == 0 && l[1] == 0\n  return false if l[0] == l[1]\n\
    \  l[0], l[1] = l[1], l[0]\n  return true if pairs_sum_to_zero(l)\n  l[0], l[1]\
    \ = l[1], l[0]\nend", "  l.sort!\n  return false if l[0] == l[-1]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0] > l[1]\nend", "  l.sort!\n  l.inject(true)\
    \ { |sum, el| sum && el == l[0] + l[1] }\nend", "  l.sort!\n  l.inject(true) {\
    \ |sum,x| sum && sum + x == 0 }\nend", "  l.sort!\n  pairs = l.each_cons(2).to_a\n\
    \  pairs.any? { |a, b| a + b == 0 }\nend", "  l.sort!\n  return true if l[0] ==\
    \ 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1]\
    \ == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n \
    \ l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1]\
    \ = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if a.sum\
    \ != b.sum\n  end\n  true\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like your\
    \ solution, but I believe it can be made more efficient by sorting the list only\
    \ once.\n<|/ c |>\n<| c |>\nI believe it can be made more efficient by sorting\
    \ the list only once. - I believe it can be made more efficient by sorting the\
    \ list only once. - I believe it can be made more efficient by sorting the list\
    \ only once. - I believe it can be made more efficient by sorting the list only\
    \ once. - I believe it can be made more efficient by sorting the list only once.\
    \ - I believe it can be made more efficient by sorting the list only once. - I\
    \ believe it can be made more efficient by sorting the list only once. - I believe\
    \ it can be made more efficient by sorting the list only once. - I believe it\
    \ can be made more efficient by sorting the list only once. - I believe it can\
    \ be made more efficient by sorting the list only once. - I believe it can be\
    \ made more efficient by sorting the list only once. - I believe it can be made\
    \ more efficient by sorting the list only once. - I believe it can be made more\
    \ efficient by sorting the list only once. - I believe it can be made more efficient\
    \ by sorting the list only once. - I believe it can be made more efficient by\
    \ sorting the list only once. - I believe it can be made more efficient by sorting\
    \ the list only once. - I believe it can be made more efficient by sorting the\
    \ list only once. - I believe it can be made more efficient by sorting the list\
    \ only once. - I believe it can be made more efficient by sorting the list only\
    \ once. - I believe it can be made more efficient by sorting the list only once.\
    \ - I believe it can be made more efficient by sorting the list only once. - I\
    \ believe it can be made more efficient by sorting the list only once. - I believe\
    \ it can be made more efficient by sorting the list only once. - I believe it\
    \ can be made more efficient by sorting the list only once. - I believe it can\
    \ be made more efficient by sorting the list only once. - I believe it can be\
    \ made more efficient by sorting the list only once. - I believe it can be made\
    \ more efficient by sorting the list only once. - I believe it can be made more\
    \ efficient by sorting the list only once. - I believe it can be made more efficient\
    \ by sorting the list only once. - I ", "    l.sort!\n    return false if l[0]\
    \ == l[-1]\n    return true if l[0] == l[1]\n    return true if l[1] == l[-1]\n\
    \    l.each_cons(2) do |x,y|\n        return true if x == y\n    end\n    return\
    \ false\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to make it more efficient.\n<|/ c |>\n<| c |>\n\
    I added a more efficient solution\n<|/ c |>\n<| c |>\nI added a more efficient\
    \ solution\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  l.sort!\n  l.each_cons(2)\
    \ do |a,b|\n    return false if a+b == 0\n  end\n  true\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\n<code>", "  l.sort!\n  return l.inject(true) { |sum, el| sum &&\
    \ el == 0 }\nend", "  l.sort!\n  return l.inject(true) { |sum, el| sum && el ==\
    \ 0 }\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a.sum\
    \ != 0 && b.sum != 0\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nI like this solution, but I wonder if there is a way to do it without\
    \ sorting the array?\n<|/ c |>\n<| c |>\n: I added a solution that doesn't sort\
    \ the array.\n<|/ c |>\n<| c |>\n: I added a solution that doesn't sort the array.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n  l.inject(true) { |sum,x|\
    \ sum && sum + x == 0 }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe `sort`\
    \ method will sort the array in place, so you don't need to assign the result\
    \ to a variable. Also, `inject` will return the last value it iterated over, so\
    \ you don't need to assign it to a variable.\n<|/ c |>\n<| c |>\nThanks for the\
    \ comments. I edited my answer to reflect your comments.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>", "    l.sort!\n    return l.inject(true) { |sum, el| sum && el ==\
    \ 0 }\nend", "  l.sort!\n  return l.inject(true) { |sum,x| sum && sum + x == 0\
    \ }\nend", "  l.each_cons(2) do |a, b|\n    return false if a.sum != b.sum\n \
    \ end\n  true\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", " \
    \ l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a.sum != b.sum\n  end\n\
    \  true\nend", "  l.sort!\n  return true if l[0] == l[-1]\n  return false if l[0]\
    \ == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true if pairs_sum_to_zero(l)\n\
    \  l[0], l[1] = l[1], l[0]\nend", "  l.sort!\n  return true if l[0] == 0 && l[1]\
    \ == 0\n  l[0], l[1] = l[1], l[0]\n  pairs_sum_to_zero(l.drop(2))\nend", "  l.sort!\n\
    \  l.each_cons(2) do |a,b|\n    return false if a+b == 0\n  end\n  true\nend",
  "  l.sort!\n  return l.inject(true) { |sum,x| sum && x==0 }\nend\n</code>\n<|/ a\
    \ dscore=0 |>\n<| c |>\nThis is not an answer to the question. OP asked for help\
    \ with his code, not for someone to write it for him.\n<|/ c |>\n<| c |>\nI appreciate\
    \ your comment, but I believe that my answer is an answer to his question. He\
    \ asked for help with his code, and I provided him with a solution that he could\
    \ use to help him with his code. He didn't ask for someone to write it for him.\
    \ He asked for help with his code, and I provided him with a solution that he\
    \ could use to help him with his code. He didn't ask for someone to write it for\
    \ him. He asked for help with his code, and I provided him with a solution that\
    \ he could use to help him with his code. He didn't ask for someone to write it\
    \ for him. He asked for help with his code, and I provided him with a solution\
    \ that he could use to help him with his code. He didn't ask for someone to write\
    \ it for him. He asked for help with his code, and I provided him with a solution\
    \ that he could use to help him with his code. He didn't ask for someone to write\
    \ it for him. He asked for help with his code, and I provided him with a solution\
    \ that he could use to help him with his code. He didn't ask for someone to write\
    \ it for him. He asked for help with his code, and I provided him with a solution\
    \ that he could use to help him with his code. He didn't ask for someone to write\
    \ it for him. He asked for help with his code, and I provided him with a solution\
    \ that he could use to help him with his code. He didn't ask for someone to write\
    \ it for him. He asked for help with his code, and I provided him with a solution\
    \ that he could use to help him with his code. He didn't ask for someone to write\
    \ it for him. He asked for help with his code, and I provided him with a solution\
    \ that he could use to help him with his code. He didn't ask for someone to write\
    \ it for him. He asked for help with his ", "  l.sort!\n  return false if l[0]\
    \ == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] ==\
    \ l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n\
    \  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0],\
    \ l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1]\
    \ = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1],\
    \ l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n\
    \  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n\
    \  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return\
    \ false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false\
    \ if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if\
    \ l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0]\
    \ == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] ==\
    \ l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n\
    \  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0],\
    \ l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1]\
    \ = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1],\
    \ l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n\
    \  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n\
    \  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return\
    \ false if ", "  l.sort!\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1]\
    \ = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l", "  l.sort!\n  l.each_cons(2)\
    \ do |a,b|\n    return false if a+b != 0\n  end\n  true\nend", "  l.sort!\n  return\
    \ true if l[0] == 0 && l[-1] == 0\n  l[0] > l[-1] ? false : true\nend", "  l.sort!\n\
    \  return false if l[0] == l[-1]\n  l[0], l[-1] = 0, 0\n  for i in 0...l.length-1\n\
    \    if l[i] + l[i+1] != 0\n      return false\n    end\n  end\n  return true\n\
    end", "    l.sort!\n    return l.inject(true) { |sum,x| sum && sum + x == 0 }\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI like this solution, but I wonder if there is\
    \ a way to make it more efficient. For example, what if there are many pairs that\
    \ sum to zero? It would be better to find all pairs whose sum is zero, and then\
    \ return those pairs. But then it would be better to sort the list first, and\
    \ then find pairs that sum to zero.\n<|/ c |>\n<| c |>\n: I added a solution that\
    \ sorts the list first. Sorting first is O(n log n), but finding pairs that sum\
    \ to zero is O(n).\n<|/ c |>\n<| c |>\n: I added a solution that sorts first and\
    \ finds pairs that sum to zero.\n<|/ c |>\n<| c |>\n: I added a solution that\
    \ sorts first and finds pairs that sum to zero.\n<|/ c |>\n<| c |>\n: I added\
    \ a solution that sorts first and finds pairs that sum to zero.\n<|/ c |>\n<|\
    \ a dscore=1 |>\n<code>", "  l.sort!\n  return l.inject(true) { |sum,x| sum &&\
    \ x==0 || sum && x==-x}\nend", "  l.sort!\n  return true if l[0] == 0 && l[1]\
    \ == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n \
    \ l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1]\
    \ = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l", "  l.sort!\n  return l.inject(true) { |sum,x| sum && x==0 }\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI like your solution, but I wonder if there is a way\
    \ to avoid sorting the list twice. Maybe something like `l.inject(true) { |sum,x|\
    \ sum && x==0 }`.\n<|/ c |>\n<| c |>\n: Yes, that would work.  I didn't think\
    \ of that.  I'll add it to the answer.\n<|/ c |>\n<| c |>\n: I added a version\
    \ that doesn't sort the list twice.  It sorts it once and then uses `inject` to\
    \ do the summing.\n<|/ c |>\n<| c |>\n: I added a version that doesn't sort the\
    \ list twice.  It sorts it once and then uses `inject` to do the summing.\n<|/\
    \ c |>\n<| c |>\n: I added a version that doesn't sort the list twice.  It sorts\
    \ it once and then uses `inject` to do the summing.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.sort!\n  l.inject(true) { |sum,x| sum && sum + x == 0 }\n\
    end", "  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n\
    \  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return false if l[0]\
    \ == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return false\
    \ if l[0] == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return\
    \ false if l[0] == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n\
    \  return false if l[0] == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n\
    \  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return false if l[0]\
    \ == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return false\
    \ if l[0] == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return\
    \ false if l[0] == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n\
    \  return false if l[0] == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n\
    \  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return false if l[0]\
    \ == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return false\
    \ if l[0] == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return\
    \ false if l[0] == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n\
    \  return false if l[0] == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n\
    \  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return false if l[0]\
    \ == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return false\
    \ if l[0] == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return\
    \ false if l[0] == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n\
    \  return false if l[0] == l[-1]\n  l.sort!\n  return false if l[0] == l[-1]\n\
    \  l.sort!\n  return false if l[0] == l[-1]\n  l.sort!\n  return false ", "  l.sort!\n\
    \  l.each_cons(2) do |a, b|\n    return false if a.sum != b.sum\n  end\n  true\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`each_cons` will iterate over\
    \ all combinations of two elements. So `[1,2,3].each_cons(2).to_a` will yield\
    \ `[[1, 2], [1, 3], [2, 3]]`. You don't need to sort the list first. Also, `each_cons`\
    \ will iterate over all combinations of two elements. So `[1,2,3].each_cons(2).to_a`\
    \ will yield `[[1, 2], [1, 3], [2, 3]]`. You don't need to sort the list first.\
    \ Also, `each_cons` will iterate over all combinations of two elements. So `[1,2,3].each_cons(2).to_a`\
    \ will yield `[[1, 2], [1, 3], [2, 3]]`. You don't need to sort the list first.\
    \ Also, `each_cons` will iterate over all combinations of two elements. So `[1,2,3].each_cons(2).to_a`\
    \ will yield `[[1, 2], [1, 3], [2, 3]]`. You don't need to sort the list first.\
    \ Also, `each_cons` will iterate over all combinations of two elements. So `[1,2,3].each_cons(2).to_a`\
    \ will yield `[[1, 2], [1, 3], [2, 3]]`. You don't need to sort the list first.\
    \ Also, `each_cons` will iterate over all combinations of two elements. So `[1,2,3].each_cons(2).to_a`\
    \ will yield `[[1, 2], [1, 3], [2, 3]]`. You don't need to sort the list first.\
    \ Also, `each_cons` will iterate over all combinations of two elements. So `[1,2,3].each_cons(2).to_a`\
    \ will yield `[[1, 2], [1, 3], [2, 3]]`. You don't need to sort the list first.\n\
    <|/ c |>\n<| c |>\nI see what you mean. Thanks for the clarification.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "    l.sort!\n    return l.inject(true) { |sum,x| sum\
    \ && sum + x == 0 }\nend", "  l.sort!\n  return true if l[0] == 0 && l[1] == 0\n\
    \  l[0] > l[1]\nend", "  l.sort!\n  return true if l[0] == 0 && l[1] == 0\n  return\
    \ false if l[0] == l[1]\n  l[0] > l[1] ? pairs_sum_to_zero(l[1..-1]) : pairs_sum_to_zero(l[0..-1])\n\
    end", "  l.sort!\n  return false if l.length < 2\n  l[0], l[1] = l[1], l[0]\n\
    \  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return\
    \ true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if\
    \ l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] ==\
    \ 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1]\
    \ == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n \
    \ l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1]\
    \ = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = ", "  l.sort!\n  return\
    \ true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  pairs_sum_to_zero(l[1..-1])\n\
    end", "  l.sort!\n  return true if l[0] == 0 && l[-1] == 0\n  for i in 0...l.size-1\n\
    \    return true if l[i] + l[i+1] == 0\n  end\n  return false\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nI like your solution, but I believe it can\
    \ be made more efficient by avoiding the sorting step. See my answer for a solution.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n  pairs = l.each_cons(2).to_a\n\
    \  pairs.any? { |a,b| a + b == 0 }\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nI like the idea of using each_cons to get pairs. I didn't know\
    \ about that method.\n<|/ c |>\n<| c |>\nI like your use of each_cons. I didn't\
    \ know about that method either.\n<|/ c |>\n<| c |>\nI like your use of each_cons.\
    \ I didn't know about that method either.\n<|/ c |>\n<| c |>\nI like your use\
    \ of each_cons. I didn't know about that method either.\n<|/ c |>\n<| c |>\nI\
    \ like your use of each_cons. I didn't know about that method either.\n<|/ c |>\n\
    <| a dscore=3 |>\n<code>", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return true\
    \ if y-x == 0\n  end\n  false\nend", "  l.sort!\n  pairs = l.zip(l[1..-1]).select\
    \ { |x,y| x+y != 0 }\n  pairs.size == 2 and pairs.all? { |x,y| x == y }\nend",
  "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a-b == 0\n  end\n  true\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\n<code>", " \
    \ l.sort!\n  return true if l[0] == 0 && l[1] == 0\n  return false if l[0] ==\
    \ 0 || l[1] == 0\n  return true if l[0] + l[1] == 0\n  return false if l[0] +\
    \ l[1] != 0\n  pairs_sum_to_zero(l.drop(1))\nend", "  l.sort!\n  return l.inject(true)\
    \ do |sum,x|\n    sum and (x.zero? or sum - x == 0)\n  end\nend\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nI like the `sort` solution. Just a couple of comments:\
    \ 1) `sort!` modifies the array in-place, which is unnecessary here, and 2) `inject`\
    \ can be replaced with `all?`, which makes the code a little more concise.\n<|/\
    \ c |>\n<| c |>\nThanks for the comments. I agree that `sort!` modifies the array\
    \ in-place, but I wanted to keep the code as close to the original as possible.\
    \ `all?` would also work, but I wanted to keep it simple and avoid the use of\
    \ methods that might be confusing to someone not familiar with Ruby.\n<|/ c |>\n\
    <| c |>\nI agree that `all?` would work, but I wanted to keep it simple and avoid\
    \ the use of methods that might be confusing to someone not familiar with Ruby.\n\
    <|/ c |>\n<| c |>\nI agree that `all?` would work, but I wanted to keep it simple\
    \ and avoid the use of methods that might be confusing to someone not familiar\
    \ with Ruby.\n<|/ c |>\n<| c |>\nI agree that `all?` would work, but I wanted\
    \ to keep it simple and avoid the use of methods that might be confusing to someone\
    \ not familiar with Ruby.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n\
    \  return true if l[0] == 0 && l[1] == 0\n  l[0] + l[1] == 0 || l[0] + l[1] !=\
    \ 0 && pairs_sum_to_zero([l[0]+l[1], l[1]+l[0]])\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a,b|\n    return true if a + b == 0\n  end\n  false\nend\n</code>\n<|/ a\
    \ dscore=2 |>\n<| a dscore=2 |>\n<code>", "  l.sort!\n  return true if l[0] ==\
    \ 0 && l[1] == 0\n  return false if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n\
    \  pairs_sum_to_zero(l)\nend", "  l.sort!\n  return false if l[0] == l[-1]\n \
    \ l[0], l[-1] = 0, 0\n  for i in 0...l.length-1\n    j = i+1\n    while j < l.length\n\
    \      l[j] += l[i]\n      j += 1\n    end\n  end\n  return false if l[0] == l[-1]\n\
    \  l[0], l[-1] = 0, 0\n  for i in 0...l.length-1\n    j = i+1\n    while j < l.length\n\
    \      l[j] += l[i]\n      j += 1\n    end\n  end\n  return false if l[0] == l[-1]\n\
    \  return true\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\nI like the\
    \ idea of sorting the list, but I wonder how this would perform on large lists.\n\
    <|/ c |>\n<| c |>\nI believe this would perform well on large lists because of\
    \ the sorting step. It would also perform well on small lists because of the `return\
    \ false if l[0] == l[-1]` step. I haven't tested it on large lists though.\n<|/\
    \ c |>\n<| c |>\nI tested it on large lists and it works fine. On small lists,\
    \ it takes about a second or two to complete.\n<|/ c |>\n<| c |>\nI tested it\
    \ on large lists and it works fine. On small lists, it takes about a second or\
    \ two to complete.\n<|/ c |>\n<| c |>\nI tested it on large lists and it works\
    \ fine. On small lists, it takes about a second or two to complete.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "  l.sort!\n  return false if l[0] == l[-1]\n  l[0],\
    \ l[-1] = 0, 0\n  l.each_cons(2) do |a, b|\n    return false if b != 0\n  end\n\
    \  true\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like your solution,\
    \ however it fails for `[1,2,3]` which should return `true` but returns `false`\n\
    <|/ c |>\n<| c |>\n: I fixed the bug, thanks. I forgot that `sort!` mutates the\
    \ original array.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return true if y-x == 0\n  end\n  false\nend", "  l.sort!\n  return\
    \ l.inject(true) { |sum,x| sum && x==l.first+l.last }\nend", "  l.sort!\n  l.inject(true)\
    \ { |sum,x| sum && sum + x == 0 }\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Thanks for your answer. I'm sorry I didn't mention this in my question, but I\
    \ do need to use recursion to solve this problem. I'm just not sure how to implement\
    \ it using recursion.\n<|/ c |>\n<| c |>\n: I added a recursive solution to my\
    \ answer.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm sorry I didn't mention\
    \ this in my question, but I do need to use recursion to solve this problem. I'm\
    \ just not sure how to implement it using recursion.\n<|/ c |>\n<| c |>\n: I added\
    \ a recursive solution to my answer.\n<|/ c |>\n<| a dscore=1 |>\n<code>", " \
    \ l.sort!\n  return l.inject(true) { |sum, el| sum && el == 0 }\nend", "  l.sort!\n\
    \  l.each_cons(2) do |a,b|\n    return false if a-b == 0\n  end\n  return true\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", "  l.sort!\n  return\
    \ true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if\
    \ l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] ==\
    \ 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1]\
    \ == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n \
    \ l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1]\
    \ = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l", "  l.sort!\n  return false if l.length < 2\n\
    \  l.each_cons(2) do |a,b|\n    return false if a + b == 0\n  end\n  return true\n\
    end\n</code>\n<|/ a |>\n<| c |>\nI like your solution, however it fails on `[1,2,3]`\
    \ which should return `true` but returns `false`.\n<|/ c |>\n<| c |>\nI fixed\
    \ the bug. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ however it fails on `[1,2,3]` which should return `true` but returns `false`.\n\
    <|/ c |>\n<| c |>\nI fixed the bug. Thanks for pointing it out.\n<|/ c |>\n<|\
    \ c |>\nI like your solution, however it fails on `[1,2,3]` which should return\
    \ `true` but returns `false`.\n<|/ c |>\n<| a |>\n<code>", "  l.sort!\n  return\
    \ true if l[0] == 0 && l[1] == 0\n  false\nend", "  l.sort!\n  l.inject(true)\
    \ { |sum,i| sum && l[i+1] - l[i] == 0 }\nend", "  l.sort!\n  l.inject(true) {\
    \ |sum,x| sum && x==l.first}\nend", "    l.sort!\n    return l.inject(true) do\
    \ |sum,e|\n      sum and (e == 0 or e + sum == 0)\n    end\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\n<code>", "    l.sort!\n   \
    \ return false if l[0] == l[-1]\n    return true if l[0] == l[1]\n    return true\
    \ if l[0] == l[2] and l[1] == l[3]\n    return true if l[0] == l[2] and l[1] ==\
    \ l[3] and l[2] == l[4]\n    return true if l[0] == l[2] and l[1] == l[3] and\
    \ l[2] == l[4] and l[3] == l[5]\n    return true if l[0] == l[2] and l[1] == l[3]\
    \ and l[2] == l[4] and l[3] == l[5] and l[4] == l[6]\n    return true if l[0]\
    \ == l[2] and l[1] == l[3] and l[2] == l[4] and l[3] == l[5] and l[4] == l[6]\
    \ and l[5] == l[7]\n    return true if l[0] == l[2] and l[1] == l[3] and l[2]\
    \ == l[4] and l[3] == l[5] and l[4] == l[6] and l[5] == l[7] and l[6] == l[8]\n\
    \    return true if l[0] == l[2] and l[1] == l[3] and l[2] == l[4] and l[3] ==\
    \ l[5] and l[4] == l[6] and l[5] == l[7] and l[6] == l[8] and l[7] == l[9]\n \
    \   return true if l[0] == l[2] and l[1] == l[3] and l[2] == l[4] and l[3] ==\
    \ l[5] and l[4] == l[6] and l[5] == l[7] and l[6] == l[8] and l[7] == l[9] and\
    \ l[8] == l[10]\n    return true if l[0] == l[2] and l[1] == l[3] and l[2] ==\
    \ l[4] and l[3] == l[5] and l[4] == l[6] and l[5] == l[7] and l[6] == l[8] and\
    \ l[7] == l[9] and l[8] == l[10] and l[9] == l[11]\n    return true if l[0] ==\
    \ l[2] and l[1] == l[3] and l[2] == l[4] and l[3] == l[5] and l[4] == l[6] and\
    \ l[5] == l[7] and l[6] == l[8] and l[7] == l[9] and l[8] == l[10] and l[9] ==\
    \ l[11] and l[10] == l[12]\n    return true if l[0] == l[2] and l[1] == l[3] and\
    \ l[2] == l[4] and l[3] == l[5] and l[4] == l[6] and l[5] == l[7] and l[6] ==\
    \ l[8] and l[7] == l[9] and l[8] == l[10] and l[9] == l[11] and l[10] == l[12]\
    \ and l[11] == l[13]\n    return true if l[0] == l[2] and l[1] == l[3] and l[2]\
    \ == l[4", "  l.sort!\n  return false if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return false if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return true if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return false if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return true if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return false if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return true if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return false if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return true if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return false if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return true if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return false if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return true if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return false if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return true if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return false if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return true if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.shift\n  l.sort!\n  return false if l.length<2 || l.length==2\n  l[0]==l[1]\n\
    \  l.", "  l.sort!\n  l.inject(true) { |sum,x| sum && sum + x == 0 }\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThis doesn't work. Try it out with [1,2,3] and [2,3,4]\n\
    <|/ c |>\n<| c |>\nIt works fine for me. Try it out with [1,2,3] and [2,3,4].\n\
    <|/ c |>\n<| c |>\nIt doesn't work for me. Try it out with [1,2,3] and [2,3,4].\n\
    <|/ c |>\n<| c |>\nIt works for me with [1,2,3] and [2,3,4]. Try it out with [1,2,3]\
    \ and [2,3,4].\n<|/ c |>\n<| c |>\nIt works for me with [1,2,3] and [2,3,4]. Try\
    \ it out with [1,2,3] and [2,3,4].\n<|/ c |>\n<| a |>\n<code>", "  l.sort!\n \
    \ l.each_cons(2) do |a,b|\n    return false if a.sum != b.sum\n  end\n  true\n\
    end", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if b - a == 0\n\
    \  end\n  true\nend", "  l.sort!\n  return false if l.length < 2 \n  l[0], l[1]\
    \ = l[1], l[0]\n  for i in 2..l.length\n    return false if l[i-1] + l[i] == 0\n\
    \  end\n  return true\nend", "  l.sort!\n  return l.inject(true) { |acc, x| acc\
    \ && (x.zero? || acc + x == 1) }\nend", "  l.sort!\n  return true if l[0] == 0\
    \ && l[1] == 0\n  return false if l[0] == l[1]\n  l[0] > l[1] ? pairs_sum_to_zero(l[1..-1])\
    \ : pairs_sum_to_zero(l[0..-1])\nend", "  l.sort!\n  return true if l[0] == 0\
    \ && l[1] == 0\n  l[0] > l[1]\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n \
    \   return true if y-x == 0\n  end\n  false\nend", "  l.sort!\n  return false\
    \ if l.length < 2\n  l.each_cons(2) do |a,b|\n    return true if a + b == 0\n\
    \  end\n  false\nend", "  l.sort!\n  l.inject(true) { |sum, el| sum && el == l[0]\
    \ + l[1] }\nend", "  l.sort!\n  return true if l[0] == 0 && l[1] == 0\n  l[0]\
    \ + l[1] == 0\nend", "  l.sort!\n  pairs = l.inject([]) do |sums, el|\n    el\
    \ = el.to_i\n    sums << el if sums.last + el == 0 \n    sums\n  end\n  pairs.size\
    \ == 2\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. Try it with\
    \ `[3, 2, 1]`. It returns `true` when it should be `false`.\n<|/ c |>\n<| c |>\n\
    Thanks for pointing that out. I've fixed the code now.\n<|/ c |>\n<| c |>\nThis\
    \ still doesn't work. Try it with `[3, 2, 1]`. It returns `true` when it should\
    \ be `false`.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've fixed the\
    \ code now.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n  l.inject(true)\
    \ do |sum, el|\n    sum and (sum - el == 0)\n  end\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis is an interesting solution, but I believe it only works if\
    \ you have a list of integers. If you have a list of strings, it won't work. Also,\
    \ `sort!` will change the original list, so you might want to make a copy first.\n\
    <|/ c |>\n<| c |>\nI believe it works with strings as well, just not in the way\
    \ you think it does. Try it out and let me know if it works.\n<|/ c |>\n<| c |>\n\
    It does work, but I believe it only works with integers. Try it out with strings\
    \ and see what happens.\n<|/ c |>\n<| c |>\nAh, I see what you mean. Yes, it only\
    \ works with integers. I didn't realize that `sort!` would change the original\
    \ list. Thanks for pointing that out.\n<|/ c |>\n<| a |>\n<code>", "  l.sort!\n\
    \  l.inject(true) { |sum,x| sum && sum + x == 0 }\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby |>\n<code>", "  l.sort!\n  l.inject(true) { |sum, el| sum\
    \ && el == l.last - l.first }\nend", "  l.sort!\n  return true if l[0] == 0 &&\
    \ l[-1] == 0\n  for i in 0...l.length-1\n    return true if l[i] + l[i+1] == 0\
    \ \n  end\n  return false\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    I like this solution, but I believe it can be improved by using a hash to avoid\
    \ the sort.\n<|/ c |>\n<| c |>\nI agree. My solution was meant to be a quick and\
    \ dirty solution that would not require any additional libraries.\n<|/ c |>\n\
    <| c |>\nI like your solution, but I believe it can be improved by using a hash\
    \ to avoid the sort.\n<|/ c |>\n<| c |>\nI agree. My solution was meant to be\
    \ a quick and dirty solution that would not require any additional libraries.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  l.sort!\n  l.inject(true) { |sum, el|\
    \ sum && el == l.last - l.first }\nend", "  l.sort!\n  l.inject(true) { |sum,x|\
    \ sum && x==l[0] && l[1]==l[-1] }\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n\
    \    return false if x == y\n    return true if x - y == 0\n  end\n  true\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if there are multiple\
    \ pairs that sum to zero. For example, `[1,2,3,4,5,6,7,8,9,0]` returns `true`,\
    \ but `[1,2,3,4,5,6,7,8,9,10,0]` returns `false`.\n<|/ c |>\n<| c |>\nYes, I noticed\
    \ that and fixed it by adding another `each_cons`. Thanks for pointing it out.\n\
    <|/ c |>\n<| c |>\nI added a more efficient solution that doesn't require sorting.\n\
    <|/ c |>\n<| a dscore=3 |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a,b|\n \
    \   return false if a-b == 0\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI like your solution, but I think it would be more efficient to\
    \ sort the array and then iterate over it once to find the pairs that sum to zero.\n\
    <|/ c |>\n<| c |>\n: Yes, that's a good point. I'll edit my answer to include\
    \ that option as well.\n<|/ c |>\n<| c |>\n: I added a solution that sorts the\
    \ array first and then iterates over it once.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  l.sort!\n  return false if l.length < 2\n  l.each_cons(2) do |a,b|\n    return\
    \ false if a + b == 0\n  end\n  return true\nend", "  l.sort!\n  l.inject(true)\
    \ { |sum,x| sum && sum + x == 0 }\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    This doesn't work for me. `[1,2,3].sort.inject(true) { |sum,x| sum && sum + x\
    \ == 0 }` returns `true` when it should return `false`\n<|/ c |>\n<| c |>\n: I\
    \ tested it and it returns `false` as expected. Are you sure you copied it correctly?\
    \ I tested it on Ruby 1.8.7 and 1.9.2\n<|/ c |>\n<| c |>\n: I tested it on Ruby\
    \ 1.8.7 and 1.9.2\n<|/ c |>\n<| c |>\n: I tested it on Ruby 1.8.7 and 1.9.2\n\
    <|/ c |>\n<| c |>\n: I tested it on Ruby 1.8.7 and 1.9.2\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  l.sort!\n  l.inject(true) { |sum,i| sum && l[i..-1].inject(true)\
    \ { |sum2,j| sum2 && l[j..i].inject(true) { |sum3,k| sum3 && l[k..j].zero? } }\
    \ } \nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it out\
    \ with [1,1,1]. You'll get false instead of true.\n<|/ c |>\n<| c |>\nAh, I see\
    \ what you mean. I'll fix it.\n<|/ c |>\n<| c |>\nFixed it. I was thinking about\
    \ it backwards.\n<|/ c |>\n<| c |>\nThis still doesn't work. Try it out with [1,1,1].\
    \ You'll get false instead of true.\n<|/ c |>\n<| c |>\nAh, I see what you mean.\
    \ I'll fix it.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n  return\
    \ true if l[0] == 0 && l[1] == 0\n  return false if l[0] == l[1]\n  l[0], l[1]\
    \ = l[1], l[0]\n  return true if pairs_sum_to_zero(l)\nend", "  l.sort!\n  return\
    \ l.inject(true) { |sum,x| sum && x==0 || sum }\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return true if y-x == 0\n  end\n  false\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false\
    \ if a+b == 0\n  end\n  return true\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| a dscore=0 |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false\
    \ if a-b == 0\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    This doesn't work if there are duplicates in the array. For example, `[1, 1, 2]`\
    \ returns `true` but should return `false`.\n<|/ c |>\n<| c |>\nThanks, I fixed\
    \ it.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if a.sum != b.sum\n  end\n  true\nend", "  l.sort!\n\
    \  l.each_cons(2) do |a,b|\n    return false if b == 0 && a.zero?\n    return\
    \ false if b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b ==\
    \ 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero?\
    \ || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 &&\
    \ a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b\
    \ == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero?\
    \ || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 &&\
    \ a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b\
    \ == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero?\
    \ || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 &&\
    \ a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b\
    \ == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero?\
    \ || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 &&\
    \ a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b\
    \ == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero?\
    \ || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 &&\
    \ a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b == 0 && a.zero? || b\
    \ == 0 && a.zero? || b == 0 && a.zero? || b == ", "  l.sort!\n  return true if\
    \ l[0] == 0 && l[-1] == 0\n  l[0], l[-1] = 0, 0\n  l.each do |i|\n    l.shift\n\
    \    l.shift\n    return true if l[0] == 0 && l[-1] == 0\n    l[0], l[-1] = 0,\
    \ 0\n  end\n  false\nend", "  l.sort!\n  return true if l[0] == 0 && l[1] == 0\n\
    \  return false if l[0] == l[1]\n  return true if l[0] + l[1] == 0\n  return false\
    \ if l[0] + l[1] != 0\n  pairs_sum_to_zero(l[1..-1]) || pairs_sum_to_zero(l[0..-2])\n\
    end", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a.sum != 0 &&\
    \ b.sum != 0\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n   \
    \ return false if a.sum != 0 && b.sum != 0\n  end\n  true\nend\n</code>\n<|/ a\
    \ tags=ruby,arrays |>\n<| c |>\nThis solution doesn't work if there are multiple\
    \ pairs that sum to zero. For example, `[1,1,1,1]` returns `true`, but `[1,1,1,2]`\
    \ returns `false`.\n<|/ c |>\n<| c |>\nI didn't notice that requirement. I've\
    \ updated my answer to account for that case.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that doesn't require sorting.\n<|/ c |>\n<| c |>\nI added a solution that doesn't\
    \ require sorting.\n<|/ c |>\n<| c |>\nI added a solution that doesn't require\
    \ sorting.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n  l.inject(true)\
    \ { |sum,i| sum && l[i..-1].inject(true) { |sum2,j| sum2 && l[j..i].inject(true)\
    \ { |sum3,k| sum3 && l[k..j].zero? } } } \nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=1 |>\n<code>", "  l.sort!\n  return l.inject(true) { |sum,x| sum &&\
    \ x==0 || sum }\nend", "  l.sort!\n  pairs = l.each_cons(2).to_a\n  pairs.any?\
    \ { |x, y| x + y == 0 }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis\
    \ doesn't work if there are multiple pairs whose sum is zero. For example, `[1,2,0]`\
    \ returns `true` but `[1,2,3]` returns `false`.\n<|/ c |>\n<| c |>\nI added a\
    \ solution that works with multiple pairs.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that works with multiple pairs.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ works with multiple pairs.\n<|/ c |>\n<| c |>\nI added a solution that works\
    \ with multiple pairs.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n\
    \  l.each_cons(2) do |a,b|\n    return false if a+b != 0\n  end\n  true\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nIt works. I tested it on [ruby 1.9.3](http://rubyfiddle.com/riddles/9f77c)\
    \ and [ruby 1.8.7](http://rubyfiddle.com/riddles/9f77c).\n<|/ c |>\n<| c |>\n\
    It doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt works. I tested\
    \ it on [ruby 1.9.3](http://rubyfiddle.com/riddles/9f77c) and [ruby 1.8.7](http://rubyfiddle.com/riddles/9f77c).\n\
    <|/ c |>\n<| c |>\nIt doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.sort!\n  return true if l[0] == 0 && l[1] == 0\n  return false\
    \ if l[0] == 0 || l[1] == 0\n  l[0] + l[1] == 0\nend", "  l.sort!\n  l.inject(true)\
    \ { |sum,x| sum && x==0 || sum }\nend", "  l.sort!\n  return true if l[0] == 0\
    \ && l[1] == 0\n  return false if l[0] == l[1]\n  return true if l[0] + l[1] ==\
    \ 0\n  return false if l[0] + l[1] != 0\n  return true if l[0] + l[1] < 0\n  return\
    \ false if l[0] + l[1] > 0\n  l.sort!\n  return true if l[0] + l[1] < 0\n  return\
    \ false if l[0] + l[1] > 0\n  l.sort!\n  return true if l[0] + l[1] > 0\n  return\
    \ false if l[0] + l[1] < 0\nend", "  l.sort!\n  return false if l.length < 2\n\
    \  l[0], l[1] = l[1], l[0]\n  return false if l[0] == l[1]\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n\
    \  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n\
    \  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n\
    \  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n\
    \  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n\
    \  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n\
    \  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n\
    \  l[0], l[1] = l[1], l[0]\n  return true if l[0] == l[1]\n  l[0], l[1] = ", " \
    \ l.sort!\n  return false if l.length < 2 \n  l.each_cons(2) do |a,b|\n    return\
    \ false if a.sum != b.sum\n  end\n  return true\nend\n</code>\n<|/ a |>\n<| c\
    \ |>\nI like your solution, but I believe it can be optimized a little more. For\
    \ example, `return false if a.sum != b.sum` can be replaced with `return false\
    \ if a.sum + b.sum != 0`. Also, `return false if l.length < 2` can be replaced\
    \ with `return false if l.length < 2`\n<|/ c |>\n<| c |>\nThanks for the suggestions.\
    \ I agree that `return false if l.length < 2` can be replaced with `return false\
    \ if l.length < 2`, but I don't think `return false if a.sum + b.sum != 0` can\
    \ be replaced with `return false if a.sum + b.sum != 0` because `a.sum + b.sum`\
    \ could return `0` even when `a.sum != b.sum`. For example, `[1,2,3].sum` returns\
    \ `6`, but `[1,2,3].sum != 0` returns `true`.\n<|/ c |>\n<| c |>\nYes, you're\
    \ right. I missed that case. Thanks for pointing it out.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a+b\
    \ == 0\n  end\n  true\nend", "  l.sort!\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  return false if l[0] == 0 || l[1] == 0\n  l[0] > l[1]\nend", "  l.sort!\n\
    \  return true if l[0] == 0 && l[-1] == 0\n  l[0], l[-1] = 0, 0\n  l.each do |i|\n\
    \    l.shift\n    l.shift\n    return true if l[0] == 0 && l[-1] == 0\n    l[0],\
    \ l[-1] = 0, 0\n  end\n  false\nend\n</code>\n<|/ a |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to make it more efficient. My solution is O(n^2)\
    \ but yours is O(n). Is there a way to make it O(n)?\n<|/ c |>\n<| c |>\n: I added\
    \ a O(n) solution that uses `sort` instead of `each`.\n<|/ c |>\n<| c |>\n: I\
    \ added a O(n) solution that uses `sort` instead of `each`.\n<|/ c |>\n<| c |>\n\
    : I added a O(n) solution that uses `sort` instead of `each`.\n<|/ c |>\n<| c\
    \ |>\n: I added a O(n) solution that uses `sort` instead of `each`.\n<|/ c |>\n\
    <| a tags=ruby,algorithm |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a,b|\n\
    \    return false if a.sum != b.sum\n  end\n  true\nend", "  l.sort!\n  return\
    \ true if l[0] == 0 && l[1] == 0\n  return false if l[0] == l[1]\n  l[0] + l[1]\
    \ == 0\nend", "  l.sort!\n  return l.inject(true) { |acc, x| acc && x[0] == x[1]\
    \ && (x[0] + x[1]) == 0 }\nend", "  l.sort!\n  pairs = l.each_cons(2).to_a\n \
    \ pairs.any? { |a,b| a + b == 0 }\nend", "  l.sort!\n  return true if l[0] ==\
    \ 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] + l[1] == 0\n\
    \  pairs_sum_to_zero(l[1..-1])\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n\
    \    return false if a.sum != b.sum\n  end\n  true\nend", "  l.sort!\n  return\
    \ l.inject(true) { |sum, el| sum && el == 0 }\nend", "  l.sort!\n  l.inject(true)\
    \ { |sum, el| sum && el == 0 || sum }\nend", "  l.sort!\n  return false if l[0]\
    \ == l[1]\n  l[0] + l[1] == 0\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ doesn't work. Try it with `[2,3,-4,5]`.\n<|/ c |>\n<| c |>\nIt does. Try it\
    \ with `[2,3,-4,5]`.\n<|/ c |>\n<| c |>\nIt doesn't work for `[2,3,-4,5]`. Try\
    \ it with `[2,3,-4,5]`.\n<|/ c |>\n<| c |>\nIt works for me. Try it with `[2,3,-4,5]`.\n\
    <|/ c |>\n<| c |>\nIt doesn't work for `[2,3,-4,5]`. Try it with `[2,3,-4,5]`.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "    l.sort!\n    return l.inject(true) {\
    \ |sum,x| sum && x==0 || sum }\nend", "    l.sort!\n    return false if l.empty?\
    \ || l.uniq.size < 2 || l.uniq.size > 3 \n    l.each_cons(2) do |a,b|\n      \
    \  return false if a.sum != 0 && b.sum != 0\n    end\n    true\nend\n</code>\n\
    <|/ a |>\n<| c |>\nI like your solution, however it fails for `[1,2,3]` which\
    \ should return `true` but returns `false`\n<|/ c |>\n<| c |>\nI added a fix for\
    \ that case\n<|/ c |>\n<| c |>\nI added a fix for that case\n<|/ c |>\n<| c |>\n\
    I added a fix for that case\n<|/ c |>\n<| c |>\nI added a fix for that case\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  l.sort!\n  pairs = l.each_cons(2).to_a\n\
    \  pairs.any? { |x, y| x + y == 0 }\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't work. Try it with `[2,3,-4,5,-6,7,-8,9]`.\n<|/ c |>\n<| c |>\nIt\
    \ does work. Try it with `[2,3,-4,5,-6,7,-8,9]`.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work. Try it with `[2,3,-4,5,-6,7,-8,9]`.\n<|/ c |>\n<| c |>\nIt does work.\
    \ Try it with `[2,3,-4,5,-6,7,-8,9]`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try\
    \ it with `[2,3,-4,5,-6,7,-8,9]`.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "    l.sort!\n\
    \    return l.inject(true) { |sum, el| sum && el == 0 }\nend", "  l.sort!\n  return\
    \ true if l[0] == 0 && l[1] == 0\n  l[0] > l[1]\nend", "  l.sort!\n  pairs = l.inject([])\
    \ do |sums, el|\n    el = el.to_i\n    sums << el if sums.last + el == 0 \n  \
    \  sums\n  end\n  pairs.size == 2\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<|\
    \ c |>\nI like your solution. Can you explain how it works?\n<|/ c |>\n<| c |>\n\
    I added some explanation.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n\
    \  return false if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  l[0] < l[1] ? pairs_sum_to_zero(l[1..-1])\
    \ : pairs_sum_to_zero(l[2..-1])\nend", "  l.sort!\n  return l.inject(true) { |acc,\
    \ x| acc && x==0 || x==-x }\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n   \
    \ return false if a+b != 0\n  end\n  true\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThis doesn't work. Try it with `[1,1,1]`.\n<|/ c |>\n<| c |>\nYes, it\
    \ does. Try it with `[1,1,1]`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with\
    \ `[1,1,1]`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `[1,1,1]`.\n<|/ c |>\n\
    <| c |>\nIt doesn't work. Try it with `[1,1,1]`.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.sort!\n  return l.inject(true) do |sum,x|\n    sum and (x.zero?\
    \ or sum - x == 0)\n  end\nend", "  l.each_cons(2) do |a,b|\n    return false\
    \ if a.sum != b.sum\n  end\n  true\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    I like your solution, however I believe it can be simplified a little bit. `each_cons`\
    \ will yield pairs of consecutive elements in the array. `sum` will return the\
    \ sum of all elements in the pair. `each_cons(2)` will yield pairs of consecutive\
    \ elements in the array. `sum` will return the sum of all elements in the pair.\
    \ `each_cons(2)` will yield pairs of consecutive elements in the array. `sum`\
    \ will return the sum of all elements in the pair. `each_cons(2)` will yield pairs\
    \ of consecutive elements in the array. `sum` will return the sum of all elements\
    \ in the pair. `each_cons(2)` will yield pairs of consecutive elements in the\
    \ array. `sum` will return the sum of all elements in the pair. `each_cons(2)`\
    \ will yield pairs of consecutive elements in the array. `sum` will return the\
    \ sum of all elements in the pair. `each_cons(2)` will yield pairs of consecutive\
    \ elements in the array. `sum` will return the sum of all elements in the pair.\
    \ `each_cons(2)` will yield pairs of consecutive elements in the array. `sum`\
    \ will return the sum of all elements in the pair. `each_cons(2)` will yield pairs\
    \ of consecutive elements in the array. `sum` will return the sum of all elements\
    \ in the pair. `each_cons(2)` will yield pairs of consecutive elements in the\
    \ array. `sum` will return the sum of all elements in the pair. `each_cons(2)`\
    \ will yield pairs of consecutive elements in the array. `sum` will return the\
    \ sum of all elements in the pair. `each_cons(2)` will yield pairs of consecutive\
    \ elements in the array. `sum` will return the sum of all elements in the pair.\
    \ `each_cons(2)` will yield pairs of consecutive elements in the array. `sum`\
    \ will return the sum of all elements in the pair. `each_cons(2)` will yield pairs\
    \ of consecutive elements in the array. `sum` will return the sum of all elements\
    \ in the pair. `each_cons(2)` will yield pairs of consecutive elements in the\
    \ array. `sum` will return the sum of all elements in the pair. `each_cons(2)`\
    \ will yield pairs of consecutive elements in the array. `sum` will return the\
    \ sum of all elements in the pair. `each_cons(2)` will yield pairs of consecutive\
    \ elements in the array. `sum` will return the sum of all element", "  l.sort!\n\
    \  l.each_cons(2) do |a,b|\n    return false if a-b == 0\n  end\n  true\nend",
  "  l.sort!\n  l.each_cons(2) do |a,b|\n    return true if a + b == 0\n  end\n  false\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return true if y-x == 0\n  end\n  false\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,1,2,2]`.\n<|/ c |>\n<| c |>\n\
    It works. Try it with `[1,1,2,2]`. It returns `true`.\n<|/ c |>\n<| c |>\nIt returns\
    \ `true` for `[1,1,2,2]`, but `false` for `[1,2,2,2]`.\n<|/ c |>\n<| c |>\nOh\
    \ yeah, I see what you mean. Thanks for pointing that out. I'll fix it.\n<|/ c\
    \ |>\n<| c |>\nI fixed it. I forgot that `each_cons` doesn't include the element\
    \ it's iterating over in the list.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  l.sort!\n\
    \  l.inject(true) do |sum, el|\n    sum and (sum - el == 0)\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work if there are multiple pairs that\
    \ sum to zero. For example, `[1,1,1]` returns `true`, but `[1,1,2]` returns `false`.\n\
    <|/ c |>\n<| c |>\nI missed that requirement. Thanks for pointing it out.\n<|/\
    \ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a,b|\n\
    \    return false if a.sum != 0 && b.sum != 0\n  end\n  true\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nI like your solution. Just a small improvement: instead\
    \ of `return false if a.sum != 0 && b.sum != 0` you can write `return false if\
    \ a.sum != 0 || b.sum != 0`\n<|/ c |>\n<| c |>\nI like your solution. Just a small\
    \ improvement: instead of `return false if a.sum != 0 && b.sum != 0` you can write\
    \ `return false if a.sum != 0 || b.sum != 0`\n<|/ c |>\n<| c |>\nI like your solution.\
    \ Just a small improvement: instead of `return false if a.sum != 0 && b.sum !=\
    \ 0` you can write `return false if a.sum != 0 || b.sum != 0`\n<|/ c |>\n<| a\
    \ |>\n<code>", "  l.sort!\n  return true if l[0] == 0 && l[1] == 0\n  l[0] > l[1]\n\
    end", "    l.sort!\n    pairs = l.inject([]) do |sums, el|\n        sums << [el,\
    \ sums.last] if sums.last != el\n        sums\n    end\n    pairs.size == 2 and\
    \ pairs.all? { |el| el[0] == el[1] }\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a.sum\
    \ != b.sum\n  end\n  true\nend", "    l.sort!\n    l.each_cons(2) do |a, b|\n\
    \        return false if a.sum != b.sum\n    end\n    true\nend\n</code>\n<|/\
    \ a tags=ruby |>\n<| c |>\nThe `sort!` call is unnecessary and inefficient. `each_cons(2)`\
    \ will do that for you.\n<|/ c |>\n<| c |>\n: Thanks. I didn't know about `each_cons`.\n\
    <|/ c |>\n<| c |>\n: Thanks. I didn't know about `each_cons`.\n<|/ c |>\n<| c\
    \ |>\n: Thanks. I didn't know about `each_cons`.\n<|/ c |>\n<| c |>\n: Thanks.\
    \ I didn't know about `each_cons`.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  l.sort!\n\
    \  l.each_cons(2) do |a,b|\n    return false if a-b == 0\n  end\n  true\nend\n\
    </code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\nThe question asks for \"\
    two distinct elements in the list that sum to zero\". This solution returns `true`\
    \ when there is at least one pair of elements that sum to zero.\n<|/ c |>\n<|\
    \ c |>\n: I misread the question. Thanks for pointing that out.\n<|/ c |>\n<|\
    \ c |>\nI believe this solution will fail for `[1,2,3]` since `[1,2,3]` has three\
    \ distinct elements that sum to zero. `[1,2,4]` has four distinct elements that\
    \ sum to zero.\n<|/ c |>\n<| c |>\n: I believe you are correct. I've updated my\
    \ answer to account for that case.\n<|/ c |>\n<| c |>\n: Thanks for pointing that\
    \ out. I've updated my answer to account for that case.\n<|/ c |>\n<| a |>\n<code>",
  "  l.each_cons(2) do |a,b|\n    return false if a.sum != b.sum\n  end\n  true\n\
    end", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a.sum != b.sum\n\
    \  end\n  true\nend\n</code>\n<|/ a |>\n<| c |>\nThis solution doesn't work if\
    \ there are two pairs whose sum is zero. For example, `[1,1,0]` returns `true`,\
    \ but `[1,1,1]` returns `false`.\n<|/ c |>\n<| c |>\nYes, you are right. I missed\
    \ that case. Thanks for pointing out.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>",
  "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a.sum != b.sum\n  end\n\
    \  true\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis solution doesn't\
    \ work if there are two pairs that sum to zero. For example, `[1, 1, 0]` returns\
    \ `true` but should return `false`.\n<|/ c |>\n<| c |>\n: I missed that case.\
    \ Thanks for pointing it out. I've updated the answer accordingly.\n<|/ c |>\n\
    <| c |>\nThis solution doesn't work if there are two pairs that sum to zero. For\
    \ example, `[1, 1, 0]` returns `true` but should return `false`.\n<|/ c |>\n<|\
    \ c |>\n: Thanks for pointing it out. I've updated the answer accordingly.\n<|/\
    \ c |>\n<| a dscore=3 |>\n<code>", "  l.sort!\n  l.inject(true) { |sum,x| sum\
    \ && sum + x == 0 }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like\
    \ this solution, but I wonder if there is a way to do this without sorting the\
    \ array. Sorting would take O(n log n) time, but this solution would take O(n)\
    \ time. Is there a way to do this without sorting?\n<|/ c |>\n<| c |>\n: Yes,\
    \ there is a way. I'll post it in a minute.\n<|/ c |>\n<| c |>\n: I posted a solution\
    \ that doesn't require sorting.\n<|/ c |>\n<| c |>\n: I added a solution that\
    \ doesn't require sorting.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "   \
    \ l.sort!\n    return l.inject(true) do |acc, x|\n        acc && x[0] == x[1]\n\
    \    end\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis code does not\
    \ work. Try it with `[1,2,3]`. It returns `true` when it should return `false`.\n\
    <|/ c |>\n<| c |>\n: I tested it with `[1,2,3]` and it returns `false`. I added\
    \ a comment to the question to clarify this.\n<|/ c |>\n<| c |>\n: I added a comment\
    \ to the question to clarify this.\n<|/ c |>\n<| c |>\n: I added a comment to\
    \ the question to clarify this.\n<|/ c |>\n<| c |>\n: I added a comment to the\
    \ question to clarify this.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n\
    \  l.each_cons(2) do |a,b|\n    return false if a.sum != 0 && b.sum != 0\n  end\n\
    \  true\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis is an interesting\
    \ solution. I'm going to have to read up on each_cons to understand how it works.\
    \ Thanks!\n<|/ c |>\n<| c |>\n`each_cons` will iterate over consecutive pairs\
    \ of elements in the array (as opposed to `each_with_index` which iterates over\
    \ pairs of consecutive elements). `each_cons` will yield pairs of consecutive\
    \ elements in the array (as opposed to `each_with_index` which yields pairs of\
    \ consecutive elements in the array).\n<|/ c |>\n<| c |>\nI added some comments\
    \ to the code above. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for the explanation.\
    \ I think I understand it now. One thing I noticed is that you used `each_cons(2)`\
    \ instead of `each_cons(2){|a,b| ...}` because you wanted pairs of consecutive\
    \ elements. I thought `each_cons` would yield pairs of consecutive elements in\
    \ the array. Is that correct?\n<|/ c |>\n<| c |>\nYes, that's correct. `each_cons`\
    \ will yield pairs of consecutive elements in the array (as opposed to `each_with_index`\
    \ which yields pairs of consecutive elements in the array).\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  l.sort!\n  l.inject(true) { |sum, el| sum && el == l[0] + l[1]\
    \ }\nend", "  l.each_cons(2) do |x,y|\n    return true if x.sum == 0 && y.sum\
    \ == 0\n  end\n  false\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return\
    \ false if a-b == 0\n  end\n  true\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    I like your solution. Very elegant. Thanks.\n<|/ c |>\n<| a |>\n<code>", "  l.sort!\n\
    \  l.each_cons(2) do |a, b|\n    return true if a + b == 0\n  end\n  false\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like your solution, but I believe\
    \ that `each_cons` will iterate through the array twice. Once to find the pairs,\
    \ and then again to find the sum. `each_cons` will iterate through the array only\
    \ once.\n<|/ c |>\n<| c |>\nYes, you are right. I was thinking about a more efficient\
    \ solution. I'll edit my answer.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>",
  "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a.sum != 0 && b.sum !=\
    \ 0\n  end\n  true\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>",
  "  l.sort!\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n\
    \  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return\
    \ true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if\
    \ l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] ==\
    \ 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1]\
    \ == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n \
    \ l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1]\
    \ = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l", "  l.sort!\n  l.inject(true)\
    \ { |sum,i| sum && l[i+1..-1].inject(true) { |sum,j| sum && l[j..i].inject(true)\
    \ { |sum,k| sum && l[k+1..j].zero? } } } \nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a tags=ruby,arrays,algorithm |>\n<code>", "    l.sort!\n    return l.inject(true)\
    \ { |sum,i| sum && l[i..-1].inject(true) { |sum,j| sum && l[j..i].inject(true)\
    \ { |sum,k| sum && l[k..j].zero? } } } \nend\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThis doesn't work. Try it with `[1,1,1,1]`.\n<|/ c |>\n<| c |>\n: I fixed\
    \ the bug. Thanks.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  l.sort!\n  l.each_cons(2)\
    \ do |a,b|\n    return false if a+b == 0\n  end\n  true\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like your solution, but I wonder if there is a way to do it without\
    \ sorting the list. Sorting takes O(nlogn) time, and this solution takes O(n).\n\
    <|/ c |>\n<| c |>\n: I thought about it, but I couldn't come up with a better\
    \ solution. Maybe someone else can.\n<|/ c |>\n<| c |>\n: I added a solution that\
    \ doesn't sort the list. Sorting takes O(nlogn) time, but this solution takes\
    \ O(n).\n<|/ c |>\n<| c |>\n: I added a solution that doesn't sort the list. Sorting\
    \ takes O(nlogn) time, but this solution takes O(n).\n<|/ c |>\n<| c |>\n: I added\
    \ a solution that doesn't sort the list. Sorting takes O(nlogn) time, but this\
    \ solution takes O(n).\n<|/ c |>\n<| a tags=ruby,algorithm |>\n<code>", "  l.sort!\n\
    \  return true if l[0] == 0 && l[1] == 0\n  l[0] > l[1]\nend", "  l.sort!\n  return\
    \ true if l[0] == 0 && l[1] == 0\n  l[0] > l[1]\nend", "  l.sort!\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] ==\
    \ 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0],\
    \ l[1] = l[1], l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1],\
    \ l[0]\n  return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n \
    \ return true if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0]\
    \ == 0 && l[1] == 0\n  l[0], l[1] = l[1], l[0]\n  return true if l[0] == 0 &&\
    \ l[1] == 0\n  l[0], l", "  l.sort!\n  return true if l[0] == 0 && l[1] == 0\n\
    \  return false if l[0] == l[1]\n  l[0], l[1] = l[1], l[0]\n  return true if pairs_sum_to_zero(l)\n\
    \  l[0], l[1] = l[1], l[0]\n  return false\nend", "  l.sort!\n  return true if\
    \ l[0] == 0 && l[-1] == 0\n  l[0] > l[-1] ? false : true\nend", "  l.sort!\n \
    \ l.inject(true) { |sum,x| sum && sum + x == 0 }\nend", "  l.sort!\n  return true\
    \ if l[0] == 0 && l[1] == 0\n  return false if l[0] == 0 || l[1] == 0\n  l[0]\
    \ + l[1] == 0\nend", "  l.sort!\n  return true if l[0] == 0 && l[-1] == 0\n  l[0],\
    \ l[-1] = 0, 0\n  l.each_cons(2) do |a, b|\n    return true if a + b == 0\n  end\n\
    \  false\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThe OP asked for \"\
    the most efficient way\", so I used `sort!` instead of `sort`.\n<|/ c |>\n<| c\
    \ |>\nI didn't know about `sort!` until now. Thanks for sharing!\n<|/ c |>\n<|\
    \ a tags=ruby,arrays |>\n<code>", "  l.sort!\n  l.inject(true) { |sum,i| sum &&\
    \ l[i+1] - l[i] == 0 }\nend", "  l.sort!\n  pairs = l.inject([]) do |sums, el|\n\
    \    el = el.to_i\n    sums << el if sums.last + el == 0 \n    sums\n  end\n \
    \ pairs.size == 2\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false\
    \ if a-b > 0\n  end\n  true\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  l.sort!\n  return l.inject(true) { |sum,x| sum && x==0 || sum\
    \ }\nend", "  l.sort!\n  return l.inject(true) { |sum,x| sum && sum + x == 0 }\n\
    end", "  l.sort!\n  return l.inject(true) { |sum,x| sum && x==0 || sum }\nend",
  "  l.sort!\n  l.inject(true) { |sum,x| sum && x==0 || sum }\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nI like the idea of using inject to solve this problem.\
    \ However it seems that this solution does not work if there are two pairs that\
    \ sum to zero. For example, `[1,1,0]` returns `true` but `[1,1,1]` returns `false`.\n\
    <|/ c |>\n<| c |>\nI see what you mean. I updated the answer to account for that\
    \ case.\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution using recursion:\n<code>",
  "  l.sort!\n  l.each_cons(2) do |x,y|\n    return true if y-x == 0\n  end\n  false\n\
    end", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return true if a + b == 0\n \
    \ end\n  false\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", " \
    \ l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a.sum != b.sum\n  end\n\
    \  true\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a+b\
    \ == 0\n  end\n  true\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>",
  "  l.sort!\n  l.each_cons(2) do |x,y|\n    return true if y-x == 0\n  end\n  false\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is not the correct solution. Try\
    \ it with `[2,3,-4,-5,-6,-7,-8]`\n<|/ c |>\n<| c |>\nI agree, my solution was\
    \ a quick and dirty one. I'll edit my answer to include a more robust solution.\n\
    <|/ c |>\n<| c |>\nThis doesn't work. Try it with `[2,3,-4,-5,-6,-7,-8]`\n<|/\
    \ c |>\n<| c |>\nI see what you mean. I've edited my answer to include a more\
    \ robust solution.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n\
    \  l.each_cons(2) do |a,b|\n    return false if a+b == 0\n  end\n  true\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if there are two\
    \ pairs that sum to zero, e.g. `[1,1,0]`\n<|/ c |>\n<| c |>\n: Yes, it does. Try\
    \ it out.\n<|/ c |>\n<| c |>\n: I added a test case to my answer. Try it out.\n\
    <|/ c |>\n<| c |>\n: I added a test case to my answer. Try it out.\n<|/ c |>\n\
    <| c |>\n: I added a test case to my answer. Try it out.\n<|/ c |>\n<| a |>\n\
    <code>", "  l.sort!\n  l.inject(true) { |sum,x| sum && x==0 || sum }\nend", " \
    \ l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a+b == 0\n  end\n  true\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like your solution, but I believe\
    \ it can be improved by using `each_cons` instead of `each_with_index`\n<|/ c\
    \ |>\n<| c |>\nThanks for the suggestion, I've edited my answer to include it.\n\
    <|/ c |>\n<| a dscore=1 |>\nHere's a solution using each_cons:\n<code>", "  l.sort!\n\
    \  l.each_cons(2) do |a,b|\n    return false if a-b == 0\n  end\n  true\nend",
  "  l.each_cons(2) do |a,b|\n    return false if a.sum != 0 && b.sum != 0\n  end\n\
    \  true\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays |>\n<code>", " \
    \ l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a-b == 0\n  end\n  true\n\
    end", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if a-b == 0\n  end\n\
    \  true\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if there are two equal\
    \ numbers in the list. For example, `[1,1,1,1]` returns `true` instead of `false`.\n\
    <|/ c |>\n<| c |>\nI added a version that works with duplicates.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work for `[1,1,1,1]` which should return `false` but returns\
    \ `true`.\n<|/ c |>\n<| c |>\nI added a version that works with duplicates.\n\
    <|/ c |>\n<| c |>\nI added a version that works with duplicates.\n<|/ c |>\n<|\
    \ a tags=ruby,arrays |>\n<code>", "  l.sort!\n  return l.inject(true) { |sum,x|\
    \ sum && x==0 || sum && x==-x}\nend", "  l.sort!\n  return false if l[0] == l[-1]\n\
    \  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0],\
    \ l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1]\
    \ = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1],\
    \ l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n\
    \  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n\
    \  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return\
    \ false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false\
    \ if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if\
    \ l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0]\
    \ == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] ==\
    \ l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n\
    \  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0],\
    \ l[-1] = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1]\
    \ = l[-1], l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1],\
    \ l[0]\n  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n\
    \  l.sort!\n  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n\
    \  return false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return\
    \ false if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false\
    \ if l[0] == l[-1]\n  l[0], l[-1] = l[-1], l[0]\n  l.sort!\n  return false if ",
  "  l.sort!\n  l.inject(true) { |sum,x| sum && sum + x == 0 }\nend", "    l.sort!\n\
    \    return l.inject(true) { |sum, el| sum && el == 0 }\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return\
    \ true if y-x == 0\n  end\n  false\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n\
    \    return false if x == y\n    return true if x + y == 0\n  end\n  true\nend",
  "    l.sort!\n    return l.inject(true) { |sum,x| sum && sum + x == 0 }\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't work if you have a list\
    \ of negative numbers. For example, `[1,2,-3,-4,-5]` returns `true` instead of\
    \ `false`.\n<|/ c |>\n<| c |>\nI tested it and it works fine. `[1,2,-3,-4,-5]`\
    \ returns `false`\n<|/ c |>\n<| c |>\nIt doesn't work for `[1,2,-3,-4,-5]` returns\
    \ `true`\n<|/ c |>\n<| c |>\nIt works for me. `[1,2,-3,-4,-5]` returns `false`\n\
    <|/ c |>\n<| c |>\nIt works for me too. `[1,2,-3,-4,-5]` returns `false`\n<|/\
    \ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  l.sort!\n  l.each_cons(2)\
    \ do |a,b|\n    return false if a-b == 0\n  end\n  true\nend", "  l.sort!\n  return\
    \ l.inject(true) { |sum, el| sum && el == 0 }\nend", "  l.sort!\n  l.inject(true)\
    \ { |sum, el| sum && el == 0 }\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n\
    \    return false if a.sum != b.sum\n  end\n  true\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,arrays |>\n<code>", "  l.sort!\n  return true if l[0] ==\
    \ 0 && l[1] == 0\n  return false if l[0] == l[1]\n  l[0] > l[1]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
