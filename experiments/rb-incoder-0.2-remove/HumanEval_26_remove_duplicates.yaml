name: HumanEval_26_remove_duplicates
language: rb
prompt: "# From a list of integers, remove all elements that occur more than once.\n\
  # Keep order of elements left the same as in the input.\ndef remove_duplicates(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_remove_duplicates\n\
  \    candidate = method(:remove_duplicates)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([1,\
  \ 4, 5], candidate.call([1, 2, 3, 2, 4, 3, 5]))\n  end\nend\n"
completions: ["  numbers.uniq!\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby |>\n\
    <code>", "  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>", "  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    <code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| c |>\nThis doesn't work if you have an array of hashes.\n<|/ c |>\n<|\
    \ c |>\nI believe it does. `[{:a => 1, :b => 2}, {:a => 1, :b => 3}, {:a => 2,\
    \ :b => 4}, {:a => 2, :b => 5}].uniq` returns `[{:a => 1, :b => 2}, {:a => 2,\
    \ :b => 4}, {:a => 2, :b => 5}]`\n<|/ c |>\n<| c |>\nYes, it does. But it also\
    \ returns `[{:a => 1, :b => 3}, {:a => 2, :b => 5}]`\n<|/ c |>\n<| c |>\nYes,\
    \ it does. But it also returns `[{:a => 1, :b => 3}, {:a => 2, :b => 5}]`\n<|/\
    \ c |>\n<| c |>\nYes, it does. But it also returns `[{:a => 1, :b => 3}, {:a =>\
    \ 2, :b => 5}]`\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>",
  "  numbers.uniq!\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,arrays |>\n<code>",
  "  numbers.uniq!\nend\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>", "  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks for\
    \ your answer. I'm new to Ruby, so I'm still trying to understand your answer.\
    \ Can you explain what `numbers.uniq!` does?\n<|/ c |>\n<| c |>\n`uniq!` removes\
    \ duplicate elements from an array. `uniq` would remove duplicate elements from\
    \ an array, but would leave the order unchanged. `uniq!` removes duplicate elements\
    \ from an array while leaving the order unchanged.\n<|/ c |>\n<| c |>\n`uniq!`\
    \ modifies the array in place and returns the modified array. `uniq` returns a\
    \ new array with the duplicates removed. `uniq!` modifies the array in place and\
    \ returns the modified array. `uniq` returns a new array with the duplicates removed.\
    \ `uniq!` modifies the array in place and returns the modified array. `uniq` returns\
    \ a new array with the duplicates removed.\n<|/ c |>\n<| c |>\n`uniq!` modifies\
    \ the array in place and returns the modified array. `uniq` returns a new array\
    \ with the duplicates removed. `uniq!` modifies the array in place and returns\
    \ the modified array. `uniq` returns a new array with the duplicates removed.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  numbers.uniq.sort!\n  numbers.delete_if\
    \ { |n| numbers.count(n) > 1 }\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`numbers.uniq.sort!`\
    \ will modify the original array. `numbers.sort!.uniq` will create a new array\
    \ without modifying the original array.\n<|/ c |>\n<| c |>\n`numbers.uniq.sort!`\
    \ will modify the original array. `numbers.sort!.uniq` will create a new array\
    \ without modifying the original array.\n<|/ c |>\n<| c |>\n`numbers.uniq.sort!`\
    \ will modify the original array. `numbers.sort!.uniq` will create a new array\
    \ without modifying the original array.\n<|/ c |>\n<| c |>\n`numbers.uniq.sort!`\
    \ will modify the original array. `numbers.sort!.uniq` will create a new array\
    \ without modifying the original array.\n<|/ c |>\n<| c |>\n`numbers.uniq.sort!`\
    \ will modify the original array. `numbers.sort!.uniq` will create a new array\
    \ without modifying the original array.\n<|/ c |>\n<| a |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq!` doesn't remove duplicates, it\
    \ just removes duplicates in an array. `uniq` removes duplicates in an array.\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. `uniq!` removes duplicates\
    \ in an array. `uniq` removes duplicates in an array.\n<|/ c |>\n<| c |>\nThis\
    \ should be the accepted answer. `uniq!` removes duplicates in an array. `uniq`\
    \ removes duplicates in an array.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. `uniq!` removes duplicates in an array. `uniq` removes duplicates in\
    \ an array.\n<|/ c |>\n<| c |>\nThis should be the accepted answer. `uniq!` removes\
    \ duplicates in an array. `uniq` removes duplicates in an array.\n<|/ c |>\n<|\
    \ a tags=ruby,arrays,duplicates |>\n<code>", "  numbers.uniq!\nend\n</code>\n\
    <|/ a |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n  numbers\nend",
  "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq!` doesn't remove\
    \ duplicates, it only removes duplicates in the array you call it on. `uniq` removes\
    \ duplicates in the array you call it on. `uniq!` removes duplicates in the array\
    \ you call it on. `uniq` removes duplicates in the array you call it on. `uniq!`\
    \ removes duplicates in the array you call it on. `uniq` removes duplicates in\
    \ the array you call it on. `uniq!` removes duplicates in the array you call it\
    \ on. `uniq` removes duplicates in the array you call it on. `uniq!` removes duplicates\
    \ in the array you call it on. `uniq` removes duplicates in the array you call\
    \ it on. `uniq!` removes duplicates in the array you call it on. `uniq` removes\
    \ duplicates in the array you call it on. `uniq!` removes duplicates in the array\
    \ you call it on. `uniq` removes duplicates in the array you call it on. `uniq!`\
    \ removes duplicates in the array you call it on. `uniq` removes duplicates in\
    \ the array you call it on. `uniq!` removes duplicates in the array you call it\
    \ on. `uniq` removes duplicates in the array you call it on. `uniq!` removes duplicates\
    \ in the array you call it on. `uniq` removes duplicates in the array you call\
    \ it on. `uniq!` removes duplicates in the array you call it on. `uniq` removes\
    \ duplicates in the array you call it on. `uniq!` removes duplicates in the array\
    \ you call it on. `uniq` removes duplicates in the array you call it on. `uniq!`\
    \ removes duplicates in the array you call it on. `uniq` removes duplicates in\
    \ the array you call it on. `uniq!` removes duplicates in the array you call it\
    \ on. `uniq` removes duplicates in the array you call it on. `uniq!` removes duplicates\
    \ in the array you call it on. `uniq` removes duplicates in the array you call\
    \ it on. `uniq!` removes duplicates in the array you call it on. `uniq` removes\
    \ duplicates in the array you call it on. `uniq!` removes duplicates in the array\
    \ you call it on. `uniq` removes duplicates in the array you call it on. `uniq!`\
    \ removes duplicates in the array you call it on. `uniq` removes duplicates in\
    \ the array you call it ", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\n`uniq!` modifies the original array. `uniq` returns a new array without\
    \ modifying the original one.\n<|/ c |>\n<| c |>\n`uniq!` modifies the original\
    \ array. `uniq` returns a new array without modifying the original one.\n<|/ c\
    \ |>\n<| c |>\n`uniq!` modifies the original array. `uniq` returns a new array\
    \ without modifying the original one.\n<|/ c |>\n<| c |>\n`uniq!` modifies the\
    \ original array. `uniq` returns a new array without modifying the original one.\n\
    <|/ c |>\n<| c |>\n`uniq!` modifies the original array. `uniq` returns a new array\
    \ without modifying the original one.\n<|/ c |>\n<| a tags=ruby |>\n<code>", " \
    \ numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=1\
    \ |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\n`uniq` doesn't preserve order\n<|/ c |>\n<| c |>\n`uniq` preserves\
    \ order in Ruby 2.4.\n<|/ c |>\n<| c |>\n`uniq` preserves order in Ruby 2.4.\n\
    <|/ c |>\n<| c |>\n`uniq` preserves order in Ruby 2.4.\n<|/ c |>\n<| c |>\n`uniq`\
    \ preserves order in Ruby 2.4.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", " \
    \ numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis\
    \ doesn't work if you have a hash with duplicate keys. `numbers.uniq!` will remove\
    \ all but one occurrence.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq!` was introduced in Rails 4.\n\
    <|/ c |>\n<| c |>\n`uniq!` was introduced in Rails 4.\n<|/ c |>\n<| c |>\n`uniq!`\
    \ was introduced in Rails 4.\n<|/ c |>\n<| c |>\n`uniq!` was introduced in Rails\
    \ 4.\n<|/ c |>\n<| c |>\n`uniq!` was introduced in Rails 4.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  numbers.uniq!\nend", "  numbers.uniq.sort\nend", "  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq!` doesn't remove duplicates,\
    \ it just removes duplicates in the order they were encountered. `uniq` removes\
    \ duplicates in the order they were encountered.\n<|/ c |>\n<| c |>\n`uniq!` removes\
    \ duplicates in the order they were encountered.\n<|/ c |>\n<| c |>\n`uniq!` removes\
    \ duplicates in the order they were encountered.\n<|/ c |>\n<| c |>\n`uniq!` removes\
    \ duplicates in the order they were encountered.\n<|/ c |>\n<| c |>\n`uniq!` removes\
    \ duplicates in the order they were encountered.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>", "  numbers.uniq!\n  numbers\nend", "  numbers.uniq!\nend\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\n`uniq!` doesn't preserve the order of the elements.\
    \ `uniq` does.\n<|/ c |>\n<| c |>\n`uniq!` preserves the order of the elements.\
    \ `uniq` does not.\n<|/ c |>\n<| c |>\n`uniq!` preserves the order of the elements.\
    \ `uniq` does not.\n<|/ c |>\n<| c |>\n`uniq!` preserves the order of the elements.\
    \ `uniq` does not.\n<|/ c |>\n<| c |>\n`uniq!` preserves the order of the elements.\
    \ `uniq` does not.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  numbers.uniq!\n\
    \  numbers\nend", "  numbers.uniq!\nend", "  numbers.uniq.sort!\n  numbers.uniq!\n\
    end", "  numbers.uniq!\nend\n</code>\n<|/ a |>\n<| c |>\n`uniq!` will remove all\
    \ duplicates, not just the first one.\n<|/ c |>\n<| c |>\n`uniq!` will remove\
    \ all duplicates, not just the first one. `uniq` will remove all duplicates, not\
    \ just the first one.\n<|/ c |>\n<| c |>\n`uniq!` will remove all duplicates,\
    \ not just the first one. `uniq` will remove all duplicates, not just the first\
    \ one. `uniq!` will remove all duplicates, not just the first one. `uniq` will\
    \ remove all duplicates, not just the first one. `uniq!` will remove all duplicates,\
    \ not just the first one. `uniq` will remove all duplicates, not just the first\
    \ one. `uniq!` will remove all duplicates, not just the first one. `uniq` will\
    \ remove all duplicates, not just the first one. `uniq!` will remove all duplicates,\
    \ not just the first one. `uniq` will remove all duplicates, not just the first\
    \ one. `uniq!` will remove all duplicates, not just the first one. `uniq` will\
    \ remove all duplicates, not just the first one. `uniq!` will remove all duplicates,\
    \ not just the first one. `uniq` will remove all duplicates, not just the first\
    \ one. `uniq!` will remove all duplicates, not just the first one. `uniq` will\
    \ remove all duplicates, not just the first one. `uniq!` will remove all duplicates,\
    \ not just the first one. `uniq` will remove all duplicates, not just the first\
    \ one. `uniq!` will remove all duplicates, not just the first one. `uniq` will\
    \ remove all duplicates, not just the first one. `uniq!` will remove all duplicates,\
    \ not just the first one. `uniq` will remove all duplicates, not just the first\
    \ one. `uniq!` will remove all duplicates, not just the first one. `uniq` will\
    \ remove all duplicates, not just the first one. `uniq!` will remove all duplicates,\
    \ not just the first one. `uniq` will remove all duplicates, not just the first\
    \ one. `uniq!` will remove all duplicates, not just the first one. `uniq` will\
    \ remove all duplicates, not just the first one. `uniq!` will remove all duplicates,\
    \ not just the first one. `uniq` will remove all duplicates, not just the first\
    \ one. `uniq!` will remove all duplicates, not just the first one. `uniq` will\
    \ remove all duplicates, not just the first one. `", "  numbers.uniq!\n  numbers\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby |>\n<code>", "  numbers.uniq!\n\
    \  numbers\nend", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\n`uniq!` modifies the original array. `uniq` returns a new array without\
    \ modifying the original one.\n<|/ c |>\n<| c |>\nThanks, I didn't know that.\
    \ I've updated my answer.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n\
    end", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| c |>\nThis doesn't work if you have a hash with duplicate keys. `Hash.new(0)`\
    \ will give you a hash with duplicate keys, but the values will be `nil`. `Hash.new(0)`\
    \ will give you a hash with duplicate keys, but the values will be `0`.\n<|/ c\
    \ |>\n<| c |>\nGood point. I've updated the answer to include a solution that\
    \ will work for hashes with duplicate keys.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if you have a hash with duplicate keys. `Hash.new(0)` will give you a hash with\
    \ duplicate keys, but the values will be `nil`. `Hash.new(0)` will give you a\
    \ hash with duplicate keys, but the values will be `0`.\n<|/ c |>\n<| c |>\nGood\
    \ point. I've updated the answer to include a solution that will work for hashes\
    \ with duplicate keys.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`uniq!`\
    \ modifies the original array. `uniq` returns a new array without modifying the\
    \ original array.\n<|/ c |>\n<| c |>\nI see that now. Thanks for pointing that\
    \ out. I've updated the answer.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  numbers.uniq!\n\
    \  numbers\nend", "  numbers.uniq!\n  numbers\nend", "  numbers.uniq!\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nI believe this should be the accepted answer. `uniq!`\
    \ removes duplicates and keeps the original order.\n<|/ c |>\n<| c |>\n`uniq!`\
    \ doesn't remove duplicates. It just removes duplicates from an array. `uniq`\
    \ removes duplicates and keeps the original order.\n<|/ c |>\n<| c |>\n`uniq!`\
    \ removes duplicates and keeps the original order. `uniq` removes duplicates and\
    \ keeps the original order. `uniq!` removes duplicates and keeps the original\
    \ order. `uniq` removes duplicates and keeps the original order. `uniq!` removes\
    \ duplicates and keeps the original order. `uniq` removes duplicates and keeps\
    \ the original order. `uniq!` removes duplicates and keeps the original order.\
    \ `uniq` removes duplicates and keeps the original order. `uniq!` removes duplicates\
    \ and keeps the original order. `uniq` removes duplicates and keeps the original\
    \ order. `uniq!` removes duplicates and keeps the original order. `uniq` removes\
    \ duplicates and keeps the original order. `uniq!` removes duplicates and keeps\
    \ the original order. `uniq` removes duplicates and keeps the original order.\
    \ `uniq!` removes duplicates and keeps the original order. `uniq` removes duplicates\
    \ and keeps the original order. `uniq!` removes duplicates and keeps the original\
    \ order. `uniq` removes duplicates and keeps the original order. `uniq!` removes\
    \ duplicates and keeps the original order. `uniq` removes duplicates and keeps\
    \ the original order. `uniq!` removes duplicates and keeps the original order.\
    \ `uniq` removes duplicates and keeps the original order. `uniq!` removes duplicates\
    \ and keeps the original order. `uniq` removes duplicates and keeps the original\
    \ order. `uniq!` removes duplicates and keeps the original order. `uniq` removes\
    \ duplicates and keeps the original order. `uniq!` removes duplicates and keeps\
    \ the original order. `uniq` removes duplicates and keeps the original order.\
    \ `uniq!` removes duplicates and keeps the original order. `uniq` removes duplicates\
    \ and keeps the original order. `uniq!` removes duplicates and keeps the original\
    \ order. `uniq` removes duplicates and keeps the original order. `uniq!` removes\
    \ duplicates and keeps the original order. `uniq` removes duplicates and ", " \
    \ numbers.uniq.sort\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<|\
    \ a tags=ruby,arrays,ruby-on-rails |>\n<code>", "  numbers.uniq!\n  numbers\n\
    end", "  numbers.uniq!\nend", "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n\
    <|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in the array.\n<|/ c |>\n<| c |>\nIt does work if there are duplicates in the\
    \ array. `uniq` removes duplicates.\n<|/ c |>\n<| c |>\n`uniq` removes duplicates,\
    \ but it also removes order. `uniq!` removes order and removes duplicates.\n<|/\
    \ c |>\n<| c |>\n`uniq!` removes duplicates and removes order. `uniq` removes\
    \ duplicates and removes order.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates\
    \ and removes order. `uniq` removes duplicates and removes order.\n<|/ c |>\n\
    <| a tags=ruby,arrays,sorting |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/\
    \ a dscore=5 |>\n<| c |>\nThis should be the accepted answer. `uniq!` was introduced\
    \ in Rails 4.\n<|/ c |>\n<| c |>\n`uniq!` was introduced in Rails 4.2\n<|/ c |>\n\
    <| c |>\n`uniq!` was introduced in Rails 4.2\n<|/ c |>\n<| c |>\n`uniq!` was introduced\
    \ in Rails 4.2\n<|/ c |>\n<| c |>\n`uniq!` was introduced in Rails 4.2\n<|/ c\
    \ |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI love this solution. Simple and elegant.\n<|/ c |>\n<| c |>\n\
    I love this solution. Simple and elegant.\n<|/ c |>\n<| c |>\nI love this solution.\
    \ Simple and elegant.\n<|/ c |>\n<| c |>\nI love this solution. Simple and elegant.\n\
    <|/ c |>\n<| c |>\nI love this solution. Simple and elegant.\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>", "  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThanks for your answer. Unfortunately, I cannot use Ruby 2.3 or\
    \ above. :(\n<|/ c |>\n<| c |>\nI see. Then I guess you have to implement your\
    \ own `uniq` method then.\n<|/ c |>\n<| c |>\nI guess I should do that. Thanks\
    \ for your help!\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\nThis doesn't work\
    \ if you have an array of hashes though.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if you have an array of hashes though.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if you have an array of hashes though.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    array.uniq.compact\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\n\
    This doesn't work if you have an array of hashes though.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have an array of hashes though.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have an array of hashes though.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have an array of hashes though.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have an array of hashes though.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<code>\narray.uniq.compact\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't\
    \ work if you have an array of hashes though.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have an array of hashes though.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have an array of hashes though.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have an array of hashes though.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have an array of hashes though.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<code>\narray.uniq.compact\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't\
    \ work if you have an array of hashes though.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have an array of hashes though.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have an array of hashes though.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<code>\narray.uniq.compact\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't\
    \ work if you have an array of hashes though.\n<|/ c |>\n<| c ", "  numbers.uniq!\n\
    end\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\n`uniq!` doesn't\
    \ remove duplicates, it just removes duplicates from the array in-place. `uniq`\
    \ returns a new array with the duplicates removed.\n<|/ c |>\n<| c |>\n: I didn't\
    \ know that. Thanks for pointing that out.\n<|/ c |>\n<| c |>\n`uniq!` doesn't\
    \ remove duplicates, it just removes duplicates from the array in-place. `uniq`\
    \ returns a new array with the duplicates removed.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<code>", "  numbers.uniq!\n  numbers\nend", "  numbers.uniq!\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't work if you have an array\
    \ of hashes, where you only want to remove duplicates from one of the hashes.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq.sort\nend", "  numbers.uniq!\n\
    end", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=1\
    \ |>\n<code>", "  numbers.uniq!\nend", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\n<| a dscore=0 |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\n  numbers\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`uniq` does not remove duplicates.\
    \ It just removes duplicates from an array. `uniq!` removes duplicates from an\
    \ array.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've updated the answer.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n\
    a.delete_if { |x| a.count(x) > 1 }\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    This solution is O(n^2) (n being the length of the array), while `uniq` solution\
    \ is O(n) (n being the length of the array).\n<|/ c |>\n<| c |>\n`delete_if` is\
    \ O(n), but `count` is O(n^2)\n<|/ c |>\n<| c |>\n`delete_if` is O(n), but `count`\
    \ is O(n^2)\n<|/ c |>\n<| c |>\n`delete_if` is O(n), but `count` is O(n^2)\n<|/\
    \ c |>\n<| c |>\n`delete_if` is O(n), but `count` is O(n^2)\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\na.uniq!\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis solution is O(n^2) (n being the length\
    \ of the array), while `uniq` solution is O(n) (n being the length of the array).\n\
    <|/ c |>\n<| c |>\n`uniq!` is O(n), but `count` is O(n^2)\n<|/ c |>\n<| c |>\n\
    `uniq!` is O(n), but `count` is O(n^2)\n<|/ c |>\n<| c |>\n`uniq!` is O(n), but\
    \ `count` is O(n^2)\n<|/ c |>\n<| a |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n\
    a.delete_if { |x| a.count(x) > 1 }\n</code>\n<|/ a tags=ruby,arrays dscore=5 |>\n\
    <| c |>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>",
  "  numbers.uniq!\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", " \
    \ numbers.uniq!\nend\n</code>\n<|/ a |>\n<| c |>\nI like this solution, but I\
    \ wonder if there's a way to do it without using uniq!\n<|/ c |>\n<| c |>\nI added\
    \ a solution without uniq!\n<|/ c |>\n<| c |>\nThanks for your answer. I'm still\
    \ trying to understand how it works. I understand that `uniq!` removes duplicates,\
    \ but how does it know to remove duplicates in the order of the original array?\
    \ Does it just look at the first element and compare it to the rest? If so, how\
    \ does it know to compare the first element to the second element?\n<|/ c |>\n\
    <| c |>\nIt compares them in order. For example, if you have `[1,2,3,4,5,5,6,7]`,\
    \ it will compare the first two elements and remove duplicates. Then it will compare\
    \ the second two elements and remove duplicates. Then it will compare the third\
    \ two elements and remove duplicates. Then it will compare the fourth two elements\
    \ and remove duplicates. Then it will compare the fifth two elements and remove\
    \ duplicates. Then it will compare the sixth two elements and remove duplicates.\
    \ Then it will compare the seventh two elements and remove duplicates. Then it\
    \ will compare the eighth two elements and remove duplicates. Then it will compare\
    \ the ninth two elements and remove duplicates.\n<|/ c |>\n<| c |>\nSo it compares\
    \ the first two elements and removes duplicates. Then it compares the second two\
    \ elements and removes duplicates. Then it compares the third two elements and\
    \ removes duplicates. Then it compares the fourth two elements and removes duplicates.\
    \ Then it compares the fifth two elements and removes duplicates. Then it compares\
    \ the sixth two elements and removes duplicates. Then it compares the seventh\
    \ two elements and removes duplicates. Then it compares the eighth two elements\
    \ and removes duplicates. Then it compares the ninth two elements and removes\
    \ duplicates. Then it compares the tenth two elements and removes duplicates.\
    \ Then it compares the eleventh two elements and removes duplicates. Then it compares\
    \ the twelfth two elements and removes duplicates. Then it compares the thirteenth\
    \ two elements and removes duplicates. Then it compares the fourteenth two elements\
    \ and removes duplicates. Then it compares the fifteenth two elements and removes\
    \ duplicates. Then it compares the sixteenth two elements and removes duplicates.\
    \ Then it compares the seventeenth two elements and removes duplicates. Then it\
    \ compares the eighteenth two elements and remove", "  numbers.uniq!\nend\n</code>\n\
    <|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c |>\n`uniq!` doesn't remove\
    \ duplicates, it just removes duplicates from an array. `uniq` removes duplicates\
    \ from an array.\n<|/ c |>\n<| c |>\n: You're right. I've edited my answer to\
    \ reflect that. Thanks!\n<|/ c |>\n<| a dscore=5 |>\n<code>\n[1,2,2,3,4].uniq\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c |>\nThis doesn't\
    \ answer the question, which is about removing duplicates.\n<|/ c |>\n<| c |>\n\
    This doesn't answer the question, which is about removing duplicates.\n<|/ c |>\n\
    <| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>\n[1,2,2,3,4].uniq\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis doesn't answer the question, which is about removing\
    \ duplicates.\n<|/ c |>\n<| a |>\n<code>\n[1,2,2,3,4].uniq\n</code>\n<|/ a dscore=5\
    \ tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c |>\nThis doesn't answer the\
    \ question, which is about removing duplicates.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ answer the question, which is about removing duplicates.\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>\n[1,2,2,3,4].uniq\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>\n[1,2,2,3,4].uniq\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't answer the question, which is\
    \ about removing duplicates.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n[1,2,2,3,4].uniq\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| a |>\n<code>\n[1,2,2,3,4].uniq\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 dscore=5 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rail",
  "  numbers.uniq!\nend", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\n`uniq!` doesn't remove duplicates, it only removes duplicates in place (and\
    \ returns `nil` if the array is empty). `uniq` does remove duplicates.\n<|/ c\
    \ |>\n<| c |>\nThanks, I fixed the answer.\n<|/ c |>\n<| a tags=ruby |>\n<code>",
  "  numbers.uniq!\nend", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nThis doesn't work if you have a hash with duplicate keys. `[1,2,2,3].uniq`\
    \ returns `[1,2,3]` but `[1,2,2,3].uniq { |x| x }` returns `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\n: That's a good point. I've added a note about that to the answer.\n\
    <|/ c |>\n<| c |>\n`uniq` doesn't work if you have a hash with duplicate keys.\
    \ `[1,2,2,3].uniq` returns `[1,2,3]` but `[1,2,2,3].uniq { |x| x }` returns `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\n: That's a good point. I've added a note about that to the\
    \ answer.\n<|/ c |>\n<| a dscore=5 |>\n<code>\na = [1,2,2,3]\na.uniq\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if you have a hash with\
    \ duplicate keys. `[1,2,2,3].uniq` returns `[1,2,3]` but `[1,2,2,3].uniq { |x|\
    \ x }` returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a\
    \ hash with duplicate keys. `[1,2,2,3].uniq` returns `[1,2,3]` but `[1,2,2,3].uniq\
    \ { |x| x }` returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nThis doesn't work if you have\
    \ a hash with duplicate keys. `[1,2,2,3].uniq` returns `[1,2,3]` but `[1,2,2,3].uniq\
    \ { |x| x }` returns `[1,2,3]`.\n<|/ c |>\n<| a dscore=5 |>\n<code>\na = [1,2,2,3]\n\
    a.uniq\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if you\
    \ have a hash with duplicate keys. `[1,2,2,3].uniq` returns `[1,2,3]` but `[1,2,2,3].uniq\
    \ { |x| x }` returns `[1,2,3]`.\n<|/ c |>\n<| a dscore=5 |>\n<code>\na = [1,2,2,3]\n\
    a.uniq\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if you ",
  "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    This doesn't work if you have an array of hashes, where you only want to remove\
    \ duplicates from one of the hashes.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ you have an array of hashes, where you only want to remove duplicates from one\
    \ of the hashes.\n<|/ c |>\n<| c |>\nThis doesn't work if you have an array of\
    \ hashes, where you only want to remove duplicates from one of the hashes.\n<|/\
    \ c |>\n<| c |>\nThis doesn't work if you have an array of hashes, where you only\
    \ want to remove duplicates from one of the hashes.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have an array of hashes, where you only want to remove duplicates\
    \ from one of the hashes.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq.sort!\n\
    \  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=0 |>\n\
    <code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=2\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like\
    \ this solution, but I wonder if there is a way to do this without having to call\
    \ uniq!? I mean, is there a way to do it without having to call uniq!?\n<|/ c\
    \ |>\n<| c |>\nI guess you could do something like `numbers.inject([]) { |memo,\
    \ num| memo << num if memo.count(num) == 1 }`, but that's a lot more code than\
    \ `uniq!`.\n<|/ c |>\n<| c |>\n`uniq!` modifies the original array, so it would\
    \ be better to do `numbers = numbers.uniq`\n<|/ c |>\n<| c |>\n`uniq!` modifies\
    \ the original array, so it would be better to do `numbers = numbers.uniq`\n<|/\
    \ c |>\n<| c |>\n`uniq!` modifies the original array, so it would be better to\
    \ do `numbers = numbers.uniq`\n<|/ c |>\n<| a dscore=5 tags=ruby,arrays |>\n<code>\n\
    numbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\nnumbers.uniq!\n\
    </code>\n<|/ a |>\n<| c |>\nThis modifies the original array, so it would be better\
    \ to do `numbers = numbers.uniq`\n<|/ c |>\n<| c |>\nThis modifies the original\
    \ array, so it would be better to do `numbers = numbers.uniq`\n<|/ c |>\n<| c\
    \ |>\nThis modifies the original array, so it would be better to do `numbers =\
    \ numbers.uniq`\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\nnumbers = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n\
    numbers.delete_if { |x| numbers.count(x) == 1 }\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis modifies the original array, so it would be better to do `numbers\
    \ = numbers.uniq`\n<|/ c |>\n<| c |>\nThis modifies the original array, so it\
    \ would be better to do `numbers = numbers.uniq`\n<|/ c |>\n<| c |>\nThis modifies\
    \ the original array, so it would be better to do `numbers = numbers.uniq`\n<|/\
    \ c |>\n<| c |>\nThis modifies the original array, so it would be better to do\
    \ `numbers = numbers.uniq`\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution, but I wonder if\
    \ there is a way to do this without using uniq!\n<|/ c |>\n<| c |>\nI believe\
    \ that `uniq!` will create a new array and remove all duplicates. I believe that\
    \ `uniq` will remove all duplicates and leave the original array untouched.\n\
    <|/ c |>\n<| c |>\n`uniq!` will create a new array and remove all duplicates.\
    \ `uniq` will remove all duplicates and leave the original array untouched.\n\
    <|/ c |>\n<| c |>\n`uniq!` will create a new array and remove all duplicates.\
    \ `uniq` will remove all duplicates and leave the original array untouched.\n\
    <|/ c |>\n<| c |>\n`uniq!` will create a new array and remove all duplicates.\
    \ `uniq` will remove all duplicates and leave the original array untouched.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer.\
    \ Using `uniq` instead of `uniq!` will preserve the original order.\n<|/ c |>\n\
    <| c |>\nThis should be the accepted answer. Using `uniq` instead of `uniq!` will\
    \ preserve the original order.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. Using `uniq` instead of `uniq!` will preserve the original order.\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. Using `uniq` instead of\
    \ `uniq!` will preserve the original order.\n<|/ c |>\n<| c |>\nThis should be\
    \ the accepted answer. Using `uniq` instead of `uniq!` will preserve the original\
    \ order.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if you have an array of hashes,\
    \ as `uniq` will remove all hashes except the first one.\n<|/ c |>\n<| c |>\n\
    I believe this would work if you used `uniq!` instead of `uniq`.\n<|/ c |>\n<|\
    \ c |>\nYes, that would work. `uniq!` modifies the array in place, so it modifies\
    \ the original array as well.\n<|/ c |>\n<| c |>\nThis doesn't work if you have\
    \ an array of hashes, as `uniq` will remove all hashes except the first one.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have an array of hashes, as `uniq`\
    \ will remove all hashes except the first one.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\nThis doesn't work if you have a hash with duplicate keys. `[1,2,2,3].uniq`\
    \ returns `[1,2,3]`.\n<|/ c |>\n<| c |>\n: It does work if you have a hash with\
    \ duplicate keys. `[1,2,2,3].uniq { |x| x }` returns `[1,2,3]`.\n<|/ c |>\n<|\
    \ c |>\n: Yes, I know. I was just pointing out that your solution doesn't work\
    \ if you have a hash with duplicate keys.\n<|/ c |>\n<| c |>\n: I see what you\
    \ mean. I've updated my answer to reflect that.\n<|/ c |>\n<| c |>\n: I see what\
    \ you mean. I've updated my answer to reflect that.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>\na = [1,2,2,3]\na.uniq", "  numbers.uniq.sort!\n  numbers.uniq!\nend\n\
    </code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=1 |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI love this solution. Very elegant.\
    \ Thank you!\n<|/ c |>\n<| c |>\nThis should be the accepted answer. Much more\
    \ elegant than a custom method.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. Much more elegant than a custom method.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. Much more elegant than a custom method.\n<|/ c |>\n\
    <| c |>\nThis should be the accepted answer. Much more elegant than a custom method.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThe `uniq!` method was added in Ruby 2.4.  If you are using an\
    \ older version of Ruby, you can use the `uniq` method instead.  See [this answer](http://stackoverflow.com/a/4155473/477037)\
    \ for more details.\n<|/ c |>\n<| c |>\n`uniq!` was added in Ruby 2.4.\n<|/ c\
    \ |>\n<| c |>\n`uniq!` was added in Ruby 2.4.\n<|/ c |>\n<| c |>\n`uniq!` was\
    \ added in Ruby 2.4.\n<|/ c |>\n<| c |>\n`uniq!` was added in Ruby 2.4.\n<|/ c\
    \ |>\n<| a tags=ruby |>\n<code>", "  numbers.uniq!\n  numbers\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThe `uniq` method was added in Ruby 2.1, so this answer\
    \ is no longer valid. `uniq!` was added in Ruby 2.2, so this answer is no longer\
    \ valid.\n<|/ c |>\n<| c |>\n`uniq` was added in Ruby 2.2, but `uniq!` was added\
    \ in Ruby 2.1. `uniq!` was added in Ruby 2.2, but `uniq` was added in Ruby 2.1.\
    \ `uniq!` was added in Ruby 2.2, but `uniq` was added in Ruby 2.1. `uniq!` was\
    \ added in Ruby 2.2, but `uniq` was added in Ruby 2.1. `uniq!` was added in Ruby\
    \ 2.2, but `uniq` was added in Ruby 2.1. `uniq!` was added in Ruby 2.2, but `uniq`\
    \ was added in Ruby 2.1. `uniq!` was added in Ruby 2.2, but `uniq` was added in\
    \ Ruby 2.1. `uniq!` was added in Ruby 2.2, but `uniq` was added in Ruby 2.1. `uniq!`\
    \ was added in Ruby 2.2, but `uniq` was added in Ruby 2.1. `uniq!` was added in\
    \ Ruby 2.2, but `uniq` was added in Ruby 2.1. `uniq!` was added in Ruby 2.2, but\
    \ `uniq` was added in Ruby 2.1. `uniq!` was added in Ruby 2.2, but `uniq` was\
    \ added in Ruby 2.1. `uniq!` was added in Ruby 2.2, but `uniq` was added in Ruby\
    \ 2.1. `uniq!` was added in Ruby 2.2, but `uniq` was added in Ruby 2.1. `uniq!`\
    \ was added in Ruby 2.2, but `uniq` was added in Ruby 2.1. `uniq!` was added in\
    \ Ruby 2.2, but `uniq` was added in Ruby 2.1. `uniq!` was added in Ruby 2.2, but\
    \ `uniq` was added in Ruby 2.1. `uniq!` was added in Ruby 2.2, but `uniq` was\
    \ added in Ruby 2.1. `uniq!` was added in Ruby 2.2, but `uniq` was added in Ruby\
    \ 2.1. `uniq!` was added in Ruby 2.2, but `uniq` was added in Ruby 2.1. ", " \
    \ numbers.uniq.sort\nend", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  numbers.uniq!\n  numbers\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`uniq!` modifies the original\
    \ array. `uniq` returns a new array without modifying the original.\n<|/ c |>\n\
    <| c |>\nThanks for pointing that out. I was thinking about `uniq` but was too\
    \ lazy to look up the docs. I edited my answer to reflect that.\n<|/ c |>\n<|\
    \ c |>\n`uniq!` modifies the original array. `uniq` returns a new array without\
    \ modifying the original.\n<|/ c |>\n<| c |>\n`uniq!` modifies the original array.\
    \ `uniq` returns a new array without modifying the original.\n<|/ c |>\n<| c |>\n\
    `uniq!` modifies the original array. `uniq` returns a new array without modifying\
    \ the original.\n<|/ c |>\n<| a dscore=5 |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n\
    a.delete_if { |x| a.count(x) == 1 }\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\nThis should be the accepted answer. `delete_if` will create a new array\
    \ instead of modifying the existing one.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `delete_if` will create a new array instead of modifying the\
    \ existing one.\n<|/ c |>\n<| c |>\nThis should be the accepted answer. `delete_if`\
    \ will create a new array instead of modifying the existing one.\n<|/ c |>\n<|\
    \ c |>\nThis should be the accepted answer. `delete_if` will create a new array\
    \ instead of modifying the existing one.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `delete_if` will create a new array instead of modifying the\
    \ existing one.\n<|/ c |>\n<| a dscore=5 |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n\
    a.delete_if { |x| a.count(x) == 1 }\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\nThis should be the accepted answer. `delete_if` will create a new array\
    \ instead of modifying the existing one.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `delete_if` will create a new array instead of modifying the\
    \ existing one.\n<|/ c |>\n<|", "  numbers.uniq.sort!\n  numbers.uniq!\nend",
  "  numbers.uniq!\n  numbers\nend", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't answer the question, which is about removing duplicates\
    \ from an array. Your solution removes duplicates from an array.\n<|/ c |>\n<|\
    \ c |>\nI believe it does. `uniq!` removes duplicates from an array. `uniq` does\
    \ not.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates from an array. `uniq` does\
    \ not.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates from an array. `uniq` does\
    \ not.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates from an array. `uniq` does\
    \ not.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n  numbers\n\
    end", "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\n`uniq` doesn't preserve the order of elements. `uniq!` does.\n<|/ c |>\n\
    <| c |>\n`uniq` preserves the order of the elements. `uniq!` does not.\n<|/ c\
    \ |>\n<| c |>\n`uniq` preserves the order of the elements. `uniq!` does not.\n\
    <|/ c |>\n<| c |>\n`uniq` preserves the order of the elements. `uniq!` does not.\n\
    <|/ c |>\n<| c |>\n`uniq` preserves the order of the elements. `uniq!` does not.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<| a tags=ruby,arrays,ruby-on-rails |>\n<code>", "  numbers.uniq!\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't work if you have a list of `[1,2,2,3]`\n\
    <|/ c |>\n<| c |>\nYes, it does. I tested it before posting it. I just added a\
    \ comment to the OP's question to clarify that he wants to keep order of elements\
    \ left the same as in the input.\n<|/ c |>\n<| c |>\nYes, I see it now. Sorry\
    \ for the misunderstanding.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  numbers.uniq!\n\
    end", "  numbers.uniq!\nend\n</code>\n<|/ a |>\n<| a |>\n<code>", "  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`uniq!` modifies\
    \ the array in place, so you don't need to return it.\n<|/ c |>\n<| c |>\nI didn't\
    \ know that. Thanks for the tip!\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>",
  "  numbers.uniq.sort!\n  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\n`uniq` doesn't preserve order. `uniq!` does.\n<|/ c |>\n<| c |>\n\
    Thanks, I didn't know that. I've updated the answer.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| a dscore=0 |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI believe this should be the accepted answer. Using `uniq!` will\
    \ remove duplicates and keep order. `uniq` will remove duplicates and return an\
    \ array.\n<|/ c |>\n<| c |>\n`uniq!` will remove duplicates and keep order. `uniq`\
    \ will remove duplicates and return an array.\n<|/ c |>\n<| c |>\n`uniq!` will\
    \ remove duplicates and keep order. `uniq` will remove duplicates and return an\
    \ array.\n<|/ c |>\n<| c |>\n`uniq!` will remove duplicates and keep order. `uniq`\
    \ will remove duplicates and return an array.\n<|/ c |>\n<| c |>\n`uniq!` will\
    \ remove duplicates and keep order. `uniq` will remove duplicates and return an\
    \ array.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq!\n  numbers\nend\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work if you have an array of\
    \ hashes, where you only want to keep the first hash that matches a given key.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have an array of hashes, where you\
    \ only want to keep the first hash that matches a given key.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have an array of hashes, where you only want to keep\
    \ the first hash that matches a given key.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if you have an array of hashes, where you only want to keep the first hash that\
    \ matches a given key.\n<|/ c |>\n<| c |>\nThis doesn't work if you have an array\
    \ of hashes, where you only want to keep the first hash that matches a given key.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| c |>\nThis doesn't work if you have a hash with duplicate keys. `{ 1\
    \ => 1, 2 => 2, 3 => 3 }.uniq => { 1 => 1, 2 => 2, 3 => 3 }`\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have a hash with duplicate keys. `{ 1 => 1, 2 => 2, 3\
    \ => 3 }.uniq => { 1 => 1, 2 => 2, 3 => 3 }`\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have a hash with duplicate keys. `{ 1 => 1, 2 => 2, 3 => 3 }.uniq\
    \ => { 1 => 1, 2 => 2, 3 => 3 }`\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`uniq` doesn't preserve the\
    \ order of the elements. `uniq!` does.\n<|/ c |>\n<| c |>\nYes, I realized that\
    \ after I posted my answer. Thanks for pointing it out.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a |>\n<| c |>\nI like your\
    \ solution, but I wonder why it works. I thought that `uniq!` would remove all\
    \ duplicates, not just the first one. Why does it work?\n<|/ c |>\n<| c |>\nIt\
    \ removes duplicates, but keeps the order of the elements. So `[1,2,2,3]` becomes\
    \ `[1,2,3]`.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates, but keeps the order\
    \ of the elements. So `[1,2,2,3]` becomes `[1,2,3]`.\n<|/ c |>\n<| c |>\nI see.\
    \ So `uniq!` removes duplicates, but keeps the order of the elements. So `[1,2,2,3]`\
    \ becomes `[1,2,3]`.\n<|/ c |>\n<| c |>\nYes, that's right. `uniq!` removes duplicates,\
    \ but keeps the order of the elements. So `[1,2,2,3]` becomes `[1,2,3]`.\n<|/\
    \ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer.\
    \ `uniq` removes duplicates, `sort!` sorts them and `uniq!` removes duplicates.\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. `uniq` removes duplicates,\
    \ `sort!` sorts them and `uniq!` removes duplicates.\n<|/ c |>\n<| c |>\nThis\
    \ should be the accepted answer. `uniq` removes duplicates, `sort!` sorts them\
    \ and `uniq!` removes duplicates.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. `uniq` removes duplicates, `sort!` sorts them and `uniq!` removes duplicates.\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. `uniq` removes duplicates,\
    \ `sort!` sorts them and `uniq!` removes duplicates.\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>", "  numbers.uniq!\nend", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\n`uniq!` was introduced in Rails 4.2, so this answer won't work\
    \ in Rails 4.1.\n<|/ c |>\n<| c |>\n`uniq!` was introduced in Rails 4.2, so this\
    \ answer won't work in Rails 4.1.\n<|/ c |>\n<| c |>\n`uniq!` was introduced in\
    \ Rails 4.2, so this answer won't work in Rails 4.1.\n<|/ c |>\n<| c |>\n`uniq!`\
    \ was introduced in Rails 4.2, so this answer won't work in Rails 4.1.\n<|/ c\
    \ |>\n<| c |>\n`uniq!` was introduced in Rails 4.2, so this answer won't work\
    \ in Rails 4.1.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq.sort!\n\
    \  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n\
    <| c |>\n`uniq!` does not remove duplicates. `uniq` does.\n<|/ c |>\n<| c |>\n\
    Thanks, I fixed the typo.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a tags=ruby,arrays,duplicates |>\n<| a dscore=1 |>\n<code>",
  "  numbers.uniq!\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a |>\n<| c |>\n`uniq!` modifies\
    \ the original array, so `numbers` will no longer be an array.\n<|/ c |>\n<| c\
    \ |>\nGood point. I've updated the answer to show how to preserve the original\
    \ array.\n<|/ c |>\n<| c |>\n`uniq!` modifies the original array, so `numbers`\
    \ will no longer be an array.\n<|/ c |>\n<| c |>\n`uniq!` modifies the original\
    \ array, so `numbers` will no longer be an array.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq!` modifies\
    \ the original array. `uniq` returns a new array without modifying the original\
    \ array.\n<|/ c |>\n<| c |>\n`uniq!` modifies the original array and returns nil.\
    \ `uniq` returns a new array without modifying the original array.\n<|/ c |>\n\
    <| c |>\n`uniq!` modifies the original array and returns nil. `uniq` returns a\
    \ new array without modifying the original array.\n<|/ c |>\n<| c |>\n`uniq!`\
    \ modifies the original array and returns nil. `uniq` returns a new array without\
    \ modifying the original array.\n<|/ c |>\n<| c |>\n`uniq!` modifies the original\
    \ array and returns nil. `uniq` returns a new array without modifying the original\
    \ array.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n  numbers\n\
    end", "  numbers.uniq!\nend", "  numbers.uniq!\nend", "  numbers.uniq!\nend\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq!` doesn't remove duplicates, it just\
    \ removes duplicates from an array. `uniq` removes duplicates from an array.\n\
    <|/ c |>\n<| c |>\n`uniq!` removes duplicates from an array. `uniq` removes duplicates\
    \ from an array.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates from an array.\
    \ `uniq` removes duplicates from an array.\n<|/ c |>\n<| c |>\n`uniq!` removes\
    \ duplicates from an array. `uniq` removes duplicates from an array.\n<|/ c |>\n\
    <| c |>\n`uniq!` removes duplicates from an array. `uniq` removes duplicates from\
    \ an array.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10]\n\
    a.delete_if { |x| a.count(x) == 1 }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ should be the accepted answer. Much more efficient than `uniq!`\n<|/ c |>\n\
    <| c |>\nThis should be the accepted answer. Much more efficient than `uniq!`\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. Much more efficient than\
    \ `uniq!`\n<|/ c |>\n<| c |>\nThis should be the accepted answer. Much more efficient\
    \ than `uniq!`\n<|/ c |>\n<| c |>\nThis should be the accepted answer. Much more\
    \ efficient than `uniq!`\n<|/ c |>\n<| a dscore=5 |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10]\n\
    a.delete_if { |x| a.count(x) > 1 }\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    This should be the accepted answer. Much more efficient than `uniq!`\n<|/ c |>\n\
    <| c |>\nThis should be the accepted answer. Much more efficient than `uniq!`\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. Much more efficient than\
    \ `uniq!`\n<|/ c |>\n<| c |>\nThis should be the accepted answer. Much more efficient\
    \ than `uniq!`\n<|/ c |>", "  numbers.uniq!\n  numbers\nend", "  numbers.uniq.sort!\n\
    \  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=1\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\n`uniq!` doesn't preserve the original order of the elements. `uniq` does.\n\
    <|/ c |>\n<| c |>\nYes, I know. That's why I added the comment \"Keep order of\
    \ elements left the same as in the input.\"\n<|/ c |>\n<| c |>\n`uniq!` preserves\
    \ the order of the elements. `uniq` does not.\n<|/ c |>\n<| c |>\n`uniq!` preserves\
    \ the order of the elements. `uniq` does not.\n<|/ c |>\n<| c |>\n`uniq!` preserves\
    \ the order of the elements. `uniq` does not.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    a = [1, 2, 3, 3, 4, 4, 5]\na.uniq!\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    This doesn't preserve the order of the elements.\n<|/ c |>\n<| c |>\nIt preserves\
    \ the order of the elements. `uniq` does not.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ preserve the order of the elements.\n<|/ c |>\n<| c |>\nIt preserves the order\
    \ of the elements. `uniq` does not.\n<|/ c |>\n<| c |>\nThis doesn't preserve\
    \ the order of the elements.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\na =\
    \ [1, 2, 3, 3, 4, 4, 5]\na.uniq!\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't\
    \ preserve the order of the elements.\n<|/ c |>\n<| c |>\nIt preserves the order\
    \ of the elements. `uniq` does not.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\n\
    a = [1, 2, 3, 3, 4, 4, 5]\na.uniq!\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ doesn't preserve the order of the elements.\n<|/ c |>\n<| c |>\nIt preserves\
    \ the order of the elements. `uniq` does not.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    a = [1, 2, 3, 3, 4, 4, 5]\na.uniq!\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    This doesn't preserve the order of the elements.\n<|/ c |>\n<| c |>\nIt preserves\
    \ the order of the elements. `uniq` does not.\n<|/ c |>\n<|", "  numbers.uniq.sort!\n\
    \  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq!` modifies the\
    \ array in-place, so it won't work if you call it on a copy of the array.\n<|/\
    \ c |>\n<| c |>\n`uniq!` modifies the array in-place, so it won't work if you\
    \ call it on a copy of the array.\n<|/ c |>\n<| c |>\n`uniq!` modifies the array\
    \ in-place, so it won't work if you call it on a copy of the array.\n<|/ c |>\n\
    <| c |>\n`uniq!` modifies the array in-place, so it won't work if you call it\
    \ on a copy of the array.\n<|/ c |>\n<| c |>\n`uniq!` modifies the array in-place,\
    \ so it won't work if you call it on a copy of the array.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\n`uniq` will remove all duplicates, not just consecutive duplicates.\n\
    <|/ c |>\n<| c |>\nI know, but I thought the OP wanted to remove consecutive duplicates.\
    \ I guess I misunderstood.\n<|/ c |>\n<| c |>\nI guess I misunderstood too. My\
    \ point was that `uniq` will remove all duplicates, not just consecutive duplicates.\n\
    <|/ c |>\n<| c |>\nI guess I misunderstood too. My point was that `uniq` will\
    \ remove all duplicates, not just consecutive duplicates.\n<|/ c |>\n<| c |>\n\
    I guess I misunderstood too. My point was that `uniq` will remove all duplicates,\
    \ not just consecutive duplicates.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>",
  "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted\
    \ answer. `uniq!` was added in Ruby 2.4.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `uniq!` was added in Ruby 2.4.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. `uniq!` was added in Ruby 2.4.\n<|/ c |>\n<| c |>\n\
    This should be the accepted answer. `uniq!` was added in Ruby 2.4.\n<|/ c |>\n\
    <| c |>\nThis should be the accepted answer. `uniq!` was added in Ruby 2.4.\n\
    <|/ c |>\n<| a dscore=5 |>\nRuby 2.4 introduced uniq!:\n<code>\n[1,2,2,3,4].uniq!",
  "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis should be the accepted answer. `uniq` removes duplicates and\
    \ `sort!` sorts the array in-place.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. `uniq` removes duplicates and `sort!` sorts the array in-place.\n<|/\
    \ c |>\n<| c |>\nThis should be the accepted answer. `uniq` removes duplicates\
    \ and `sort!` sorts the array in-place.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `uniq` removes duplicates and `sort!` sorts the array in-place.\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. `uniq` removes duplicates\
    \ and `sort!` sorts the array in-place.\n<|/ c |>\n<| a |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer.\
    \ Much more elegant and efficient than iterating through each element and removing\
    \ duplicates.\n<|/ c |>\n<| c |>\nThis should be the accepted answer. Much more\
    \ elegant and efficient than iterating through each element and removing duplicates.\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. Much more elegant and efficient\
    \ than iterating through each element and removing duplicates.\n<|/ c |>\n<| c\
    \ |>\nThis should be the accepted answer. Much more elegant and efficient than\
    \ iterating through each element and removing duplicates.\n<|/ c |>\n<| c |>\n\
    This should be the accepted answer. Much more elegant and efficient than iterating\
    \ through each element and removing duplicates.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,arrays,ruby-on-rails-3\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| a dscore=1 |>\n<code>", "  numbers.uniq!\n  numbers\nend\n</code>\n<|/\
    \ a tags=ruby,ruby-on-rails |>\n<| c |>\nThanks so much for the help!\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis doesn't work if you have an array of hashes.\
    \ I used `to_a` on the array before calling `uniq` on it: `numbers.to_a.uniq.sort!`\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have an array of hashes. I used `to_a`\
    \ on the array before calling `uniq` on it: `numbers.to_a.uniq.sort!`\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have an array of hashes. I used `to_a` on the\
    \ array before calling `uniq` on it: `numbers.to_a.uniq.sort!`\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if you have an array of hashes. I used `to_a` on the array\
    \ before calling `uniq` on it: `numbers.to_a.uniq.sort!`\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have an array of hashes. I used `to_a` on the array before\
    \ calling `uniq` on it: `numbers.to_a.uniq.sort!`\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\nThis doesn't work if you have a hash with duplicate keys. `[1,2,2,3].uniq`\
    \ returns `[1,2,3]`\n<|/ c |>\n<| c |>\nThis doesn't work if you have a hash with\
    \ duplicate keys. `[1,2,2,3].uniq` returns `[1,2,3]`\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work if you have a hash with duplicate keys. `[1,2,2,3].uniq` returns\
    \ `[1,2,3]`\n<|/ c |>\n<| c |>\nThis doesn't work if you have a hash with duplicate\
    \ keys. `[1,2,2,3].uniq` returns `[1,2,3]`\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if you have a hash with duplicate keys. `[1,2,2,3].uniq` returns `[1,2,3]`\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>\n[1,2,2,3].uniq\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work if you have a hash with duplicate keys. `[1,2,2,3].uniq`\
    \ returns `[1,2,3]`\n<|/ c |>\n<| c |>\nThis doesn't work if you have a hash with\
    \ duplicate keys. `[1,2,2,3].uniq` returns `[1,2,3]`\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work if you have a hash with duplicate keys. `[1,2,2,3].uniq` returns\
    \ `[1,2,3]`\n<|/ c |>\n<| c |>\nThis doesn't work if you have a hash with duplicate\
    \ keys. `[1,2,2,3].uniq` returns `[1,2,3]`\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if you have a hash with duplicate keys. `[1,2,2,3].uniq` returns `[1,2,3]`\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>\n[1,2,2,3].uniq\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis doesn't work if you have a hash with duplicate keys. `[1,2,2,3].uniq`\
    \ returns `[1,2,3]`\n<|/ c |>\n<| c |>\nThis doesn't work if you have a hash with\
    \ duplicate keys. `[1,2,2,3].uniq` returns `[1,2,3]`\n<|/ c |>\n<| c |>\nThis ",
  "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=2\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like\
    \ this solution. Although I do think it would be better to have `numbers` be an\
    \ `Array` rather than an `Array` of `Array`s.\n<|/ c |>\n<| c |>\nI agree, `numbers`\
    \ should be an `Array` rather than an `Array` of `Array`s.\n<|/ c |>\n<| c |>\n\
    This solution is very elegant, but it's also very slow. On a large array (say\
    \ 10000 elements) it takes about a minute to complete. On a small array (say 100\
    \ elements) it takes about a second.\n<|/ c |>\n<| c |>\nI agree with you, it's\
    \ very slow for large arrays. I wonder if there's a faster way to do this in Ruby.\n\
    <|/ c |>\n<| c |>\nI agree with you, it's very slow for large arrays. I wonder\
    \ if there's a faster way to do this in Ruby.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  numbers.uniq.sort\nend", "  numbers.uniq!\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| a dscore=0 |>\n<code>", "  numbers.uniq!\nend", " \
    \ numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=0\
    \ |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\n`uniq!` doesn't remove duplicates, it just removes duplicates from\
    \ an array. `uniq` removes duplicates from an array.\n<|/ c |>\n<| c |>\n`uniq!`\
    \ removes duplicates from an array. `uniq` removes duplicates from an array.\n\
    <|/ c |>\n<| c |>\n`uniq!` removes duplicates from an array. `uniq` removes duplicates\
    \ from an array.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates from an array.\
    \ `uniq` removes duplicates from an array.\n<|/ c |>\n<| c |>\n`uniq!` removes\
    \ duplicates from an array. `uniq` removes duplicates from an array.\n<|/ c |>\n\
    <| a tags=ruby,arrays |>\n<code>", "  numbers.uniq.sort\nend", "  numbers.uniq!\n\
    end", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe `uniq!`\
    \ method was added in Ruby 2.3. See [this answer](http://stackoverflow.com/a/4151644/128421)\
    \ for the equivalent in older versions.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\n`uniq!` modifies the original array. `uniq` returns a new array without\
    \ modifying the original.\n<|/ c |>\n<| c |>\n: Yes, I know. I was just pointing\
    \ out that `uniq!` modifies the original array. `uniq` returns a new array without\
    \ modifying the original.\n<|/ c |>\n<| c |>\n`uniq!` modifies the original array.\
    \ `uniq` returns a new array without modifying the original.\n<|/ c |>\n<| c |>\n\
    : Yes, I know. I was just pointing out that `uniq!` modifies the original array.\
    \ `uniq` returns a new array without modifying the original.\n<|/ c |>\n<| c |>\n\
    `uniq!` modifies the original array. `uniq` returns a new array without modifying\
    \ the original.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a dscore=5 tags=ruby,arrays |>\n<| c |>\n`uniq!` doesn't remove\
    \ duplicates. It just removes duplicates from the array while preserving the original\
    \ order. `uniq` removes duplicates from the array while preserving the original\
    \ order.\n<|/ c |>\n<| c |>\n`uniq!` does remove duplicates, as does `uniq`. `uniq`\
    \ does remove duplicates, but it also preserves the original order.\n<|/ c |>\n\
    <| c |>\n`uniq!` removes duplicates from the array while preserving the original\
    \ order. `uniq` removes duplicates from the array while preserving the original\
    \ order.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates from the array while preserving\
    \ the original order. `uniq` removes duplicates from the array while preserving\
    \ the original order.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates from the\
    \ array while preserving the original order. `uniq` removes duplicates from the\
    \ array while preserving the original order.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    a = [1, 2, 3, 4, 4, 5]\na.uniq", "  numbers.uniq!\n  numbers\nend", "  numbers.uniq!\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=1 |>\n<code>", "  numbers.uniq.sort!\n\
    \  numbers.uniq!\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\n`uniq` doesn't preserve\
    \ the order of the elements. `uniq!` does.\n<|/ c |>\n<| c |>\n`uniq!` preserves\
    \ the order of the elements. `uniq` does not.\n<|/ c |>\n<| c |>\n`uniq!` preserves\
    \ the order of the elements. `uniq` does not.\n<|/ c |>\n<| c |>\n`uniq!` preserves\
    \ the order of the elements. `uniq` does not.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\n`uniq!` modifies the original array, so you don't need to assign it back\
    \ to `numbers` afterwards.\n<|/ c |>\n<| c |>\n`uniq!` modifies the original array,\
    \ so you don't need to assign it back to `numbers` afterwards.\n<|/ c |>\n<| c\
    \ |>\n`uniq!` modifies the original array, so you don't need to assign it back\
    \ to `numbers` afterwards.\n<|/ c |>\n<| c |>\n`uniq!` modifies the original array,\
    \ so you don't need to assign it back to `numbers` afterwards.\n<|/ c |>\n<| c\
    \ |>\n`uniq!` modifies the original array, so you don't need to assign it back\
    \ to `numbers` afterwards.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq.sort!\n\
    \  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=0\
    \ |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't preserve the order of the elements.\n<|/ c |>\n<|\
    \ c |>\nYes, it does preserve the order of the elements. `uniq` removes duplicates\
    \ and `sort!` sorts the array in place.\n<|/ c |>\n<| c |>\nThe OP wants to preserve\
    \ the order of the elements. `uniq` removes duplicates and `sort!` sorts the array\
    \ in place.\n<|/ c |>\n<| c |>\nYes, I missed that part. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| c |>\n`uniq` doesn't preserve the order of the elements.\
    \ `uniq!` does.\n<|/ c |>\n<| a dscore=5 |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\n\
    a.group_by{|x| x}.map{|k,v| v.first}\n</code>\n<|/ a tags=ruby,arrays |>\n<| c\
    \ |>\nThis doesn't preserve the order of the elements.\n<|/ c |>\n<| c |>\n`group_by`\
    \ preserves the order of the elements.\n<|/ c |>\n<| c |>\n`group_by` preserves\
    \ the order of the elements. `map` does not.\n<|/ c |>\n<| c |>\n`group_by` preserves\
    \ the order of the elements. `map` does not.\n<|/ c |>\n<| c |>\n`group_by` preserves\
    \ the order of the elements. `map` does not.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\na.group_by{|x|\
    \ x}.map{|k,v| v.first}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't preserve\
    \ the order of the elements.\n<|/ c |>\n<| c |>\n`group_by` preserves the order\
    \ of the elements.\n<|/ c |>\n<| c |>\n`group_by` preserves the order of the elements.\
    \ `map` does not.\n<|/ c |>\n<| c |>\n`group_by` preserves the order of the elements.\
    \ `map` does not.\n<|/ c |>\n<| a dscore=5 |>\n<code>\na = [1,2,", "  numbers.uniq!\n\
    end\n</code>\n<|/ a |>\n<| c |>\n`uniq!` doesn't remove duplicates, it just removes\
    \ duplicates from an array. `uniq` removes duplicates from an array.\n<|/ c |>\n\
    <| c |>\nThanks for pointing that out. I've updated the answer.\n<|/ c |>\n<|\
    \ a tags=ruby |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThanks for your answer. I'm getting an error when trying to run\
    \ this code. `undefined method `uniq!' for #<Array:0x0000000534dac8>`\n<|/ c |>\n\
    <| c |>\nMy bad, forgot that `uniq!` was a method on `Array`.  I've updated my\
    \ answer.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm getting an error when\
    \ trying to run this code. `undefined method `uniq!' for #<Array:0x0000000534dac8>`\n\
    <|/ c |>\n<| c |>\nSorry, I forgot that `uniq!` was a method on `Array`.  I've\
    \ updated my answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  numbers.uniq.sort!\n\
    \  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution,\
    \ but I wonder why `uniq` doesn't have a `sort!` method. Seems like it would be\
    \ a useful thing to have.\n<|/ c |>\n<| c |>\n`uniq` does have a `sort!` method,\
    \ but `uniq!` does not. `uniq!` modifies the array in place, so it modifies the\
    \ array in place. `uniq` returns a new array without modifying the original array.\n\
    <|/ c |>\n<| c |>\n`uniq!` modifies the array in place, so it modifies the array\
    \ in place. `uniq` returns a new array without modifying the original array.\n\
    <|/ c |>\n<| c |>\n`uniq!` modifies the array in place, so it modifies the array\
    \ in place. `uniq` returns a new array without modifying the original array.\n\
    <|/ c |>\n<| c |>\n`uniq!` modifies the array in place, so it modifies the array\
    \ in place. `uniq` returns a new array without modifying the original array.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThe OP wants to remove duplicates, not just sort them.\n<|/ c |>\n\
    <| c |>\nI agree, my answer was posted before the OP clarified that he wanted\
    \ to remove duplicates.\n<|/ c |>\n<| c |>\nI agree, my answer was posted before\
    \ the OP clarified that he wanted to remove duplicates.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a dscore=0 |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI believe that `uniq!` will mutate the original array. `uniq` will\
    \ return a copy of the original array without duplicates.\n<|/ c |>\n<| c |>\n\
    Yes, `uniq!` will mutate the original array. `uniq` will return a copy of the\
    \ original array without duplicates.\n<|/ c |>\n<| c |>\n`uniq!` will mutate the\
    \ original array. `uniq` will return a copy of the original array without duplicates.\n\
    <|/ c |>\n<| c |>\n`uniq!` will mutate the original array. `uniq` will return\
    \ a copy of the original array without duplicates.\n<|/ c |>\n<| c |>\n`uniq!`\
    \ will mutate the original array. `uniq` will return a copy of the original array\
    \ without duplicates.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", " \
    \ numbers.uniq.sort\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>",
  "  numbers.uniq!\nend", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby |>\n<| c\
    \ |>\n`uniq!` modifies the original array. `uniq` returns a new array without\
    \ duplicates.\n<|/ c |>\n<| c |>\nThanks, I fixed the answer.\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>", "  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI believe this should be the accepted answer. `uniq!` removes duplicates,\
    \ while `uniq` only removes duplicates in the current array and returns the remaining\
    \ elements. `uniq!` also modifies the original array and `uniq` does not.\n<|/\
    \ c |>\n<| c |>\n`uniq!` modifies the original array and `uniq` does not.\n<|/\
    \ c |>\n<| c |>\n`uniq!` modifies the original array and `uniq` does not.\n<|/\
    \ c |>\n<| c |>\n`uniq!` modifies the original array and `uniq` does not.\n<|/\
    \ c |>\n<| c |>\n`uniq!` modifies the original array and `uniq` does not.\n<|/\
    \ c |>\n<| a |>\nThe most efficient way is to use Enumerable#uniq:\n<code>\n[1,\
    \ 1, 2, 3].uniq", "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n<|/ a\
    \ tags=ruby,arrays |>\n<| c |>\n`uniq` will remove duplicates, but not preserve\
    \ order. `uniq!` will preserve order, but remove duplicates.\n<|/ c |>\n<| c |>\n\
    `uniq!` preserves order, but removes duplicates. `uniq` removes duplicates, but\
    \ does not preserve order.\n<|/ c |>\n<| c |>\n`uniq!` preserves order, but removes\
    \ duplicates. `uniq` removes duplicates, but does not preserve order.\n<|/ c |>\n\
    <| c |>\n`uniq!` preserves order, but removes duplicates. `uniq` removes duplicates,\
    \ but does not preserve order.\n<|/ c |>\n<| c |>\n`uniq!` preserves order, but\
    \ removes duplicates. `uniq` removes duplicates, but does not preserve order.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n  numbers\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\n`uniq!` modifies the original array. `uniq`\
    \ returns a new array without modifying the original array.\n<|/ c |>\n<| c |>\n\
    Yes, I know. That's why I said \"From a list of integers, remove all elements\
    \ that occur more than once.\" The OP didn't specify whether he wanted to modify\
    \ the original array or not.\n<|/ c |>\n<| c |>\nI guess I misunderstood your\
    \ comment. `uniq!` modifies the original array and `uniq` returns a new array\
    \ without modifying the original array.\n<|/ c |>\n<| c |>\nYes, that's what I\
    \ meant.\n<|/ c |>\n<| c |>\n`uniq` returns a new array without modifying the\
    \ original array. `uniq!` modifies the original array.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<| c |>\nThis doesn't work if you have an array of hashes.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work if you have an array of hashes.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have an array of hashes.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have an array of hashes.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ you have an array of hashes.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\na.uniq.sort\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work if you have an array of\
    \ hashes.\n<|/ c |>\n<| c |>\nThis doesn't work if you have an array of hashes.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have an array of hashes.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have an array of hashes.\n<|/ c |>\n<| c |>\n\
    This doesn't work if you have an array of hashes.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\na.uniq\n</code>\n\
    <|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\nThis doesn't work if you have\
    \ an array of hashes.\n<|/ c |>\n<| c |>\nThis doesn't work if you have an array\
    \ of hashes.\n<|/ c |>\n<| c |>\nThis doesn't work if you have an array of hashes.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have an array of hashes.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have an array of hashes.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]\na.uniq\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work if you have an array of\
    \ hashes.\n<|/ c |>\n<| c |>\nThis doesn't work if you have an array of hashes.\n\
    <|/ c |>\n", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like\
    \ this solution the best. Easy to read and understand.\n<|/ c |>\n<| c |>\nI like\
    \ this solution the best. Easy to read and understand.\n<|/ c |>\n<| c |>\nI like\
    \ this solution the best. Easy to read and understand.\n<|/ c |>\n<| c |>\nI like\
    \ this solution the best. Easy to read and understand.\n<|/ c |>\n<| c |>\nI like\
    \ this solution the best. Easy to read and understand.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3,ruby-on-rails-3.2\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like\
    \ this solution, because it doesn't require any additional gems. However, it does\
    \ require Ruby 1.8.7 or greater.\n<|/ c |>\n<| c |>\nI like it, but I wonder why\
    \ you used `uniq!` instead of `uniq`?\n<|/ c |>\n<| c |>\n`uniq!` modifies the\
    \ array in place. `uniq` returns a new array.\n<|/ c |>\n<| c |>\nI like it, but\
    \ I wonder why you used `uniq!` instead of `uniq`?\n<|/ c |>\n<| c |>\nI like\
    \ it, but I wonder why you used `uniq!` instead of `uniq`?\n<|/ c |>\n<| a |>\n\
    <code>", "  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  numbers.uniq!\nend", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  numbers.uniq!\nend", "  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq!` doesn't remove duplicates,\
    \ it just removes duplicates in place and returns `nil` if the array is empty.\n\
    <|/ c |>\n<| c |>\n`uniq!` removes duplicates in place and returns `nil` if the\
    \ array is empty. `uniq` removes duplicates and returns an array with the duplicates\
    \ removed. `uniq!` removes duplicates in place and returns `nil` if the array\
    \ is empty.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates in place and returns\
    \ `nil` if the array is empty. `uniq` removes duplicates and returns an array\
    \ with the duplicates removed. `uniq!` removes duplicates in place and returns\
    \ `nil` if the array is empty.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates\
    \ in place and returns `nil` if the array is empty. `uniq` removes duplicates\
    \ and returns an array with the duplicates removed. `uniq!` removes duplicates\
    \ in place and returns `nil` if the array is empty.\n<|/ c |>\n<| c |>\n`uniq!`\
    \ removes duplicates in place and returns `nil` if the array is empty. `uniq`\
    \ removes duplicates and returns an array with the duplicates removed. `uniq!`\
    \ removes duplicates in place and returns `nil` if the array is empty.\n<|/ c\
    \ |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nI like your solution, but I believe it would be more efficient to just\
    \ use `uniq!` on the array rather than creating a new array and removing duplicates.\n\
    <|/ c |>\n<| c |>\nI agree with you, just wanted to show an alternative to OP's\
    \ code :)\n<|/ c |>\n<| c |>\nI agree, `uniq!` would be more efficient.\n<|/ c\
    \ |>\n<| c |>\nI like your solution, but I believe it would be more efficient\
    \ to just use `uniq!` on the array rather than creating a new array and removing\
    \ duplicates.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`uniq!` mutates\
    \ the array, so you don't need to return it\n<|/ c |>\n<| c |>\n: Yes, I know.\
    \ That's why I wrote \"From a list of integers, remove all elements that occur\
    \ more than once.\" The OP didn't say anything about keeping the order of the\
    \ elements.\n<|/ c |>\n<| c |>\nI guess I missed that part of the question\n<|/\
    \ c |>\n<| c |>\n: Yes, I know. That's why I wrote \"From a list of integers,\
    \ remove all elements that occur more than once.\" The OP didn't say anything\
    \ about keeping the order of the elements.\n<|/ c |>\n<| a tags=ruby,arrays |>\n\
    <code>", "  numbers.uniq.sort!\n  numbers.delete_if { |x| numbers.count(x) > 1\
    \ }\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't preserve the\
    \ original order of the elements. `[1, 2, 3, 1].uniq` returns `[1, 2]`.\n<|/ c\
    \ |>\n<| c |>\nYes, it does. `[1, 2, 3, 1].uniq` returns `[1, 2]`. `[1, 2, 3,\
    \ 1].uniq.sort` returns `[1, 2, 3]`.\n<|/ c |>\n<| c |>\nI guess I misunderstood\
    \ your comment. You're saying that the original order is preserved but the order\
    \ of the elements is not preserved? That doesn't make any sense. `[1, 2, 3, 1].uniq`\
    \ returns `[1, 2]` because `1` and `2` are both unique and `1` comes before `2`\
    \ in the original order. `[1, 2, 3, 1].uniq.sort` returns `[1, 2, 3]` because\
    \ `1` comes before `2` but `3` comes after `2` in the original order.\n<|/ c |>\n\
    <| c |>\nYes, you're right. I was thinking of `[1, 2, 3, 1].uniq` returning `[1,\
    \ 2]` because `1` and `2` are both unique and `1` comes before `2` in the original\
    \ order. `[1, 2, 3, 1].uniq.sort` returning `[1, 2, 3]` because `1` comes before\
    \ `2` but `3` comes after `2` in the original order. My mistake.\n<|/ c |>\n<|\
    \ a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3\
    \ |>\n<| c |>\nThanks for your answer. I'm getting an error when trying to run\
    \ your code. `undefined method `uniq!' for #<Array:0x000000051c7d28>`\n<|/ c |>\n\
    <| c |>\nAh, sorry, I missed the fact that `uniq!` was a method on `Array`, not\
    \ `Enumerable`. I've updated my answer to reflect that.\n<|/ c |>\n<| c |>\nThanks\
    \ again! I ended up using your first solution. I'm still curious as to why my\
    \ code didn't work. I'm still new to Ruby, so I appreciate your help.\n<|/ c |>\n\
    <| c |>\nI suspect that `uniq!` was introduced in Ruby 1.9.2, and you're using\
    \ 1.9.1. `uniq` returns a new array without duplicates, and `uniq!` modifies the\
    \ original array in place. `uniq` was introduced in Ruby 1.8.7 and `uniq!` was\
    \ introduced in Ruby 1.9.2.\n<|/ c |>\n<| c |>\nAh! I see. Thanks for your help.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<code>", "  numbers.uniq.sort!\n\
    \  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq` will remove\
    \ all duplicates, not just consecutive duplicates.\n<|/ c |>\n<| c |>\n`uniq`\
    \ will remove all duplicates, not just consecutive duplicates.\n<|/ c |>\n<| c\
    \ |>\n`uniq` will remove all duplicates, not just consecutive duplicates.\n<|/\
    \ c |>\n<| c |>\n`uniq` will remove all duplicates, not just consecutive duplicates.\n\
    <|/ c |>\n<| c |>\n`uniq` will remove all duplicates, not just consecutive duplicates.\n\
    <|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`uniq` removes duplicates,\
    \ but it also removes elements from the original array. `uniq!` modifies the original\
    \ array in place.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I was trying\
    \ to be consistent with the OP's original code, but you're right. I'll update\
    \ my answer.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<| c |>\nThis\
    \ doesn't work if you have an array of hashes, for example, `[{:a => 1, :b =>\
    \ 2}, {:a => 1, :b => 3}, {:a => 2, :b => 4}]`\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have an array of hashes, for example, `[{:a => 1, :b => 2}, {:a\
    \ => 1, :b => 3}, {:a => 2, :b => 4}]`\n<|/ c |>\n<| a dscore=4 |>\n<code>", " \
    \ numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI love this solution.\
    \ Works perfectly for me. Thanks!\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. Much more elegant than my solution. Thanks!\n<|/ c |>\n<| c |>\nThis\
    \ should be the accepted answer. Much more elegant than my solution. Thanks!\n\
    <|/ c |>\n<| c |>\nI love this solution. Works perfectly for me. Thanks!\n<|/\
    \ c |>\n<| c |>\nThis should be the accepted answer. Much more elegant than my\
    \ solution. Thanks!\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails |>\n<code>\n\
    a = [1,2,3,4,5,6,7,8,9,10]\na.uniq!\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ doesn't answer the question, which is about removing duplicates, not sorting\
    \ them.\n<|/ c |>\n<| c |>\nThis doesn't answer the question, which is about removing\
    \ duplicates, not sorting them.\n<|/ c |>\n<| c |>\nThis doesn't answer the question,\
    \ which is about removing duplicates, not sorting them.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't answer the question, which is about removing duplicates, not sorting\
    \ them.\n<|/ c |>\n<| c |>\nThis doesn't answer the question, which is about removing\
    \ duplicates, not sorting them.\n<|/ c |>\n<| a tags=ruby,arrays,ruby-on-rails\
    \ |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10]\na.uniq!\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\nThis doesn't answer the question, which is about removing duplicates,\
    \ not sorting them.\n<|/ c |>\n<| c |>\nThis doesn't answer the question, which\
    \ is about removing duplicates, not sorting them.\n<|/ c |>\n<| a |>\n<code>\n\
    a = [1,2,3,4,5,6,7,8,9,10]\na.uniq!\n</code>\n<|/ a dscore=5 tags=ruby,arrays,ruby-on-rails\
    \ |>\n<| c |>\nThis doesn't answer the question, which is about removing duplicates,\
    \ not sorting them.\n<|/ c |>\n<| c |>\nThis doesn't answer the question, which\
    \ is about removing duplicates, not sorting them.\n<|/ c |>\n<| ", "  numbers.uniq!\n\
    \  numbers\nend", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI believe this doesn't work if you have a hash with duplicate keys.\
    \ `h = { :a => 1, :b => 1, :c => 2 }` will result in `h[:a] == h[:b]` being true.\n\
    <|/ c |>\n<| c |>\nYes, it does. I tested it before posting my answer. `h = {\
    \ :a => 1, :b => 1, :c => 2 }` results in `h[:a] == h[:b]` being true.\n<|/ c\
    \ |>\n<| c |>\nI tested it again and you're right. I was thinking of hashes with\
    \ duplicate keys. I guess I should delete my comment.\n<|/ c |>\n<| c |>\nI deleted\
    \ my comment because I realized that my comment was wrong. Sorry about that. :)\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq.sort\nend", "  numbers.uniq!\n\
    \  numbers\nend", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n\
    <| c |>\nI like this solution, but I wonder if there is a way to do this without\
    \ having to use uniq!\n<|/ c |>\n<| c |>\n: I added a solution that doesn't use\
    \ uniq!\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  numbers.uniq.sort!\n  numbers.uniq!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer.\
    \ `uniq` removes duplicates and `sort!` sorts the array in place.\n<|/ c |>\n\
    <| c |>\n`uniq` removes duplicates and `sort!` sorts the array in place. `uniq!`\
    \ sorts the array in place and removes duplicates.\n<|/ c |>\n<| c |>\n`uniq`\
    \ removes duplicates and `sort!` sorts the array in place. `uniq!` sorts the array\
    \ in place and removes duplicates.\n<|/ c |>\n<| c |>\n`uniq` removes duplicates\
    \ and `sort!` sorts the array in place. `uniq!` sorts the array in place and removes\
    \ duplicates.\n<|/ c |>\n<| c |>\n`uniq` removes duplicates and `sort!` sorts\
    \ the array in place. `uniq!` sorts the array in place and removes duplicates.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution, but I believe\
    \ it only works in Rails 3+. I'm looking for a solution that works in Rails 2.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if you have an array of hashes, because hashes\
    \ aren't ordered.\n<|/ c |>\n<| c |>\nThis doesn't work if you have an array of\
    \ hashes, because hashes aren't ordered.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if you have an array of hashes, because hashes aren't ordered.\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work if you have an array of hashes, because hashes aren't\
    \ ordered.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  numbers.uniq.sort!\n\
    \  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq!`\
    \ modifies the array in place, so it won't work if you call it after `sort!`.\n\
    <|/ c |>\n<| c |>\n: Good point. I've updated the answer to include a solution\
    \ that doesn't modify the array in place.\n<|/ c |>\n<| c |>\n`uniq!` modifies\
    \ the array in place, so it won't work if you call it after `sort!`.\n<|/ c |>\n\
    <| c |>\n`uniq!` modifies the array in place, so it won't work if you call it\
    \ after `sort!`.\n<|/ c |>\n<| c |>\n`uniq!` modifies the array in place, so it\
    \ won't work if you call it after `sort!`.\n<|/ c |>\n<| a dscore=5 |>\n<code>",
  "  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a dscore=5 tags=ruby,arrays |>\n\
    <| c |>\nThis should be the accepted answer. `uniq!` does exactly what it says\
    \ on the tin.\n<|/ c |>\n<| c |>\n`uniq!` doesn't remove duplicates, it just removes\
    \ duplicates in place. `uniq` does remove duplicates.\n<|/ c |>\n<| c |>\nThis\
    \ should be the accepted answer. `uniq!` does exactly what it says on the tin.\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. `uniq!` does exactly what\
    \ it says on the tin.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ `uniq!` does exactly what it says on the tin.\n<|/ c |>\n<| a dscore=5 |>\n\
    <code>\na = [1,2,3,4,5,6,7,8,9,10]\na.delete_if { |x| a.count(x) > 1 }\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis should be the accepted answer. `delete_if`\
    \ does exactly what it says on the tin.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `delete_if` does exactly what it says on the tin.\n<|/ c |>\n\
    <| c |>\nThis should be the accepted answer. `delete_if` does exactly what it\
    \ says on the tin.\n<|/ c |>\n<| c |>\nThis should be the accepted answer. `delete_if`\
    \ does exactly what it says on the tin.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `delete_if` does exactly what it says on the tin.\n<|/ c |>\n\
    <| a tags=ruby,arrays |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10]\na.select { |x| a.count(x)\
    \ == 1 }\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer.\
    \ `select` does exactly what it says on the tin.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. `select` does exactly what it says on the tin.\n<|/\
    \ c |>\n<| c |>\nThis should be the accepted answer. `select` does exactly what\
    \ it says on the tin.\n<|/ c |>\n<| c |>\n", "  numbers.uniq!\n  numbers\nend\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq!` does not remove duplicates, it only\
    \ removes duplicates in place (and returns `nil` if no changes were made).\n<|/\
    \ c |>\n<| c |>\n`uniq!` does remove duplicates, it just doesn't return `nil`\
    \ if no changes were made. `uniq` does return `nil` if no changes were made. `uniq!`\
    \ returns `nil` if no changes were made. `uniq` returns `nil` if no changes were\
    \ made.\n<|/ c |>\n<| c |>\n`uniq!` returns `nil` if no changes were made. `uniq`\
    \ returns `nil` if no changes were made. `uniq!` returns `nil` if no changes were\
    \ made. `uniq` returns `nil` if no changes were made. `uniq!` returns `nil` if\
    \ no changes were made. `uniq` returns `nil` if no changes were made. `uniq!`\
    \ returns `nil` if no changes were made. `uniq` returns `nil` if no changes were\
    \ made. `uniq!` returns `nil` if no changes were made. `uniq` returns `nil` if\
    \ no changes were made. `uniq!` returns `nil` if no changes were made. `uniq`\
    \ returns `nil` if no changes were made. `uniq!` returns `nil` if no changes were\
    \ made. `uniq` returns `nil` if no changes were made. `uniq!` returns `nil` if\
    \ no changes were made. `uniq` returns `nil` if no changes were made. `uniq!`\
    \ returns `nil` if no changes were made. `uniq` returns `nil` if no changes were\
    \ made. `uniq!` returns `nil` if no changes were made. `uniq` returns `nil` if\
    \ no changes were made. `uniq!` returns `nil` if no changes were made. `uniq`\
    \ returns `nil` if no changes were made. `uniq!` returns `nil` if no changes were\
    \ made. `uniq` returns `nil` if no changes were made. `uniq!` returns `nil` if\
    \ no changes were made. `uniq` returns `nil` if no changes were made. `uniq!`\
    \ returns `nil` if no changes were made. `uniq` returns `nil` if no changes were\
    \ made. `uniq!` returns `nil` if no changes were made. `uniq` returns `nil` if\
    \ no changes were made. `uniq!` returns `nil", "  numbers.uniq!\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nI like this solution, but I believe it only works\
    \ in Rails 2.x. Rails 3 has `uniq` which does exactly what this does.\n<|/ c |>\n\
    <| c |>\nI believe this also works in Rails 3.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if you have a hash with duplicate keys. `uniq` will remove all but the\
    \ first occurrence.\n<|/ c |>\n<| c |>\nThis doesn't work if you have a hash with\
    \ duplicate keys. `uniq` will remove all but the first occurrence.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have a hash with duplicate keys. `uniq` will\
    \ remove all but the first occurrence.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n\
    <| a dscore=0 |>\n<code>", "  numbers.uniq.sort!\n  numbers.delete_if { |x| numbers.count(x)\
    \ > 1 }\nend\n</code>\n<|/ a tags=ruby,arrays,ruby-on-rails |>\n<| c |>\n`uniq`\
    \ doesn't preserve the order of elements. `uniq!` does.\n<|/ c |>\n<| c |>\nThanks,\
    \ I didn't know that. I've updated my answer.\n<|/ c |>\n<| a dscore=3 |>\n<code>",
  "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  numbers.uniq!\nend", "  numbers.uniq.sort!\n  numbers.uniq!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer.\
    \ `uniq!` removes duplicates, `uniq` does not. `uniq!` modifies the array in place,\
    \ and `uniq` returns a new array with the duplicates removed.\n<|/ c |>\n<| c\
    \ |>\nThis should be the accepted answer. `uniq!` removes duplicates, `uniq` does\
    \ not. `uniq!` modifies the array in place, and `uniq` returns a new array with\
    \ the duplicates removed.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ `uniq!` removes duplicates, `uniq` does not. `uniq!` modifies the array in place,\
    \ and `uniq` returns a new array with the duplicates removed.\n<|/ c |>\n<| c\
    \ |>\nThis should be the accepted answer. `uniq!` removes duplicates, `uniq` does\
    \ not. `uniq!` modifies the array in place, and `uniq` returns a new array with\
    \ the duplicates removed.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ `uniq!` removes duplicates, `uniq` does not. `uniq!` modifies the array in place,\
    \ and `uniq` returns a new array with the duplicates removed.\n<|/ c |>\n<| a\
    \ tags=ruby,arrays |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\n`uniq!` doesn't remove duplicates, it only removes duplicates\
    \ in the current array. `uniq` removes duplicates in the entire array.\n<|/ c\
    \ |>\n<| c |>\n`uniq!` removes duplicates in the current array. `uniq` removes\
    \ duplicates in the entire array.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates\
    \ in the current array. `uniq` removes duplicates in the entire array.\n<|/ c\
    \ |>\n<| c |>\n`uniq!` removes duplicates in the current array. `uniq` removes\
    \ duplicates in the entire array.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates\
    \ in the current array. `uniq` removes duplicates in the entire array.\n<|/ c\
    \ |>\n<| a tags=ruby,arrays |>\n<code>\na = [1,2,2,3,4,5,6,7,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,",
  "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`uniq!` doesn't remove\
    \ duplicates, it just removes duplicates in place and returns `nil`. So this doesn't\
    \ answer the question.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates in place\
    \ and returns `nil` if the array is empty. `uniq` returns an array without duplicates.\n\
    <|/ c |>\n<| c |>\n`uniq!` returns `nil` if the array is empty. `uniq` returns\
    \ an array without duplicates.\n<|/ c |>\n<| c |>\n`uniq!` returns `nil` if the\
    \ array is empty. `uniq` returns an array without duplicates.\n<|/ c |>\n<| c\
    \ |>\n`uniq!` returns `nil` if the array is empty. `uniq` returns an array without\
    \ duplicates.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  numbers.uniq.sort!\n \
    \ numbers.uniq!\n  numbers\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq` doesn't\
    \ remove duplicates, it just removes duplicates in the order they appear in the\
    \ array. `uniq!` removes duplicates.\n<|/ c |>\n<| c |>\n`uniq` removes duplicates\
    \ in the order they appear in the array. `uniq!` removes duplicates.\n<|/ c |>\n\
    <| c |>\n`uniq` removes duplicates in the order they appear in the array. `uniq!`\
    \ removes duplicates.\n<|/ c |>\n<| c |>\n`uniq` removes duplicates in the order\
    \ they appear in the array. `uniq!` removes duplicates.\n<|/ c |>\n<| c |>\n`uniq`\
    \ removes duplicates in the order they appear in the array. `uniq!` removes duplicates.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\nend\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis doesn't work for me in Rails 4.1.1 with Ruby\
    \ 2.1.1. `uniq!` returns `nil` and the array is unchanged.\n<|/ c |>\n<| c |>\n\
    I believe this only works in Rails 3.2+\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ for me in Rails 4.1.1 with Ruby 2.1.1. uniq! returns nil and the array is unchanged.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for me in Rails 4.1.1 with Ruby 2.1.1. uniq!\
    \ returns nil and the array is unchanged.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ for me in Rails 4.1.1 with Ruby 2.1.1. uniq! returns nil and the array is unchanged.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThe `uniq!` method was added in Ruby 2.4.\n<|/ c |>\n<| c |>\n\
    `uniq!` was added in Ruby 2.4.\n<|/ c |>\n<| c |>\n`uniq!` was added in Ruby 2.4.\n\
    <|/ c |>\n<| c |>\n`uniq!` was added in Ruby 2.4.\n<|/ c |>\n<| c |>\n`uniq!`\
    \ was added in Ruby 2.4.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI believe this should be the accepted\
    \ answer. `uniq!` removes duplicates, while `uniq` removes duplicates and returns\
    \ the original array. `uniq!` should be used when the order of the elements is\
    \ not important.\n<|/ c |>\n<| c |>\nI agree with you, but I believe that `uniq!`\
    \ should be used when the order of the elements is not important.\n<|/ c |>\n\
    <| c |>\nI agree, `uniq!` should be used when the order of the elements is not\
    \ important. `uniq` should be used when the order of the elements is not important.\n\
    <|/ c |>\n<| c |>\nI agree, `uniq!` should be used when the order of the elements\
    \ is not important. `uniq` should be used when the order of the elements is not\
    \ important.\n<|/ c |>\n<| c |>\n`uniq!` should be used when the order of the\
    \ elements is not important. `uniq` should be used when the order of the elements\
    \ is not important.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>\na = [1,2,3,4,5,6,7,8,9,10]\n\
    a.uniq!\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis does not provide an answer\
    \ to the question. To critique or request clarification from an author, leave\
    \ a comment below their post - you can always comment on your own posts, and once\
    \ you have sufficient [reputation](http://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](http://stackoverflow.com/help/privileges/comment).\n\
    <|/ c |>\n<| c |>\nThis does provide an answer to the question. `uniq!` removes\
    \ duplicates, while `uniq` removes duplicates and returns the original array.\
    \ `uniq!` should be used when the order of the elements is not important.\n<|/\
    \ c |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post -\
    \ you can always comment on your own posts, and once you have sufficient [reputation](http://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](http://stackoverflow.com/help/privileges/comment).\n\
    <|/ c |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post -\
    \ you can always comment on your own posts, and once you have sufficient [reput",
  "  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<|\
    \ c |>\nThis does not answer the question. OP wants to remove duplicates, not\
    \ uniquify them.\n<|/ c |>\n<| c |>\nThe OP wants to remove duplicates, not uniquify\
    \ them. `uniq!` does both.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates, not\
    \ uniquify them. `uniq` removes duplicates, uniquify them.\n<|/ c |>\n<| c |>\n\
    `uniq!` removes duplicates, not uniquify them. `uniq` removes duplicates, uniquify\
    \ them.\n<|/ c |>\n<| c |>\n`uniq!` removes duplicates, not uniquify them. `uniq`\
    \ removes duplicates, uniquify them.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n\
    <code>", "  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like your\
    \ answer but I think it would be better to have `remove_duplicates` return `numbers`\
    \ instead of `nil`.\n<|/ c |>\n<| c |>\nI agree, that would be better. I've edited\
    \ the answer to reflect that.\n<|/ c |>\n<| c |>\nI like your answer, but I think\
    \ it would be better to have `remove_duplicates` return `numbers` instead of `nil`.\n\
    <|/ c |>\n<| c |>\nI like your answer, but I think it would be better to have\
    \ `remove_duplicates` return `numbers` instead of `nil`.\n<|/ c |>\n<| c |>\n\
    I like your answer, but I think it would be better to have `remove_duplicates`\
    \ return `numbers` instead of `nil`.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>",
  "  numbers.uniq!\n  numbers\nend", "  numbers.uniq!\n  numbers\nend", "  numbers.uniq!\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\n`uniq!` modifies the original array.\
    \ `uniq` returns a new array without modifying the original.\n<|/ c |>\n<| c |>\n\
    Yes, I know, but I wanted to keep the same method signature as in the question.\
    \ `uniq!` modifies the original array, so I wanted to show that `uniq` returns\
    \ a new array without modifying the original.\n<|/ c |>\n<| c |>\nI agree with\
    \ you, but I wanted to point out that `uniq!` modifies the original array and\
    \ `uniq` returns a new array without modifying the original.\n<|/ c |>\n<| c |>\n\
    I agree with you, but I wanted to point out that `uniq!` modifies the original\
    \ array and `uniq` returns a new array without modifying the original.\n<|/ c\
    \ |>\n<| c |>\nI agree with you, but I wanted to point out that `uniq!` modifies\
    \ the original array and `uniq` returns a new array without modifying the original.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  numbers.uniq!\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| a |>\n<code>", "  numbers.uniq!\n  numbers\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nI like your use of uniq! but I think it would be better to do `numbers.uniq!(&:itself)`\
    \ since `uniq!` will mutate the original array and `uniq` will return a copy of\
    \ the array.\n<|/ c |>\n<| c |>\nI agree, that would be better. I was just trying\
    \ to keep it close to the OP's original code.\n<|/ c |>\n<| a dscore=4 |>\n<code>",
  "  numbers.uniq.sort!\n  numbers.uniq!\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    I like this solution, because it doesn't require any additional gems and is easy\
    \ to understand.\n<|/ c |>\n<| c |>\nI like this solution, because it doesn't\
    \ require any additional gems and is easy to understand.\n<|/ c |>\n<| c |>\n\
    I like this solution, because it doesn't require any additional gems and is easy\
    \ to understand.\n<|/ c |>\n<| c |>\nI like this solution, because it doesn't\
    \ require any additional gems and is easy to understand.\n<|/ c |>\n<| c |>\n\
    I like this solution, because it doesn't require any additional gems and is easy\
    \ to understand.\n<|/ c |>\n<| a tags=ruby,arrays,duplicates |>\n<code>", "  numbers.uniq!\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=1 |>\n<code>", " \
    \ numbers.uniq!\n  numbers\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\n`uniq!`\
    \ was introduced in Ruby 2.4.\n<|/ c |>\n<| c |>\n`uniq!` was introduced in Ruby\
    \ 2.4.\n<|/ c |>\n<| c |>\n`uniq!` was introduced in Ruby 2.4.\n<|/ c |>\n<| c\
    \ |>\n`uniq!` was introduced in Ruby 2.4.\n<|/ c |>\n<| c |>\n`uniq!` was introduced\
    \ in Ruby 2.4.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  numbers.uniq!\n\
    \  numbers\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays |>\n\
    <code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
