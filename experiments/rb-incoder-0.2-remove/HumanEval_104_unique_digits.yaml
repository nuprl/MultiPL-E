name: HumanEval_104_unique_digits
language: rb
prompt: "# Given a list of positive integers x. return a sorted list of all \n# elements\
  \ that hasn't any even digit.\n# Note: Returned list should be sorted in increasing\
  \ order.\n# For example:\ndef unique_digits(x)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique_digits\n\
  \    candidate = method(:unique_digits)\n    assert_equal([1, 15, 33], candidate.call([15,\
  \ 33, 1422, 1]))\n    assert_equal([], candidate.call([152, 323, 1422, 10]))\n \
  \   assert_equal([111, 151], candidate.call([12345, 2033, 111, 151]))\n    assert_equal([31,\
  \ 135], candidate.call([135, 103, 31]))\n  end\nend\n"
completions: ["  x.sort!\n  result = []\n  x.each do |i|\n    result << i unless i.to_s.chars.uniq.count\
    \ % 2 == 0\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n\
    <code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ != 1\n  end\n  result\nend\nunique_digits([1, 2, 3, 1])", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count == 1\n  end\n\
    \  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if\
    \ you have a number like \"1231\" because \"1\" is repeated twice.\n<|/ c |>\n\
    <| c |>\n: I didn't see that requirement in the question. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i unless\
    \ i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't answer the question. He wants to know if there are\
    \ any numbers that don't have an even digit.\n<|/ c |>\n<| c |>\nYes, I missed\
    \ that part. Updated my answer.\n<|/ c |>\n<| c |>\nThis doesn't answer the question.\
    \ He wants to know if there are any numbers that don't have an even digit.\n<|/\
    \ c |>\n<| c |>\nYes, I missed that part. Updated my answer.\n<|/ c |>\n<| a |>\n\
    <code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend\nunique_digits([1, 2, 3, 2])", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i unless i.to_s.chars.uniq.count % 2 ==\
    \ 0\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't\
    \ work if there are multiple occurrences of an even digit.\n<|/ c |>\n<| c |>\n\
    I believe that OP wants to return all elements that doesn't have any even digit.\n\
    <|/ c |>\n<| c |>\nYes, that's what I meant. Sorry for the confusion.\n<|/ c |>\n\
    <| c |>\nI added a solution that returns all elements that doesn't have any even\
    \ digit.\n<|/ c |>\n<| c |>\nI believe that OP wants to return all elements that\
    \ doesn't have any even digit.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count !=\
    \ i.to_s.chars.count\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt works. I tested\
    \ it with `[1,2,3]`. Please try it yourself.\n<|/ c |>\n<| c |>\nI tested it with\
    \ `[1,2,3]` and it returned `[2,3]` instead of `[2,3,1]`.\n<|/ c |>\n<| c |>\n\
    I tested it with `[1,2,3]` and it returned `[2,3,1]` instead of `[2,3,1]`. Please\
    \ try it yourself.\n<|/ c |>\n<| c |>\nI tested it with `[1,2,3]` and it returned\
    \ `[2,3,1]` instead of `[2,3,1]`. Please try it yourself.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.count != 0\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  x.sort!\n  result = []\n \
    \ x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size == 1\n\
    \  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThis\
    \ doesn't work. Try it with `[2,3,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\n\
    <|/ c |>\n<| c |>\nYes, I missed that case. Thanks for pointing out. Updated the\
    \ answer.\n<|/ c |>\n<| c |>\nThis doesn't work. Try it with `[2,3,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\n\
    <|/ c |>\n<| c |>\nYes, I missed that case. Thanks for pointing out. Updated the\
    \ answer.\n<|/ c |>\n<| c |>\nThis doesn't work. Try it with `[2,3,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`\n\
    <|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i unless i.to_s.chars.uniq.count % 2 == 0\n  end\n\
    \  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i unless i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend", "  x.sort.uniq \nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=ruby,ruby-on-rails |>\n<code>", "  x.sort.uniq\nend", "  x.sort!\n \
    \ result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count !=\
    \ 1\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i if i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby,arrays,sorting |>\n<| c |>\nI like your solution, but I believe\
    \ it would be more efficient to sort only once and to return `x.uniq` instead\
    \ of `x.sort!.uniq`.\n<|/ c |>\n<| c |>\nYes, you are right. I just wanted to\
    \ show that `uniq` method can be used.\n<|/ c |>\n<| c |>\nI believe that `x.sort!.uniq`\
    \ is more efficient than `x.uniq` because `uniq` needs to sort the array and `sort!`\
    \ just sorts the array in place.\n<|/ c |>\n<| c |>\nYes, you are right. `uniq`\
    \ method can be used. Thanks for your comment.\n<|/ c |>\n<| c |>\nI believe that\
    \ `x.sort!.uniq` is more efficient than `x.uniq` because `uniq` needs to sort\
    \ the array and `sort!` just sorts the array in place. \u2013 Amadan\n<|/ c |>\n\
    <| a |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n      result << i\n    end\n  end\n  result\nend", "  x.sort.uniq\nend",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,algorithm |>\n<| c |>\n\
    I like your solution, however it has a bug. Try it with `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]`.\
    \ It returns `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]` instead of `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1]`\n\
    <|/ c |>\n<| c |>\nThanks for pointing out. I fixed the bug.\n<|/ c |>\n<| c |>\n\
    This solution does not work for `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]`\n<|/ c\
    \ |>\n<| c |>\nI fixed the bug. Thanks for pointing out.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere's a solution that uses Enumerable#group_by, which I believe is more\
    \ efficient than using Enumerable#each_with_object:\n<code>", "  x.sort.uniq\n\
    end", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI believe this\
    \ would fail for `[1,2,3]` since `[1,2,3].uniq` returns `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nI believe this would fail for `[1,2,3]` since `[1,2,3].uniq` returns\
    \ `[1,2,3]`.\n<|/ c |>\n<| c |>\nI believe this would fail for `[1,2,3]` since\
    \ `[1,2,3].uniq` returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nI believe this would fail\
    \ for `[1,2,3]` since `[1,2,3].uniq` returns `[1,2,3]`.\n<|/ c |>\n<| c |>\nI\
    \ believe this would fail for `[1,2,3]` since `[1,2,3].uniq` returns `[1,2,3]`.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  x.sort!\n  result = []\n  x.each do |x|\n\
    \    if x.to_s.chars.uniq.count != 0\n      result << x\n    end\n  end\n  result.sort!\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    if i.to_s.chars.map(&:to_i).uniq.size == 1\n    \
    \  result << i\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\n`x.sort!` will change the original array. `x.sort_by!` will create\
    \ a new array and leave the original untouched.\n<|/ c |>\n<| c |>\nI didn't know\
    \ that. Thanks for pointing it out. I've updated the answer.\n<|/ c |>\n<| c |>\n\
    `x.sort!` will change the original array. `x.sort_by!` will create a new array\
    \ and leave the original untouched.\n<|/ c |>\n<| c |>\n`x.sort!` will change\
    \ the original array. `x.sort_by!` will create a new array and leave the original\
    \ untouched.\n<|/ c |>\n<| c |>\n`x.sort!` will change the original array. `x.sort_by!`\
    \ will create a new array and leave the original untouched.\n<|/ c |>\n<| a dscore=3\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.count != 1\n  end\n  result\nend\nunique_digits([1,2,3,4,5,6,7,8,9,0])",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI guess you\
    \ meant `x.sort!` instead of `x.sort`\n<|/ c |>\n<| c |>\nYes, I meant `x.sort!`\
    \ instead of `x.sort`\n<|/ c |>\n<| c |>\n`x.sort!` will sort the array in place.\
    \ `x.sort` will create a new array and sort it.\n<|/ c |>\n<| c |>\nYes, I know.\
    \ My point was that `x.sort` will create a new array and sort it, so `x.sort!`\
    \ will sort the array in place. `x.sort` will create a new array and sort it.\n\
    <|/ c |>\n<| c |>\nI guess you meant `x.sort!` instead of `x.sort`\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>", "  x.sort!\n  result = []\n  x.each do |x|\n    result\
    \ << x if x % 2 == 0\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i unless i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n\
    \  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n  \
    \  result << i if i.to_s.chars.uniq.size == 1\n  end\n  result\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nYes, it does. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt doesn't work.\
    \ Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nIt doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    if i.to_s.chars.map(&:to_i).uniq.count\
    \ == 1\n      result << i\n    end\n  end\n  result\nend", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size == 1\n  end\n\
    \  result\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nI tested it with `[1,2,3]` and it works. I guess you missed\
    \ the part where I said \"Given a list of positive integers x. return a sorted\
    \ list of all elements that hasn't any even digit.\"\n<|/ c |>\n<| c |>\nYes,\
    \ I missed that. Sorry. :)\n<|/ c |>\n<| c |>\nI added a more efficient solution\
    \ that doesn't require sorting.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i unless i.to_s.chars.uniq.count\
    \ % 2 == 0\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n\
    This doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nI tested it with\
    \ `[1,2,3]` and it worked fine.\n<|/ c |>\n<| c |>\nYes, it works. But it also\
    \ works with `[1,2,3]`. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nI tested it\
    \ with `[1,2,3]` and it worked fine.\n<|/ c |>\n<| c |>\nI tested it with `[1,2,3]`\
    \ and it worked fine.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count !=\
    \ 1\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    if\
    \ i.to_s.chars.map(&:to_i).uniq.count == 1\n      result << i\n    end\n  end\n\
    \  result\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis solution doesn't work\
    \ if the array is `[1,2,3]`\n<|/ c |>\n<| c |>\nIt works, it just doesn't produce\
    \ the correct result. Try it yourself.\n<|/ c |>\n<| c |>\nYes, it works. I tested\
    \ it before posting. What is your expected output?\n<|/ c |>\n<| c |>\n`[1,2,3]`\
    \ should return `[2,3]`\n<|/ c |>\n<| c |>\nOh, I see. My bad. Sorry about that.\n\
    <|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i if i.to_s.chars.uniq.count > 1\n  end\n  result\nend\n\
    </code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\nThis doesn't work. Try\
    \ `unique_digits([1,2,3,4,5,6,7,8,9])`\n<|/ c |>\n<| c |>\nIt works fine for me.\
    \ Try it yourself.\n<|/ c |>\n<| c |>\nYes, it works. But it also returns `[1,2,3,4,5,6,7,8,9]`\
    \ which is not the expected result. Try it yourself.\n<|/ c |>\n<| c |>\nYes,\
    \ I see what you mean. Thanks for pointing that out. I've updated my answer.\n\
    <|/ c |>\n<| c |>\nThis doesn't work. Try `unique_digits([1,2,3,4,5,6,7,8,9])`\n\
    <|/ c |>\n<| a tags=ruby,arrays,algorithm |>\n<code>", "  x.sort!\n  result =\
    \ []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count > 1\n  end\n\
    \  result\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count >\
    \ 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\n\
    This is not the correct answer. `unique_digits` returns `[1,2,3,4,5,6,7,8,9,0]`\
    \ but your method returns `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<| c |>\nI fixed\
    \ the bug, thanks for pointing it out. :)\n<|/ c |>\n<| a tags=ruby,arrays,sorting\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n  result\nend\n</code>\n<|/\
    \ a tags=ruby,algorithm |>\n<| c |>\n`x.sort!` will mutate the original array.\
    \ `x.sort!(&:to_i).uniq` will create a new array without mutating the original.\n\
    <|/ c |>\n<| c |>\nYes, you are right. Thanks for pointing out. I've updated my\
    \ answer.\n<|/ c |>\n<| c |>\n`x.sort!(&:to_i).uniq` will create a new array without\
    \ mutating the original.\n<|/ c |>\n<| c |>\n`x.sort!(&:to_i).uniq` will create\
    \ a new array without mutating the original.\n<|/ c |>\n<| c |>\n`x.sort!(&:to_i).uniq`\
    \ will create a new array without mutating the original.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.count > 1\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis doesn't answer the question at all. You're just reiterating what\
    \ OP already knows.\n<|/ c |>\n<| c |>\nThe OP asked for \"a sorted list of all\
    \ elements that hasn't any even digit.\" This answer does exactly that.\n<|/ c\
    \ |>\n<| c |>\nOP asked for \"a sorted list of all elements that hasn't any even\
    \ digit.\" This answer does exactly that.\n<|/ c |>\n<| c |>\nThe OP asked for\
    \ \"a sorted list of all elements that hasn't any even digit.\" This answer does\
    \ exactly that.\n<|/ c |>\n<| c |>\nThe OP asked for \"a sorted list of all elements\
    \ that hasn't any even digit.\" This answer does exactly that.\n<|/ c |>\n<| a\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i unless\
    \ i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are multiple even digits in a row. For\
    \ example, `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ != i.to_s.chars.count\n  end\n  result\nend", "  x.sort.uniq\nend", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count !=\
    \ i.to_s.chars.count\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i if i.to_s.chars.uniq.count != i.to_s.chars.count\n \
    \ end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\n\
    This doesn't work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<| c |>\nI\
    \ tested it on ruby 2.4.1 and it works. I didn't test on other versions.\n<|/\
    \ c |>\n<| c |>\nI tested it on ruby 2.4.1 and it works. I didn't test on other\
    \ versions.\n<|/ c |>\n<| c |>\nI tested it on ruby 2.4.1 and it works. I didn't\
    \ test on other versions.\n<|/ c |>\n<| c |>\nI tested it on ruby 2.4.1 and it\
    \ works. I didn't test on other versions.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.count != i.to_s.chars.count\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nIt works. `[1,2,3].sort.uniq` returns `[1,2,3]`. `[1,2,3].sort.uniq.sort`\
    \ returns `[1,2,3]`.\n<|/ c |>\n<| c |>\n`[1,2,3].sort.uniq` returns `[1,2,3]`.\
    \ `[1,2,3].sort.uniq.sort` returns `[1,2,3]`.\n<|/ c |>\n<| c |>\n`[1,2,3].sort.uniq`\
    \ returns `[1,2,3]`. `[1,2,3].sort.uniq.sort` returns `[1,2,3]`.\n<|/ c |>\n<|\
    \ c |>\n`[1,2,3].sort.uniq` returns `[1,2,3]`. `[1,2,3].sort.uniq.sort` returns\
    \ `[1,2,3]`.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    if i.to_s.chars.map(&:to_i).uniq.size == 1\n      result\
    \ << i\n    end\n  end\n  result\nend", "  x.sort.uniq\nend\n</cell>\n<code language=julia-1.0>\n\
    unique_digits([1,2,3,4,5,6,7,8,9,0])\n</cell>\n<code language=julia-1.0>", " \
    \ x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis\
    \ doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt works. I tested\
    \ it with `[1,2,3]`. What do you mean by \"doesn't work\"?\n<|/ c |>\n<| c |>\n\
    It doesn't return `[1,2,3]` but `[2,3]`.\n<|/ c |>\n<| c |>\nOh, I see. You are\
    \ right. Sorry, I missed that requirement. I'll fix my answer.\n<|/ c |>\n<| c\
    \ |>\nI fixed my answer. Thanks for pointing it out.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.size == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`. It returns `[1,2,3]`\
    \ instead of `[2,3]`.\n<|/ c |>\n<| c |>\nIt returns `[2,3]` because `[1,2,3]`\
    \ has two `2`s. `[2,3]` has one `2` and one `3`.\n<|/ c |>\n<| c |>\nAh yes, I\
    \ see now. Sorry for the misunderstanding.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  x.sort!\n  x.uniq!\n  x\nend", "  x.sort!\n  result = []\n  x.each do |i|\n \
    \   result << i if i.to_s.chars.map(&:to_i).uniq.count == 1\n  end\n  result\n\
    end\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\nThis solution doesn't\
    \ work for `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ != 0\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis does not\
    \ provide an answer to the question. To critique or request clarification from\
    \ an author, leave a comment below their post. - [From Review](/review/low-quality-posts/15709192)\n\
    <|/ c |>\n<| c |>\nThis does provide an answer to the question. He asked for a\
    \ way to find all numbers that do not have any even digit. He also asked for help\
    \ with his solution. He also asked for help with his solution. He also asked for\
    \ help with his solution. He also asked for help with his solution. He also asked\
    \ for help with his solution. He also asked for help with his solution. He also\
    \ asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also asked for help with his solution. He also asked for help with his solution.\
    \ He also as", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n  result\nend\n</code>\n<|/\
    \ a tags=ruby,arrays,sorting |>\n<| c |>\nThis doesn't work if there are multiple\
    \ numbers with same number of digits. For example, `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]`\
    \ returns `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]`\n<|/ c |>\n<| c |>\nI agree\
    \ with you. My solution doesn't work if there are multiple numbers with same number\
    \ of digits. I updated my answer to fix this problem.\n<|/ c |>\n<| a tags=ruby,arrays,sorting\
    \ |>\n<code>", "  x.sort.uniq\nend", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i unless i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n  result\n\
    end\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| a dscore=0 |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i unless i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis solution\
    \ doesn't work if `x` is `[1,2,3]`. It returns `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    Yes, I noticed that and fixed it now. Thanks for pointing that out.\n<|/ c |>\n\
    <| c |>\nThis solution doesn't work if `x` is `[1,2,3]`. It returns `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nI fixed it now. Thanks for pointing that out.\n<|/ c |>\n<|\
    \ a dscore=0 |>\n<code>", "  x.sort!\n  result = []\n  x.each do |x|\n    result\
    \ << x if x.to_s.chars.uniq.count != 0\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThanks for your answer. Your solution works perfectly for me. I'm\
    \ just wondering why my solution doesn't work. Could you please explain that?\n\
    <|/ c |>\n<| c |>\nYour solution doesn't work because you sort your array and\
    \ then you try to find unique elements. But your array is already sorted, so you\
    \ just need to find unique elements. So you just need to remove `x.sort!` and\
    \ it will work. Or you can just remove `x.sort!` and then use `x.uniq` instead\
    \ of `x.uniq!`\n<|/ c |>\n<| c |>\nThanks for your explanation. Now I understand\
    \ why my solution doesn't work. Thanks again.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ % 2 == 0\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<| c |>\nI missed that\
    \ requirement. Thanks for pointing it out.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.count != 0\n  end\n  result\nend", "  x.sort!\n  result =\
    \ []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count != i.to_s.chars.count\n\
    \  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't\
    \ work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<| c |>\nI tested it and\
    \ it works. I added a test case to my answer. Can you please explain why it doesn't\
    \ work?\n<|/ c |>\n<| c |>\nI tested it and it works. I added a test case to my\
    \ answer. Can you please explain why it doesn't work?\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works. I added a test case to my answer. Can you please explain why\
    \ it doesn't work?\n<|/ c |>\n<| c |>\nI tested it and it works. I added a test\
    \ case to my answer. Can you please explain why it doesn't work?\n<|/ c |>\n<|\
    \ a tags=ruby,arrays |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i if i.to_s.chars.uniq.size == 1\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby,arrays,sorting |>\n<| a tags=ruby,arrays,sorting |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n  result\nend\n</code>\n<|/\
    \ a tags=ruby,arrays,algorithm |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\n: Thanks for pointing out. I've updated my answer.\n<|/ c |>\n\
    <| c |>\n: I've updated my answer again. Now it works with `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\n: I've updated my answer again. Now it works with `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\n: I've updated my answer again. Now it works with `[1,2,3]`.\n<|/ c |>\n\
    <| a tags=ruby,arrays,algorithm |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i if i.to_s.chars.uniq.size == 1\n  end\n  result\nend",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't\
    \ work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with\
    \ `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `[1,2,3]`.\n<|/\
    \ c |>\n<| c |>\nIt doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    It doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i unless i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c\
    \ |>\nThis doesn't work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<| c\
    \ |>\nIt works. I tested it with `[1,2,3,4,5,6,7,8,9,0]`. Please check my updated\
    \ answer.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n\
    <|/ c |>\n<| c |>\nIt works. I tested it with `[1,2,3,4,5,6,7,8,9,0]`. Please\
    \ check my updated answer.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i unless i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer. Your solution is\
    \ very similar to mine. My solution also works, but I wanted to know why my solution\
    \ didn't work. Thanks again.\n<|/ c |>\n<| c |>\nI guess you were trying to find\
    \ out why your solution didn't work. My solution was to show you the difference\
    \ between your solution and mine. Your solution was a lot more complicated than\
    \ it needed to be. My solution was a lot simpler.\n<|/ c |>\n<| c |>\nYes, I understand\
    \ your solution is more complicated than mine. But I wanted to know why my solution\
    \ didn't work. Thanks again.\n<|/ c |>\n<| a |>\n<code>", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count != 0\n  end\n\
    \  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size ==\
    \ 1\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work.\
    \ Try it with `[1,2,3,4,5,6,7,8,9,0]`\n<|/ c |>\n<| c |>\nI tested it and it works.\
    \ I added a test case in the answer. Can you please tell me what is the problem\
    \ you are facing?\n<|/ c |>\n<| c |>\nThe OP wants to return a list of all elements\
    \ that haven't any even digit. Your code returns all elements that have a single\
    \ digit.\n<|/ c |>\n<| c |>\nI see, I misunderstood the question. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    if i.to_s.chars.uniq.count > 1\n      result << i\n    end\n  end\n\
    \  result\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThis doesn't\
    \ work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n, thanks for pointing out.\
    \ I've fixed the code now.\n<|/ c |>\n<| c |>\n, thanks for pointing out. I've\
    \ fixed the code now.\n<|/ c |>\n<| c |>\n, thanks for pointing out. I've fixed\
    \ the code now.\n<|/ c |>\n<| c |>\n, thanks for pointing out. I've fixed the\
    \ code now.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>",
  "  x.sort!\n  x.uniq!\n  x\nend", "  x.sort!\n  result = []\n  x.each do |i|\n \
    \   if i.to_s.chars.uniq.size == 1\n      result << i\n    end\n  end\n  result\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't answer the question at\
    \ all. You're just reiterating what the OP already knows.\n<|/ c |>\n<| c |>\n\
    I guess I misunderstood the question. I'll try to rephrase it.\n<|/ c |>\n<| c\
    \ |>\nI rephrased the question. Hope it helps.\n<|/ c |>\n<| c |>\nI rephrased\
    \ the question. Hope it helps.\n<|/ c |>\n<| c |>\nI rephrased the question. Hope\
    \ it helps.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i if i.to_s.chars.uniq.count != 0\n  end\n  result\n\
    end", "  x.sort!\n  result = []\n  x.each do |i|\n    if i.to_s.chars.map(&:to_i).uniq.count\
    \ == 1\n      result << i\n    end\n  end\n  result\nend", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i unless i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<|\
    \ c |>\nThis doesn't work. Try it with `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`.\n\
    <|/ c |>\n<| c |>\n: It does work. Try it with `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`.\
    \ `unique_digits` returns `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`.\n\
    <|/ c |>\n<| c |>\n: I missed the fact that `unique_digits` was supposed to return\
    \ an array. Fixed now.\n<|/ c |>\n<| c |>\n: I added a solution that doesn't require\
    \ sorting.\n<|/ c |>\n<| c |>\n: I added a solution that doesn't require sorting.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i if i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\nend", " \
    \ x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n  \
    \  result << i if i.to_s.chars.uniq.size == 1\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nI like this solution, but I wonder\
    \ if it can be done without sorting the array. My intuition tells me that sorting\
    \ is O(n log n), but this solution seems to require O(n) extra space.\n<|/ c |>\n\
    <| c |>\n: Yes, it can be done without sorting, but it's more complicated. I'll\
    \ post an answer in a minute.\n<|/ c |>\n<| c |>\n: I added an answer that doesn't\
    \ require sorting.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\nHere's a solution\
    \ without sorting:\n<code>", "  x.sort.uniq\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThis doesn't work. Try it with `[1,2,2,3]`.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing out. I've fixed the answer.\n<|/ c |>\n<| c |>\nThis doesn't work.\
    \ Try it with `[1,2,2,3]`.\n<|/ c |>\n<| c |>\nThanks for pointing out. I've fixed\
    \ the answer.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i if i.to_s.chars.uniq.count == 1\n  end\n  result\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n  result\
    \ = []\n  x.each do |x|\n    if x.to_s.chars.map(&:to_i).uniq.size == 1\n    \
    \  result << x\n    end\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a tags=ruby,arrays,algorithm |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i if i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\n\
    end", "  x.sort!\n  result = []\n  x.each do |i|\n    if i.to_s.chars.uniq.count\
    \ != 0\n      result << i\n    end\n  end\n  result\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby,arrays |>\n<code>", "  x.sort!\n  result = []\n  x.each do\
    \ |i|\n    if i.to_s.chars.map(&:to_i).uniq.size == 1\n      result << i\n   \
    \ end\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work. Try it with `[1,2,3]`. It returns `[1,2,3]` instead of `[2,3]`.\n<|/ c\
    \ |>\n<| c |>\nThanks for pointing out. I've fixed the answer.\n<|/ c |>\n<| c\
    \ |>\nThis still doesn't work. Try it with `[1,2,3]`. It returns `[1,2,3]` instead\
    \ of `[2,3]`.\n<|/ c |>\n<| c |>\nThanks for pointing out. I've fixed the answer.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i if i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n  result\n\
    end\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThis is not the correct\
    \ solution. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nYes, I didn't see that\
    \ requirement in the question. Thanks for pointing it out.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\nend\nunique_digits([1, 2,\
    \ 3, 5])", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ != 0\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't\
    \ work. Try it with `unique_digits([1,2,3,4,5,6,7,8,9,0])`.\n<|/ c |>\n<| c |>\n\
    I tested it and it works. I added the test case in the answer. Can you please\
    \ tell me what is not working?\n<|/ c |>\n<| c |>\nI tested it and it works. I\
    \ added the test case in the answer. Can you please tell me what is not working?\n\
    <|/ c |>\n<| c |>\nI tested it and it works. I added the test case in the answer.\
    \ Can you please tell me what is not working?\n<|/ c |>\n<| c |>\nI tested it\
    \ and it works. I added the test case in the answer. Can you please tell me what\
    \ is not working?\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  x.sort!\n  x.each do\
    \ |i|\n    x.delete_at(i) if i.to_s.chars.map(&:to_i).uniq.size != 1\n  end\n\
    \  x\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis does not provide\
    \ an answer to the question. To critique or request clarification from an author,\
    \ leave a comment below their post. - [From Review](/review/low-quality-posts/10278394)\n\
    <|/ c |>\n<| c |>\nI believe this does answer the question. He wants to remove\
    \ all elements from an array that have at least one even digit. He also wants\
    \ to sort the array in increasing order. He also wants to remove all elements\
    \ that don't have any even digit. He also wants to remove all elements that don't\
    \ have a unique digit. He also wants to remove all elements that don't have a\
    \ unique digit and are evenly divisible by 2. He also wants to remove all elements\
    \ that don't have a unique digit and are evenly divisible by 3. He also wants\
    \ to remove all elements that don't have a unique digit and are evenly divisible\
    \ by 4. He also wants to remove all elements that don't have a unique digit and\
    \ are evenly divisible by 5. He also wants to remove all elements that don't have\
    \ a unique digit and are evenly divisible by 6. He also wants to remove all elements\
    \ that don't have a unique digit and are evenly divisible by 7. He also wants\
    \ to remove all elements that don't have a unique digit and are evenly divisible\
    \ by 8. He also wants to remove all elements that don't have a unique digit and\
    \ are evenly divisible by 9. He also wants to remove all elements that don't have\
    \ a unique digit and are evenly divisible by 10.\n<|/ c |>\n<| c |>\nHe also wants\
    \ to remove all elements that don't have a unique digit and are evenly divisible\
    \ by 11. He also wants to remove all elements that don't have a unique digit and\
    \ are evenly divisible by 12. He also wants to remove all elements that don't\
    \ have a unique digit and are evenly divisible by 13. He also wants to remove\
    \ all elements that don't have a unique digit and are evenly divisible by 14.\
    \ He also wants to remove all elements that don't have a unique digit and are\
    \ evenly divisible by 15. He also wants to remove all elements that don't have\
    \ a unique digit and are evenly divisible ", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i if i.to_s.chars.uniq.count == 1\n  end\n  result\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", "  x.sort!\n  result =\
    \ []\n  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size ==\
    \ 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.size == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nI like your solution, but I think it would be more efficient to\
    \ sort the array first, then iterate over it once, rather than sorting it twice.\n\
    <|/ c |>\n<| c |>\nI agree, that's why I added the comment \"# Given a list of\
    \ positive integers x. return a sorted list of all ", "  x.sort!\n  x.uniq!\n\
    \  x\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ != i.to_s.chars.count\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c\
    \ |>\n<| c |>\n: I tested it and it works. I added the test case in the answer.\n\
    <|/ c |>\n<| c |>\n: I added a more efficient solution.\n<|/ c |>\n<| c |>\n:\
    \ I added a more efficient solution.\n<|/ c |>\n<| c |>\n: I added a more efficient\
    \ solution.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size ==\
    \ 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nI like\
    \ your solution, but I believe it can be improved. `x.sort!` will sort the array\
    \ in-place, which will cause the original array to be mutated. `x.sort!(&:itself)`\
    \ will create a new array without mutating the original. `x.sort!(&:to_i)` will\
    \ create a new array without mutating the original. `x.sort!(&:to_s)` will create\
    \ a new array without mutating the original. `x.sort!(&:to_sym)` will create a\
    \ new array without mutating the original. `x.sort!(&:to_sym)` will create a new\
    \ array without mutating the original. `x.sort!(&:to_sym)` will create a new array\
    \ without mutating the original. `x.sort!(&:to_sym)` will create a new array without\
    \ mutating the original. `x.sort!(&:to_sym)` will create a new array without mutating\
    \ the original. `x.sort!(&:to_sym)` will create a new array without mutating the\
    \ original. `x.sort!(&:to_sym)` will create a new array without mutating the original.\
    \ `x.sort!(&:to_sym)` will create a new array without mutating the original. `x.sort!(&:to_sym)`\
    \ will create a new array without mutating the original. `x.sort!(&:to_sym)` will\
    \ create a new array without mutating the original. `x.sort!(&:to_sym)` will create\
    \ a new array without mutating the original. `x.sort!(&:to_sym)` will create a\
    \ new array without mutating the original. `x.sort!(&:to_sym)` will create a new\
    \ array without mutating the original. `x.sort!(&:to_sym)` will create a new array\
    \ without mutating the original. `x.sort!(&:to_sym)` will create a new array without\
    \ mutating the original. `x.sort!(&:to_sym)` will create a new array without mutating\
    \ the original. `x.sort!(&:to_sym)` will create a new array without mutating the\
    \ original. `x.sort!(&:to_sym)` will create a new array without mutating the original.\
    \ `x.sort!(&:to_sym)` will create a new array without mutating the original. `x.sort!(&:to_sym)`\
    \ will create a new array without mutating the original. `x.sort!(&:to_sym)` will\
    \ create a new array without mut", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i if i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n  result\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nYes, it does. I tested it before posting.\n<|/ c |>\n<| c |>\n\
    It doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt does work. Try\
    \ it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `[1,2,3]`.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i if i.to_s.chars.uniq.count != 1\n  end\n  result\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nI believe it does. Try it with `[1,2,3]`. It returns `[1,2,3]`.\n<|/\
    \ c |>\n<| c |>\nIt returns `[1,2,3]` because `[1,2,3].uniq` returns `[1,2,3]`.\n\
    <|/ c |>\n<| c |>\nYes, I see that now. Thanks for pointing that out.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i if i.to_s.chars.uniq.size == 1\n  end\n  result\nend\nunique_digits([1,\
    \ 2, 3, 10, 4, 5])", "  x.sort!\n  result = []\n  x.each do |i|\n    result <<\
    \ i if i.to_s.chars.uniq.size == 1\n  end\n  result\nend", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i unless i.to_s.chars.uniq.count % 2 ==\
    \ 0\n  end\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like the `each_with_object`\
    \ solution, but I wonder if there's a way to avoid the temporary array `result`?\
    \ I mean, `each_with_object` will create an array with one element (the return\
    \ value of the block), but that element will then be discarded and replaced by\
    \ the next element of the enumerator. Is there a way to avoid that?\n<|/ c |>\n\
    <| c |>\n: Yes, there is. See my answer.\n<|/ c |>\n<| a dscore=3 |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i unless i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<|\
    \ c |>\nI like your solution, but I believe it can be made more efficient by not\
    \ converting `x` to a string, since it already is an array of integers. Also,\
    \ `x.sort!` can be replaced by `x.sort`\n<|/ c |>\n<| c |>\nYes, you are right.\
    \ Thanks for your comment. I will update my answer.\n<|/ c |>\n<| c |>\nI believe\
    \ this solution is O(n^2) (worst case), whereas the other solution is O(n) (best\
    \ case).\n<|/ c |>\n<| c |>\nI believe this solution is O(n) because `x.sort!`\
    \ sorts the array in-place. `x.sort` would create a new array and copy the elements\
    \ to it, which would take O(n^2) time.\n<|/ c |>\n<| c |>\nI believe this solution\
    \ is O(n) because `x.sort!` sorts the array in-place. `x.sort` would create a\
    \ new array and copy the elements to it, which would take O(n^2) time.\n<|/ c\
    \ |>\n<| a tags=ruby,arrays,algorithm |>\n<code>", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i if i.to_s.chars.uniq.size == 1\n  end\n  result\n\
    end\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThis doesn't work. Try\
    \ it with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt works, try it with `[1,2,3]`\n<|/\
    \ c |>\n<| c |>\nIt doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    It works, try it with `[1,2,3]`\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with\
    \ `[1,2,3]`.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  x.sort.uniq\
    \ \nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis\
    \ doesn't work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<| c |>\n, thanks\
    \ for pointing out. I fixed the bug. Thanks again.\n<|/ c |>\n<| c |>\nI like\
    \ your solution, but I wonder how it compares to mine. My solution is O(n), yours\
    \ is O(n^2). Do you think mine is faster?\n<|/ c |>\n<| c |>\n, mine is O(n),\
    \ yours is O(n^2). Do you think mine is faster?\n<|/ c |>\n<| c |>\n, thanks for\
    \ your comment. I think mine is faster than yours because mine is O(n) while yours\
    \ is O(n^2). Do you think mine is faster?\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ % 2 == 0\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n\
    <| c |>\nThis doesn't work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<|\
    \ c |>\nYes, it does. I tested it before posting it. I don't know why you think\
    \ it doesn't.\n<|/ c |>\n<| c |>\nI tested it before posting it. I don't know\
    \ why you think it doesn't.\n<|/ c |>\n<| c |>\nI tested it before posting it.\
    \ I don't know why you think it doesn't.\n<|/ c |>\n<| c |>\nI tested it before\
    \ posting it. I don't know why you think it doesn't.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.count == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    , thanks for pointing out. I've updated my answer.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ != i.to_s.chars.count\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i if i.to_s.chars.uniq.size == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    I tested it with `[1,2,3]` and it worked fine.\n<|/ c |>\n<| c |>\nI tested it\
    \ with `[1,2,3]` and it worked fine.\n<|/ c |>\n<| c |>\nI tested it with `[1,2,3]`\
    \ and it worked fine.\n<|/ c |>\n<| c |>\nI tested it with `[1,2,3]` and it worked\
    \ fine.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count != 1\n  end\n\
    \  result\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\n`x.sort!` will mutate the\
    \ array in-place, which is not the best practice. Instead, use `x.sort { |a, b|\
    \ a.to_s.chars.uniq.count <=> b.to_s.chars.uniq.count }`.\n<|/ c |>\n<| c |>\n\
    Thanks for your comment. I just realized that `sort!` will mutate the array in-place\
    \ and I changed my answer.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count %\
    \ 2 == 0\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't\
    \ work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<| c |>\n, thanks for\
    \ pointing out, I fixed the code now. :)\n<|/ c |>\n<| c |>\nThis still doesn't\
    \ work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<| c |>\n, thanks for\
    \ pointing out, I fixed the code now. :)\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n      result << i\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    , thanks for pointing out. I fixed the code now.\n<|/ c |>\n<| c |>\n, thanks\
    \ for pointing out. I fixed the code now.\n<|/ c |>\n<| c |>\n, thanks for pointing\
    \ out. I fixed the code now.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", " \
    \ x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ % 2 == 0\n  end\n  result\nend\nunique_digits([1,2,3,4,5,6,7,8,9,10])", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size ==\
    \ 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-4\
    \ |>\n<| c |>\nThis doesn't work if you have a number like `12321`\n<|/ c |>\n\
    <| c |>\nYes, it does. `12321` has two digits that aren't even, and `12321` has\
    \ two digits that aren't even.\n<|/ c |>\n<| c |>\nOh sorry, I missed that part.\
    \ My bad.\n<|/ c |>\n<| a |>\n<code>", "  x.sort!\n  result = []\n  x.each do\
    \ |i|\n    result << i if i.to_s.chars.uniq.count != 0\n  end\n  result\nend\n\
    </code>\n<|/ a tags=ruby,arrays,algorithm |>\n<| c |>\nThe OP wants the result\
    \ to be sorted, so `x.sort!` should be called before `x.each do |i|`.\n<|/ c |>\n\
    <| c |>\nI agree. Thanks for pointing out.\n<|/ c |>\n<| c |>\nI believe that\
    \ `x.sort!` should be called before `x.each do |i|` because `x.sort!` sorts the\
    \ array in-place and `x.each` iterates over the array and modifies the array in\
    \ place. `x.sort!` should be called before `x.each` because `x.each` modifies\
    \ the array in place.\n<|/ c |>\n<| c |>\nThanks for pointing out. I've updated\
    \ my answer.\n<|/ c |>\n<| c |>\nThanks for your answer. Your solution works but\
    \ I think it can be done more efficiently using recursion.\n<|/ c |>\n<| a |>\n\
    <code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ != i.to_s.chars.length\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThanks for your answer. Your solution works well for small arrays, but\
    \ it takes too long for large arrays. I tested it on a large array and it took\
    \ about 2 minutes to finish it. I was wondering if there is a faster way to do\
    \ it.\n<|/ c |>\n<| c |>\nI tested it on a large array and it took about 2 minutes\
    \ to finish it. I was wondering if there is a faster way to do it.\n<|/ c |>\n\
    <| c |>\nI tested it on a large array and it took about 2 minutes to finish it.\
    \ I was wondering if there is a faster way to do it.\n<|/ c |>\n<| c |>\nI tested\
    \ it on a large array and it took about 2 minutes to finish it. I was wondering\
    \ if there is a faster way to do it.\n<|/ c |>\n<| c |>\nI tested it on a large\
    \ array and it took about 2 minutes to finish it. I was wondering if there is\
    \ a faster way to do it.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count !=\
    \ 1\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work.\
    \ Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<| c |>\nI guess you meant `x.sort!`\
    \ instead of `x.sort`\n<|/ c |>\n<| c |>\nYes, I meant `x.sort!` instead of `x.sort`\n\
    <|/ c |>\n<| a |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i unless i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    if i.to_s.chars.map(&:to_i).uniq.size == 1\n      result << i\n\
    \    end\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for\
    \ your answer. Your solution works but it is very slow for large arrays. I posted\
    \ my own solution that is much faster.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\n<code>", "  x.sort!\n  x.uniq!\n  x\nend\n</cell>\n<code language=julia-1.0>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend", "  x.sort.uniq\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis is not an answer to the question. He wants to know why his\
    \ code doesn't work, not how to fix it.\n<|/ c |>\n<| c |>\nI agree with you,\
    \ my answer was more of a \"why doesn't it work\" than a \"how to fix it\" but\
    \ I'll add some more explanation anyway\n<|/ c |>\n<| c |>\nI agree with you,\
    \ my answer was more of a \"why doesn't it work\" than a \"how to fix it\" but\
    \ I'll add some more explanation anyway\n<|/ c |>\n<| c |>\nI agree with you,\
    \ my answer was more of a \"why doesn't it work\" than a \"how to fix it\" but\
    \ I'll add some more explanation anyway\n<|/ c |>\n<| c |>\nI agree with you,\
    \ my answer was more of a \"why doesn't it work\" than a \"how to fix it\" but\
    \ I'll add some more explanation anyway\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work. Try it with `[1,2,3]`\n<|/ c |>\n<| c |>\nYeah, I forgot about that. Thanks\
    \ for pointing it out. I've updated my answer.\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i unless i.to_s.chars.uniq.count\
    \ % 2 == 0\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i if i.to_s.chars.uniq.count == 1\n  end\n  result\nend\nunique_digits([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9])", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i if i.to_s.chars.uniq.size == 1\n  end\n  result\nend\nunique_digits([1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9])", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i if i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i if i.to_s.chars.uniq.count == 1\n  end\n  result\nend\n\
    </code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThis doesn't work. Try it\
    \ with `[1,2,3]`.\n<|/ c |>\n<| c |>\nIt works, try it with `[1,2,3]`\n<|/ c |>\n\
    <| c |>\nIt works, try it with `[1,2,3]`\n<|/ c |>\n<| c |>\nIt works, try it\
    \ with `[1,2,3]`\n<|/ c |>\n<| c |>\nIt works, try it with `[1,2,3]`\n<|/ c |>\n\
    <| a tags=ruby,arrays,sorting |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i if i.to_s.chars.uniq.size == 1\n  end\n  result\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n\
    <|/ c |>\n<| c |>\nYes, it does. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n\
    <| c |>\nI didn't say it wouldn't, I said it wouldn't. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n\
    <|/ c |>\n<| c |>\nOh, I see. Sorry, I misunderstood your question. I'll delete\
    \ my answer.\n<|/ c |>\n<| c |>\nNo problem. Your answer is fine, just pointing\
    \ out that your answer doesn't work. :)\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ != i.to_s.chars.count\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a tags=ruby,arrays,algorithm |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i if i.to_s.chars.uniq.count > 1\n  end\n  result\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't answer the question. He wants\
    \ to know if there are any numbers that only have one digit.\n<|/ c |>\n<| c |>\n\
    I believe this does answer the question. He wants to know if there are any numbers\
    \ that only have one digit. He also stated that he wants to know if there are\
    \ any numbers that only have one digit.\n<|/ c |>\n<| c |>\nI believe this does\
    \ answer the question. He wants to know if there are any numbers that only have\
    \ one digit. He also stated that he wants to know if there are any numbers that\
    \ only have one digit.\n<|/ c |>\n<| c |>\nI believe this does answer the question.\
    \ He wants to know if there are any numbers that only have one digit. He also\
    \ stated that he wants to know if there are any numbers that only have one digit.\n\
    <|/ c |>\n<| c |>\nI believe this does answer the question. He wants to know if\
    \ there are any numbers that only have one digit. He also stated that he wants\
    \ to know if there are any numbers that only have one digit.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.count == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i if i.to_s.chars.uniq.count != 0\n  end\n  result\nend", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i unless i.to_s.chars.uniq.count\
    \ % 2 == 0\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't\
    \ answer the question of how to get the unique digits. Also, `x.sort!` will mutate\
    \ the array and will cause problems if you try to use it again later.\n<|/ c |>\n\
    <| c |>\nI agree with you. My answer was more about how to get the unique digits.\
    \ I edited my answer to include a more efficient solution.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n      result << i\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3,4,5,6,7,8,9,0]`\n<|/ c |>\n\
    <| c |>\n, thanks for pointing out. I've updated my answer. I've tested it and\
    \ it works.\n<|/ c |>\n<| c |>\n, I've updated my answer again. I've tested it\
    \ and it works.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i if i.to_s.chars.uniq.count != 0\n  end\n  result\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't work. Try\
    \ it with `[1,2,3]`. It returns `[1,2,3]` instead of `[2,3]`.\n<|/ c |>\n<| c\
    \ |>\n, thanks for pointing out. I've fixed the code. Now it works as expected.\n\
    <|/ c |>\n<| a |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i if i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n  result\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n\
    <| c |>\nYes, I forgot about that case. Thanks for pointing out. I've updated\
    \ the answer.\n<|/ c |>\n<| a tags=ruby,arrays |>\n<code>", "  x.sort!\n  x.uniq!\n\
    \  x\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| a\
    \ dscore=0 |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i unless i.to_s.chars.uniq.size == 1\n  end\n  result\nend", "  x.sort.uniq\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size == 1\n  end\n\
    \  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.size == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i unless i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\nend\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work if there are multiple even digits in a row.\
    \ For example, `unique_digits([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20])` returns `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15, 16, 17, 18, 19, 20]`.\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed\
    \ the answer.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size == 1\n\
    \  end\n  result\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work.\
    \ Try `unique_digits([1,2,3,4,5,6,7,8,9,0])`\n<|/ c |>\n<| c |>\nI fixed the bug,\
    \ thanks for pointing it out. :)\n<|/ c |>\n<| c |>\nI fixed the bug, thanks for\
    \ pointing it out. :)\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count != 1\n  end\n\
    \  result\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails,ruby-on-rails-3 |>\n<|\
    \ c |>\nThis doesn't work if there are multiple digits in a string. For example,\
    \ `unique_digits([\"12\", \"34\", \"56\", \"78\"])` returns `[\"12\", \"34\",\
    \ \"56\", \"78\"]`\n<|/ c |>\n<| c |>\nI see your point. I've updated my answer\
    \ to include a solution that will handle multiple digits in a string.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    if\
    \ i.to_s.chars.map(&:to_i).uniq.size == 1\n      result << i\n    end\n  end\n\
    \  result\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`x.sort!` will modify\
    \ the array in-place. `x.sort` will return a sorted copy. `x.sort!.uniq` will\
    \ return the unique elements of the sorted copy. `x.sort.uniq` will return the\
    \ unique elements of the original array.\n<|/ c |>\n<| c |>\nThanks for your comment.\
    \ I just edited my answer to reflect your comment.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't answer the question, which is about a specific algorithm\
    \ that doesn't use any loops.\n<|/ c |>\n<| c |>\nI agree with you, my answer\
    \ was more about how to solve the problem with loops, not how to solve it without\
    \ loops.\n<|/ c |>\n<| c |>\nI agree with you, my answer was more about how to\
    \ solve the problem with loops, not how to solve it without loops.\n<|/ c |>\n\
    <| c |>\nI agree with you, my answer was more about how to solve the problem with\
    \ loops, not how to solve it without loops.\n<|/ c |>\n<| c |>\nI agree with you,\
    \ my answer was more about how to solve the problem with loops, not how to solve\
    \ it without loops.\n<|/ c |>\n<| a tags=ruby,algorithm |>\n<code>", "  x.sort.uniq\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't answer the question. OP\
    \ wants to return a list of all elements that don't have an even digit.\n<|/ c\
    \ |>\n<| c |>\nI misunderstood the question, thanks for pointing that out. I've\
    \ updated my answer.\n<|/ c |>\n<| a |>\n<code>", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i if i.to_s.chars.uniq.count > 1\n  end\n  result\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count != i.to_s.chars.count\n\
    \  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i if i.to_s.chars.uniq.count == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nThis doesn't work for negative numbers. `unique_digits([-1, -2,\
    \ -3])` returns `[-3, -2, -1]`, but should return `[-1, -2]`.\n<|/ c |>\n<| c\
    \ |>\nI fixed the bug. Thanks for pointing out.\n<|/ c |>\n<| a |>\n<code>", " \
    \ x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ % 2 == 0\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i if i.to_s.chars.uniq.count != 0\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| a tags=ruby |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i unless i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n\
    \  result\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| a dscore=0 |>\n\
    <code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\n`x.sort!`\
    \ will mutate the array in-place. `x.sort` will return a sorted copy. `x.sort!`\
    \ will mutate the array in-place and return the sorted copy. `x.sort` will mutate\
    \ the array in-place and return the sorted copy.\n<|/ c |>\n<| c |>\nThanks for\
    \ pointing out. I was thinking about `sort` but didn't realize that `sort!` will\
    \ mutate the array in-place.\n<|/ c |>\n<| c |>\n`x.sort!` will mutate the array\
    \ in-place and return the sorted copy. `x.sort` will mutate the array in-place\
    \ and return the sorted copy.\n<|/ c |>\n<| c |>\n`x.sort!` will mutate the array\
    \ in-place and return the sorted copy. `x.sort` will mutate the array in-place\
    \ and return the sorted copy.\n<|/ c |>\n<| c |>\n`x.sort!` will mutate the array\
    \ in-place and return the sorted copy. `x.sort` will mutate the array in-place\
    \ and return the sorted copy.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  x.sort!\n\
    \  result = []\n  x.each do |i|\n    result << i unless i.to_s.chars.uniq.count\
    \ > 1\n  end\n  result\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work. Try\
    \ it with `[1,2,3]`. It returns `[1,2,3]` instead of `[2,3]`.\n<|/ c |>\n<| c\
    \ |>\n: You are right. I missed that case. Thanks for pointing out. Updated the\
    \ answer.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  x.sort!\n \
    \ result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count > 1\n\
    \  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.size == 1\n  end\n  result\nend", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i if i.to_s.chars.uniq.count % 2 == 0\n  end\n\
    \  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i unless\
    \ i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n  result\nend\n</code>\n<|/\
    \ a dscore=1 |>\n<| a tags=ruby,arrays |>\n<code>", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size == 1\n\
    \  end\n  result\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis\
    \ doesn't work. Try it with `[1,2,3]`. It returns `[1,2,3]` instead of `[2,3]`.\n\
    <|/ c |>\n<| c |>\nYeah, I missed that requirement. Updated the answer.\n<|/ c\
    \ |>\n<| a dscore=1 |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i if i.to_s.chars.map(&:to_i).uniq.size == 1\n  end\n  result\n\
    end", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.count != 0\n  end\n  result\nend", "  x.sort.uniq\nend", " \
    \ x.sort!\n  result = []\n  x.each do |i|\n    if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n      result << i\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nI like the idea of using uniq to remove duplicates, but I wonder\
    \ if there is a way to do it without converting to a string. My first thought\
    \ was to convert the array to a string and use gsub to remove all instances of\
    \ digits, but that would require converting back to an array and sorting it again.\n\
    <|/ c |>\n<| c |>\nI guess you could do `x.map(&:to_s).uniq.sort` but that would\
    \ require converting back to an array.\n<|/ c |>\n<| c |>\nYes, that would require\
    \ converting back to an array. I'm thinking there might be a way to do it without\
    \ converting to a string, but I haven't thought of it yet.\n<|/ c |>\n<| c |>\n\
    I added a solution that doesn't require converting to a string.\n<|/ c |>\n<|\
    \ c |>\nI added a solution that doesn't require converting to a string. :)\n<|/\
    \ c |>\n<| a tags=ruby,arrays |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i if i.to_s.chars.uniq.count != 0\n  end\n  result\nend\n\
    </code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThanks for your answer. Your\
    \ solution is very elegant and concise. However I cannot use any additional methods.\
    \ I should only use sort, uniq, chars, count and each methods. I cannot use any\
    \ additional methods. I should only use sort, uniq, chars, count and each methods.\
    \ I cannot use any additional methods. I should only use sort, uniq, chars, count\
    \ and each methods. I cannot use any additional methods. I should only use sort,\
    \ uniq, chars, count and each methods. I cannot use any additional methods. I\
    \ should only use sort, uniq, chars, count and each methods.\n<|/ c |>\n<| c |>\n\
    I cannot use any additional methods. I should only use sort, uniq, chars, count\
    \ and each methods. I cannot use any additional methods. I should only use sort,\
    \ uniq, chars, count and each methods. I cannot use any additional methods. I\
    \ should only use sort, uniq, chars, count and each methods. I cannot use any\
    \ additional methods. I should only use sort, uniq, chars, count and each methods.\n\
    <|/ c |>\n<| c |>\nI cannot use any additional methods. I should only use sort,\
    \ uniq, chars, count and each methods. I cannot use any additional methods. I\
    \ should only use sort, uniq, chars, count and each methods. I cannot use any\
    \ additional methods. I should only use sort, uniq, chars, count and each methods.\
    \ I cannot use any additional methods. I should only use sort, uniq, chars, count\
    \ and each methods.\n<|/ c |>\n<| c |>\nI cannot use any additional methods. I\
    \ should only use sort, uniq, chars, count and each methods. I cannot use any\
    \ additional methods. I should only use sort, uniq, chars, count and each methods.\
    \ I cannot use any additional methods. I should only use sort, uniq, chars, count\
    \ and each methods. I cannot use any additional methods. I should only use sort,\
    \ uniq, chars, count and each methods.\n<|/ c |>\n<| c |>\nI cannot use any additional\
    \ methods. I should only use sort, uniq, chars, count and each methods. I ", " \
    \ x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ == 1\n  end\n  result\nend", "  x.sort!\n  result = []\n  x.each do |i|\n  \
    \  result << i if i.to_s.chars.uniq.size == 1\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby,arrays,sorting |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count != 0\n  end\n\
    \  result\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't answer the\
    \ question. OP wants to know if there are any duplicates in the array. Your solution\
    \ returns `true` if there are duplicates.\n<|/ c |>\n<| c |>\nI believe OP wants\
    \ to know if there are any duplicates in the array and if there are duplicates,\
    \ return `true`\n<|/ c |>\n<| c |>\nYes, that's what OP wants. But your solution\
    \ returns `true` even if there are duplicates.\n<|/ c |>\n<| c |>\nI believe OP\
    \ wants to know if there are any duplicates in the array and if there are duplicates,\
    \ return `true`\n<|/ c |>\n<| c |>\nYes, that's what OP wants. But your solution\
    \ returns `true` even if there are duplicates.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<|\
    \ c |>\nI like your solution, but I believe it can be improved. For example, `unique_digits([1,2,3,4,5,6,7,8,9,0])`\
    \ returns `[1,2,3,4,5,6,7,8,9]`, but should return `[1,2,3,4,5,6,7,8,9,0]`. Also,\
    \ `unique_digits([1,2,3,4,5,6,7,8,9,0])` returns `[1,2,3,4,5,6,7,8,9]`, but should\
    \ return `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<| c |>\nI believe that `unique_digits([1,2,3,4,5,6,7,8,9,0])`\
    \ returns `[1,2,3,4,5,6,7,8,9]`, but should return `[1,2,3,4,5,6,7,8,9,0]`.\n\
    <|/ c |>\n<| c |>\nYes, I believe that `unique_digits([1,2,3,4,5,6,7,8,9,0])`\
    \ returns `[1,2,3,4,5,6,7,8,9]`, but should return `[1,2,3,4,5,6,7,8,9,0]`.\n\
    <|/ c |>\n<| c |>\nI believe that `unique_digits([1,2,3,4,5,6,7,8,9,0])` returns\
    \ `[1,2,3,4,5,6,7,8,9]`, but should return `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n\
    <| c |>\nI believe that `unique_digits([1,2,3,4,5,6,7,8,9,0])` returns `[1,2,3,4,5,6,7,8,9]`,\
    \ but should return `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<| a tags=ruby,arrays,algorithm\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i unless\
    \ i.to_s.chars.uniq.count > 1\n  end\n  result\nend", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i if i.to_s.chars.uniq.count == 1\n  end\n  result\n\
    end", "  x.sort.uniq\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c\
    \ |>\nI like your solution, but I believe it can be improved. `x.sort!` will sort\
    \ the array in-place, which is unnecessary. Also, you could use `x.uniq` instead\
    \ of `x.chars.map(&:to_i).uniq.size == 1`.\n<|/ c |>\n<| c |>\nThanks, I didn't\
    \ know `uniq` existed. I've updated my answer.\n<|/ c |>\n<| c |>\nThanks for\
    \ your solution. I am not able to understand why you used `x.sort!` instead of\
    \ `x.sort`. Can you please explain this?\n<|/ c |>\n<| c |>\n`x.sort!` will sort\
    \ the array in-place, which is unnecessary. Also, you could use `x.uniq` instead\
    \ of `x.chars.map(&:to_i).uniq.size == 1`.\n<|/ c |>\n<| c |>\nThanks for your\
    \ explanation. Can you please explain why you used `x.sort!` instead of `x.sort`?\n\
    <|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i if i.to_s.chars.uniq.size == 1\n  end\n  result\n\
    end\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThis doesn't work. Try\
    \ it with `[1,2,3,4,5,6,7,8,9,0]`.\n<|/ c |>\n<| c |>\n, thanks for pointing out.\
    \ I've fixed the code.\n<|/ c |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n\
    <|/ c |>\n<| c |>\n, thanks for pointing out. I've fixed the code.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result\
    \ << i if i.to_s.chars.uniq.count != 1\n  end\n  result\nend", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,algorithm\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.count > 1\n  end\n  result\nend\nunique_digits([1,3,5,7,9])",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ != 0\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.map(&:to_i).uniq.count == 1\n  end\n  result\nend\n</code>\n<|/\
    \ a tags=ruby,arrays,sorting |>\n<| a tags=ruby,arrays,sorting |>\n<code>", " \
    \ x.sort.uniq \nend\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't\
    \ work. `[1,2,3].uniq` returns `[1,2,3]` instead of `[2,3]`.\n<|/ c |>\n<| c |>\n\
    : I fixed the bug. Thanks for pointing it out.\n<|/ c |>\n<| a tags=ruby,arrays\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |x|\n    if x.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n      result << x\n    end\n  end\n  result\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    I tested it and it works. I added the test case in the answer. Can you please\
    \ explain why it doesn't work?\n<|/ c |>\n<| c |>\nIt doesn't work because `[1,2,3]`\
    \ has three elements and your method returns only two elements. Try it with `[1,2,3,4,5]`.\n\
    <|/ c |>\n<| c |>\nI tested it again and it works. I added the test case in the\
    \ answer. Can you please explain why it doesn't work?\n<|/ c |>\n<| c |>\nI tested\
    \ it again and it works. I added the test case in the answer. Can you please explain\
    \ why it doesn't work?\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", " \
    \ x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c\
    \ |>\nThis doesn't work. Try `unique_digits([1,2,3,4,5,6,7,8,9,0])`.\n<|/ c |>\n\
    <| c |>\nYes, it does. Try it yourself.\n<|/ c |>\n<| c |>\nI did try it myself.\
    \ It doesn't work. Try it yourself.\n<|/ c |>\n<| c |>\nI did try it myself. It\
    \ doesn't work. Try it yourself.\n<|/ c |>\n<| c |>\nI did try it myself. It doesn't\
    \ work. Try it yourself.\n<|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    if i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n      result << i\n    end\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm\
    \ |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    I tested it on [ruby 2.5.1](https://repl.it/repls/AwesomeSpiritedGhost) and it\
    \ works fine.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with `[1,2,3]`.\n<|/\
    \ c |>\n<| c |>\nIt doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| c |>\n\
    It doesn't work. Try it with `[1,2,3]`.\n<|/ c |>\n<| a dscore=0 |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays,sorting\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.size == 1\n  end\n  result\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This solution doesn't work if there are multiple digits in a number.\n<|/ c |>\n\
    <| c |>\n: Yes, I know. That's why I wrote \"Given a list of positive integers\
    \ x. return a sorted list of all elements that hasn't any even digit.\" in the\
    \ first line of my answer.\n<|/ c |>\n<| c |>\n: I edited my answer to include\
    \ a solution that works with multiple digits in a number.\n<|/ c |>\n<| c |>\n\
    : I edited my answer to include a solution that works with multiple digits in\
    \ a number.\n<|/ c |>\n<| c |>\n: I edited my answer to include a solution that\
    \ works with multiple digits in a number.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails\
    \ |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if\
    \ i.to_s.chars.uniq.count != i.to_s.chars.count\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby,arrays,sorting |>\n<| a tags=ruby,arrays,sorting |>\n<code>",
  "  x.sort!\n  result = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count\
    \ > 1\n  end\n  result\nend\n</code>\n<|/ a |>\n<| c |>\nThis does not provide\
    \ an answer to the question. To critique or request clarification from an author,\
    \ leave a comment below their post. - [From Review](/review/low-quality-posts/10606154)\n\
    <|/ c |>\n<| c |>\nI believe it does provide an answer. He asked how to find all\
    \ numbers that don't have an even digit. He also asked how to sort them in increasing\
    \ order. He also asked how to find all numbers that don't have an even digit.\
    \ He also asked how to find all numbers that don't have an even digit. He also\
    \ asked how to find all numbers that don't have an even digit. He also asked how\
    \ to find all numbers that don't have an even digit. He also asked how to find\
    \ all numbers that don't have an even digit. He also asked how to find all numbers\
    \ that don't have an even digit. He also asked how to find all numbers that don't\
    \ have an even digit. He also asked how to find all numbers that don't have an\
    \ even digit. He also asked how to find all numbers that don't have an even digit.\
    \ He also asked how to find all numbers that don't have an even digit. He also\
    \ asked how to find all numbers that don't have an even digit. He also asked how\
    \ to find all numbers that don't have an even digit. He also asked how to find\
    \ all numbers that don't have an even digit. He also asked how to find all numbers\
    \ that don't have an even digit. He also asked how to find all numbers that don't\
    \ have an even digit. He also asked how to find all numbers that don't have an\
    \ even digit. He also asked how to find all numbers that don't have an even digit.\
    \ He also asked how to find all numbers that don't have an even digit. He also\
    \ asked how to find all numbers that don't have an even digit. He also asked how\
    \ to find all numbers that don't have an even digit. He also asked how to find\
    \ all numbers that don't have an even digit. He also asked how to find all numbers\
    \ that don't have an even digit. He also asked how to find all numbers that don't\
    \ have an even digit. He also asked how to find all numbers that don't have an\
    \ even digit. He also asked how to find all numbers that ", "  x.sort!\n  result\
    \ = []\n  x.each do |i|\n    result << i if i.to_s.chars.uniq.count != i.to_s.chars.count\n\
    \  end\n  result\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't answer\
    \ the question. He wants to know if there is a faster way to do this than what\
    \ he has already done.\n<|/ c |>\n<| c |>\nI guess I misunderstood the question.\
    \ I'll delete my answer.\n<|/ c |>\n<| c |>\nI guess I misunderstood the question.\
    \ I'll delete my answer.\n<|/ c |>\n<| c |>\nI guess I misunderstood the question.\
    \ I'll delete my answer.\n<|/ c |>\n<| c |>\nI guess I misunderstood the question.\
    \ I'll delete my answer.\n<|/ c |>\n<| a |>\n<code>", "  x.sort!\n  result = []\n\
    \  x.each do |i|\n    result << i if i.to_s.chars.uniq.count == 1\n  end\n  result\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work. Try it with `unique_digits([1,5,3,7,2,4,6,8,0])`.\n\
    <|/ c |>\n<| c |>\nYes, it does. Try it with `unique_digits([1,5,3,7,2,4,6,8,0])`.\n\
    <|/ c |>\n<| c |>\nIt doesn't work. Try it with `unique_digits([1,5,3,7,2,4,6,8,0])`.\n\
    <|/ c |>\n<| c |>\nIt doesn't work. Try it with `unique_digits([1,5,3,7,2,4,6,8,0])`.\n\
    <|/ c |>\n<| c |>\nIt doesn't work. Try it with `unique_digits([1,5,3,7,2,4,6,8,0])`.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  x.sort!\n  result = []\n  x.each do |i|\n\
    \    result << i if i.to_s.chars.uniq.count == 1\n  end\n  result\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`. It returns\
    \ `[1,2,3]` instead of `[2,3]`.\n<|/ c |>\n<| c |>\n: I see what you mean. Fixed\
    \ it.\n<|/ c |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3]`. It returns\
    \ `[1,2,3]` instead of `[2,3]`.\n<|/ c |>\n<| c |>\n: I see what you mean. Fixed\
    \ it.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i unless i.to_s.chars.uniq.count % 2 == 0\n  end\n  result\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work. Try it with `[1,2,3,4,5,6,7,8,9,0]`.\n\
    <|/ c |>\n<| c |>\nI tested it on ruby 2.1.0 and it works. I guess you tested\
    \ it on ruby 1.9.3 or something else.\n<|/ c |>\n<| c |>\nI tested it on ruby\
    \ 1.9.3p448 and it works. I guess you tested it on ruby 2.1.0 or something else.\n\
    <|/ c |>\n<| c |>\nI tested it on ruby 1.9.3p448 and it works. I guess you tested\
    \ it on ruby 2.1.0 or something else.\n<|/ c |>\n<| c |>\nI tested it on ruby\
    \ 2.1.0 and it works. I guess you tested it on ruby 1.9.3 or something else.\n\
    <|/ c |>\n<| a tags=ruby,arrays,sorting |>\n<code>", "  x.sort.uniq \nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i if i.to_s.chars.uniq.count > 1\n  end\n  result\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", "  x.sort!\n  result =\
    \ []\n  x.each do |i|\n    result << i unless i.to_s.chars.map(&:to_i).uniq.size\
    \ == 1\n  end\n  result\nend\n</code>\n<|/ a tags=ruby,arrays,algorithm |>\n<|\
    \ c |>\nI like your solution, but I believe it can be improved. For example, `unique_digits([1,\
    \ 2, 3, 1])` returns `[2, 3, 1]`, which is not sorted.\n<|/ c |>\n<| c |>\nYes,\
    \ you are right. I didn't notice that requirement. Thanks for pointing out.\n\
    <|/ c |>\n<| c |>\nI believe this solution is O(n^2) because of the `uniq` call.\
    \ `uniq` makes the algorithm O(n^2) because of the sort.\n<|/ c |>\n<| c |>\n\
    Yes, you are right. Thanks for pointing out. I updated my answer.\n<|/ c |>\n\
    <| a tags=ruby,arrays,algorithm |>\n<code>", "  x.sort!\n  result = []\n  x.each\
    \ do |i|\n    result << i if i.to_s.chars.uniq.count != 0\n  end\n  result\nend\n\
    </code>\n<|/ a tags=ruby,algorithm |>\n<| a dscore=0 |>\n<code>", "  x.sort!\n\
    \  x.uniq!\n  x\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
