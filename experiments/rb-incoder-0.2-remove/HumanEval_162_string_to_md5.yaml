name: HumanEval_162_string_to_md5
language: rb
prompt: "# Given a string 'text', return its md5 hash equivalent string.\n# If 'text'\
  \ is an empty string, return None.\ndef string_to_md5(text)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_to_md5\n\
  \    candidate = method(:string_to_md5)\n    assert_equal(\"3e25960a79dbc69b674cd4ec67a72c62\"\
  , candidate.call(\"Hello world\"))\n    assert_equal(nil, candidate.call(\"\"))\n\
  \    assert_equal(\"0ef78513b0cb8cef12743f5aeb35f888\", candidate.call(\"A B C\"\
  ))\n    assert_equal(\"5f4dcc3b5aa765d61d8327deb882cf99\", candidate.call(\"password\"\
  ))\n  end\nend\n"
completions: ["  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", " \
    \ begin\n    require 'digest/md5'\n  rescue LoadError\n    return nil\n  end\n\
    \  Digest::MD5.hexdigest(text)\nend", "  text = text.to_s\n  return Digest::MD5.hexdigest(text)\
    \ if text\nend", "  digest = Digest::MD5.digest(text)\n  digest.strip!\n  return\
    \ digest\nend", "  begin\n    require 'digest/md5'\n  rescue LoadError\n    require\
    \ 'openssl'\n  end", "  begin\n    require 'digest/md5'\n  rescue LoadError\n\
    \    require 'openssl'\n  end", "  digest = Digest::MD5.digest(text)\n  return\
    \ Digest::MD5.hexdigest(digest) if digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  return md5.digest\n\
    end", "  begin\n    require 'digest/md5'\n    Digest::MD5.hexdigest(text)\n  rescue\
    \ LoadError\n    nil\n  end\nend", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n\
    \  md5.digest\nend", "  return Digest::MD5.hexdigest(text) if text\nend", "  begin\n\
    \    require 'digest/md5'\n    Digest::MD5.hexdigest(text)\n  rescue LoadError\n\
    \    nil\n  end\nend", "  if text.empty?\n    return nil\n  end", "  return Digest::MD5.hexdigest(text)\
    \ if text\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  begin\n    require 'digest/md5'\n  rescue LoadError\n    require 'openssl'\n\
    \  end\n  if text.empty?\n    return nil\n  end\n  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  return md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  return\
    \ md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  digest = Digest::MD5.new\n  digest.update(text)\n  return digest.hexdigest\n\
    end", "  if text.empty?\n    return nil\n  end\n  Digest::MD5.hexdigest(text)\n\
    end", "  digest = Digest::MD5.hexdigest(text)\n  digest.empty? ? nil : digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  md5\
    \ = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text.to_s)\n  return md5.digest\nend", "  begin\n    require 'digest/md5'\n\
    \  rescue LoadError\n    return nil\n  end\n  Digest::MD5.hexdigest(text)\nend",
  "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  return Digest::MD5.hexdigest(text)\
    \ if text\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  return md5.digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  return\
    \ Digest::MD5.hexdigest(text) if text\nend", "  begin\n    require 'digest/md5'\n\
    \  rescue LoadError\n    require 'openssl'\n    require 'digest/sha1'\n    require\
    \ 'digest/sha224'\n    require 'digest/sha256'\n    require 'digest/sha384'\n\
    \    require 'digest/sha512'\n    require 'digest/md5'\n  end\n  digest = Digest::MD5.new\n\
    \  digest.update(text)\n  digest.hexdigest\nend", "  md5 = Digest::MD5.new\n \
    \ md5.update(text)\n  md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  md5.digest\nend", "  begin\n    require 'digest/md5'\n    Digest::MD5.hexdigest(text)\n\
    \  rescue LoadError\n    nil\n  end\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  digest = md5.digest\n  digest.strip!\n  digest\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n\
    \  md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n  md5.digest\nend", " \
    \ md5 = Digest::MD5.new\n  md5.update(text)\n  return md5.digest\nend", "  md5\
    \ = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  text = text.to_s\n\
    \  return Digest::MD5.hexdigest(text) if text\nend", "  text = text.to_s\n  return\
    \ Digest::MD5.hexdigest(text) if text\nend", "  text.to_s.gsub(/\\s+/, \"\").scan(/\\\
    w{32}/).join\nend", "  if text.empty?\n    return nil\n  end\n  Digest::MD5.hexdigest(text)\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  return md5.digest\nend",
  "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n  digest\nend", " \
    \ digest = Digest::MD5.hexdigest(text)\n  digest.blank? ? nil : digest\nend",
  "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  digest = Digest::MD5.digest(text)\n\
    \  digest.strip! if digest\n  digest\nend", "  text = text.to_s\n  return text\
    \ if text.present? and text.size > 0 else None\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n  return digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n\
    \  digest\nend", "  digest = Digest::MD5.digest(text)\n  return nil if digest.nil?\n\
    \  digest.unpack('H*').first\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  md5.digest\nend", "  text = text.to_s\n  return nil if text.empty?\n  Digest::MD5.hexdigest(text)\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  return\
    \ Digest::MD5.hexdigest(text) if text\nend", "  digest = Digest::MD5.digest(text)\n\
    \  return Digest::MD5.hexdigest(digest) if digest\nend", "  digest = Digest::MD5.digest(text)\n\
    \  digest.strip! if digest\n  digest\nend", "  return Digest::MD5.hexdigest(text)\
    \ if text\nend", "  begin\n    require 'digest/md5'\n    Digest::MD5.hexdigest(text)\n\
    \  rescue LoadError\n    nil\n  end\nend", "  begin\n    require 'digest/md5'\n\
    \    Digest::MD5.hexdigest(text)\n  rescue LoadError\n    nil\n  end\nend", " \
    \ begin\n    require 'digest/md5'\n  rescue LoadError\n    return nil\n  end\n\
    \  Digest::MD5.hexdigest(text)\nend", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n\
    \  md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  text.to_s.gsub!(/\\n/, '')\n  text.to_s.gsub!(/\\t/, '')\n  text.to_s.gsub!(/\\\
    r?\\n/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\s+/, '')\n  text.to_s.gsub!(/\\\
    s+/, '')\n  text.to_s.gsub", "  text.to_s.gsub!(/[^0-9a-f]/, '') if text\n  text.to_s.gsub!(/[a-f0-9]/)\
    \ { |x| x[/[a-f0-9]/].hex.chr }\n  text.to_s.gsub!(/[a-f0-9]{32}/) { |x| Digest::MD5.hexdigest(x)\
    \ }\n  text.to_s.gsub!(/[a-f0-9]{64}/) { |x| Digest::MD5.hexdigest(x) }\n  text.to_s.gsub!(/[a-f0-9]{128}/)\
    \ { |x| Digest::MD5.hexdigest(x) }\n  text.to_s.gsub!(/[a-f0-9]{256}/) { |x| Digest::MD5.hexdigest(x)\
    \ }\n  text.to_s.gsub!(/[a-f0-9]{512}/) { |x| Digest::MD5.hexdigest(x) }\n  text.to_s.gsub!(/[a-f0-9]{1024}/)\
    \ { |x| Digest::MD5.hexdigest(x) }\n  text.to_s.gsub!(/[a-f0-9]{2048}/) { |x|\
    \ Digest::MD5.hexdigest(x) }\n  text.to_s.gsub!(/[a-f0-9]{4096}/) { |x| Digest::MD5.hexdigest(x)\
    \ }\n  text.to_s.gsub!(/[a-f0-9]{8192}/) { |x| Digest::MD5.hexdigest(x) }\n  text.to_s.gsub!(/[a-f0-9]{16384}/)\
    \ { |x| Digest::MD5.hexdigest(x) }\n  text.to_s.gsub!(/[a-f0-9]{32768}/) { |x|\
    \ Digest::MD5.hexdigest(x) }\n  text.to_s.gsub!(/[a-f0-9]{65536}/) { |x| Digest::MD5.hexdigest(x)\
    \ }\n  text.to_s.gsub!(/[a-f0-9]{131072}/) { |x| Digest::MD5.hexdigest(x) }\n\
    \  text.to_s.gsub!(/[a-f0-9]{262144}/) { |x| Digest::MD5.hexdigest(x) }\n  text.to_s.gsub!(/[a-f0-9]{524288}/)\
    \ { |x| Digest::MD5.hexdigest(x) }\n  text.to_s.gsub!(/[a-f0-9]{1048576}/) { |x|\
    \ Digest::MD5.hexdigest(x) }\n  text.to_s.gsub!(", "  md5 = Digest::MD5.new\n\
    \  md5.update(text.to_s)\n  md5.digest\nend", "  begin\n    require 'digest/md5'\n\
    \  rescue LoadError\n    return nil\n  end\n  Digest::MD5.hexdigest(text)\nend",
  "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  digest = Digest::MD5.digest(text)\n\
    \  digest.strip! if digest.respond_to?(:strip)\n  digest\nend", "  digest = Digest::MD5.digest(text)\n\
    \  digest.strip!\n  return digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  return md5.digest\nend", "  text = text.to_s\n  return nil if text.empty?\n\
    \  Digest::MD5.hexdigest(text)\nend", "  text = text.to_s\n  return Digest::MD5.hexdigest(text)\
    \ if text\nend", "  text.to_s.gsub!(/\\s+/, \"\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \"\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \"_\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \"-\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \".\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \"_\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \"-\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \".\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \"_\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \"-\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \".\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \"_\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \"-\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \".\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \"_\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \"-\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \".\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \"_\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \"-\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \".\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \"_\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \"-\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \".\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \"_\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \"-\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \".\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/, \"_\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/,\
    \ \"-\") if text\n  text.to_s.gsub!(/[^a-zA-Z0-9]/", "  begin\n    require 'digest/md5'\n\
    \  rescue LoadError\n    return nil\n  end\n  Digest::MD5.hexdigest(text)\nend",
  "  if text.empty?\n    return nil\n  else\n    Digest::MD5.hexdigest(text)\n  end\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n  md5.digest\nend", " \
    \ if text.empty?\n    return nil\n  end\n  require 'digest/md5'\n  Digest::MD5.hexdigest(text)\n\
    end", "  if text.empty?\n    return nil\n  else\n    Digest::MD5.hexdigest(text)\n\
    \  end\nend", "  begin\n    require 'digest/md5'\n  rescue LoadError\n    return\
    \ nil\n  end\n  Digest::MD5.hexdigest(text)\nend", "  text.to_s.gsub(/[^0-9a-f]/,\
    \ '').tr('a-f', '0-9').unpack('H*').first\nend", "  begin\n    require 'digest/md5'\n\
    \  rescue LoadError\n    require 'openssl'\n  end", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  md5.digest\nend", "  return Digest::MD5.hexdigest(text)\
    \ if text\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  text.to_s.gsub!(/[^0-9a-f]/, '').to_s.gsub!(/[a-f]/) { |s| s.hex.chr\
    \ }\n  Digest::MD5.hexdigest(text)\nend", "  begin\n    require 'digest/md5'\n\
    \  rescue LoadError\n    require 'openssl'\n    require 'digest/md5'\n  end\n\
    \  begin\n    Digest::MD5.hexdigest(text)\n  rescue ArgumentError\n    begin\n\
    \      OpenSSL::Digest::MD5.hexdigest(text)\n    rescue LoadError\n      nil\n\
    \    end\n  end\nend", "  text = text.to_s\n  return nil if text.empty?\n  Digest::MD5.hexdigest(text)\n\
    end", "  text = text.to_s\n  return Digest::MD5.hexdigest(text) if text\nend",
  "  return Digest::MD5.hexdigest(text) if text\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  return md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  return md5.digest\nend", "  begin\n    require 'digest/md5'\n  rescue LoadError\n\
    \    require 'openssl'\n  end\n  begin\n    Digest::MD5.hexdigest(text)\n  rescue\
    \ ArgumentError\n    begin\n      OpenSSL::Digest::MD5.hexdigest(text)\n    rescue\
    \ LoadError\n      nil\n    end\n  end\nend", "  text = text.to_s\n  return nil\
    \ if text.empty?\n  Digest::MD5.hexdigest(text)\nend", "  digest = Digest::MD5.hexdigest(text)\n\
    \  digest.blank? ? nil : digest\nend", "  return Digest::MD5.hexdigest(text) if\
    \ text\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  return md5.digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  return md5.digest\nend",
  "  return Digest::MD5.hexdigest(text) if text\nend", "  begin\n    require 'digest/md5'\n\
    \    Digest::MD5.hexdigest(text)\n  rescue LoadError\n    nil\n  end\nend", " \
    \ digest = Digest::MD5.digest(text)\n  return nil if digest.nil? || digest.empty?\n\
    \  digest\nend", "  digest = Digest::MD5.digest(text)\n  return nil if digest.nil?\n\
    \  digest.unpack('H*').first\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  return md5.digest\nend",
  "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  return Digest::MD5.hexdigest(text)\
    \ if text\nend", "  digest = Digest::MD5.digest(text)\n  return nil if digest.nil?\n\
    \  digest.unpack('H*').first\nend", "  return Digest::MD5.hexdigest(text)\nend",
  "  digest = Digest::MD5.digest(text)\n  return nil if digest.nil?\n  digest.unpack('H*').first\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  digest\
    \ = Digest::MD5.digest(text)\n  return nil if digest.nil?\n  digest.unpack('H*').first\n\
    end", "  text.to_s.md5\nend", "  digest = Digest::MD5.digest(text)\n  return nil\
    \ if digest.nil?\n  digest.unpack('H*').first\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text.to_s)\n  md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  md5.digest\nend", "  return Digest::MD5.hexdigest(text) if text\nend", "  digest\
    \ = Digest::MD5.digest(text)\n  return nil if digest.nil?\n  digest.unpack('H*').first\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  begin\n\
    \    require 'digest/md5'\n    Digest::MD5.hexdigest(text)\n  rescue LoadError\n\
    \    nil\n  end\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  if text.empty?\n    return nil\n  end\n  Digest::MD5.hexdigest(text)\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n  md5.digest\nend", " \
    \ md5 = Digest::MD5.new\n  md5.update(text.to_s)\n  return md5.digest\nend", " \
    \ begin\n    require 'digest/md5'\n  rescue LoadError\n    return nil\n  end\n\
    \  Digest::MD5.hexdigest(text)\nend", "  digest = Digest::MD5.digest(text)\n \
    \ return nil if digest.nil?\n  digest.unpack('H*').first\nend", "  digest = Digest::MD5.digest(text)\n\
    \  return nil if digest.nil? || digest.empty?\n  digest.unpack(\"H*\").first\n\
    end", "  begin\n    require 'digest/md5'\n  rescue LoadError\n    return nil\n\
    \  end\n  Digest::MD5.hexdigest(text)\nend", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n\
    \  md5.digest\nend", "  return Digest::MD5.hexdigest(text) if text\nend", "  begin\n\
    \    require 'digest/md5'\n  rescue LoadError\n    return nil\n  end\n  Digest::MD5.hexdigest(text)\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  md5\
    \ = Digest::MD5.new\n  md5.update(text.to_s)\n  return md5.digest\nend", "  md5\
    \ = Digest::MD5.new\n  md5.update(text.to_s)\n  md5.digest\nend", "  begin\n \
    \   require 'digest/md5'\n  rescue LoadError\n    require 'openssl'\n    require\
    \ 'digest/sha1'\n  end\n  begin\n    Digest::MD5.hexdigest(text)\n  rescue ArgumentError\n\
    \    begin\n      Digest::SHA1.hexdigest(text)\n    rescue ArgumentError\n   \
    \   nil\n    end\n  end\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest =\
    \ md5.digest\n  return digest.unpack(\"H*\").first\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  digest = md5.digest\n  return digest.unpack('H*')[0] if\
    \ digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend",
  "  digest = Digest::MD5.digest(text)\n  digest.strip! if digest.respond_to?(:strip)\n\
    \  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n\
    \  return digest.unpack(\"H*\").first\nend", "  digest = Digest::MD5.digest(text)\n\
    \  digest.strip!\n  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  md5.digest\nend", "  digest = Digest::MD5.digest(text)\n  digest.strip! if\
    \ digest\n  digest\nend", "  begin\n    require 'digest/md5'\n  rescue LoadError\n\
    \    return nil\n  end\n  Digest::MD5.hexdigest(text)\nend", "  begin\n    require\
    \ 'digest/md5'\n  rescue LoadError\n    return nil\n  end\n  Digest::MD5.hexdigest(text)\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n  md5.digest\nend", " \
    \ md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  digest = Digest::MD5.digest(text)\n\
    \  return nil if digest.empty?\n  digest\nend", "  begin\n    require 'digest/md5'\n\
    \  rescue LoadError\n    require 'openssl'\n  end", "  digest = Digest::MD5.new\n\
    \  digest.update(text)\n  digest.hexdigest\nend", "  md5 = Digest::MD5.new\n \
    \ md5.update(text.to_s)\n  md5.digest\nend", "  begin\n    require 'digest/md5'\n\
    \  rescue LoadError\n    return nil\n  end\n  Digest::MD5.hexdigest(text)\nend",
  "  digest = Digest::MD5.digest(text)\n  digest.strip!\n  digest\nend", "  md5 =\
    \ Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  return digest.unpack('H*')[0]\
    \ if digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  return Digest::MD5.hexdigest(text) if text\nend", "  begin\n    require\
    \ 'digest/md5'\n    Digest::MD5.hexdigest(text)\n  rescue LoadError\n    begin\n\
    \      require 'openssl'\n      OpenSSL::Digest::MD5.hexdigest(text)\n    rescue\
    \ LoadError\n      nil\n    end\n  end\nend", "  text = text.to_s\n  return Digest::MD5.hexdigest(text)\
    \ if text\nend", "  if text.empty?\n    \"\"\n  else\n    Digest::MD5.hexdigest(text)\n\
    \  end\nend", "  text = text.to_s\n  return text if text.empty?\n  Digest::MD5.hexdigest(text)\n\
    end", "  return Digest::MD5.hexdigest(text)\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  digest = md5.digest\n  return digest.unpack(\"H*\").first\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text.to_s)\n  md5.digest\nend", " \
    \ text.to_s.gsub(/\\s+/, \"\").scan(/\\w{32}/).join\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text.to_s)\n  return md5.digest\nend", "  begin\n    require 'digest/md5'\n\
    \  rescue LoadError\n    return nil\n  end\n  Digest::MD5.hexdigest(text)\nend",
  "  md5 = Digest::MD5.new\n  md5.update(text)\n  return md5.digest\nend", "  md5\
    \ = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  if text.empty?\n\
    \    return nil\n  end\n  Digest::MD5.hexdigest(text)\nend", "  return Digest::MD5.hexdigest(text)\
    \ if text\nend", "  text = text.to_s\n  return text if text.empty? or text.start_with?('md5sum:')\n\
    \  text = text.split(' ')[0]\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/md5sum:/,\
    \ '')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\s+/, ' ')\n  text.gsub!(/\\\
    s+/, ' ')", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n\
    \  digest.strip!\n  return digest\nend", "  if text.nil?\n    return nil\n  else\n\
    \    require 'digest/md5'\n    Digest::MD5.hexdigest(text)\n  end\nend", "  text\
    \ = text.to_s\n  return nil if text.empty?\n  Digest::MD5.hexdigest(text)\nend",
  "  if text.empty?\n    return nil\n  end\n  Digest::MD5.hexdigest(text)\nend", " \
    \ text = text.to_s\n  return nil if text.empty?\n  Digest::MD5.hexdigest(text)\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  md5\
    \ = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  digest.strip!\n\
    \  return digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest\
    \ = md5.digest\n  return digest.unpack(\"H*\").first\nend", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  return md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  return md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest\
    \ = md5.digest\n  digest.strip!\n  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  return md5.digest\nend", "  digest = Digest::MD5.digest(text)\n  digest.strip!\
    \ if digest.respond_to?(:strip)\n  digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n\
    \  md5.digest\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\nend", "  return\
    \ Digest::MD5.hexdigest(text) if text\nend", "  begin\n    require 'digest/md5'\n\
    \  rescue LoadError\n    require 'openssl'\n  end", "  md5 = Digest::MD5.new\n\
    \  md5.update(text)\n  return md5.digest\nend", "  return Digest::MD5.hexdigest(text)\
    \ if text\nend", "  md5 = Digest::MD5.new\n  md5.update(text)\n  md5.digest\n\
    end", "  md5 = Digest::MD5.new\n  md5.update(text)\n  digest = md5.digest\n  return\
    \ digest.unpack(\"H*\").first\nend", "  digest = Digest::MD5.digest(text)\n  return\
    \ nil if digest.nil?\n  digest.unpack(\"H*\").first\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
