language: swift
name: HumanEval_12_longest
results:
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var maxLength = 0\n    var longestString: String?\n\
    \    for string in strings {\n        if string.characters.count > maxLength {\n\
    \            maxLength = string.characters.count\n            longestString =\
    \ string\n        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpcb5sn7_f.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > maxLength {\n    \
    \              ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpcb5sn7_f.swift:14:32: error: 'characters' is unavailable: Please\
    \ use String directly\n            maxLength = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.count > longestString!.count {\n\
    \            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n   \
    \ return strings.max(by: { $0.count < $1.count })!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n   \
    \ return strings.max { $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.count > longest!.count {\n          \
    \  longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8uow4a1e.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8uow4a1e.swift:15:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8uow4a1e.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8uow4a1e.swift:15:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    var longestLength\
    \ = 0\n    for string in strings {\n        if string.characters.count > longestLength\
    \ {\n            longestString = string\n            longestLength = string.characters.count\n\
    \        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4vrar_cz.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestLength {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp4vrar_cz.swift:15:36: error: 'characters' is unavailable: Please\
    \ use String directly\n            longestLength = string.characters.count\n \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    return strings.maxElement({ $0.characters.count\
    \ < $1.characters.count })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp2nwg5z0_.swift:10:20: error: value of type '[String]' has no member\
    \ 'maxElement'\n    return strings.maxElement({ $0.characters.count < $1.characters.count\
    \ })\n           ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    for string\
    \ in strings {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp9h2bnwpa.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp9h2bnwpa.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    return strings.maxElement()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpjvbcfgst.swift:10:20: error: value of type '[String]' has no member\
    \ 'maxElement'\n    return strings.maxElement()\n           ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    return strings.reduce(nil) { (longest, string) in\n\
    \        return longest == nil || string.count > longest!.count ? string : longest\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.count > longestString!.count {\n\
    \            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n   \
    \ var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.count > longestString!.count {\n\
    \            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    var longestLength\
    \ = 0\n    for string in strings {\n        if string.characters.count > longestLength\
    \ {\n            longestString = string\n            longestLength = string.characters.count\n\
    \        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4vrar_cz.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestLength {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp4vrar_cz.swift:15:36: error: 'characters' is unavailable: Please\
    \ use String directly\n            longestLength = string.characters.count\n \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    for string\
    \ in strings {\n        if longestString == nil || string.count > longestString!.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard let longest = strings.max(by: { $0.count <\
    \ $1.count }) else {\n        return nil\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    for string\
    \ in strings {\n        if longestString == nil || string.count > longestString!.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    return strings.reduce(nil) { (longest, string) in\n\
    \        if let longest = longest {\n            return string.count > longest.count\
    \ ? string : longest\n        } else {\n            return string\n        }\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(longest(strings: [] as\
    \ [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\n\
    assert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8uow4a1e.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8uow4a1e.swift:15:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest = \"\"\n    for string in strings {\n\
    \        if string.characters.count > longest.characters.count {\n           \
    \ longest = string\n        }\n    }\n    return longest.characters.count > 0\
    \ ? longest : nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpzouxu7fv.swift:12:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpzouxu7fv.swift:12:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpzouxu7fv.swift:16:20: error: 'characters'\
    \ is unavailable: Please use String directly\n    return longest.characters.count\
    \ > 0 ? longest : nil\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.count > longest!.count {\n          \
    \  longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard let first = strings.first else {\n       \
    \ return nil\n    }\n    return strings.reduce(first) {\n        return $1.count\
    \ > $0.count ? $1 : $0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.count > longest!.count {\n          \
    \  longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8uow4a1e.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8uow4a1e.swift:15:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard let first = strings.first else {\n       \
    \ return nil\n    }\n    return strings.reduce(first) { (longest, string) -> String\
    \ in\n        return string.count > longest.count ? string : longest\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    var longestLength\
    \ = 0\n    for string in strings {\n        if string.characters.count > longestLength\
    \ {\n            longestString = string\n            longestLength = string.characters.count\n\
    \        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4vrar_cz.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestLength {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp4vrar_cz.swift:15:36: error: 'characters' is unavailable: Please\
    \ use String directly\n            longestLength = string.characters.count\n \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || longest!.characters.count < string.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp_uarg5ji.swift:12:39: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || longest!.characters.count\
    \ < string.characters.count {\n                                      ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_uarg5ji.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || longest!.characters.count < string.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n   \
    \ var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.count > longestString!.count {\n\
    \            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8uow4a1e.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8uow4a1e.swift:15:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard let first = strings.first else {\n       \
    \ return nil\n    }\n    return strings.reduce(first) {\n        $0.count > $1.count\
    \ ? $0 : $1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpz_vrtqxa/tmpz_vrtqxa.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf23a11c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf23708b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf23708988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf237077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz_vrtqxa                        0x00005563667268fa <unavailable> + 6394

    5    libc.so.6                          0x00002abf23bfd460 __libc_start_main +
    245

    6    tmpz_vrtqxa                        0x00005563667261e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    for string\
    \ in strings {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp9h2bnwpa.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp9h2bnwpa.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    return strings.reduce(nil) { (longest, string) in\n\
    \        if let longest = longest {\n            return longest.characters.count\
    \ > string.characters.count ? longest : string\n        } else {\n           \
    \ return string\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpz5o3b8jp.swift:12:28: error: 'characters' is unavailable: Please\
    \ use String directly\n            return longest.characters.count > string.characters.count\
    \ ? longest : string\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpz5o3b8jp.swift:12:54: error: 'characters'\
    \ is unavailable: Please use String directly\n            return longest.characters.count\
    \ > string.characters.count ? longest : string\n                             \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    for string\
    \ in strings {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp9h2bnwpa.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp9h2bnwpa.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n   \
    \ var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.count > longest!.count {\n          \
    \  longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    return strings.maxElement { $0.characters.count\
    \ < $1.characters.count }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpoqagzod8.swift:10:20: error: value of type '[String]' has no member\
    \ 'maxElement'\n    return strings.maxElement { $0.characters.count < $1.characters.count\
    \ }\n           ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard let longest = strings.max(by: { $0.count <\
    \ $1.count }) else {\n        return nil\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    var longestLength\
    \ = 0\n    for string in strings {\n        if string.characters.count > longestLength\
    \ {\n            longestString = string\n            longestLength = string.characters.count\n\
    \        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4vrar_cz.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestLength {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp4vrar_cz.swift:15:36: error: 'characters' is unavailable: Please\
    \ use String directly\n            longestLength = string.characters.count\n \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    for string\
    \ in strings {\n        if let longestString = longestString {\n            if\
    \ string.count > longestString.count {\n                longestString = string\n\
    \            }\n        } else {\n            longestString = string\n       \
    \ }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8kilbzbx.swift:14:17: error: cannot assign to value: 'longestString'\
    \ is a 'let' constant\n                longestString = string\n              \
    \  ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard let first = strings.first else {\n       \
    \ return nil\n    }\n    return strings.reduce(first) {\n        $0.count > $1.count\
    \ ? $0 : $1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpz_vrtqxa/tmpz_vrtqxa.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf23a11c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf23708b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf23708988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf237077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz_vrtqxa                        0x00005563667268fa <unavailable> + 6394

    5    libc.so.6                          0x00002abf23bfd460 __libc_start_main +
    245

    6    tmpz_vrtqxa                        0x00005563667261e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8uow4a1e.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8uow4a1e.swift:15:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard let longest = strings.max(by: { $0.count <\
    \ $1.count }) else {\n        return nil\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    for string\
    \ in strings {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp9h2bnwpa.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp9h2bnwpa.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n   \
    \ var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    for string\
    \ in strings {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp9h2bnwpa.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp9h2bnwpa.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard let first = strings.first else {\n       \
    \ return nil\n    }\n    return strings.reduce(first) {\n        $0.count > $1.count\
    \ ? $0 : $1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpz_vrtqxa/tmpz_vrtqxa.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf23a11c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf23708b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf23708988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf237077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz_vrtqxa                        0x00005563667268fa <unavailable> + 6394

    5    libc.so.6                          0x00002abf23bfd460 __libc_start_main +
    245

    6    tmpz_vrtqxa                        0x00005563667261e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    return strings.reduce(nil) {\n        $0 == nil\
    \ || $0!.count < $1.count ? $1 : $0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n   \
    \ return strings.max { $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.count > longestString!.count {\n\
    \            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard !strings.isEmpty else { return nil }\n   \
    \ return strings.reduce(strings[0]) { $1.count > $0.count ? $1 : $0 }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    var longestLength\
    \ = 0\n    for string in strings {\n        if string.characters.count > longestLength\
    \ {\n            longestString = string\n            longestLength = string.characters.count\n\
    \        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4vrar_cz.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestLength {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp4vrar_cz.swift:15:36: error: 'characters' is unavailable: Please\
    \ use String directly\n            longestLength = string.characters.count\n \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8uow4a1e.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8uow4a1e.swift:15:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    for string\
    \ in strings {\n        if longestString == nil || string.count > longestString!.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    return strings.reduce(nil) { (longest, string) in\n\
    \        return longest == nil || string.characters.count > longest!.characters.count\
    \ ? string : longest\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp5o327ib4.swift:11:41: error: 'characters' is unavailable: Please\
    \ use String directly\n        return longest == nil || string.characters.count\
    \ > longest!.characters.count ? string : longest\n                           \
    \             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp5o327ib4.swift:11:69: error: 'characters' is unavailable: Please\
    \ use String directly\n        return longest == nil || string.characters.count\
    \ > longest!.characters.count ? string : longest\n                           \
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'tmp1fh0_nwp/tmp1fh0_nwp.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b955de67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b955db5eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b955db5e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b955db5d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1fh0_nwp                        0x000055e285bf779a <unavailable> + 6042

    5    libc.so.6                          0x00002b955e053460 __libc_start_main +
    245

    6    tmp1fh0_nwp                        0x000055e285bf7089 <unavailable> + 4233

    '
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard strings.count > 0 else {\n        return nil\n\
    \    }\n    return strings.max { $0.count < $1.count }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    return strings.maxElement { $0.characters.count\
    \ < $1.characters.count }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpoqagzod8.swift:10:20: error: value of type '[String]' has no member\
    \ 'maxElement'\n    return strings.maxElement { $0.characters.count < $1.characters.count\
    \ }\n           ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8uow4a1e.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8uow4a1e.swift:15:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.count > longest!.count {\n          \
    \  longest = string\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.count > longestString!.count {\n\
    \            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard let first = strings.first else {\n       \
    \ return nil\n    }\n    return strings.reduce(first) { $1.count > $0.count ?\
    \ $1 : $0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest = \"\"\n    for string in strings {\n\
    \        if string.characters.count > longest.characters.count {\n           \
    \ longest = string\n        }\n    }\n    return longest.characters.count > 0\
    \ ? longest : nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpzouxu7fv.swift:12:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpzouxu7fv.swift:12:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpzouxu7fv.swift:16:20: error: 'characters'\
    \ is unavailable: Please use String directly\n    return longest.characters.count\
    \ > 0 ? longest : nil\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longestString.characters.count {\n            longestString = string\n   \
    \     }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp8uow4a1e.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8uow4a1e.swift:15:52: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestString.characters.count\
    \ {\n                                                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.characters.count > longestString!.characters.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpnm_qwkub.swift:12:43: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longestString == nil || string.characters.count\
    \ > longestString!.characters.count {\n                                      \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpnm_qwkub.swift:12:77:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \                                                                        ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.count > longestString!.count {\n\
    \            longestString = string\n        }\n    }\n    return longestString\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longestString: String? = nil\n    var longestLength\
    \ = 0\n    for string in strings {\n        if string.characters.count > longestLength\
    \ {\n            longestString = string\n            longestLength = string.characters.count\n\
    \        }\n    }\n    return longestString\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmp4vrar_cz.swift:13:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longestLength {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp4vrar_cz.swift:15:36: error: 'characters' is unavailable: Please\
    \ use String directly\n            longestLength = string.characters.count\n \
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    guard let first = strings.first else {\n       \
    \ return nil\n    }\n    return strings.reduce(first) {\n        $0.count > $1.count\
    \ ? $0 : $1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: Exception
  stderr: 'tmpz_vrtqxa/tmpz_vrtqxa.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abf23a11c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abf23708b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abf23708988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abf237077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz_vrtqxa                        0x00005563667268fa <unavailable> + 6394

    5    libc.so.6                          0x00002abf23bfd460 __libc_start_main +
    245

    6    tmpz_vrtqxa                        0x00005563667261e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || string.characters.count > longest!.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpgajt3kal.swift:12:37: error: 'characters' is unavailable: Please\
    \ use String directly\n        if longest == nil || string.characters.count >\
    \ longest!.characters.count {\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpgajt3kal.swift:12:65:\
    \ error: 'characters' is unavailable: Please use String directly\n        if longest\
    \ == nil || string.characters.count > longest!.characters.count {\n          \
    \                                                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > longest.characters.count {\n            longest = string\n        }\n    }\n\
    \    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: SyntaxError
  stderr: "/tmp/tmpmn7rqan_.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpmn7rqan_.swift:15:46: error: 'characters' is unavailable: Please\
    \ use String directly\n        if string.characters.count > longest.characters.count\
    \ {\n                                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
