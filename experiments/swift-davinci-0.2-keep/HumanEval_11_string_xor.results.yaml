language: swift
name: HumanEval_11_string_xor
results:
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n \
    \   return xor_bytes.map { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { $0 - 48 }\n    let b = b.utf8.map { $0\
    \ - 48 }\n    let c = zip(a, b).map { $0 ^ $1 }\n    return String(c.map { $0\
    \ + 48 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp7yswodsw.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(c.map { $0 + 48 })\n           ^\nSwift.String:4:12: note:\
    \ candidate requires that the types 'UInt8' and 'Character' be equivalent (requirement\
    \ specified as 'S.Element' == 'Character')\n    public init<S>(_ characters: S)\
    \ where S : Sequence, S.Element == Character\n           ^\nSwift.RangeReplaceableCollection:3:23:\
    \ note: candidate requires that the types 'String.Element' (aka 'Character') and\
    \ 'UInt8' be equivalent (requirement specified as 'Self.Element' == 'S.Element')\n\
    \    @inlinable public init<S>(_ elements: S) where S : Sequence, Self.Element\
    \ == S.Element\n                      ^\nSwift.String:7:23: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(cString:)')\n    @inlinable public\
    \ init(cString nullTerminatedUTF8: [UInt8])\n                      ^\nSwift.String:2:12:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n\
    \    public init<Subject>(describing instance: Subject)\n           ^\nSwift.String:3:23:\
    \ note: incorrect labels for candidate (have: '(_:)', expected: '(describing:)')\n\
    \    @inlinable public init<Subject>(describing instance: Subject) where Subject\
    \ : CustomStringConvertible\n                      ^\nSwift.String:6:12: note:\
    \ incorrect labels for candidate (have: '(_:)', expected: '(reflecting:)')\n \
    \   public init<Subject>(reflecting subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let aa = a.utf8.map { Int($0) }\n    let bb = b.utf8.map {\
    \ Int($0) }\n    let cc = zip(aa, bb).map { $0 ^ $1 }\n    return String(bytes:\
    \ cc, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpwn11wkwi.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: cc, encoding: .utf8)!\n           ^\n/tmp/tmpwn11wkwi.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ cc, encoding: .utf8)!\n           ^\n/tmp/tmpwn11wkwi.swift:10:12: note: found\
    \ candidate with type '([Int]) -> String'\n    return String(bytes: cc, encoding:\
    \ .utf8)!\n           ^\n/tmp/tmpwn11wkwi.swift:10:12: note: found candidate with\
    \ type '(Substring.UTF8View) -> String?'\n    return String(bytes: cc, encoding:\
    \ .utf8)!\n           ^\n/tmp/tmpwn11wkwi.swift:10:12: note: found candidate with\
    \ type '(Substring.UTF16View) -> String?'\n    return String(bytes: cc, encoding:\
    \ .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for (i, j) in zip(a, b) {\n        result\
    \ += String(i ^ j)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpccet0qkp.swift:9:28: error: binary operator '^' cannot be applied\
    \ to two 'String.Element' (aka 'Character') operands\n        result += String(i\
    \ ^ j)\n                         ~ ^ ~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n \
    \   return String(bytes: xor_bytes, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_p2o5j3w.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmp_p2o5j3w.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmp_p2o5j3w.swift:10:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp_p2o5j3w.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp_p2o5j3w.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    var result = \"\"\n    for i in 0..<a_bytes.count {\n   \
    \     result += String(a_bytes[i] ^ b_bytes[i])\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let result = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n    return\
    \ result.map { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return\
    \ result.reduce(\"\") { $0 + String(format: \"%02x\", $1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpz93z8xfj.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpz93z8xfj.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmpz93z8xfj.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n   \
    \ let xor_bytes_str = xor_bytes.map { String($0, radix: 2) }\n    return xor_bytes_str.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpk6kc0_wx.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpk6kc0_wx.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpk6kc0_wx.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        result.append(a_char == b_char ? \"0\" : \"1\")\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpqovf9wz4.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpqovf9wz4.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpqovf9wz4.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return\
    \ result.reduce(\"\") { $0 + String(format: \"%02x\", $1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpz93z8xfj.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpz93z8xfj.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmpz93z8xfj.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n \
    \   return String(bytes: xor_bytes, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_p2o5j3w.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmp_p2o5j3w.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmp_p2o5j3w.swift:10:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp_p2o5j3w.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp_p2o5j3w.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        let a_int = Int(String(a_char))!\n        let b_int =\
    \ Int(String(b_char))!\n        let xor = a_int ^ b_int\n        result += String(xor)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        let a_int = Int(String(a_char))!\n        let b_int = Int(String(b_char))!\n\
    \        let result_int = a_int ^ b_int\n        result += String(result_int)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmplxlq70vp.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmplxlq70vp.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmplxlq70vp.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        let a_int = Int(String(a_char))!\n        let b_int =\
    \ Int(String(b_char))!\n        result += String(a_int ^ b_int)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return\
    \ result.reduce(\"\") { $0 + String(format: \"%02x\", $1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpz93z8xfj.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpz93z8xfj.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmpz93z8xfj.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    let result = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n    return\
    \ String(bytes: result, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpqrtt7d02.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: result, encoding: .utf8)!\n           ^\n/tmp/tmpqrtt7d02.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ result, encoding: .utf8)!\n           ^\n/tmp/tmpqrtt7d02.swift:10:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpqrtt7d02.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpqrtt7d02.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n   \
    \ return String(bytes: xor_bytes, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpbgqh48j3.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpbgqh48j3.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpbgqh48j3.swift:10:12: note:\
    \ found candidate with type '([Int]) -> String'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpbgqh48j3.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpbgqh48j3.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ aChar = a[a.index(a.startIndex, offsetBy: i)]\n        let bChar = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if aChar == bChar {\n            result += \"0\"\n  \
    \      } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var res = \"\"\n    for i in 0..<a.count {\n        let a_char\
    \ = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            res += \"0\"\n   \
    \     } else {\n            res += \"1\"\n        }\n    }\n    return res\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n   \
    \ return String(bytes: xor_bytes, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpbgqh48j3.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpbgqh48j3.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpbgqh48j3.swift:10:12: note:\
    \ found candidate with type '([Int]) -> String'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpbgqh48j3.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpbgqh48j3.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    let result = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n    return\
    \ result.map { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n   \
    \ return xor_bytes.map { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ ai = a[i]\n        let bi = b[i]\n        let ri = ai ^ bi\n        result.append(ri)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpzy5ppjzj.swift:9:18: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let ai =\
    \ a[i]\n                 ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpzy5ppjzj.swift:10:18: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let bi = b[i]\n                 ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpzy5ppjzj.swift:11:21: error: binary\
    \ operator '^' cannot be applied to two 'Character' operands\n        let ri =\
    \ ai ^ bi\n                 ~~ ^ ~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return\
    \ result.reduce(\"\") { $0 + String(format: \"%02x\", $1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpz93z8xfj.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpz93z8xfj.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmpz93z8xfj.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n   \
    \ return xor_bytes.map { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for (i, j) in zip(a, b) {\n        result\
    \ += String(Int(String(i))! ^ Int(String(j))!)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    let c = zip(a, b).map { $0 ^ $1 }\n    return String(c.map\
    \ { Character(UnicodeScalar($0 + 48)) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpkip6qx06.swift:10:37: error: value of optional type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n    return String(c.map { Character(UnicodeScalar($0\
    \ + 48)) })\n                                    ^\n/tmp/tmpkip6qx06.swift:10:37:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return String(c.map { Character(UnicodeScalar($0 + 48)) })\n    \
    \                                ^\n                                         \
    \                  ?? <#default value#>\n/tmp/tmpkip6qx06.swift:10:37: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ String(c.map { Character(UnicodeScalar($0 + 48)) })\n                      \
    \              ^\n                                                          !\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for (i, j) in zip(a, b) {\n        result\
    \ += String(Int(String(i))! ^ Int(String(j))!)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        let a_int = Int(String(a_char))!\n        let b_int =\
    \ Int(String(b_char))!\n        let xor = a_int ^ b_int\n        result.append(String(xor))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    var res = [Int]()\n    for i in 0..<a.count {\n      \
    \  res.append(a[i] ^ b[i])\n    }\n    return res.map { String($0) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpk6kc0_wx.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpk6kc0_wx.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpk6kc0_wx.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        let a_int = Int(String(a_char))!\n        let b_int =\
    \ Int(String(b_char))!\n        result += String(a_int ^ b_int)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n \
    \   return xor_bytes.map { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    return zip(a, b).map { $0 ^ $1 }.map { String($0) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    var result = [Int]()\n    for i in 0..<a.count {\n   \
    \     result.append(a[i] ^ b[i])\n    }\n    return result.map { String($0) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for (index, char) in a.characters.enumerated()\
    \ {\n        if char == \"0\" {\n            result.append(b[index])\n       \
    \ } else {\n            result.append(b[index] == \"0\" ? \"1\" : \"0\")\n   \
    \     }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpewop3rfq.swift:8:28: error: 'characters' is unavailable: Please\
    \ use String directly\n    for (index, char) in a.characters.enumerated() {\n\
    \                           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpewop3rfq.swift:10:27: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   result.append(b[index])\n                          ^~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpewop3rfq.swift:12:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            result.append(b[index] == \"0\" ? \"\
    1\" : \"0\")\n                          ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n \
    \   return xor_bytes.map { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { $0 }\n    let b_bytes = b.utf8.map\
    \ { $0 }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n    return\
    \ String(bytes: xor_bytes, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmph5gq0fiz.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmph5gq0fiz.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmph5gq0fiz.swift:10:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmph5gq0fiz.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmph5gq0fiz.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    return String(zip(a, b).map(^))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpl70hu94f.swift:7:33: error: no exact matches in reference to operator\
    \ function '^'\n    return String(zip(a, b).map(^))\n                        \
    \        ^\nSwift.BinaryInteger:1:17: note: candidate requires that 'String.Element'\
    \ (aka 'Character') conform to 'BinaryInteger' (requirement specified as 'Self'\
    \ : 'BinaryInteger')\npublic protocol BinaryInteger : CustomStringConvertible,\
    \ Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude\
    \ == Self.Magnitude.Magnitude {\n                ^\nSwift.BinaryInteger:1:11:\
    \ note: candidate requires that 'String.Element' (aka 'Character') conform to\
    \ 'BinaryInteger' (requirement specified as 'Self' : 'BinaryInteger')\nextension\
    \ BinaryInteger {\n          ^\nSwift.SIMD:1:11: note: candidate requires that\
    \ 'String.Element' (aka 'Character') conform to 'SIMD' (requirement specified\
    \ as 'Self' : 'SIMD')\nextension SIMD where Self.Scalar : FixedWidthInteger {\n\
    \          ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return result.map\
    \ { String($0) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824361
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    let c = zip(a, b).map { $0 ^ $1 }\n    return String(c.map\
    \ { Character(UnicodeScalar($0 + 48)) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpkip6qx06.swift:10:37: error: value of optional type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n    return String(c.map { Character(UnicodeScalar($0\
    \ + 48)) })\n                                    ^\n/tmp/tmpkip6qx06.swift:10:37:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return String(c.map { Character(UnicodeScalar($0 + 48)) })\n    \
    \                                ^\n                                         \
    \                  ?? <#default value#>\n/tmp/tmpkip6qx06.swift:10:37: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ String(c.map { Character(UnicodeScalar($0 + 48)) })\n                      \
    \              ^\n                                                          !\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return\
    \ result.reduce(\"\") { $0 + String(UnicodeScalar(UInt8(bitPattern: $1))) }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp8x965t07.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp8x965t07.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        let a_int = Int(String(a_char))!\n        let b_int =\
    \ Int(String(b_char))!\n        let xor = a_int ^ b_int\n        result.append(String(xor))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n   \
    \ return xor_bytes.reduce(\"\") { $0 + String(UnicodeScalar($1)) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp4hx10eln.swift:10:40: error: no exact matches in call to initializer\
    \ \n    return xor_bytes.reduce(\"\") { $0 + String(UnicodeScalar($1)) }\n   \
    \                                    ^\nSwift.String:3:23: note: found candidate\
    \ with type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>')\n    @inlinable\
    \ public init(_ scalar: Unicode.Scalar)\n                      ^\nSwift.String:4:23:\
    \ note: found candidate with type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>')\n\
    \    @inlinable public init<T>(_ value: T) where T : LosslessStringConvertible\n\
    \                      ^\nSwift.String:2:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:6:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return\
    \ result.reduce(\"\") { $0 + String(UnicodeScalar(UInt8(bitPattern: $1))) }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp8x965t07.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp8x965t07.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ charA = a[a.index(a.startIndex, offsetBy: i)]\n        let charB = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if charA == charB {\n            result += \"0\"\n  \
    \      } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824361
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return result.map\
    \ { String($0) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824361
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map { UInt8(bitPattern:\
    \ $0) ^ UInt8(bitPattern: $1) }\n    return result.reduce(\"\") { $0 + String(UnicodeScalar(UInt8(bitPattern:\
    \ $1))) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp29fb468h.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp29fb468h.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmp29fb468h.swift:9:32: error: cannot convert value of type '(Int8,\
    \ Int8) -> UInt8' to expected argument type '(Zip2Sequence<_, _>.Element) throws\
    \ -> UInt8'\n    let result = zip(a, b).map { UInt8(bitPattern: $0) ^ UInt8(bitPattern:\
    \ $1) }\n                               ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for (index, element) in a.enumerated()\
    \ {\n        if element == b[b.index(b.startIndex, offsetBy: index)] {\n     \
    \       result += \"0\"\n        } else {\n            result += \"1\"\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824361
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    var result = [UInt8]()\n    for i in 0..<a_bytes.count {\n\
    \        result.append(a_bytes[i] ^ b_bytes[i])\n    }\n    return String(bytes:\
    \ result, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp6bz16_jv.swift:13:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: result, encoding: .utf8)!\n           ^\n/tmp/tmp6bz16_jv.swift:13:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ result, encoding: .utf8)!\n           ^\n/tmp/tmp6bz16_jv.swift:13:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp6bz16_jv.swift:13:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp6bz16_jv.swift:13:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        result += String(a_char == b_char ? \"0\" : \"1\")\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824361
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let aa = Array(a.utf8)\n    let bb = Array(b.utf8)\n    var\
    \ cc = [UInt8]()\n    for i in 0..<aa.count {\n        cc.append(aa[i] ^ bb[i])\n\
    \    }\n    return String(bytes: cc, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp4ut5vbhn.swift:13:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: cc, encoding: .utf8)!\n           ^\n/tmp/tmp4ut5vbhn.swift:13:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ cc, encoding: .utf8)!\n           ^\n/tmp/tmp4ut5vbhn.swift:13:12: note: found\
    \ candidate with type '([UInt8]) -> String'\n    return String(bytes: cc, encoding:\
    \ .utf8)!\n           ^\n/tmp/tmp4ut5vbhn.swift:13:12: note: found candidate with\
    \ type '(Substring.UTF8View) -> String?'\n    return String(bytes: cc, encoding:\
    \ .utf8)!\n           ^\n/tmp/tmp4ut5vbhn.swift:13:12: note: found candidate with\
    \ type '(Substring.UTF16View) -> String?'\n    return String(bytes: cc, encoding:\
    \ .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let aChar = a[a.startIndex.advancedBy(i)]\n        let bChar = b[b.startIndex.advancedBy(i)]\n\
    \        if aChar == bChar {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpbnunllsj.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpbnunllsj.swift:9:36:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ aChar = a[a.startIndex.advancedBy(i)]\n                      ~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpbnunllsj.swift:10:36: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n        let bChar = b[b.startIndex.advancedBy(i)]\n          \
    \            ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    var result = \"\"\n    for i in 0..<a.count {\n      \
    \  result += String(a[i] ^ b[i])\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824361
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n   \
    \ return xor_bytes.map { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for (i, j) in zip(a, b) {\n        result\
    \ += String(Int(String(i))! ^ Int(String(j))!)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpk6kc0_wx.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpk6kc0_wx.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpk6kc0_wx.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return\
    \ result.reduce(\"\") { $0 + String(format: \"%02x\", $1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpz93z8xfj.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpz93z8xfj.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmpz93z8xfj.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        result += String(a_char == b_char ? \"0\" : \"1\")\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824361
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        result += String(a_char == b_char ? \"0\" : \"1\")\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpubhj8fqr.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpubhj8fqr.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpubhj8fqr.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        let a_int = Int(String(a_char))!\n        let b_int =\
    \ Int(String(b_char))!\n        let xor = a_int ^ b_int\n        result.append(String(xor))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return result.map\
    \ { String($0) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824361
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpk6kc0_wx.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpk6kc0_wx.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpk6kc0_wx.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    var result = [UInt8]()\n    for (a, b) in zip(a_bytes, b_bytes)\
    \ {\n        result.append(a ^ b)\n    }\n    return String(bytes: result, encoding:\
    \ .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpv3ctxsg6.swift:13:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: result, encoding: .utf8)!\n           ^\n/tmp/tmpv3ctxsg6.swift:13:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ result, encoding: .utf8)!\n           ^\n/tmp/tmpv3ctxsg6.swift:13:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpv3ctxsg6.swift:13:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpv3ctxsg6.swift:13:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    let c = zip(a, b).map { $0 ^ $1 }\n    return String(c.map\
    \ { Character(UnicodeScalar($0 + 48)) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpkip6qx06.swift:10:37: error: value of optional type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n    return String(c.map { Character(UnicodeScalar($0\
    \ + 48)) })\n                                    ^\n/tmp/tmpkip6qx06.swift:10:37:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return String(c.map { Character(UnicodeScalar($0 + 48)) })\n    \
    \                                ^\n                                         \
    \                  ?? <#default value#>\n/tmp/tmpkip6qx06.swift:10:37: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ String(c.map { Character(UnicodeScalar($0 + 48)) })\n                      \
    \              ^\n                                                          !\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    let c = zip(a, b).map { $0 ^ $1 }\n    return String(c.map\
    \ { Character(UnicodeScalar($0 + 48)) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpkip6qx06.swift:10:37: error: value of optional type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n    return String(c.map { Character(UnicodeScalar($0\
    \ + 48)) })\n                                    ^\n/tmp/tmpkip6qx06.swift:10:37:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return String(c.map { Character(UnicodeScalar($0 + 48)) })\n    \
    \                                ^\n                                         \
    \                  ?? <#default value#>\n/tmp/tmpkip6qx06.swift:10:37: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ String(c.map { Character(UnicodeScalar($0 + 48)) })\n                      \
    \              ^\n                                                          !\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    return String(zip(a, b).map(^))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpl70hu94f.swift:7:33: error: no exact matches in reference to operator\
    \ function '^'\n    return String(zip(a, b).map(^))\n                        \
    \        ^\nSwift.BinaryInteger:1:17: note: candidate requires that 'String.Element'\
    \ (aka 'Character') conform to 'BinaryInteger' (requirement specified as 'Self'\
    \ : 'BinaryInteger')\npublic protocol BinaryInteger : CustomStringConvertible,\
    \ Hashable, Numeric, Strideable where Self.Magnitude : BinaryInteger, Self.Magnitude\
    \ == Self.Magnitude.Magnitude {\n                ^\nSwift.BinaryInteger:1:11:\
    \ note: candidate requires that 'String.Element' (aka 'Character') conform to\
    \ 'BinaryInteger' (requirement specified as 'Self' : 'BinaryInteger')\nextension\
    \ BinaryInteger {\n          ^\nSwift.SIMD:1:11: note: candidate requires that\
    \ 'String.Element' (aka 'Character') conform to 'SIMD' (requirement specified\
    \ as 'Self' : 'SIMD')\nextension SIMD where Self.Scalar : FixedWidthInteger {\n\
    \          ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n   \
    \ return String(bytes: xor_bytes, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpbgqh48j3.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpbgqh48j3.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpbgqh48j3.swift:10:12: note:\
    \ found candidate with type '([Int]) -> String'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpbgqh48j3.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpbgqh48j3.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for (i, j) in zip(a, b) {\n        result\
    \ += String(Int(String(i))! ^ Int(String(j))!)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return\
    \ result.reduce(\"\") { $0 + String(UnicodeScalar(UInt8(bitPattern: $1))) }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp8x965t07.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp8x965t07.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let result_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n\
    \    return String(bytes: result_bytes, encoding: .utf8)!\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpdfxd_ps2.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: result_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpdfxd_ps2.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ result_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpdfxd_ps2.swift:10:12:\
    \ note: found candidate with type '([Int]) -> String'\n    return String(bytes:\
    \ result_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpdfxd_ps2.swift:10:12:\
    \ note: found candidate with type '(Substring.UTF8View) -> String?'\n    return\
    \ String(bytes: result_bytes, encoding: .utf8)!\n           ^\n/tmp/tmpdfxd_ps2.swift:10:12:\
    \ note: found candidate with type '(Substring.UTF16View) -> String?'\n    return\
    \ String(bytes: result_bytes, encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    let xored = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n    return\
    \ xored.map { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824361
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n \
    \   return String(bytes: xor_bytes, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\n\
    assert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp_p2o5j3w.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmp_p2o5j3w.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ xor_bytes, encoding: .utf8)!\n           ^\n/tmp/tmp_p2o5j3w.swift:10:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp_p2o5j3w.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp_p2o5j3w.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: xor_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let xored = zip(a, b).map { $0 ^ $1 }\n    return\
    \ xored.map { String(UnicodeScalar(UInt8(bitPattern: $0))) }.joined()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpqrtpqhuf.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpqrtpqhuf.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n"
  stdout: ''
  timestamp: 1659824361
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        let a_int = Int(String(a_char))\n        let b_int = Int(String(b_char))\n\
    \        let result_int = a_int! ^ b_int!\n        result.append(String(result_int))\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpc1yaeft1.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpc1yaeft1.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpc1yaeft1.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824361
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return\
    \ result.reduce(\"\") { $0 + String(format: \"%02x\", $1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpz93z8xfj.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpz93z8xfj.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmpz93z8xfj.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return\
    \ result.reduce(\"\") { $0 + String(format: \"%02x\", $1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpz93z8xfj.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpz93z8xfj.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmpz93z8xfj.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_bit = a[a.index(a.startIndex, offsetBy: i)]\n        let b_bit = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_bit == b_bit {\n            result += \"0\"\n  \
    \      } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824361
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return\
    \ result.reduce(\"\") { $0 + String(format: \"%02x\", $1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\"\
    )\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\"\
    , b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpz93z8xfj.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmpz93z8xfj.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n/tmp/tmpz93z8xfj.swift:10:43: error: incorrect argument labels in call (have\
    \ 'format:_:', expected 'repeating:count:')\n    return result.reduce(\"\") {\
    \ $0 + String(format: \"%02x\", $1) }\n                                      \
    \    ^~~~~~~\n                                           repeating       count:\
    \ \n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let aa = a.utf8.map { UInt8($0) }\n    let bb = b.utf8.map\
    \ { UInt8($0) }\n    let cc = zip(aa, bb).map { $0 ^ $1 }\n    return String(bytes:\
    \ cc, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp23ii_plc.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: cc, encoding: .utf8)!\n           ^\n/tmp/tmp23ii_plc.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ cc, encoding: .utf8)!\n           ^\n/tmp/tmp23ii_plc.swift:10:12: note: found\
    \ candidate with type '([UInt8]) -> String'\n    return String(bytes: cc, encoding:\
    \ .utf8)!\n           ^\n/tmp/tmp23ii_plc.swift:10:12: note: found candidate with\
    \ type '(Substring.UTF8View) -> String?'\n    return String(bytes: cc, encoding:\
    \ .utf8)!\n           ^\n/tmp/tmp23ii_plc.swift:10:12: note: found candidate with\
    \ type '(Substring.UTF16View) -> String?'\n    return String(bytes: cc, encoding:\
    \ .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824361
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    let c = zip(a, b).map { $0 ^ $1 }\n    return String(c.map\
    \ { Character(UnicodeScalar($0 + 48)) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpkip6qx06.swift:10:37: error: value of optional type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n    return String(c.map { Character(UnicodeScalar($0\
    \ + 48)) })\n                                    ^\n/tmp/tmpkip6qx06.swift:10:37:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return String(c.map { Character(UnicodeScalar($0 + 48)) })\n    \
    \                                ^\n                                         \
    \                  ?? <#default value#>\n/tmp/tmpkip6qx06.swift:10:37: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ String(c.map { Character(UnicodeScalar($0 + 48)) })\n                      \
    \              ^\n                                                          !\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let result = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n    return\
    \ result.map { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let xor_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n   \
    \ return xor_bytes.reduce(\"\") { $0 + String(UnicodeScalar($1)) }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp4hx10eln.swift:10:40: error: no exact matches in call to initializer\
    \ \n    return xor_bytes.reduce(\"\") { $0 + String(UnicodeScalar($1)) }\n   \
    \                                    ^\nSwift.String:3:23: note: found candidate\
    \ with type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>')\n    @inlinable\
    \ public init(_ scalar: Unicode.Scalar)\n                      ^\nSwift.String:4:23:\
    \ note: found candidate with type 'UnicodeScalar?' (aka 'Optional<Unicode.Scalar>')\n\
    \    @inlinable public init<T>(_ value: T) where T : LosslessStringConvertible\n\
    \                      ^\nSwift.String:2:12: note: incorrect labels for candidate\
    \ (have: '(_:)', expected: '(describing:)')\n    public init<Subject>(describing\
    \ instance: Subject)\n           ^\nSwift.String:6:12: note: incorrect labels\
    \ for candidate (have: '(_:)', expected: '(reflecting:)')\n    public init<Subject>(reflecting\
    \ subject: Subject)\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { Int($0) }\n    let b_bytes = b.utf8.map\
    \ { Int($0) }\n    let c_bytes = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n    return\
    \ String(bytes: c_bytes, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp5dn_928q.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: c_bytes, encoding: .utf8)!\n           ^\n/tmp/tmp5dn_928q.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ c_bytes, encoding: .utf8)!\n           ^\n/tmp/tmp5dn_928q.swift:10:12: note:\
    \ found candidate with type '([Int]) -> String'\n    return String(bytes: c_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp5dn_928q.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: c_bytes,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmp5dn_928q.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: c_bytes,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824361
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    let result = zip(a, b).map { $0 ^ $1 }\n    return result.map\
    \ { String($0) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(string_xor(a:\
    \ \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"\
    1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824361
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    let c = zip(a, b).map { $0 ^ $1 }\n    return String(c.map\
    \ { Character(UnicodeScalar($0 + 48)) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpkip6qx06.swift:10:37: error: value of optional type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n    return String(c.map { Character(UnicodeScalar($0\
    \ + 48)) })\n                                    ^\n/tmp/tmpkip6qx06.swift:10:37:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return String(c.map { Character(UnicodeScalar($0 + 48)) })\n    \
    \                                ^\n                                         \
    \                  ?? <#default value#>\n/tmp/tmpkip6qx06.swift:10:37: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ String(c.map { Character(UnicodeScalar($0 + 48)) })\n                      \
    \              ^\n                                                          !\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        let a_int = Int(String(a_char))!\n        let b_int = Int(String(b_char))!\n\
    \        result += String(a_int ^ b_int)\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpykostldx.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpykostldx.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpykostldx.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824361
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        result += String(Int(String(a_char))! ^ Int(String(b_char))!)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpk6kc0_wx.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpk6kc0_wx.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpk6kc0_wx.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for (i, j) in zip(a, b) {\n        result\
    \ += String(Int(String(i))! ^ Int(String(j))!)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    let result = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n    return\
    \ result.map { String($0, radix: 2) }.joined()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        result += String(a_char == b_char ? \"0\" : \"1\")\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(string_xor(a: \"111000\"\
    , b: \"101010\") == \"010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\"\
    )\nassert(string_xor(a: \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpubhj8fqr.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpubhj8fqr.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpubhj8fqr.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.map { Int(String($0))! }\n    let b = b.map { Int(String($0))!\
    \ }\n    let c = zip(a, b).map { $0 ^ $1 }\n    return c.map { String($0) }.joined()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824361
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[i]\n        let b_char = b[i]\n        if a_char == b_char {\n  \
    \          result += \"0\"\n        } else {\n            result += \"1\"\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpq2006l07.swift:9:22: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let a_char\
    \ = a[i]\n                     ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpq2006l07.swift:10:22: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let b_char = b[i]\n                     ^~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824361
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { Int($0) - 48 }\n    let b = b.utf8.map\
    \ { Int($0) - 48 }\n    let c = zip(a, b).map { $0 ^ $1 }\n    return String(c.map\
    \ { Character(UnicodeScalar($0 + 48)) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpkip6qx06.swift:10:37: error: value of optional type 'UnicodeScalar?'\
    \ (aka 'Optional<Unicode.Scalar>') must be unwrapped to a value of type 'UnicodeScalar'\
    \ (aka 'Unicode.Scalar')\n    return String(c.map { Character(UnicodeScalar($0\
    \ + 48)) })\n                                    ^\n/tmp/tmpkip6qx06.swift:10:37:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return String(c.map { Character(UnicodeScalar($0 + 48)) })\n    \
    \                                ^\n                                         \
    \                  ?? <#default value#>\n/tmp/tmpkip6qx06.swift:10:37: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n    return\
    \ String(c.map { Character(UnicodeScalar($0 + 48)) })\n                      \
    \              ^\n                                                          !\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a_bytes = a.utf8.map { UInt8($0) }\n    let b_bytes = b.utf8.map\
    \ { UInt8($0) }\n    let result = zip(a_bytes, b_bytes).map { $0 ^ $1 }\n    return\
    \ String(bytes: result, encoding: .utf8)!\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(string_xor(a: \"111000\", b: \"101010\") == \"010010\")\nassert(string_xor(a:\
    \ \"1\", b: \"1\") == \"0\")\nassert(string_xor(a: \"0101\", b: \"0000\") == \"\
    0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpqrtt7d02.swift:10:12: error: no exact matches in call to initializer\
    \ \n    return String(bytes: result, encoding: .utf8)!\n           ^\n/tmp/tmpqrtt7d02.swift:10:12:\
    \ note: found candidate with type '(Array<_>, _.Type) -> String'\n    return String(bytes:\
    \ result, encoding: .utf8)!\n           ^\n/tmp/tmpqrtt7d02.swift:10:12: note:\
    \ found candidate with type '([UInt8]) -> String'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpqrtt7d02.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF8View) -> String?'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n/tmp/tmpqrtt7d02.swift:10:12: note: found candidate\
    \ with type '(Substring.UTF16View) -> String?'\n    return String(bytes: result,\
    \ encoding: .utf8)!\n           ^\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    let a = a.utf8.map { UInt8(bitPattern: $0) }\n    let b = b.utf8.map\
    \ { UInt8(bitPattern: $0) }\n    let xor = zip(a, b).map { $0 ^ $1 }\n    return\
    \ xor.map { String(UnicodeScalar(UInt8(bitPattern: $0))) }.joined()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmp27mhw_cx.swift:7:44: error: cannot convert value of type 'String.UTF8View.Element'\
    \ (aka 'UInt8') to expected argument type 'Int8'\n    let a = a.utf8.map { UInt8(bitPattern:\
    \ $0) }\n                                           ^\n                      \
    \                     Int8( )\n/tmp/tmp27mhw_cx.swift:8:44: error: cannot convert\
    \ value of type 'String.UTF8View.Element' (aka 'UInt8') to expected argument type\
    \ 'Int8'\n    let b = b.utf8.map { UInt8(bitPattern: $0) }\n                 \
    \                          ^\n                                           Int8(\
    \ )\n"
  stdout: ''
  timestamp: 1659824361
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 1
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.characters.count {\n\
    \        let a_char = a[a.startIndex.advancedBy(i)]\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \        if a_char == b_char {\n            result.append(\"0\")\n        } else\
    \ {\n            result.append(\"1\")\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: SyntaxError
  stderr: "/tmp/tmpcp645j2n.swift:8:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    for i in 0..<a.characters.count {\n               \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpcp645j2n.swift:9:37:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        let\
    \ a_char = a[a.startIndex.advancedBy(i)]\n                       ~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpcp645j2n.swift:10:37: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n        let b_char = b[b.startIndex.advancedBy(i)]\n\
    \                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
- exit_code: 0
  program: "\n/// Input are two strings a and b consisting only of 1s and 0s.\n///\
    \ Perform binary XOR on these inputs and return result also as a string.\n///\
    \ >>> string_xor('010', '110')\n/// '100'\nfunc string_xor(a: String, b: String)\
    \ -> String {\n    var result = \"\"\n    for i in 0..<a.count {\n        let\
    \ a_char = a[a.index(a.startIndex, offsetBy: i)]\n        let b_char = b[b.index(b.startIndex,\
    \ offsetBy: i)]\n        if a_char == b_char {\n            result += \"0\"\n\
    \        } else {\n            result += \"1\"\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(string_xor(a: \"111000\", b: \"101010\") == \"\
    010010\")\nassert(string_xor(a: \"1\", b: \"1\") == \"0\")\nassert(string_xor(a:\
    \ \"0101\", b: \"0000\") == \"0101\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824360
