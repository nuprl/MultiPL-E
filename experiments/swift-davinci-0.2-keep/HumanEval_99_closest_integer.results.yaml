language: swift
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ ceiled = Int(number.rounded(.up))\n    let floored = Int(number.rounded(.down))\n\
    \    let diff1 = abs(number - Double(rounded))\n    let diff2 = abs(number - Double(ceiled))\n\
    \    let diff3 = abs(number - Double(floored))\n    if diff1 < diff2 && diff1\
    \ < diff3 {\n        return rounded\n    } else if diff2 < diff1 && diff2 < diff3\
    \ {\n        return ceiled\n    } else {\n        return floored\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_i'
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ ceiled = Int(number.rounded(.up))\n    let floored = Int(number.rounded(.down))\n\
    \    let diff1 = abs(number - Double(rounded))\n    let diff2 = abs(number - Double(ceiled))\n\
    \    let diff3 = abs(number - Double(floored))\n    if diff1 < diff2 && diff1\
    \ < diff3 {\n        return rounded\n    } else if diff2 < diff1 && diff2 < diff3\
    \ {\n        return ceiled\n    } else {\n        return floored\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TptrZ3/tmpxl5pmqnh-1.o:tmpxl5pmqnh-1.o:function $s11tmpxl5pmqnh15closest_i'
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = Int(round(doubleValue!))\n\
    \    return roundedValue\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpra_j8vd9.swift:17:28: error: cannot find 'round' in scope\n   \
    \ let roundedValue = Int(round(doubleValue!))\n                           ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmptwk4e0ax/tmptwk4e0ax.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab74939fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab749096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab749096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7490957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptwk4e0ax                        0x000055aa69f5e512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab74958b460 __libc_start_main +
    245

    6    tmptwk4e0ax                        0x000055aa69f5e049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    return value - Double(floor) < Double(ceil) - value\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppiy10yr2.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmppiy10yr2.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmppiy10yr2.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmppiy10yr2.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpf155rap2.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded >= 0.5 {\n        return Int(rounded + 1)\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdcqsaanh.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return floor\n    } else if number\
    \ - Double(ceil) == -0.5 {\n        return ceil\n    } else {\n        return\
    \ rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_i'
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let roundedInt\
    \ = Int(rounded)\n    if rounded - Double(roundedInt) >= 0.5 {\n        return\
    \ roundedInt + 1\n    } else {\n        return roundedInt\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.oheS24/tmpe83xqx2o-1.o:tmpe83xqx2o-1.o:function $s11tmpe83xqx2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.oheS24/tmpe83xqx2o-1.o:tmpe83xqx2o-1.o:function $s11tmpe83xqx2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.oheS24/tmpe83xqx2o-1.o:tmpe83xqx2o-1.o:function $s11tmpe83xqx2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.oheS24/tmpe83xqx2o-1.o:tmpe83xqx2o-1.o:function $s11tmpe83xqx2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.oheS24/tmpe83xqx2o-1.o:tmpe83xqx2o-1.o:function $s11tmpe83xqx2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.oheS24/tmpe83xqx2o-1.o:tmpe83xqx2o-1.o:function $s11tmpe83xqx2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.oheS24/tmpe83xqx2o-1.o:tmpe83xqx2o-1.o:function $s11tmpe83xqx2o15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpyxarxh2j/tmpyxarxh2j.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37090e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3708ddab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3708dda988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3708dd97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyxarxh2j                        0x00005578ab219512 <unavailable> + 5394

    5    libc.so.6                          0x00002b37092cf460 __libc_start_main +
    245

    6    tmpyxarxh2j                        0x00005578ab219049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpf155rap2.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(rounded)\n    let ceil = Int(rounded) + 1\n    let diffFloor = abs(number\
    \ - Double(floor))\n    let diffCeil = abs(number - Double(ceil))\n    if diffFloor\
    \ < diffCeil {\n        return floor\n    } else {\n        return ceil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpupwc0fip.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n    if\
    \ rounded - Double(floor) == 0.5 {\n        return ceil\n    } else if rounded\
    \ - Double(floor) == -0.5 {\n        return floor\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp56t_jgj9.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let integer\
    \ = Int(rounded)\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7ratgvlt.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = doubleValue!.rounded()\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded == 0.5 {\n        return Int(number > 0 ? rounded + 1 : rounded -\
    \ 1)\n    }\n    return Int(rounded)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxq371c8n.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(round(Double(value)!))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpsnrcf7eg.swift:16:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(Double(value)!))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(round(Double(value)!))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpsnrcf7eg.swift:16:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(Double(value)!))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let roundedInt\
    \ = Int(rounded)\n    let decimal = number - rounded\n    if decimal > 0.5 {\n\
    \        return roundedInt + 1\n    } else if decimal < -0.5 {\n        return\
    \ roundedInt - 1\n    } else {\n        return roundedInt\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpcwiv6a3v.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdus47ffw/tmpdus47ffw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d4b12ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4ae21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4ae21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d4ae207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdus47ffw                        0x000055db3df7f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9d4b316460 __libc_start_main +
    245

    6    tmpdus47ffw                        0x000055db3df7f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    if number\
    \ - rounded >= 0.5 {\n        return Int(rounded + 1)\n    } else {\n        return\
    \ Int(rounded)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.nerMu4/tmp5rgm5i4q-1.o:tmp5rgm5i4q-1.o:function $s11tmp5rgm5i4q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.nerMu4/tmp5rgm5i4q-1.o:tmp5rgm5i4q-1.o:function $s11tmp5rgm5i4q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.nerMu4/tmp5rgm5i4q-1.o:tmp5rgm5i4q-1.o:function $s11tmp5rgm5i4q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.nerMu4/tmp5rgm5i4q-1.o:tmp5rgm5i4q-1.o:function $s11tmp5rgm5i4q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.nerMu4/tmp5rgm5i4q-1.o:tmp5rgm5i4q-1.o:function $s11tmp5rgm5i4q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.nerMu4/tmp5rgm5i4q-1.o:tmp5rgm5i4q-1.o:function $s11tmp5rgm5i4q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.nerMu4/tmp5rgm5i4q-1.o:tmp5rgm5i4q-1.o:function $s11tmp5rgm5i4q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let diff_floor = abs(number - Double(floor))\n    let diff_ceil = abs(number\
    \ - Double(ceil))\n    if diff_floor == diff_ceil {\n        return number > 0\
    \ ? ceil : floor\n    }\n    return diff_floor < diff_ceil ? floor : ceil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_rd01ssz.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.ZzysA4/tmp_rd01ssz-1.o:tmp_rd01ssz-1.o:function\
    \ $s11tmp_rd01ssz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.ZzysA4/tmp_rd01ssz-1.o:tmp_rd01ssz-1.o:function\
    \ $s11tmp_rd01ssz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.ZzysA4/tmp_rd01ssz-1.o:tmp_rd01ssz-1.o:function\
    \ $s11tmp_rd01ssz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.ZzysA4/tmp_rd01ssz-1.o:tmp_rd01ssz-1.o:function\
    \ $s11tmp_rd01ssz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.ZzysA4/tmp_rd01ssz-1.o:tmp_rd01ssz-1.o:function\
    \ $s11tmp_rd01ssz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.ZzysA4/tmp_rd01ssz-1.o:tmp_rd01ssz-1.o:function\
    \ $s11tmp_rd01ssz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.ZzysA4/tmp_rd01ssz-1.o:tmp_rd01ssz-1.o:function\
    \ $s11tmp_rd01ssz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.ZzysA4/tmp_rd01ssz-1.o:tmp_rd01ssz-1.o:function\
    \ $s11tmp_rd01ssz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.ZzysA4/tmp_rd01ssz-1.o:tmp_rd01ssz-1.o:function\
    \ $s11tmp_rd01ssz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.ZzysA4/tmp_rd01ssz-1.o:tmp_rd01ssz-1.o:function\
    \ $s11tmp_rd01ssz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.ZzysA4/tmp_rd01ssz-1.o:tmp_rd01ssz-1.o:function\
    \ $s11tmp_rd01ssz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.ZzysA4/tmp_rd0"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let integerValue = Int(doubleValue!)\n\
    \    let decimalValue = doubleValue! - Double(integerValue)\n    if decimalValue\
    \ < 0.5 {\n        return integerValue\n    } else {\n        return integerValue\
    \ + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpkvatx_eh/tmpkvatx_eh.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b39c7403c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b39c70fab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b39c70fa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b39c70f97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkvatx_eh                        0x000055b89a4cd512 <unavailable> + 5394

    5    libc.so.6                          0x00002b39c75ef460 __libc_start_main +
    245

    6    tmpkvatx_eh                        0x000055b89a4cd049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilDiff = abs(number\
    \ - Double(ceil))\n    if floorDiff == ceilDiff {\n        return number < 0 ?\
    \ floor : ceil\n    }\n    return floorDiff < ceilDiff ? floor : ceil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpq2e4edxh.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.Gf82v4/tmpq2e4edxh-1.o:tmpq2e4edxh-1.o:function\
    \ $s11tmpq2e4edxh15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Gf82v4/tmpq2e4edxh-1.o:tmpq2e4edxh-1.o:function\
    \ $s11tmpq2e4edxh15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Gf82v4/tmpq2e4edxh-1.o:tmpq2e4edxh-1.o:function\
    \ $s11tmpq2e4edxh15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Gf82v4/tmpq2e4edxh-1.o:tmpq2e4edxh-1.o:function\
    \ $s11tmpq2e4edxh15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Gf82v4/tmpq2e4edxh-1.o:tmpq2e4edxh-1.o:function\
    \ $s11tmpq2e4edxh15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Gf82v4/tmpq2e4edxh-1.o:tmpq2e4edxh-1.o:function\
    \ $s11tmpq2e4edxh15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Gf82v4/tmpq2e4edxh-1.o:tmpq2e4edxh-1.o:function\
    \ $s11tmpq2e4edxh15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Gf82v4/tmpq2e4edxh-1.o:tmpq2e4edxh-1.o:function\
    \ $s11tmpq2e4edxh15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Gf82v4/tmpq2e4edxh-1.o:tmpq2e4edxh-1.o:function\
    \ $s11tmpq2e4edxh15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Gf82v4/tmpq2e4edxh-1.o:tmpq2e4edxh-1.o:function\
    \ $s11tmpq2e4edxh15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Gf82v4/tmpq2e4edxh-1.o:tmpq2e4edxh-1.o:function\
    \ $s11tmpq2e4edxh15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Gf82v4/tmpq2e4"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpyxarxh2j/tmpyxarxh2j.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37090e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3708ddab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3708dda988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3708dd97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyxarxh2j                        0x00005578ab219512 <unavailable> + 5394

    5    libc.so.6                          0x00002b37092cf460 __libc_start_main +
    245

    6    tmpyxarxh2j                        0x00005578ab219049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value)\n    let intValue = Int(floatValue!)\n    let\
    \ decimalValue = floatValue! - Float(intValue)\n    if decimalValue >= 0.5 {\n\
    \        return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmppy_f6zhf/tmppy_f6zhf.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1fe7ca4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1fe799bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1fe799b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1fe799a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppy_f6zhf                        0x000055823dde9512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1fe7e90460 __libc_start_main +
    245

    6    tmppy_f6zhf                        0x000055823dde9049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp92yrj2y6.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdus47ffw/tmpdus47ffw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d4b12ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4ae21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4ae21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d4ae207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdus47ffw                        0x000055db3df7f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9d4b316460 __libc_start_main +
    245

    6    tmpdus47ffw                        0x000055db3df7f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floorDistance = abs(number - Double(floor))\n    let ceilDistance = abs(number\
    \ - Double(ceil))\n    if floorDistance == ceilDistance {\n        return number\
    \ < 0 ? floor : ceil\n    }\n    return floorDistance < ceilDistance ? floor :\
    \ ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp61yffucz.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.EUfZoo/tmp61yffucz-1.o:tmp61yffucz-1.o:function\
    \ $s11tmp61yffucz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.EUfZoo/tmp61yffucz-1.o:tmp61yffucz-1.o:function\
    \ $s11tmp61yffucz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.EUfZoo/tmp61yffucz-1.o:tmp61yffucz-1.o:function\
    \ $s11tmp61yffucz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.EUfZoo/tmp61yffucz-1.o:tmp61yffucz-1.o:function\
    \ $s11tmp61yffucz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.EUfZoo/tmp61yffucz-1.o:tmp61yffucz-1.o:function\
    \ $s11tmp61yffucz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.EUfZoo/tmp61yffucz-1.o:tmp61yffucz-1.o:function\
    \ $s11tmp61yffucz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.EUfZoo/tmp61yffucz-1.o:tmp61yffucz-1.o:function\
    \ $s11tmp61yffucz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.EUfZoo/tmp61yffucz-1.o:tmp61yffucz-1.o:function\
    \ $s11tmp61yffucz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.EUfZoo/tmp61yffucz-1.o:tmp61yffucz-1.o:function\
    \ $s11tmp61yffucz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.EUfZoo/tmp61yffucz-1.o:tmp61yffucz-1.o:function\
    \ $s11tmp61yffucz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.EUfZoo/tmp61yffucz-1.o:tmp61yffucz-1.o:function\
    \ $s11tmp61yffucz15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.EUfZoo/tmp61yf"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp92yrj2y6.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp7p2dpiai/tmp7p2dpiai.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19538cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19535c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19535c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19535c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7p2dpiai                        0x000055ed4c25a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1953abb460 __libc_start_main +
    245

    6    tmp7p2dpiai                        0x000055ed4c25a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptcn1q0sk.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmptcn1q0sk.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmptcn1q0sk.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmptcn1q0sk.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    if abs(value - Double(floor)) < abs(value - Double(ceil))\
    \ {\n        return floor\n    }\n    return ceil\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_upualls.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmp_upualls.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmp_upualls.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmp_upualls.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ ceiled = Int(number.rounded(.up))\n    let floored = Int(number.rounded(.down))\n\
    \    let distanceFromRounded = abs(number - Double(rounded))\n    let distanceFromCeiled\
    \ = abs(number - Double(ceiled))\n    let distanceFromFloored = abs(number - Double(floored))\n\
    \    if distanceFromRounded == distanceFromCeiled {\n        return ceiled\n \
    \   } else if distanceFromRounded == distanceFromFloored {\n        return floored\n\
    \    } else {\n        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.qsoTno/tmpgfe6pcuq-1.o:tmpgfe6pcuq-1.o:function $s11tmpgfe6pcuq15closest_i'
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp7p2dpiai/tmp7p2dpiai.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19538cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19535c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19535c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19535c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7p2dpiai                        0x000055ed4c25a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1953abb460 __libc_start_main +
    245

    6    tmp7p2dpiai                        0x000055ed4c25a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdus47ffw/tmpdus47ffw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d4b12ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4ae21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4ae21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d4ae207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdus47ffw                        0x000055db3df7f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9d4b316460 __libc_start_main +
    245

    6    tmpdus47ffw                        0x000055db3df7f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    if number\
    \ - Double(rounded) == 0.5 {\n        return rounded + 1\n    }\n    return rounded\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmph_aq52pv.swift:17:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    if rounded\
    \ > number {\n        return Int(rounded - 1)\n    }\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.NJ97Hn/tmpi9o__4ll-1.o:tmpi9o__4ll-1.o:function $s11tmpi9o__4ll15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.NJ97Hn/tmpi9o__4ll-1.o:tmpi9o__4ll-1.o:function $s11tmpi9o__4ll15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.NJ97Hn/tmpi9o__4ll-1.o:tmpi9o__4ll-1.o:function $s11tmpi9o__4ll15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.NJ97Hn/tmpi9o__4ll-1.o:tmpi9o__4ll-1.o:function $s11tmpi9o__4ll15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.NJ97Hn/tmpi9o__4ll-1.o:tmpi9o__4ll-1.o:function $s11tmpi9o__4ll15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.NJ97Hn/tmpi9o__4ll-1.o:tmpi9o__4ll-1.o:function $s11tmpi9o__4ll15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.NJ97Hn/tmpi9o__4ll-1.o:tmpi9o__4ll-1.o:function $s11tmpi9o__4ll15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    return Int(doubleValue! + (doubleValue!\
    \ > 0 ? 0.5 : -0.5))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpyxarxh2j/tmpyxarxh2j.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37090e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3708ddab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3708dda988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3708dd97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyxarxh2j                        0x00005578ab219512 <unavailable> + 5394

    5    libc.so.6                          0x00002b37092cf460 __libc_start_main +
    245

    6    tmpyxarxh2j                        0x00005578ab219049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var result = 0\n    if let doubleValue = Double(value) {\n        result =\
    \ Int(doubleValue)\n        if doubleValue - Double(result) >= 0.5 {\n       \
    \     result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpk5co2lx7/tmpk5co2lx7.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f0cc68c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f0c95fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f0c95f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f0c95e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk5co2lx7                        0x0000563c45914512 <unavailable> + 5394

    5    libc.so.6                          0x00002b5f0ce54460 __libc_start_main +
    245

    6    tmpk5co2lx7                        0x0000563c45914049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpyxarxh2j/tmpyxarxh2j.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37090e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3708ddab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3708dda988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3708dd97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyxarxh2j                        0x00005578ab219512 <unavailable> + 5394

    5    libc.so.6                          0x00002b37092cf460 __libc_start_main +
    245

    6    tmpyxarxh2j                        0x00005578ab219049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floor_diff = abs(number - Double(floor))\n    let ceiling_diff = abs(number\
    \ - Double(ceiling))\n    if floor_diff < ceiling_diff {\n        return floor\n\
    \    } else if floor_diff > ceiling_diff {\n        return ceiling\n    } else\
    \ {\n        return rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jmaaiw/tmpytig8_cq-1.o:tmpytig8_cq-1.o:function $s11tmpytig8_cq15closest_i'
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmptwk4e0ax/tmptwk4e0ax.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab74939fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab749096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab749096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7490957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptwk4e0ax                        0x000055aa69f5e512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab74958b460 __libc_start_main +
    245

    6    tmptwk4e0ax                        0x000055aa69f5e049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let doubleValue2 = Double(intValue)\n    if doubleValue! - doubleValue2 > 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpff_j2fgz/tmpff_j2fgz.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c8e327c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c8e01eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c8e01e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c8e01d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpff_j2fgz                        0x000055578df9e46b <unavailable> + 5227

    5    libc.so.6                          0x00002b5c8e513460 __libc_start_main +
    245

    6    tmpff_j2fgz                        0x000055578df9e049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdus47ffw/tmpdus47ffw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d4b12ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4ae21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4ae21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d4ae207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdus47ffw                        0x000055db3df7f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9d4b316460 __libc_start_main +
    245

    6    tmpdus47ffw                        0x000055db3df7f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(round(Double(value)!))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpsnrcf7eg.swift:16:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(Double(value)!))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilDiff = abs(number\
    \ - Double(ceil))\n    if floorDiff == ceilDiff {\n        return number > 0 ?\
    \ ceil : floor\n    }\n    return floorDiff < ceilDiff ? floor : ceil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxrvidvyr.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.Fkfl3y/tmpxrvidvyr-1.o:tmpxrvidvyr-1.o:function\
    \ $s11tmpxrvidvyr15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Fkfl3y/tmpxrvidvyr-1.o:tmpxrvidvyr-1.o:function\
    \ $s11tmpxrvidvyr15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Fkfl3y/tmpxrvidvyr-1.o:tmpxrvidvyr-1.o:function\
    \ $s11tmpxrvidvyr15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Fkfl3y/tmpxrvidvyr-1.o:tmpxrvidvyr-1.o:function\
    \ $s11tmpxrvidvyr15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Fkfl3y/tmpxrvidvyr-1.o:tmpxrvidvyr-1.o:function\
    \ $s11tmpxrvidvyr15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Fkfl3y/tmpxrvidvyr-1.o:tmpxrvidvyr-1.o:function\
    \ $s11tmpxrvidvyr15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.Fkfl3y/tmpxrvidvyr-1.o:tmpxrvidvyr-1.o:function\
    \ $s11tmpxrvidvyr15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Fkfl3y/tmpxrvidvyr-1.o:tmpxrvidvyr-1.o:function\
    \ $s11tmpxrvidvyr15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.Fkfl3y/tmpxrvidvyr-1.o:tmpxrvidvyr-1.o:function\
    \ $s11tmpxrvidvyr15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.Fkfl3y/tmpxrvidvyr-1.o:tmpxrvidvyr-1.o:function\
    \ $s11tmpxrvidvyr15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.Fkfl3y/tmpxrvidvyr-1.o:tmpxrvidvyr-1.o:function\
    \ $s11tmpxrvidvyr15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.Fkfl3y/tmpxrvi"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptcn1q0sk.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmptcn1q0sk.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmptcn1q0sk.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmptcn1q0sk.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ ceiled = Int(number.rounded(.up))\n    let floored = Int(number.rounded(.down))\n\
    \    let rounded_diff = abs(rounded - number)\n    let ceiled_diff = abs(ceiled\
    \ - number)\n    let floored_diff = abs(floored - number)\n    if rounded_diff\
    \ < ceiled_diff && rounded_diff < floored_diff {\n        return rounded\n   \
    \ } else if ceiled_diff < rounded_diff && ceiled_diff < floored_diff {\n     \
    \   return ceiled\n    } else {\n        return floored\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpy4fzavo1.swift:20:36: error: binary operator '-' cannot be applied\
    \ to operands of type 'Int' and 'Double'\n    let rounded_diff = abs(rounded -\
    \ number)\n                           ~~~~~~~ ^ ~~~~~~\n/tmp/tmpy4fzavo1.swift:20:36:\
    \ note: overloads for '-' exist with these partially matching parameter lists:\
    \ (Double, Double), (Int, Int)\n    let rounded_diff = abs(rounded - number)\n\
    \                                   ^\n/tmp/tmpy4fzavo1.swift:21:34: error: binary\
    \ operator '-' cannot be applied to operands of type 'Int' and 'Double'\n    let\
    \ ceiled_diff = abs(ceiled - number)\n                          ~~~~~~ ^ ~~~~~~\n\
    /tmp/tmpy4fzavo1.swift:21:34: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (Double, Double), (Int, Int)\n    let ceiled_diff\
    \ = abs(ceiled - number)\n                                 ^\n/tmp/tmpy4fzavo1.swift:22:36:\
    \ error: binary operator '-' cannot be applied to operands of type 'Int' and 'Double'\n\
    \    let floored_diff = abs(floored - number)\n                           ~~~~~~~\
    \ ^ ~~~~~~\n/tmp/tmpy4fzavo1.swift:22:36: note: overloads for '-' exist with these\
    \ partially matching parameter lists: (Double, Double), (Int, Int)\n    let floored_diff\
    \ = abs(floored - number)\n                                   ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let diff\
    \ = abs(number - rounded)\n    if diff < 0.5 {\n        return Int(rounded)\n\
    \    } else {\n        return Int(number > 0 ? rounded + 1 : rounded - 1)\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\"\
    ) == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmphxcsvmz3.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    if value - Double(floor) < Double(ceil) - value {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppp99hnuh.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmppp99hnuh.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmppp99hnuh.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmppp99hnuh.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let rounded = round(num)\n    let int = Int(rounded)\n\
    \    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpfokm2tbi.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(num)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = doubleValue!.rounded()\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = doubleValue!.rounded()\n\
    \    let intValue = Int(roundedValue)\n    return intValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal < 0.5 {\n    \
    \    return intValue\n    } else {\n        return intValue + 1\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp9cqid1bs/tmp9cqid1bs.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b461932ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4619025b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4619025988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b46190247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9cqid1bs                        0x000055db06556512 <unavailable> + 5394

    5    libc.so.6                          0x00002b461951a460 __libc_start_main +
    245

    6    tmp9cqid1bs                        0x000055db06556049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptcn1q0sk.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmptcn1q0sk.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmptcn1q0sk.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmptcn1q0sk.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return floor\n    } else if number\
    \ - Double(ceil) == -0.5 {\n        return ceil\n    } else {\n        return\
    \ rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_i'
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmptwk4e0ax/tmptwk4e0ax.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab74939fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab749096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab749096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7490957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptwk4e0ax                        0x000055aa69f5e512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab74958b460 __libc_start_main +
    245

    6    tmptwk4e0ax                        0x000055aa69f5e049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpf155rap2.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let ceiled\
    \ = ceil(number)\n    let floored = floor(number)\n    if (number - rounded) ==\
    \ 0 {\n        return Int(rounded)\n    } else if (number - rounded) > 0 {\n \
    \       return Int(ceiled)\n    } else {\n        return Int(floored)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpcw5v2paw.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpcw5v2paw.swift:18:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(number)\n        \
    \         ^~~~\n/tmp/tmpcw5v2paw.swift:19:19: error: cannot find 'floor' in scope\n\
    \    let floored = floor(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptcn1q0sk.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmptcn1q0sk.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmptcn1q0sk.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmptcn1q0sk.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdus47ffw/tmpdus47ffw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d4b12ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4ae21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4ae21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d4ae207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdus47ffw                        0x000055db3df7f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9d4b316460 __libc_start_main +
    245

    6    tmpdus47ffw                        0x000055db3df7f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let integer\
    \ = Int(rounded)\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7ratgvlt.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    if value - Double(floor) < Double(ceil) - value {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppp99hnuh.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmppp99hnuh.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmppp99hnuh.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmppp99hnuh.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdus47ffw/tmpdus47ffw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d4b12ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4ae21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4ae21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d4ae207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdus47ffw                        0x000055db3df7f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9d4b316460 __libc_start_main +
    245

    6    tmpdus47ffw                        0x000055db3df7f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let roundedInt\
    \ = Int(rounded)\n    let decimal = number - rounded\n    if decimal == 0 {\n\
    \        return roundedInt\n    } else if decimal > 0 {\n        return roundedInt\
    \ + 1\n    } else {\n        return roundedInt - 1\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7po0ds_j.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(rounded)\n    let ceil = Int(rounded) + 1\n    let diff_floor = abs(number\
    \ - Double(floor))\n    let diff_ceil = abs(number - Double(ceil))\n    if diff_floor\
    \ < diff_ceil {\n        return floor\n    } else {\n        return ceil\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\"\
    ) == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpy8lob6q5.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    if num - Double(int)\
    \ < 0.5 {\n        return int\n    } else {\n        return int + 1\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp9ad4qi7j/tmp9ad4qi7j.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba9dc214c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba9dbf0bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba9dbf0b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba9dbf0a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9ad4qi7j                        0x000056006096c512 <unavailable> + 5394

    5    libc.so.6                          0x00002ba9dc400460 __libc_start_main +
    245

    6    tmp9ad4qi7j                        0x000056006096c049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let ceiled\
    \ = ceil(number)\n    let floored = floor(number)\n    let rounded_diff = abs(rounded\
    \ - number)\n    let ceiled_diff = abs(ceiled - number)\n    let floored_diff\
    \ = abs(floored - number)\n    if rounded_diff < ceiled_diff && rounded_diff <\
    \ floored_diff {\n        return Int(rounded)\n    } else if ceiled_diff < rounded_diff\
    \ && ceiled_diff < floored_diff {\n        return Int(ceiled)\n    } else {\n\
    \        return Int(floored)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptnp1qd7r.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmptnp1qd7r.swift:18:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(number)\n        \
    \         ^~~~\n/tmp/tmptnp1qd7r.swift:19:19: error: cannot find 'floor' in scope\n\
    \    let floored = floor(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let rounded_int\
    \ = Int(rounded)\n    let decimal = number - rounded\n    if decimal > 0.5 {\n\
    \        return rounded_int + 1\n    } else if decimal < -0.5 {\n        return\
    \ rounded_int - 1\n    } else {\n        return rounded_int\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.5YX9QC/tmpmy774vc3-1.o:tmpmy774vc3-1.o:function $s11tmpmy774vc315closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.5YX9QC/tmpmy774vc3-1.o:tmpmy774vc3-1.o:function $s11tmpmy774vc315closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.5YX9QC/tmpmy774vc3-1.o:tmpmy774vc3-1.o:function $s11tmpmy774vc315closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.5YX9QC/tmpmy774vc3-1.o:tmpmy774vc3-1.o:function $s11tmpmy774vc315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.5YX9QC/tmpmy774vc3-1.o:tmpmy774vc3-1.o:function $s11tmpmy774vc315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.5YX9QC/tmpmy774vc3-1.o:tmpmy774vc3-1.o:function $s11tmpmy774vc315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.5YX9QC/tmpmy774vc3-1.o:tmpmy774vc3-1.o:function $s11tmpmy774vc315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let rounded = round(doubleValue!)\n  \
    \  return Int(rounded)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpr_u1lzdq.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(doubleValue!)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    return int\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpf155rap2.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    if number -\
    \ Double(integer) < 0.5 {\n        return integer\n    } else {\n        return\
    \ integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp2s9ltfnw/tmp2s9ltfnw.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57f525fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57f4f56b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57f4f56988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57f4f557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2s9ltfnw                        0x000055803236d512 <unavailable> + 5394

    5    libc.so.6                          0x00002b57f544b460 __libc_start_main +
    245

    6    tmp2s9ltfnw                        0x000055803236d049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = doubleValue!.rounded()\n\
    \    let intValue = Int(roundedValue)\n    return intValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.wuLHLx/tmp7h4n22ig-1.o:tmp7h4n22ig-1.o:function $s11tmp7h4n22ig15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(number.rounded(.down))\n \
    \   let ceil = Int(number.rounded(.up))\n    let diff_floor = abs(number - Double(floor))\n\
    \    let diff_ceil = abs(number - Double(ceil))\n    return diff_floor < diff_ceil\
    \ ? floor : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.MwAEnB/tmpbat7y7ra-1.o:tmpbat7y7ra-1.o:function $s11tmpbat7y7ra15closest_i'
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff1 = abs(number - Double(floor))\n    let diff2\
    \ = abs(number - Double(ceil))\n    if diff1 < diff2 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp5reikjie.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmp5reikjie.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmp5reikjie.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmp5reikjie.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdus47ffw/tmpdus47ffw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d4b12ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4ae21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4ae21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d4ae207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdus47ffw                        0x000055db3df7f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9d4b316460 __libc_start_main +
    245

    6    tmpdus47ffw                        0x000055db3df7f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpzjjdb8la/tmpzjjdb8la.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac03b4a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac03b19eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac03b19e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac03b19d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzjjdb8la                        0x0000558cec20a512 <unavailable> + 5394

    5    libc.so.6                          0x00002ac03b693460 __libc_start_main +
    245

    6    tmpzjjdb8la                        0x0000558cec20a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpyxarxh2j/tmpyxarxh2j.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37090e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3708ddab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3708dda988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3708dd97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyxarxh2j                        0x00005578ab219512 <unavailable> + 5394

    5    libc.so.6                          0x00002b37092cf460 __libc_start_main +
    245

    6    tmpyxarxh2j                        0x00005578ab219049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let integer\
    \ = Int(rounded)\n    let decimal = rounded - Double(integer)\n    if decimal\
    \ >= 0.5 {\n        return integer + 1\n    } else {\n        return integer\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.2thEpB/tmpejvennj5-1.o:tmpejvennj5-1.o:function $s11tmpejvennj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.2thEpB/tmpejvennj5-1.o:tmpejvennj5-1.o:function $s11tmpejvennj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.2thEpB/tmpejvennj5-1.o:tmpejvennj5-1.o:function $s11tmpejvennj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.2thEpB/tmpejvennj5-1.o:tmpejvennj5-1.o:function $s11tmpejvennj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.2thEpB/tmpejvennj5-1.o:tmpejvennj5-1.o:function $s11tmpejvennj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.2thEpB/tmpejvennj5-1.o:tmpejvennj5-1.o:function $s11tmpejvennj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.2thEpB/tmpejvennj5-1.o:tmpejvennj5-1.o:function $s11tmpejvennj515closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let floor = Int(floor(num))\n    let ceil = Int(ceil(num))\n\
    \    let diff1 = abs(num - Double(floor))\n    let diff2 = abs(num - Double(ceil))\n\
    \    if diff1 < diff2 {\n        return floor\n    } else {\n        return ceil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpmuepxtpf.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(num))\n                    ^\n/tmp/tmpmuepxtpf.swift:17:9:\
    \ note: 'floor' declared here\n    let floor = Int(floor(num))\n        ^\n/tmp/tmpmuepxtpf.swift:18:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(num))\n\
    \                   ^\n/tmp/tmpmuepxtpf.swift:18:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(num))\n        ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let roundedInt\
    \ = Int(rounded)\n    let roundedDouble = Double(roundedInt)\n    if number >\
    \ roundedDouble {\n        return roundedInt + 1\n    } else if number < roundedDouble\
    \ {\n        return roundedInt - 1\n    } else {\n        return roundedInt\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.K58EPD/tmpftmlbvsz-1.o:tmpftmlbvsz-1.o:function $s11tmpftmlbvsz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.K58EPD/tmpftmlbvsz-1.o:tmpftmlbvsz-1.o:function $s11tmpftmlbvsz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.K58EPD/tmpftmlbvsz-1.o:tmpftmlbvsz-1.o:function $s11tmpftmlbvsz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.K58EPD/tmpftmlbvsz-1.o:tmpftmlbvsz-1.o:function $s11tmpftmlbvsz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.K58EPD/tmpftmlbvsz-1.o:tmpftmlbvsz-1.o:function $s11tmpftmlbvsz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.K58EPD/tmpftmlbvsz-1.o:tmpftmlbvsz-1.o:function $s11tmpftmlbvsz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.K58EPD/tmpftmlbvsz-1.o:tmpftmlbvsz-1.o:function $s11tmpftmlbvsz15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded > 0.5 {\n        return Int(rounded + 1)\n    } else if number - rounded\
    \ < -0.5 {\n        return Int(rounded - 1)\n    } else {\n        return Int(rounded)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp8iv1zy5p.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdus47ffw/tmpdus47ffw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d4b12ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4ae21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4ae21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d4ae207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdus47ffw                        0x000055db3df7f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9d4b316460 __libc_start_main +
    245

    6    tmpdus47ffw                        0x000055db3df7f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    let floorDiff = abs(floor - value)\n    let ceilDiff\
    \ = abs(ceil - value)\n    if floorDiff == ceilDiff {\n        return floor >\
    \ 0 ? floor : ceil\n    }\n    return floorDiff < ceilDiff ? floor : ceil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp21zae0vv.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmp21zae0vv.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmp21zae0vv.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmp21zae0vv.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdus47ffw/tmpdus47ffw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d4b12ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4ae21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4ae21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d4ae207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdus47ffw                        0x000055db3df7f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9d4b316460 __libc_start_main +
    245

    6    tmpdus47ffw                        0x000055db3df7f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(floor(number))\n    let ceil = Int(ceil(number))\n    if rounded - Double(floor)\
    \ == 0.5 {\n        return floor\n    } else if rounded - Double(ceil) == 0.5\
    \ {\n        return ceil\n    } else {\n        return Int(rounded)\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpm1kg1xkj.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpm1kg1xkj.swift:18:21:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ Int(floor(number))\n                    ^\n/tmp/tmpm1kg1xkj.swift:18:9: note:\
    \ 'floor' declared here\n    let floor = Int(floor(number))\n        ^\n/tmp/tmpm1kg1xkj.swift:19:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(number))\n\
    \                   ^\n/tmp/tmpm1kg1xkj.swift:19:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014090
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let ceiled\
    \ = number.rounded(.up)\n    let floored = number.rounded(.down)\n    let diffRounded\
    \ = abs(number - rounded)\n    let diffCeiled = abs(number - ceiled)\n    let\
    \ diffFloored = abs(number - floored)\n    if diffRounded < diffCeiled && diffRounded\
    \ < diffFloored {\n        return Int(rounded)\n    } else if diffCeiled < diffFloored\
    \ {\n        return Int(ceiled)\n    } else {\n        return Int(floored)\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.NaWcZD/tmp7n92f6hv-1.o:tmp7n92f6hv-1.o:function $s11tmp7n92f6hv15closest_i'
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdus47ffw/tmpdus47ffw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d4b12ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4ae21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4ae21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d4ae207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdus47ffw                        0x000055db3df7f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9d4b316460 __libc_start_main +
    245

    6    tmpdus47ffw                        0x000055db3df7f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpyxarxh2j/tmpyxarxh2j.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37090e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3708ddab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3708dda988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3708dd97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyxarxh2j                        0x00005578ab219512 <unavailable> + 5394

    5    libc.so.6                          0x00002b37092cf460 __libc_start_main +
    245

    6    tmpyxarxh2j                        0x00005578ab219049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value)\n    let intValue = Int(floatValue!)\n    let\
    \ decimalValue = floatValue! - Float(intValue)\n    if decimalValue >= 0.5 {\n\
    \        return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmppy_f6zhf/tmppy_f6zhf.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1fe7ca4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1fe799bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1fe799b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1fe799a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppy_f6zhf                        0x000055823dde9512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1fe7e90460 __libc_start_main +
    245

    6    tmppy_f6zhf                        0x000055823dde9049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdus47ffw/tmpdus47ffw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d4b12ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4ae21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4ae21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d4ae207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdus47ffw                        0x000055db3df7f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9d4b316460 __libc_start_main +
    245

    6    tmpdus47ffw                        0x000055db3df7f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptcn1q0sk.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmptcn1q0sk.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmptcn1q0sk.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmptcn1q0sk.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let roundedInt\
    \ = Int(rounded)\n    let roundedDouble = Double(roundedInt)\n    if number >\
    \ roundedDouble {\n        return roundedInt + 1\n    } else if number < roundedDouble\
    \ {\n        return roundedInt - 1\n    } else {\n        return roundedInt\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_4e2nu2i.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    let decimal\
    \ = number - Double(intNumber)\n    if decimal >= 0.5 {\n        return intNumber\
    \ + 1\n    } else {\n        return intNumber\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpntagneqd/tmpntagneqd.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae784f49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae784c40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae784c40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae784c3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpntagneqd                        0x000055b4a6195512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae785135460 __libc_start_main +
    245

    6    tmpntagneqd                        0x000055b4a6195049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) < Double(ceil) - number {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpx8n0yplx.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    if number\
    \ - rounded < 0.5 {\n        return Int(rounded)\n    } else {\n        return\
    \ Int(rounded + 1)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp1aw14svb.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(rounded)\n    let ceil = Int(rounded) + 1\n    let diffFloor = abs(number\
    \ - Double(floor))\n    let diffCeil = abs(number - Double(ceil))\n    if diffFloor\
    \ < diffCeil {\n        return floor\n    } else {\n        return ceil\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpupwc0fip.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diffFloor = abs(number - Double(floor))\n    let\
    \ diffCeil = abs(number - Double(ceil))\n    if diffFloor < diffCeil {\n     \
    \   return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpgncsedhp.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpgncsedhp.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpgncsedhp.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpgncsedhp.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let integer\
    \ = Int(rounded)\n    return integer\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7ratgvlt.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ ceiled = Int(number.rounded(.up))\n    let floored = Int(number.rounded(.down))\n\
    \    let diff1 = abs(number - Double(rounded))\n    let diff2 = abs(number - Double(ceiled))\n\
    \    let diff3 = abs(number - Double(floored))\n    if diff1 <= diff2 && diff1\
    \ <= diff3 {\n        return rounded\n    } else if diff2 <= diff1 && diff2 <=\
    \ diff3 {\n        return ceiled\n    } else {\n        return floored\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ySq6JM/tmph2ck9r3w-1.o:tmph2ck9r3w-1.o:function $s11tmph2ck9r3w15closest_i'
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    return\
    \ rounded\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpwzfw5d5v.swift:17:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ ceiled = Int(number.rounded(.up))\n    let floored = Int(number.rounded(.down))\n\
    \    let diffRounded = abs(number - Double(rounded))\n    let diffCeiled = abs(number\
    \ - Double(ceiled))\n    let diffFloored = abs(number - Double(floored))\n   \
    \ if diffRounded == diffCeiled {\n        return ceiled\n    } else if diffRounded\
    \ == diffFloored {\n        return floored\n    } else {\n        return rounded\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.npybbM/tmpy5six808-1.o:tmpy5six808-1.o:function $s11tmpy5six80815closest_i'
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    return Int(doubleValue! + (doubleValue!\
    \ > 0 ? 0.5 : -0.5))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value)\n    let intValue = Int(floatValue!)\n    let\
    \ decimal = floatValue! - Float(intValue)\n    if decimal >= 0.5 {\n        return\
    \ intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpqea6dhii/tmpqea6dhii.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bff890c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bff587b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4bff587988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4bff5867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqea6dhii                        0x000055e950c9a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b4bffa7c460 __libc_start_main +
    245

    6    tmpqea6dhii                        0x000055e950c9a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal >= 0.5 {\n        return integer\
    \ + 1\n    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp7p2dpiai/tmp7p2dpiai.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19538cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19535c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19535c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19535c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7p2dpiai                        0x000055ed4c25a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1953abb460 __libc_start_main +
    245

    6    tmp7p2dpiai                        0x000055ed4c25a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) < Double(ceil) - number {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpx8n0yplx.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0yplx-1.o:tmpx8n0yplx-1.o:function\
    \ $s11tmpx8n0yplx15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.j9iMoG/tmpx8n0"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = Int(floor(value))\n    let ceil\
    \ = Int(ceil(value))\n    let diff_floor = abs(value - Double(floor))\n    let\
    \ diff_ceil = abs(value - Double(ceil))\n    return diff_floor < diff_ceil ? floor\
    \ : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpjfs_vclc.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(value))\n                    ^\n\
    /tmp/tmpjfs_vclc.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(value))\n\
    \        ^\n/tmp/tmpjfs_vclc.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(value))\n                  \
    \ ^\n/tmp/tmpjfs_vclc.swift:18:9: note: 'ceil' declared here\n    let ceil = Int(ceil(value))\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpo_8igpza/tmpo_8igpza.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002aef1d24dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef1cf44561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aef1cf44286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aef1cf4413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aef1cf43bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpo_8igpza                        0x00005623a981375a <unavailable> + 5978

    6    tmpo_8igpza                        0x00005623a98133dd <unavailable> + 5085

    7    libc.so.6                          0x00002aef1d439460 __libc_start_main +
    245

    8    tmpo_8igpza                        0x00005623a9813039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n    let\
    \ floor_diff = abs(number - Double(floor))\n    let ceil_diff = abs(number - Double(ceil))\n\
    \    if floor_diff == ceil_diff {\n        return number > 0 ? ceil : floor\n\
    \    }\n    return floor_diff < ceil_diff ? floor : ceil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmphiw1sbt6.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value)\n    let intValue = Int(floatValue!)\n    let\
    \ decimal = floatValue! - Float(intValue)\n    if decimal >= 0.5 {\n        return\
    \ intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpqea6dhii/tmpqea6dhii.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bff890c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bff587b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4bff587988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4bff5867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqea6dhii                        0x000055e950c9a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b4bffa7c460 __libc_start_main +
    245

    6    tmpqea6dhii                        0x000055e950c9a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    if number - Double(floor) == 0.5 {\n        return floor\n    } else if number\
    \ - Double(ceil) == -0.5 {\n        return ceil\n    } else {\n        return\
    \ rounded\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.jYWtI4/tmpugfa3jg7-1.o:tmpugfa3jg7-1.o:function $s11tmpugfa3jg715closest_i'
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpyxarxh2j/tmpyxarxh2j.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37090e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3708ddab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3708dda988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3708dd97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyxarxh2j                        0x00005578ab219512 <unavailable> + 5394

    5    libc.so.6                          0x00002b37092cf460 __libc_start_main +
    245

    6    tmpyxarxh2j                        0x00005578ab219049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptcn1q0sk.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmptcn1q0sk.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmptcn1q0sk.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmptcn1q0sk.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmptwk4e0ax/tmptwk4e0ax.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab74939fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab749096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab749096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7490957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptwk4e0ax                        0x000055aa69f5e512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab74958b460 __libc_start_main +
    245

    6    tmptwk4e0ax                        0x000055aa69f5e049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer = Int(number)\n    let decimal\
    \ = number - Double(integer)\n    if decimal < 0.5 {\n        return integer\n\
    \    } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpzjjdb8la/tmpzjjdb8la.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac03b4a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac03b19eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac03b19e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac03b19d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzjjdb8la                        0x0000558cec20a512 <unavailable> + 5394

    5    libc.so.6                          0x00002ac03b693460 __libc_start_main +
    245

    6    tmpzjjdb8la                        0x0000558cec20a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let ceiled\
    \ = ceil(number)\n    let floored = floor(number)\n    if rounded - number ==\
    \ 0.5 {\n        return Int(ceiled)\n    } else if number - rounded == 0.5 {\n\
    \        return Int(floored)\n    } else {\n        return Int(rounded)\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqdt2t9mx.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpqdt2t9mx.swift:18:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(number)\n        \
    \         ^~~~\n/tmp/tmpqdt2t9mx.swift:19:19: error: cannot find 'floor' in scope\n\
    \    let floored = floor(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    let decimal\
    \ = number - Double(intNumber)\n    if decimal >= 0.5 {\n        return intNumber\
    \ + 1\n    } else {\n        return intNumber\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpntagneqd/tmpntagneqd.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae784f49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae784c40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae784c40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae784c3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpntagneqd                        0x000055b4a6195512 <unavailable> + 5394

    5    libc.so.6                          0x00002ae785135460 __libc_start_main +
    245

    6    tmpntagneqd                        0x000055b4a6195049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    return Int(doubleValue! + 0.5)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpbfaexmcg/tmpbfaexmcg.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b62f10fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b62f0df5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b62f0df5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b62f0df47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbfaexmcg                        0x0000556621c88512 <unavailable> + 5394

    5    libc.so.6                          0x00002b62f12ea460 __libc_start_main +
    245

    6    tmpbfaexmcg                        0x0000556621c88049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilingDiff = abs(number\
    \ - Double(ceiling))\n    if floorDiff == ceilingDiff {\n        return rounded\
    \ > 0 ? ceiling : floor\n    }\n    return floorDiff < ceilingDiff ? floor : ceiling\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.94UW6V/tmp0r59_qi7-1.o:tmp0r59_qi7-1.o:function $s11tmp0r59_qi715closest_i'
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    let intValue = Int(roundedValue)\n    return intValue\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp14hbj1lh.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimal = doubleValue! - Double(intValue)\n    if decimal >= 0.5 {\n   \
    \     return intValue + 1\n    } else {\n        return intValue\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpyxarxh2j/tmpyxarxh2j.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37090e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3708ddab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3708dda988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3708dd97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyxarxh2j                        0x00005578ab219512 <unavailable> + 5394

    5    libc.so.6                          0x00002b37092cf460 __libc_start_main +
    245

    6    tmpyxarxh2j                        0x00005578ab219049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff1 = abs(number - Double(floor))\n    let diff2\
    \ = abs(number - Double(ceil))\n    if diff1 < diff2 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp5reikjie.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmp5reikjie.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmp5reikjie.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmp5reikjie.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let int\
    \ = Int(rounded)\n    let decimal = rounded - Double(int)\n    if decimal == 0.5\
    \ {\n        if int > 0 {\n            return int + 1\n        } else {\n    \
    \        return int - 1\n        }\n    }\n    return int\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.bBzwHY/tmpxhckhkdw-1.o:tmpxhckhkdw-1.o:function $s11tmpxhckhkdw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.bBzwHY/tmpxhckhkdw-1.o:tmpxhckhkdw-1.o:function $s11tmpxhckhkdw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.bBzwHY/tmpxhckhkdw-1.o:tmpxhckhkdw-1.o:function $s11tmpxhckhkdw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.bBzwHY/tmpxhckhkdw-1.o:tmpxhckhkdw-1.o:function $s11tmpxhckhkdw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.bBzwHY/tmpxhckhkdw-1.o:tmpxhckhkdw-1.o:function $s11tmpxhckhkdw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.bBzwHY/tmpxhckhkdw-1.o:tmpxhckhkdw-1.o:function $s11tmpxhckhkdw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.bBzwHY/tmpxhckhkdw-1.o:tmpxhckhkdw-1.o:function $s11tmpxhckhkdw15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp92yrj2y6.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceil = Int(number.rounded(.up))\n\
    \    let floor_diff = abs(number - Double(floor))\n    let ceil_diff = abs(number\
    \ - Double(ceil))\n    if floor_diff == ceil_diff {\n        return number < 0\
    \ ? floor : ceil\n    }\n    return floor_diff < ceil_diff ? floor : ceil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2nohs2pt.swift:17:9: warning: initialization of immutable value\
    \ 'rounded' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let rounded = Int(number.rounded())\n    ~~~~^~~~~~~\n    _\nerror:\
    \ link command failed with exit code 1 (use -v to see invocation)\n/tmp/TemporaryDirectory.chZiXZ/tmp2nohs2pt-1.o:tmp2nohs2pt-1.o:function\
    \ $s11tmp2nohs2pt15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.chZiXZ/tmp2nohs2pt-1.o:tmp2nohs2pt-1.o:function\
    \ $s11tmp2nohs2pt15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.chZiXZ/tmp2nohs2pt-1.o:tmp2nohs2pt-1.o:function\
    \ $s11tmp2nohs2pt15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.chZiXZ/tmp2nohs2pt-1.o:tmp2nohs2pt-1.o:function\
    \ $s11tmp2nohs2pt15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.chZiXZ/tmp2nohs2pt-1.o:tmp2nohs2pt-1.o:function\
    \ $s11tmp2nohs2pt15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.chZiXZ/tmp2nohs2pt-1.o:tmp2nohs2pt-1.o:function\
    \ $s11tmp2nohs2pt15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'floor'\n/tmp/TemporaryDirectory.chZiXZ/tmp2nohs2pt-1.o:tmp2nohs2pt-1.o:function\
    \ $s11tmp2nohs2pt15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.chZiXZ/tmp2nohs2pt-1.o:tmp2nohs2pt-1.o:function\
    \ $s11tmp2nohs2pt15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'round'\n/tmp/TemporaryDirectory.chZiXZ/tmp2nohs2pt-1.o:tmp2nohs2pt-1.o:function\
    \ $s11tmp2nohs2pt15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'rint'\n/tmp/TemporaryDirectory.chZiXZ/tmp2nohs2pt-1.o:tmp2nohs2pt-1.o:function\
    \ $s11tmp2nohs2pt15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'trunc'\n/tmp/TemporaryDirectory.chZiXZ/tmp2nohs2pt-1.o:tmp2nohs2pt-1.o:function\
    \ $s11tmp2nohs2pt15closest_integer5valueSiSS_tF: error: undefined reference to\
    \ 'ceil'\n/tmp/TemporaryDirectory.chZiXZ/tmp2noh"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let int\
    \ = Int(rounded)\n    let decimal = rounded - Double(int)\n    if decimal > 0.5\
    \ {\n        return int + 1\n    } else if decimal < -0.5 {\n        return int\
    \ - 1\n    } else {\n        return int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.iHnXp0/tmpjoajd5yh-1.o:tmpjoajd5yh-1.o:function $s11tmpjoajd5yh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.iHnXp0/tmpjoajd5yh-1.o:tmpjoajd5yh-1.o:function $s11tmpjoajd5yh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.iHnXp0/tmpjoajd5yh-1.o:tmpjoajd5yh-1.o:function $s11tmpjoajd5yh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.iHnXp0/tmpjoajd5yh-1.o:tmpjoajd5yh-1.o:function $s11tmpjoajd5yh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.iHnXp0/tmpjoajd5yh-1.o:tmpjoajd5yh-1.o:function $s11tmpjoajd5yh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.iHnXp0/tmpjoajd5yh-1.o:tmpjoajd5yh-1.o:function $s11tmpjoajd5yh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.iHnXp0/tmpjoajd5yh-1.o:tmpjoajd5yh-1.o:function $s11tmpjoajd5yh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    return Int(doubleValue! + 0.5)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpbfaexmcg/tmpbfaexmcg.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b62f10fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b62f0df5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b62f0df5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b62f0df47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbfaexmcg                        0x0000556621c88512 <unavailable> + 5394

    5    libc.so.6                          0x00002b62f12ea460 __libc_start_main +
    245

    6    tmpbfaexmcg                        0x0000556621c88049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let intValue\
    \ = Int(rounded)\n    if number - Double(intValue) >= 0.5 {\n        return intValue\
    \ + 1\n    } else {\n        return intValue\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var result = 0\n    let number = Double(value)\n    if number != nil {\n  \
    \      result = Int(number! + 0.5)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpgh84idu1/tmpgh84idu1.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5f6f21ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5f6ef15b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5f6ef15988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5f6ef147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgh84idu1                        0x0000557950154512 <unavailable> + 5394

    5    libc.so.6                          0x00002b5f6f40a460 __libc_start_main +
    245

    6    tmpgh84idu1                        0x0000557950154049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let intNumber = Int(number)\n    if number\
    \ - Double(intNumber) < 0.5 {\n        return intNumber\n    } else {\n      \
    \  return intNumber + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpjczrwxlo/tmpjczrwxlo.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3303365c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b330305cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b330305c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b330305b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjczrwxlo                        0x000055b91b592512 <unavailable> + 5394

    5    libc.so.6                          0x00002b3303551460 __libc_start_main +
    245

    6    tmpjczrwxlo                        0x000055b91b592049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(round(Double(value)!))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpsnrcf7eg.swift:16:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(Double(value)!))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let int =\
    \ Int(rounded)\n    if rounded - Double(int) > 0.5 {\n        return int + 1\n\
    \    } else {\n        return int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_06fj549.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    return Int(rounded)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp92yrj2y6.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue < 0.5\
    \ {\n        return intValue\n    } else {\n        return intValue + 1\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpinl_dbuy/tmpinl_dbuy.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aefeab44c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aefea83bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aefea83b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aefea83a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpinl_dbuy                        0x000055a1e2717512 <unavailable> + 5394

    5    libc.so.6                          0x00002aefead30460 __libc_start_main +
    245

    6    tmpinl_dbuy                        0x000055a1e2717049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpo_8igpza/tmpo_8igpza.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002aef1d24dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef1cf44561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aef1cf44286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aef1cf4413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aef1cf43bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpo_8igpza                        0x00005623a981375a <unavailable> + 5978

    6    tmpo_8igpza                        0x00005623a98133dd <unavailable> + 5085

    7    libc.so.6                          0x00002aef1d439460 __libc_start_main +
    245

    8    tmpo_8igpza                        0x00005623a9813039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptcn1q0sk.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmptcn1q0sk.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmptcn1q0sk.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmptcn1q0sk.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    if number - Double(floor) < Double(ceil) - number {\n\
    \        return floor\n    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptcn1q0sk.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmptcn1q0sk.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmptcn1q0sk.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmptcn1q0sk.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let intValue = Int(doubleValue!)\n   \
    \ let decimalValue = doubleValue! - Double(intValue)\n    if decimalValue >= 0.5\
    \ {\n        return intValue + 1\n    } else {\n        return intValue\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdus47ffw/tmpdus47ffw.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d4b12ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4ae21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4ae21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d4ae207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdus47ffw                        0x000055db3df7f512 <unavailable> + 5394

    5    libc.so.6                          0x00002b9d4b316460 __libc_start_main +
    245

    6    tmpdus47ffw                        0x000055db3df7f049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let int = Int(number)\n    let decimal = number\
    \ - Double(int)\n    if decimal >= 0.5 {\n        return int + 1\n    } else {\n\
    \        return int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpugpp03d6/tmpugpp03d6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57e747dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57e7174b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57e7174988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57e71737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpugpp03d6                        0x000055652a611512 <unavailable> + 5394

    5    libc.so.6                          0x00002b57e7669460 __libc_start_main +
    245

    6    tmpugpp03d6                        0x000055652a611049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let floor = Int(floor(num))\n    let ceil = Int(ceil(num))\n\
    \    let diff1 = abs(num - Double(floor))\n    let diff2 = abs(num - Double(ceil))\n\
    \    if diff1 < diff2 {\n        return floor\n    } else {\n        return ceil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpmuepxtpf.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(num))\n                    ^\n/tmp/tmpmuepxtpf.swift:17:9:\
    \ note: 'floor' declared here\n    let floor = Int(floor(num))\n        ^\n/tmp/tmpmuepxtpf.swift:18:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(num))\n\
    \                   ^\n/tmp/tmpmuepxtpf.swift:18:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(num))\n        ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff1 = abs(number - Double(floor))\n    let diff2\
    \ = abs(number - Double(ceil))\n    if diff1 < diff2 {\n        return floor\n\
    \    } else {\n        return ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp5reikjie.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmp5reikjie.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmp5reikjie.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmp5reikjie.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    let decimal = num - Double(int)\n\
    \    if decimal >= 0.5 {\n        return int + 1\n    } else {\n        return\
    \ int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmptwk4e0ax/tmptwk4e0ax.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab74939fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab749096b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab749096988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7490957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptwk4e0ax                        0x000055aa69f5e512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab74958b460 __libc_start_main +
    245

    6    tmptwk4e0ax                        0x000055aa69f5e049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QH4WED/tmpuikicvzn-1.o:tmpuikicvzn-1.o:function $s11tmpuikicvzn15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(number.rounded())\n    let\
    \ floor = Int(number.rounded(.down))\n    let ceiling = Int(number.rounded(.up))\n\
    \    let floorDiff = abs(number - Double(floor))\n    let ceilingDiff = abs(number\
    \ - Double(ceiling))\n    if floorDiff == ceilingDiff {\n        return rounded\n\
    \    } else if floorDiff < ceilingDiff {\n        return floor\n    } else {\n\
    \        return ceiling\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.21Lan6/tmp33t79n80-1.o:tmp33t79n80-1.o:function $s11tmp33t79n8015closest_i'
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let floor = Int(floor(number))\n    let ceil\
    \ = Int(ceil(number))\n    let diff1 = abs(number - Double(floor))\n    let diff2\
    \ = abs(number - Double(ceil))\n    if diff1 == diff2 {\n        return number\
    \ > 0 ? ceil : floor\n    }\n    return diff1 < diff2 ? floor : ceil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpy5tcrqv0.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(number))\n                    ^\n\
    /tmp/tmpy5tcrqv0.swift:17:9: note: 'floor' declared here\n    let floor = Int(floor(number))\n\
    \        ^\n/tmp/tmpy5tcrqv0.swift:18:20: error: use of local variable 'ceil'\
    \ before its declaration\n    let ceil = Int(ceil(number))\n                 \
    \  ^\n/tmp/tmpy5tcrqv0.swift:18:9: note: 'ceil' declared here\n    let ceil =\
    \ Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = doubleValue!.rounded()\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.Be2iF4/tmpcn1pev93-1.o:tmpcn1pev93-1.o:function $s11tmpcn1pev9315closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    let roundedValue = round(doubleValue!)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj9_1zxmc.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let roundedValue = round(doubleValue!)\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = number.rounded()\n    let intValue\
    \ = Int(rounded)\n    if number - Double(intValue) >= 0.5 {\n        return intValue\
    \ + 1\n    } else {\n        return intValue\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.3frc4Z/tmppaskyfv2-1.o:tmppaskyfv2-1.o:function $s11tmppaskyfv215closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let floor\
    \ = Int(rounded.rounded(.down))\n    let ceil = Int(rounded.rounded(.up))\n  \
    \  if abs(number - Double(floor)) == abs(number - Double(ceil)) {\n        return\
    \ number > 0 ? ceil : floor\n    }\n    return number > 0 ? floor : ceil\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpg81cnxh8.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmpg81cnxh8.swift:18:38:\
    \ error: cannot infer contextual base in reference to member 'down'\n    let floor\
    \ = Int(rounded.rounded(.down))\n                                    ~^~~~\n/tmp/tmpg81cnxh8.swift:19:37:\
    \ error: cannot infer contextual base in reference to member 'up'\n    let ceil\
    \ = Int(rounded.rounded(.up))\n                                   ~^~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = Int(round(number))\n    let\
    \ floor = Int(floor(number))\n    let ceil = Int(ceil(number))\n    if abs(number\
    \ - Double(rounded)) < abs(number - Double(floor)) {\n        return rounded\n\
    \    } else if abs(number - Double(rounded)) < abs(number - Double(ceil)) {\n\
    \        return rounded\n    } else if abs(number - Double(floor)) < abs(number\
    \ - Double(ceil)) {\n        return floor\n    } else {\n        return ceil\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_x3fw97r.swift:17:23: error: cannot find 'round' in scope\n   \
    \ let rounded = Int(round(number))\n                      ^~~~~\n/tmp/tmp_x3fw97r.swift:18:21:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ Int(floor(number))\n                    ^\n/tmp/tmp_x3fw97r.swift:18:9: note:\
    \ 'floor' declared here\n    let floor = Int(floor(number))\n        ^\n/tmp/tmp_x3fw97r.swift:19:20:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = Int(ceil(number))\n\
    \                   ^\n/tmp/tmp_x3fw97r.swift:19:9: note: 'ceil' declared here\n\
    \    let ceil = Int(ceil(number))\n        ^\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let rounded = round(num)\n    let diff = abs(num\
    \ - rounded)\n    if diff == 0.5 {\n        return Int(num > 0 ? rounded + 1 :\
    \ rounded - 1)\n    }\n    return Int(rounded)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpt3uxwdxo.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(num)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(\"\
    10\")\n/// 10\n/// >>> closest_integer(\"15.3\")\n/// 15\n/// Note:\n/// Rounding\
    \ away from zero means that if the given number is equidistant\n/// from two integers,\
    \ the one you should return is the one that is the\n/// farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)\n    return Int(doubleValue!.rounded(.awayFromZero))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.TNX0M6/tmp7frs6n8n-1.o:tmp7frs6n8n-1.o:function $s11tmp7frs6n8n15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.TNX0M6/tmp7frs6n8n-1.o:tmp7frs6n8n-1.o:function $s11tmp7frs6n8n15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.TNX0M6/tmp7frs6n8n-1.o:tmp7frs6n8n-1.o:function $s11tmp7frs6n8n15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.TNX0M6/tmp7frs6n8n-1.o:tmp7frs6n8n-1.o:function $s11tmp7frs6n8n15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TNX0M6/tmp7frs6n8n-1.o:tmp7frs6n8n-1.o:function $s11tmp7frs6n8n15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TNX0M6/tmp7frs6n8n-1.o:tmp7frs6n8n-1.o:function $s11tmp7frs6n8n15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TNX0M6/tmp7frs6n8n-1.o:tmp7frs6n8n-1.o:function $s11tmp7frs6n8n15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014089
