language: swift
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let diff = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / diff }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1r3mdq_5.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp1r3mdq_5.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { (number) ->\
    \ Double in\n        return (number - min_number) / range\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmponlvl3nc.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmponlvl3nc.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min) / (max - min) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbh5kwzfw.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpbh5kwzfw.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let diff = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / diff }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1r3mdq_5.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp1r3mdq_5.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min = numbers.minElement()!\n    let\
    \ max = numbers.maxElement()!\n    for number in numbers {\n        result.append((number\
    \ - min) / (max - min))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdi0p7lq_.swift:8:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpdi0p7lq_.swift:9:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { (number) -> Double in\n \
    \       return (number - min) / range\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_k2861y2.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp_k2861y2.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min) / (max - min) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbh5kwzfw.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpbh5kwzfw.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min) / (max - min) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbh5kwzfw.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpbh5kwzfw.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { (number) ->\
    \ Double in\n        (number - min_number) / range\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp5y_ofzl8.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5y_ofzl8.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    if numbers.count < 2 {\n        return numbers\n    }\n    let min_number\
    \ = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n    let\
    \ range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqjvo7vkq.swift:10:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqjvo7vkq.swift:11:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_val = numbers.minElement()!\n    let max_val = numbers.maxElement()!\n\
    \    let range = max_val - min_val\n    return numbers.map { ($0 - min_val) /\
    \ range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq_nv6aij.swift:7:27: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_val = numbers.minElement()!\n                  ~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpq_nv6aij.swift:8:27: error: value of type '[Double]' has\
    \ no member 'maxElement'\n    let max_val = numbers.maxElement()!\n          \
    \        ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { (number) -> Double in\n        return (number - min_number)\
    \ / (max_number - min_number)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkwsfl9ec.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpkwsfl9ec.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { (number) -> Double in\n        return (number - min_number)\
    \ / (max_number - min_number)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkwsfl9ec.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpkwsfl9ec.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { (number) ->\
    \ Double in\n        (number - min_number) / range\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp5y_ofzl8.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5y_ofzl8.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { (number) -> Double in\n \
    \       (number - min) / range\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmprtokmjjl.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmprtokmjjl.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else {\n        return numbers\n    }\n    let\
    \ min = numbers.min()!\n    let max = numbers.max()!\n    let range = max - min\n\
    \    return numbers.map { ($0 - min) / range }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { (number) -> Double in\n        return (number - min_number)\
    \ / (max_number - min_number)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkwsfl9ec.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpkwsfl9ec.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { (number) ->\
    \ Double in\n        return (number - min_number) / range\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmponlvl3nc.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmponlvl3nc.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let diff = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / diff }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1r3mdq_5.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp1r3mdq_5.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let diff = max - min\n    return numbers.map { ($0 - min) / diff }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0rmiprog.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp0rmiprog.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min) / (max - min) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbh5kwzfw.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpbh5kwzfw.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result: [Double] = []\n    let min_number = numbers.minElement()!\n\
    \    let max_number = numbers.maxElement()!\n    for number in numbers {\n   \
    \     result.append((number - min_number) / (max_number - min_number))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpf26l2kd4.swift:8:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpf26l2kd4.swift:9:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min) / (max - min) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbh5kwzfw.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpbh5kwzfw.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min = numbers.minElement()!\n    let\
    \ max = numbers.maxElement()!\n    for number in numbers {\n        result.append((number\
    \ - min) / (max - min))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdi0p7lq_.swift:8:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpdi0p7lq_.swift:9:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min_number = numbers.minElement()!\n\
    \    let max_number = numbers.maxElement()!\n    for number in numbers {\n   \
    \     result.append((number - min_number) / (max_number - min_number))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq932qhq5.swift:8:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpq932qhq5.swift:9:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { (number) ->\
    \ Double in\n        return (number - min_number) / range\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmponlvl3nc.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmponlvl3nc.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min) / (max - min) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbh5kwzfw.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpbh5kwzfw.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_num = numbers.minElement()!\n    let max_num = numbers.maxElement()!\n\
    \    let diff = max_num - min_num\n    return numbers.map { ($0 - min_num) / diff\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0,\
    \ 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0,\
    \ 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25,\
    \ 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0])\
    \ == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0,\
    \ 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp3pkc212m.swift:7:27: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_num = numbers.minElement()!\n                  ~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp3pkc212m.swift:8:27: error: value of type '[Double]' has\
    \ no member 'maxElement'\n    let max_num = numbers.maxElement()!\n          \
    \        ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min_number = numbers.minElement()!\n\
    \    let max_number = numbers.maxElement()!\n    for number in numbers {\n   \
    \     result.append((number - min_number) / (max_number - min_number))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq932qhq5.swift:8:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpq932qhq5.swift:9:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { (number) ->\
    \ Double in\n        return (number - min_number) / range\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmponlvl3nc.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmponlvl3nc.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result: [Double] = []\n    let min_number = numbers.minElement()!\n\
    \    let max_number = numbers.maxElement()!\n    for number in numbers {\n   \
    \     result.append((number - min_number) / (max_number - min_number))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpf26l2kd4.swift:8:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpf26l2kd4.swift:9:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min_number = numbers.minElement()!\n\
    \    let max_number = numbers.maxElement()!\n    for number in numbers {\n   \
    \     result.append((number - min_number) / (max_number - min_number))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq932qhq5.swift:8:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpq932qhq5.swift:9:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { (number) ->\
    \ Double in\n        return (number - min_number) / range\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmponlvl3nc.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmponlvl3nc.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { (number) ->\
    \ Double in\n        (number - min_number) / range\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp5y_ofzl8.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5y_ofzl8.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min_number = numbers.minElement()!\n\
    \    let max_number = numbers.maxElement()!\n    for number in numbers {\n   \
    \     result.append((number - min_number) / (max_number - min_number))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq932qhq5.swift:8:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpq932qhq5.swift:9:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min_number = numbers.minElement()!\n\
    \    let max_number = numbers.maxElement()!\n    for number in numbers {\n   \
    \     result.append((number - min_number) / (max_number - min_number))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq932qhq5.swift:8:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpq932qhq5.swift:9:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_val = numbers.minElement()!\n    let max_val = numbers.maxElement()!\n\
    \    let diff = max_val - min_val\n    return numbers.map { ($0 - min_val) / diff\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers: [2.0,\
    \ 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0,\
    \ 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25,\
    \ 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0, 3.0, 4.0])\
    \ == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers: [12.0, 11.0,\
    \ 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq90uetio.swift:7:27: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_val = numbers.minElement()!\n                  ~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpq90uetio.swift:8:27: error: value of type '[Double]' has\
    \ no member 'maxElement'\n    let max_val = numbers.maxElement()!\n          \
    \        ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min = numbers.minElement()!\n    let\
    \ max = numbers.maxElement()!\n    for n in numbers {\n        result.append((n\
    \ - min) / (max - min))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpm89549rx.swift:8:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpm89549rx.swift:9:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let max_number = numbers.maxElement()!\n    let min_number = numbers.minElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { (number) ->\
    \ Double in\n        return (number - min_number) / range\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp5dg_4nqt.swift:7:30: error: value of type '[Double]' has no member\
    \ 'maxElement'\n    let max_number = numbers.maxElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5dg_4nqt.swift:8:30: error: value of type '[Double]'\
    \ has no member 'minElement'\n    let min_number = numbers.minElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let diff = max - min\n    return numbers.map { ($0 - min) / diff }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0rmiprog.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp0rmiprog.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min) / (max - min) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbh5kwzfw.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpbh5kwzfw.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min_val = numbers.minElement()!\n  \
    \  let max_val = numbers.maxElement()!\n    for number in numbers {\n        result.append((number\
    \ - min_val) / (max_val - min_val))\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpt7otuz92.swift:8:27: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_val = numbers.minElement()!\n                  ~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpt7otuz92.swift:9:27: error: value of type '[Double]' has\
    \ no member 'maxElement'\n    let max_val = numbers.maxElement()!\n          \
    \        ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min_number = numbers.minElement()!\n\
    \    let max_number = numbers.maxElement()!\n    let range = max_number - min_number\n\
    \    for number in numbers {\n        result.append((number - min_number) / range)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpoicwq0wd.swift:8:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpoicwq0wd.swift:9:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min_number = numbers.minElement()!\n\
    \    let max_number = numbers.maxElement()!\n    for number in numbers {\n   \
    \     result.append((number - min_number) / (max_number - min_number))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq932qhq5.swift:8:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpq932qhq5.swift:9:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    return numbers.map { (number) -> Double in\n        return (number - min_value)\
    \ / (max_value - min_value)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpl5e8xarc.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpl5e8xarc.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_value) / (max_value - min_value) }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0xh4qsko.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp0xh4qsko.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let diff = max - min\n    return numbers.map { ($0 - min) / diff }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0rmiprog.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp0rmiprog.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min = numbers.minElement()!\n    let\
    \ max = numbers.maxElement()!\n    let scale = 1.0 / (max - min)\n    for number\
    \ in numbers {\n        result.append((number - min) * scale)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp78g64mps.swift:8:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp78g64mps.swift:9:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp78g64mps.swift:10:21:\
    \ error: binary operator '/' cannot be applied to operands of type 'Double' and\
    \ 'Duration'\n    let scale = 1.0 / (max - min)\n                ~~~ ^ ~~~~~~~~~~~\n\
    /tmp/tmp78g64mps.swift:10:21: note: overloads for '/' exist with these partially\
    \ matching parameter lists: (Double, Double), (Duration, Duration)\n    let scale\
    \ = 1.0 / (max - min)\n                    ^\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let difference = max_number - min_number\n    return numbers.map { ($0 -\
    \ min_number) / difference }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpodbw_e_c.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpodbw_e_c.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let diff = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / diff }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1r3mdq_5.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp1r3mdq_5.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { (number) ->\
    \ Double in\n        return (number - min_number) / range\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmponlvl3nc.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmponlvl3nc.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_val = numbers.minElement()!\n    let max_val = numbers.maxElement()!\n\
    \    let range = max_val - min_val\n    return numbers.map { ($0 - min_val) /\
    \ range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq_nv6aij.swift:7:27: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_val = numbers.minElement()!\n                  ~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpq_nv6aij.swift:8:27: error: value of type '[Double]' has\
    \ no member 'maxElement'\n    let max_val = numbers.maxElement()!\n          \
    \        ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let delta = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / delta }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpuaownxbq.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpuaownxbq.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    return numbers.map { (n: Double) -> Double in\n        (n - min) / (max -\
    \ min)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8byuizaj.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmp8byuizaj.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min) / (max - min) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbh5kwzfw.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpbh5kwzfw.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { (number) -> Double in\n        return (number - min_number)\
    \ / (max_number - min_number)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkwsfl9ec.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpkwsfl9ec.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min) / (max - min) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbh5kwzfw.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpbh5kwzfw.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min_number = numbers.minElement()!\n\
    \    let max_number = numbers.maxElement()!\n    for number in numbers {\n   \
    \     result.append((number - min_number) / (max_number - min_number))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq932qhq5.swift:8:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpq932qhq5.swift:9:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for number\
    \ in numbers {\n        if number < min_value {\n            min_value = number\n\
    \        }\n        if number > max_value {\n            max_value = number\n\
    \        }\n    }\n    let range = max_value - min_value\n    return numbers.map\
    \ { (number) -> Double in\n        return (number - min_value) / range\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min) / (max - min) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbh5kwzfw.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpbh5kwzfw.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min_value = numbers.minElement()!\n\
    \    let max_value = numbers.maxElement()!\n    for number in numbers {\n    \
    \    result.append((number - min_value) / (max_value - min_value))\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp20sbuhi4.swift:8:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp20sbuhi4.swift:9:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { (number) -> Double in\n        (number - min_number)\
    \ / (max_number - min_number)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpikb0_ykb.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpikb0_ykb.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let max_number = numbers.maxElement()!\n    let min_number = numbers.minElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbmq_a372.swift:7:30: error: value of type '[Double]' has no member\
    \ 'maxElement'\n    let max_number = numbers.maxElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpbmq_a372.swift:8:30: error: value of type '[Double]'\
    \ has no member 'minElement'\n    let min_number = numbers.minElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min_value = numbers[0]\n    var max_value = numbers[0]\n    for number\
    \ in numbers {\n        if number < min_value {\n            min_value = number\n\
    \        }\n        if number > max_value {\n            max_value = number\n\
    \        }\n    }\n    let range = max_value - min_value\n    return numbers.map\
    \ { (number) -> Double in\n        return (number - min_value) / range\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var result = [Double]()\n    let min_number = numbers.minElement()!\n\
    \    let max_number = numbers.maxElement()!\n    for number in numbers {\n   \
    \     result.append((number - min_number) / (max_number - min_number))\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq932qhq5.swift:8:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpq932qhq5.swift:9:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min_val = numbers[0]\n    var max_val = numbers[0]\n    for number\
    \ in numbers {\n        if number < min_val {\n            min_val = number\n\
    \        }\n        if number > max_val {\n            max_val = number\n    \
    \    }\n    }\n    let range = max_val - min_val\n    return numbers.map { (number)\
    \ -> Double in\n        (number - min_val) / range\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    let range = max_value - min_value\n    return numbers.map { ($0 - min_value)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdluk_unk.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdluk_unk.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_value = numbers.minElement()!\n    let max_value = numbers.maxElement()!\n\
    \    return numbers.map { (n: Double) -> Double in\n        (n - min_value) /\
    \ (max_value - min_value)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp_r01mx8t.swift:7:29: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_value = numbers.minElement()!\n                  \
    \  ~~~~~~~ ^~~~~~~~~~\n/tmp/tmp_r01mx8t.swift:8:29: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_value = numbers.maxElement()!\n    \
    \                ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min) / (max - min) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpbh5kwzfw.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpbh5kwzfw.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    let range = max_number - min_number\n    return numbers.map { ($0 - min_number)\
    \ / range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphs_tn9ah.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmphs_tn9ah.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_val = numbers.minElement()!\n    let max_val = numbers.maxElement()!\n\
    \    let range = max_val - min_val\n    return numbers.map { ($0 - min_val) /\
    \ range }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq_nv6aij.swift:7:27: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_val = numbers.minElement()!\n                  ~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmpq_nv6aij.swift:8:27: error: value of type '[Double]' has\
    \ no member 'maxElement'\n    let max_val = numbers.maxElement()!\n          \
    \        ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_number = numbers.minElement()!\n    let max_number = numbers.maxElement()!\n\
    \    return numbers.map { ($0 - min_number) / (max_number - min_number) }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpb1i9v_mm.swift:7:30: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_number = numbers.minElement()!\n                 \
    \    ~~~~~~~ ^~~~~~~~~~\n/tmp/tmpb1i9v_mm.swift:8:30: error: value of type '[Double]'\
    \ has no member 'maxElement'\n    let max_number = numbers.maxElement()!\n   \
    \                  ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min_num = numbers.minElement()!\n    let max_num = numbers.maxElement()!\n\
    \    return numbers.map { (num: Double) -> Double in\n        (num - min_num)\
    \ / (max_num - min_num)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp73vyh01_.swift:7:27: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min_num = numbers.minElement()!\n                  ~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp73vyh01_.swift:8:27: error: value of type '[Double]' has\
    \ no member 'maxElement'\n    let max_num = numbers.maxElement()!\n          \
    \        ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = numbers.minElement()!\n    let max = numbers.maxElement()!\n\
    \    let range = max - min\n    return numbers.map { ($0 - min) / range }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg33e56ty.swift:7:23: error: value of type '[Double]' has no member\
    \ 'minElement'\n    let min = numbers.minElement()!\n              ~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpg33e56ty.swift:8:23: error: value of type '[Double]' has no member 'maxElement'\n\
    \    let max = numbers.maxElement()!\n              ~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013597
