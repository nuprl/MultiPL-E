language: swift
name: HumanEval_148_bf
results:
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let startIndex = planets.firstIndex(of: planet1) ?? -1\n \
    \   let endIndex = planets.firstIndex(of: planet2) ?? -1\n    if startIndex ==\
    \ -1 || endIndex == -1 {\n        return []\n    }\n    let result = planets[startIndex...endIndex].sorted(by:\
    \ { planets.firstIndex(of: $0)! < planets.firstIndex(of: $1)! })\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpwe_rpyru/tmpwe_rpyru.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab2a89edc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab2a86e4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab2a86e4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab2a86e37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwe_rpyru                        0x0000564a78ea285b <unavailable> + 6235

    5    libc.so.6                          0x00002ab2a8bd9460 __libc_start_main +
    245

    6    tmpwe_rpyru                        0x0000564a78ea2409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let firstIndex = planets.firstIndex(of: planet1)\n    let\
    \ secondIndex = planets.firstIndex(of: planet2)\n    if firstIndex == nil || secondIndex\
    \ == nil {\n        return []\n    }\n    if firstIndex! < secondIndex! {\n  \
    \      return Array(planets[firstIndex! + 1..<secondIndex!])\n    } else {\n \
    \       return Array(planets[secondIndex! + 1..<firstIndex!])\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b57eb44fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57eb146561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b57eb146286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b57eb14613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b57eb145bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp7c2ggdct                        0x0000557a9e8d6ba5 <unavailable> + 11173

    6    tmp7c2ggdct                        0x0000557a9e8d5e4b <unavailable> + 7755

    7    libc.so.6                          0x00002b57eb63b460 __libc_start_main +
    245

    8    tmp7c2ggdct                        0x0000557a9e8d5379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let p1 = planets.firstIndex(of: planet1)\n    let p2 = planets.firstIndex(of:\
    \ planet2)\n    if p1 == nil || p2 == nil {\n        return []\n    }\n    let\
    \ start = min(p1!, p2!)\n    let end = max(p1!, p2!)\n    return Array(planets[start...end])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp8vciu9gp/tmp8vciu9gp.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057f8d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057f5cab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057f5ca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057f5c97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8vciu9gp                        0x000055f673aa294b <unavailable> + 6475

    5    libc.so.6                          0x00002b057fabf460 __libc_start_main +
    245

    6    tmp8vciu9gp                        0x000055f673aa24f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    let start = min(index1!, index2!)\n    let end\
    \ = max(index1!, index2!)\n    return Array(planets[start...end])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpw_8ei1rd/tmpw_8ei1rd.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b80fcd35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b80fca2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b80fca2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b80fca2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw_8ei1rd                        0x0000555ad2ed294b <unavailable> + 6475

    5    libc.so.6                          0x00002b80fcf21460 __libc_start_main +
    245

    6    tmpw_8ei1rd                        0x0000555ad2ed24f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let start = min(planet1Index!,\
    \ planet2Index!)\n    let end = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[start...end])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp5o2d4v_x/tmp5o2d4v_x.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c21defc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c21ae6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c21ae6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c21ae57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5o2d4v_x                        0x0000563ba976e94b <unavailable> + 6475

    5    libc.so.6                          0x00002b4c21fdb460 __libc_start_main +
    245

    6    tmp5o2d4v_x                        0x0000563ba976e4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    let start = min(index1!, index2!)\n    let end\
    \ = max(index1!, index2!)\n    return Array(planets[start...end])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpw_8ei1rd/tmpw_8ei1rd.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b80fcd35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b80fca2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b80fca2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b80fca2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw_8ei1rd                        0x0000555ad2ed294b <unavailable> + 6475

    5    libc.so.6                          0x00002b80fcf21460 __libc_start_main +
    245

    6    tmpw_8ei1rd                        0x0000555ad2ed24f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result = [String]()\n    var start = 0\n    var end =\
    \ 0\n    for (index, planet) in planets.enumerated() {\n        if planet == planet1\
    \ {\n            start = index\n        }\n        if planet == planet2 {\n  \
    \          end = index\n        }\n    }\n    if start > end {\n        for i\
    \ in end...start {\n            result.append(planets[i])\n        }\n    } else\
    \ {\n        for i in start...end {\n            result.append(planets[i])\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpc3s8w1rm/tmpc3s8w1rm.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe4fe36c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe4fb2db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe4fb2d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe4fb2c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc3s8w1rm                        0x0000555b41157a1b <unavailable> + 6683

    5    libc.so.6                          0x00002afe50022460 __libc_start_main +
    245

    6    tmpc3s8w1rm                        0x0000555b411575c9 <unavailable> + 5577

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let first = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ second = planets.firstIndex(of: planet2) ?? -1\n    if first == -1 || second\
    \ == -1 {\n        return []\n    }\n    let min = min(first, second)\n    let\
    \ max = max(first, second)\n    return Array(planets[min...max])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpvd717wz1/tmpvd717wz1.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44e8c8dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44e8984b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44e8984988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44e89837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvd717wz1                        0x0000559e4bdfb94b <unavailable> + 6475

    5    libc.so.6                          0x00002b44e8e79460 __libc_start_main +
    245

    6    tmpvd717wz1                        0x0000559e4bdfb4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    let\
    \ result = planets[startIndex...endIndex]\n    return Array(result)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpet2gpk0k/tmpet2gpk0k.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7500753c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b750044ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b750044a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75004497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpet2gpk0k                        0x000055b382da694b <unavailable> + 6475

    5    libc.so.6                          0x00002b750093f460 __libc_start_main +
    245

    6    tmpet2gpk0k                        0x000055b382da64f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planetsSet = Set(planets)\n    guard planetsSet.contains(planet1)\
    \ && planetsSet.contains(planet2) else {\n        return []\n    }\n    let startIndex\
    \ = planets.firstIndex(of: planet1)!\n    let endIndex = planets.firstIndex(of:\
    \ planet2)!\n    let result = planets[min(startIndex, endIndex) + 1..<max(startIndex,\
    \ endIndex)]\n    return Array(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002af383a76c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af38376d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af38376d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af38376d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af38376cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpjwi4hdp8                        0x000055d82babeba1 <unavailable> + 11169

    6    tmpjwi4hdp8                        0x000055d82babe02b <unavailable> + 8235

    7    libc.so.6                          0x00002af383c62460 __libc_start_main +
    245

    8    tmpjwi4hdp8                        0x000055d82babd559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    return p1 < p2 ? Array(planets[p1+1..<p2])\
    \ : Array(planets[p2+1..<p1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b94a0ac7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b94a07be561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b94a07be286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b94a07be13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b94a07bdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp7xxhxouj                        0x0000560f382e77b6 <unavailable> + 10166

    6    tmp7xxhxouj                        0x0000560f382e6e4b <unavailable> + 7755

    7    libc.so.6                          0x00002b94a0cb3460 __libc_start_main +
    245

    8    tmp7xxhxouj                        0x0000560f382e6379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1),\n    \
    \    let index2 = planets.firstIndex(of: planet2) else {\n            return []\n\
    \    }\n    let start = min(index1, index2)\n    let end = max(index1, index2)\n\
    \    return Array(planets[start...end])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmprs8_6juq/tmprs8_6juq.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3db252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3daf49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3daf49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3daf487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprs8_6juq                        0x000055a7d949094b <unavailable> + 6475

    5    libc.so.6                          0x00002ab3db43e460 __libc_start_main +
    245

    6    tmprs8_6juq                        0x000055a7d94904f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! < index2! {\n        return Array(planets[index1!\
    \ + 1..<index2!])\n    } else {\n        return Array(planets[index2! + 1..<index1!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac7b4bbcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac7b48b3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac7b48b3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac7b48b313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac7b48b2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgwoami9j                        0x000055bae4e7bba5 <unavailable> + 11173

    6    tmpgwoami9j                        0x000055bae4e7ae4b <unavailable> + 7755

    7    libc.so.6                          0x00002ac7b4da8460 __libc_start_main +
    245

    8    tmpgwoami9j                        0x000055bae4e7a379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let startIndex = planets.firstIndex(of: planet1) ?? -1\n \
    \   let endIndex = planets.firstIndex(of: planet2) ?? -1\n    if startIndex ==\
    \ -1 || endIndex == -1 {\n        return []\n    }\n    if startIndex < endIndex\
    \ {\n        return Array(planets[startIndex + 1...endIndex - 1])\n    } else\
    \ {\n        return Array(planets[endIndex + 1...startIndex - 1])\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5e7eb5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5e7bac561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab5e7bac286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab5e7bac13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab5e7babbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3kiz59xi                        0x00005651f136fa8c <unavailable> + 10892

    6    tmp3kiz59xi                        0x00005651f136eedb <unavailable> + 7899

    7    libc.so.6                          0x00002ab5e80a1460 __libc_start_main +
    245

    8    tmp3kiz59xi                        0x00005651f136e409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let planetsBetween = planets[planet1Index!...planet2Index!]\n\
    \    return Array(planetsBetween)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpbklqg6fc/tmpbklqg6fc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f5b08bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f5ad82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f5ad82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f5ad817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbklqg6fc                        0x000056350131685b <unavailable> + 6235

    5    libc.so.6                          0x00002b0f5b277460 __libc_start_main +
    245

    6    tmpbklqg6fc                        0x0000563501316409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index!+1..<planet2Index!])\n    } else\
    \ {\n        return Array(planets[planet2Index!+1..<planet1Index!])\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ae3d7537c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae3d722e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae3d722e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae3d722e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae3d722dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmphrawecnr                        0x0000561353b53ba5 <unavailable> + 11173

    6    tmphrawecnr                        0x0000561353b52e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ae3d7723460 __libc_start_main +
    245

    8    tmphrawecnr                        0x0000561353b52379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! < index2! {\n        return Array(planets[index1!\
    \ + 1 ..< index2!])\n    } else {\n        return Array(planets[index2! + 1 ..<\
    \ index1!])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b2727d64c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2727a5b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2727a5b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2727a5b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2727a5abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmploza5c9k                        0x000055855a89bba5 <unavailable> + 11173

    6    tmploza5c9k                        0x000055855a89ae4b <unavailable> + 7755

    7    libc.so.6                          0x00002b2727f50460 __libc_start_main +
    245

    8    tmploza5c9k                        0x000055855a89a379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let i1 = planets.firstIndex(of: planet1), let i2 = planets.firstIndex(of:\
    \ planet2) else {\n        return []\n    }\n    let min = min(i1, i2)\n    let\
    \ max = max(i1, i2)\n    return Array(planets[min...max])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpw9pls8d1/tmpw9pls8d1.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b7e587c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b7e27eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b7e27e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b7e27d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw9pls8d1                        0x000055fd1c8da94b <unavailable> + 6475

    5    libc.so.6                          0x00002b3b7e773460 __libc_start_main +
    245

    6    tmpw9pls8d1                        0x000055fd1c8da4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let p1 = planets.index(of: planet1)\n    let p2 = planets.index(of:\
    \ planet2)\n    if p1 == nil || p2 == nil {\n        return []\n    }\n    let\
    \ min = min(p1!, p2!)\n    let max = max(p1!, p2!)\n    return Array(planets[min...max])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmprhhyw7l9/tmprhhyw7l9.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ab8cbdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ab89b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7ab89b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7ab89b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprhhyw7l9                        0x000055e17afeb93b <unavailable> + 6459

    5    libc.so.6                          0x00002b7ab8ea9460 __libc_start_main +
    245

    6    tmprhhyw7l9                        0x000055e17afeb4e9 <unavailable> + 5353

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1...planet2Index! - 1])\n  \
    \  } else {\n        return Array(planets[planet2Index! + 1...planet1Index! -\
    \ 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b47931c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4792ebf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4792ebf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4792ebf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4792ebebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpbon39hqh                        0x0000559961f06d9f <unavailable> + 11679

    6    tmpbon39hqh                        0x0000559961f05edb <unavailable> + 7899

    7    libc.so.6                          0x00002b47933b4460 __libc_start_main +
    245

    8    tmpbon39hqh                        0x0000559961f05409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    let start = min(index1!, index2!)\n    let end\
    \ = max(index1!, index2!)\n    return Array(planets[start...end])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpw_8ei1rd/tmpw_8ei1rd.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b80fcd35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b80fca2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b80fca2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b80fca2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw_8ei1rd                        0x0000555ad2ed294b <unavailable> + 6475

    5    libc.so.6                          0x00002b80fcf21460 __libc_start_main +
    245

    6    tmpw_8ei1rd                        0x0000555ad2ed24f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let planet1Index = planets.firstIndex(of: planet1),\n\
    \        let planet2Index = planets.firstIndex(of: planet2) else {\n         \
    \   return []\n    }\n    let startIndex = min(planet1Index, planet2Index)\n \
    \   let endIndex = max(planet1Index, planet2Index)\n    return Array(planets[startIndex...endIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpl48rx0u_/tmpl48rx0u_.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b332b741c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b332b438b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b332b438988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b332b4377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl48rx0u_                        0x000055e63cf4f94b <unavailable> + 6475

    5    libc.so.6                          0x00002b332b92d460 __libc_start_main +
    245

    6    tmpl48rx0u_                        0x000055e63cf4f4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1...planet2Index! - 1])\n  \
    \  } else {\n        return Array(planets[planet2Index! + 1...planet1Index! -\
    \ 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b47931c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4792ebf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4792ebf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4792ebf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4792ebebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpbon39hqh                        0x0000559961f06d9f <unavailable> + 11679

    6    tmpbon39hqh                        0x0000559961f05edb <unavailable> + 7899

    7    libc.so.6                          0x00002b47933b4460 __libc_start_main +
    245

    8    tmpbon39hqh                        0x0000559961f05409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1 ..< planet2Index!])\n    }\
    \ else {\n        return Array(planets[planet2Index! + 1 ..< planet1Index!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ad650115c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad64fe0c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad64fe0c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad64fe0c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad64fe0bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmph27gzz2t                        0x00005635f8e72ba5 <unavailable> + 11173

    6    tmph27gzz2t                        0x00005635f8e71e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ad650301460 __libc_start_main +
    245

    8    tmph27gzz2t                        0x00005635f8e71379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1...planet2Index! - 1])\n  \
    \  } else {\n        return Array(planets[planet2Index! + 1...planet1Index! -\
    \ 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b47931c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4792ebf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4792ebf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4792ebf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4792ebebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpbon39hqh                        0x0000559961f06d9f <unavailable> + 11679

    6    tmpbon39hqh                        0x0000559961f05edb <unavailable> + 7899

    7    libc.so.6                          0x00002b47933b4460 __libc_start_main +
    245

    8    tmpbon39hqh                        0x0000559961f05409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1 ..< planet2Index!])\n    }\
    \ else {\n        return Array(planets[planet2Index! + 1 ..< planet1Index!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ad650115c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad64fe0c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad64fe0c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad64fe0c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad64fe0bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmph27gzz2t                        0x00005635f8e72ba5 <unavailable> + 11173

    6    tmph27gzz2t                        0x00005635f8e71e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ad650301460 __libc_start_main +
    245

    8    tmph27gzz2t                        0x00005635f8e71379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! < index2! {\n        return Array(planets[index1!\
    \ + 1...index2! - 1])\n    } else {\n        return Array(planets[index2! + 1...index1!\
    \ - 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bf2307c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bf1ffe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3bf1ffe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3bf1ffe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3bf1ffdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpox6xp_ws                        0x000055b48cd0fd9f <unavailable> + 11679

    6    tmpox6xp_ws                        0x000055b48cd0eedb <unavailable> + 7899

    7    libc.so.6                          0x00002b3bf24f3460 __libc_start_main +
    245

    8    tmpox6xp_ws                        0x000055b48cd0e409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let first = planets.firstIndex(of: planet1), let second\
    \ = planets.firstIndex(of: planet2) else { return [] }\n    let result = planets[min(first,\
    \ second) + 1 ..< max(first, second)]\n    return Array(result)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ab526c73c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab52696a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab52696a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab52696a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab526969bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpwb022son                        0x000055ed4ff4f888 <unavailable> + 10376

    6    tmpwb022son                        0x000055ed4ff4ef2b <unavailable> + 7979

    7    libc.so.6                          0x00002ab526e5f460 __libc_start_main +
    245

    8    tmpwb022son                        0x000055ed4ff4e459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1 ..< planet2Index!])\n    }\
    \ else {\n        return Array(planets[planet2Index! + 1 ..< planet1Index!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ad650115c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad64fe0c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad64fe0c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad64fe0c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad64fe0bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmph27gzz2t                        0x00005635f8e72ba5 <unavailable> + 11173

    6    tmph27gzz2t                        0x00005635f8e71e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ad650301460 __libc_start_main +
    245

    8    tmph27gzz2t                        0x00005635f8e71379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1),\n        let\
    \ p2 = planets.firstIndex(of: planet2) else { return [] }\n    let min = min(p1,\
    \ p2)\n    let max = max(p1, p2)\n    return Array(planets[min...max])\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp_8fmhvrz/tmp_8fmhvrz.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4627e25c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4627b1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4627b1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4627b1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_8fmhvrz                        0x000055a78dbd394b <unavailable> + 6475

    5    libc.so.6                          0x00002b4628011460 __libc_start_main +
    245

    6    tmp_8fmhvrz                        0x000055a78dbd34f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let planetsBetween = planets[planet1Index!...planet2Index!]\n\
    \    return Array(planetsBetween)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpbklqg6fc/tmpbklqg6fc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f5b08bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f5ad82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f5ad82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f5ad817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbklqg6fc                        0x000056350131685b <unavailable> + 6235

    5    libc.so.6                          0x00002b0f5b277460 __libc_start_main +
    245

    6    tmpbklqg6fc                        0x0000563501316409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result: [String] = []\n    guard let index1 = planets.firstIndex(of:\
    \ planet1), let index2 = planets.firstIndex(of: planet2) else {\n        return\
    \ result\n    }\n    if index1 > index2 {\n        for i in index2...index1 {\n\
    \            result.append(planets[i])\n        }\n    } else {\n        for i\
    \ in index1...index2 {\n            result.append(planets[i])\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmphqhx52y_/tmphqhx52y_.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b02072efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0206fe6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0206fe6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0206fe57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphqhx52y_                        0x000055add279380b <unavailable> + 6155

    5    libc.so.6                          0x00002b02074db460 __libc_start_main +
    245

    6    tmphqhx52y_                        0x000055add27933b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let start = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ end = planets.firstIndex(of: planet2) ?? -1\n    if start < 0 || end < 0 {\n\
    \        return []\n    }\n    if start < end {\n        return Array(planets[start+1...end-1])\n\
    \    } else {\n        return Array(planets[end+1...start-1].reversed())\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2:\
    \ \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\"\
    ) == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1:\
    \ \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp2p1rsyox/tmp2p1rsyox.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbc51f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbc4eecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbc4eec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbc4eeb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2p1rsyox                        0x00005650d867ffc2 <unavailable> + 8130

    5    libc.so.6                          0x00002adbc53e1460 __libc_start_main +
    245

    6    tmp2p1rsyox                        0x00005650d867f559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let planet1Index = planets.firstIndex(of: planet1),\
    \ let planet2Index = planets.firstIndex(of: planet2) else {\n        return []\n\
    \    }\n    let startIndex = min(planet1Index, planet2Index)\n    let endIndex\
    \ = max(planet1Index, planet2Index)\n    return Array(planets[startIndex...endIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp7h7kdtw8/tmp7h7kdtw8.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d61e6cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d61b63b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d61b63988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d61b627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7h7kdtw8                        0x000055e76390d94b <unavailable> + 6475

    5    libc.so.6                          0x00002b5d62058460 __libc_start_main +
    245

    6    tmp7h7kdtw8                        0x000055e76390d4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1),\n    \
    \    let index2 = planets.firstIndex(of: planet2) else {\n            return []\n\
    \    }\n    let start = min(index1, index2)\n    let end = max(index1, index2)\n\
    \    return Array(planets[start...end])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmprs8_6juq/tmprs8_6juq.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3db252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3daf49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3daf49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3daf487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprs8_6juq                        0x000055a7d949094b <unavailable> + 6475

    5    libc.so.6                          0x00002ab3db43e460 __libc_start_main +
    245

    6    tmprs8_6juq                        0x000055a7d94904f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1), let index2\
    \ = planets.firstIndex(of: planet2) else {\n        return []\n    }\n    let\
    \ minIndex = min(index1, index2)\n    let maxIndex = max(index1, index2)\n   \
    \ return Array(planets[minIndex+1..<maxIndex])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b888cc91c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b888c988561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b888c988286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b888c98813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b888c987bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp4l7pc_qo                        0x0000557ae7cbd851 <unavailable> + 10321

    6    tmp4l7pc_qo                        0x0000557ae7cbcf2b <unavailable> + 7979

    7    libc.so.6                          0x00002b888ce7d460 __libc_start_main +
    245

    8    tmp4l7pc_qo                        0x0000557ae7cbc459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1 ..< planet2Index!])\n    }\
    \ else {\n        return Array(planets[planet2Index! + 1 ..< planet1Index!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ad650115c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad64fe0c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad64fe0c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad64fe0c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad64fe0bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmph27gzz2t                        0x00005635f8e72ba5 <unavailable> + 11173

    6    tmph27gzz2t                        0x00005635f8e71e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ad650301460 __libc_start_main +
    245

    8    tmph27gzz2t                        0x00005635f8e71379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result: [String] = []\n    guard let index1 = planets.firstIndex(of:\
    \ planet1), let index2 = planets.firstIndex(of: planet2) else {\n        return\
    \ result\n    }\n    let minIndex = min(index1, index2)\n    let maxIndex = max(index1,\
    \ index2)\n    for i in minIndex + 1..<maxIndex {\n        result.append(planets[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b2948a10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2948707561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2948707286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b294870713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2948706bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpy7isol0d                        0x0000557f613a58ab <unavailable> + 10411

    6    tmpy7isol0d                        0x0000557f613a4f6b <unavailable> + 8043

    7    libc.so.6                          0x00002b2948bfc460 __libc_start_main +
    245

    8    tmpy7isol0d                        0x0000557f613a4499 <unavailable> + 5273

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index!+1..<planet2Index!])\n    } else\
    \ {\n        return Array(planets[planet2Index!+1..<planet1Index!])\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ae3d7537c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae3d722e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae3d722e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae3d722e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae3d722dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmphrawecnr                        0x0000561353b53ba5 <unavailable> + 11173

    6    tmphrawecnr                        0x0000561353b52e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ae3d7723460 __libc_start_main +
    245

    8    tmphrawecnr                        0x0000561353b52379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! < index2! {\n        return Array(planets[index1!\
    \ + 1...index2! - 1])\n    } else {\n        return Array(planets[index2! + 1...index1!\
    \ - 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bf2307c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bf1ffe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3bf1ffe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3bf1ffe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3bf1ffdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpox6xp_ws                        0x000055b48cd0fd9f <unavailable> + 11679

    6    tmpox6xp_ws                        0x000055b48cd0eedb <unavailable> + 7899

    7    libc.so.6                          0x00002b3bf24f3460 __libc_start_main +
    245

    8    tmpox6xp_ws                        0x000055b48cd0e409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    let min = p1 < p2 ? p1 : p2\n    let max =\
    \ p1 > p2 ? p1 : p2\n    return Array(planets[min...max])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp9tyxloty/tmp9tyxloty.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad691f4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad691c41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad691c41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad691c407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9tyxloty                        0x000055adc658985b <unavailable> + 6235

    5    libc.so.6                          0x00002ad692136460 __libc_start_main +
    245

    6    tmp9tyxloty                        0x000055adc6589409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let start = min(planet1Index!,\
    \ planet2Index!)\n    let end = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[start...end])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp5o2d4v_x/tmp5o2d4v_x.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c21defc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c21ae6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c21ae6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c21ae57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5o2d4v_x                        0x0000563ba976e94b <unavailable> + 6475

    5    libc.so.6                          0x00002b4c21fdb460 __libc_start_main +
    245

    6    tmp5o2d4v_x                        0x0000563ba976e4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let first = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ second = planets.firstIndex(of: planet2) ?? -1\n    if first == -1 || second\
    \ == -1 {\n        return []\n    }\n    if first > second {\n        return Array(planets[second...first])\n\
    \    }\n    return Array(planets[first...second])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp09_gznju/tmp09_gznju.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b832fd70c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b832fa67b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b832fa67988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b832fa667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp09_gznju                        0x0000561da3ff285b <unavailable> + 6235

    5    libc.so.6                          0x00002b832ff5c460 __libc_start_main +
    245

    6    tmp09_gznju                        0x0000561da3ff2409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let planet1Index = planets.firstIndex(of: planet1),\n\
    \        let planet2Index = planets.firstIndex(of: planet2) else {\n         \
    \   return []\n    }\n    let startIndex = min(planet1Index, planet2Index)\n \
    \   let endIndex = max(planet1Index, planet2Index)\n    return Array(planets[startIndex...endIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpl48rx0u_/tmpl48rx0u_.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b332b741c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b332b438b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b332b438988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b332b4377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl48rx0u_                        0x000055e63cf4f94b <unavailable> + 6475

    5    libc.so.6                          0x00002b332b92d460 __libc_start_main +
    245

    6    tmpl48rx0u_                        0x000055e63cf4f4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1 ..< planet2Index!])\n    }\
    \ else {\n        return Array(planets[planet2Index! + 1 ..< planet1Index!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ad650115c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad64fe0c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad64fe0c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad64fe0c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad64fe0bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmph27gzz2t                        0x00005635f8e72ba5 <unavailable> + 11173

    6    tmph27gzz2t                        0x00005635f8e71e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ad650301460 __libc_start_main +
    245

    8    tmph27gzz2t                        0x00005635f8e71379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let planetsBetween = planets[min(planet1Index!,\
    \ planet2Index!) + 1 ..< max(planet1Index!, planet2Index!)]\n    return planet1Index!\
    \ < planet2Index! ? Array(planetsBetween) : Array(planetsBetween.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpwar73npn/tmpwar73npn.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c78684c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c7837bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c7837b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c7837a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwar73npn                        0x000056026a9f7012 <unavailable> + 8210

    5    libc.so.6                          0x00002b4c78870460 __libc_start_main +
    245

    6    tmpwar73npn                        0x000056026a9f65a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    return planets[min(p1, p2) + 1 ..< max(p1,\
    \ p2)].reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp106ugchz/tmp106ugchz.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af665d6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af665a62b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af665a62988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af665a617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp106ugchz                        0x000055e4f14fd89b <unavailable> + 6299

    5    libc.so.6                          0x00002af665f57460 __libc_start_main +
    245

    6    tmp106ugchz                        0x000055e4f14fd449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    return planets[min(p1, p2) + 1..<max(p1, p2)].reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpzljfwyl5/tmpzljfwyl5.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af25daf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af25d7eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af25d7ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af25d7e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzljfwyl5                        0x0000556ed56d589b <unavailable> + 6299

    5    libc.so.6                          0x00002af25dcdf460 __libc_start_main +
    245

    6    tmpzljfwyl5                        0x0000556ed56d5449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    return planets[min(p1, p2) + 1 ..< max(p1,\
    \ p2)].reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp106ugchz/tmp106ugchz.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af665d6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af665a62b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af665a62988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af665a617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp106ugchz                        0x000055e4f14fd89b <unavailable> + 6299

    5    libc.so.6                          0x00002af665f57460 __libc_start_main +
    245

    6    tmp106ugchz                        0x000055e4f14fd449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1),\n    \
    \    let index2 = planets.firstIndex(of: planet2) else {\n            return []\n\
    \    }\n    if index1 < index2 {\n        return Array(planets[index1 + 1 ..<\
    \ index2])\n    } else {\n        return Array(planets[index2 + 1 ..< index1])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b16be0e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16bdde0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b16bdde0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b16bdde013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b16bdddfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpo4vjkk71                        0x000055dc5d2a47ed <unavailable> + 10221

    6    tmpo4vjkk71                        0x000055dc5d2a3e4b <unavailable> + 7755

    7    libc.so.6                          0x00002b16be2d5460 __libc_start_main +
    245

    8    tmpo4vjkk71                        0x000055dc5d2a3379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let start = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ end = planets.firstIndex(of: planet2) ?? -1\n    if start == -1 || end == -1\
    \ {\n        return []\n    }\n    return start < end ? Array(planets[start+1..<end])\
    \ : Array(planets[end+1..<start]).reversed()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmppbskgz1v/tmppbskgz1v.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aad6a39dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aad6a094b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aad6a094988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aad6a0937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppbskgz1v                        0x000055f2ef5dbe42 <unavailable> + 7746

    5    libc.so.6                          0x00002aad6a589460 __libc_start_main +
    245

    6    tmppbskgz1v                        0x000055f2ef5db3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let planet1Index = planets.firstIndex(of: planet1),\
    \ let planet2Index = planets.firstIndex(of: planet2) else {\n        return []\n\
    \    }\n    let startIndex = min(planet1Index, planet2Index)\n    let endIndex\
    \ = max(planet1Index, planet2Index)\n    return Array(planets[startIndex...endIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp7h7kdtw8/tmp7h7kdtw8.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d61e6cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d61b63b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d61b63988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d61b627b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7h7kdtw8                        0x000055e76390d94b <unavailable> + 6475

    5    libc.so.6                          0x00002b5d62058460 __libc_start_main +
    245

    6    tmp7h7kdtw8                        0x000055e76390d4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let p1 = planets.firstIndex(of: planet1)\n    let p2 = planets.firstIndex(of:\
    \ planet2)\n    if p1 == nil || p2 == nil {\n        return []\n    }\n    if\
    \ p1! < p2! {\n        return Array(planets[p1! + 1 ..< p2!])\n    } else {\n\
    \        return Array(planets[p2! + 1 ..< p1!])\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ff2db7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ff2aae561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2ff2aae286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2ff2aae13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2ff2aadbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpqyxjecmk                        0x0000557533c03ba5 <unavailable> + 11173

    6    tmpqyxjecmk                        0x0000557533c02e4b <unavailable> + 7755

    7    libc.so.6                          0x00002b2ff2fa3460 __libc_start_main +
    245

    8    tmpqyxjecmk                        0x0000557533c02379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    let min = p1 < p2 ? p1 : p2\n    let max =\
    \ p1 > p2 ? p1 : p2\n    return Array(planets[min...max])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp9tyxloty/tmp9tyxloty.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad691f4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad691c41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad691c41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad691c407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9tyxloty                        0x000055adc658985b <unavailable> + 6235

    5    libc.so.6                          0x00002ad692136460 __libc_start_main +
    245

    6    tmp9tyxloty                        0x000055adc6589409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if let planet1Index = planet1Index,\
    \ let planet2Index = planet2Index {\n        if planet1Index < planet2Index {\n\
    \            return Array(planets[planet1Index + 1..<planet2Index])\n        }\
    \ else {\n            return Array(planets[planet2Index + 1..<planet1Index])\n\
    \        }\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b20127eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20124e5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b20124e5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b20124e513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b20124e4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpbiplxnph                        0x000055d91a4cb851 <unavailable> + 10321

    6    tmpbiplxnph                        0x000055d91a4cae4b <unavailable> + 7755

    7    libc.so.6                          0x00002b20129da460 __libc_start_main +
    245

    8    tmpbiplxnph                        0x000055d91a4ca379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if let planet1Index = planet1Index,\
    \ let planet2Index = planet2Index {\n        if planet1Index < planet2Index {\n\
    \            return Array(planets[planet1Index+1..<planet2Index])\n        } else\
    \ {\n            return Array(planets[planet2Index+1..<planet1Index])\n      \
    \  }\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b21e5f0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21e5c03561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b21e5c03286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b21e5c0313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b21e5c02bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp724bcpa_                        0x000055e1fbb21851 <unavailable> + 10321

    6    tmp724bcpa_                        0x000055e1fbb20e4b <unavailable> + 7755

    7    libc.so.6                          0x00002b21e60f8460 __libc_start_main +
    245

    8    tmp724bcpa_                        0x000055e1fbb20379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let first = planets.firstIndex(of: planet1), let second\
    \ = planets.firstIndex(of: planet2) else { return [] }\n    return first < second\
    \ ? Array(planets[first...second]) : Array(planets[second...first])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp5osmj1zj/tmp5osmj1zj.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad517076c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad516d6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad516d6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad516d6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5osmj1zj                        0x000055db6662f85b <unavailable> + 6235

    5    libc.so.6                          0x00002ad517262460 __libc_start_main +
    245

    6    tmp5osmj1zj                        0x000055db6662f409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index!+1..<planet2Index!])\n    } else\
    \ {\n        return Array(planets[planet2Index!+1..<planet1Index!])\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ae3d7537c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae3d722e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae3d722e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae3d722e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae3d722dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmphrawecnr                        0x0000561353b53ba5 <unavailable> + 11173

    6    tmphrawecnr                        0x0000561353b52e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ae3d7723460 __libc_start_main +
    245

    8    tmphrawecnr                        0x0000561353b52379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result: [String] = []\n    var start = 0\n    var end\
    \ = 0\n    for i in 0..<planets.count {\n        if planets[i] == planet1 {\n\
    \            start = i\n        }\n        if planets[i] == planet2 {\n      \
    \      end = i\n        }\n    }\n    if start == 0 && end == 0 {\n        return\
    \ result\n    }\n    if start > end {\n        let temp = start\n        start\
    \ = end\n        end = temp\n    }\n    for i in start+1..<end {\n        result.append(planets[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b053a0e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0539ddb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0539ddb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0539ddb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0539ddabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzdt1bmjl                        0x0000561351bec86a <unavailable> + 10346

    6    tmpzdt1bmjl                        0x0000561351bebe8b <unavailable> + 7819

    7    libc.so.6                          0x00002b053a2d0460 __libc_start_main +
    245

    8    tmpzdt1bmjl                        0x0000561351beb3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1 ..< planet2Index!])\n    }\
    \ else {\n        return Array(planets[planet2Index! + 1 ..< planet1Index!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ad650115c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad64fe0c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad64fe0c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad64fe0c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad64fe0bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmph27gzz2t                        0x00005635f8e72ba5 <unavailable> + 11173

    6    tmph27gzz2t                        0x00005635f8e71e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ad650301460 __libc_start_main +
    245

    8    tmph27gzz2t                        0x00005635f8e71379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    if let index1 = planets.firstIndex(of: planet1), let index2\
    \ = planets.firstIndex(of: planet2) {\n        if index1 < index2 {\n        \
    \    return Array(planets[index1+1..<index2])\n        } else {\n            return\
    \ Array(planets[index2+1..<index1])\n        }\n    }\n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b16de8bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b16de5b3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b16de5b3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b16de5b313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b16de5b2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpckua80lt                        0x000056275875b7ed <unavailable> + 10221

    6    tmpckua80lt                        0x000056275875ae4b <unavailable> + 7755

    7    libc.so.6                          0x00002b16deaa8460 __libc_start_main +
    245

    8    tmpckua80lt                        0x000056275875a379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let start = min(planet1Index!,\
    \ planet2Index!)\n    let end = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[start...end])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp5o2d4v_x/tmp5o2d4v_x.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c21defc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c21ae6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c21ae6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c21ae57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5o2d4v_x                        0x0000563ba976e94b <unavailable> + 6475

    5    libc.so.6                          0x00002b4c21fdb460 __libc_start_main +
    245

    6    tmp5o2d4v_x                        0x0000563ba976e4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1), let index2\
    \ = planets.firstIndex(of: planet2) else {\n        return []\n    }\n    let\
    \ start = min(index1, index2)\n    let end = max(index1, index2)\n    return Array(planets[start...end])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpax1ccl3v/tmpax1ccl3v.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab41a442c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab41a139b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab41a139988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab41a1387b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpax1ccl3v                        0x000055ba1172494b <unavailable> + 6475

    5    libc.so.6                          0x00002ab41a62e460 __libc_start_main +
    245

    6    tmpax1ccl3v                        0x000055ba117244f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let first = planets.firstIndex(of: planet1),\n     \
    \   let second = planets.firstIndex(of: planet2) else { return [] }\n    return\
    \ first < second ? Array(planets[first...second]) : Array(planets[second...first])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp6vik2hp8/tmp6vik2hp8.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8fe1928c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8fe161fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8fe161f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8fe161e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6vik2hp8                        0x00005569b16da85b <unavailable> + 6235

    5    libc.so.6                          0x00002b8fe1b14460 __libc_start_main +
    245

    6    tmp6vik2hp8                        0x00005569b16da409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    if p1 < p2 {\n        return Array(planets[p1+1...p2-1])\n\
    \    } else {\n        return Array(planets[p2+1...p1-1])\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b3330c92c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3330989561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3330989286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b333098913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3330988bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmppggg9rhu                        0x000055b16372e9ff <unavailable> + 10751

    6    tmppggg9rhu                        0x000055b16372dedb <unavailable> + 7899

    7    libc.so.6                          0x00002b3330e7e460 __libc_start_main +
    245

    8    tmppggg9rhu                        0x000055b16372d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    return p1 < p2 ? Array(planets[p1...p2]) :\
    \ Array(planets[p2...p1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpxzdn1bhg/tmpxzdn1bhg.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b431f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b42ee9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b42ee9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b42ee87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxzdn1bhg                        0x0000555636e8885b <unavailable> + 6235

    5    libc.so.6                          0x00002b0b433de460 __libc_start_main +
    245

    6    tmpxzdn1bhg                        0x0000555636e88409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1), let index2\
    \ = planets.firstIndex(of: planet2) else {\n        return []\n    }\n    return\
    \ index1 < index2 ? Array(planets[index1...index2]) : Array(planets[index2...index1])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpafzn4n0z/tmpafzn4n0z.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b03226b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b03223abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b03223ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b03223aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafzn4n0z                        0x000056458e43a85b <unavailable> + 6235

    5    libc.so.6                          0x00002b03228a0460 __libc_start_main +
    245

    6    tmpafzn4n0z                        0x000056458e43a409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! < index2! {\n        return Array(planets[index1!\
    \ + 1 ..< index2!])\n    } else {\n        return Array(planets[index2! + 1 ..<\
    \ index1!])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b2727d64c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2727a5b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2727a5b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2727a5b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2727a5abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmploza5c9k                        0x000055855a89bba5 <unavailable> + 11173

    6    tmploza5c9k                        0x000055855a89ae4b <unavailable> + 7755

    7    libc.so.6                          0x00002b2727f50460 __libc_start_main +
    245

    8    tmploza5c9k                        0x000055855a89a379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let first = planets.firstIndex(of: planet1),\n     \
    \   let second = planets.firstIndex(of: planet2) else { return [] }\n    return\
    \ planets[min(first, second) + 1 ..< max(first, second)].reversed()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpyqzicxqw/tmpyqzicxqw.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ddafc1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ddacb8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ddacb8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ddacb77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyqzicxqw                        0x0000560963b9389b <unavailable> + 6299

    5    libc.so.6                          0x00002b2ddb1ad460 __libc_start_main +
    245

    6    tmpyqzicxqw                        0x0000560963b93449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    return p1 < p2 ? Array(planets[p1...p2]) :\
    \ Array(planets[p2...p1]).reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmprqsds2ig/tmprqsds2ig.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad249e05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad249afcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad249afc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad249afb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprqsds2ig                        0x000055ac322ce8bb <unavailable> + 6331

    5    libc.so.6                          0x00002ad249ff1460 __libc_start_main +
    245

    6    tmprqsds2ig                        0x000055ac322ce469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let minIndex = min(planet1Index!,\
    \ planet2Index!)\n    let maxIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[minIndex...maxIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmphfmhh2ew/tmphfmhh2ew.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba075bb0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0758a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0758a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0758a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphfmhh2ew                        0x000055f2d7b0494b <unavailable> + 6475

    5    libc.so.6                          0x00002ba075d9c460 __libc_start_main +
    245

    6    tmphfmhh2ew                        0x000055f2d7b044f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    guard planet1Index != nil\
    \ && planet2Index != nil else { return [] }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpzu9katdy/tmpzu9katdy.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b37db6b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b37db3abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b37db3ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b37db3aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzu9katdy                        0x000055d4a4ebc94b <unavailable> + 6475

    5    libc.so.6                          0x00002b37db8a0460 __libc_start_main +
    245

    6    tmpzu9katdy                        0x000055d4a4ebc4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! > planet2Index!\
    \ {\n        return Array(planets[planet2Index!...planet1Index!])\n    } else\
    \ {\n        return Array(planets[planet1Index!...planet2Index!])\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpibx8pw1a/tmpibx8pw1a.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89ed9e6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89ed6ddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89ed6dd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89ed6dc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpibx8pw1a                        0x00005636f61ed85b <unavailable> + 6235

    5    libc.so.6                          0x00002b89edbd2460 __libc_start_main +
    245

    6    tmpibx8pw1a                        0x00005636f61ed409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let planetsBetween = planets[min(planet1Index!,\
    \ planet2Index!) + 1 ..< max(planet1Index!, planet2Index!)]\n    return planet1Index!\
    \ < planet2Index! ? Array(planetsBetween) : Array(planetsBetween.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpwar73npn/tmpwar73npn.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c78684c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c7837bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c7837b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c7837a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwar73npn                        0x000056026a9f7012 <unavailable> + 8210

    5    libc.so.6                          0x00002b4c78870460 __libc_start_main +
    245

    6    tmpwar73npn                        0x000056026a9f65a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let first = planets.firstIndex(of: planet1), let second\
    \ = planets.firstIndex(of: planet2) else {\n        return []\n    }\n    return\
    \ first < second ? Array(planets[first...second]) : Array(planets[second...first])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpsoidhiyv/tmpsoidhiyv.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae72fe9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae72fb93b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae72fb93988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae72fb927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsoidhiyv                        0x0000560a6bfcc85b <unavailable> + 6235

    5    libc.so.6                          0x00002ae730088460 __libc_start_main +
    245

    6    tmpsoidhiyv                        0x0000560a6bfcc409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    guard let p1 = planet1Index,\
    \ let p2 = planet2Index else { return [] }\n    if p1 < p2 {\n        return Array(planets[p1...p2])\n\
    \    } else {\n        return Array(planets[p2...p1])\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpkzilryhy/tmpkzilryhy.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b056c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b053bfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b053bf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b053be7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkzilryhy                        0x00005584afeca85b <unavailable> + 6235

    5    libc.so.6                          0x00002b1b058b4460 __libc_start_main +
    245

    6    tmpkzilryhy                        0x00005584afeca409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    let startIndex = min(index1!, index2!)\n    let\
    \ endIndex = max(index1!, index2!)\n    return Array(planets[startIndex...endIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp8bbmxqp5/tmp8bbmxqp5.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67092bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6708fb5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6708fb5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6708fb47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8bbmxqp5                        0x0000564928aa394b <unavailable> + 6475

    5    libc.so.6                          0x00002b67094aa460 __libc_start_main +
    245

    6    tmp8bbmxqp5                        0x0000564928aa34f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let first = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ second = planets.firstIndex(of: planet2) ?? -1\n    if first == -1 || second\
    \ == -1 {\n        return []\n    }\n    let start = min(first, second)\n    let\
    \ end = max(first, second)\n    return Array(planets[start...end])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpzjpy1yfu/tmpzjpy1yfu.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ac6cc1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ac69b8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3ac69b8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3ac69b77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzjpy1yfu                        0x0000559cb692494b <unavailable> + 6475

    5    libc.so.6                          0x00002b3ac6ead460 __libc_start_main +
    245

    6    tmpzjpy1yfu                        0x0000559cb69244f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let start = min(planet1Index!,\
    \ planet2Index!)\n    let end = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[start...end])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp5o2d4v_x/tmp5o2d4v_x.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c21defc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c21ae6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c21ae6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c21ae57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5o2d4v_x                        0x0000563ba976e94b <unavailable> + 6475

    5    libc.so.6                          0x00002b4c21fdb460 __libc_start_main +
    245

    6    tmp5o2d4v_x                        0x0000563ba976e4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let minIndex = min(planet1Index!,\
    \ planet2Index!)\n    let maxIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[minIndex...maxIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmphfmhh2ew/tmphfmhh2ew.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba075bb0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0758a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0758a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0758a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphfmhh2ew                        0x000055f2d7b0494b <unavailable> + 6475

    5    libc.so.6                          0x00002ba075d9c460 __libc_start_main +
    245

    6    tmphfmhh2ew                        0x000055f2d7b044f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1..<planet2Index!])\n    } else\
    \ {\n        return Array(planets[planet2Index! + 1..<planet1Index!])\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b4486653c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b448634a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b448634a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b448634a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4486349bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpd0zlping                        0x000055f7ac6aeba5 <unavailable> + 11173

    6    tmpd0zlping                        0x000055f7ac6ade4b <unavailable> + 7755

    7    libc.so.6                          0x00002b448683f460 __libc_start_main +
    245

    8    tmpd0zlping                        0x000055f7ac6ad379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let firstIndex = planets.firstIndex(of: planet1)\n    let\
    \ secondIndex = planets.firstIndex(of: planet2)\n    if firstIndex == nil || secondIndex\
    \ == nil {\n        return []\n    }\n    let result = planets[min(firstIndex!,\
    \ secondIndex!)...max(firstIndex!, secondIndex!)]\n    return firstIndex! < secondIndex!\
    \ ? result : result.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmprrv326pr.swift:23:39: error: cannot convert return expression of\
    \ type 'ArraySlice<String>' to return type '[String]'\n    return firstIndex!\
    \ < secondIndex! ? result : result.reversed()\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planets1 = planets.firstIndex(of: planet1)\n    let planets2\
    \ = planets.firstIndex(of: planet2)\n    if planets1 == nil || planets2 == nil\
    \ {\n        return []\n    }\n    if planets1! < planets2! {\n        return\
    \ Array(planets[planets1! + 1 ..< planets2!])\n    } else {\n        return Array(planets[planets2!\
    \ + 1 ..< planets1!])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e40cbac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e409b1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9e409b1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9e409b113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9e409b0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpto07t6gi                        0x000055ecedd89ba5 <unavailable> + 11173

    6    tmpto07t6gi                        0x000055ecedd88e4b <unavailable> + 7755

    7    libc.so.6                          0x00002b9e40ea6460 __libc_start_main +
    245

    8    tmpto07t6gi                        0x000055ecedd88379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result = [String]()\n    let index1 = planets.firstIndex(of:\
    \ planet1)\n    let index2 = planets.firstIndex(of: planet2)\n    if index1 ==\
    \ nil || index2 == nil {\n        return result\n    }\n    if index1! < index2!\
    \ {\n        for i in index1!+1..<index2! {\n            result.append(planets[i])\n\
    \        }\n    } else {\n        for i in index2!+1..<index1! {\n           \
    \ result.append(planets[i])\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ab9155d8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab9152cf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab9152cf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab9152cf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab9152cebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpsn8hmbst                        0x000055daa1b54c9b <unavailable> + 11419

    6    tmpsn8hmbst                        0x000055daa1b53edb <unavailable> + 7899

    7    libc.so.6                          0x00002ab9157c4460 __libc_start_main +
    245

    8    tmpsn8hmbst                        0x000055daa1b53409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1 ..< planet2Index!])\n    }\
    \ else {\n        return Array(planets[planet2Index! + 1 ..< planet1Index!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ad650115c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad64fe0c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad64fe0c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad64fe0c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad64fe0bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmph27gzz2t                        0x00005635f8e72ba5 <unavailable> + 11173

    6    tmph27gzz2t                        0x00005635f8e71e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ad650301460 __libc_start_main +
    245

    8    tmph27gzz2t                        0x00005635f8e71379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! < index2! {\n        return Array(planets[index1!\
    \ + 1..<index2!])\n    } else {\n        return Array(planets[index2! + 1..<index1!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac7b4bbcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac7b48b3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac7b48b3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac7b48b313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac7b48b2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgwoami9j                        0x000055bae4e7bba5 <unavailable> + 11173

    6    tmpgwoami9j                        0x000055bae4e7ae4b <unavailable> + 7755

    7    libc.so.6                          0x00002ac7b4da8460 __libc_start_main +
    245

    8    tmpgwoami9j                        0x000055bae4e7a379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let start = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ end = planets.firstIndex(of: planet2) ?? -1\n    if start == -1 || end == -1\
    \ {\n        return []\n    }\n    let result = planets[min(start, end) + 1 ..<\
    \ max(start, end)]\n    return result.count > 0 ? Array(result) : []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b489ede7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b489eade561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b489eade286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b489eade13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b489eaddbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp3dddm126                        0x000055c56ae1a8ea <unavailable> + 10474

    6    tmp3dddm126                        0x000055c56ae19f8b <unavailable> + 8075

    7    libc.so.6                          0x00002b489efd3460 __libc_start_main +
    245

    8    tmp3dddm126                        0x000055c56ae194b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let idx1 = planets.firstIndex(of: planet1), let idx2\
    \ = planets.firstIndex(of: planet2) else { return [] }\n    let minIdx = min(idx1,\
    \ idx2)\n    let maxIdx = max(idx1, idx2)\n    return Array(planets[minIdx+1..<maxIdx])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9fcce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac9fc9df561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac9fc9df286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac9fc9df13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac9fc9debb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp149btzr9                        0x000055e5c42f0851 <unavailable> + 10321

    6    tmp149btzr9                        0x000055e5c42eff2b <unavailable> + 7979

    7    libc.so.6                          0x00002ac9fced4460 __libc_start_main +
    245

    8    tmp149btzr9                        0x000055e5c42ef459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! < index2! {\n        return Array(planets[index1!+1...index2!-1])\n\
    \    } else {\n        return Array(planets[index2!+1...index1!-1])\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a1623dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a15f34561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9a15f34286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9a15f3413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9a15f33bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp26751as6                        0x00005566a5e40d9f <unavailable> + 11679

    6    tmp26751as6                        0x00005566a5e3fedb <unavailable> + 7899

    7    libc.so.6                          0x00002b9a16429460 __libc_start_main +
    245

    8    tmp26751as6                        0x00005566a5e3f409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    guard let p1 = planet1Index,\
    \ let p2 = planet2Index else { return [] }\n    let start = min(p1, p2)\n    let\
    \ end = max(p1, p2)\n    return Array(planets[start...end])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpb1e2ugo9/tmpb1e2ugo9.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba404c67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba40495eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba40495e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba40495d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb1e2ugo9                        0x000055c7cb3d394b <unavailable> + 6475

    5    libc.so.6                          0x00002ba404e53460 __libc_start_main +
    245

    6    tmpb1e2ugo9                        0x000055c7cb3d34f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    let min = min(p1, p2)\n    let max = max(p1,\
    \ p2)\n    return Array(planets[min...max])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmph9204re1/tmph9204re1.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad431b6ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad431861b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad431861988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad4318607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph9204re1                        0x0000564d206ed94b <unavailable> + 6475

    5    libc.so.6                          0x00002ad431d56460 __libc_start_main +
    245

    6    tmph9204re1                        0x0000564d206ed4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    return p1 < p2 ? Array(planets[p1...p2]) :\
    \ Array(planets[p2...p1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpxzdn1bhg/tmpxzdn1bhg.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b431f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b42ee9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b42ee9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b42ee87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxzdn1bhg                        0x0000555636e8885b <unavailable> + 6235

    5    libc.so.6                          0x00002b0b433de460 __libc_start_main +
    245

    6    tmpxzdn1bhg                        0x0000555636e88409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result: [String] = []\n    guard let index1 = planets.firstIndex(of:\
    \ planet1), let index2 = planets.firstIndex(of: planet2) else {\n        return\
    \ result\n    }\n    if index1 < index2 {\n        result = Array(planets[index1...index2])\n\
    \    } else {\n        result = Array(planets[index2...index1])\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpzy71a67y/tmpzy71a67y.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c10927c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c1061eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c1061e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c1061d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzy71a67y                        0x00005578d1bf485b <unavailable> + 6235

    5    libc.so.6                          0x00002b3c10b13460 __libc_start_main +
    245

    6    tmpzy71a67y                        0x00005578d1bf4409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let planetsBetween = planets[min(planet1Index!,\
    \ planet2Index!) + 1 ..< max(planet1Index!, planet2Index!)]\n    return planet1Index!\
    \ < planet2Index! ? Array(planetsBetween) : Array(planetsBetween.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpwar73npn/tmpwar73npn.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c78684c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c7837bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4c7837b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4c7837a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwar73npn                        0x000056026a9f7012 <unavailable> + 8210

    5    libc.so.6                          0x00002b4c78870460 __libc_start_main +
    245

    6    tmpwar73npn                        0x000056026a9f65a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let p1 = planets.firstIndex(of: planet1)\n    let p2 = planets.firstIndex(of:\
    \ planet2)\n    if p1 == nil || p2 == nil {\n        return []\n    }\n    let\
    \ start = min(p1!, p2!)\n    let end = max(p1!, p2!)\n    return Array(planets[start...end])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp8vciu9gp/tmp8vciu9gp.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b057f8d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b057f5cab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b057f5ca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b057f5c97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8vciu9gp                        0x000055f673aa294b <unavailable> + 6475

    5    libc.so.6                          0x00002b057fabf460 __libc_start_main +
    245

    6    tmp8vciu9gp                        0x000055f673aa24f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    return planets[min(p1, p2) + 1 ..< max(p1,\
    \ p2)].reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp106ugchz/tmp106ugchz.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af665d6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af665a62b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af665a62988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af665a617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp106ugchz                        0x000055e4f14fd89b <unavailable> + 6299

    5    libc.so.6                          0x00002af665f57460 __libc_start_main +
    245

    6    tmp106ugchz                        0x000055e4f14fd449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1), let index2\
    \ = planets.firstIndex(of: planet2) else {\n        return []\n    }\n    return\
    \ index1 < index2 ? Array(planets[index1...index2]) : Array(planets[index2...index1])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpafzn4n0z/tmpafzn4n0z.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b03226b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b03223abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b03223ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b03223aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafzn4n0z                        0x000056458e43a85b <unavailable> + 6235

    5    libc.so.6                          0x00002b03228a0460 __libc_start_main +
    245

    6    tmpafzn4n0z                        0x000056458e43a409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let start = planets.firstIndex(of: planet1), let end\
    \ = planets.firstIndex(of: planet2) else { return [] }\n    return start < end\
    \ ? Array(planets[start+1..<end]) : Array(planets[end+1..<start]).reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp5wlnqdc_/tmp5wlnqdc_.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8aa2d58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8aa2a4fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8aa2a4f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8aa2a4e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5wlnqdc_                        0x0000559eaae1de42 <unavailable> + 7746

    5    libc.so.6                          0x00002b8aa2f44460 __libc_start_main +
    245

    6    tmp5wlnqdc_                        0x0000559eaae1d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    return p1 < p2 ? Array(planets[p1...p2]) :\
    \ Array(planets[p2...p1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpxzdn1bhg/tmpxzdn1bhg.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b431f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b42ee9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b42ee9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b42ee87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxzdn1bhg                        0x0000555636e8885b <unavailable> + 6235

    5    libc.so.6                          0x00002b0b433de460 __libc_start_main +
    245

    6    tmpxzdn1bhg                        0x0000555636e88409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1),\n    \
    \    let index2 = planets.firstIndex(of: planet2) else {\n            return []\n\
    \    }\n    return planets[min(index1, index2) + 1 ..< max(index1, index2)].reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmplrxhzk5j/tmplrxhzk5j.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af864ab7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af8647aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af8647ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af8647ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplrxhzk5j                        0x000055758c8aa89b <unavailable> + 6299

    5    libc.so.6                          0x00002af864ca3460 __libc_start_main +
    245

    6    tmplrxhzk5j                        0x000055758c8aa449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let planet1Index = planets.firstIndex(of: planet1),\n\
    \        let planet2Index = planets.firstIndex(of: planet2) else {\n         \
    \   return []\n    }\n    if planet1Index > planet2Index {\n        return Array(planets[planet2Index...planet1Index])\n\
    \    } else {\n        return Array(planets[planet1Index...planet2Index])\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2:\
    \ \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\"\
    ) == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1:\
    \ \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpleauuool/tmpleauuool.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2294d14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2294a0bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2294a0b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2294a0a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpleauuool                        0x000055695f49a85b <unavailable> + 6235

    5    libc.so.6                          0x00002b2294f00460 __libc_start_main +
    245

    6    tmpleauuool                        0x000055695f49a409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let min = planet1Index!\
    \ < planet2Index! ? planet1Index! : planet2Index!\n    let max = planet1Index!\
    \ > planet2Index! ? planet1Index! : planet2Index!\n    return Array(planets[min...max])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpfc711f8t/tmpfc711f8t.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b667c593c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b667c28ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b667c28a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b667c2897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfc711f8t                        0x00005638de85d85b <unavailable> + 6235

    5    libc.so.6                          0x00002b667c77f460 __libc_start_main +
    245

    6    tmpfc711f8t                        0x00005638de85d409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let firstIndex = planets.firstIndex(of: planet1)\n    let\
    \ secondIndex = planets.firstIndex(of: planet2)\n    if firstIndex == nil || secondIndex\
    \ == nil {\n        return []\n    }\n    if firstIndex! > secondIndex! {\n  \
    \      return Array(planets[secondIndex!...firstIndex!])\n    } else {\n     \
    \   return Array(planets[firstIndex!...secondIndex!])\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpyqeaauvh/tmpyqeaauvh.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aadc3addc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aadc37d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aadc37d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aadc37d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyqeaauvh                        0x0000564c3063485b <unavailable> + 6235

    5    libc.so.6                          0x00002aadc3cc9460 __libc_start_main +
    245

    6    tmpyqeaauvh                        0x0000564c30634409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1 ..< planet2Index!])\n    }\
    \ else {\n        return Array(planets[planet2Index! + 1 ..< planet1Index!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ad650115c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad64fe0c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad64fe0c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad64fe0c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad64fe0bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmph27gzz2t                        0x00005635f8e72ba5 <unavailable> + 11173

    6    tmph27gzz2t                        0x00005635f8e71e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ad650301460 __libc_start_main +
    245

    8    tmph27gzz2t                        0x00005635f8e71379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! > planet2Index!\
    \ {\n        return Array(planets[planet2Index!...planet1Index!])\n    } else\
    \ {\n        return Array(planets[planet1Index!...planet2Index!])\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpibx8pw1a/tmpibx8pw1a.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89ed9e6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89ed6ddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89ed6dd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89ed6dc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpibx8pw1a                        0x00005636f61ed85b <unavailable> + 6235

    5    libc.so.6                          0x00002b89edbd2460 __libc_start_main +
    245

    6    tmpibx8pw1a                        0x00005636f61ed409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    guard let planet1IndexUnwrapped\
    \ = planet1Index, let planet2IndexUnwrapped = planet2Index else {\n        return\
    \ []\n    }\n    if planet1IndexUnwrapped < planet2IndexUnwrapped {\n        return\
    \ Array(planets[planet1IndexUnwrapped + 1...planet2IndexUnwrapped - 1])\n    }\
    \ else {\n        return Array(planets[planet2IndexUnwrapped + 1...planet1IndexUnwrapped\
    \ - 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b7d0d74cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7d0d443561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7d0d443286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7d0d44313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7d0d442bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmppj_aeu0l                        0x000055d3c9364a63 <unavailable> + 10851

    6    tmppj_aeu0l                        0x000055d3c9363edb <unavailable> + 7899

    7    libc.so.6                          0x00002b7d0d938460 __libc_start_main +
    245

    8    tmppj_aeu0l                        0x000055d3c9363409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    guard let p1 = planet1Index,\
    \ let p2 = planet2Index else {\n        return []\n    }\n    if p1 > p2 {\n \
    \       return Array(planets[p2...p1])\n    } else {\n        return Array(planets[p1...p2])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpx_a277eq/tmpx_a277eq.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4b5265c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4b4f5cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4b4f5c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4b4f5b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx_a277eq                        0x00005566ef69b85b <unavailable> + 6235

    5    libc.so.6                          0x00002af4b5451460 __libc_start_main +
    245

    6    tmpx_a277eq                        0x00005566ef69b409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1),\n        let\
    \ p2 = planets.firstIndex(of: planet2) else { return [] }\n    return p1 < p2\
    \ ? Array(planets[p1+1...p2-1]) : Array(planets[p2+1...p1-1])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b6fc571ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6fc5411561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6fc5411286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6fc541113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6fc5410bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpl7_97sll                        0x00005556c3d729c8 <unavailable> + 10696

    6    tmpl7_97sll                        0x00005556c3d71edb <unavailable> + 7899

    7    libc.so.6                          0x00002b6fc5906460 __libc_start_main +
    245

    8    tmpl7_97sll                        0x00005556c3d71409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let first = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ second = planets.firstIndex(of: planet2) ?? -1\n    if first == -1 || second\
    \ == -1 {\n        return []\n    }\n    if first > second {\n        return Array(planets[second...first])\n\
    \    }\n    return Array(planets[first...second])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp09_gznju/tmp09_gznju.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b832fd70c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b832fa67b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b832fa67988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b832fa667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp09_gznju                        0x0000561da3ff285b <unavailable> + 6235

    5    libc.so.6                          0x00002b832ff5c460 __libc_start_main +
    245

    6    tmp09_gznju                        0x0000561da3ff2409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let start = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ end = planets.firstIndex(of: planet2) ?? -1\n    if start == -1 || end == -1\
    \ {\n        return []\n    }\n    return planets[start...end].sorted { (planet1,\
    \ planet2) -> Bool in\n        return planet1 < planet2\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpnwbuoqv2/tmpnwbuoqv2.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aacc338dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aacc3084b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aacc3084988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aacc30837b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnwbuoqv2                        0x0000555bd73768ab <unavailable> + 6315

    5    libc.so.6                          0x00002aacc3579460 __libc_start_main +
    245

    6    tmpnwbuoqv2                        0x0000555bd7376459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result: [String] = []\n    guard let index1 = planets.firstIndex(of:\
    \ planet1), let index2 = planets.firstIndex(of: planet2) else {\n        return\
    \ result\n    }\n    if index1 < index2 {\n        result = Array(planets[index1+1..<index2])\n\
    \    } else {\n        result = Array(planets[index2+1..<index1])\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e9d6eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e9d3e5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0e9d3e5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0e9d3e513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0e9d3e4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpypdxunag                        0x000055ddcc34d819 <unavailable> + 10265

    6    tmpypdxunag                        0x000055ddcc34ce4b <unavailable> + 7755

    7    libc.so.6                          0x00002b0e9d8da460 __libc_start_main +
    245

    8    tmpypdxunag                        0x000055ddcc34c379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1...planet2Index! - 1])\n  \
    \  } else {\n        return Array(planets[planet2Index! + 1...planet1Index! -\
    \ 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b47931c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4792ebf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4792ebf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4792ebf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4792ebebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpbon39hqh                        0x0000559961f06d9f <unavailable> + 11679

    6    tmpbon39hqh                        0x0000559961f05edb <unavailable> + 7899

    7    libc.so.6                          0x00002b47933b4460 __libc_start_main +
    245

    8    tmpbon39hqh                        0x0000559961f05409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1...planet2Index! - 1])\n  \
    \  } else {\n        return Array(planets[planet2Index! + 1...planet1Index! -\
    \ 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b47931c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4792ebf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4792ebf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4792ebf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4792ebebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpbon39hqh                        0x0000559961f06d9f <unavailable> + 11679

    6    tmpbon39hqh                        0x0000559961f05edb <unavailable> + 7899

    7    libc.so.6                          0x00002b47933b4460 __libc_start_main +
    245

    8    tmpbon39hqh                        0x0000559961f05409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    guard let p1 = planet1Index,\
    \ let p2 = planet2Index else { return [] }\n    let result = planets[min(p1, p2)\
    \ + 1 ..< max(p1, p2)]\n    return Array(result)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b317287cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3172573561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3172573286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b317257313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3172572bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpu7ywvke4                        0x0000563673ab18ec <unavailable> + 10476

    6    tmpu7ywvke4                        0x0000563673ab0f2b <unavailable> + 7979

    7    libc.so.6                          0x00002b3172a68460 __libc_start_main +
    245

    8    tmpu7ywvke4                        0x0000563673ab0459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1 ..< planet2Index!])\n    }\
    \ else {\n        return Array(planets[planet2Index! + 1 ..< planet1Index!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ad650115c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad64fe0c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad64fe0c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad64fe0c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad64fe0bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmph27gzz2t                        0x00005635f8e72ba5 <unavailable> + 11173

    6    tmph27gzz2t                        0x00005635f8e71e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ad650301460 __libc_start_main +
    245

    8    tmph27gzz2t                        0x00005635f8e71379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let p1 = planets.firstIndex(of: planet1)\n    let p2 = planets.firstIndex(of:\
    \ planet2)\n    if p1 == nil || p2 == nil {\n        return []\n    }\n    return\
    \ planets[min(p1!, p2!)+1..<max(p1!, p2!)]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp1sywyskg.swift:22:19: error: cannot convert return expression of\
    \ type 'ArraySlice<String>' to return type '[String]'\n    return planets[min(p1!,\
    \ p2!)+1..<max(p1!, p2!)]\n           ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else {\n        return []\n    }\n    return planets[min(p1, p2) +\
    \ 1 ..< max(p1, p2)].reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp759h1s52/tmp759h1s52.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac535601c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac5352f8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac5352f8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac5352f77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp759h1s52                        0x00005624f260b89b <unavailable> + 6299

    5    libc.so.6                          0x00002ac5357ed460 __libc_start_main +
    245

    6    tmp759h1s52                        0x00005624f260b449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let start = planets.firstIndex(of: planet1) ?? 0\n    let\
    \ end = planets.firstIndex(of: planet2) ?? 0\n    let range = start < end ? start...end\
    \ : end...start\n    return Array(planets[range])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpfd6cbfem/tmpfd6cbfem.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7279ccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7276c3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7276c3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7276c27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfd6cbfem                        0x0000561e58f3185b <unavailable> + 6235

    5    libc.so.6                          0x00002ae727bb8460 __libc_start_main +
    245

    6    tmpfd6cbfem                        0x0000561e58f31409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1 ..< planet2Index!])\n    }\
    \ else {\n        return Array(planets[planet2Index! + 1 ..< planet1Index!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ad650115c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad64fe0c561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad64fe0c286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad64fe0c13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad64fe0bbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmph27gzz2t                        0x00005635f8e72ba5 <unavailable> + 11173

    6    tmph27gzz2t                        0x00005635f8e71e4b <unavailable> + 7755

    7    libc.so.6                          0x00002ad650301460 __libc_start_main +
    245

    8    tmph27gzz2t                        0x00005635f8e71379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let planet1Index = planets.firstIndex(of: planet1),\n\
    \        let planet2Index = planets.firstIndex(of: planet2) else {\n         \
    \   return []\n    }\n    let startIndex = min(planet1Index, planet2Index)\n \
    \   let endIndex = max(planet1Index, planet2Index)\n    return Array(planets[startIndex...endIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpl48rx0u_/tmpl48rx0u_.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b332b741c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b332b438b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b332b438988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b332b4377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl48rx0u_                        0x000055e63cf4f94b <unavailable> + 6475

    5    libc.so.6                          0x00002b332b92d460 __libc_start_main +
    245

    6    tmpl48rx0u_                        0x000055e63cf4f4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! < index2! {\n        return Array(planets[index1!\
    \ + 1..<index2!])\n    } else {\n        return Array(planets[index2! + 1..<index1!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac7b4bbcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac7b48b3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac7b48b3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac7b48b313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac7b48b2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgwoami9j                        0x000055bae4e7bba5 <unavailable> + 11173

    6    tmpgwoami9j                        0x000055bae4e7ae4b <unavailable> + 7755

    7    libc.so.6                          0x00002ac7b4da8460 __libc_start_main +
    245

    8    tmpgwoami9j                        0x000055bae4e7a379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let start = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ end = planets.firstIndex(of: planet2) ?? -1\n    if start == -1 || end == -1\
    \ {\n        return []\n    }\n    return planets[start...end].sorted()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpjymbsopg/tmpjymbsopg.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab022ff4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab022cebb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab022ceb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab022cea7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjymbsopg                        0x00005628f9da188b <unavailable> + 6283

    5    libc.so.6                          0x00002ab0231e0460 __libc_start_main +
    245

    6    tmpjymbsopg                        0x00005628f9da1439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    guard let p1 = planet1Index,\
    \ let p2 = planet2Index else {\n        return []\n    }\n    let start = min(p1,\
    \ p2)\n    let end = max(p1, p2)\n    return Array(planets[start...end])\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp7n2rqvy5/tmp7n2rqvy5.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b82ae4c9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b82ae1c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b82ae1c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b82ae1bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7n2rqvy5                        0x000055a2bc24694b <unavailable> + 6475

    5    libc.so.6                          0x00002b82ae6b5460 __libc_start_main +
    245

    6    tmp7n2rqvy5                        0x000055a2bc2464f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let firstIndex = planets.firstIndex(of: planet1)\n    let\
    \ secondIndex = planets.firstIndex(of: planet2)\n    if firstIndex == nil || secondIndex\
    \ == nil {\n        return []\n    }\n    if firstIndex! > secondIndex! {\n  \
    \      return Array(planets[secondIndex!...firstIndex!])\n    } else {\n     \
    \   return Array(planets[firstIndex!...secondIndex!])\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpyqeaauvh/tmpyqeaauvh.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aadc3addc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aadc37d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aadc37d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aadc37d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyqeaauvh                        0x0000564c3063485b <unavailable> + 6235

    5    libc.so.6                          0x00002aadc3cc9460 __libc_start_main +
    245

    6    tmpyqeaauvh                        0x0000564c30634409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! < index2! {\n        return Array(planets[index1!\
    \ + 1 ..< index2!])\n    } else {\n        return Array(planets[index2! + 1 ..<\
    \ index1!])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b2727d64c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2727a5b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2727a5b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2727a5b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2727a5abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmploza5c9k                        0x000055855a89bba5 <unavailable> + 11173

    6    tmploza5c9k                        0x000055855a89ae4b <unavailable> + 7755

    7    libc.so.6                          0x00002b2727f50460 __libc_start_main +
    245

    8    tmploza5c9k                        0x000055855a89a379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let start = planets.firstIndex(of: planet1), let end\
    \ = planets.firstIndex(of: planet2) else { return [] }\n    return start < end\
    \ ? Array(planets[start+1..<end]) : Array(planets[end+1..<start])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b19e89d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19e86ca561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b19e86ca286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b19e86ca13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b19e86c9bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpx749_t_s                        0x000055ff6e30c7b6 <unavailable> + 10166

    6    tmpx749_t_s                        0x000055ff6e30be4b <unavailable> + 7755

    7    libc.so.6                          0x00002b19e8bbf460 __libc_start_main +
    245

    8    tmpx749_t_s                        0x000055ff6e30b379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! < index2! {\n        return Array(planets[index1!\
    \ + 1...index2! - 1])\n    } else {\n        return Array(planets[index2! + 1...index1!\
    \ - 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b3bf2307c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3bf1ffe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3bf1ffe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3bf1ffe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3bf1ffdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpox6xp_ws                        0x000055b48cd0fd9f <unavailable> + 11679

    6    tmpox6xp_ws                        0x000055b48cd0eedb <unavailable> + 7899

    7    libc.so.6                          0x00002b3bf24f3460 __libc_start_main +
    245

    8    tmpox6xp_ws                        0x000055b48cd0e409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1),\n    \
    \    let index2 = planets.firstIndex(of: planet2) else {\n            return []\n\
    \    }\n    let start = min(index1, index2)\n    let end = max(index1, index2)\n\
    \    return Array(planets[start...end])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmprs8_6juq/tmprs8_6juq.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3db252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3daf49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3daf49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3daf487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprs8_6juq                        0x000055a7d949094b <unavailable> + 6475

    5    libc.so.6                          0x00002ab3db43e460 __libc_start_main +
    245

    6    tmprs8_6juq                        0x000055a7d94904f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    guard let p1 = planet1Index,\
    \ let p2 = planet2Index else { return [] }\n    if p1 > p2 {\n        return Array(planets[p2...p1])\n\
    \    } else {\n        return Array(planets[p1...p2])\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp30k2bew7/tmp30k2bew7.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5fde9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5fdb94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5fdb94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5fdb937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp30k2bew7                        0x000055bc79a7685b <unavailable> + 6235

    5    libc.so.6                          0x00002ba5fe089460 __libc_start_main +
    245

    6    tmp30k2bew7                        0x000055bc79a76409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let planetsBetween = planets[min(planet1Index!,\
    \ planet2Index!) + 1..<max(planet1Index!, planet2Index!)]\n    return Array(planetsBetween)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b0ed5d67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0ed5a5e561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0ed5a5e286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0ed5a5e13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0ed5a5dbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp6g4u6g19                        0x0000557332bd6b1c <unavailable> + 11036

    6    tmp6g4u6g19                        0x0000557332bd5f2b <unavailable> + 7979

    7    libc.so.6                          0x00002b0ed5f53460 __libc_start_main +
    245

    8    tmp6g4u6g19                        0x0000557332bd5459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result: [String] = []\n    let planet1Index = planets.firstIndex(of:\
    \ planet1)\n    let planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index\
    \ == nil || planet2Index == nil {\n        return result\n    }\n    if planet1Index!\
    \ < planet2Index! {\n        for i in planet1Index! + 1..<planet2Index! {\n  \
    \          result.append(planets[i])\n        }\n    } else {\n        for i in\
    \ planet2Index! + 1..<planet1Index! {\n            result.append(planets[i])\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b6bf60a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6bf5d98561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6bf5d98286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6bf5d9813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6bf5d97bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpzu93xdwl                        0x00005577b4a14c56 <unavailable> + 11350

    6    tmpzu93xdwl                        0x00005577b4a13e8b <unavailable> + 7819

    7    libc.so.6                          0x00002b6bf628d460 __libc_start_main +
    245

    8    tmpzu93xdwl                        0x00005577b4a133b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! < index2! {\n        return Array(planets[index1!\
    \ + 1..<index2!])\n    } else {\n        return Array(planets[index2! + 1..<index1!])\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ac7b4bbcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac7b48b3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ac7b48b3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ac7b48b313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ac7b48b2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgwoami9j                        0x000055bae4e7bba5 <unavailable> + 11173

    6    tmpgwoami9j                        0x000055bae4e7ae4b <unavailable> + 7755

    7    libc.so.6                          0x00002ac7b4da8460 __libc_start_main +
    245

    8    tmpgwoami9j                        0x000055bae4e7a379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result: [String] = []\n    guard let planet1Index = planets.firstIndex(of:\
    \ planet1),\n        let planet2Index = planets.firstIndex(of: planet2) else {\n\
    \            return result\n    }\n    if planet1Index > planet2Index {\n    \
    \    for i in planet2Index...planet1Index {\n            result.append(planets[i])\n\
    \        }\n    } else {\n        for i in planet1Index...planet2Index {\n   \
    \         result.append(planets[i])\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpsospr7fj/tmpsospr7fj.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae442291c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae441f88b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae441f88988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae441f877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsospr7fj                        0x000055d69371e80b <unavailable> + 6155

    5    libc.so.6                          0x00002ae44247d460 __libc_start_main +
    245

    6    tmpsospr7fj                        0x000055d69371e3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let first = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ second = planets.firstIndex(of: planet2) ?? -1\n    if first == -1 || second\
    \ == -1 {\n        return []\n    }\n    if first > second {\n        return Array(planets[second...first])\n\
    \    }\n    return Array(planets[first...second])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp09_gznju/tmp09_gznju.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b832fd70c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b832fa67b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b832fa67988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b832fa667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp09_gznju                        0x0000561da3ff285b <unavailable> + 6235

    5    libc.so.6                          0x00002b832ff5c460 __libc_start_main +
    245

    6    tmp09_gznju                        0x0000561da3ff2409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1),\n    \
    \    let index2 = planets.firstIndex(of: planet2) else {\n            return []\n\
    \    }\n    let start = min(index1, index2)\n    let end = max(index1, index2)\n\
    \    return Array(planets[start...end])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmprs8_6juq/tmprs8_6juq.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3db252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3daf49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3daf49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3daf487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprs8_6juq                        0x000055a7d949094b <unavailable> + 6475

    5    libc.so.6                          0x00002ab3db43e460 __libc_start_main +
    245

    6    tmprs8_6juq                        0x000055a7d94904f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1), let index2\
    \ = planets.firstIndex(of: planet2) else {\n        return []\n    }\n    return\
    \ index1 < index2 ? Array(planets[index1...index2]) : Array(planets[index2...index1])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpafzn4n0z/tmpafzn4n0z.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b03226b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b03223abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b03223ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b03223aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafzn4n0z                        0x000056458e43a85b <unavailable> + 6235

    5    libc.so.6                          0x00002b03228a0460 __libc_start_main +
    245

    6    tmpafzn4n0z                        0x000056458e43a409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! > index2! {\n        return Array(planets[index2!...index1!])\n\
    \    } else {\n        return Array(planets[index1!...index2!])\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpr8e3pkyf/tmpr8e3pkyf.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada98cd9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada989d0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada989d0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada989cf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr8e3pkyf                        0x000055982397885b <unavailable> + 6235

    5    libc.so.6                          0x00002ada98ec5460 __libc_start_main +
    245

    6    tmpr8e3pkyf                        0x0000559823978409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1...planet2Index! - 1])\n  \
    \  } else {\n        return Array(planets[planet2Index! + 1...planet1Index! -\
    \ 1].reversed())\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpye8so7v6/tmpye8so7v6.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae2c6e1fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2c6b16b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2c6b16988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2c6b157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpye8so7v6                        0x0000559912f00fc2 <unavailable> + 8130

    5    libc.so.6                          0x00002ae2c700b460 __libc_start_main +
    245

    6    tmpye8so7v6                        0x0000559912f00559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1), let index2\
    \ = planets.firstIndex(of: planet2) else { return [] }\n    return index1 < index2\
    \ ? Array(planets[index1+1..<index2]) : Array(planets[index2+1..<index1])\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b156a0edc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1569de4561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1569de4286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1569de413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1569de3bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpsfi0ol8u                        0x000055aa5e5477b6 <unavailable> + 10166

    6    tmpsfi0ol8u                        0x000055aa5e546e4b <unavailable> + 7755

    7    libc.so.6                          0x00002b156a2d9460 __libc_start_main +
    245

    8    tmpsfi0ol8u                        0x000055aa5e546379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    guard let p1Index = planet1Index,\
    \ let p2Index = planet2Index else {\n        return []\n    }\n    if p1Index\
    \ > p2Index {\n        return Array(planets[p2Index...p1Index])\n    } else {\n\
    \        return Array(planets[p1Index...p2Index])\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpgn76v039/tmpgn76v039.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c7be70c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c7bb67b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c7bb67988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c7bb667b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgn76v039                        0x000055923bdfc85b <unavailable> + 6235

    5    libc.so.6                          0x00002b5c7c05c460 __libc_start_main +
    245

    6    tmpgn76v039                        0x000055923bdfc409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let idx1 = planets.firstIndex(of: planet1)\n    let idx2 =\
    \ planets.firstIndex(of: planet2)\n    if idx1 == nil || idx2 == nil {\n     \
    \   return []\n    }\n    let minIdx = min(idx1!, idx2!)\n    let maxIdx = max(idx1!,\
    \ idx2!)\n    return Array(planets[minIdx...maxIdx])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp7l0pw_o2/tmp7l0pw_o2.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b17b7e8ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17b7b81b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17b7b81988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17b7b807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7l0pw_o2                        0x0000556faa3c794b <unavailable> + 6475

    5    libc.so.6                          0x00002b17b8076460 __libc_start_main +
    245

    6    tmp7l0pw_o2                        0x0000556faa3c74f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    return planets[min(p1, p2) + 1 ..< max(p1,\
    \ p2)].reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp106ugchz/tmp106ugchz.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af665d6bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af665a62b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af665a62988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af665a617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp106ugchz                        0x000055e4f14fd89b <unavailable> + 6299

    5    libc.so.6                          0x00002af665f57460 __libc_start_main +
    245

    6    tmp106ugchz                        0x000055e4f14fd449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if let planet1Index = planet1Index,\
    \ let planet2Index = planet2Index {\n        if planet1Index < planet2Index {\n\
    \            return Array(planets[planet1Index + 1..<planet2Index])\n        }\
    \ else {\n            return Array(planets[planet2Index + 1..<planet1Index])\n\
    \        }\n    }\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b20127eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20124e5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b20124e5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b20124e513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b20124e4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpbiplxnph                        0x000055d91a4cb851 <unavailable> + 10321

    6    tmpbiplxnph                        0x000055d91a4cae4b <unavailable> + 7755

    7    libc.so.6                          0x00002b20129da460 __libc_start_main +
    245

    8    tmpbiplxnph                        0x000055d91a4ca379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    if index1! > index2! {\n        return Array(planets[index2!...index1!])\n\
    \    } else {\n        return Array(planets[index1!...index2!])\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpr8e3pkyf/tmpr8e3pkyf.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada98cd9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada989d0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada989d0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada989cf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr8e3pkyf                        0x000055982397885b <unavailable> + 6235

    5    libc.so.6                          0x00002ada98ec5460 __libc_start_main +
    245

    6    tmpr8e3pkyf                        0x0000559823978409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result = [String]()\n    var start = 0\n    var end =\
    \ 0\n    for i in 0..<planets.count {\n        if planets[i] == planet1 {\n  \
    \          start = i\n        }\n        if planets[i] == planet2 {\n        \
    \    end = i\n        }\n    }\n    if start == 0 && end == 0 {\n        return\
    \ result\n    }\n    if start > end {\n        let temp = start\n        start\
    \ = end\n        end = temp\n    }\n    for i in start..<end {\n        result.append(planets[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpr4yb2yhh/tmpr4yb2yhh.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3b7ee5cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3b7eb53b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3b7eb53988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3b7eb527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr4yb2yhh                        0x000055fbad2b785b <unavailable> + 6235

    5    libc.so.6                          0x00002b3b7f048460 __libc_start_main +
    245

    6    tmpr4yb2yhh                        0x000055fbad2b7409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let p1 = planets.firstIndex(of: planet1)\n    let p2 = planets.firstIndex(of:\
    \ planet2)\n    if p1 == nil || p2 == nil {\n        return []\n    }\n    if\
    \ p1! > p2! {\n        return Array(planets[p2!...p1!])\n    }\n    return Array(planets[p1!...p2!])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpkm_5tygp/tmpkm_5tygp.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5a02b8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af59ffafb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af59ffaf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af59ffae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkm_5tygp                        0x000055dac615285b <unavailable> + 6235

    5    libc.so.6                          0x00002af5a04a4460 __libc_start_main +
    245

    6    tmpkm_5tygp                        0x000055dac6152409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let start = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ end = planets.firstIndex(of: planet2) ?? -1\n    if start == -1 || end == -1\
    \ {\n        return []\n    }\n    let result = planets[start...end].sorted(by:\
    \ { planets.firstIndex(of: $0)! < planets.firstIndex(of: $1)! })\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpcrlur3as/tmpcrlur3as.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b569f504c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b569f1fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b569f1fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b569f1fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcrlur3as                        0x0000560a1fc3b85b <unavailable> + 6235

    5    libc.so.6                          0x00002b569f6f0460 __libc_start_main +
    245

    6    tmpcrlur3as                        0x0000560a1fc3b409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let first = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ second = planets.firstIndex(of: planet2) ?? -1\n    if first == -1 || second\
    \ == -1 {\n        return []\n    }\n    return first < second ? Array(planets[first...second])\
    \ : Array(planets[second...first])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmp1e3iu9px/tmp1e3iu9px.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afdc8415c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afdc810cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afdc810c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afdc810b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1e3iu9px                        0x000055ce11b7e85b <unavailable> + 6235

    5    libc.so.6                          0x00002afdc8601460 __libc_start_main +
    245

    6    tmp1e3iu9px                        0x000055ce11b7e409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1),\n    \
    \    let index2 = planets.firstIndex(of: planet2) else {\n            return []\n\
    \    }\n    let start = min(index1, index2)\n    let end = max(index1, index2)\n\
    \    return Array(planets[start...end])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmprs8_6juq/tmprs8_6juq.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3db252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3daf49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3daf49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3daf487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprs8_6juq                        0x000055a7d949094b <unavailable> + 6475

    5    libc.so.6                          0x00002ab3db43e460 __libc_start_main +
    245

    6    tmprs8_6juq                        0x000055a7d94904f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result = [String]()\n    guard let firstIndex = planets.firstIndex(of:\
    \ planet1),\n        let secondIndex = planets.firstIndex(of: planet2) else {\n\
    \            return result\n    }\n    if firstIndex < secondIndex {\n       \
    \ for i in firstIndex + 1 ..< secondIndex {\n            result.append(planets[i])\n\
    \        }\n    } else {\n        for i in secondIndex + 1 ..< firstIndex {\n\
    \            result.append(planets[i])\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c49792c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c49489561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9c49489286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9c4948913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9c49488bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmphduu1o3a                        0x0000556e079a28f8 <unavailable> + 10488

    6    tmphduu1o3a                        0x0000556e079a1edb <unavailable> + 7899

    7    libc.so.6                          0x00002b9c4997e460 __libc_start_main +
    245

    8    tmphduu1o3a                        0x0000556e079a1409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let start = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ end = planets.firstIndex(of: planet2) ?? -1\n    if start == -1 || end == -1\
    \ {\n        return []\n    }\n    if start < end {\n        return Array(planets[start...end])\n\
    \    } else {\n        return Array(planets[end...start].reversed())\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp2c1airpr/tmp2c1airpr.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1a56c1dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1a56914b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1a56914988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1a569137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2c1airpr                        0x0000563ca96819ab <unavailable> + 6571

    5    libc.so.6                          0x00002b1a56e09460 __libc_start_main +
    245

    6    tmp2c1airpr                        0x0000563ca9681559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else {\n        return []\n    }\n    return p1 < p2 ? Array(planets[p1...p2])\
    \ : Array(planets[p2...p1]).reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmp6y_oy9vh/tmp6y_oy9vh.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4239f8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4239c82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4239c82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4239c817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6y_oy9vh                        0x0000563314c628bb <unavailable> + 6331

    5    libc.so.6                          0x00002b423a177460 __libc_start_main +
    245

    6    tmp6y_oy9vh                        0x0000563314c62469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1...planet2Index! - 1])\n  \
    \  } else {\n        return Array(planets[planet2Index! + 1...planet1Index! -\
    \ 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b47931c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4792ebf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4792ebf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4792ebf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4792ebebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpbon39hqh                        0x0000559961f06d9f <unavailable> + 11679

    6    tmpbon39hqh                        0x0000559961f05edb <unavailable> + 7899

    7    libc.so.6                          0x00002b47933b4460 __libc_start_main +
    245

    8    tmpbon39hqh                        0x0000559961f05409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let idx1 = planets.firstIndex(of: planet1)\n    let idx2 =\
    \ planets.firstIndex(of: planet2)\n    guard let i1 = idx1, let i2 = idx2 else\
    \ {\n        return []\n    }\n    let minIdx = min(i1, i2)\n    let maxIdx =\
    \ max(i1, i2)\n    return Array(planets[minIdx...maxIdx])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpv5jjpvds/tmpv5jjpvds.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad222bebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad2228e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad2228e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2228e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv5jjpvds                        0x000055cdbc8c994b <unavailable> + 6475

    5    libc.so.6                          0x00002ad222dd7460 __libc_start_main +
    245

    6    tmpv5jjpvds                        0x000055cdbc8c94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    let min = min(p1, p2)\n    let max = max(p1,\
    \ p2)\n    return Array(planets[min...max])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmph9204re1/tmph9204re1.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad431b6ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad431861b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad431861988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad4318607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph9204re1                        0x0000564d206ed94b <unavailable> + 6475

    5    libc.so.6                          0x00002ad431d56460 __libc_start_main +
    245

    6    tmph9204re1                        0x0000564d206ed4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else {\n        return []\n    }\n    return p1 < p2 ? Array(planets[p1...p2])\
    \ : Array(planets[p2...p1]).reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmp6y_oy9vh/tmp6y_oy9vh.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4239f8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4239c82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4239c82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4239c817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6y_oy9vh                        0x0000563314c628bb <unavailable> + 6331

    5    libc.so.6                          0x00002b423a177460 __libc_start_main +
    245

    6    tmp6y_oy9vh                        0x0000563314c62469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let p1 = planets.firstIndex(of: planet1), let p2 = planets.firstIndex(of:\
    \ planet2) else { return [] }\n    let min = min(p1, p2)\n    let max = max(p1,\
    \ p2)\n    return Array(planets[min...max])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmph9204re1/tmph9204re1.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad431b6ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad431861b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad431861988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad4318607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph9204re1                        0x0000564d206ed94b <unavailable> + 6475

    5    libc.so.6                          0x00002ad431d56460 __libc_start_main +
    245

    6    tmph9204re1                        0x0000564d206ed4f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1...planet2Index! - 1])\n  \
    \  } else {\n        return Array(planets[planet2Index! + 1...planet1Index! -\
    \ 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b47931c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4792ebf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4792ebf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4792ebf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4792ebebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpbon39hqh                        0x0000559961f06d9f <unavailable> + 11679

    6    tmpbon39hqh                        0x0000559961f05edb <unavailable> + 7899

    7    libc.so.6                          0x00002b47933b4460 __libc_start_main +
    245

    8    tmpbon39hqh                        0x0000559961f05409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    guard let index1 = planets.firstIndex(of: planet1), let index2\
    \ = planets.firstIndex(of: planet2) else {\n        return []\n    }\n    return\
    \ index1 < index2 ? Array(planets[index1...index2]) : Array(planets[index2...index1])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpafzn4n0z/tmpafzn4n0z.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b03226b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b03223abb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b03223ab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b03223aa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpafzn4n0z                        0x000056458e43a85b <unavailable> + 6235

    5    libc.so.6                          0x00002b03228a0460 __libc_start_main +
    245

    6    tmpafzn4n0z                        0x000056458e43a409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let index1 = planets.firstIndex(of: planet1)\n    let index2\
    \ = planets.firstIndex(of: planet2)\n    if index1 == nil || index2 == nil {\n\
    \        return []\n    }\n    let start = min(index1!, index2!)\n    let end\
    \ = max(index1!, index2!)\n    return Array(planets[start...end])\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpw_8ei1rd/tmpw_8ei1rd.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b80fcd35c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b80fca2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b80fca2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b80fca2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw_8ei1rd                        0x0000555ad2ed294b <unavailable> + 6475

    5    libc.so.6                          0x00002b80fcf21460 __libc_start_main +
    245

    6    tmpw_8ei1rd                        0x0000555ad2ed24f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! > planet2Index!\
    \ {\n        return Array(planets[planet2Index!...planet1Index!])\n    } else\
    \ {\n        return Array(planets[planet1Index!...planet2Index!])\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpibx8pw1a/tmpibx8pw1a.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89ed9e6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89ed6ddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89ed6dd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89ed6dc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpibx8pw1a                        0x00005636f61ed85b <unavailable> + 6235

    5    libc.so.6                          0x00002b89edbd2460 __libc_start_main +
    245

    6    tmpibx8pw1a                        0x00005636f61ed409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let start = planets.firstIndex(of: planet1) ?? -1\n    let\
    \ end = planets.firstIndex(of: planet2) ?? -1\n    if start == -1 || end == -1\
    \ {\n        return []\n    }\n    let result = planets[start...end].sorted()\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpaivu4ajx/tmpaivu4ajx.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9358538c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b935822fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b935822f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b935822e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaivu4ajx                        0x000055e7211ad88b <unavailable> + 6283

    5    libc.so.6                          0x00002b9358724460 __libc_start_main +
    245

    6    tmpaivu4ajx                        0x000055e7211ad439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659823174
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    if planet1Index! < planet2Index!\
    \ {\n        return Array(planets[planet1Index! + 1...planet2Index! - 1])\n  \
    \  } else {\n        return Array(planets[planet2Index! + 1...planet1Index! -\
    \ 1])\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b47931c8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4792ebf561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4792ebf286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4792ebf13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4792ebebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpbon39hqh                        0x0000559961f06d9f <unavailable> + 11679

    6    tmpbon39hqh                        0x0000559961f05edb <unavailable> + 7899

    7    libc.so.6                          0x00002b47933b4460 __libc_start_main +
    245

    8    tmpbon39hqh                        0x0000559961f05409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    guard let p1 = planet1Index,\
    \ let p2 = planet2Index else { return [] }\n    let start = min(p1, p2)\n    let\
    \ end = max(p1, p2)\n    return Array(planets[start...end])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpb1e2ugo9/tmpb1e2ugo9.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba404c67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba40495eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba40495e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba40495d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb1e2ugo9                        0x000055c7cb3d394b <unavailable> + 6475

    5    libc.so.6                          0x00002ba404e53460 __libc_start_main +
    245

    6    tmpb1e2ugo9                        0x000055c7cb3d34f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823173
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    let planet1Index = planets.firstIndex(of: planet1)\n    let\
    \ planet2Index = planets.firstIndex(of: planet2)\n    if planet1Index == nil ||\
    \ planet2Index == nil {\n        return []\n    }\n    let startIndex = min(planet1Index!,\
    \ planet2Index!)\n    let endIndex = max(planet1Index!, planet2Index!)\n    return\
    \ Array(planets[startIndex...endIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpxco6njne/tmpxco6njne.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac70dd98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac70da8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac70da8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac70da8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxco6njne                        0x0000560c6cce994b <unavailable> + 6475

    5    libc.so.6                          0x00002ac70df84460 __libc_start_main +
    245

    6    tmpxco6njne                        0x0000560c6cce94f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659823172
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    let planets = [\"\
    Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    var result = [String]()\n    var start = 0\n    var end =\
    \ 0\n    for i in 0..<planets.count {\n        if planets[i] == planet1 {\n  \
    \          start = i\n        }\n        if planets[i] == planet2 {\n        \
    \    end = i\n        }\n    }\n    if start == 0 && end == 0 {\n        return\
    \ result\n    }\n    if start > end {\n        let temp = start\n        start\
    \ = end\n        end = temp\n    }\n    for i in start+1..<end {\n        result.append(planets[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b6ee6fb5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6ee6cac561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6ee6cac286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6ee6cac13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6ee6cabbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpqdg5v4im                        0x00005651fc0648af <unavailable> + 10415

    6    tmpqdg5v4im                        0x00005651fc063edb <unavailable> + 7899

    7    libc.so.6                          0x00002b6ee71a1460 __libc_start_main +
    245

    8    tmpqdg5v4im                        0x00005651fc063409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659823174
