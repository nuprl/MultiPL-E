name: HumanEval_68_pluck
language: swift
prompt: "\n/// \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n/// your task is to pluck one of the nodes and return it.\n///\
  \ The plucked node should be the node with the smallest even value.\n/// If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n/// The plucked node should be returned in a list, [ smalest_value, its\
  \ index ],\n/// If there are no even values or the given array is empty, return\
  \ [].\n/// Example 1:\n/// Input: [4,2,3]\n/// Output: [2, 1]\n/// Explanation:\
  \ 2 has the smallest even value, and 2 has the smallest index.\n/// Example 2:\n\
  /// Input: [1,2,3]\n/// Output: [2, 1]\n/// Explanation: 2 has the smallest even\
  \ value, and 2 has the smallest index. \n/// Example 3:\n/// Input: []\n/// Output:\
  \ []\n/// Example 4:\n/// Input: [5, 0, 3, 0, 4, 2]\n/// Output: [0, 1]\n/// Explanation:\
  \ 0 is the smallest value, but  there are two zeros,\n/// so we will choose the\
  \ first zero, which has the smallest index.\n/// Constraints:\n/// * 1 <= nodes.length\
  \ <= 10000\n/// * 0 <= node.value\nfunc pluck(arr: [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(pluck(arr: [4, 2, 3]) == [2, 1])\nassert(pluck(arr:\
  \ [1, 2, 3]) == [2, 1])\nassert(pluck(arr: [] as [Int]) == [] as [Int])\nassert(pluck(arr:\
  \ [5, 0, 3, 0, 4, 2]) == [0, 1])\nassert(pluck(arr: [1, 2, 3, 0, 5, 3]) == [0, 3])\n\
  assert(pluck(arr: [5, 4, 8, 4, 8]) == [4, 1])\nassert(pluck(arr: [7, 6, 7, 1]) ==\
  \ [6, 1])\nassert(pluck(arr: [7, 9, 7, 1]) == [] as [Int])"
completions: ["    var minEven = Int.max\n    var minEvenIndex = -1\n    for i in\
    \ 0..<arr.count {\n        if arr[i] % 2 == 0 {\n            if arr[i] < minEven\
    \ {\n                minEven = arr[i]\n                minEvenIndex = i\n    \
    \        }\n        }\n    }\n    if minEvenIndex == -1 {\n        return []\n\
    \    }\n    return [minEven, minEvenIndex]", "    var evens = [Int]()\n    var\
    \ index = 0\n    for i in arr {\n        if i % 2 == 0 {\n            evens.append(i)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    evens.sort()\n\
    \    for i in arr {\n        if i == evens[0] {\n            return [i, index]\n\
    \        }\n        index += 1\n    }\n    return []", "    var evens = [Int]()\n\
    \    var index = 0\n    for i in arr {\n        if i % 2 == 0 {\n            evens.append(i)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    let\
    \ min = evens.min()!\n    for i in arr {\n        if i == min {\n            return\
    \ [i, index]\n        }\n        index += 1\n    }\n    return []", "    var minEven\
    \ = Int.max\n    var minEvenIndex = -1\n    for (i, n) in arr.enumerated() {\n\
    \        if n % 2 == 0 && n < minEven {\n            minEven = n\n           \
    \ minEvenIndex = i\n        }\n    }\n    if minEvenIndex == -1 {\n        return\
    \ []\n    }\n    return [minEven, minEvenIndex]", "    var minEven = Int.max\n\
    \    var minEvenIndex = -1\n    for (index, element) in arr.enumerated() {\n \
    \       if element % 2 == 0 {\n            if element < minEven {\n          \
    \      minEven = element\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEvenIndex == -1 {\n        return []\n    }\n   \
    \ return [minEven, minEvenIndex]", "    var minEven = Int.max\n    var minEvenIndex\
    \ = -1\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 && value < minEven {\n            minEven = value\n            minEvenIndex\
    \ = index\n        }\n    }\n    if minEvenIndex == -1 {\n        return []\n\
    \    }\n    return [minEven, minEvenIndex]", "    var evens = [Int]()\n    var\
    \ index = 0\n    for i in arr {\n        if i % 2 == 0 {\n            evens.append(i)\n\
    \        }\n    }\n    if evens.count == 0 {\n        return []\n    }\n    evens.sort()\n\
    \    for i in arr {\n        if i == evens[0] {\n            return [i, index]\n\
    \        }\n        index += 1\n    }\n    return []", "    guard arr.count >\
    \ 0 else { return [] }\n    var minEven = Int.max\n    var minEvenIndex = -1\n\
    \    for i in 0..<arr.count {\n        if arr[i] % 2 == 0 {\n            if arr[i]\
    \ < minEven {\n                minEven = arr[i]\n                minEvenIndex\
    \ = i\n            }\n        }\n    }\n    if minEvenIndex == -1 {\n        return\
    \ []\n    }\n    return [minEven, minEvenIndex]", "    var minEven = Int.max\n\
    \    var minEvenIndex = -1\n    for (index, value) in arr.enumerated() {\n   \
    \     if value % 2 == 0 && value < minEven {\n            minEven = value\n  \
    \          minEvenIndex = index\n        }\n    }\n    if minEvenIndex == -1 {\n\
    \        return []\n    }\n    return [minEven, minEvenIndex]", "    var minEven\
    \ = Int.max\n    var minEvenIndex = -1\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 && value < minEven {\n            minEven = value\n\
    \            minEvenIndex = index\n        }\n    }\n    if minEvenIndex == -1\
    \ {\n        return []\n    }\n    return [minEven, minEvenIndex]", "    var result\
    \ = [Int]()\n    var min = Int.max\n    var index = 0\n    var minIndex = 0\n\
    \    for i in 0..<arr.count {\n        if arr[i] % 2 == 0 {\n            if arr[i]\
    \ < min {\n                min = arr[i]\n                minIndex = i\n      \
    \      }\n        }\n    }\n    if min != Int.max {\n        result.append(min)\n\
    \        result.append(minIndex)\n    }\n    return result", "    var minEven\
    \ = Int.max\n    var minEvenIndex = -1\n    for (index, value) in arr.enumerated()\
    \ {\n        if value % 2 == 0 {\n            if value < minEven {\n         \
    \       minEven = value\n                minEvenIndex = index\n            }\n\
    \        }\n    }\n    if minEvenIndex == -1 {\n        return []\n    }\n   \
    \ return [minEven, minEvenIndex]", "    var minEven = Int.max\n    var minEvenIndex\
    \ = -1\n    for (index, value) in arr.enumerated() {\n        if value % 2 ==\
    \ 0 && value < minEven {\n            minEven = value\n            minEvenIndex\
    \ = index\n        }\n    }\n    if minEvenIndex == -1 {\n        return []\n\
    \    }\n    return [minEven, minEvenIndex]", "    var result = [Int]()\n    var\
    \ minEven = Int.max\n    var minEvenIndex = Int.max\n    for (index, element)\
    \ in arr.enumerated() {\n        if element % 2 == 0 {\n            if element\
    \ < minEven {\n                minEven = element\n                minEvenIndex\
    \ = index\n            }\n        }\n    }\n    if minEven != Int.max {\n    \
    \    result.append(minEven)\n        result.append(minEvenIndex)\n    }\n    return\
    \ result", "    guard arr.count > 0 else { return [] }\n    var minEven = Int.max\n\
    \    var minEvenIndex = -1\n    for (index, value) in arr.enumerated() {\n   \
    \     if value % 2 == 0 {\n            if value < minEven {\n                minEven\
    \ = value\n                minEvenIndex = index\n            }\n        }\n  \
    \  }\n    if minEvenIndex == -1 {\n        return []\n    }\n    return [minEven,\
    \ minEvenIndex]", "    var minEven = Int.max\n    var minEvenIndex = -1\n    for\
    \ (index, value) in arr.enumerated() {\n        if value % 2 == 0 && value < minEven\
    \ {\n            minEven = value\n            minEvenIndex = index\n        }\n\
    \    }\n    if minEvenIndex == -1 {\n        return []\n    }\n    return [minEven,\
    \ minEvenIndex]", "    var result = [Int]()\n    var evens = [Int]()\n    for\
    \ (index, value) in arr.enumerated() {\n        if value % 2 == 0 {\n        \
    \    evens.append(value)\n            result.append(index)\n        }\n    }\n\
    \    if evens.count > 0 {\n        let min = evens.min()!\n        let index =\
    \ evens.firstIndex(of: min)!\n        return [min, result[index]]\n    }\n   \
    \ return []", "    guard arr.count > 0 else { return [] }\n    var minEven = Int.max\n\
    \    var minEvenIndex = Int.max\n    for (index, value) in arr.enumerated() {\n\
    \        if value % 2 == 0 && value < minEven {\n            minEven = value\n\
    \            minEvenIndex = index\n        }\n    }\n    return minEven == Int.max\
    \ ? [] : [minEven, minEvenIndex]", "    var evens = [Int]()\n    var evensIndex\
    \ = [Int]()\n    for i in 0..<arr.count {\n        if arr[i] % 2 == 0 {\n    \
    \        evens.append(arr[i])\n            evensIndex.append(i)\n        }\n \
    \   }\n    if evens.count == 0 {\n        return []\n    }\n    var min = evens[0]\n\
    \    var minIndex = evensIndex[0]\n    for i in 1..<evens.count {\n        if\
    \ evens[i] < min {\n            min = evens[i]\n            minIndex = evensIndex[i]\n\
    \        }\n    }\n    return [min, minIndex]", "    var minEven = Int.max\n \
    \   var minEvenIndex = -1\n    for (index, value) in arr.enumerated() {\n    \
    \    if value % 2 == 0 && value < minEven {\n            minEven = value\n   \
    \         minEvenIndex = index\n        }\n    }\n    if minEvenIndex == -1 {\n\
    \        return []\n    }\n    return [minEven, minEvenIndex]"]
stop_tokens:
- "\n}"
