language: swift
name: HumanEval_9_rolling_max
results:
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_value = 0\n    for number\
    \ in numbers {\n        max_value = max(max_value, number)\n        result.append(max_value)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b41a4a93c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41a478a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b41a478a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b41a478a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b41a4789bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b41a4589e83 <unavailable> + 188035

    6    tmpgwpxtpbk                        0x000055cca7d49b58 <unavailable> + 7000

    7    tmpgwpxtpbk                        0x000055cca7d4962d <unavailable> + 5677

    8    libc.so.6                          0x00002b41a4c7f460 __libc_start_main +
    245

    9    tmpgwpxtpbk                        0x000055cca7d49339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n   \
    \ for number in numbers {\n        current_max = max(current_max, number)\n  \
    \      result.append(current_max)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aba33f07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aba33bfe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aba33bfe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aba33bfe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aba33bfdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aba339fde83 <unavailable> + 188035

    6    tmpeko4ehv6                        0x000055d5f99b0af8 <unavailable> + 6904

    7    tmpeko4ehv6                        0x000055d5f99b05bd <unavailable> + 5565

    8    libc.so.6                          0x00002aba340f3460 __libc_start_main +
    245

    9    tmpeko4ehv6                        0x000055d5f99b02c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b60c1389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60c1080561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b60c1080286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b60c108013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b60c107fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b60c0e7fe83 <unavailable> + 188035

    6    tmpux4nvvi2                        0x0000564626608a5f <unavailable> + 6751

    7    tmpux4nvvi2                        0x000056462660852d <unavailable> + 5421

    8    libc.so.6                          0x00002b60c1575460 __libc_start_main +
    245

    9    tmpux4nvvi2                        0x0000564626608239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_value = Int.min\n    for number\
    \ in numbers {\n        max_value = max(max_value, number)\n        result.append(max_value)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab2796efc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab2793e6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab2793e6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab2793e613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab2793e5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab2791e5e83 <unavailable> + 188035

    6    tmpp44wv3se                        0x0000556acc98ba5f <unavailable> + 6751

    7    tmpp44wv3se                        0x0000556acc98b52d <unavailable> + 5421

    8    libc.so.6                          0x00002ab2798db460 __libc_start_main +
    245

    9    tmpp44wv3se                        0x0000556acc98b239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b60c1389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60c1080561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b60c1080286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b60c108013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b60c107fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b60c0e7fe83 <unavailable> + 188035

    6    tmpux4nvvi2                        0x0000564626608a5f <unavailable> + 6751

    7    tmpux4nvvi2                        0x000056462660852d <unavailable> + 5421

    8    libc.so.6                          0x00002b60c1575460 __libc_start_main +
    245

    9    tmpux4nvvi2                        0x0000564626608239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c74ce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c749df561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6c749df286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6c749df13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6c749debb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6c747dee83 <unavailable> + 188035

    6    tmpuxrx8qb2                        0x000055aac3ebbaf8 <unavailable> + 6904

    7    tmpuxrx8qb2                        0x000055aac3ebb5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b6c74ed4460 __libc_start_main +
    245

    9    tmpuxrx8qb2                        0x000055aac3ebb2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var maxes = [Int]()\n    var max = Int.min\n    for number in\
    \ numbers {\n        if number > max {\n            max = number\n        }\n\
    \        maxes.append(max)\n    }\n    return maxes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5d11e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5d0edb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad5d0edb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad5d0edb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad5d0edabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad5d0cdae83 <unavailable> + 188035

    6    tmps6vm8iel                        0x000055957640ca52 <unavailable> + 6738

    7    tmps6vm8iel                        0x000055957640c52d <unavailable> + 5421

    8    libc.so.6                          0x00002ad5d13d0460 __libc_start_main +
    245

    9    tmps6vm8iel                        0x000055957640c239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [max_so_far]\n\
    \    for number in numbers[1..<numbers.count] {\n        max_so_far = max(max_so_far,\
    \ number)\n        result.append(max_so_far)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bb2b4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bb2843561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4bb2843286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4bb284313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4bb2842bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4bb2642e83 <unavailable> + 188035

    6    tmps2d9kzjq                        0x00005620c732dc38 <unavailable> + 7224

    7    tmps2d9kzjq                        0x00005620c732d70d <unavailable> + 5901

    8    libc.so.6                          0x00002b4bb2d38460 __libc_start_main +
    245

    9    tmps2d9kzjq                        0x00005620c732d419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b13b2683c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13b237a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13b237a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13b237a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13b2379bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13b2179e83 <unavailable> + 188035

    6    tmpzajpslmz                        0x00005563a1d57ae8 <unavailable> + 6888

    7    tmpzajpslmz                        0x00005563a1d575bd <unavailable> + 5565

    8    libc.so.6                          0x00002b13b286f460 __libc_start_main +
    245

    9    tmpzajpslmz                        0x00005563a1d572c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for i in\
    \ 0..<numbers.count {\n        max = max(max, numbers[i])\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpuwu33iuk.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c74ce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c749df561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6c749df286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6c749df13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6c749debb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6c747dee83 <unavailable> + 188035

    6    tmpuxrx8qb2                        0x000055aac3ebbaf8 <unavailable> + 6904

    7    tmpuxrx8qb2                        0x000055aac3ebb5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b6c74ed4460 __libc_start_main +
    245

    9    tmpuxrx8qb2                        0x000055aac3ebb2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number in numbers\
    \ {\n        max = max > number ? max : number\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acdbe75fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acdbe456561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acdbe456286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acdbe45613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acdbe455bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acdbe255e83 <unavailable> + 188035

    6    tmpwcb86u7i                        0x0000563cc4395a5f <unavailable> + 6751

    7    tmpwcb86u7i                        0x0000563cc439552d <unavailable> + 5421

    8    libc.so.6                          0x00002acdbe94b460 __libc_start_main +
    245

    9    tmpwcb86u7i                        0x0000563cc4395239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c74ce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c749df561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6c749df286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6c749df13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6c749debb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6c747dee83 <unavailable> + 188035

    6    tmpuxrx8qb2                        0x000055aac3ebbaf8 <unavailable> + 6904

    7    tmpuxrx8qb2                        0x000055aac3ebb5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b6c74ed4460 __libc_start_main +
    245

    9    tmpuxrx8qb2                        0x000055aac3ebb2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ n in numbers {\n        max_so_far = max(max_so_far, n)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b61724a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6172198561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6172198286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b617219813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6172197bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6171f97e83 <unavailable> + 188035

    6    tmpblietbr2                        0x0000557a3efd1af8 <unavailable> + 6904

    7    tmpblietbr2                        0x0000557a3efd15bd <unavailable> + 5565

    8    libc.so.6                          0x00002b617268d460 __libc_start_main +
    245

    9    tmpblietbr2                        0x0000557a3efd12c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for number\
    \ in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for number\
    \ in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_value = numbers[0]\n    for\
    \ number in numbers {\n        max_value = max(max_value, number)\n        result.append(max_value)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b763b5b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b763b2a8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b763b2a8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b763b2a813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b763b2a7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b763b0a7e83 <unavailable> + 188035

    6    tmptsao98xs                        0x00005626c9e54af8 <unavailable> + 6904

    7    tmptsao98xs                        0x00005626c9e545bd <unavailable> + 5565

    8    libc.so.6                          0x00002b763b79d460 __libc_start_main +
    245

    9    tmptsao98xs                        0x00005626c9e542c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number in numbers\
    \ {\n        max = max > number ? max : number\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b41a4a93c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41a478a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b41a478a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b41a478a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b41a4789bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b41a4589e83 <unavailable> + 188035

    6    tmpgwpxtpbk                        0x000055cca7d49b58 <unavailable> + 7000

    7    tmpgwpxtpbk                        0x000055cca7d4962d <unavailable> + 5677

    8    libc.so.6                          0x00002b41a4c7f460 __libc_start_main +
    245

    9    tmpgwpxtpbk                        0x000055cca7d49339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_value = Int.min\n    for number\
    \ in numbers {\n        max_value = max(max_value, number)\n        result.append(max_value)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for number in numbers[1..<numbers.count] {\n        if number > max_so_far\
    \ {\n            max_so_far = number\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b324f7d6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b324f4cd561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b324f4cd286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b324f4cd13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b324f4ccbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b324f2cce83 <unavailable> + 188035

    6    tmpjbhfrft8                        0x000055d18b8e9bfb <unavailable> + 7163

    7    tmpjbhfrft8                        0x000055d18b8e96cd <unavailable> + 5837

    8    libc.so.6                          0x00002b324f9c2460 __libc_start_main +
    245

    9    tmpjbhfrft8                        0x000055d18b8e93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_value = 0\n    for number\
    \ in numbers {\n        max_value = max(max_value, number)\n        result.append(max_value)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c74ce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c749df561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6c749df286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6c749df13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6c749debb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6c747dee83 <unavailable> + 188035

    6    tmpuxrx8qb2                        0x000055aac3ebbaf8 <unavailable> + 6904

    7    tmpuxrx8qb2                        0x000055aac3ebb5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b6c74ed4460 __libc_start_main +
    245

    9    tmpuxrx8qb2                        0x000055aac3ebb2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b60c1389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60c1080561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b60c1080286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b60c108013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b60c107fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b60c0e7fe83 <unavailable> + 188035

    6    tmpux4nvvi2                        0x0000564626608a5f <unavailable> + 6751

    7    tmpux4nvvi2                        0x000056462660852d <unavailable> + 5421

    8    libc.so.6                          0x00002b60c1575460 __libc_start_main +
    245

    9    tmpux4nvvi2                        0x0000564626608239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for number\
    \ in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number in numbers\
    \ {\n        max = max > number ? max : number\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [max_so_far]\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0655cecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06559e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b06559e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b06559e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b06559e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b06557e2e83 <unavailable> + 188035

    6    tmp_dok88g0                        0x0000558563940b08 <unavailable> + 6920

    7    tmp_dok88g0                        0x00005585639405dd <unavailable> + 5597

    8    libc.so.6                          0x00002b0655ed8460 __libc_start_main +
    245

    9    tmp_dok88g0                        0x00005585639402e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number in numbers\
    \ {\n        if number > max {\n            max = number\n        }\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b41a4a93c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41a478a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b41a478a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b41a478a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b41a4789bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b41a4589e83 <unavailable> + 188035

    6    tmpgwpxtpbk                        0x000055cca7d49b58 <unavailable> + 7000

    7    tmpgwpxtpbk                        0x000055cca7d4962d <unavailable> + 5677

    8    libc.so.6                          0x00002b41a4c7f460 __libc_start_main +
    245

    9    tmpgwpxtpbk                        0x000055cca7d49339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [max_so_far]\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0655cecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06559e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b06559e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b06559e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b06559e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b06557e2e83 <unavailable> + 188035

    6    tmp_dok88g0                        0x0000558563940b08 <unavailable> + 6920

    7    tmp_dok88g0                        0x00005585639405dd <unavailable> + 5597

    8    libc.so.6                          0x00002b0655ed8460 __libc_start_main +
    245

    9    tmp_dok88g0                        0x00005585639402e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for number\
    \ in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ i in 0..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aac3efc9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aac3ecc0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aac3ecc0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aac3ecc013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aac3ecbfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aac3eabfe83 <unavailable> + 188035

    6    tmpwkqaxt7n                        0x000055e1d4d46b68 <unavailable> + 7016

    7    tmpwkqaxt7n                        0x000055e1d4d4662d <unavailable> + 5677

    8    libc.so.6                          0x00002aac3f1b5460 __libc_start_main +
    245

    9    tmpwkqaxt7n                        0x000055e1d4d46339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c74ce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c749df561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6c749df286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6c749df13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6c749debb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6c747dee83 <unavailable> + 188035

    6    tmpuxrx8qb2                        0x000055aac3ebbaf8 <unavailable> + 6904

    7    tmpuxrx8qb2                        0x000055aac3ebb5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b6c74ed4460 __libc_start_main +
    245

    9    tmpuxrx8qb2                        0x000055aac3ebb2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [max_so_far]\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0655cecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06559e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b06559e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b06559e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b06559e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b06557e2e83 <unavailable> + 188035

    6    tmp_dok88g0                        0x0000558563940b08 <unavailable> + 6920

    7    tmp_dok88g0                        0x00005585639405dd <unavailable> + 5597

    8    libc.so.6                          0x00002b0655ed8460 __libc_start_main +
    245

    9    tmp_dok88g0                        0x00005585639402e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acdbe75fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acdbe456561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acdbe456286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acdbe45613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acdbe455bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acdbe255e83 <unavailable> + 188035

    6    tmpwcb86u7i                        0x0000563cc4395a5f <unavailable> + 6751

    7    tmpwcb86u7i                        0x0000563cc439552d <unavailable> + 5421

    8    libc.so.6                          0x00002acdbe94b460 __libc_start_main +
    245

    9    tmpwcb86u7i                        0x0000563cc4395239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for number in numbers[1..<numbers.count] {\n        if number > max_so_far\
    \ {\n            max_so_far = number\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b324f7d6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b324f4cd561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b324f4cd286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b324f4cd13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b324f4ccbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b324f2cce83 <unavailable> + 188035

    6    tmpjbhfrft8                        0x000055d18b8e9bfb <unavailable> + 7163

    7    tmpjbhfrft8                        0x000055d18b8e96cd <unavailable> + 5837

    8    libc.so.6                          0x00002b324f9c2460 __libc_start_main +
    245

    9    tmpjbhfrft8                        0x000055d18b8e93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c74ce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c749df561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6c749df286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6c749df13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6c749debb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6c747dee83 <unavailable> + 188035

    6    tmpuxrx8qb2                        0x000055aac3ebbaf8 <unavailable> + 6904

    7    tmpuxrx8qb2                        0x000055aac3ebb5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b6c74ed4460 __libc_start_main +
    245

    9    tmpuxrx8qb2                        0x000055aac3ebb2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ i in 0..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002aac3efc9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aac3ecc0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002aac3ecc0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002aac3ecc013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002aac3ecbfbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002aac3eabfe83 <unavailable> + 188035

    6    tmpwkqaxt7n                        0x000055e1d4d46b68 <unavailable> + 7016

    7    tmpwkqaxt7n                        0x000055e1d4d4662d <unavailable> + 5677

    8    libc.so.6                          0x00002aac3f1b5460 __libc_start_main +
    245

    9    tmpwkqaxt7n                        0x000055e1d4d46339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c730eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c72de5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0c72de5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0c72de513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0c72de4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0c72be4e83 <unavailable> + 188035

    6    tmpeljpz53h                        0x000055fb9148eae8 <unavailable> + 6888

    7    tmpeljpz53h                        0x000055fb9148e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b0c732da460 __libc_start_main +
    245

    9    tmpeljpz53h                        0x000055fb9148e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b13b2683c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13b237a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13b237a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13b237a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13b2379bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13b2179e83 <unavailable> + 188035

    6    tmpzajpslmz                        0x00005563a1d57ae8 <unavailable> + 6888

    7    tmpzajpslmz                        0x00005563a1d575bd <unavailable> + 5565

    8    libc.so.6                          0x00002b13b286f460 __libc_start_main +
    245

    9    tmpzajpslmz                        0x00005563a1d572c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for number\
    \ in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c74ce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c749df561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6c749df286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6c749df13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6c749debb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6c747dee83 <unavailable> + 188035

    6    tmpuxrx8qb2                        0x000055aac3ebbaf8 <unavailable> + 6904

    7    tmpuxrx8qb2                        0x000055aac3ebb5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b6c74ed4460 __libc_start_main +
    245

    9    tmpuxrx8qb2                        0x000055aac3ebb2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_value = numbers[0]\n    result.append(max_value)\n\
    \    for i in 1..<numbers.count {\n        max_value = max(max_value, numbers[i])\n\
    \        result.append(max_value)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d45be4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d458db561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9d458db286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9d458db13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9d458dabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b9d456dae83 <unavailable> + 188035

    6    tmpmgef3y8q                        0x00005653081e7b68 <unavailable> + 7016

    7    tmpmgef3y8q                        0x00005653081e762d <unavailable> + 5677

    8    libc.so.6                          0x00002b9d45dd0460 __libc_start_main +
    245

    9    tmpmgef3y8q                        0x00005653081e7339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max(max, numbers[i])\n      \
    \  result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: SyntaxError
  stderr: "/tmp/tmpiu5vq18a.swift:11:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, numbers[i])\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acdbe75fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acdbe456561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acdbe456286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acdbe45613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acdbe455bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acdbe255e83 <unavailable> + 188035

    6    tmpwcb86u7i                        0x0000563cc4395a5f <unavailable> + 6751

    7    tmpwcb86u7i                        0x0000563cc439552d <unavailable> + 5421

    8    libc.so.6                          0x00002acdbe94b460 __libc_start_main +
    245

    9    tmpwcb86u7i                        0x0000563cc4395239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpo6wurk1g.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for n in numbers\
    \ {\n        if n > max {\n            max = n\n        }\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b41a4a93c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41a478a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b41a478a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b41a478a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b41a4789bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b41a4589e83 <unavailable> + 188035

    6    tmpgwpxtpbk                        0x000055cca7d49b58 <unavailable> + 7000

    7    tmpgwpxtpbk                        0x000055cca7d4962d <unavailable> + 5677

    8    libc.so.6                          0x00002b41a4c7f460 __libc_start_main +
    245

    9    tmpgwpxtpbk                        0x000055cca7d49339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var current_max = numbers[0]\n   \
    \ result.append(current_max)\n    for i in 1..<numbers.count {\n        current_max\
    \ = max(current_max, numbers[i])\n        result.append(current_max)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002afc0973bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc09432561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afc09432286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afc0943213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afc09431bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002afc09231e83 <unavailable> + 188035

    6    tmpvzb86nho                        0x0000560e31b62b68 <unavailable> + 7016

    7    tmpvzb86nho                        0x0000560e31b6262d <unavailable> + 5677

    8    libc.so.6                          0x00002afc09927460 __libc_start_main +
    245

    9    tmpvzb86nho                        0x0000560e31b62339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c74ce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c749df561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6c749df286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6c749df13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6c749debb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6c747dee83 <unavailable> + 188035

    6    tmpuxrx8qb2                        0x000055aac3ebbaf8 <unavailable> + 6904

    7    tmpuxrx8qb2                        0x000055aac3ebb5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b6c74ed4460 __libc_start_main +
    245

    9    tmpuxrx8qb2                        0x000055aac3ebb2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_value = numbers[0]\n    for\
    \ i in 0..<numbers.count {\n        max_value = max(max_value, numbers[i])\n \
    \       result.append(max_value)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ace291cac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace28ec1561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ace28ec1286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ace28ec113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ace28ec0bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ace28cc0e83 <unavailable> + 188035

    6    tmp154nxh_4                        0x0000558e248d8b68 <unavailable> + 7016

    7    tmp154nxh_4                        0x0000558e248d862d <unavailable> + 5677

    8    libc.so.6                          0x00002ace293b6460 __libc_start_main +
    245

    9    tmp154nxh_4                        0x0000558e248d8339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5d11e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5d0edb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad5d0edb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad5d0edb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad5d0edabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad5d0cdae83 <unavailable> + 188035

    6    tmps6vm8iel                        0x000055957640ca52 <unavailable> + 6738

    7    tmps6vm8iel                        0x000055957640c52d <unavailable> + 5421

    8    libc.so.6                          0x00002ad5d13d0460 __libc_start_main +
    245

    9    tmps6vm8iel                        0x000055957640c239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number in numbers\
    \ {\n        max = max > number ? max : number\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c74ce8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c749df561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6c749df286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b6c749df13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6c749debb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6c747dee83 <unavailable> + 188035

    6    tmpuxrx8qb2                        0x000055aac3ebbaf8 <unavailable> + 6904

    7    tmpuxrx8qb2                        0x000055aac3ebb5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b6c74ed4460 __libc_start_main +
    245

    9    tmpuxrx8qb2                        0x000055aac3ebb2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5d11e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5d0edb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad5d0edb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad5d0edb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad5d0edabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad5d0cdae83 <unavailable> + 188035

    6    tmps6vm8iel                        0x000055957640ca52 <unavailable> + 6738

    7    tmps6vm8iel                        0x000055957640c52d <unavailable> + 5421

    8    libc.so.6                          0x00002ad5d13d0460 __libc_start_main +
    245

    9    tmps6vm8iel                        0x000055957640c239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5d11e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5d0edb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad5d0edb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad5d0edb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad5d0edabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad5d0cdae83 <unavailable> + 188035

    6    tmps6vm8iel                        0x000055957640ca52 <unavailable> + 6738

    7    tmps6vm8iel                        0x000055957640c52d <unavailable> + 5421

    8    libc.so.6                          0x00002ad5d13d0460 __libc_start_main +
    245

    9    tmps6vm8iel                        0x000055957640c239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for number\
    \ in numbers {\n        if number > max_so_far {\n            max_so_far = number\n\
    \        }\n        result.append(max_so_far)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c730eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c72de5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0c72de5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0c72de513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0c72de4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0c72be4e83 <unavailable> + 188035

    6    tmpeljpz53h                        0x000055fb9148eae8 <unavailable> + 6888

    7    tmpeljpz53h                        0x000055fb9148e5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b0c732da460 __libc_start_main +
    245

    9    tmpeljpz53h                        0x000055fb9148e2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b13b2683c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13b237a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13b237a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13b237a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13b2379bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13b2179e83 <unavailable> + 188035

    6    tmpzajpslmz                        0x00005563a1d57ae8 <unavailable> + 6888

    7    tmpzajpslmz                        0x00005563a1d575bd <unavailable> + 5565

    8    libc.so.6                          0x00002b13b286f460 __libc_start_main +
    245

    9    tmpzajpslmz                        0x00005563a1d572c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number in numbers\
    \ {\n        if number > max {\n            max = number\n        }\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for number\
    \ in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number in numbers\
    \ {\n        max = max > number ? max : number\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acdbe75fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acdbe456561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acdbe456286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acdbe45613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acdbe455bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acdbe255e83 <unavailable> + 188035

    6    tmpwcb86u7i                        0x0000563cc4395a5f <unavailable> + 6751

    7    tmpwcb86u7i                        0x0000563cc439552d <unavailable> + 5421

    8    libc.so.6                          0x00002acdbe94b460 __libc_start_main +
    245

    9    tmpwcb86u7i                        0x0000563cc4395239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b355317ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3552e71561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3552e71286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3552e7113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3552e70bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3552c70e83 <unavailable> + 188035

    6    tmp9gjaw00k                        0x000055b6c786daf8 <unavailable> + 6904

    7    tmp9gjaw00k                        0x000055b6c786d5bd <unavailable> + 5565

    8    libc.so.6                          0x00002b3553366460 __libc_start_main +
    245

    9    tmp9gjaw00k                        0x000055b6c786d2c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for number\
    \ in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for number\
    \ in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b60c1389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60c1080561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b60c1080286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b60c108013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b60c107fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b60c0e7fe83 <unavailable> + 188035

    6    tmpux4nvvi2                        0x0000564626608a5f <unavailable> + 6751

    7    tmpux4nvvi2                        0x000056462660852d <unavailable> + 5421

    8    libc.so.6                          0x00002b60c1575460 __libc_start_main +
    245

    9    tmpux4nvvi2                        0x0000564626608239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [max_so_far]\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0655cecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06559e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b06559e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b06559e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b06559e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b06557e2e83 <unavailable> + 188035

    6    tmp_dok88g0                        0x0000558563940b08 <unavailable> + 6920

    7    tmp_dok88g0                        0x00005585639405dd <unavailable> + 5597

    8    libc.so.6                          0x00002b0655ed8460 __libc_start_main +
    245

    9    tmp_dok88g0                        0x00005585639402e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for number\
    \ in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = 0\n    for number in numbers\
    \ {\n        max = max > number ? max : number\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5d11e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5d0edb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad5d0edb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad5d0edb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad5d0edabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad5d0cdae83 <unavailable> + 188035

    6    tmps6vm8iel                        0x000055957640ca52 <unavailable> + 6738

    7    tmps6vm8iel                        0x000055957640c52d <unavailable> + 5421

    8    libc.so.6                          0x00002ad5d13d0460 __libc_start_main +
    245

    9    tmps6vm8iel                        0x000055957640c239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b13b2683c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13b237a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13b237a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13b237a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13b2379bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13b2179e83 <unavailable> + 188035

    6    tmpzajpslmz                        0x00005563a1d57ae8 <unavailable> + 6888

    7    tmpzajpslmz                        0x00005563a1d575bd <unavailable> + 5565

    8    libc.so.6                          0x00002b13b286f460 __libc_start_main +
    245

    9    tmpzajpslmz                        0x00005563a1d572c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad5d11e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad5d0edb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad5d0edb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad5d0edb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad5d0edabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad5d0cdae83 <unavailable> + 188035

    6    tmps6vm8iel                        0x000055957640ca52 <unavailable> + 6738

    7    tmps6vm8iel                        0x000055957640c52d <unavailable> + 5421

    8    libc.so.6                          0x00002ad5d13d0460 __libc_start_main +
    245

    9    tmps6vm8iel                        0x000055957640c239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = 0\n    var result = [Int]()\n    for number\
    \ in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for number in numbers[1..<numbers.count] {\n        max_so_far = max(max_so_far,\
    \ number)\n        result.append(max_so_far)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b788298fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7882686561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7882686286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b788268613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7882685bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7882485e83 <unavailable> + 188035

    6    tmphcvkrx_h                        0x000056162c948c9b <unavailable> + 7323

    7    tmphcvkrx_h                        0x000056162c94875d <unavailable> + 5981

    8    libc.so.6                          0x00002b7882b7b460 __libc_start_main +
    245

    9    tmphcvkrx_h                        0x000056162c948469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b13b2683c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b13b237a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b13b237a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b13b237a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b13b2379bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b13b2179e83 <unavailable> + 188035

    6    tmpzajpslmz                        0x00005563a1d57ae8 <unavailable> + 6888

    7    tmpzajpslmz                        0x00005563a1d575bd <unavailable> + 5565

    8    libc.so.6                          0x00002b13b286f460 __libc_start_main +
    245

    9    tmpzajpslmz                        0x00005563a1d572c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dfe19bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dfde92561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b3dfde92286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b3dfde9213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b3dfde91bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b3dfdc91e83 <unavailable> + 188035

    6    tmphss230bc                        0x000055c25887bad8 <unavailable> + 6872

    7    tmphss230bc                        0x000055c25887b5ad <unavailable> + 5549

    8    libc.so.6                          0x00002b3dfe387460 __libc_start_main +
    245

    9    tmphss230bc                        0x000055c25887b2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = Int.min\n    for\
    \ number in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = 0\n    for number\
    \ in numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b41a4a93c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41a478a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b41a478a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b41a478a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b41a4789bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b41a4589e83 <unavailable> + 188035

    6    tmpgwpxtpbk                        0x000055cca7d49b58 <unavailable> + 7000

    7    tmpgwpxtpbk                        0x000055cca7d4962d <unavailable> + 5677

    8    libc.so.6                          0x00002b41a4c7f460 __libc_start_main +
    245

    9    tmpgwpxtpbk                        0x000055cca7d49339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ number in numbers {\n        if number > max_so_far {\n            max_so_far\
    \ = number\n        }\n        result.append(max_so_far)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b60c1389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b60c1080561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b60c1080286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b60c108013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b60c107fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b60c0e7fe83 <unavailable> + 188035

    6    tmpux4nvvi2                        0x0000564626608a5f <unavailable> + 6751

    7    tmpux4nvvi2                        0x000056462660852d <unavailable> + 5421

    8    libc.so.6                          0x00002b60c1575460 __libc_start_main +
    245

    9    tmpux4nvvi2                        0x0000564626608239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002acdbe75fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acdbe456561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002acdbe456286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002acdbe45613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002acdbe455bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002acdbe255e83 <unavailable> + 188035

    6    tmpwcb86u7i                        0x0000563cc4395a5f <unavailable> + 6751

    7    tmpwcb86u7i                        0x0000563cc439552d <unavailable> + 5421

    8    libc.so.6                          0x00002acdbe94b460 __libc_start_main +
    245

    9    tmpwcb86u7i                        0x0000563cc4395239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = Swift.max(max, number)\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7ac432c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ac129561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae7ac129286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae7ac12913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae7ac128bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ae7abf28e83 <unavailable> + 188035

    6    tmpbk7dqynv                        0x0000562791825b68 <unavailable> + 7016

    7    tmpbk7dqynv                        0x000056279182562d <unavailable> + 5677

    8    libc.so.6                          0x00002ae7ac61e460 __libc_start_main +
    245

    9    tmpbk7dqynv                        0x0000562791825339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [max_so_far]\n\
    \    for number in numbers[1..<numbers.count] {\n        max_so_far = max(max_so_far,\
    \ number)\n        result.append(max_so_far)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bb2b4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bb2843561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4bb2843286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4bb284313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4bb2842bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4bb2642e83 <unavailable> + 188035

    6    tmps2d9kzjq                        0x00005620c732dc38 <unavailable> + 7224

    7    tmps2d9kzjq                        0x00005620c732d70d <unavailable> + 5901

    8    libc.so.6                          0x00002b4bb2d38460 __libc_start_main +
    245

    9    tmps2d9kzjq                        0x00005620c732d419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [max_so_far]\n\
    \    for number in numbers[1..<numbers.count] {\n        max_so_far = max(max_so_far,\
    \ number)\n        result.append(max_so_far)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bb2b4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bb2843561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4bb2843286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4bb284313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4bb2842bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b4bb2642e83 <unavailable> + 188035

    6    tmps2d9kzjq                        0x00005620c732dc38 <unavailable> + 7224

    7    tmps2d9kzjq                        0x00005620c732d70d <unavailable> + 5901

    8    libc.so.6                          0x00002b4bb2d38460 __libc_start_main +
    245

    9    tmps2d9kzjq                        0x00005620c732d419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var max_so_far = numbers[0]\n    var result = [max_so_far]\n\
    \    for i in 1..<numbers.count {\n        max_so_far = max(max_so_far, numbers[i])\n\
    \        result.append(max_so_far)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0655cecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06559e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b06559e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b06559e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b06559e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b06557e2e83 <unavailable> + 188035

    6    tmp_dok88g0                        0x0000558563940b08 <unavailable> + 6920

    7    tmp_dok88g0                        0x00005585639405dd <unavailable> + 5597

    8    libc.so.6                          0x00002b0655ed8460 __libc_start_main +
    245

    9    tmp_dok88g0                        0x00005585639402e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad0da66bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad0da362561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad0da362286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad0da36213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad0da361bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ad0da161e83 <unavailable> + 188035

    6    tmpqni01zzz                        0x000055f9449bbae8 <unavailable> + 6888

    7    tmpqni01zzz                        0x000055f9449bb5ad <unavailable> + 5549

    8    libc.so.6                          0x00002ad0da857460 __libc_start_main +
    245

    9    tmpqni01zzz                        0x000055f9449bb2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    for\
    \ n in numbers {\n        max_so_far = max(max_so_far, n)\n        result.append(max_so_far)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b61724a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6172198561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6172198286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b617219813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6172197bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b6171f97e83 <unavailable> + 188035

    6    tmpblietbr2                        0x0000557a3efd1af8 <unavailable> + 6904

    7    tmpblietbr2                        0x0000557a3efd15bd <unavailable> + 5565

    8    libc.so.6                          0x00002b617268d460 __libc_start_main +
    245

    9    tmpblietbr2                        0x0000557a3efd12c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659824759
- exit_code: 0
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var maxes = [Int]()\n    var max = Int.min\n    for number in\
    \ numbers {\n        if number > max {\n            max = number\n        }\n\
    \        maxes.append(max)\n    }\n    return maxes\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers:\
    \ [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) ==\
    \ [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3]) == [3, 3, 3, 100,\
    \ 100])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824759
- exit_code: 1
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max = Int.min\n    for number\
    \ in numbers {\n        max = max(max, number)\n        result.append(max)\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rolling_max(numbers:\
    \ [] as [Int]) == [] as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1,\
    \ 2, 3, 4])\nassert(rolling_max(numbers: [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers:\
    \ [3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100])"
  status: SyntaxError
  stderr: "/tmp/tmpsfplo8c2.swift:10:15: error: cannot call value of non-function\
    \ type 'Int'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1659824759
- exit_code: -4
  program: "\n/// From a given list of integers, generate a list of rolling maximum\
    \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max([1,\
    \ 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
    \ -> [Int] {\n    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for number in numbers[1..<numbers.count] {\n        max_so_far = max(max_so_far,\
    \ number)\n        result.append(max_so_far)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == [] as [Int])\n\
    assert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
    \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
    \ == [3, 3, 3, 100, 100])"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b788298fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7882686561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7882686286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b788268613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7882685bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7882485e83 <unavailable> + 188035

    6    tmphcvkrx_h                        0x000056162c948c9b <unavailable> + 7323

    7    tmphcvkrx_h                        0x000056162c94875d <unavailable> + 5981

    8    libc.so.6                          0x00002b7882b7b460 __libc_start_main +
    245

    9    tmphcvkrx_h                        0x000056162c948469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1659824759
