language: swift
name: HumanEval_128_prod_signs
results:
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard arr.count > 0 else { return nil }\n    let signs = arr.map { $0\
    \ >= 0 ? 1 : -1 }\n    let mags = arr.map { abs($0) }\n    return mags.reduce(1,\
    \ combine: *) * signs.reduce(1, combine: *)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp6vhmc6vh.swift:14:23: error: extraneous argument label 'combine:'\
    \ in call\n    return mags.reduce(1, combine: *) * signs.reduce(1, combine: *)\n\
    \                      ^   ~~~~~~~~~\n                          \n/tmp/tmp6vhmc6vh.swift:14:53:\
    \ error: extraneous argument label 'combine:' in call\n    return mags.reduce(1,\
    \ combine: *) * signs.reduce(1, combine: *)\n                                \
    \                    ^   ~~~~~~~~~\n                                         \
    \               \n"
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let prod = signs.reduce(1, *)\n    let\
    \ sum = arr.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp9kh1nz2k/tmp9kh1nz2k.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b839af20c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b839ac17b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b839ac17988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b839ac167b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9kh1nz2k                        0x000055e8760f0559 <unavailable> + 5465

    5    libc.so.6                          0x00002b839b10c460 __libc_start_main +
    245

    6    tmp9kh1nz2k                        0x000055e8760f00e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, combine: *)\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpw8u8jk58.swift:16:28: error: extraneous argument label 'combine:'\
    \ in call\n    let prod = signs.reduce(1, combine: *)\n                      \
    \     ^   ~~~~~~~~~\n                               \n/tmp/tmpw8u8jk58.swift:17:32:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n                               ^   ~~~~~~~~~\n                \
    \                   \n/tmp/tmpw8u8jk58.swift:18:17: error: cannot convert return\
    \ expression of type 'Duration' to return type 'Int?'\n    return prod * sum\n\
    \           ~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ product = 1\n    for i in arr {\n        sum += abs(i)\n        product *= i\
    \ > 0 ? 1 : i < 0 ? -1 : 0\n    }\n    return sum * product\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ product = 1\n    for i in arr {\n        if i > 0 {\n            sum += i\n\
    \            product *= 1\n        } else if i < 0 {\n            sum += -i\n\
    \            product *= -1\n        } else {\n            product *= 0\n     \
    \   }\n    }\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i == 0\
    \ ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1baj3i4z/tmp1baj3i4z.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dd4945c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dd463cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dd463c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dd463b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1baj3i4z                        0x0000563b9b9c18a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b3dd4b31460 __libc_start_main +
    245

    6    tmp1baj3i4z                        0x0000563b9b9c12a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n  \
    \  return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard arr.count > 0 else { return nil }\n    let signs = arr.map { $0\
    \ < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n    return\
    \ signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n  \
    \  return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    return arr.reduce(1) { $0\
    \ * $1.signum() } * arr.reduce(0) { $0 + abs($1) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let signProduct = signs.reduce(1, *)\n\
    \    let magnitudes = arr.map { $0 == 0 ? 0 : abs($0) }\n    let magnitudeSum\
    \ = magnitudes.reduce(0, +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ sign = 1\n    for i in arr {\n        if i > 0 {\n            sum += i\n   \
    \     } else if i < 0 {\n            sum += -i\n            sign *= -1\n     \
    \   } else {\n            sign = 0\n        }\n    }\n    return sum * sign\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prodSigns = signs.reduce(1, *)\n    let sumMagnitudes = magnitudes.reduce(0,\
    \ +)\n    return prodSigns * sumMagnitudes\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for num in arr {\n        if num > 0 {\n            prod *= 1\n\
    \        } else if num < 0 {\n            prod *= -1\n        } else {\n     \
    \       prod *= 0\n        }\n        sum += abs(num)\n    }\n    return sum *\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        if i > 0 {\n            sum += i\n   \
    \         prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \  }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i == 0\
    \ ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1baj3i4z/tmp1baj3i4z.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dd4945c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dd463cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dd463c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dd463b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1baj3i4z                        0x0000563b9b9c18a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b3dd4b31460 __libc_start_main +
    245

    6    tmp1baj3i4z                        0x0000563b9b9c12a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i > 0 ?\
    \ 1 : i < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let sum = arr.reduce(0) { $0 + abs($1)\
    \ }\n    let product = signs.reduce(1) { $0 * $1 }\n    return sum * product\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i == 0 {\n            continue\n   \
    \     }\n        prod *= i > 0 ? 1 : -1\n        sum += abs(i)\n    }\n    return\
    \ prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpogbbmhkd/tmpogbbmhkd.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeed71f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeed6eeeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeed6eee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeed6eed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpogbbmhkd                        0x0000561970c00815 <unavailable> + 6165

    5    libc.so.6                          0x00002aeed73e3460 __libc_start_main +
    245

    6    tmpogbbmhkd                        0x0000561970c00219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for num in arr {\n        sum += abs(num)\n        prod *= num\
    \ < 0 ? -1 : num > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        if i > 0 {\n            sum += i\n   \
    \         prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \  }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for num in arr {\n        sum += abs(num)\n        prod *= num\
    \ == 0 ? 1 : num / abs(num)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpm1xh_qeh/tmpm1xh_qeh.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab7dea66c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab7de75db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab7de75d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab7de75c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm1xh_qeh                        0x000055ff18ebe8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002ab7dec52460 __libc_start_main +
    245

    6    tmpm1xh_qeh                        0x000055ff18ebe2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    return arr.map { abs($0)\
    \ }.reduce(1, combine: *) * arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1,\
    \ combine: *)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmphx5ilwqh.swift:14:38: error: extraneous argument label 'combine:'\
    \ in call\n    return arr.map { abs($0) }.reduce(1, combine: *) * arr.map { $0\
    \ < 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1, combine: *)\n                        \
    \             ^   ~~~~~~~~~\n                                         \n/tmp/tmphx5ilwqh.swift:14:103:\
    \ error: extraneous argument label 'combine:' in call\n    return arr.map { abs($0)\
    \ }.reduce(1, combine: *) * arr.map { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1,\
    \ combine: *)\n                                                              \
    \                                        ^   ~~~~~~~~~\n                     \
    \                                                                            \
    \         \n"
  stdout: ''
  timestamp: 1659824705
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let sum = magnitudes.reduce(0, combine: +)\n    let product = signs.reduce(1,\
    \ combine: *)\n    return sum * product\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptmzvb5f2.swift:16:32: error: extraneous argument label 'combine:'\
    \ in call\n    let sum = magnitudes.reduce(0, combine: +)\n                  \
    \             ^   ~~~~~~~~~\n                                   \n/tmp/tmptmzvb5f2.swift:17:31:\
    \ error: extraneous argument label 'combine:' in call\n    let product = signs.reduce(1,\
    \ combine: *)\n                              ^   ~~~~~~~~~\n                 \
    \                 \n/tmp/tmptmzvb5f2.swift:18:16: error: cannot convert return\
    \ expression of type 'Duration' to return type 'Int?'\n    return sum * product\n\
    \           ~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    let signs = arr.map { $0\
    \ == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n   \
    \ let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n    return\
    \ prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n  \
    \  return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    let signs = arr.map { $0\
    \ == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n   \
    \ return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let mags = arr.map { abs($0) }\n    return\
    \ signs.reduce(1, *) * mags.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for num in arr {\n        sum += abs(num)\n        prod *= num\
    \ < 0 ? -1 : num > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard arr.count > 0 else { return nil }\n    let signs = arr.map { $0\
    \ == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n   \
    \ let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n    return\
    \ prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for num in arr {\n        if num > 0 {\n            prod *= 1\n\
    \        } else if num < 0 {\n            prod *= -1\n        } else {\n     \
    \       prod *= 0\n        }\n        sum += abs(num)\n    }\n    return sum *\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, combine: *)\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7voxf4kz.swift:16:28: error: extraneous argument label 'combine:'\
    \ in call\n    let prod = signs.reduce(1, combine: *)\n                      \
    \     ^   ~~~~~~~~~\n                               \n/tmp/tmp7voxf4kz.swift:17:32:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n                               ^   ~~~~~~~~~\n                \
    \                   \n/tmp/tmp7voxf4kz.swift:18:17: error: cannot convert return\
    \ expression of type 'Duration' to return type 'Int?'\n    return prod * sum\n\
    \           ~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i < 0 {\n            prod *= -1\n  \
    \      } else if i > 0 {\n            prod *= 1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for num in arr {\n        if num > 0 {\n            prod *= 1\n\
    \        } else if num < 0 {\n            prod *= -1\n        } else {\n     \
    \       prod *= 0\n        }\n        sum += abs(num)\n    }\n    return sum *\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    let signs = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes\
    \ = arr.map { abs($0) }\n    let prod = signs.reduce(1, combine: *)\n    let sum\
    \ = magnitudes.reduce(0, combine: +)\n    return prod * sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpapfunb9a.swift:13:28: error: extraneous argument label 'combine:'\
    \ in call\n    let prod = signs.reduce(1, combine: *)\n                      \
    \     ^   ~~~~~~~~~\n                               \n/tmp/tmpapfunb9a.swift:14:32:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n                               ^   ~~~~~~~~~\n                \
    \                   \n/tmp/tmpapfunb9a.swift:15:17: error: cannot convert return\
    \ expression of type 'Duration' to return type 'Int?'\n    return prod * sum\n\
    \           ~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let product = signs.reduce(1, *)\n  \
    \  let magnitudes = arr.map { abs($0) }\n    let sum = magnitudes.reduce(0, +)\n\
    \    return product * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n  \
    \  return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard arr.count > 0 else {\n        return nil\n    }\n    let signs\
    \ = arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map {\
    \ abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for num in arr {\n        prod *= num.signum()\n        sum +=\
    \ num.magnitude\n    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqjsxtuej.swift:18:20: error: cannot convert value of type 'UInt'\
    \ to expected argument type 'Int'\n        sum += num.magnitude\n            \
    \       ^\n               Int(         )\n"
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let sum = arr.reduce(0) { $0 + abs($1)\
    \ }\n    let prod = signs.reduce(1) { $0 * $1 }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let sign_prod = signs.reduce(1, combine:\
    \ *)\n    let magnitudes = arr.map { abs($0) }\n    let magnitude_sum = magnitudes.reduce(0,\
    \ combine: +)\n    return sign_prod * magnitude_sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpmass5ozt.swift:15:33: error: extraneous argument label 'combine:'\
    \ in call\n    let sign_prod = signs.reduce(1, combine: *)\n                 \
    \               ^   ~~~~~~~~~\n                                    \n/tmp/tmpmass5ozt.swift:17:42:\
    \ error: extraneous argument label 'combine:' in call\n    let magnitude_sum =\
    \ magnitudes.reduce(0, combine: +)\n                                         ^\
    \   ~~~~~~~~~\n                                             \n/tmp/tmpmass5ozt.swift:18:22:\
    \ error: cannot convert return expression of type 'Duration' to return type 'Int?'\n\
    \    return sign_prod * magnitude_sum\n           ~~~~~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i == 0\
    \ ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1baj3i4z/tmp1baj3i4z.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dd4945c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dd463cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dd463c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dd463b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1baj3i4z                        0x0000563b9b9c18a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b3dd4b31460 __libc_start_main +
    245

    6    tmp1baj3i4z                        0x0000563b9b9c12a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    var prod = 1\n    var sum\
    \ = 0\n    for n in arr {\n        prod *= n == 0 ? 1 : n > 0 ? 1 : -1\n     \
    \   sum += abs(n)\n    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpidvod8py/tmpidvod8py.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b960e245c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b960df3cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b960df3c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b960df3b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpidvod8py                        0x00005595fc994815 <unavailable> + 6165

    5    libc.so.6                          0x00002b960e431460 __libc_start_main +
    245

    6    tmpidvod8py                        0x00005595fc994219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        if i > 0 {\n            sum += i\n   \
    \         prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \  }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let mags = arr.map { abs($0) }\n    let\
    \ prod = signs.reduce(1, combine: *)\n    let sum = mags.reduce(0, combine: +)\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpgx7h5xok.swift:16:28: error: extraneous argument label 'combine:'\
    \ in call\n    let prod = signs.reduce(1, combine: *)\n                      \
    \     ^   ~~~~~~~~~\n                               \n/tmp/tmpgx7h5xok.swift:17:26:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = mags.reduce(0,\
    \ combine: +)\n                         ^   ~~~~~~~~~\n                      \
    \       \n/tmp/tmpgx7h5xok.swift:18:17: error: cannot convert return expression\
    \ of type 'Duration' to return type 'Int?'\n    return prod * sum\n          \
    \ ~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for num in arr {\n        if num == 0 {\n            prod = 0\n\
    \        } else if num > 0 {\n            prod *= 1\n        } else {\n      \
    \      prod *= -1\n        }\n        sum += abs(num)\n    }\n    return sum *\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for num in arr {\n        if num > 0 {\n            sum += num\n\
    \            prod *= 1\n        } else if num < 0 {\n            sum += abs(num)\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let sum = arr.reduce(0) { $0 + abs($1)\
    \ }\n    let prod = signs.reduce(1) { $0 * $1 }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ product = 1\n    for i in arr {\n        sum += abs(i)\n        product *= i\
    \ < 0 ? -1 : i > 0 ? 1 : 0\n    }\n    return sum * product\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i == 0\
    \ ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1baj3i4z/tmp1baj3i4z.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dd4945c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dd463cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dd463c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dd463b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1baj3i4z                        0x0000563b9b9c18a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b3dd4b31460 __libc_start_main +
    245

    6    tmp1baj3i4z                        0x0000563b9b9c12a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n  \
    \  return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard arr.count > 0 else { return nil }\n    let signs = arr.map { $0\
    \ < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n    return\
    \ magnitudes.reduce(1, combine: *) * signs.reduce(1, combine: *)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdyw81oto.swift:14:29: error: extraneous argument label 'combine:'\
    \ in call\n    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine:\
    \ *)\n                            ^   ~~~~~~~~~\n                            \
    \    \n/tmp/tmpdyw81oto.swift:14:59: error: extraneous argument label 'combine:'\
    \ in call\n    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine:\
    \ *)\n                                                          ^   ~~~~~~~~~\n\
    \                                                              \n"
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for num in arr {\n        if num > 0 {\n            prod *= 1\n\
    \        } else if num < 0 {\n            prod *= -1\n        } else {\n     \
    \       prod *= 0\n        }\n        sum += abs(num)\n    }\n    return sum *\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        if i > 0 {\n            sum += i\n   \
    \         prod *= 1\n        } else if i < 0 {\n            sum += -i\n      \
    \      prod *= -1\n        } else {\n            prod *= 0\n        }\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let sign = arr.map {\
    \ $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let prod = sign.reduce(1, *)\n    let sum\
    \ = arr.reduce(0, +)\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpiubuixqz/tmpiubuixqz.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b498f685c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b498f37cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b498f37c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b498f37b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiubuixqz                        0x000055be4a705559 <unavailable> + 5465

    5    libc.so.6                          0x00002b498f871460 __libc_start_main +
    245

    6    tmpiubuixqz                        0x000055be4a7050e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i > 0 ?\
    \ 1 : i < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for num in arr {\n        prod *= num > 0 ? 1 : num < 0 ? -1 :\
    \ 0\n        sum += abs(num)\n    }\n    return prod * sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i == 0\
    \ ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1baj3i4z/tmp1baj3i4z.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dd4945c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dd463cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dd463c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dd463b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1baj3i4z                        0x0000563b9b9c18a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b3dd4b31460 __libc_start_main +
    245

    6    tmp1baj3i4z                        0x0000563b9b9c12a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    return arr.map { abs($0)\
    \ }.reduce(1, *) * arr.map { $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) }.reduce(1, *)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpuro961fi/tmpuro961fi.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1f2c52c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1f2949b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1f2949988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1f29487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuro961fi                        0x0000560d5de14639 <unavailable> + 5689

    5    libc.so.6                          0x00002ab1f2e3e460 __libc_start_main +
    245

    6    tmpuro961fi                        0x0000560d5de141c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine: *)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpzmviw_af.swift:16:29: error: extraneous argument label 'combine:'\
    \ in call\n    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine:\
    \ *)\n                            ^   ~~~~~~~~~\n                            \
    \    \n/tmp/tmpzmviw_af.swift:16:59: error: extraneous argument label 'combine:'\
    \ in call\n    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine:\
    \ *)\n                                                          ^   ~~~~~~~~~\n\
    \                                                              \n"
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    let signs = arr.map { $0\
    \ < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n    let\
    \ prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n    return\
    \ prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let signProduct = signs.reduce(1, *)\n\
    \    let magnitudes = arr.map { abs($0) }\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    let signs = arr.map { $0\
    \ == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n   \
    \ let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n    return\
    \ prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i == 0\
    \ ? 1 : i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp1baj3i4z/tmp1baj3i4z.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3dd4945c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3dd463cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3dd463c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3dd463b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1baj3i4z                        0x0000563b9b9c18a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b3dd4b31460 __libc_start_main +
    245

    6    tmp1baj3i4z                        0x0000563b9b9c12a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    var sum = 0\n    var prod\
    \ = 1\n    for num in arr {\n        sum += abs(num)\n        prod *= num < 0\
    \ ? -1 : num > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, combine: *)\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp66lb2iio.swift:16:28: error: extraneous argument label 'combine:'\
    \ in call\n    let prod = signs.reduce(1, combine: *)\n                      \
    \     ^   ~~~~~~~~~\n                               \n/tmp/tmp66lb2iio.swift:17:32:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n                               ^   ~~~~~~~~~\n                \
    \                   \n/tmp/tmp66lb2iio.swift:18:17: error: cannot convert return\
    \ expression of type 'Duration' to return type 'Int?'\n    return prod * sum\n\
    \           ~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { $0 == 0 ?\
    \ 0 : abs($0) }\n    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0,\
    \ +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ product = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n\
    \            product *= i / abs(i)\n        }\n    }\n    return sum * product\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmppqm0s6f3/tmppqm0s6f3.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af6158bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af6155b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af6155b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af6155b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppqm0s6f3                        0x000055eca21078a5 <unavailable> + 6309

    5    libc.so.6                          0x00002af615aa6460 __libc_start_main +
    245

    6    tmppqm0s6f3                        0x000055eca21072a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    return arr.map { $0\
    \ == 0 ? 0 : $0 > 0 ? 1 : -1 }.reduce(1, *) * arr.map { abs($0) }.reduce(0, +)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let prod = signs.reduce(1, *)\n    let\
    \ mags = arr.map { abs($0) }\n    let sum = mags.reduce(0, +)\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        if i > 0 {\n            sum += i\n   \
    \         prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \  }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        if i > 0 {\n            sum += i\n   \
    \         prod *= 1\n        } else if i < 0 {\n            sum += -i\n      \
    \      prod *= -1\n        } else {\n            prod *= 0\n        }\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard arr.count > 0 else {\n        return nil\n    }\n    var prod =\
    \ 1\n    var sum = 0\n    for i in arr {\n        if i > 0 {\n            prod\
    \ *= 1\n        } else if i < 0 {\n            prod *= -1\n        } else {\n\
    \            prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum\
    \ * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    let signs = arr.map { $0\
    \ < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n    return\
    \ magnitudes.reduce(1, combine: *) * signs.reduce(1, combine: *)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpvdqql_mn.swift:14:29: error: extraneous argument label 'combine:'\
    \ in call\n    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine:\
    \ *)\n                            ^   ~~~~~~~~~\n                            \
    \    \n/tmp/tmpvdqql_mn.swift:14:59: error: extraneous argument label 'combine:'\
    \ in call\n    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine:\
    \ *)\n                                                          ^   ~~~~~~~~~\n\
    \                                                              \n"
  stdout: ''
  timestamp: 1659824703
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    return signs.reduce(1, combine: *) * magnitudes.reduce(0, combine: +)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpozgwl5n_.swift:16:24: error: extraneous argument label 'combine:'\
    \ in call\n    return signs.reduce(1, combine: *) * magnitudes.reduce(0, combine:\
    \ +)\n                       ^   ~~~~~~~~~\n                           \n/tmp/tmpozgwl5n_.swift:16:59:\
    \ error: extraneous argument label 'combine:' in call\n    return signs.reduce(1,\
    \ combine: *) * magnitudes.reduce(0, combine: +)\n                           \
    \                               ^   ~~~~~~~~~\n                              \
    \                                \n"
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for num in arr {\n        if num > 0 {\n            prod *= 1\n\
    \        } else if num < 0 {\n            prod *= -1\n        } else {\n     \
    \       prod *= 0\n        }\n        sum += abs(num)\n    }\n    return sum *\
    \ prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    var result = 1\n    for i\
    \ in arr {\n        result *= i == 0 ? 0 : i > 0 ? 1 : -1\n    }\n    return arr.reduce(0,\
    \ { $0 + abs($1) }) * result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard arr.count > 0 else { return nil }\n    var prod = 1\n    var sum\
    \ = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n       \
    \ } else if i < 0 {\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        prod *= i.signum()\n        sum += i.magnitude\n\
    \    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmph230twp3.swift:18:18: error: cannot convert value of type 'UInt'\
    \ to expected argument type 'Int'\n        sum += i.magnitude\n              \
    \   ^\n               Int(       )\n"
  stdout: ''
  timestamp: 1659824703
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        if i == 0 {\n            continue\n  \
    \      }\n        sum += abs(i)\n        prod *= i > 0 ? 1 : -1\n    }\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmppnqj_ilo/tmppnqj_ilo.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3347a89c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3347780b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3347780988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b334777f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppnqj_ilo                        0x0000557a39d42815 <unavailable> + 6165

    5    libc.so.6                          0x00002b3347c75460 __libc_start_main +
    245

    6    tmppnqj_ilo                        0x0000557a39d42219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard arr.count > 0 else { return nil }\n    var sum = 0\n    var prod\
    \ = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i > 0 ? 1 :\
    \ i < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    let signs = arr.map { $0\
    \ < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n    return\
    \ signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let prod = signs.reduce(1, *)\n    let\
    \ sum = arr.reduce(0, +)\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpcjk1spvk/tmpcjk1spvk.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7dc60bec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7dc5db5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7dc5db5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7dc5db47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcjk1spvk                        0x00005568efca8559 <unavailable> + 5465

    5    libc.so.6                          0x00002b7dc62aa460 __libc_start_main +
    245

    6    tmpcjk1spvk                        0x00005568efca80e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n  \
    \  return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let sign = arr.map {\
    \ $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }.reduce(1, *)\n    let mag = arr.map { abs($0)\
    \ }.reduce(0, +)\n    return sign * mag\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard arr.count > 0 else { return nil }\n    let signs = arr.map { $0\
    \ < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let magnitudes = arr.map { abs($0) }\n    let\
    \ prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n    return\
    \ prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i > 0 ?\
    \ 1 : (i < 0 ? -1 : 0)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine: *)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpzmviw_af.swift:16:29: error: extraneous argument label 'combine:'\
    \ in call\n    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine:\
    \ *)\n                            ^   ~~~~~~~~~\n                            \
    \    \n/tmp/tmpzmviw_af.swift:16:59: error: extraneous argument label 'combine:'\
    \ in call\n    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine:\
    \ *)\n                                                          ^   ~~~~~~~~~\n\
    \                                                              \n"
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let signProduct = signs.reduce(1, *)\n\
    \    let magnitudes = arr.map { abs($0) }\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 < 0 ? -1 : ($0 > 0 ? 1 : 0) }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, combine: *)\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj_ut705y.swift:16:28: error: extraneous argument label 'combine:'\
    \ in call\n    let prod = signs.reduce(1, combine: *)\n                      \
    \     ^   ~~~~~~~~~\n                               \n/tmp/tmpj_ut705y.swift:17:32:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n                               ^   ~~~~~~~~~\n                \
    \                   \n/tmp/tmpj_ut705y.swift:18:17: error: cannot convert return\
    \ expression of type 'Duration' to return type 'Int?'\n    return prod * sum\n\
    \           ~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    return arr.map { $0 == 0\
    \ ? 0 : $0 > 0 ? 1 : -1 }.reduce(1, *) * arr.map { abs($0) }.reduce(0, +)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        if i > 0 {\n            sum += i\n   \
    \         prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \  }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i > 0 ?\
    \ 1 : i < 0 ? -1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard arr.count > 0 else { return nil }\n    let signs = arr.map { $0\
    \ == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n   \
    \ return signs.reduce(1, *) * magnitudes.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n \
    \       sum += abs(i)\n    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard arr.count > 0 else {\n        return nil\n    }\n    var prod =\
    \ 1\n    var sum = 0\n    for elem in arr {\n        if elem > 0 {\n         \
    \   prod *= 1\n        } else if elem < 0 {\n            prod *= -1\n        }\
    \ else {\n            prod *= 0\n        }\n        sum += abs(elem)\n    }\n\
    \    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    return nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp16rqmzf6/tmp16rqmzf6.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb93580c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb93277b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb93277988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb932767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp16rqmzf6                        0x00005576e92243d9 <unavailable> + 5081

    5    libc.so.6                          0x00002acb9376c460 __libc_start_main +
    245

    6    tmp16rqmzf6                        0x00005576e9223f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let sum = arr.reduce(0) { $0 + abs($1)\
    \ }\n    let prod = signs.reduce(1) { $0 * $1 }\n    return sum * prod\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for num in arr {\n        if num < 0 {\n            prod *= -1\n\
    \        } else if num > 0 {\n            sum += num\n        }\n    }\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp3kjx3_sn/tmp3kjx3_sn.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa8011dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa7fe14b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa7fe14988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa7fe137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3kjx3_sn                        0x0000557dc902c599 <unavailable> + 5529

    5    libc.so.6                          0x00002baa80309460 __libc_start_main +
    245

    6    tmp3kjx3_sn                        0x0000557dc902c129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659824703
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let signProd = signs.reduce(1, combine:\
    \ *)\n    let magnitudes = arr.map { abs($0) }\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n    return sum * signProd\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpyo31pdn_.swift:15:32: error: extraneous argument label 'combine:'\
    \ in call\n    let signProd = signs.reduce(1, combine: *)\n                  \
    \             ^   ~~~~~~~~~\n                                   \n/tmp/tmpyo31pdn_.swift:17:32:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n                               ^   ~~~~~~~~~\n                \
    \                   \n/tmp/tmpyo31pdn_.swift:18:16: error: cannot convert return\
    \ expression of type 'Duration' to return type 'Int?'\n    return sum * signProd\n\
    \           ~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for num in arr {\n        if num > 0 {\n            sum += num\n\
    \            prod *= 1\n        } else if num < 0 {\n            sum += -num\n\
    \            prod *= -1\n        } else {\n            prod *= 0\n        }\n\
    \    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let product = signs.reduce(1, combine: *)\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n    return product * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpo90h56t4.swift:16:31: error: extraneous argument label 'combine:'\
    \ in call\n    let product = signs.reduce(1, combine: *)\n                   \
    \           ^   ~~~~~~~~~\n                                  \n/tmp/tmpo90h56t4.swift:17:32:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n                               ^   ~~~~~~~~~\n                \
    \                   \n/tmp/tmpo90h56t4.swift:18:20: error: cannot convert return\
    \ expression of type 'Duration' to return type 'Int?'\n    return product * sum\n\
    \           ~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    let signs = arr.map { $0\
    \ == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n   \
    \ return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine: *)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpwuxuivom.swift:14:29: error: extraneous argument label 'combine:'\
    \ in call\n    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine:\
    \ *)\n                            ^   ~~~~~~~~~\n                            \
    \    \n/tmp/tmpwuxuivom.swift:14:59: error: extraneous argument label 'combine:'\
    \ in call\n    return magnitudes.reduce(1, combine: *) * signs.reduce(1, combine:\
    \ *)\n                                                          ^   ~~~~~~~~~\n\
    \                                                              \n"
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    let signs = arr.map { $0\
    \ < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let prod = signs.reduce(1, *)\n    let mags\
    \ = arr.map { abs($0) }\n    let sum = mags.reduce(0, +)\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    return arr.isEmpty ? nil : arr.map { abs($0) }.reduce(1, combine: *)\
    \ * arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }.reduce(1, combine: *)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmphza2jimg.swift:11:58: error: extraneous argument label 'combine:'\
    \ in call\n    return arr.isEmpty ? nil : arr.map { abs($0) }.reduce(1, combine:\
    \ *) * arr.map { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }.reduce(1, combine: *)\n     \
    \                                                    ^   ~~~~~~~~~\n         \
    \                                                    \n/tmp/tmphza2jimg.swift:11:124:\
    \ error: extraneous argument label 'combine:' in call\n    return arr.isEmpty\
    \ ? nil : arr.map { abs($0) }.reduce(1, combine: *) * arr.map { $0 == 0 ? 0 :\
    \ $0 > 0 ? 1 : -1 }.reduce(1, combine: *)\n                                  \
    \                                                                            \
    \             ^   ~~~~~~~~~\n                                                \
    \                                                                            \
    \   \n"
  stdout: ''
  timestamp: 1659824708
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let prod = signs.reduce(1, *)\n    let\
    \ sum = arr.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpz8ebnok0/tmpz8ebnok0.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4f3451c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4f3148b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac4f3148988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4f31477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz8ebnok0                        0x000055ec0b9e8559 <unavailable> + 5465

    5    libc.so.6                          0x00002ac4f363d460 __libc_start_main +
    245

    6    tmpz8ebnok0                        0x000055ec0b9e80e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1659824703
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for num in arr {\n        prod *= num.signum()\n        sum +=\
    \ num.magnitude\n    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqjsxtuej.swift:18:20: error: cannot convert value of type 'UInt'\
    \ to expected argument type 'Int'\n        sum += num.magnitude\n            \
    \       ^\n               Int(         )\n"
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n  \
    \  return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 > 0 ? 1 : ($0 < 0 ? -1 : 0) }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, combine: *)\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7voxf4kz.swift:16:28: error: extraneous argument label 'combine:'\
    \ in call\n    let prod = signs.reduce(1, combine: *)\n                      \
    \     ^   ~~~~~~~~~\n                               \n/tmp/tmp7voxf4kz.swift:17:32:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n                               ^   ~~~~~~~~~\n                \
    \                   \n/tmp/tmp7voxf4kz.swift:18:17: error: cannot convert return\
    \ expression of type 'Duration' to return type 'Int?'\n    return prod * sum\n\
    \           ~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i == 0 {\n            continue\n   \
    \     }\n        prod *= i > 0 ? 1 : -1\n        sum += abs(i)\n    }\n    return\
    \ prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpogbbmhkd/tmpogbbmhkd.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeed71f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeed6eeeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeed6eee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeed6eed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpogbbmhkd                        0x0000561970c00815 <unavailable> + 6165

    5    libc.so.6                          0x00002aeed73e3460 __libc_start_main +
    245

    6    tmpogbbmhkd                        0x0000561970c00219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let sign = arr.map {\
    \ $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let sum = arr.map { abs($0) }.reduce(0,\
    \ combine: +)\n    let prod = sign.reduce(1, combine: *)\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqq1pzux6.swift:15:41: error: extraneous argument label 'combine:'\
    \ in call\n    let sum = arr.map { abs($0) }.reduce(0, combine: +)\n         \
    \                               ^   ~~~~~~~~~\n                              \
    \              \n/tmp/tmpqq1pzux6.swift:16:27: error: extraneous argument label\
    \ 'combine:' in call\n    let prod = sign.reduce(1, combine: *)\n            \
    \              ^   ~~~~~~~~~\n                              \n/tmp/tmpqq1pzux6.swift:17:16:\
    \ error: cannot convert return expression of type 'Duration' to return type 'Int?'\n\
    \    return sum * prod\n           ~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659824703
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    let signs = arr.map { $0\
    \ < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let prod = signs.reduce(1, *)\n    let sum\
    \ = arr.reduce(0, +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp8u5rn31d/tmp8u5rn31d.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b23a0502c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b23a01f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b23a01f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b23a01f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8u5rn31d                        0x000055da4ff97559 <unavailable> + 5465

    5    libc.so.6                          0x00002b23a06ee460 __libc_start_main +
    245

    6    tmp8u5rn31d                        0x000055da4ff970e9 <unavailable> + 4329

    '
  stdout: ''
  timestamp: 1659824704
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, *)\n    let sum = magnitudes.reduce(0, +)\n  \
    \  return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let mags = arr.map { abs($0) }\n    let\
    \ prod = signs.reduce(1, *)\n    let sum = mags.reduce(0, +)\n    return prod\
    \ * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1, 2,\
    \ 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824704
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        prod *= i < 0 ? -1 : i == 0 ? 0 : 1\n \
    \       sum += abs(i)\n    }\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        if i > 0 {\n            sum += i\n   \
    \         prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \  }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let signProduct = signs.reduce(1, *)\n\
    \    let magnitudes = arr.map { abs($0) }\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for num in arr {\n        if num == 0 {\n            continue\n\
    \        }\n        prod *= num > 0 ? 1 : -1\n        sum += abs(num)\n    }\n\
    \    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmp39c51sel/tmp39c51sel.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d4fcf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d4f9eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d4f9ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d4f9e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp39c51sel                        0x0000560452a49815 <unavailable> + 6165

    5    libc.so.6                          0x00002b3d4fedf460 __libc_start_main +
    245

    6    tmp39c51sel                        0x0000560452a49219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824703
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i == 0 {\n            continue\n   \
    \     }\n        prod *= i < 0 ? -1 : 1\n        sum += abs(i)\n    }\n    return\
    \ prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpja7mv45m/tmpja7mv45m.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71d3d96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71d3a8db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71d3a8d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71d3a8c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpja7mv45m                        0x000055d94d874815 <unavailable> + 6165

    5    libc.so.6                          0x00002b71d3f82460 __libc_start_main +
    245

    6    tmpja7mv45m                        0x000055d94d874219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824704
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 < 0 ? -1 : $0 > 0 ? 1 : 0 }\n    let prod = signs.reduce(1, combine: *)\n\
    \    let sum = arr.reduce(0, combine: +)\n    return prod * sum\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpaa0eut61.swift:15:28: error: extraneous argument label 'combine:'\
    \ in call\n    let prod = signs.reduce(1, combine: *)\n                      \
    \     ^   ~~~~~~~~~\n                               \n/tmp/tmpaa0eut61.swift:16:25:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = arr.reduce(0,\
    \ combine: +)\n                        ^   ~~~~~~~~~\n                       \
    \     \n/tmp/tmpaa0eut61.swift:17:17: error: cannot convert return expression\
    \ of type 'Duration' to return type 'Int?'\n    return prod * sum\n          \
    \ ~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824703
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    var sum = 0\n    var prod = 1\n    for i in arr {\n        if i > 0 {\n\
    \            sum += i\n            prod *= 1\n        } else if i < 0 {\n    \
    \        sum += -i\n            prod *= -1\n        } else {\n            prod\
    \ *= 0\n        }\n    }\n    return prod == 0 ? nil : sum * prod\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpmpc2uf20/tmpmpc2uf20.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b46440bfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4643db6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4643db6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4643db57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmpc2uf20                        0x000056288d35d6d5 <unavailable> + 5845

    5    libc.so.6                          0x00002b46442ab460 __libc_start_main +
    245

    6    tmpmpc2uf20                        0x000056288d35d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824704
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        if i > 0 {\n            sum += i\n   \
    \         prod *= 1\n        } else if i < 0 {\n            sum += abs(i)\n  \
    \          prod *= -1\n        } else {\n            prod *= 0\n        }\n  \
    \  }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        if i == 0 {\n            continue\n  \
    \      }\n        sum += abs(i)\n        prod *= i < 0 ? -1 : 1\n    }\n    return\
    \ sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpytkqxsjx/tmpytkqxsjx.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b661443ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6614135b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6614135988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66141347b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpytkqxsjx                        0x00005642f9d9e815 <unavailable> + 6165

    5    libc.so.6                          0x00002b661462a460 __libc_start_main +
    245

    6    tmpytkqxsjx                        0x00005642f9d9e219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1659824704
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 < 0 ? -1 : ($0 > 0 ? 1 : 0) }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, combine: *)\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpj_ut705y.swift:16:28: error: extraneous argument label 'combine:'\
    \ in call\n    let prod = signs.reduce(1, combine: *)\n                      \
    \     ^   ~~~~~~~~~\n                               \n/tmp/tmpj_ut705y.swift:17:32:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n                               ^   ~~~~~~~~~\n                \
    \                   \n/tmp/tmpj_ut705y.swift:18:17: error: cannot convert return\
    \ expression of type 'Duration' to return type 'Int?'\n    return prod * sum\n\
    \           ~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    var sum = 0\n    var prod\
    \ = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i == 0 ? 1 :\
    \ i / abs(i)\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpuohzp786/tmpuohzp786.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b983f5c3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b983f2bab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b983f2ba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b983f2b97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuohzp786                        0x000055f9f8f348a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b983f7af460 __libc_start_main +
    245

    6    tmpuohzp786                        0x000055f9f8f342a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824704
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard !arr.isEmpty else { return nil }\n    return arr.reduce(1) { $0\
    \ * $1.signum() } * arr.reduce(0) { $0 + abs($1) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    guard arr.count > 0 else { return nil }\n    var result = 1\n    for\
    \ i in arr {\n        result *= i == 0 ? 0 : i > 0 ? 1 : -1\n    }\n    return\
    \ result * arr.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr:\
    \ [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpb35nj7up/tmpb35nj7up.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af27fbe9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af27f8e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af27f8e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af27f8df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb35nj7up                        0x000055a397d0a619 <unavailable> + 5657

    5    libc.so.6                          0x00002af27fdd5460 __libc_start_main +
    245

    6    tmpb35nj7up                        0x000055a397d0a1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659824704
- exit_code: 1
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 == 0 ? 0 : $0 > 0 ? 1 : -1 }\n    let magnitudes = arr.map { abs($0) }\n\
    \    let prod = signs.reduce(1, combine: *)\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n    return prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) ==\
    \ 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp66lb2iio.swift:16:28: error: extraneous argument label 'combine:'\
    \ in call\n    let prod = signs.reduce(1, combine: *)\n                      \
    \     ^   ~~~~~~~~~\n                               \n/tmp/tmp66lb2iio.swift:17:32:\
    \ error: extraneous argument label 'combine:' in call\n    let sum = magnitudes.reduce(0,\
    \ combine: +)\n                               ^   ~~~~~~~~~\n                \
    \                   \n/tmp/tmp66lb2iio.swift:18:17: error: cannot convert return\
    \ expression of type 'Duration' to return type 'Int?'\n    return prod * sum\n\
    \           ~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        prod *= i < 0 ?\
    \ -1 : i > 0 ? 1 : 0\n    }\n    return sum * prod\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    let signs = arr.map\
    \ { $0 > 0 ? 1 : $0 < 0 ? -1 : 0 }\n    let signProduct = signs.reduce(1, *)\n\
    \    let magnitudes = arr.map { abs($0) }\n    let magnitudeSum = magnitudes.reduce(0,\
    \ +)\n    return signProduct * magnitudeSum\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0,\
    \ 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824703
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var sum = 0\n    var\
    \ prod = 1\n    for i in arr {\n        sum += abs(i)\n        if i != 0 {\n \
    \           prod *= i / abs(i)\n        }\n    }\n    return sum * prod\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmpsto3a_0c/tmpsto3a_0c.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1375525c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b137521cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b137521c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b137521b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsto3a_0c                        0x000056084a1ec8a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b1375711460 __libc_start_main +
    245

    6    tmpsto3a_0c                        0x000056084a1ec2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824702
- exit_code: 0
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i > 0 {\n            prod *= 1\n   \
    \     } else if i < 0 {\n            prod *= -1\n        } else {\n          \
    \  prod *= 0\n        }\n        sum += abs(i)\n    }\n    return sum * prod\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(prod_signs(arr: [1, 2, 2, -4]) == -9)\nassert(prod_signs(arr:\
    \ [0, 1]) == 0)\nassert(prod_signs(arr: [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr:\
    \ [] as [Int]) == nil)\nassert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\n\
    assert(prod_signs(arr: [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1,\
    \ 1]) == -4)\nassert(prod_signs(arr: [-1, 1, 1, 0]) == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824702
- exit_code: -4
  program: "\n/// You are given an array arr of integers and you need to return\n\
    /// sum of magnitudes of integers multiplied by product of all signs\n/// of each\
    \ number in the array, represented by 1, -1 or 0.\n/// Note: return None for empty\
    \ arr.\n/// Example:\n/// >>> prod_signs([1, 2, 2, -4]) == -9\n/// >>> prod_signs([0,\
    \ 1]) == 0\n/// >>> prod_signs([]) == None\nfunc prod_signs(arr: [Int]) -> Int?\
    \ {\n    if arr.isEmpty {\n        return nil\n    }\n    var prod = 1\n    var\
    \ sum = 0\n    for i in arr {\n        if i == 0 {\n            continue\n   \
    \     }\n        prod *= i / abs(i)\n        sum += abs(i)\n    }\n    return\
    \ prod * sum\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(prod_signs(arr: [1,\
    \ 2, 2, -4]) == -9)\nassert(prod_signs(arr: [0, 1]) == 0)\nassert(prod_signs(arr:\
    \ [1, 1, 1, 2, 3, -1, 1]) == -10)\nassert(prod_signs(arr: [] as [Int]) == nil)\n\
    assert(prod_signs(arr: [2, 4, 1, 2, -1, -1, 9]) == 20)\nassert(prod_signs(arr:\
    \ [-1, 1, -1, 1]) == 4)\nassert(prod_signs(arr: [-1, 1, 1, 1]) == -4)\nassert(prod_signs(arr:\
    \ [-1, 1, 1, 0]) == 0)"
  status: Exception
  stderr: 'tmparg5of7j/tmparg5of7j.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8234409c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8234100b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8234100988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b82340ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmparg5of7j                        0x0000559b174078a5 <unavailable> + 6309

    5    libc.so.6                          0x00002b82345f5460 __libc_start_main +
    245

    6    tmparg5of7j                        0x0000559b174072a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824704
