language: swift
name: HumanEval_115_max_fill
results:
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var sum = 0\n        for cell in row {\n            sum += cell\n   \
    \         if sum == capacity {\n                result += 1\n                sum\
    \ = 0\n            }\n        }\n        if sum > 0 {\n            result += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                grid[i][j]\
    \ = 0\n                var k = i + 1\n                while k < grid.count &&\
    \ capacity > 0 {\n                    if grid[k][j] == 1 {\n                 \
    \       grid[k][j] = 0\n                        capacity -= 1\n              \
    \      }\n                    k += 1\n                }\n            }\n     \
    \   }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsa_fceuc.swift:41:34: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                        capacity -=\
    \ 1\n                        ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                var k =\
    \ i\n                while k < grid.count && grid[k][j] == 1 {\n             \
    \       grid[k][j] = 0\n                    k += 1\n                }\n      \
    \      }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpb9iq57j4/tmpb9iq57j4.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeeca689c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeeca380b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeeca380988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeeca37f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb9iq57j4                        0x000056251839e706 <unavailable> + 5894

    5    libc.so.6                          0x00002aeeca875460 __libc_start_main +
    245

    6    tmpb9iq57j4                        0x000056251839e299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for i in 0..<grid.count\
    \ {\n        var sum = 0\n        for j in 0..<grid[i].count {\n            sum\
    \ += grid[i][j]\n        }\n        result += sum / capacity\n        if sum %\
    \ capacity != 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn7f9m03b/tmpn7f9m03b.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25f3cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25f39edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25f39ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25f39ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7f9m03b                        0x000055932be713d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b25f3ee2460 __libc_start_main +
    245

    6    tmpn7f9m03b                        0x000055932be70f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var min_row = -1\n        var min_value = Int.max\n\
    \        for i in 0..<grid.count {\n            var sum = 0\n            for j\
    \ in 0..<grid[i].count {\n                sum += grid[i][j]\n            }\n \
    \           if sum < min_value {\n                min_value = sum\n          \
    \      min_row = i\n            }\n        }\n        if min_value == 0 {\n  \
    \          break\n        }\n        for j in 0..<grid[min_row].count {\n    \
    \        if grid[min_row][j] == 1 {\n                grid[min_row][j] = 0\n  \
    \              count += 1\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpeklx093x/tmpeklx093x.swift:71: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aac57735c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aac5742cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aac5742c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aac5742b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeklx093x                        0x0000562527d55706 <unavailable> + 5894

    5    libc.so.6                          0x00002aac57921460 __libc_start_main +
    245

    6    tmpeklx093x                        0x0000562527d55299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2f4geop2.swift:36:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                result += capacity\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpywi8cll0/tmpywi8cll0.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b958b4e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b958b1dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b958b1dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b958b1db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpywi8cll0                        0x0000558067b41827 <unavailable> + 6183

    5    libc.so.6                          0x00002b958b6d1460 __libc_start_main +
    245

    6    tmpywi8cll0                        0x0000558067b411e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var row_max = [Int](repeating:\
    \ 0, count: grid.count)\n    for row in 0..<grid.count {\n        for col in 0..<grid[row].count\
    \ {\n            if grid[row][col] == 1 {\n                row_max[row] = col\n\
    \            }\n        }\n    }\n    for col in 0..<grid[0].count {\n       \
    \ var row = 0\n        var col_max = 0\n        while row < grid.count {\n   \
    \         if row_max[row] >= col {\n                col_max = row\n          \
    \  }\n            row += 1\n        }\n        for row in 0...col_max {\n    \
    \        if row_max[row] >= col {\n                result += 1\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpwgpbv6c7/tmpwgpbv6c7.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7352d8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7352a82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7352a82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7352a817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwgpbv6c7                        0x0000564e93368806 <unavailable> + 6150

    5    libc.so.6                          0x00002b7352f77460 __libc_start_main +
    245

    6    tmpwgpbv6c7                        0x0000564e93368399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    var row = 0\n    while fill < max_fill {\n        var col = 0\n   \
    \     while col < grid[row].count {\n            if grid[row][col] == 1 {\n  \
    \              fill += 1\n                grid[row][col] = 0\n            }\n\
    \            col += 1\n        }\n        row += 1\n        result += 1\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgkt7awly.swift:46:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n"
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var sum = 0\n        for i in 0..<row.count {\n            if row[i]\
    \ == 1 {\n                sum += 1\n            } else {\n                if sum\
    \ > 0 {\n                    result += 1\n                    sum = 0\n      \
    \          }\n            }\n        }\n        if sum > 0 {\n            result\
    \ += 1\n        }\n    }\n    return result * capacity\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp1o3i1dh7/tmp1o3i1dh7.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06b0f53c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06b0c4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06b0c4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06b0c497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1o3i1dh7                        0x000055ebf092b776 <unavailable> + 6006

    5    libc.so.6                          0x00002b06b113f460 __libc_start_main +
    245

    6    tmp1o3i1dh7                        0x000055ebf092b309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max_fill = 0\n    for row in grid\
    \ {\n        var fill = 0\n        for cell in row {\n            if cell == 1\
    \ {\n                fill += 1\n            } else {\n                if fill\
    \ > max_fill {\n                    max_fill = fill\n                }\n     \
    \           fill = 0\n            }\n        }\n        if fill > max_fill {\n\
    \            max_fill = fill\n        }\n    }\n    return max_fill\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpiu7b5f81/tmpiu7b5f81.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b636a74fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b636a446b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b636a446988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b636a4457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiu7b5f81                        0x000055a1ac563546 <unavailable> + 5446

    5    libc.so.6                          0x00002b636a93b460 __libc_start_main +
    245

    6    tmpiu7b5f81                        0x000055a1ac5630d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                grid[i][j]\
    \ = 0\n                var k = i\n                while k < grid.count && grid[k][j]\
    \ == 0 {\n                    grid[k][j] = 1\n                    k += 1\n   \
    \             }\n                k = i - 1\n                while k >= 0 && grid[k][j]\
    \ == 0 {\n                    grid[k][j] = 1\n                    k -= 1\n   \
    \             }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpmxp21raa/tmpmxp21raa.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac0cfc7fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac0cf976b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac0cf976988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac0cf9757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmxp21raa                        0x000055ae056cf706 <unavailable> + 5894

    5    libc.so.6                          0x00002ac0cfe6b460 __libc_start_main +
    245

    6    tmpmxp21raa                        0x000055ae056cf299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max_fill = 0\n    for row in grid\
    \ {\n        var fill = 0\n        for cell in row {\n            if cell == 1\
    \ {\n                fill += 1\n            } else {\n                if fill\
    \ > 0 {\n                    max_fill += 1\n                    fill = 0\n   \
    \             }\n            }\n        }\n        if fill > 0 {\n           \
    \ max_fill += 1\n        }\n    }\n    return max_fill * capacity\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpmw9_mhcg/tmpmw9_mhcg.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20355afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20352a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20352a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20352a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmw9_mhcg                        0x0000563f5f6f6546 <unavailable> + 5446

    5    libc.so.6                          0x00002b203579b460 __libc_start_main +
    245

    6    tmpmw9_mhcg                        0x0000563f5f6f60d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var water = 0\n        for cell in row {\n            water += cell\n\
    \            if water == capacity {\n                result += 1\n           \
    \     water = 0\n            }\n        }\n        if water > 0 {\n          \
    \  result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr9zxq02w/tmpr9zxq02w.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3856e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3853dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3853db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3853da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr9zxq02w                        0x0000563671f8a546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba3858d0460 __libc_start_main +
    245

    6    tmpr9zxq02w                        0x0000563671f8a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var water = 0\n        for well in row {\n            water += well\n\
    \            if water >= capacity {\n                result += 1\n           \
    \     water = 0\n            }\n        }\n        if water > 0 {\n          \
    \  result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max_row = 0\n \
    \   for row in grid {\n        max_row = max(max_row, row.reduce(0, +))\n    }\n\
    \    for _ in 0..<max_row {\n        for row in grid {\n            for i in 0..<row.count\
    \ {\n                if row[i] > 0 {\n                    row[i] -= 1\n      \
    \              count += 1\n                }\n            }\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpdhyddrav.swift:39:28: error: left side of mutating operator isn't\
    \ mutable: 'row' is a 'let' constant\n                    row[i] -= 1\n      \
    \              ~~~    ^\n"
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var fill = 0\n        for col in row {\n            if col == 1 {\n \
    \               fill += 1\n            } else {\n                if fill > 0 {\n\
    \                    result += 1\n                    fill = 0\n             \
    \   }\n            }\n        }\n        if fill > 0 {\n            result +=\
    \ 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpc6exw_zc/tmpc6exw_zc.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b41293c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b41290bbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b41290bb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b41290ba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc6exw_zc                        0x0000556ac2071546 <unavailable> + 5446

    5    libc.so.6                          0x00002b41295b0460 __libc_start_main +
    245

    6    tmpc6exw_zc                        0x0000556ac20710d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var sum = 0\n        for i in 0..<row.count {\n            sum += row[i]\n\
    \            if sum == capacity {\n                result += 1\n             \
    \   sum = 0\n            } else if sum > capacity {\n                result +=\
    \ 1\n                sum = row[i]\n            }\n        }\n        if sum >\
    \ 0 {\n            result += 1\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                var k =\
    \ i\n                while k < grid.count && grid[k][j] == 1 {\n             \
    \       grid[k][j] = 0\n                    k += 1\n                }\n      \
    \      }\n        }\n    }\n    return count / capacity + (count % capacity ==\
    \ 0 ? 0 : 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmps1y0my9z/tmps1y0my9z.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb36ea5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb36b9cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb36b9c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb36b9b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps1y0my9z                        0x0000555c4c526706 <unavailable> + 5894

    5    libc.so.6                          0x00002aeb37091460 __libc_start_main +
    245

    6    tmps1y0my9z                        0x0000555c4c526299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_row = 0\n\
    \    for row in grid {\n        max_row = max(max_row, row.reduce(0, +))\n   \
    \ }\n    if max_row == 0 {\n        return 0\n    }\n    var current_fill = 0\n\
    \    var current_row = 0\n    while current_fill < max_row {\n        current_fill\
    \ = 0\n        for i in 0..<grid.count {\n            if grid[i][current_row]\
    \ == 1 {\n                current_fill += 1\n            }\n        }\n      \
    \  current_row += 1\n        result += 1\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f47c22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f47919561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b0f47919286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b0f4791913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b0f47918bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b0f47718e83 <unavailable> + 188035

    6    tmpipit_9iy                        0x000055dbd8c402fa <unavailable> + 8954

    7    tmpipit_9iy                        0x000055dbd8c3f7f8 <unavailable> + 6136

    8    libc.so.6                          0x00002b0f47e0e460 __libc_start_main +
    245

    9    tmpipit_9iy                        0x000055dbd8c3f409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var current_capacity = capacity\n        for well in row {\n        \
    \    if well == 1 {\n                if current_capacity == 0 {\n            \
    \        result += 1\n                    current_capacity = capacity\n      \
    \          }\n                current_capacity -= 1\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp0obwladz/tmp0obwladz.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac55f868c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac55f55fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac55f55f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac55f55e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0obwladz                        0x000055c1e8834546 <unavailable> + 5446

    5    libc.so.6                          0x00002ac55fa54460 __libc_start_main +
    245

    6    tmp0obwladz                        0x000055c1e88340d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                count += 1\n            }\n        }\n        max_fill = max(max_fill,\
    \ count)\n        count = 0\n    }\n    return max_fill / capacity + (max_fill\
    \ % capacity == 0 ? 0 : 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmput9c_l1o/tmput9c_l1o.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002accae716c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002accae40db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002accae40d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002accae40c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmput9c_l1o                        0x00005566fcc5d676 <unavailable> + 5750

    5    libc.so.6                          0x00002accae902460 __libc_start_main +
    245

    6    tmput9c_l1o                        0x00005566fcc5d209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var water = 0\n        for well in row {\n            water += well\n\
    \            if water == capacity {\n                result += 1\n           \
    \     water = 0\n            }\n        }\n        if water > 0 {\n          \
    \  result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        if fill\
    \ + capacity > max_fill {\n            fill = max_fill\n        } else {\n   \
    \         fill += capacity\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwnxiky9u/tmpwnxiky9u.swift:72: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c52271c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c51f68b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c51f68988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c51f677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwnxiky9u                        0x0000560410df7546 <unavailable> + 5446

    5    libc.so.6                          0x00002b5c5245d460 __libc_start_main +
    245

    6    tmpwnxiky9u                        0x0000560410df70d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var current_fill\
    \ = 0\n    while current_fill < max_fill {\n        result += 1\n        current_fill\
    \ += capacity\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp3ff9brzi/tmp3ff9brzi.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0db6b60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0db6857b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0db6857988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0db68567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3ff9brzi                        0x000055cab3fcfb44 <unavailable> + 6980

    5    libc.so.6                          0x00002b0db6d4c460 __libc_start_main +
    245

    6    tmp3ff9brzi                        0x000055cab3fcf0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                let row\
    \ = min(i + capacity, grid.count - 1)\n                let col = min(j + capacity,\
    \ grid[i].count - 1)\n                for k in i...row {\n                   \
    \ for l in j...col {\n                        grid[k][l] = 0\n               \
    \     }\n                }\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpuzcvg9pi/tmpuzcvg9pi.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9d12d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9d0fccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9d0fcc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9d0fcb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuzcvg9pi                        0x0000561a9e6c3886 <unavailable> + 6278

    5    libc.so.6                          0x00002ae9d14c1460 __libc_start_main +
    245

    6    tmpuzcvg9pi                        0x0000561a9e6c3419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for cell in row {\n    \
    \        if cell == 1 {\n                max_fill += 1\n            } else {\n\
    \                max_fill = 0\n            }\n            if max_fill == capacity\
    \ {\n                result += 1\n                max_fill = 0\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp2f6ihrsh/tmp2f6ihrsh.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef2505cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef24d53b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef24d53988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef24d527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2f6ihrsh                        0x000056033f81a717 <unavailable> + 5911

    5    libc.so.6                          0x00002aef25248460 __libc_start_main +
    245

    6    tmp2f6ihrsh                        0x000056033f81a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                result += 1\n            }\n        }\n    }\n    return result\
    \ / capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpd4u38juh/tmpd4u38juh.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adfb4b9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adfb4894b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adfb4894988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adfb48937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd4u38juh                        0x000055c41c8cd827 <unavailable> + 6183

    5    libc.so.6                          0x00002adfb4d89460 __libc_start_main +
    245

    6    tmpd4u38juh                        0x000055c41c8cd1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_height = 0\n\
    \    for row in grid {\n        max_height = max(max_height, row.max()!)\n   \
    \ }\n    for height in 1...max_height {\n        var fill_count = 0\n        for\
    \ row in grid {\n            for cell in row {\n                if cell >= height\
    \ {\n                    fill_count += 1\n                }\n            }\n \
    \       }\n        result += fill_count / capacity\n        if fill_count % capacity\
    \ != 0 {\n            result += 1\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b8530fd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8530cce561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8530cce286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8530cce13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8530ccdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpa5aff1gm                        0x00005583256301a2 <unavailable> + 8610

    6    tmpa5aff1gm                        0x000055832562fa5b <unavailable> + 6747

    7    libc.so.6                          0x00002b85311c3460 __libc_start_main +
    245

    8    tmpa5aff1gm                        0x000055832562f359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    while fill < max_fill {\n        var current_fill = 0\n        for\
    \ row in grid {\n            for col in row {\n                if col == 1 {\n\
    \                    current_fill += 1\n                    if current_fill ==\
    \ capacity {\n                        result += 1\n                        current_fill\
    \ = 0\n                    }\n                }\n            }\n        }\n  \
    \      fill += capacity\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpt4ta5w7i/tmpt4ta5w7i.swift:71: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe97878c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe9756fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe9756f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe9756e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt4ta5w7i                        0x000055c7bf64f546 <unavailable> + 5446

    5    libc.so.6                          0x00002afe97a64460 __libc_start_main +
    245

    6    tmpt4ta5w7i                        0x000055c7bf64f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                count += 1\n            }\n        }\n        max_fill = max(max_fill,\
    \ count)\n        count = 0\n    }\n    return max_fill / capacity + (max_fill\
    \ % capacity == 0 ? 0 : 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmput9c_l1o/tmput9c_l1o.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002accae716c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002accae40db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002accae40d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002accae40c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmput9c_l1o                        0x00005566fcc5d676 <unavailable> + 5750

    5    libc.so.6                          0x00002accae902460 __libc_start_main +
    245

    6    tmput9c_l1o                        0x00005566fcc5d209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max_fill = 0\n    for row in grid\
    \ {\n        var fill = 0\n        for cell in row {\n            if cell == 1\
    \ {\n                fill += 1\n            } else {\n                if fill\
    \ > max_fill {\n                    max_fill = fill\n                }\n     \
    \           fill = 0\n            }\n        }\n        if fill > max_fill {\n\
    \            max_fill = fill\n        }\n    }\n    return max_fill\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpiu7b5f81/tmpiu7b5f81.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b636a74fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b636a446b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b636a446988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b636a4457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiu7b5f81                        0x000055a1ac563546 <unavailable> + 5446

    5    libc.so.6                          0x00002b636a93b460 __libc_start_main +
    245

    6    tmpiu7b5f81                        0x000055a1ac5630d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                let row\
    \ = min(i + capacity, grid.count - 1)\n                let col = min(j + capacity,\
    \ grid[i].count - 1)\n                for k in i...row {\n                   \
    \ for l in j...col {\n                        grid[k][l] = 0\n               \
    \     }\n                }\n            }\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpuzcvg9pi/tmpuzcvg9pi.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9d12d5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9d0fccb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9d0fcc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9d0fcb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuzcvg9pi                        0x0000561a9e6c3886 <unavailable> + 6278

    5    libc.so.6                          0x00002ae9d14c1460 __libc_start_main +
    245

    6    tmpuzcvg9pi                        0x0000561a9e6c3419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for col in row {\n     \
    \       if col == 1 {\n                max_fill += 1\n            }\n        }\n\
    \        result += max_fill / capacity\n        if max_fill % capacity != 0 {\n\
    \            result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for i in 0..<grid.count {\n        max_fill = 0\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                max_fill += 1\n       \
    \     }\n        }\n        result += max_fill / capacity\n        if max_fill\
    \ % capacity > 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    let rows = grid.count\n    let cols =\
    \ grid[0].count\n    var result = 0\n    var row_max = [Int](repeating: 0, count:\
    \ rows)\n    for i in 0..<rows {\n        for j in 0..<cols {\n            row_max[i]\
    \ = max(row_max[i], grid[i][j])\n        }\n    }\n    for i in 0..<rows {\n \
    \       for j in 0..<cols {\n            if grid[i][j] == 1 {\n              \
    \  result += 1\n            }\n        }\n        result += row_max[i] / capacity\n\
    \        if row_max[i] % capacity != 0 {\n            result += 1\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsc11caq5/tmpsc11caq5.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6098ba0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6098897b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6098897988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b60988967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsc11caq5                        0x000055d8c6dee7a6 <unavailable> + 6054

    5    libc.so.6                          0x00002b6098d8c460 __libc_start_main +
    245

    6    tmpsc11caq5                        0x000055d8c6dee339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    while fill < max_fill {\n        fill = 0\n        for row in grid\
    \ {\n            for col in row {\n                if col == 1 {\n           \
    \         fill += 1\n                    if fill == capacity {\n             \
    \           result += 1\n                        fill = 0\n                  \
    \  }\n                }\n            }\n        }\n        result += 1\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr9zxq02w/tmpr9zxq02w.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3856e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3853dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3853db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3853da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr9zxq02w                        0x0000563671f8a546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba3858d0460 __libc_start_main +
    245

    6    tmpr9zxq02w                        0x0000563671f8a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        var sum = 0\n        for j in 0..<grid[i].count {\n            sum\
    \ += grid[i][j]\n        }\n        count += sum / capacity\n        if sum %\
    \ capacity > 0 {\n            count += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for col in row {\n     \
    \       if col == 1 {\n                max_fill += 1\n            } else {\n \
    \               max_fill = 0\n            }\n            if max_fill == capacity\
    \ {\n                result += 1\n                max_fill = 0\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpbjlclfgz/tmpbjlclfgz.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade88af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade887efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade887ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade887ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbjlclfgz                        0x000055bab6127717 <unavailable> + 5911

    5    libc.so.6                          0x00002ade88ce4460 __libc_start_main +
    245

    6    tmpbjlclfgz                        0x000055bab61270d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n       \
    \     if grid[i][j] == 1 {\n                max_fill += 1\n            }\n   \
    \     }\n    }\n    var fill = 0\n    var i = 0\n    while fill < max_fill {\n\
    \        var j = 0\n        while j < grid[i].count {\n            if grid[i][j]\
    \ == 1 {\n                fill += 1\n                grid[i][j] = 0\n        \
    \    }\n            j += 1\n        }\n        result += 1\n        i += 1\n \
    \       if i == grid.count {\n            i = 0\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpahd_jz6p.swift:46:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 0\n                ~~~~  \
    \ ^\n"
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    for row in\
    \ grid {\n        for col in row {\n            if col == 1 {\n              \
    \  result += 1\n            }\n        }\n        if result == max_fill {\n  \
    \          break\n        }\n        result = 0\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdd_n3ds6/tmpdd_n3ds6.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9bbf93c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac9bbc8ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac9bbc8a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9bbc897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdd_n3ds6                        0x000055b504153546 <unavailable> + 5446

    5    libc.so.6                          0x00002ac9bc17f460 __libc_start_main +
    245

    6    tmpdd_n3ds6                        0x000055b5041530d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var current_fill\
    \ = 0\n    for row in grid {\n        for cell in row {\n            if cell ==\
    \ 1 {\n                current_fill += 1\n            }\n            if current_fill\
    \ == max_fill {\n                result += 1\n                current_fill = 0\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpx6xm8stm/tmpx6xm8stm.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeed5a97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeed578eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeed578e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeed578d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx6xm8stm                        0x00005651b89bb546 <unavailable> + 5446

    5    libc.so.6                          0x00002aeed5c83460 __libc_start_main +
    245

    6    tmpx6xm8stm                        0x00005651b89bb0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for i in 0..<grid.count\
    \ {\n        var sum = 0\n        for j in 0..<grid[i].count {\n            sum\
    \ += grid[i][j]\n        }\n        result += sum / capacity\n        if sum %\
    \ capacity != 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var sum = 0\n        for cell in row {\n            sum += cell\n   \
    \         if sum == capacity {\n                result += 1\n                sum\
    \ = 0\n            }\n        }\n        if sum > 0 {\n            result += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                grid[i][j]\
    \ = 0\n                if i > 0 {\n                    grid[i-1][j] = min(grid[i-1][j]\
    \ + 1, capacity)\n                }\n                if i < grid.count - 1 {\n\
    \                    grid[i+1][j] = min(grid[i+1][j] + 1, capacity)\n        \
    \        }\n                if j > 0 {\n                    grid[i][j-1] = min(grid[i][j-1]\
    \ + 1, capacity)\n                }\n                if j < grid[i].count - 1\
    \ {\n                    grid[i][j+1] = min(grid[i][j+1] + 1, capacity)\n    \
    \            }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpyf8e8jgd/tmpyf8e8jgd.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4010fabc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4010ca2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4010ca2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4010ca17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyf8e8jgd                        0x000055fb77a5d796 <unavailable> + 6038

    5    libc.so.6                          0x00002b4011197460 __libc_start_main +
    245

    6    tmpyf8e8jgd                        0x000055fb77a5d329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var sum = 0\n        for col in row {\n            sum += col\n     \
    \       if sum == capacity {\n                result += 1\n                sum\
    \ = 0\n            }\n        }\n        if sum > 0 {\n            result += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var found = false\n        for i in 0..<grid.count {\n\
    \            for j in 0..<grid[i].count {\n                if grid[i][j] == 1\
    \ {\n                    found = true\n                    grid[i][j] = 0\n  \
    \                  count += 1\n                }\n            }\n        }\n \
    \       if !found {\n            break\n        }\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ -1 {\n                    grid[i][j] = 1\n                }\n            }\n\
    \        }\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 1 {\n                    for k in 0..<capacity\
    \ {\n                        if i + k < grid.count {\n                       \
    \     grid[i + k][j] = -1\n                        }\n                    }\n\
    \                }\n            }\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpk8nu68d0/tmpk8nu68d0.swift:82: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4d4769cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4d47393b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4d47393988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4d473927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk8nu68d0                        0x000056311c0f18d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b4d47888460 __libc_start_main +
    245

    6    tmpk8nu68d0                        0x000056311c0f1299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for col in row {\n     \
    \       if col == 1 {\n                max_fill += 1\n            } else {\n \
    \               result += max_fill / capacity\n                max_fill = 0\n\
    \            }\n        }\n        result += max_fill / capacity\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpnyt80lf2/tmpnyt80lf2.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af10b4b1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af10b1a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af10b1a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af10b1a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnyt80lf2                        0x0000558b7e66c7a7 <unavailable> + 6055

    5    libc.so.6                          0x00002af10b69d460 __libc_start_main +
    245

    6    tmpnyt80lf2                        0x0000558b7e66c169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                count += 1\n            }\n        }\n        max_fill = max(max_fill,\
    \ count)\n        count = 0\n    }\n    return max_fill / capacity + (max_fill\
    \ % capacity > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5fjd9mw3/tmp5fjd9mw3.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af584e28c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af584b1fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af584b1f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af584b1e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5fjd9mw3                        0x000055b6bf199676 <unavailable> + 5750

    5    libc.so.6                          0x00002af585014460 __libc_start_main +
    245

    6    tmp5fjd9mw3                        0x000055b6bf199209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var bucket = 0\n  \
    \  for row in grid {\n        for col in row {\n            if col == 1 {\n  \
    \              bucket += 1\n            }\n        }\n        if bucket > capacity\
    \ {\n            count += bucket / capacity\n            bucket = bucket % capacity\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp67nx_h40/tmp67nx_h40.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea41e07c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea41afeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea41afe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea41afd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp67nx_h40                        0x00005628f95eb7a7 <unavailable> + 6055

    5    libc.so.6                          0x00002aea41ff3460 __libc_start_main +
    245

    6    tmp67nx_h40                        0x00005628f95eb169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    for row in grid {\n\
    \        var sum = 0\n        for i in row {\n            sum += i\n        }\n\
    \        count += sum / capacity\n        if sum % capacity != 0 {\n         \
    \   count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr9zxq02w/tmpr9zxq02w.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3856e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3853dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3853db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3853da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr9zxq02w                        0x0000563671f8a546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba3858d0460 __libc_start_main +
    245

    6    tmpr9zxq02w                        0x0000563671f8a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var current_fill = 0\n        for well in row {\n            if well\
    \ == 1 {\n                current_fill += 1\n            } else {\n          \
    \      if current_fill > 0 {\n                    result += 1\n              \
    \      current_fill = 0\n                }\n            }\n        }\n       \
    \ if current_fill > 0 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp9k1wfnfi/tmp9k1wfnfi.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aed4fa78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aed4f76fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aed4f76f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aed4f76e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9k1wfnfi                        0x0000555680fda546 <unavailable> + 5446

    5    libc.so.6                          0x00002aed4fc64460 __libc_start_main +
    245

    6    tmp9k1wfnfi                        0x0000555680fda0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2f4geop2.swift:36:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for column in row {\n  \
    \          if column == 1 {\n                max_fill += 1\n            }\n  \
    \      }\n        result += max_fill / capacity\n        if max_fill % capacity\
    \ != 0 {\n            result += 1\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    while fill < max_fill {\n        for row in grid {\n            for\
    \ cell in row {\n                if cell == 1 {\n                    fill += 1\n\
    \                    if fill == max_fill {\n                        return result\n\
    \                    }\n                }\n            }\n            result +=\
    \ 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp5b1hwz5w/tmp5b1hwz5w.swift:69: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad3d0e10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad3d0b07b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad3d0b07988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad3d0b067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5b1hwz5w                        0x00005647d98b8546 <unavailable> + 5446

    5    libc.so.6                          0x00002ad3d0ffc460 __libc_start_main +
    245

    6    tmp5b1hwz5w                        0x00005647d98b80d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    let n = grid.count\n    let m = grid[0].count\n\
    \    var water = 0\n    var count = 0\n    for i in 0..<n {\n        for j in\
    \ 0..<m {\n            water += grid[i][j]\n        }\n    }\n    while water\
    \ > 0 {\n        count += 1\n        var i = 0\n        var j = 0\n        while\
    \ i < n && j < m {\n            if grid[i][j] == 1 {\n                water -=\
    \ 1\n                grid[i][j] = 0\n            }\n            if j == m - 1\
    \ {\n                i += 1\n                j = 0\n            } else {\n   \
    \             j += 1\n            }\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpw3fo82ab.swift:46:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 0\n                ~~~~  \
    \ ^\n"
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    let rows = grid.count\n\
    \    let cols = grid[0].count\n    var count = 0\n    var i = 0\n    while i <\
    \ rows {\n        var j = 0\n        while j < cols {\n            if grid[i][j]\
    \ == 1 {\n                count += 1\n                var k = i\n            \
    \    while k < rows && k < i + capacity {\n                    grid[k][j] = 0\n\
    \                    k += 1\n                }\n            }\n            j +=\
    \ 1\n        }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpexbxu5jx/tmpexbxu5jx.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abdaa390c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abdaa087b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abdaa087988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abdaa0867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpexbxu5jx                        0x000056531e6b4747 <unavailable> + 5959

    5    libc.so.6                          0x00002abdaa57c460 __libc_start_main +
    245

    6    tmpexbxu5jx                        0x000056531e6b4109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    for row in grid {\n\
    \        var sum = 0\n        for i in row {\n            sum += i\n        }\n\
    \        count += sum / capacity\n        if sum % capacity != 0 {\n         \
    \   count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for i in 0..<grid.count {\n        max_fill = 0\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                max_fill += 1\n       \
    \     }\n        }\n        result += max_fill / capacity\n        if max_fill\
    \ % capacity != 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn7f9m03b/tmpn7f9m03b.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25f3cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25f39edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25f39ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25f39ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7f9m03b                        0x000055932be713d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b25f3ee2460 __libc_start_main +
    245

    6    tmpn7f9m03b                        0x000055932be70f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2f4geop2.swift:36:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var fill = 0\n        for cell in row {\n            if cell == 1 {\n\
    \                fill += 1\n            } else {\n                if fill > 0\
    \ {\n                    result += 1\n                    fill = 0\n         \
    \       }\n            }\n        }\n        if fill > 0 {\n            result\
    \ += 1\n        }\n    }\n    return result * capacity\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpg6ras09l/tmpg6ras09l.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f3ad49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f3aa40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f3aa40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f3aa3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg6ras09l                        0x0000563734573546 <unavailable> + 5446

    5    libc.so.6                          0x00002b2f3af35460 __libc_start_main +
    245

    6    tmpg6ras09l                        0x00005637345730d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var sum = 0\n        for i in 0..<row.count {\n            if row[i]\
    \ == 1 {\n                sum += 1\n            } else {\n                if sum\
    \ > 0 {\n                    let fill = min(sum, capacity)\n                 \
    \   result += fill\n                    sum -= fill\n                }\n     \
    \       }\n        }\n        if sum > 0 {\n            result += sum\n      \
    \  }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpx8x0820e/tmpx8x0820e.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad047da0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad047a97b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad047a97988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad047a967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx8x0820e                        0x000055ad9fcb99e7 <unavailable> + 6631

    5    libc.so.6                          0x00002ad047f8c460 __libc_start_main +
    245

    6    tmpx8x0820e                        0x000055ad9fcb93a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr9zxq02w/tmpr9zxq02w.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3856e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3853dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3853db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3853da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr9zxq02w                        0x0000563671f8a546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba3858d0460 __libc_start_main +
    245

    6    tmpr9zxq02w                        0x0000563671f8a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for col in row {\n     \
    \       if col == 1 {\n                max_fill += 1\n            } else {\n \
    \               if max_fill > 0 {\n                    result += 1\n         \
    \           max_fill = 0\n                }\n            }\n        }\n      \
    \  if max_fill > 0 {\n            result += 1\n        }\n    }\n    return result\
    \ * capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_wlutmvv/tmp_wlutmvv.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1588e0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1588b03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1588b03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1588b027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_wlutmvv                        0x0000559f3f450546 <unavailable> + 5446

    5    libc.so.6                          0x00002b1588ff8460 __libc_start_main +
    245

    6    tmp_wlutmvv                        0x0000559f3f4500d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var row = 0\n        var col = 0\n        var max_height\
    \ = 0\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] > max_height {\n                    max_height\
    \ = grid[i][j]\n                    row = i\n                    col = j\n   \
    \             }\n            }\n        }\n        if max_height == 0 {\n    \
    \        break\n        }\n        for i in 0..<grid.count {\n            for\
    \ j in 0..<grid[i].count {\n                if grid[i][j] > 0 {\n            \
    \        grid[i][j] -= 1\n                }\n            }\n        }\n      \
    \  grid[row][col] = capacity\n        count += 1\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824468
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_row = 0\n\
    \    for row in grid {\n        max_row = max(max_row, row.reduce(0, +))\n   \
    \ }\n    var current_max = 0\n    for row in grid {\n        current_max = max(current_max,\
    \ row.reduce(0, +))\n        if current_max == max_row {\n            break\n\
    \        }\n        result += 1\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpajpv1lpi/tmpajpv1lpi.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba5c74b2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba5c71a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba5c71a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba5c71a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpajpv1lpi                        0x000055fbabaa0656 <unavailable> + 5718

    5    libc.so.6                          0x00002ba5c769e460 __libc_start_main +
    245

    6    tmpajpv1lpi                        0x000055fbabaa01e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] >\
    \ 0 {\n                    filled = true\n                    let amount = min(grid[i][j],\
    \ capacity)\n                    grid[i][j] -= amount\n                    if\
    \ i > 0 {\n                        grid[i-1][j] += amount\n                  \
    \  }\n                    if i < grid.count - 1 {\n                        grid[i+1][j]\
    \ += amount\n                    }\n                    if j > 0 {\n         \
    \               grid[i][j-1] += amount\n                    }\n              \
    \      if j < grid[i].count - 1 {\n                        grid[i][j+1] += amount\n\
    \                    }\n                }\n            }\n        }\n        if\
    \ !filled {\n            break\n        }\n        count += 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824468
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    let rows = grid.count\n\
    \    let cols = grid[0].count\n    var max_row = Array(repeating: 0, count: cols)\n\
    \    for i in 0..<rows {\n        for j in 0..<cols {\n            if grid[i][j]\
    \ == 1 {\n                max_row[j] += 1\n            }\n        }\n    }\n \
    \   for i in 0..<rows {\n        for j in 0..<cols {\n            if grid[i][j]\
    \ == 1 {\n                result += 1\n                max_row[j] -= 1\n     \
    \       }\n            if max_row[j] == 0 {\n                break\n         \
    \   }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpagx8f_ge/tmpagx8f_ge.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab66d0f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab66cde9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab66cde9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab66cde87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpagx8f_ge                        0x0000558b2cb5a716 <unavailable> + 5910

    5    libc.so.6                          0x00002ab66d2de460 __libc_start_main +
    245

    6    tmpagx8f_ge                        0x0000558b2cb5a2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                count += 1\n            }\n        }\n        if count > max_fill\
    \ {\n            max_fill = count\n        }\n        count = 0\n    }\n    return\
    \ max_fill / capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpcrlwn4hd/tmpcrlwn4hd.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b529ef50c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b529ec47b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b529ec47988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b529ec467b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcrlwn4hd                        0x000055d1cb62f5d6 <unavailable> + 5590

    5    libc.so.6                          0x00002b529f13c460 __libc_start_main +
    245

    6    tmpcrlwn4hd                        0x000055d1cb62f169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    let rows = grid.count\n\
    \    let cols = grid[0].count\n    var max_row = [Int](repeating: 0, count: cols)\n\
    \    for row in 0..<rows {\n        for col in 0..<cols {\n            if grid[row][col]\
    \ == 1 {\n                max_row[col] += 1\n            }\n        }\n    }\n\
    \    for row in 0..<rows {\n        for col in 0..<cols {\n            if grid[row][col]\
    \ == 1 {\n                result += 1\n                if max_row[col] > capacity\
    \ {\n                    max_row[col] -= capacity\n                } else {\n\
    \                    max_row[col] = 0\n                }\n            }\n    \
    \    }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpojibilvq/tmpojibilvq.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb933e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb930dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb930dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb930db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpojibilvq                        0x000055a53c70a8e7 <unavailable> + 6375

    5    libc.so.6                          0x00002acb935d1460 __libc_start_main +
    245

    6    tmpojibilvq                        0x000055a53c70a2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var count = 0\n        for cell in row {\n            if cell == 1 {\n\
    \                count += 1\n            }\n        }\n        result += count\
    \ / capacity\n        if count % capacity != 0 {\n            result += 1\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for i in 0..<grid.count\
    \ {\n        var sum = 0\n        for j in 0..<grid[i].count {\n            sum\
    \ += grid[i][j]\n        }\n        result += (sum + capacity - 1) / capacity\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for cell in row {\n            if cell ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpegzmykbs/tmpegzmykbs.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b816a3afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b816a0a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b816a0a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b816a0a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpegzmykbs                        0x0000559f66565546 <unavailable> + 5446

    5    libc.so.6                          0x00002b816a59b460 __libc_start_main +
    245

    6    tmpegzmykbs                        0x0000559f665650d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn7f9m03b/tmpn7f9m03b.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25f3cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25f39edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25f39ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25f39ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7f9m03b                        0x000055932be713d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b25f3ee2460 __libc_start_main +
    245

    6    tmpn7f9m03b                        0x000055932be70f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var max_row = -1\n        var max_col = -1\n       \
    \ var max_val = 0\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] > max_val {\n                    max_val =\
    \ grid[i][j]\n                    max_row = i\n                    max_col = j\n\
    \                }\n            }\n        }\n        if max_val == 0 {\n    \
    \        break\n        }\n        count += 1\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] >\
    \ 0 {\n                    let diff = min(capacity, max_val - grid[i][j])\n  \
    \                  grid[i][j] += diff\n                    max_val -= diff\n \
    \               }\n            }\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824468
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn7f9m03b/tmpn7f9m03b.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25f3cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25f39edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25f39ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25f39ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7f9m03b                        0x000055932be713d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b25f3ee2460 __libc_start_main +
    245

    6    tmpn7f9m03b                        0x000055932be70f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    while fill < max_fill {\n        var fill_this_round = 0\n        for\
    \ row in grid {\n            for col in row {\n                if col == 1 {\n\
    \                    fill_this_round += 1\n                    fill += 1\n   \
    \                 if fill_this_round == capacity {\n                        result\
    \ += 1\n                        fill_this_round = 0\n                    }\n \
    \               }\n            }\n        }\n        if fill_this_round > 0 {\n\
    \            result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr8eicn24/tmpr8eicn24.swift:78: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4097332c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4097029b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4097029988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40970287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr8eicn24                        0x000055f7215a9b44 <unavailable> + 6980

    5    libc.so.6                          0x00002b409751e460 __libc_start_main +
    245

    6    tmpr8eicn24                        0x000055f7215a90d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for cell in row {\n            if cell ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpegzmykbs/tmpegzmykbs.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b816a3afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b816a0a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b816a0a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b816a0a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpegzmykbs                        0x0000559f66565546 <unavailable> + 5446

    5    libc.so.6                          0x00002b816a59b460 __libc_start_main +
    245

    6    tmpegzmykbs                        0x0000559f665650d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var wells = grid\n\
    \    var max_fill = 0\n    for i in 0..<wells.count {\n        for j in 0..<wells[i].count\
    \ {\n            max_fill = max(max_fill, wells[i][j])\n        }\n    }\n   \
    \ for fill in 0..<max_fill {\n        for i in 0..<wells.count {\n           \
    \ for j in 0..<wells[i].count {\n                if wells[i][j] > 0 {\n      \
    \              wells[i][j] -= 1\n                    count += 1\n            \
    \    }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmplusis55h/tmplusis55h.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f79ba4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f7989bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f7989b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f7989a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplusis55h                        0x000055d84eb00967 <unavailable> + 6503

    5    libc.so.6                          0x00002b2f79d90460 __libc_start_main +
    245

    6    tmplusis55h                        0x000055d84eb00329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_row = 0\n\
    \    var max_col = 0\n    for row in grid {\n        max_row = max(max_row, row.reduce(0,\
    \ +))\n        for (col, val) in row.enumerated() {\n            max_col = max(max_col,\
    \ val)\n        }\n    }\n    for i in 0..<max_row {\n        for j in 0..<max_col\
    \ {\n            var filled = 0\n            for row in grid {\n             \
    \   for (col, val) in row.enumerated() {\n                    if val > 0 {\n \
    \                       filled += 1\n                        grid[col][row] -=\
    \ 1\n                    }\n                }\n            }\n            if filled\
    \ > 0 {\n                result += 1\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp789efg8d.swift:46:35: error: cannot convert value of type '[Int]'\
    \ to expected argument type 'Int'\n                        grid[col][row] -= 1\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659824463
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    while max_fill\
    \ > 0 {\n        max_fill = 0\n        for i in 0..<grid.count {\n           \
    \ var fill = 0\n            for j in 0..<grid[i].count {\n                if grid[i][j]\
    \ == 1 {\n                    fill += 1\n                }\n            }\n  \
    \          if fill > capacity {\n                max_fill += fill - capacity\n\
    \                result += 1\n            } else {\n                result +=\
    \ 1\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824468
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    var i = 0\n    while fill < max_fill {\n        var j = 0\n       \
    \ while j < grid[i].count {\n            if grid[i][j] == 1 {\n              \
    \  fill += 1\n                grid[i][j] = 0\n            }\n            j +=\
    \ 1\n        }\n        i += 1\n        result += 1\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpzdwit11r.swift:46:24: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[i][j] = 0\n                ~~~~  \
    \ ^\n"
  stdout: ''
  timestamp: 1659824463
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var total = 0\n    for row in grid {\n\
    \        var max_fill = 0\n        for well in row {\n            if well == 1\
    \ {\n                max_fill += 1\n            } else {\n                max_fill\
    \ = 0\n            }\n            if max_fill > capacity {\n                max_fill\
    \ = capacity\n            }\n        }\n        total += max_fill\n    }\n   \
    \ return total\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpziwb_mwl/tmpziwb_mwl.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b62ab4cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b62ab1c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b62ab1c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b62ab1c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpziwb_mwl                        0x0000561f3c52e546 <unavailable> + 5446

    5    libc.so.6                          0x00002b62ab6bb460 __libc_start_main +
    245

    6    tmpziwb_mwl                        0x0000561f3c52e0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    let n = grid.count\n    let m = grid[0].count\n\
    \    var grid = grid\n    var count = 0\n    for i in 0..<n {\n        for j in\
    \ 0..<m {\n            if grid[i][j] == 1 {\n                count += 1\n    \
    \            fill(&grid, i, j, capacity)\n            }\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3dcpctob.swift:38:17: error: cannot find 'fill' in scope\n    \
    \            fill(&grid, i, j, capacity)\n                ^~~~\n"
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn7f9m03b/tmpn7f9m03b.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25f3cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25f39edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25f39ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25f39ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7f9m03b                        0x000055932be713d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b25f3ee2460 __libc_start_main +
    245

    6    tmpn7f9m03b                        0x000055932be70f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var wells = grid\n\
    \    for i in 0..<wells.count {\n        for j in 0..<wells[i].count {\n     \
    \       if wells[i][j] == 1 {\n                count += 1\n                wells[i][j]\
    \ = 0\n                for k in 0..<wells.count {\n                    if wells[k][j]\
    \ == 1 {\n                        wells[k][j] = 0\n                        count\
    \ += 1\n                    }\n                }\n            }\n        }\n \
    \   }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpnqhltfht/tmpnqhltfht.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1828d27c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1828a1eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1828a1e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1828a1d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnqhltfht                        0x0000564b4f7ed8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b1828f13460 __libc_start_main +
    245

    6    tmpnqhltfht                        0x0000564b4f7ed299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var current_fill\
    \ = 0\n    for row in grid {\n        for cell in row {\n            if cell ==\
    \ 1 {\n                current_fill += 1\n            }\n            if current_fill\
    \ == max_fill {\n                result += 1\n                current_fill = 0\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpx6xm8stm/tmpx6xm8stm.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeed5a97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeed578eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeed578e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeed578d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx6xm8stm                        0x00005651b89bb546 <unavailable> + 5446

    5    libc.so.6                          0x00002aeed5c83460 __libc_start_main +
    245

    6    tmpx6xm8stm                        0x00005651b89bb0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for i in 0..<row.count {\n            if row[i]\
    \ == 1 {\n                max_fill += 1\n            }\n        }\n    }\n   \
    \ while max_fill > 0 {\n        result += 1\n        max_fill -= capacity\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmps5fv2x4i/tmps5fv2x4i.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba57b387c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba57b07eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba57b07e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba57b07d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps5fv2x4i                        0x00005615f79b4d74 <unavailable> + 7540

    5    libc.so.6                          0x00002ba57b573460 __libc_start_main +
    245

    6    tmps5fv2x4i                        0x00005615f79b4309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                count += 1\n            }\n        }\n        max_fill = max(max_fill,\
    \ count)\n        count = 0\n    }\n    return max_fill / capacity + (max_fill\
    \ % capacity > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp29awumw0/tmp29awumw0.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84daa9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da7947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29awumw0                        0x000055ef5a8b9676 <unavailable> + 5750

    5    libc.so.6                          0x00002b84dac8a460 __libc_start_main +
    245

    6    tmp29awumw0                        0x000055ef5a8b9209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for i in 0..<grid.count\
    \ {\n        var row = grid[i]\n        var max_fill = 0\n        for j in 0..<row.count\
    \ {\n            if row[j] == 1 {\n                max_fill += 1\n           \
    \ }\n        }\n        result += max_fill / capacity\n        if max_fill % capacity\
    \ > 0 {\n            result += 1\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var max_row = -1\n        var max_fill = 0\n       \
    \ for i in 0..<grid.count {\n            var fill = 0\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 1 {\n                    fill += 1\n   \
    \             }\n            }\n            if fill > max_fill {\n           \
    \     max_fill = fill\n                max_row = i\n            }\n        }\n\
    \        if max_fill == 0 {\n            break\n        }\n        for j in 0..<grid[max_row].count\
    \ {\n            if grid[max_row][j] == 1 {\n                grid[max_row][j]\
    \ = 0\n                count += 1\n            }\n        }\n        for i in\
    \ 0..<grid.count {\n            if i == max_row {\n                continue\n\
    \            }\n            for j in 0..<grid[i].count {\n                if grid[i][j]\
    \ == 1 {\n                    grid[i][j] = 0\n                    count += 1\n\
    \                }\n                if count == capacity {\n                 \
    \   break\n                }\n            }\n            if count == capacity\
    \ {\n                break\n            }\n        }\n        count = 0\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdquwij0l/tmpdquwij0l.swift:91: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8aa7604c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8aa72fbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8aa72fb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8aa72fa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdquwij0l                        0x0000563bae52b706 <unavailable> + 5894

    5    libc.so.6                          0x00002b8aa77f0460 __libc_start_main +
    245

    6    tmpdquwij0l                        0x0000563bae52b299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                count += 1\n            }\n        }\n        max_fill = max(max_fill,\
    \ count)\n        count = 0\n    }\n    return max_fill / capacity + (max_fill\
    \ % capacity > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp29awumw0/tmp29awumw0.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84daa9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da7947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29awumw0                        0x000055ef5a8b9676 <unavailable> + 5750

    5    libc.so.6                          0x00002b84dac8a460 __libc_start_main +
    245

    6    tmp29awumw0                        0x000055ef5a8b9209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max = 0\n    for\
    \ row in grid {\n        for i in row {\n            if i == 1 {\n           \
    \     count += 1\n            }\n        }\n        if count > max {\n       \
    \     max = count\n        }\n        count = 0\n    }\n    return max / capacity\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpi8mes_0n/tmpi8mes_0n.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0801a8ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0801781b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0801781988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08017807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8mes_0n                        0x0000557c5beee5d6 <unavailable> + 5590

    5    libc.so.6                          0x00002b0801c76460 __libc_start_main +
    245

    6    tmpi8mes_0n                        0x0000557c5beee169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                count += 1\n            }\n        }\n        max_fill = max(max_fill,\
    \ count)\n        count = 0\n    }\n    return max_fill / capacity + (max_fill\
    \ % capacity > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp29awumw0/tmp29awumw0.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84daa9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da795b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da795988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da7947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp29awumw0                        0x000055ef5a8b9676 <unavailable> + 5750

    5    libc.so.6                          0x00002b84dac8a460 __libc_start_main +
    245

    6    tmp29awumw0                        0x000055ef5a8b9209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var water = 0\n        for well in row {\n            water += well\n\
    \            if water == capacity {\n                result += 1\n           \
    \     water = 0\n            }\n        }\n        if water > 0 {\n          \
    \  result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var result = 0\n\
    \    while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    let row = grid[i]\n\
    \                    let row_capacity = capacity - row.reduce(0, +)\n        \
    \            if row_capacity > 0 {\n                        result += 1\n    \
    \                    for k in 0..<row.count {\n                            grid[i][k]\
    \ = min(1, grid[i][k] + row_capacity)\n                        }\n           \
    \         }\n                }\n            }\n        }\n        if !filled {\n\
    \            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824468
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var current_fill\
    \ = 0\n    while current_fill < max_fill {\n        for row in grid {\n      \
    \      for cell in row {\n                if cell == 1 {\n                   \
    \ current_fill += 1\n                }\n            }\n            if current_fill\
    \ < max_fill {\n                result += 1\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp67j0iwb4/tmp67j0iwb4.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3e8f49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3e8c40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3e8c40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3e8c3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp67j0iwb4                        0x00005617a4757546 <unavailable> + 5446

    5    libc.so.6                          0x00002ab3e9135460 __libc_start_main +
    245

    6    tmp67j0iwb4                        0x00005617a47570d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn7f9m03b/tmpn7f9m03b.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25f3cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25f39edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25f39ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25f39ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7f9m03b                        0x000055932be713d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b25f3ee2460 __libc_start_main +
    245

    6    tmpn7f9m03b                        0x000055932be70f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    // edge case\n    if grid.count == 0 {\n\
    \        return 0\n    }\n    // init\n    var count = 0\n    var max_fill = 0\n\
    \    var max_fill_index = 0\n    var max_fill_row = 0\n    // find max fill\n\
    \    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n       \
    \     if grid[i][j] == 1 {\n                count += 1\n            }\n      \
    \  }\n        if count > max_fill {\n            max_fill = count\n          \
    \  max_fill_index = i\n        }\n        count = 0\n    }\n    // fill\n    for\
    \ i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n            if\
    \ grid[i][j] == 1 {\n                max_fill_row += 1\n            }\n      \
    \  }\n        if max_fill_row > capacity {\n            max_fill_row = capacity\n\
    \        }\n        count += max_fill_row\n        max_fill_row = 0\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4tvymydk/tmp4tvymydk.swift:81: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afacbf1fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afacbc16b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afacbc16988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afacbc157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4tvymydk                        0x0000564fe21cd656 <unavailable> + 5718

    5    libc.so.6                          0x00002afacc10b460 __libc_start_main +
    245

    6    tmp4tvymydk                        0x0000564fe21cd1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_row = 0\n\
    \    var max_col = 0\n    for row in grid {\n        max_row = max(max_row, row.reduce(0,\
    \ +))\n        for (index, col) in row.enumerated() {\n            max_col = max(max_col,\
    \ col)\n            if col == 1 {\n                result += 1\n            }\n\
    \        }\n    }\n    result += max(max_row, max_col)\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpx49mt0ry/tmpx49mt0ry.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71fed3bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71fea32b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71fea32988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71fea317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx49mt0ry                        0x0000563449be6866 <unavailable> + 6246

    5    libc.so.6                          0x00002b71fef27460 __libc_start_main +
    245

    6    tmpx49mt0ry                        0x0000563449be63f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    var row = 0\n    while fill < max_fill {\n        var col = 0\n   \
    \     while col < grid[row].count {\n            if grid[row][col] == 1 {\n  \
    \              fill += 1\n                grid[row][col] = 0\n            }\n\
    \            col += 1\n        }\n        row += 1\n        result += 1\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvrtpl9mb.swift:46:26: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                grid[row][col] = 0\n                ~~~~\
    \     ^\n"
  stdout: ''
  timestamp: 1659824463
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2f4geop2.swift:36:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for i in 0..<grid.count {\n        max_fill = 0\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                max_fill += 1\n       \
    \     }\n        }\n        result += max_fill / capacity\n        if max_fill\
    \ % capacity > 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                count += 1\n            }\n        }\n        max_fill = max(max_fill,\
    \ count)\n        count = 0\n    }\n    return max_fill / capacity + (max_fill\
    \ % capacity > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5fjd9mw3/tmp5fjd9mw3.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af584e28c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af584b1fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af584b1f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af584b1e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5fjd9mw3                        0x000055b6bf199676 <unavailable> + 5750

    5    libc.so.6                          0x00002af585014460 __libc_start_main +
    245

    6    tmp5fjd9mw3                        0x000055b6bf199209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var fill = 0\n        for cell in row {\n            if cell == 1 {\n\
    \                fill += 1\n            } else {\n                if fill > 0\
    \ {\n                    result += 1\n                    fill = 0\n         \
    \       }\n            }\n        }\n        if fill > 0 {\n            result\
    \ += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpa39sg9p9/tmpa39sg9p9.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af4d3728c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af4d341fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af4d341f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af4d341e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa39sg9p9                        0x000055ba4fc6a546 <unavailable> + 5446

    5    libc.so.6                          0x00002af4d3914460 __libc_start_main +
    245

    6    tmpa39sg9p9                        0x000055ba4fc6a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var sum = 0\n        for col in row {\n            sum += col\n     \
    \       if sum > capacity {\n                result += 1\n                sum\
    \ = col\n            }\n        }\n        result += 1\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpktbo5j5i/tmpktbo5j5i.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af020d17c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af020a0eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af020a0e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af020a0d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpktbo5j5i                        0x0000564b89e99717 <unavailable> + 5911

    5    libc.so.6                          0x00002af020f03460 __libc_start_main +
    245

    6    tmpktbo5j5i                        0x0000564b89e990d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn7f9m03b/tmpn7f9m03b.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25f3cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25f39edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25f39ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25f39ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7f9m03b                        0x000055932be713d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b25f3ee2460 __libc_start_main +
    245

    6    tmpn7f9m03b                        0x000055932be70f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var current = 0\n        for cell in row {\n            if cell == 1\
    \ {\n                current += 1\n            } else {\n                if current\
    \ > 0 {\n                    let fill = min(current, capacity)\n             \
    \       result += fill\n                    current -= fill\n                }\n\
    \            }\n        }\n        if current > 0 {\n            result += current\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpf4r362sg/tmpf4r362sg.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b62d7dd9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b62d7ad0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b62d7ad0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b62d7acf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf4r362sg                        0x000055ce6f26f7a7 <unavailable> + 6055

    5    libc.so.6                          0x00002b62d7fc5460 __libc_start_main +
    245

    6    tmpf4r362sg                        0x000055ce6f26f169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_height = 0\n\
    \    for row in grid {\n        max_height = max(max_height, row.max()!)\n   \
    \ }\n    for i in 0..<max_height {\n        var fill_count = 0\n        for row\
    \ in grid {\n            for cell in row {\n                if cell >= i {\n \
    \                   fill_count += 1\n                }\n            }\n      \
    \  }\n        result += fill_count / capacity\n        if fill_count % capacity\
    \ != 0 {\n            result += 1\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp7h1b8qgr/tmp7h1b8qgr.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b50f2585c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b50f227cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b50f227c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b50f227b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7h1b8qgr                        0x0000557b1797e7c6 <unavailable> + 6086

    5    libc.so.6                          0x00002b50f2771460 __libc_start_main +
    245

    6    tmp7h1b8qgr                        0x0000557b1797e359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr9zxq02w/tmpr9zxq02w.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3856e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3853dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3853db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3853da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr9zxq02w                        0x0000563671f8a546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba3858d0460 __libc_start_main +
    245

    6    tmpr9zxq02w                        0x0000563671f8a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr9zxq02w/tmpr9zxq02w.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3856e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3853dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3853db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3853da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr9zxq02w                        0x0000563671f8a546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba3858d0460 __libc_start_main +
    245

    6    tmpr9zxq02w                        0x0000563671f8a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for i in 0..<grid.count\
    \ {\n        var sum = 0\n        for j in 0..<grid[i].count {\n            sum\
    \ += grid[i][j]\n        }\n        result += sum / capacity\n        if sum %\
    \ capacity != 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    let n = grid.count\n    let m = grid[0].count\n\
    \    var grid = grid\n    var count = 0\n    for i in 0..<n {\n        for j in\
    \ 0..<m {\n            if grid[i][j] == 1 {\n                count += 1\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4w7tzuli.swift:38:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    // 1. find the max height of each column\n\
    \    var max_height = [Int](repeating: 0, count: grid[0].count)\n    for row in\
    \ grid {\n        for (i, col) in row.enumerated() {\n            if col == 1\
    \ {\n                max_height[i] += 1\n            }\n        }\n    }\n   \
    \ // 2. find the min height of each column\n    var min_height = [Int](repeating:\
    \ Int.max, count: grid[0].count)\n    for row in grid {\n        for (i, col)\
    \ in row.enumerated() {\n            if col == 1 {\n                min_height[i]\
    \ = min(min_height[i], 1)\n            } else {\n                min_height[i]\
    \ = min(min_height[i], 0)\n            }\n        }\n    }\n    // 3. find the\
    \ max height of each column\n    var max_fill = 0\n    for i in 0..<max_height.count\
    \ {\n        max_fill = max(max_fill, max_height[i] - min_height[i])\n    }\n\
    \    // 4. find the number of times we need to lower the buckets\n    return max_fill\
    \ / capacity + (max_fill % capacity == 0 ? 0 : 1)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp79k2hwy4/tmp79k2hwy4.swift:72: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67d0814c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67d050bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67d050b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67d050a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp79k2hwy4                        0x00005576847d4b86 <unavailable> + 7046

    5    libc.so.6                          0x00002b67d0a00460 __libc_start_main +
    245

    6    tmp79k2hwy4                        0x00005576847d4719 <unavailable> + 5913

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn7f9m03b/tmpn7f9m03b.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25f3cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25f39edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25f39ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25f39ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7f9m03b                        0x000055932be713d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b25f3ee2460 __libc_start_main +
    245

    6    tmpn7f9m03b                        0x000055932be70f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max_fill = 0\n    for row in grid\
    \ {\n        var fill = 0\n        for well in row {\n            fill += well\n\
    \            if fill == capacity {\n                max_fill += 1\n          \
    \      fill = 0\n            }\n        }\n        if fill > 0 {\n           \
    \ max_fill += 1\n        }\n    }\n    return max_fill\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    for k in 0..<grid.count {\n                        if grid[k][j]\
    \ < capacity {\n                            grid[k][j] += 1\n                \
    \        }\n                    }\n                }\n            }\n        }\n\
    \        if !filled {\n            break\n        }\n        count += 1\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824468
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var current_capacity = capacity\n        for col in row {\n         \
    \   if col == 1 {\n                current_capacity -= 1\n            }\n    \
    \        if current_capacity == 0 {\n                result += 1\n           \
    \     current_capacity = capacity\n            }\n        }\n        if current_capacity\
    \ < capacity {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    // 1. find the max height of the wells\n\
    \    var max_height = 0\n    for row in grid {\n        let row_max = row.max()!\n\
    \        if row_max > max_height {\n            max_height = row_max\n       \
    \ }\n    }\n    // 2. fill the wells from bottom to top\n    var count = 0\n \
    \   for height in 0..<max_height {\n        for row in grid {\n            for\
    \ col in row {\n                if col > height {\n                    count +=\
    \ 1\n                }\n            }\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp2ilta71f/tmp2ilta71f.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afe56d5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afe56a52b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afe56a52988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afe56a517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2ilta71f                        0x000055fc44653937 <unavailable> + 6455

    5    libc.so.6                          0x00002afe56f47460 __libc_start_main +
    245

    6    tmp2ilta71f                        0x000055fc446532f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var water = 0\n        for well in row {\n            water += well\n\
    \            if water == capacity {\n                result += 1\n           \
    \     water = 0\n            }\n        }\n        if water > 0 {\n          \
    \  result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                grid[i][j]\
    \ = 0\n                var k = i + 1\n                while k < grid.count &&\
    \ capacity > 0 {\n                    if grid[k][j] == 1 {\n                 \
    \       grid[k][j] = 0\n                        capacity -= 1\n              \
    \      }\n                    k += 1\n                }\n            }\n     \
    \   }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsa_fceuc.swift:41:34: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                        capacity -=\
    \ 1\n                        ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn7f9m03b/tmpn7f9m03b.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25f3cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25f39edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25f39ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25f39ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7f9m03b                        0x000055932be713d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b25f3ee2460 __libc_start_main +
    245

    6    tmpn7f9m03b                        0x000055932be70f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var current_capacity = capacity\n        for col in row {\n         \
    \   if col == 1 {\n                current_capacity -= 1\n            }\n    \
    \        if current_capacity == 0 {\n                result += 1\n           \
    \     current_capacity = capacity\n            }\n        }\n        if current_capacity\
    \ < capacity {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for cell in row {\n            if cell ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpegzmykbs/tmpegzmykbs.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b816a3afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b816a0a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b816a0a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b816a0a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpegzmykbs                        0x0000559f66565546 <unavailable> + 5446

    5    libc.so.6                          0x00002b816a59b460 __libc_start_main +
    245

    6    tmpegzmykbs                        0x0000559f665650d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var sum = 0\n        for cell in row {\n            sum += cell\n   \
    \         if sum == capacity {\n                result += 1\n                sum\
    \ = 0\n            }\n        }\n        if sum > 0 {\n            result += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                count += 1\n            }\n        }\n        max_fill = max(max_fill,\
    \ count)\n        count = 0\n    }\n    return max_fill / capacity + (max_fill\
    \ % capacity > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5fjd9mw3/tmp5fjd9mw3.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af584e28c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af584b1fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af584b1f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af584b1e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5fjd9mw3                        0x000055b6bf199676 <unavailable> + 5750

    5    libc.so.6                          0x00002af585014460 __libc_start_main +
    245

    6    tmp5fjd9mw3                        0x000055b6bf199209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var water = 0\n        for well in row {\n            water += well\n\
    \            if water == capacity {\n                result += 1\n           \
    \     water = 0\n            }\n        }\n        if water > 0 {\n          \
    \  result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max_fill = 0\n    for row in grid\
    \ {\n        var fill = 0\n        for well in row {\n            if well == 1\
    \ {\n                fill += 1\n            } else {\n                if fill\
    \ > 0 {\n                    max_fill += 1\n                    fill = 0\n   \
    \             }\n            }\n        }\n        if fill > 0 {\n           \
    \ max_fill += 1\n        }\n    }\n    return max_fill * capacity\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwjujxba_/tmpwjujxba_.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae44dd8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae44da82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae44da82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae44da817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwjujxba_                        0x00005654e27be546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae44df77460 __libc_start_main +
    245

    6    tmpwjujxba_                        0x00005654e27be0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var current_fill\
    \ = 0\n    var current_row = 0\n    while current_fill < max_fill {\n        var\
    \ current_capacity = capacity\n        while current_capacity > 0 && current_row\
    \ < grid.count {\n            for i in 0..<grid[current_row].count {\n       \
    \         if grid[current_row][i] == 1 {\n                    grid[current_row][i]\
    \ = 0\n                    current_fill += 1\n                    current_capacity\
    \ -= 1\n                }\n            }\n            current_row += 1\n     \
    \   }\n        result += 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2cm1l7sf.swift:46:38: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                    grid[current_row][i] = 0\n        \
    \            ~~~~             ^\n"
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var count = 0\n        for col in row {\n            if col == 1 {\n\
    \                count += 1\n            }\n        }\n        result += count\
    \ / capacity\n        if count % capacity != 0 {\n            result += 1\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   var row = 0\n    var col = 0\n    while row < grid.count {\n        col =\
    \ 0\n        while col < grid[row].count {\n            if grid[row][col] == 1\
    \ {\n                count += 1\n                grid = fill_bucket(grid: grid,\
    \ row: row, col: col, capacity: capacity)\n            }\n            col += 1\n\
    \        }\n        row += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp_2fmf405.swift:39:24: error: cannot find 'fill_bucket' in scope\n\
    \                grid = fill_bucket(grid: grid, row: row, col: col, capacity:\
    \ capacity)\n                       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var sum = 0\n        for col in row {\n            sum += col\n     \
    \       if sum == capacity {\n                result += 1\n                sum\
    \ = 0\n            }\n        }\n        if sum > 0 {\n            result += 1\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    let rows = grid.count\n    let cols =\
    \ grid[0].count\n    var grid = grid\n    var count = 0\n    for _ in 0..<rows\
    \ {\n        for col in 0..<cols {\n            if grid[0][col] == 1 {\n     \
    \           count += 1\n                grid[0][col] = 0\n                var\
    \ row = 1\n                while row < rows && capacity > 0 {\n              \
    \      if grid[row][col] == 1 {\n                        grid[row][col] = 0\n\
    \                        capacity -= 1\n                    }\n              \
    \      row += 1\n                }\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp4dfzz5zu.swift:43:34: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                        capacity -=\
    \ 1\n                        ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max_fill = 0\n    for row in grid\
    \ {\n        var fill = 0\n        for well in row {\n            if well == 1\
    \ {\n                fill += 1\n            } else {\n                if fill\
    \ > 0 {\n                    max_fill += 1\n                    fill = 0\n   \
    \             }\n            }\n        }\n        if fill > 0 {\n           \
    \ max_fill += 1\n        }\n    }\n    return max_fill * capacity\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwjujxba_/tmpwjujxba_.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae44dd8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae44da82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae44da82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae44da817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwjujxba_                        0x00005654e27be546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae44df77460 __libc_start_main +
    245

    6    tmpwjujxba_                        0x00005654e27be0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var wells = grid\n\
    \    for i in 0..<wells.count {\n        for j in 0..<wells[i].count {\n     \
    \       if wells[i][j] == 1 {\n                wells[i][j] = capacity\n      \
    \      }\n        }\n    }\n    var max_fill = 0\n    while true {\n        max_fill\
    \ = 0\n        for i in 0..<wells.count {\n            for j in 0..<wells[i].count\
    \ {\n                if wells[i][j] > max_fill {\n                    max_fill\
    \ = wells[i][j]\n                }\n            }\n        }\n        if max_fill\
    \ == 0 {\n            break\n        }\n        for i in 0..<wells.count {\n \
    \           for j in 0..<wells[i].count {\n                if wells[i][j] == max_fill\
    \ {\n                    wells[i][j] = 0\n                    if i > 0 {\n   \
    \                     wells[i-1][j] += 1\n                    }\n            \
    \        if i < wells.count - 1 {\n                        wells[i+1][j] += 1\n\
    \                    }\n                    if j > 0 {\n                     \
    \   wells[i][j-1] += 1\n                    }\n                    if j < wells[i].count\
    \ - 1 {\n                        wells[i][j+1] += 1\n                    }\n \
    \               }\n            }\n        }\n        result += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824468
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var row_sum = 0\n        for col in row {\n            row_sum += col\n\
    \        }\n        result += row_sum / capacity\n        if row_sum % capacity\
    \ != 0 {\n            result += 1\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for col in row {\n     \
    \       if col == 1 {\n                max_fill += 1\n            } else {\n \
    \               max_fill = 0\n            }\n            if max_fill == capacity\
    \ {\n                result += 1\n                max_fill = 0\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpbjlclfgz/tmpbjlclfgz.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade88af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade887efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade887ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade887ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbjlclfgz                        0x000055bab6127717 <unavailable> + 5911

    5    libc.so.6                          0x00002ade88ce4460 __libc_start_main +
    245

    6    tmpbjlclfgz                        0x000055bab61270d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for cell in row {\n    \
    \        if cell == 1 {\n                max_fill += 1\n            } else {\n\
    \                if max_fill > 0 {\n                    result += 1\n        \
    \            max_fill = 0\n                }\n            }\n        }\n     \
    \   if max_fill > 0 {\n            result += 1\n        }\n    }\n    return result\
    \ * capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpl52sfdrl/tmpl52sfdrl.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3338366c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b333805db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b333805d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b333805c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl52sfdrl                        0x000055d1b72d9546 <unavailable> + 5446

    5    libc.so.6                          0x00002b3338552460 __libc_start_main +
    245

    6    tmpl52sfdrl                        0x000055d1b72d90d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max_fill = 0\n    for row in grid\
    \ {\n        var fill = 0\n        for well in row {\n            if well == 1\
    \ {\n                fill += 1\n            } else {\n                if fill\
    \ > 0 {\n                    max_fill += 1\n                    fill = 0\n   \
    \             }\n            }\n        }\n        if fill > 0 {\n           \
    \ max_fill += 1\n        }\n    }\n    return max_fill\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp9lpvcjct/tmp9lpvcjct.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae984210c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae983f07b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae983f07988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae983f067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9lpvcjct                        0x0000563f8dae4546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae9843fc460 __libc_start_main +
    245

    6    tmp9lpvcjct                        0x0000563f8dae40d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var wells = grid\n\
    \    for i in 0..<wells.count {\n        for j in 0..<wells[i].count {\n     \
    \       if wells[i][j] == 1 {\n                wells[i][j] = 0\n             \
    \   count += 1\n                var bucket = capacity\n                var k =\
    \ i\n                while k < wells.count && bucket > 0 {\n                 \
    \   if wells[k][j] == 1 {\n                        wells[k][j] = 0\n         \
    \               bucket -= 1\n                    }\n                    k += 1\n\
    \                }\n            }\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpd4z9jupe/tmpd4z9jupe.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0958f82c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0958c79b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0958c79988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0958c787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd4z9jupe                        0x00005636c7607706 <unavailable> + 5894

    5    libc.so.6                          0x00002b095916e460 __libc_start_main +
    245

    6    tmpd4z9jupe                        0x00005636c7607299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        var fill = 0\n        for cell in row {\n    \
    \        if cell == 1 {\n                fill += 1\n            } else {\n   \
    \             if fill > max_fill {\n                    max_fill = fill\n    \
    \            }\n                fill = 0\n            }\n        }\n        if\
    \ fill > max_fill {\n            max_fill = fill\n        }\n        result +=\
    \ max_fill / capacity\n        max_fill = max_fill % capacity\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpvn6zm1j8/tmpvn6zm1j8.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ad140bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ad1102b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ad1102988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ad11017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvn6zm1j8                        0x000055e9b74327a7 <unavailable> + 6055

    5    libc.so.6                          0x00002b9ad15f7460 __libc_start_main +
    245

    6    tmpvn6zm1j8                        0x000055e9b7432169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for cell in row {\n            if cell ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpegzmykbs/tmpegzmykbs.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b816a3afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b816a0a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b816a0a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b816a0a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpegzmykbs                        0x0000559f66565546 <unavailable> + 5446

    5    libc.so.6                          0x00002b816a59b460 __libc_start_main +
    245

    6    tmpegzmykbs                        0x0000559f665650d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                let row\
    \ = i\n                let col = j\n                var row_count = 0\n      \
    \          while row_count < capacity && row + row_count < grid.count {\n    \
    \                if grid[row + row_count][col] == 1 {\n                      \
    \  grid[row + row_count][col] = 0\n                    }\n                   \
    \ row_count += 1\n                }\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp76rkbgzi/tmp76rkbgzi.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5b90eb9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5b90bb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5b90bb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5b90baf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp76rkbgzi                        0x000055a7f85d58d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b5b910a5460 __libc_start_main +
    245

    6    tmp76rkbgzi                        0x000055a7f85d5299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    for row in\
    \ grid {\n        for col in row {\n            if col == 1 {\n              \
    \  result += 1\n            }\n        }\n        if result == max_fill {\n  \
    \          break\n        }\n        result = 0\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdd_n3ds6/tmpdd_n3ds6.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9bbf93c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac9bbc8ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac9bbc8a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9bbc897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdd_n3ds6                        0x000055b504153546 <unavailable> + 5446

    5    libc.so.6                          0x00002ac9bc17f460 __libc_start_main +
    245

    6    tmpdd_n3ds6                        0x000055b5041530d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for col in row {\n     \
    \       if col == 1 {\n                max_fill += 1\n            } else {\n \
    \               if max_fill > 0 {\n                    result += 1\n         \
    \           max_fill = 0\n                }\n            }\n        }\n      \
    \  if max_fill > 0 {\n            result += 1\n        }\n    }\n    return result\
    \ * capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_wlutmvv/tmp_wlutmvv.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1588e0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1588b03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1588b03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1588b027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_wlutmvv                        0x0000559f3f450546 <unavailable> + 5446

    5    libc.so.6                          0x00002b1588ff8460 __libc_start_main +
    245

    6    tmp_wlutmvv                        0x0000559f3f4500d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var wells = grid\n\
    \    for i in 0..<wells.count {\n        for j in 0..<wells[i].count {\n     \
    \       if wells[i][j] == 1 {\n                wells[i][j] = 0\n             \
    \   result += 1\n                var bucket = capacity\n                var k\
    \ = i\n                while bucket > 0 && k >= 0 {\n                    if wells[k][j]\
    \ == 1 {\n                        wells[k][j] = 0\n                        bucket\
    \ -= 1\n                    }\n                    k -= 1\n                }\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjxv1s07i/tmpjxv1s07i.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b22ea0abc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b22e9da2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b22e9da2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b22e9da17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjxv1s07i                        0x000055c9375878d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b22ea297460 __libc_start_main +
    245

    6    tmpjxv1s07i                        0x000055c937587299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for col in row {\n            if col ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpr9zxq02w/tmpr9zxq02w.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba3856e4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba3853dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba3853db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3853da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr9zxq02w                        0x0000563671f8a546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba3858d0460 __libc_start_main +
    245

    6    tmpr9zxq02w                        0x0000563671f8a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for col in row {\n     \
    \       if col == 1 {\n                max_fill += 1\n            } else {\n \
    \               if max_fill > 0 {\n                    result += 1\n         \
    \           max_fill = 0\n                }\n            }\n        }\n      \
    \  if max_fill > 0 {\n            result += 1\n        }\n    }\n    return result\
    \ * capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_wlutmvv/tmp_wlutmvv.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1588e0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1588b03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1588b03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1588b027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_wlutmvv                        0x0000559f3f450546 <unavailable> + 5446

    5    libc.so.6                          0x00002b1588ff8460 __libc_start_main +
    245

    6    tmp_wlutmvv                        0x0000559f3f4500d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var count = 0\n        for col in row {\n            if col == 1 {\n\
    \                count += 1\n            }\n        }\n        result += count\
    \ / capacity\n        if count % capacity != 0 {\n            result += 1\n  \
    \      }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   var row = 0\n    while row < grid.count {\n        var col = 0\n        while\
    \ col < grid[row].count {\n            if grid[row][col] == 1 {\n            \
    \    count += 1\n                var i = row\n                while i < grid.count\
    \ && i - row < capacity {\n                    var j = col\n                 \
    \   while j < grid[i].count && j - col < capacity {\n                        grid[i][j]\
    \ = 0\n                        j += 1\n                    }\n               \
    \     i += 1\n                }\n            }\n            col += 1\n       \
    \ }\n        row += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpl30gseun/tmpl30gseun.swift:69: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b300e3a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b300e098b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b300e098988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b300e0977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl30gseun                        0x000055ff2a550747 <unavailable> + 5959

    5    libc.so.6                          0x00002b300e58d460 __libc_start_main +
    245

    6    tmpl30gseun                        0x000055ff2a550109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_row = 0\n\
    \    var max_col = 0\n    for row in grid {\n        for col in row {\n      \
    \      if col > max_col {\n                max_col = col\n            }\n    \
    \    }\n        max_row += max_col\n        max_col = 0\n    }\n    result = max_row\
    \ / capacity\n    if max_row % capacity > 0 {\n        result += 1\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmptt6tdwdr/tmptt6tdwdr.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6368214c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6367f0bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6367f0b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6367f0a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptt6tdwdr                        0x000055da174925d6 <unavailable> + 5590

    5    libc.so.6                          0x00002b6368400460 __libc_start_main +
    245

    6    tmptt6tdwdr                        0x000055da17492169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for cell in row {\n            if cell ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpegzmykbs/tmpegzmykbs.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b816a3afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b816a0a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b816a0a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b816a0a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpegzmykbs                        0x0000559f66565546 <unavailable> + 5446

    5    libc.so.6                          0x00002b816a59b460 __libc_start_main +
    245

    6    tmpegzmykbs                        0x0000559f665650d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var count = 0\n        for i in row {\n            if i == 1 {\n    \
    \            count += 1\n            }\n        }\n        result += count / capacity\n\
    \        if count % capacity != 0 {\n            result += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var water = 0\n        for well in row {\n            water += well\n\
    \            if water > capacity {\n                result += 1\n            \
    \    water = well\n            }\n        }\n        result += 1\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxz6mce7i/tmpxz6mce7i.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b19e8e25c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b19e8b1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b19e8b1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19e8b1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxz6mce7i                        0x0000555a664b4717 <unavailable> + 5911

    5    libc.so.6                          0x00002b19e9011460 __libc_start_main +
    245

    6    tmpxz6mce7i                        0x0000555a664b40d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                fill_bucket(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpf_s3j8s3.swift:36:17: error: cannot find 'fill_bucket' in scope\n\
    \                fill_bucket(grid: &grid, i: i, j: j, capacity: capacity)\n  \
    \              ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for col in row {\n     \
    \       if col == 1 {\n                max_fill += 1\n            } else {\n \
    \               max_fill = 0\n            }\n            if max_fill == capacity\
    \ {\n                result += 1\n                max_fill = 0\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpbjlclfgz/tmpbjlclfgz.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade88af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade887efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade887ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade887ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbjlclfgz                        0x000055bab6127717 <unavailable> + 5911

    5    libc.so.6                          0x00002ade88ce4460 __libc_start_main +
    245

    6    tmpbjlclfgz                        0x000055bab61270d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                grid[i][j]\
    \ = 0\n                var k = i + 1\n                while k < grid.count &&\
    \ capacity > 0 {\n                    if grid[k][j] == 1 {\n                 \
    \       grid[k][j] = 0\n                        capacity -= 1\n              \
    \      }\n                    k += 1\n                }\n            }\n     \
    \   }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpsa_fceuc.swift:41:34: error: left side of mutating operator isn't\
    \ mutable: 'capacity' is a 'let' constant\n                        capacity -=\
    \ 1\n                        ~~~~~~~~ ^\n"
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    for row in grid {\n        for cell in row {\n            if cell ==\
    \ 1 {\n                fill += 1\n            }\n        }\n        if fill ==\
    \ max_fill {\n            break\n        }\n        result += 1\n        fill\
    \ = 0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpegzmykbs/tmpegzmykbs.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b816a3afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b816a0a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b816a0a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b816a0a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpegzmykbs                        0x0000559f66565546 <unavailable> + 5446

    5    libc.so.6                          0x00002b816a59b460 __libc_start_main +
    245

    6    tmpegzmykbs                        0x0000559f665650d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_height = 0\n\
    \    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n       \
    \     if grid[i][j] == 1 {\n                max_height = max(max_height, i)\n\
    \            }\n        }\n    }\n    for i in 0...max_height {\n        var filled\
    \ = 0\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                filled += 1\n            }\n        }\n        if filled > 0\
    \ {\n            result += 1\n        }\n        if filled > capacity {\n    \
    \        result += filled - capacity\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp83lfdyiv/tmp83lfdyiv.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b627cfecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b627cce3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b627cce3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b627cce27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp83lfdyiv                        0x000055c6eb2c89b7 <unavailable> + 6583

    5    libc.so.6                          0x00002b627d1d8460 __libc_start_main +
    245

    6    tmp83lfdyiv                        0x000055c6eb2c8379 <unavailable> + 4985

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn7f9m03b/tmpn7f9m03b.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25f3cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25f39edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25f39ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25f39ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7f9m03b                        0x000055932be713d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b25f3ee2460 __libc_start_main +
    245

    6    tmpn7f9m03b                        0x000055932be70f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var max_fill = 0\n        var max_fill_index = -1\n\
    \        for i in 0..<grid.count {\n            var fill = 0\n            for\
    \ j in 0..<grid[i].count {\n                if grid[i][j] == 1 {\n           \
    \         fill += 1\n                }\n            }\n            if fill > max_fill\
    \ {\n                max_fill = fill\n                max_fill_index = i\n   \
    \         }\n        }\n        if max_fill == 0 {\n            break\n      \
    \  }\n        count += 1\n        for j in 0..<grid[max_fill_index].count {\n\
    \            if grid[max_fill_index][j] == 1 {\n                grid[max_fill_index][j]\
    \ = 0\n                if max_fill > capacity {\n                    max_fill\
    \ -= capacity\n                } else {\n                    max_fill = 0\n  \
    \              }\n            }\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpg9cveb3i/tmpg9cveb3i.swift:78: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae5501b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae54feb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae54feb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae54feaf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg9cveb3i                        0x000055dbbd327706 <unavailable> + 5894

    5    libc.so.6                          0x00002ae5503a5460 __libc_start_main +
    245

    6    tmpg9cveb3i                        0x000055dbbd327299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659824464
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for i in 0..<grid.count {\n        max_fill = 0\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                max_fill += 1\n       \
    \     }\n        }\n        result += max_fill / capacity\n        if max_fill\
    \ % capacity != 0 {\n            result += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for well in row {\n    \
    \        if well == 1 {\n                max_fill += 1\n            } else {\n\
    \                if max_fill > 0 {\n                    result += 1\n        \
    \            max_fill = 0\n                }\n            }\n        }\n     \
    \   if max_fill > 0 {\n            result += 1\n        }\n    }\n    return result\
    \ * capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4877t_a9/tmp4877t_a9.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba4d1ab2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba4d17a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba4d17a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba4d17a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4877t_a9                        0x000055c65158c546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba4d1c9e460 __libc_start_main +
    245

    6    tmp4877t_a9                        0x000055c65158c0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824464
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                fill_bucket(grid:\
    \ &grid, capacity: capacity, i: i, j: j)\n            }\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyp3qtjog.swift:36:17: error: cannot find 'fill_bucket' in scope\n\
    \                fill_bucket(grid: &grid, capacity: capacity, i: i, j: j)\n  \
    \              ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var current_fill\
    \ = 0\n    while current_fill < max_fill {\n        for row in grid {\n      \
    \      for cell in row {\n                if cell == 1 {\n                   \
    \ current_fill += 1\n                }\n            }\n            if current_fill\
    \ < max_fill {\n                result += 1\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp67j0iwb4/tmp67j0iwb4.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab3e8f49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab3e8c40b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab3e8c40988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab3e8c3f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp67j0iwb4                        0x00005617a4757546 <unavailable> + 5446

    5    libc.so.6                          0x00002ab3e9135460 __libc_start_main +
    245

    6    tmp67j0iwb4                        0x00005617a47570d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var count = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    for row in\
    \ grid {\n        for col in row {\n            if col == 1 {\n              \
    \  count += 1\n            }\n        }\n        if count == max_fill {\n    \
    \        return count\n        }\n        count = 0\n    }\n    return capacity\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp744vor64/tmp744vor64.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad4e1177c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad4e0e6eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad4e0e6e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad4e0e6d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp744vor64                        0x0000556484cc9546 <unavailable> + 5446

    5    libc.so.6                          0x00002ad4e1363460 __libc_start_main +
    245

    6    tmp744vor64                        0x0000556484cc90d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824464
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for col in row {\n     \
    \       if col == 1 {\n                max_fill += 1\n            } else {\n \
    \               max_fill = 0\n            }\n            if max_fill == capacity\
    \ {\n                result += 1\n                max_fill = 0\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpbjlclfgz/tmpbjlclfgz.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade88af8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade887efb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade887ef988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade887ee7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbjlclfgz                        0x000055bab6127717 <unavailable> + 5911

    5    libc.so.6                          0x00002ade88ce4460 __libc_start_main +
    245

    6    tmpbjlclfgz                        0x000055bab61270d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var fill_count = 0\n    var max_fill =\
    \ 0\n    for row in grid {\n        for col in row {\n            if col == 1\
    \ {\n                fill_count += 1\n            }\n        }\n        max_fill\
    \ = max(max_fill, fill_count)\n        fill_count = 0\n    }\n    return max_fill\
    \ / capacity + (max_fill % capacity > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpq5pixtbo/tmpq5pixtbo.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b030037dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0300074b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0300074988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b03000737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq5pixtbo                        0x000055833e334676 <unavailable> + 5750

    5    libc.so.6                          0x00002b0300569460 __libc_start_main +
    245

    6    tmpq5pixtbo                        0x000055833e334209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1659824464
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max_fill = 0\n    for row in grid\
    \ {\n        var fill = 0\n        for well in row {\n            if well == 1\
    \ {\n                fill += 1\n            } else {\n                if fill\
    \ > 0 {\n                    max_fill += 1\n                    fill = 0\n   \
    \             }\n            }\n        }\n        if fill > 0 {\n           \
    \ max_fill += 1\n        }\n    }\n    return max_fill * capacity\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwjujxba_/tmpwjujxba_.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae44dd8bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae44da82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae44da82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae44da817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwjujxba_                        0x00005654e27be546 <unavailable> + 5446

    5    libc.so.6                          0x00002ae44df77460 __libc_start_main +
    245

    6    tmpwjujxba_                        0x00005654e27be0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var water = 0\n        for well in row {\n            water += well\n\
    \            if water == capacity {\n                result += 1\n           \
    \     water = 0\n            }\n        }\n        if water > 0 {\n          \
    \  result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_row = 0\n\
    \    for row in grid {\n        max_row = max(max_row, row.reduce(0, +))\n   \
    \ }\n    for _ in 0..<max_row {\n        result += 1\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] >\
    \ 0 {\n                    grid[i][j] -= 1\n                }\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmps3d5hy6t.swift:40:32: error: left side of mutating operator isn't\
    \ mutable: 'grid' is a 'let' constant\n                    grid[i][j] -= 1\n \
    \                   ~~~~       ^\n"
  stdout: ''
  timestamp: 1659824464
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var max_fill = 0\n    for row in grid\
    \ {\n        var fill = 0\n        for well in row {\n            fill += well\n\
    \            if fill > capacity {\n                max_fill += 1\n           \
    \     fill = well\n            }\n        }\n        max_fill += 1\n    }\n  \
    \  return max_fill\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpvqd4umrv/tmpvqd4umrv.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b138a23ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1389f35b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1389f35988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1389f347b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvqd4umrv                        0x00005638ecd1a717 <unavailable> + 5911

    5    libc.so.6                          0x00002b138a42a460 __libc_start_main +
    245

    6    tmpvqd4umrv                        0x00005638ecd1a0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824464
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var row_max = [Int](repeating:\
    \ 0, count: grid.count)\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                row_max[i] = j\n      \
    \      }\n        }\n    }\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                var min_capacity = capacity\n\
    \                for k in 0..<i {\n                    min_capacity = min(min_capacity,\
    \ row_max[k] - j)\n                }\n                result += min_capacity\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxud58p9p/tmpxud58p9p.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af879894c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af87958bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af87958b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af87958a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxud58p9p                        0x000055953b84a7a6 <unavailable> + 6054

    5    libc.so.6                          0x00002af879a80460 __libc_start_main +
    245

    6    tmpxud58p9p                        0x000055953b84a339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824464
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpn7f9m03b/tmpn7f9m03b.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b25f3cf6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b25f39edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b25f39ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b25f39ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn7f9m03b                        0x000055932be713d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b25f3ee2460 __libc_start_main +
    245

    6    tmpn7f9m03b                        0x000055932be70f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var current_fill\
    \ = 0\n    while current_fill < max_fill {\n        for row in grid {\n      \
    \      for col in row {\n                if col == 1 {\n                    current_fill\
    \ += 1\n                    if current_fill == max_fill {\n                  \
    \      return result\n                    }\n                }\n            }\n\
    \            result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpz10vz90c/tmpz10vz90c.swift:69: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b298344bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2983142b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2983142988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b29831417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz10vz90c                        0x000055650bd34546 <unavailable> + 5446

    5    libc.so.6                          0x00002b2983637460 __libc_start_main +
    245

    6    tmpz10vz90c                        0x000055650bd340d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824464
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        var fill = 0\n        for col in row {\n     \
    \       if col == 1 {\n                fill += 1\n            } else {\n     \
    \           if fill > max_fill {\n                    max_fill = fill\n      \
    \          }\n                fill = 0\n            }\n        }\n        if fill\
    \ > max_fill {\n            max_fill = fill\n        }\n        result += max_fill\
    \ / capacity\n        max_fill = max_fill % capacity\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpgvo8yz4q/tmpgvo8yz4q.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f6adc4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f6aabbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f6aabb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f6aaba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgvo8yz4q                        0x00005588df1967a7 <unavailable> + 6055

    5    libc.so.6                          0x00002b2f6afb0460 __libc_start_main +
    245

    6    tmpgvo8yz4q                        0x00005588df196169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659824464
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for col in row {\n            if col == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    while max_fill\
    \ > 0 {\n        result += 1\n        max_fill -= capacity\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp9k6m2vs6/tmp9k6m2vs6.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1b7cc75c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1b7c96cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1b7c96c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1b7c96b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9k6m2vs6                        0x0000561db89adb44 <unavailable> + 6980

    5    libc.so.6                          0x00002b1b7ce61460 __libc_start_main +
    245

    6    tmp9k6m2vs6                        0x0000561db89ad0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824464
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for row in 0..<grid.count {\n        for col in 0..<grid[row].count {\n  \
    \          if grid[row][col] == 1 {\n                count += 1\n            \
    \    fill(grid: &grid, row: row, col: col, capacity: capacity)\n            }\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpoe5nv4a2.swift:36:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, row: row, col: col, capacity: capacity)\n     \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1659824464
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n        \
    \    if grid[i][j] == 1 {\n                count += 1\n                fill(grid:\
    \ &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n    }\n  \
    \  return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp2f4geop2.swift:36:17: error: cannot find 'fill' in scope\n    \
    \            fill(grid: &grid, i: i, j: j, capacity: capacity)\n             \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1659824462
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    for row in grid {\n\
    \        var water = 0\n        for cell in row {\n            water += cell\n\
    \            if water == capacity {\n                result += 1\n           \
    \     water = 0\n            }\n        }\n        if water > 0 {\n          \
    \  result += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824462
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        max_fill = 0\n        for col in row {\n     \
    \       if col == 1 {\n                max_fill += 1\n            } else {\n \
    \               if max_fill > 0 {\n                    result += 1\n         \
    \           max_fill = 0\n                }\n            }\n        }\n      \
    \  if max_fill > 0 {\n            result += 1\n        }\n    }\n    return result\
    \ * capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_wlutmvv/tmp_wlutmvv.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1588e0cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1588b03b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1588b03988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1588b027b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_wlutmvv                        0x0000559f3f450546 <unavailable> + 5446

    5    libc.so.6                          0x00002b1588ff8460 __libc_start_main +
    245

    6    tmp_wlutmvv                        0x0000559f3f4500d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659824463
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]]\n/// bucket_capacity : 1\n/// Output: 6\n/// Example 2:\n/// Input:\
    \ \n/// grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity\
    \ : 2\n/// Output: 5\n/// Example 3:\n/// Input: \n/// grid : [[0,0,0], [0,0,0]]\n\
    /// bucket_capacity : 5\n/// Output: 0\n/// Constraints:\n/// * all wells have\
    \ the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <= grid[:,1].length\
    \ <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n    var grid = grid\n    var count = 0\n \
    \   while true {\n        var filled = false\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 1 {\n                    filled = true\n                    grid[i][j] = 0\n\
    \                    if i > 0 {\n                        grid[i-1][j] = min(grid[i-1][j]\
    \ + capacity, 1)\n                    }\n                    if i < grid.count\
    \ - 1 {\n                        grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n\
    \                    }\n                    if j > 0 {\n                     \
    \   grid[i][j-1] = min(grid[i][j-1] + capacity, 1)\n                    }\n  \
    \                  if j < grid[i].count - 1 {\n                        grid[i][j+1]\
    \ = min(grid[i][j+1] + capacity, 1)\n                    }\n                }\n\
    \            }\n        }\n        if !filled {\n            break\n        }\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659824467
