language: swift
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let\
    \ x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return (n * modp(n\
    \ - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfjos7o0n.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmpfjos7o0n.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmpfjos7o0n.swift:21:21: error: missing argument label 'n:' in call\n\
    \    return (n * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var n = n\n    var p = p\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afae0907c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afae05fe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afae05fe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afae05fe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afae05fdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw8a75xda                        0x00005574a5ab5730 <unavailable> + 5936

    6    tmpw8a75xda                        0x00005574a5ab51e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afae0af3460 __libc_start_main +
    245

    8    tmpw8a75xda                        0x00005574a5ab4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var res = 1\n    while n > 0 {\n        if n % 2 == 1\
    \ {\n            res = (res * n) % p\n        }\n        n = n / 2\n    }\n  \
    \  return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpb_ucbqsd/tmpb_ucbqsd.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9c4f4ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9c4c41b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9c4c41988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9c4c407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb_ucbqsd                        0x000055e6c38912cd <unavailable> + 4813

    5    libc.so.6                          0x00002ad9c5136460 __libc_start_main +
    245

    6    tmpb_ucbqsd                        0x000055e6c3890ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    if n < 0 {\n        n = -n\n    }\n   \
    \ if p < 0 {\n        p = -p\n    }\n    var result = 1\n    for _ in 0..<n {\n\
    \        result = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1, p: p) * modp(n,\
    \ p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppdoxsbd5.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmppdoxsbd5.swift:18:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmppdoxsbd5.swift:20:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * modp(n, p: p) % p\n               ^\n          \
    \      n: \n/tmp/tmppdoxsbd5.swift:20:34: error: missing argument label 'n:' in\
    \ call\n    return modp(n-1, p: p) * modp(n, p: p) % p\n                     \
    \            ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n & 1 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n >> 1\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b69145a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6914298561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6914298286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b691429813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6914297bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_b922ngj                        0x00005579c4d7869d <unavailable> + 5789

    6    tmp_b922ngj                        0x00005579c4d781e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b691478d460 __libc_start_main +
    245

    8    tmp_b922ngj                        0x00005579c4d77ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var n = n\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpfi8jd9co/tmpfi8jd9co.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae951c8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae951986b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae951986988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9519857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfi8jd9co                        0x000055c0083772cd <unavailable> + 4813

    5    libc.so.6                          0x00002ae951e7b460 __libc_start_main +
    245

    6    tmpfi8jd9co                        0x000055c008376ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var r = 1\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            r = (r * n) % p\n        }\n        n = n / 2\n    }\n    return\
    \ r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmps0a8kcu4/tmps0a8kcu4.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5bcc52c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5bc949b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5bc949988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5bc9487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps0a8kcu4                        0x000055fa95e542cd <unavailable> + 4813

    5    libc.so.6                          0x00002ab5bce3e460 __libc_start_main +
    245

    6    tmps0a8kcu4                        0x000055fa95e53ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return\
    \ n % p\n    }\n    var n = n\n    var result = 1\n    while n > 0 {\n       \
    \ if n % 2 == 1 {\n            result = (result * n) % p\n        }\n        n\
    \ = n / 2\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp9rf9_9ku/tmp9rf9_9ku.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b55a92d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b55a8fcbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b55a8fcb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b55a8fca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9rf9_9ku                        0x00005565088a32cd <unavailable> + 4813

    5    libc.so.6                          0x00002b55a94c0460 __libc_start_main +
    245

    6    tmp9rf9_9ku                        0x00005565088a2ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    n %= p\n    while n\
    \ > 0 {\n        if n & 1 == 1 {\n            result = (result * n) % p\n    \
    \    }\n        n = n >> 1\n        n = (n * n) % p\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return\
    \ n % p\n    }\n    var res = modp(n: n / 2, p: p)\n    res = (res * res) % p\n\
    \    if n % 2 == 1 {\n        res = (res * n) % p\n    }\n    return res\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp4_ag84yk/tmp4_ag84yk.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaea42b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaea3fb0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaea3fb0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaea3faf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4_ag84yk                        0x0000560c911422cd <unavailable> + 4813

    5    libc.so.6                          0x00002aaea44a5460 __libc_start_main +
    245

    6    tmp4_ag84yk                        0x0000560c91141ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    } else if n % 2 == 0 {\n        let\
    \ m = modp(n / 2, p: p)\n        return (m * m) % p\n    } else {\n        return\
    \ (modp(n - 1, p: p) * n) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpoeuva0ym.swift:17:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmpoeuva0ym.swift:18:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m * m) % p\n              \
    \    ^\n/tmp/tmpoeuva0ym.swift:20:21: error: missing argument label 'n:' in call\n\
    \        return (modp(n - 1, p: p) * n) % p\n                    ^\n         \
    \            n: \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let\
    \ m = modp(n / 2, p: p)\n        return (m * m) % p\n    }\n    return (modp(n\
    \ - 1, p: p) * n) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3yd5mp1e.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp3yd5mp1e.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m * m) % p\n              \
    \    ^\n/tmp/tmp3yd5mp1e.swift:21:17: error: missing argument label 'n:' in call\n\
    \    return (modp(n - 1, p: p) * n) % p\n                ^\n                 n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let\
    \ m = modp(n / 2, p: p)\n        return (m * m) % p\n    }\n    return (modp(n\
    \ - 1, p: p) * n) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3yd5mp1e.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp3yd5mp1e.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m * m) % p\n              \
    \    ^\n/tmp/tmp3yd5mp1e.swift:21:17: error: missing argument label 'n:' in call\n\
    \    return (modp(n - 1, p: p) * n) % p\n                ^\n                 n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var r = 1\n    var b = n\n    var e = p - 2\n    while e > 0 {\n    \
    \    if e % 2 == 1 {\n            r = (r * b) % p\n        }\n        e = e /\
    \ 2\n        b = (b * b) % p\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp6746besb/tmp6746besb.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad85a8d7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad85a5ceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad85a5ce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad85a5cd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6746besb                        0x000055cb2dda424d <unavailable> + 4685

    5    libc.so.6                          0x00002ad85aac3460 __libc_start_main +
    245

    6    tmp6746besb                        0x000055cb2dda3ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        n = (n * n) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return\
    \ n % p\n    }\n    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n:\
    \ n / 2, p: p) % p\n    }\n    return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpo7aay2dg/tmpo7aay2dg.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b013f773c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b013f46ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b013f46a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b013f4697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo7aay2dg                        0x00005615c39c324d <unavailable> + 4685

    5    libc.so.6                          0x00002b013f95f460 __libc_start_main +
    245

    6    tmpo7aay2dg                        0x00005615c39c2ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n-1, p: p) * modp(n,\
    \ p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppdoxsbd5.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmppdoxsbd5.swift:18:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmppdoxsbd5.swift:20:16: error: missing argument label 'n:' in call\n\
    \    return modp(n-1, p: p) * modp(n, p: p) % p\n               ^\n          \
    \      n: \n/tmp/tmppdoxsbd5.swift:20:34: error: missing argument label 'n:' in\
    \ call\n    return modp(n-1, p: p) * modp(n, p: p) % p\n                     \
    \            ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * p) % 101\n        }\n        n = n / 2\n\
    \        p = (p * p) % 101\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpawxxtt1z.swift:21:9: error: cannot assign to value: 'p' is a 'let'\
    \ constant\n        p = (p * p) % 101\n        ^\n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let\
    \ m = modp(n / 2, p: p)\n        return (m * m) % p\n    }\n    return (n * modp(n\
    \ - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpd52eu328.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmpd52eu328.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m * m) % p\n              \
    \    ^\n/tmp/tmpd52eu328.swift:21:21: error: missing argument label 'n:' in call\n\
    \    return (n * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let\
    \ x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return (modp(n\
    \ - 1, p: p) * n) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpi42eo9_a.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmpi42eo9_a.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmpi42eo9_a.swift:21:17: error: missing argument label 'n:' in call\n\
    \    return (modp(n - 1, p: p) * n) % p\n                ^\n                 n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var res = 1\n    while n > 0 {\n      \
    \  if n % 2 == 1 {\n            res = (res * n) % p\n        }\n        n = n\
    \ / 2\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b5e7992bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5e79622561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b5e79622286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b5e7962213c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b5e79621bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp8u08d3sa                        0x000055bace70d730 <unavailable> + 5936

    6    tmp8u08d3sa                        0x000055bace70d1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b5e79b17460 __libc_start_main +
    245

    8    tmp8u08d3sa                        0x000055bace70cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var n = n\n    var p = p\n    while n > 0 {\n   \
    \     if n & 1 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n >> 1\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b91d8cffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91d89f6561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b91d89f6286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b91d89f613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b91d89f5bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpt1s4r98c                        0x0000561088a0a69d <unavailable> + 5789

    6    tmpt1s4r98c                        0x0000561088a0a1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b91d8eeb460 __libc_start_main +
    245

    8    tmpt1s4r98c                        0x0000561088a09ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var n = n\n    var p = p\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afae0907c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afae05fe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afae05fe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afae05fe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afae05fdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw8a75xda                        0x00005574a5ab5730 <unavailable> + 5936

    6    tmpw8a75xda                        0x00005574a5ab51e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afae0af3460 __libc_start_main +
    245

    8    tmpw8a75xda                        0x00005574a5ab4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        n = (n * n) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n & 1 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n >> 1\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b69145a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6914298561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6914298286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b691429813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6914297bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_b922ngj                        0x00005579c4d7869d <unavailable> + 5789

    6    tmp_b922ngj                        0x00005579c4d781e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b691478d460 __libc_start_main +
    245

    8    tmp_b922ngj                        0x00005579c4d77ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n/2, p: p) * modp(n/2,\
    \ p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0x0_wo4a.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp0x0_wo4a.swift:18:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp0x0_wo4a.swift:20:16: error: missing argument label 'n:' in call\n\
    \    return modp(n/2, p: p) * modp(n/2, p: p) * 2 % p\n               ^\n    \
    \            n: \n/tmp/tmp0x0_wo4a.swift:20:34: error: missing argument label\
    \ 'n:' in call\n    return modp(n/2, p: p) * modp(n/2, p: p) * 2 % p\n       \
    \                          ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    n %= p\n    while n\
    \ > 0 {\n        if n & 1 == 1 {\n            result = (result * n) % p\n    \
    \    }\n        n = n >> 1\n        n = (n * n) % p\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        n = (n * n) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var n = n\n    var p = p\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afae0907c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afae05fe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afae05fe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afae05fe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afae05fdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw8a75xda                        0x00005574a5ab5730 <unavailable> + 5936

    6    tmpw8a75xda                        0x00005574a5ab51e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afae0af3460 __libc_start_main +
    245

    8    tmpw8a75xda                        0x00005574a5ab4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let\
    \ t = modp(n / 2, p: p)\n        return (t * t) % p\n    }\n    return (modp(n\
    \ - 1, p: p) * n) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_n4e2d23.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let t = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp_n4e2d23.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (t * t) % p\n              \
    \    ^\n/tmp/tmp_n4e2d23.swift:21:17: error: missing argument label 'n:' in call\n\
    \    return (modp(n - 1, p: p) * n) % p\n                ^\n                 n:\
    \ \n"
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var n = n\n    var p = p\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afae0907c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afae05fe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afae05fe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afae05fe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afae05fdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw8a75xda                        0x00005574a5ab5730 <unavailable> + 5936

    6    tmpw8a75xda                        0x00005574a5ab51e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afae0af3460 __libc_start_main +
    245

    8    tmpw8a75xda                        0x00005574a5ab4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let\
    \ m = modp(n / 2, p: p)\n        return (m * m) % p\n    }\n    return (modp(n\
    \ - 1, p: p) * n) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3yd5mp1e.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp3yd5mp1e.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m * m) % p\n              \
    \    ^\n/tmp/tmp3yd5mp1e.swift:21:17: error: missing argument label 'n:' in call\n\
    \    return (modp(n - 1, p: p) * n) % p\n                ^\n                 n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var n = n\n    var p = p\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afae0907c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afae05fe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afae05fe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afae05fe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afae05fdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw8a75xda                        0x00005574a5ab5730 <unavailable> + 5936

    6    tmpw8a75xda                        0x00005574a5ab51e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afae0af3460 __libc_start_main +
    245

    8    tmpw8a75xda                        0x00005574a5ab4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n/2, p: p) * modp(n/2,\
    \ p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0x0_wo4a.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp0x0_wo4a.swift:18:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp0x0_wo4a.swift:20:16: error: missing argument label 'n:' in call\n\
    \    return modp(n/2, p: p) * modp(n/2, p: p) * 2 % p\n               ^\n    \
    \            n: \n/tmp/tmp0x0_wo4a.swift:20:34: error: missing argument label\
    \ 'n:' in call\n    return modp(n/2, p: p) * modp(n/2, p: p) * 2 % p\n       \
    \                          ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var res = 1\n    var n = n\n    var p = p\n    while n > 0 {\n      \
    \  if n % 2 == 1 {\n            res = (res * n) % p\n        }\n        n = n\
    \ / 2\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ae3fdf74c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae3fdc6b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae3fdc6b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae3fdc6b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae3fdc6abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmps_p5trab                        0x0000563412002730 <unavailable> + 5936

    6    tmps_p5trab                        0x00005634120021e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ae3fe160460 __libc_start_main +
    245

    8    tmps_p5trab                        0x0000563412001ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let\
    \ x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return (modp(n\
    \ - 1, p: p) * n) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpi42eo9_a.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmpi42eo9_a.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmpi42eo9_a.swift:21:17: error: missing argument label 'n:' in call\n\
    \    return (modp(n - 1, p: p) * n) % p\n                ^\n                 n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n/2, p: p) * modp(n/2,\
    \ p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0x0_wo4a.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp0x0_wo4a.swift:18:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp0x0_wo4a.swift:20:16: error: missing argument label 'n:' in call\n\
    \    return modp(n/2, p: p) * modp(n/2, p: p) * 2 % p\n               ^\n    \
    \            n: \n/tmp/tmp0x0_wo4a.swift:20:34: error: missing argument label\
    \ 'n:' in call\n    return modp(n/2, p: p) * modp(n/2, p: p) * 2 % p\n       \
    \                          ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n & 1 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n >> 1\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b69145a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6914298561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6914298286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b691429813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6914297bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_b922ngj                        0x00005579c4d7869d <unavailable> + 5789

    6    tmp_b922ngj                        0x00005579c4d781e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b691478d460 __libc_start_main +
    245

    8    tmp_b922ngj                        0x00005579c4d77ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var r = 1\n    while n > 0 {\n        if n & 1 == 1 {\n\
    \            r = (r * n) % p\n        }\n        n = n >> 1\n    }\n    return\
    \ r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpvieflbxy/tmpvieflbxy.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1710be9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17108e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17108e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17108df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvieflbxy                        0x00005614a46b02cd <unavailable> + 4813

    5    libc.so.6                          0x00002b1710dd5460 __libc_start_main +
    245

    6    tmpvieflbxy                        0x00005614a46afef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n - 1, p: p) * modp(n: n, p: p)\
    \ % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * modp(n, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpujd4esdn.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmpujd4esdn.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmpujd4esdn.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * modp(n, p: p) % p\n\
    \               ^\n                n: \n/tmp/tmpujd4esdn.swift:20:36: error: missing\
    \ argument label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p)\
    \ * modp(n, p: p) % p\n                                   ^\n                \
    \                    n: \n/tmp/tmpujd4esdn.swift:20:56: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * modp(n,\
    \ p: p) % p\n                                                       ^\n      \
    \                                                  n: \n"
  stdout: ''
  timestamp: 1660014324
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    for _ in 0..<n {\n        result = (result * 2) %\
    \ p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    var result = 1\n    var n =\
    \ n\n    var p = p\n    while n > 0 {\n        if n & 1 == 1 {\n            result\
    \ = (result * n) % p\n        }\n        n = n >> 1\n        p = (p * p) % p\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b129d0f9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b129cdf0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b129cdf0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b129cdf013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b129cdefbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpyhbkzo1z                        0x000055be0d8116b9 <unavailable> + 5817

    6    tmpyhbkzo1z                        0x000055be0d8111e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b129d2e5460 __libc_start_main +
    245

    8    tmpyhbkzo1z                        0x000055be0d810ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var res = 1\n    var n = n\n    var p = p\n    while n > 0 {\n      \
    \  if n % 2 == 1 {\n            res = (res * n) % p\n        }\n        n = n\
    \ / 2\n        p = (p * p) % p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002ae3fdf74c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae3fdc6b561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae3fdc6b286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae3fdc6b13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae3fdc6abb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmps_p5trab                        0x0000563412002730 <unavailable> + 5936

    6    tmps_p5trab                        0x00005634120021e0 <unavailable> + 4576

    7    libc.so.6                          0x00002ae3fe160460 __libc_start_main +
    245

    8    tmps_p5trab                        0x0000563412001ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    } else if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    } else {\n        return modp(n\
    \ / 2, p: p) * modp(n / 2, p: p) * 2 % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_u_caph4.swift:17:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp_u_caph4.swift:17:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp_u_caph4.swift:19:20: error: missing argument label 'n:' in\
    \ call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n       \
    \            ^\n                    n: \n/tmp/tmp_u_caph4.swift:19:40: error:\
    \ missing argument label 'n:' in call\n        return modp(n / 2, p: p) * modp(n\
    \ / 2, p: p) * 2 % p\n                                       ^\n             \
    \                           n: \n"
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n & 1 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n >> 1\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b69145a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6914298561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6914298286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b691429813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6914297bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_b922ngj                        0x00005579c4d7869d <unavailable> + 5789

    6    tmp_b922ngj                        0x00005579c4d781e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b691478d460 __libc_start_main +
    245

    8    tmp_b922ngj                        0x00005579c4d77ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    if n < 0 {\n        n = n + p\n    }\n\
    \    if n == 0 {\n        return 1\n    }\n    if n == 1 {\n        return n\n\
    \    }\n    var result = 1\n    var i = 0\n    while i < n {\n        result =\
    \ (result * 2) % p\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var n = n\n    var p = p\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afae0907c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afae05fe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afae05fe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afae05fe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afae05fdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw8a75xda                        0x00005574a5ab5730 <unavailable> + 5936

    6    tmpw8a75xda                        0x00005574a5ab51e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afae0af3460 __libc_start_main +
    245

    8    tmpw8a75xda                        0x00005574a5ab4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let\
    \ m = modp(n/2, p: p)\n        return (m * m) % p\n    }\n    return (modp(n-1,\
    \ p: p) * n) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp962orwfe.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n/2, p: p)\n                    ^\n                    \
    \ n: \n/tmp/tmp962orwfe.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m * m) % p\n              \
    \    ^\n/tmp/tmp962orwfe.swift:21:17: error: missing argument label 'n:' in call\n\
    \    return (modp(n-1, p: p) * n) % p\n                ^\n                 n:\
    \ \n"
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        n = (n * n) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let\
    \ m = modp(n / 2, p: p)\n        return (m * m) % p\n    }\n    return (modp(n\
    \ - 1, p: p) * n) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3yd5mp1e.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp3yd5mp1e.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m * m) % p\n              \
    \    ^\n/tmp/tmp3yd5mp1e.swift:21:17: error: missing argument label 'n:' in call\n\
    \    return (modp(n - 1, p: p) * n) % p\n                ^\n                 n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n & 1 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n >> 1\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002b69145a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6914298561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b6914298286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b691429813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b6914297bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp_b922ngj                        0x00005579c4d7869d <unavailable> + 5789

    6    tmp_b922ngj                        0x00005579c4d781e0 <unavailable> + 4576

    7    libc.so.6                          0x00002b691478d460 __libc_start_main +
    245

    8    tmp_b922ngj                        0x00005579c4d77ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    if n < 0 {\n        n = -n\n    }\n   \
    \ var result = 1\n    for _ in 0..<n {\n        result = (result * 2) % p\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        n = (n * n) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    if n < 0 {\n        n = p - (-n % p)\n\
    \    }\n    if n >= p {\n        n %= p\n    }\n    if n == 0 {\n        return\
    \ 1\n    }\n    var result = 1\n    for _ in 0..<n {\n        result = (result\
    \ * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp9ggc8e7b/tmp9ggc8e7b.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b571071ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5710411b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5710411988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57104107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9ggc8e7b                        0x0000555c74bea3bd <unavailable> + 5053

    5    libc.so.6                          0x00002b5710906460 __libc_start_main +
    245

    6    tmp9ggc8e7b                        0x0000555c74be9fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    for _ in 0..<n {\n        result = (result * 2) %\
    \ p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var n = n\n    var p = p\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afae0907c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afae05fe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afae05fe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afae05fe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afae05fdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw8a75xda                        0x00005574a5ab5730 <unavailable> + 5936

    6    tmpw8a75xda                        0x00005574a5ab51e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afae0af3460 __libc_start_main +
    245

    8    tmpw8a75xda                        0x00005574a5ab4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var n = n\n    var p = p\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afae0907c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afae05fe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afae05fe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afae05fe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afae05fdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw8a75xda                        0x00005574a5ab5730 <unavailable> + 5936

    6    tmpw8a75xda                        0x00005574a5ab51e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afae0af3460 __libc_start_main +
    245

    8    tmpw8a75xda                        0x00005574a5ab4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var r = 1\n    while n > 0 {\n        if n % 2 == 1 {\n\
    \            r = (r * n) % p\n        }\n        n = n / 2\n    }\n    return\
    \ r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmps0a8kcu4/tmps0a8kcu4.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5bcc52c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5bc949b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5bc949988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5bc9487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps0a8kcu4                        0x000055fa95e542cd <unavailable> + 4813

    5    libc.so.6                          0x00002ab5bce3e460 __libc_start_main +
    245

    6    tmps0a8kcu4                        0x000055fa95e53ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        n = (n * n) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var base = n\n    var exponent = p\n    while exponent\
    \ > 0 {\n        if exponent % 2 == 1 {\n            result = (result * base)\
    \ % p\n        }\n        exponent = exponent >> 1\n        base = (base * base)\
    \ % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpp6h792q7/tmpp6h792q7.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59bfc38c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59bf92fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59bf92f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59bf92e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp6h792q7                        0x000055c930c652cd <unavailable> + 4813

    5    libc.so.6                          0x00002b59bfe24460 __libc_start_main +
    245

    6    tmpp6h792q7                        0x000055c930c64ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    for _ in 0..<n {\n        result = (result * 2) %\
    \ p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n & 1 == 1 {\n            result = (result * p) % MODULO\n        }\n\
    \        n = n >> 1\n        p = (p * p) % MODULO\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpy14p3gov.swift:19:37: error: cannot find 'MODULO' in scope\n  \
    \          result = (result * p) % MODULO\n                                  \
    \  ^~~~~~\n/tmp/tmpy14p3gov.swift:22:23: error: cannot find 'MODULO' in scope\n\
    \        p = (p * p) % MODULO\n                      ^~~~~~\n"
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var n = n\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpfi8jd9co/tmpfi8jd9co.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae951c8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae951986b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae951986988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9519857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfi8jd9co                        0x000055c0083772cd <unavailable> + 4813

    5    libc.so.6                          0x00002ae951e7b460 __libc_start_main +
    245

    6    tmpfi8jd9co                        0x000055c008376ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let\
    \ m = modp(n / 2, p: p)\n        return (m * m) % p\n    }\n    return (modp(n\
    \ - 1, p: p) * n) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3yd5mp1e.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let m = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmp3yd5mp1e.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (m * m) % p\n              \
    \    ^\n/tmp/tmp3yd5mp1e.swift:21:17: error: missing argument label 'n:' in call\n\
    \    return (modp(n - 1, p: p) * n) % p\n                ^\n                 n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var n = n\n    var p = p\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afae0907c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afae05fe561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afae05fe286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afae05fe13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afae05fdbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpw8a75xda                        0x00005574a5ab5730 <unavailable> + 5936

    6    tmpw8a75xda                        0x00005574a5ab51e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afae0af3460 __libc_start_main +
    245

    8    tmpw8a75xda                        0x00005574a5ab4ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    var result = 1\n    var n =\
    \ n\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpt85x22il/tmpt85x22il.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b767ca48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b767c73fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b767c73f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b767c73e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt85x22il                        0x000055e4895042cd <unavailable> + 4813

    5    libc.so.6                          0x00002b767cc34460 __libc_start_main +
    245

    6    tmpt85x22il                        0x000055e489503ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    var n = n\n    var result =\
    \ 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * p) % n\n        }\n        n = n / 2\n        p = (p * p) % n\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbf_3dklx.swift:24:9: error: cannot assign to value: 'p' is a 'let'\
    \ constant\n        p = (p * p) % n\n        ^\n"
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    if n < 0 {\n        n = -n\n    }\n   \
    \ if p < 0 {\n        p = -p\n    }\n    if n == 0 {\n        return 1\n    }\n\
    \    if n % 2 == 0 {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) % p\n    } else {\n        return modp(n: n / 2, p: p) * modp(n: n / 2, p:\
    \ p) * modp(n: 2, p: p) % p\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014330
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    } else if n == 1 {\n        return\
    \ n % p\n    } else {\n        return (modp(n: n - 1, p: p) * n) % p\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpgddqj_0z/tmpgddqj_0z.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31746ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31743d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31743d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31743d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgddqj_0z                        0x000055c622bd924d <unavailable> + 4685

    5    libc.so.6                          0x00002b31748c9460 __libc_start_main +
    245

    6    tmpgddqj_0z                        0x000055c622bd8ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    for _ in 0..<n {\n        result = (result * 2) %\
    \ p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var r = 1\n    var b = n\n    while b > 0 {\n        if b % 2 == 1 {\n\
    \            r = (r * n) % p\n        }\n        b /= 2\n        n = (n * n) %\
    \ p\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2i55qvnw.swift:21:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = (n * n) % p\n        ^\n"
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    var x = modp(n / 2, p: p)\n\
    \    x = (x * x) % p\n    if n % 2 == 1 {\n        x = (x * 2) % p\n    }\n  \
    \  return x\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj0c1_acc.swift:17:17: error: missing argument label 'n:' in call\n\
    \    var x = modp(n / 2, p: p)\n                ^\n                 n: \n/tmp/tmpj0c1_acc.swift:18:12:\
    \ error: cannot convert value of type 'Duration' to expected argument type 'Int'\n\
    \    x = (x * x) % p\n           ^\n"
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        n = (n * n) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    for _ in 0..<n {\n        result = (result * 2) %\
    \ p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 0
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    for _ in 0..<n {\n        result = (result * 2) %\
    \ p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    var result = modp(n / 2, p:\
    \ p)\n    result = (result * result) % p\n    if n % 2 == 1 {\n        result\
    \ = (result * 2) % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpeb7clxa4.swift:17:22: error: missing argument label 'n:' in call\n\
    \    var result = modp(n / 2, p: p)\n                     ^\n                \
    \      n: \n/tmp/tmpeb7clxa4.swift:18:22: error: cannot convert value of type\
    \ 'Duration' to expected argument type 'Int'\n    result = (result * result) %\
    \ p\n                     ^\n"
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var res = 1\n    while n > 0 {\n        if n & 1 == 1\
    \ {\n            res = (res * n) % p\n        }\n        n = n >> 1\n    }\n \
    \   return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpuuplx6o7/tmpuuplx6o7.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf330a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf32d9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf32d9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf32d997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuuplx6o7                        0x0000563c014662cd <unavailable> + 4813

    5    libc.so.6                          0x00002adf3328f460 __libc_start_main +
    245

    6    tmpuuplx6o7                        0x0000563c01465ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        let\
    \ x = modp(n / 2, p: p)\n        return (x * x) % p\n    }\n    return (n * modp(n\
    \ - 1, p: p)) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfjos7o0n.swift:18:21: error: missing argument label 'n:' in call\n\
    \        let x = modp(n / 2, p: p)\n                    ^\n                  \
    \   n: \n/tmp/tmpfjos7o0n.swift:19:19: error: cannot convert value of type 'Duration'\
    \ to expected argument type 'Int'\n        return (x * x) % p\n              \
    \    ^\n/tmp/tmpfjos7o0n.swift:21:21: error: missing argument label 'n:' in call\n\
    \    return (n * modp(n - 1, p: p)) % p\n                    ^\n             \
    \        n: \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var p = p\n    var result = 1\n    while n > 0 {\n   \
    \     if n % 2 == 1 {\n            result = (result * n) % p\n        }\n    \
    \    n = n / 2\n        p = (p * p) % p\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'Swift/IntegerTypes.swift:14366: Fatal error: Division by zero in remainder
    operation

    Current stack trace:

    0    libswiftCore.so                    0x00002afd36f81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd36c78561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002afd36c78286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002afd36c7813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002afd36c77bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp0bhgyn68                        0x00005598b5d8b730 <unavailable> + 5936

    6    tmp0bhgyn68                        0x00005598b5d8b1e0 <unavailable> + 4576

    7    libc.so.6                          0x00002afd3716d460 __libc_start_main +
    245

    8    tmp0bhgyn68                        0x00005598b5d8aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var n = n\n    var result = 1\n    while n > 0 {\n        if n % 2 ==\
    \ 1 {\n            result = (result * n) % p\n        }\n        n = n / 2\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmp2i3x0nlm/tmp2i3x0nlm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b925553ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9255231b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9255231988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92552307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2i3x0nlm                        0x000055a1aa92e2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b9255726460 __libc_start_main +
    245

    6    tmp2i3x0nlm                        0x000055a1aa92def9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    var n = n\n    var result =\
    \ 1\n    while n > 0 {\n        if n % 2 == 1 {\n            result = (result\
    \ * n) % p\n        }\n        n = n / 2\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpqay88czy/tmpqay88czy.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b171faa7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b171f79eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b171f79e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b171f79d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqay88czy                        0x0000558eebf6d2cd <unavailable> + 4813

    5    libc.so.6                          0x00002b171fc93460 __libc_start_main +
    245

    6    tmpqay88czy                        0x0000558eebf6cef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n: n / 2, p: p) * modp(n: n / 2, p: p) % p\n    }\n    return modp(n: n\
    \ - 1, p: p) * modp(n: 1, p: p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014329
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n / 2, p: p) * modp(n / 2, p: p) % p\n    }\n    return modp(n / 2, p:\
    \ p) * modp(n / 2, p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3gpxvpze.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n                  \
    \ ^\n                    n: \n/tmp/tmp3gpxvpze.swift:18:40: error: missing argument\
    \ label 'n:' in call\n        return modp(n / 2, p: p) * modp(n / 2, p: p) % p\n\
    \                                       ^\n                                  \
    \      n: \n/tmp/tmp3gpxvpze.swift:20:16: error: missing argument label 'n:' in\
    \ call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n           \
    \    ^\n                n: \n/tmp/tmp3gpxvpze.swift:20:36: error: missing argument\
    \ label 'n:' in call\n    return modp(n / 2, p: p) * modp(n / 2, p: p) * 2 % p\n\
    \                                   ^\n                                    n:\
    \ \n"
  stdout: ''
  timestamp: 1660014323
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    var result = 1\n    var base = n\n    var exponent = p\n    while exponent\
    \ > 0 {\n        if exponent % 2 == 1 {\n            result = (result * base)\
    \ % p\n        }\n        exponent = exponent >> 1\n        base = (base * base)\
    \ % p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpp6h792q7/tmpp6h792q7.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59bfc38c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59bf92fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59bf92f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59bf92e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp6h792q7                        0x000055c930c652cd <unavailable> + 4813

    5    libc.so.6                          0x00002b59bfe24460 __libc_start_main +
    245

    6    tmpp6h792q7                        0x000055c930c64ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014324
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 1\n    }\n    if n % 2 == 0 {\n        return\
    \ modp(n/2, p: p) * modp(n/2, p: p) % p\n    }\n    return modp(n/2, p: p) * modp(n/2,\
    \ p: p) * 2 % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0x0_wo4a.swift:18:20: error: missing argument label 'n:' in call\n\
    \        return modp(n/2, p: p) * modp(n/2, p: p) % p\n                   ^\n\
    \                    n: \n/tmp/tmp0x0_wo4a.swift:18:38: error: missing argument\
    \ label 'n:' in call\n        return modp(n/2, p: p) * modp(n/2, p: p) % p\n \
    \                                    ^\n                                     \
    \ n: \n/tmp/tmp0x0_wo4a.swift:20:16: error: missing argument label 'n:' in call\n\
    \    return modp(n/2, p: p) * modp(n/2, p: p) * 2 % p\n               ^\n    \
    \            n: \n/tmp/tmp0x0_wo4a.swift:20:34: error: missing argument label\
    \ 'n:' in call\n    return modp(n/2, p: p) * modp(n/2, p: p) * 2 % p\n       \
    \                          ^\n                                  n: \n"
  stdout: ''
  timestamp: 1660014324
