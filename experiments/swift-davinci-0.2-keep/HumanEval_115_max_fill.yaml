name: HumanEval_115_max_fill
language: swift
prompt: "\n/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// Input: \n/// grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n/// bucket_capacity\
  \ : 1\n/// Output: 6\n/// Example 2:\n/// Input: \n/// grid : [[0,0,1,1], [0,0,0,0],\
  \ [1,1,1,1], [0,1,1,1]]\n/// bucket_capacity : 2\n/// Output: 5\n/// Example 3:\n\
  /// Input: \n/// grid : [[0,0,0], [0,0,0]]\n/// bucket_capacity : 5\n/// Output:\
  \ 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <= grid.length\
  \ <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// *\
  \ 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
  \ 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0,\
  \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid:\
  \ [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], capacity: 9) == 2)"
completions: ["    var result = 0\n    for row in grid {\n        var sum = 0\n  \
    \      for cell in row {\n            sum += cell\n            if sum == capacity\
    \ {\n                result += 1\n                sum = 0\n            }\n   \
    \     }\n        if sum > 0 {\n            result += 1\n        }\n    }\n   \
    \ return result", "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                count += 1\n                grid[i][j] = 0\n                var\
    \ k = i + 1\n                while k < grid.count && capacity > 0 {\n        \
    \            if grid[k][j] == 1 {\n                        grid[k][j] = 0\n  \
    \                      capacity -= 1\n                    }\n                \
    \    k += 1\n                }\n            }\n        }\n    }\n    return count",
  "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count {\n       \
    \ for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n           \
    \     count += 1\n                var k = i\n                while k < grid.count\
    \ && grid[k][j] == 1 {\n                    grid[k][j] = 0\n                 \
    \   k += 1\n                }\n            }\n        }\n    }\n    return count",
  "    var result = 0\n    for i in 0..<grid.count {\n        var sum = 0\n      \
    \  for j in 0..<grid[i].count {\n            sum += grid[i][j]\n        }\n  \
    \      result += sum / capacity\n        if sum % capacity != 0 {\n          \
    \  result += 1\n        }\n    }\n    return result", '    return 0', "    var\
    \ grid = grid\n    var count = 0\n    while true {\n        var filled = false\n\
    \        for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n\
    \                if grid[i][j] == 1 {\n                    filled = true\n   \
    \                 grid[i][j] = 0\n                    if i > 0 {\n           \
    \             grid[i-1][j] = min(grid[i-1][j] + capacity, 1)\n               \
    \     }\n                    if i < grid.count - 1 {\n                       \
    \ grid[i+1][j] = min(grid[i+1][j] + capacity, 1)\n                    }\n    \
    \                if j > 0 {\n                        grid[i][j-1] = min(grid[i][j-1]\
    \ + capacity, 1)\n                    }\n                    if j < grid[i].count\
    \ - 1 {\n                        grid[i][j+1] = min(grid[i][j+1] + capacity, 1)\n\
    \                    }\n                }\n            }\n        }\n        if\
    \ !filled {\n            break\n        }\n        count += 1\n    }\n    return\
    \ count", "    var grid = grid\n    var count = 0\n    while true {\n        var\
    \ min_row = -1\n        var min_value = Int.max\n        for i in 0..<grid.count\
    \ {\n            var sum = 0\n            for j in 0..<grid[i].count {\n     \
    \           sum += grid[i][j]\n            }\n            if sum < min_value {\n\
    \                min_value = sum\n                min_row = i\n            }\n\
    \        }\n        if min_value == 0 {\n            break\n        }\n      \
    \  for j in 0..<grid[min_row].count {\n            if grid[min_row][j] == 1 {\n\
    \                grid[min_row][j] = 0\n                count += 1\n          \
    \  }\n        }\n    }\n    return count", "    var grid = grid\n    var count\
    \ = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count {\n \
    \           if grid[i][j] == 1 {\n                count += 1\n               \
    \ fill(grid: &grid, i: i, j: j, capacity: capacity)\n            }\n        }\n\
    \    }\n    return count", "    var result = 0\n    for i in 0..<grid.count {\n\
    \        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n    \
    \            result += capacity\n            }\n        }\n    }\n    return result",
  "    var result = 0\n    var row_max = [Int](repeating: 0, count: grid.count)\n\
    \    for row in 0..<grid.count {\n        for col in 0..<grid[row].count {\n \
    \           if grid[row][col] == 1 {\n                row_max[row] = col\n   \
    \         }\n        }\n    }\n    for col in 0..<grid[0].count {\n        var\
    \ row = 0\n        var col_max = 0\n        while row < grid.count {\n       \
    \     if row_max[row] >= col {\n                col_max = row\n            }\n\
    \            row += 1\n        }\n        for row in 0...col_max {\n         \
    \   if row_max[row] >= col {\n                result += 1\n            }\n   \
    \     }\n    }\n    return result", "    var result = 0\n    var max_fill = 0\n\
    \    for row in grid {\n        for cell in row {\n            if cell == 1 {\n\
    \                max_fill += 1\n            }\n        }\n    }\n    var fill\
    \ = 0\n    var row = 0\n    while fill < max_fill {\n        var col = 0\n   \
    \     while col < grid[row].count {\n            if grid[row][col] == 1 {\n  \
    \              fill += 1\n                grid[row][col] = 0\n            }\n\
    \            col += 1\n        }\n        row += 1\n        result += 1\n    }\n\
    \    return result", "    var result = 0\n    for row in grid {\n        var sum\
    \ = 0\n        for i in 0..<row.count {\n            if row[i] == 1 {\n      \
    \          sum += 1\n            } else {\n                if sum > 0 {\n    \
    \                result += 1\n                    sum = 0\n                }\n\
    \            }\n        }\n        if sum > 0 {\n            result += 1\n   \
    \     }\n    }\n    return result * capacity", "    var max_fill = 0\n    for\
    \ row in grid {\n        var fill = 0\n        for cell in row {\n           \
    \ if cell == 1 {\n                fill += 1\n            } else {\n          \
    \      if fill > max_fill {\n                    max_fill = fill\n           \
    \     }\n                fill = 0\n            }\n        }\n        if fill >\
    \ max_fill {\n            max_fill = fill\n        }\n    }\n    return max_fill",
  "    var grid = grid\n    var count = 0\n    for i in 0..<grid.count {\n       \
    \ for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n           \
    \     count += 1\n                grid[i][j] = 0\n                var k = i\n\
    \                while k < grid.count && grid[k][j] == 0 {\n                 \
    \   grid[k][j] = 1\n                    k += 1\n                }\n          \
    \      k = i - 1\n                while k >= 0 && grid[k][j] == 0 {\n        \
    \            grid[k][j] = 1\n                    k -= 1\n                }\n \
    \           }\n        }\n    }\n    return count", "    var max_fill = 0\n  \
    \  for row in grid {\n        var fill = 0\n        for cell in row {\n      \
    \      if cell == 1 {\n                fill += 1\n            } else {\n     \
    \           if fill > 0 {\n                    max_fill += 1\n               \
    \     fill = 0\n                }\n            }\n        }\n        if fill >\
    \ 0 {\n            max_fill += 1\n        }\n    }\n    return max_fill * capacity",
  "    var result = 0\n    for row in grid {\n        var water = 0\n        for cell\
    \ in row {\n            water += cell\n            if water == capacity {\n  \
    \              result += 1\n                water = 0\n            }\n       \
    \ }\n        if water > 0 {\n            result += 1\n        }\n    }\n    return\
    \ result", "    var result = 0\n    var max_fill = 0\n    for row in grid {\n\
    \        for col in row {\n            if col == 1 {\n                max_fill\
    \ += 1\n            }\n        }\n    }\n    var fill = 0\n    for row in grid\
    \ {\n        for col in row {\n            if col == 1 {\n                fill\
    \ += 1\n            }\n        }\n        if fill == max_fill {\n            break\n\
    \        }\n        result += 1\n        fill = 0\n    }\n    return result",
  "    var result = 0\n    for row in grid {\n        var water = 0\n        for well\
    \ in row {\n            water += well\n            if water >= capacity {\n  \
    \              result += 1\n                water = 0\n            }\n       \
    \ }\n        if water > 0 {\n            result += 1\n        }\n    }\n    return\
    \ result", "    var count = 0\n    var max_row = 0\n    for row in grid {\n  \
    \      max_row = max(max_row, row.reduce(0, +))\n    }\n    for _ in 0..<max_row\
    \ {\n        for row in grid {\n            for i in 0..<row.count {\n       \
    \         if row[i] > 0 {\n                    row[i] -= 1\n                 \
    \   count += 1\n                }\n            }\n        }\n    }\n    return\
    \ count", "    var result = 0\n    for row in grid {\n        var fill = 0\n \
    \       for col in row {\n            if col == 1 {\n                fill += 1\n\
    \            } else {\n                if fill > 0 {\n                    result\
    \ += 1\n                    fill = 0\n                }\n            }\n     \
    \   }\n        if fill > 0 {\n            result += 1\n        }\n    }\n    return\
    \ result"]
stop_tokens:
- "\n}"
