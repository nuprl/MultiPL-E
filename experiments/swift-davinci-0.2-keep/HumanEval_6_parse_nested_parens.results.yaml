language: swift
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups {\n\
    \        var max_nesting_level = 0\n        var current_nesting_level = 0\n  \
    \      for paren in paren_group {\n            if paren == \"(\" {\n         \
    \       current_nesting_level += 1\n            } else if paren == \")\" {\n \
    \               current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp6_6rktsu.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    return max_depths\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp0_9o4r2x.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.split(separator:\
    \ \" \")\n    for paren_group in paren_groups {\n        var stack = [Character]()\n\
    \        var max_depth = 0\n        for char in paren_group {\n            if\
    \ char == \"(\" {\n                stack.append(char)\n                max_depth\
    \ = max(max_depth, stack.count)\n            } else if char == \")\" {\n     \
    \           stack.removeLast()\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_level = 0\n    var nesting_level = 0\n    var\
    \ max_nesting_levels: [Int] = []\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            nesting_level += 1\n            if nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = nesting_level\n            }\n      \
    \  } else if char == \")\" {\n            nesting_level -= 1\n            if nesting_level\
    \ == 0 {\n                max_nesting_levels.append(max_nesting_level)\n     \
    \           max_nesting_level = 0\n            }\n        }\n    }\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_max = 0\n    var current_count\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_count += 1\n            if current_count > current_max {\n        \
    \        current_max = current_count\n            }\n        } else if char ==\
    \ \")\" {\n            current_count -= 1\n        } else if char == \" \" {\n\
    \            result.append(current_max)\n            current_max = 0\n       \
    \     current_count = 0\n        }\n    }\n    result.append(current_max)\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var max_level = 0\n    var level =\
    \ 0\n    for char in paren_string {\n        if char == \"(\" {\n            level\
    \ += 1\n            max_level = max(max_level, level)\n        } else if char\
    \ == \")\" {\n            level -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_level)\n            max_level = 0\n            level\
    \ = 0\n        }\n    }\n    result.append(max_level)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var nesting_level = 0\n   \
    \     var max_nesting_level = 0\n        for char in group.characters {\n    \
    \        if char == \"(\" {\n                nesting_level += 1\n            }\
    \ else if char == \")\" {\n                nesting_level -= 1\n            }\n\
    \            if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpumne1tce.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var i = 0\n    while i < paren_string.count\
    \ {\n        let index = paren_string.index(paren_string.startIndex, offsetBy:\
    \ i)\n        let paren = paren_string[index]\n        if paren == \"(\" {\n \
    \           current_nesting_level += 1\n            if current_nesting_level >\
    \ max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if paren == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if paren == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n        i += 1\n    }\n    max_nesting_levels.append(max_nesting_level)\n\
    \    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    let groups = paren_string.split(separator: \" \")\n    var max_nesting\
    \ = [Int]()\n    for group in groups {\n        var nesting = 0\n        var max_nesting_in_group\
    \ = 0\n        for char in group {\n            if char == \"(\" {\n         \
    \       nesting += 1\n            } else if char == \")\" {\n                nesting\
    \ -= 1\n            }\n            if nesting > max_nesting_in_group {\n     \
    \           max_nesting_in_group = nesting\n            }\n        }\n       \
    \ max_nesting.append(max_nesting_in_group)\n    }\n    return max_nesting\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var i = 0\n    var j = 0\n    var\
    \ count = 0\n    var max_count = 0\n    while i < paren_string.count {\n     \
    \   let char = paren_string[paren_string.index(paren_string.startIndex, offsetBy:\
    \ i)]\n        if char == \"(\" {\n            count += 1\n            max_count\
    \ = max(max_count, count)\n        } else if char == \")\" {\n            count\
    \ -= 1\n        } else if char == \" \" {\n            result.append(max_count)\n\
    \            max_count = 0\n            count = 0\n            j = i + 1\n   \
    \     }\n        i += 1\n    }\n    result.append(max_count)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var max_depths = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            depth -= 1\n  \
    \      } else if char == \" \" {\n            max_depths.append(max_depth)\n \
    \           max_depth = 0\n            depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.split(separator: \" \")\n  \
    \  var result = [Int]()\n    for paren_group in paren_groups {\n        var max_depth\
    \ = 0\n        var current_depth = 0\n        for char in paren_group {\n    \
    \        if char == \"(\" {\n                current_depth += 1\n            }\
    \ else if char == \")\" {\n                current_depth -= 1\n            }\n\
    \            if current_depth > max_depth {\n                max_depth = current_depth\n\
    \            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var max_depth_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            depth\
    \ -= 1\n        } else if char == \" \" {\n            max_depth_list.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    max_depth_list.append(max_depth)\n\
    \    return max_depth_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = Stack<Character>()\n\
    \    var max_depth = 0\n    for paren in paren_string {\n        if paren == \"\
    (\" {\n            paren_stack.push(paren)\n            max_depth = max(max_depth,\
    \ paren_stack.count)\n        } else if paren == \")\" {\n            paren_stack.pop()\n\
    \        } else if paren == \" \" {\n            result.append(max_depth)\n  \
    \          max_depth = 0\n        }\n    }\n    result.append(max_depth)\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpj38qewgh.swift:9:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_depth = 0\n       \
    \ var current_depth = 0\n        for paren in group {\n            if paren ==\
    \ \"(\" {\n                current_depth += 1\n            } else if paren ==\
    \ \")\" {\n                current_depth -= 1\n            }\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth\n            }\n  \
    \      }\n        result.append(max_depth)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpvls5cp0w.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = [Character]()\n\
    \    var max_depth = 0\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.append(char)\n      \
    \      current_depth += 1\n            if current_depth > max_depth {\n      \
    \          max_depth = current_depth\n            }\n        } else if char ==\
    \ \")\" {\n            if paren_stack.last == \"(\" {\n                paren_stack.removeLast()\n\
    \                current_depth -= 1\n            } else {\n                print(\"\
    Invalid input\")\n                return []\n            }\n        } else if\
    \ char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            current_depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var max_depths = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            depth -= 1\n  \
    \      } else if char == \" \" {\n            max_depths.append(max_depth)\n \
    \           max_depth = 0\n            depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_level = 0\n    var results\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        nesting_level += 1\n            if nesting_level > max_nesting {\n  \
    \              max_nesting = nesting_level\n            }\n        } else if char\
    \ == \")\" {\n            nesting_level -= 1\n        } else if char == \" \"\
    \ {\n            results.append(max_nesting)\n            max_nesting = 0\n  \
    \          nesting_level = 0\n        }\n    }\n    results.append(max_nesting)\n\
    \    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var stack = Stack<Character>()\n    var max_depth = 0\n    var\
    \ depths = [Int]()\n    var current_depth = 0\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            stack.push(char)\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    if stack.isEmpty {\n                depths.append(0)\n                current_depth\
    \ = 0\n                max_depth = 0\n            } else {\n                stack.pop()\n\
    \                current_depth -= 1\n            }\n        } else if char ==\
    \ \" \" {\n            depths.append(max_depth)\n            current_depth = 0\n\
    \            max_depth = 0\n        }\n    }\n    depths.append(max_depth)\n \
    \   return depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp1ljah_np.swift:8:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_nesting =\
    \ 0\n    var nesting_levels = [Int]()\n    for char in paren_string {\n      \
    \  if char == \"(\" {\n            paren_stack.push(char)\n            max_nesting\
    \ += 1\n        } else if char == \")\" {\n            paren_stack.pop()\n   \
    \         if paren_stack.isEmpty() {\n                nesting_levels.append(max_nesting)\n\
    \                max_nesting = 0\n            }\n        }\n    }\n    return\
    \ nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpx16u5jhp.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var stack = Stack<Character>()\n    var max_level = 0\n    var\
    \ level = 0\n    var max_levels = [Int]()\n    for char in paren_string {\n  \
    \      if char == \"(\" {\n            stack.push(char)\n            level +=\
    \ 1\n            if level > max_level {\n                max_level = level\n \
    \           }\n        } else if char == \")\" {\n            stack.pop()\n  \
    \          level -= 1\n            if stack.isEmpty() {\n                max_levels.append(max_level)\n\
    \                max_level = 0\n                level = 0\n            }\n   \
    \     }\n    }\n    return max_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp_24coh0j.swift:8:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var max_nesting_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            max_nesting_list.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    max_nesting_list.append(max_nesting)\n\
    \    return max_nesting_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    let paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups {\n\
    \        var max_nesting_level = 0\n        var current_nesting_level = 0\n  \
    \      for paren in paren_group {\n            if paren == \"(\" {\n         \
    \       current_nesting_level += 1\n            } else if paren == \")\" {\n \
    \               current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp1oiqsr20.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var nesting_level = 0\n        var\
    \ max_nesting_level = 0\n        for char in group {\n            if char == \"\
    (\" {\n                nesting_level += 1\n            } else if char == \")\"\
    \ {\n                nesting_level -= 1\n            }\n            if nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = nesting_level\n \
    \           }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpd0za2apy.swift:9:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var paren_stack = Stack<Character>()\n\
    \        var max_nesting = 0\n        var current_nesting = 0\n        for paren\
    \ in paren_group {\n            if paren == \"(\" {\n                paren_stack.push(paren)\n\
    \                current_nesting += 1\n                if current_nesting > max_nesting\
    \ {\n                    max_nesting = current_nesting\n                }\n  \
    \          } else if paren == \")\" {\n                if paren_stack.isEmpty()\
    \ {\n                    print(\"Error: Unmatched closing parenthesis\")\n   \
    \                 return []\n                } else {\n                    paren_stack.pop()\n\
    \                    current_nesting -= 1\n                }\n            }\n\
    \        }\n        if !paren_stack.isEmpty() {\n            print(\"Error: Unmatched\
    \ opening parenthesis\")\n            return []\n        }\n        result.append(max_nesting)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2qxb3bt2.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp2qxb3bt2.swift:11:27:\
    \ error: cannot find 'Stack' in scope\n        var paren_stack = Stack<Character>()\n\
    \                          ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_level = 0\n       \
    \ var current_level = 0\n        for char in group {\n            if char == \"\
    (\" {\n                current_level += 1\n            } else if char == \")\"\
    \ {\n                current_level -= 1\n            }\n            if current_level\
    \ > max_level {\n                max_level = current_level\n            }\n  \
    \      }\n        max_nesting_levels.append(max_level)\n    }\n    return max_nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpj5eb2tru.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_depth = 0\n       \
    \ var current_depth = 0\n        for char in group {\n            if char == \"\
    (\" {\n                current_depth += 1\n                if current_depth >\
    \ max_depth {\n                    max_depth = current_depth\n               \
    \ }\n            } else if char == \")\" {\n                current_depth -= 1\n\
    \            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpnf1iqgsv.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    let paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var result = [Int]()\n    for paren_group in paren_groups {\n        result.append(parse_nested_parens_helper(paren_group:\
    \ paren_group))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmplhdw71qy.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var stack = Stack<Character>()\n \
    \   var max_level = 0\n    var current_level = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.push(char)\n            current_level\
    \ += 1\n            if current_level > max_level {\n                max_level\
    \ = current_level\n            }\n        } else if char == \")\" {\n        \
    \    stack.pop()\n            current_level -= 1\n        } else if char == \"\
    \ \" {\n            result.append(max_level)\n            max_level = 0\n    \
    \        current_level = 0\n        }\n    }\n    result.append(max_level)\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp0z34cvt1.swift:9:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var current_level: Int = 0\n   \
    \ var max_level: Int = 0\n    for char in paren_string {\n        if char == \"\
    (\" {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == \")\" {\n            current_level -= 1\n        } else if char ==\
    \ \" \" {\n            result.append(max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var current_depth = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        } else if char == \")\" {\n            current_depth -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            current_depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9xn5rv8d.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var stack = Stack<Character>()\n\
    \        var max_depth = 0\n        var current_depth = 0\n        for char in\
    \ group {\n            if char == \"(\" {\n                stack.push(char)\n\
    \                current_depth += 1\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth\n                }\n      \
    \      } else if char == \")\" {\n                if stack.isEmpty() {\n     \
    \               print(\"Error: mismatched parentheses\")\n                   \
    \ return [Int]()\n                }\n                stack.pop()\n           \
    \     current_depth -= 1\n            }\n        }\n        if !stack.isEmpty()\
    \ {\n            print(\"Error: mismatched parentheses\")\n            return\
    \ [Int]()\n        }\n        result.append(max_depth)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpi2yajhx7.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpi2yajhx7.swift:11:21:\
    \ error: cannot find 'Stack' in scope\n        var stack = Stack<Character>()\n\
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_nesting = 0\n\
    \        var current_nesting = 0\n        for char in paren_group {\n        \
    \    if char == \"(\" {\n                current_nesting += 1\n            } else\
    \ if char == \")\" {\n                current_nesting -= 1\n            }\n  \
    \          if current_nesting > max_nesting {\n                max_nesting = current_nesting\n\
    \            }\n        }\n        result.append(max_nesting)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmprukh_004.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_level = 0\n\
    \    var max_level = 0\n    for char in paren_string {\n        if char == \"\
    (\" {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == \")\" {\n            current_level -= 1\n        } else if char ==\
    \ \" \" {\n            max_nesting_levels.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    max_nesting_levels.append(max_level)\n\
    \    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_level = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        nesting_level += 1\n            if nesting_level > max_nesting {\n  \
    \              max_nesting = nesting_level\n            }\n        } else if char\
    \ == \")\" {\n            nesting_level -= 1\n        } else if char == \" \"\
    \ {\n            result.append(max_nesting)\n            max_nesting = 0\n   \
    \         nesting_level = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var depth = 0\n    for char in paren_string {\n  \
    \      if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            if paren_stack.isEmpty()\
    \ {\n                result.append(0)\n                depth = 0\n           \
    \     max_depth = 0\n            } else {\n                paren_stack.pop()\n\
    \                depth -= 1\n            }\n        } else if char == \" \" {\n\
    \            if paren_stack.isEmpty() {\n                result.append(max_depth)\n\
    \                depth = 0\n                max_depth = 0\n            }\n   \
    \     }\n    }\n    if !paren_stack.isEmpty() {\n        result.append(0)\n  \
    \  } else {\n        result.append(max_depth)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp0j0b721t.swift:9:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_depth = 0\n       \
    \ var depth = 0\n        for char in group {\n            if char == \"(\" {\n\
    \                depth += 1\n            } else if char == \")\" {\n         \
    \       depth -= 1\n            }\n            if depth > max_depth {\n      \
    \          max_depth = depth\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpcdf2j5mb.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_level = 0\n    var nesting_level = 0\n    var\
    \ max_nesting_levels = [Int]()\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            nesting_level += 1\n            if nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = nesting_level\n            }\n      \
    \  } else if char == \")\" {\n            nesting_level -= 1\n        } else if\
    \ char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            nesting_level = 0\n        }\n\
    \    }\n    max_nesting_levels.append(max_nesting_level)\n    return max_nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_level = 0\n    var max_nesting_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        nesting_level += 1\n            if nesting_level > max_nesting {\n  \
    \              max_nesting = nesting_level\n            }\n        } else if char\
    \ == \")\" {\n            nesting_level -= 1\n        } else if char == \" \"\
    \ {\n            max_nesting_list.append(max_nesting)\n            max_nesting\
    \ = 0\n            nesting_level = 0\n        }\n    }\n    max_nesting_list.append(max_nesting)\n\
    \    return max_nesting_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_max = 0\n    var current_count\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_count += 1\n            if current_count > current_max {\n        \
    \        current_max = current_count\n            }\n        } else if char ==\
    \ \")\" {\n            current_count -= 1\n        } else if char == \" \" {\n\
    \            result.append(current_max)\n            current_max = 0\n       \
    \     current_count = 0\n        }\n    }\n    result.append(current_max)\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depths = [Int]()\n    for char in paren_string {\n        if char ==\
    \ \"(\" {\n            paren_stack.push(char)\n            max_depth += 1\n  \
    \      } else if char == \")\" {\n            paren_stack.pop()\n            if\
    \ paren_stack.isEmpty() {\n                depths.append(max_depth)\n        \
    \        max_depth = 0\n            }\n        }\n    }\n    return depths\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpga70y6du.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var max_depths = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            depth -= 1\n  \
    \      } else if char == \" \" {\n            max_depths.append(max_depth)\n \
    \           max_depth = 0\n            depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let groups = paren_string.split(separator:\
    \ \" \")\n    for group in groups {\n        var nesting_level = 0\n        var\
    \ max_nesting_level = 0\n        for char in group {\n            if char == \"\
    (\" {\n                nesting_level += 1\n            } else if char == \")\"\
    \ {\n                nesting_level -= 1\n            }\n            if nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = nesting_level\n \
    \           }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups {\n\
    \        var max_nesting_level = 0\n        var current_nesting_level = 0\n  \
    \      for paren in paren_group {\n            if paren == \"(\" {\n         \
    \       current_nesting_level += 1\n            } else if paren == \")\" {\n \
    \               current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp6_6rktsu.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var stack = Stack<Character>()\n \
    \   var max_depth = 0\n    var depth = 0\n    for char in paren_string {\n   \
    \     if char == \"(\" {\n            stack.push(char)\n            depth += 1\n\
    \            if depth > max_depth {\n                max_depth = depth\n     \
    \       }\n        } else if char == \")\" {\n            if stack.isEmpty {\n\
    \                print(\"Error: mismatched parentheses\")\n                return\
    \ []\n            }\n            stack.pop()\n            depth -= 1\n       \
    \ } else if char == \" \" {\n            if stack.isEmpty {\n                result.append(max_depth)\n\
    \                max_depth = 0\n            }\n        }\n    }\n    if !stack.isEmpty\
    \ {\n        print(\"Error: mismatched parentheses\")\n        return []\n   \
    \ }\n    result.append(max_depth)\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmplkm4u8x3.swift:9:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9xn5rv8d.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_levels = [Int]()\n    var paren_level = 0\n    var\
    \ paren_count = 0\n    for char in paren_string {\n        if char == \"(\" {\n\
    \            paren_count += 1\n            paren_level += 1\n        } else if\
    \ char == \")\" {\n            paren_count -= 1\n            paren_level -= 1\n\
    \        } else if char == \" \" {\n            paren_levels.append(paren_level)\n\
    \            paren_level = 0\n        }\n    }\n    paren_levels.append(paren_level)\n\
    \    return paren_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmprntv6dc_/tmprntv6dc_.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba61366dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba613364b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba613364988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba6133637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprntv6dc_                        0x00005570b0f2068e <unavailable> + 5774

    5    libc.so.6                          0x00002ba613859460 __libc_start_main +
    245

    6    tmprntv6dc_                        0x00005570b0f202a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var result:\
    \ [Int] = []\n    for char in paren_string {\n        if char == \"(\" {\n   \
    \         current_nesting += 1\n            max_nesting = max(max_nesting, current_nesting)\n\
    \        } else if char == \")\" {\n            current_nesting -= 1\n       \
    \ } else if char == \" \" {\n            result.append(max_nesting)\n        \
    \    max_nesting = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    let paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting = [Int]()\n    for paren_group in paren_groups {\n    \
    \    var current_nesting = 0\n        var max_nesting_in_group = 0\n        for\
    \ paren in paren_group {\n            if paren == \"(\" {\n                current_nesting\
    \ += 1\n            } else if paren == \")\" {\n                current_nesting\
    \ -= 1\n            }\n            if current_nesting > max_nesting_in_group {\n\
    \                max_nesting_in_group = current_nesting\n            }\n     \
    \   }\n        max_nesting.append(max_nesting_in_group)\n    }\n    return max_nesting\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp5u_jcinz.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var curr_depth = 0\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            curr_depth\
    \ += 1\n            if curr_depth > max_depth {\n                max_depth = curr_depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            curr_depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            curr_depth = 0\n        }\n    }\n   \
    \ result.append(max_depth)\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpj7k_qv0t.swift:9:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9xn5rv8d.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack: [Character] = []\n    var max_depth: Int =\
    \ 0\n    var depths: [Int] = []\n    var depth: Int = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.append(char)\n      \
    \      depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.popLast()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            depths.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    depths.append(max_depth)\n\
    \    return depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    let paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups {\n\
    \        var nesting_level = 0\n        var max_nesting_level = 0\n        for\
    \ char in paren_group.characters {\n            if char == \"(\" {\n         \
    \       nesting_level += 1\n            } else if char == \")\" {\n          \
    \      nesting_level -= 1\n            }\n            if nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = nesting_level\n            }\n      \
    \  }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp65lscj93.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_levels = [Int]()\n    var\
    \ current_nesting = 0\n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            current_nesting += 1\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            nesting_levels.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    nesting_levels.append(max_nesting)\n\
    \    return nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var current_depth = 0\n        for char in paren_group {\n           \
    \ if char == \"(\" {\n                current_depth += 1\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth\n             \
    \   }\n            } else if char == \")\" {\n                current_depth -=\
    \ 1\n            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpqekvhndv.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var depths = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depths.append(max_depth)\n            max_depth = 0\n           \
    \ depth = 0\n        }\n    }\n    return depths\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp2i8s0181.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_level = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        nesting_level += 1\n            if nesting_level > max_nesting {\n  \
    \              max_nesting = nesting_level\n            }\n        } else if char\
    \ == \")\" {\n            nesting_level -= 1\n        } else if char == \" \"\
    \ {\n            result.append(max_nesting)\n            max_nesting = 0\n   \
    \         nesting_level = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_level = 0\n    var max_nesting_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        nesting_level += 1\n            if nesting_level > max_nesting {\n  \
    \              max_nesting = nesting_level\n            }\n        } else if char\
    \ == \")\" {\n            nesting_level -= 1\n        } else if char == \" \"\
    \ {\n            max_nesting_list.append(max_nesting)\n            max_nesting\
    \ = 0\n            nesting_level = 0\n        }\n    }\n    max_nesting_list.append(max_nesting)\n\
    \    return max_nesting_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var max_level = 0\n        var level\
    \ = 0\n        for char in group {\n            if char == \"(\" {\n         \
    \       level += 1\n            } else if char == \")\" {\n                level\
    \ -= 1\n            }\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        }\n        result.append(max_level)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmprn82pvyy.swift:9:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var max_depth = 0\n    var current_depth\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_depth += 1\n            if current_depth > max_depth {\n          \
    \      max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            current_depth -= 1\n        } else if char == \" \" {\n   \
    \         result.append(max_depth)\n            max_depth = 0\n            current_depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = [Int]()\n    var current_nesting = 0\n   \
    \ var max_current_nesting = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            current_nesting += 1\n            if current_nesting\
    \ > max_current_nesting {\n                max_current_nesting = current_nesting\n\
    \            }\n        } else if char == \")\" {\n            current_nesting\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting.append(max_current_nesting)\n\
    \            max_current_nesting = 0\n            current_nesting = 0\n      \
    \  }\n    }\n    max_nesting.append(max_current_nesting)\n    return max_nesting\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var current_depth = 0\n    var max_depth_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth += 1\n            if current_depth > max_depth {\n    \
    \            max_depth = current_depth\n            }\n        } else if char\
    \ == \")\" {\n            current_depth -= 1\n        } else if char == \" \"\
    \ {\n            max_depth_list.append(max_depth)\n            max_depth = 0\n\
    \            current_depth = 0\n        }\n    }\n    max_depth_list.append(max_depth)\n\
    \    return max_depth_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var results: [Int] = []\n    var paren_stack: [Character] =\
    \ []\n    var max_depth: Int = 0\n    var depth: Int = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.append(char)\n      \
    \      depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            if paren_stack.count\
    \ > 0 {\n                paren_stack.removeLast()\n                depth -= 1\n\
    \            }\n        } else if char == \" \" {\n            if paren_stack.count\
    \ == 0 {\n                results.append(max_depth)\n                max_depth\
    \ = 0\n                depth = 0\n            }\n        }\n    }\n    if paren_stack.count\
    \ == 0 {\n        results.append(max_depth)\n    }\n    return results\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_nesting = 0\n\
    \        var current_nesting = 0\n        for char in paren_group {\n        \
    \    if char == \"(\" {\n                current_nesting += 1\n            } else\
    \ if char == \")\" {\n                current_nesting -= 1\n            }\n  \
    \          if current_nesting > max_nesting {\n                max_nesting = current_nesting\n\
    \            }\n        }\n        result.append(max_nesting)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmprukh_004.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9xn5rv8d.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_level = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        nesting_level += 1\n            if nesting_level > max_nesting {\n  \
    \              max_nesting = nesting_level\n            }\n        } else if char\
    \ == \")\" {\n            nesting_level -= 1\n        } else if char == \" \"\
    \ {\n            result.append(max_nesting)\n            max_nesting = 0\n   \
    \         nesting_level = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_levels = [Int]()\n    var paren_level = 0\n    for\
    \ char in paren_string {\n        if char == \"(\" {\n            paren_level\
    \ += 1\n        } else if char == \")\" {\n            paren_level -= 1\n    \
    \    } else if char == \" \" {\n            paren_levels.append(paren_level)\n\
    \            paren_level = 0\n        }\n    }\n    return paren_levels\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmp8r87fj41/tmp8r87fj41.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3274a78c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b327476fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b327476f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b327476e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8r87fj41                        0x0000559cfa25768e <unavailable> + 5774

    5    libc.so.6                          0x00002b3274c64460 __libc_start_main +
    245

    6    tmp8r87fj41                        0x0000559cfa2572a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var max_nesting = 0\n    var nesting\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  nesting += 1\n            if nesting > max_nesting {\n                max_nesting\
    \ = nesting\n            }\n        } else if char == \")\" {\n            nesting\
    \ -= 1\n        } else if char == \" \" {\n            result.append(max_nesting)\n\
    \            max_nesting = 0\n            nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var max_depth = 0\n    var depth\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  depth += 1\n            if depth > max_depth {\n                max_depth =\
    \ depth\n            }\n        } else if char == \")\" {\n            depth -=\
    \ 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var current_group = \"\"\n    var groups\
    \ = paren_string.components(separatedBy: \" \")\n    for group in groups {\n \
    \       current_group = group\n        for char in current_group.characters {\n\
    \            if char == \"(\" {\n                current_nesting_level += 1\n\
    \            } else if char == \")\" {\n                current_nesting_level\
    \ -= 1\n            }\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level\n            }\n\
    \        }\n        max_nesting_levels.append(max_nesting_level)\n        current_nesting_level\
    \ = 0\n        max_nesting_level = 0\n    }\n    return max_nesting_levels\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpgjcsl9w9.swift:12:31: error: value of type 'String' has no member\
    \ 'components'\n    var groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpgjcsl9w9.swift:15:35: error:\
    \ 'characters' is unavailable: Please use String directly\n        for char in\
    \ current_group.characters {\n                                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var nesting_level = 0\n\
    \        var max_nesting_level = 0\n        for char in paren_group {\n      \
    \      if char == \"(\" {\n                nesting_level += 1\n            } else\
    \ if char == \")\" {\n                nesting_level -= 1\n            }\n    \
    \        if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp8zhsypb9.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    let paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups {\n\
    \        var max_nesting_level = 0\n        var current_nesting_level = 0\n  \
    \      for paren in paren_group {\n            if paren == \"(\" {\n         \
    \       current_nesting_level += 1\n            } else if paren == \")\" {\n \
    \               current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp1oiqsr20.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    let paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for group in paren_groups {\n   \
    \     var nesting_level = 0\n        var max_nesting_level = 0\n        for char\
    \ in group.characters {\n            if char == \"(\" {\n                nesting_level\
    \ += 1\n            } else if char == \")\" {\n                nesting_level -=\
    \ 1\n            }\n            if nesting_level > max_nesting_level {\n     \
    \           max_nesting_level = nesting_level\n            }\n        }\n    \
    \    max_nesting_levels.append(max_nesting_level)\n    }\n    return max_nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpjbj97e80.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var max_depth = 0\n    var current_depth\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_depth += 1\n            if current_depth > max_depth {\n          \
    \      max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            current_depth -= 1\n        } else if char == \" \" {\n   \
    \         result.append(max_depth)\n            max_depth = 0\n            current_depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var max_depth_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            depth\
    \ -= 1\n        } else if char == \" \" {\n            max_depth_list.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    max_depth_list.append(max_depth)\n\
    \    return max_depth_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depths = [Int]()\n    var depth = 0\n    for paren in paren_string {\n\
    \        if paren == \"(\" {\n            depth += 1\n            max_depth =\
    \ max(max_depth, depth)\n            paren_stack.push(paren)\n        } else if\
    \ paren == \")\" {\n            depth -= 1\n            paren_stack.pop()\n  \
    \          if paren_stack.isEmpty() {\n                depths.append(max_depth)\n\
    \                max_depth = 0\n            }\n        }\n    }\n    return depths\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp10xr4eo3.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var stack: [Character]\
    \ = []\n        var max_level = 0\n        var current_level = 0\n        for\
    \ char in paren_group.characters {\n            if char == \"(\" {\n         \
    \       current_level += 1\n                max_level = max(max_level, current_level)\n\
    \                stack.append(char)\n            } else if char == \")\" {\n \
    \               current_level -= 1\n                stack.popLast()\n        \
    \    }\n        }\n        result.append(max_level)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmprcudu_73.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_nesting_level\
    \ = 0\n        var current_nesting_level = 0\n        for char in paren_group\
    \ {\n            if char == \"(\" {\n                current_nesting_level +=\
    \ 1\n            } else if char == \")\" {\n                current_nesting_level\
    \ -= 1\n            }\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level\n            }\n\
    \        }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpa3imobrt.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = [Int]()\n    var current_nesting = 0\n   \
    \ var max_current_nesting = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            current_nesting += 1\n            if current_nesting\
    \ > max_current_nesting {\n                max_current_nesting = current_nesting\n\
    \            }\n        } else if char == \")\" {\n            current_nesting\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting.append(max_current_nesting)\n\
    \            max_current_nesting = 0\n            current_nesting = 0\n      \
    \  }\n    }\n    max_nesting.append(max_current_nesting)\n    return max_nesting\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    return max_depths\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp0_9o4r2x.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for paren in paren_string {\n      \
    \  if paren == \"(\" {\n            current_nesting_level += 1\n            if\
    \ current_nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = current_nesting_level\n            }\n        } else if paren == \")\" {\n\
    \            current_nesting_level -= 1\n        } else if paren == \" \" {\n\
    \            max_nesting_levels.append(max_nesting_level)\n            max_nesting_level\
    \ = 0\n            current_nesting_level = 0\n        }\n    }\n    return max_nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmp9k8rbwif/tmp9k8rbwif.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb33c5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb33952b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb33952988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb339517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9k8rbwif                        0x000055fed2c6a68e <unavailable> + 5774

    5    libc.so.6                          0x00002abb33e47460 __libc_start_main +
    245

    6    tmp9k8rbwif                        0x000055fed2c6a2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_depth = 0\n       \
    \ var current_depth = 0\n        for char in group.characters {\n            if\
    \ char == \"(\" {\n                current_depth += 1\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth\n             \
    \   }\n            } else if char == \")\" {\n                current_depth -=\
    \ 1\n            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpqq38ro4f.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nested_parens = [Int]()\n    var current_nested_parens\
    \ = 0\n    var max_current_nested_parens = 0\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            current_nested_parens += 1\n        \
    \    if current_nested_parens > max_current_nested_parens {\n                max_current_nested_parens\
    \ = current_nested_parens\n            }\n        } else if char == \")\" {\n\
    \            current_nested_parens -= 1\n        } else if char == \" \" {\n \
    \           max_nested_parens.append(max_current_nested_parens)\n            max_current_nested_parens\
    \ = 0\n            current_nested_parens = 0\n        }\n    }\n    max_nested_parens.append(max_current_nested_parens)\n\
    \    return max_nested_parens\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var current_depth = 0\n    var max_depths\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth += 1\n            if current_depth > max_depth {\n    \
    \            max_depth = current_depth\n            }\n        } else if char\
    \ == \")\" {\n            current_depth -= 1\n        } else if char == \" \"\
    \ {\n            max_depths.append(max_depth)\n            max_depth = 0\n   \
    \         current_depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var stack = Stack<Character>()\n\
    \        var max_depth = 0\n        var depth = 0\n        for paren in paren_group\
    \ {\n            if paren == \"(\" {\n                stack.push(paren)\n    \
    \            depth += 1\n                if depth > max_depth {\n            \
    \        max_depth = depth\n                }\n            } else if paren ==\
    \ \")\" {\n                if stack.isEmpty() {\n                    print(\"\
    Invalid paren group: \\(paren_group)\")\n                    break\n         \
    \       }\n                stack.pop()\n                depth -= 1\n         \
    \   }\n        }\n        if !stack.isEmpty() {\n            print(\"Invalid paren\
    \ group: \\(paren_group)\")\n        }\n        result.append(max_depth)\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpqszo39uu.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpqszo39uu.swift:11:21:\
    \ error: cannot find 'Stack' in scope\n        var stack = Stack<Character>()\n\
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_levels = [Int]()\n    var paren_stack = [Character]()\n\
    \    var current_level = 0\n    for char in paren_string {\n        if char ==\
    \ \"(\" {\n            paren_stack.append(char)\n            current_level +=\
    \ 1\n        } else if char == \")\" {\n            paren_stack.removeLast()\n\
    \            current_level -= 1\n        } else if char == \" \" {\n         \
    \   paren_levels.append(current_level)\n        }\n    }\n    return paren_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmpa1ruchnb/tmpa1ruchnb.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3fb508bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3fb4d82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3fb4d82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3fb4d817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa1ruchnb                        0x00005652b53a382e <unavailable> + 6190

    5    libc.so.6                          0x00002b3fb5277460 __libc_start_main +
    245

    6    tmpa1ruchnb                        0x00005652b53a3449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    current_depth += 1\n            if current_depth > max_depth {\n        \
    \        max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            paren_stack.pop()\n            current_depth -= 1\n       \
    \ } else if char == \" \" {\n            if paren_stack.isEmpty() {\n        \
    \        result.append(max_depth)\n                max_depth = 0\n           \
    \     current_depth = 0\n            }\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmphdf8v5ly.swift:9:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var depths = [Int]()\n\
    \    for c in paren_string {\n        if c == \"(\" {\n            depth += 1\n\
    \            if depth > max_depth {\n                max_depth = depth\n     \
    \       }\n        } else if c == \")\" {\n            depth -= 1\n        } else\
    \ if c == \" \" {\n            depths.append(max_depth)\n            max_depth\
    \ = 0\n            depth = 0\n        }\n    }\n    return depths\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmpj411gwb9/tmpj411gwb9.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae038e3ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae038b35b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae038b35988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae038b347b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpj411gwb9                        0x000055557fde868e <unavailable> + 5774

    5    libc.so.6                          0x00002ae03902a460 __libc_start_main +
    245

    6    tmpj411gwb9                        0x000055557fde82a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_nesting =\
    \ 0\n    var nesting_levels = [Int]()\n    for char in paren_string {\n      \
    \  if char == \"(\" {\n            paren_stack.push(char)\n            max_nesting\
    \ += 1\n        } else if char == \")\" {\n            paren_stack.pop()\n   \
    \         if paren_stack.isEmpty() {\n                nesting_levels.append(max_nesting)\n\
    \                max_nesting = 0\n            }\n        }\n    }\n    return\
    \ nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpx16u5jhp.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting = [Int]()\n    for paren_group in paren_groups {\n    \
    \    var current_nesting = 0\n        var max_nesting_in_group = 0\n        for\
    \ char in paren_group.characters {\n            if char == \"(\" {\n         \
    \       current_nesting += 1\n            } else if char == \")\" {\n        \
    \        current_nesting -= 1\n            }\n            if current_nesting >\
    \ max_nesting_in_group {\n                max_nesting_in_group = current_nesting\n\
    \            }\n        }\n        max_nesting.append(max_nesting_in_group)\n\
    \    }\n    return max_nesting\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpq5oxx2ih.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depths = [Int]()\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    current_depth += 1\n            if current_depth > max_depth {\n        \
    \        max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            paren_stack.pop()\n            current_depth -= 1\n       \
    \ } else if char == \" \" {\n            depths.append(max_depth)\n          \
    \  max_depth = 0\n            current_depth = 0\n        }\n    }\n    depths.append(max_depth)\n\
    \    return depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpk4hf82t8.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9xn5rv8d.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let groups = paren_string.split(separator:\
    \ \" \")\n    for group in groups {\n        var max_depth = 0\n        var depth\
    \ = 0\n        for char in group {\n            if char == \"(\" {\n         \
    \       depth += 1\n            } else if char == \")\" {\n                depth\
    \ -= 1\n            }\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        }\n        result.append(max_depth)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels: [Int] = []\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var stack: [Character] = []\n   \
    \     var max_depth = 0\n        for char in group {\n            if char == \"\
    (\" {\n                stack.append(char)\n                max_depth = max(max_depth,\
    \ stack.count)\n            } else if char == \")\" {\n                stack.popLast()\n\
    \            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpvnqxtoni.swift:9:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var current_depth = 0\n    var max_depth_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth += 1\n            if current_depth > max_depth {\n    \
    \            max_depth = current_depth\n            }\n        } else if char\
    \ == \")\" {\n            current_depth -= 1\n        } else if char == \" \"\
    \ {\n            max_depth_list.append(max_depth)\n            max_depth = 0\n\
    \            current_depth = 0\n        }\n    }\n    max_depth_list.append(max_depth)\n\
    \    return max_depth_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var results: [Int] = []\n    var current_level = 0\n    var\
    \ max_level = 0\n    for char in paren_string {\n        if char == \"(\" {\n\
    \            current_level += 1\n            if current_level > max_level {\n\
    \                max_level = current_level\n            }\n        } else if char\
    \ == \")\" {\n            current_level -= 1\n        } else if char == \" \"\
    \ {\n            results.append(max_level)\n            max_level = 0\n      \
    \      current_level = 0\n        }\n    }\n    results.append(max_level)\n  \
    \  return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_levels = [Int]()\n    var\
    \ current_nesting = 0\n    for paren in paren_string {\n        if paren == \"\
    (\" {\n            current_nesting += 1\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting\n            }\n        } else\
    \ if paren == \")\" {\n            nesting_levels.append(current_nesting)\n  \
    \          current_nesting -= 1\n        }\n    }\n    return nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmptwtnrbyl/tmptwtnrbyl.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac949aebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac9497e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac9497e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9497e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptwtnrbyl                        0x000056076b30668e <unavailable> + 5774

    5    libc.so.6                          0x00002ac949cd7460 __libc_start_main +
    245

    6    tmptwtnrbyl                        0x000056076b3062a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9xn5rv8d.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var stack = Stack<Character>()\n \
    \   var max_depth = 0\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.push(char)\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    stack.pop()\n            current_depth -= 1\n        } else if char == \"\
    \ \" {\n            result.append(max_depth)\n            max_depth = 0\n    \
    \        current_depth = 0\n        }\n    }\n    result.append(max_depth)\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpbxxa_601.swift:9:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depths = [Int]()\n    var depth = 0\n    for paren in paren_string {\n\
    \        if paren == \"(\" {\n            paren_stack.push(paren)\n          \
    \  depth += 1\n            if depth > max_depth {\n                max_depth =\
    \ depth\n            }\n        } else if paren == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if paren == \" \" {\n            depths.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    depths.append(max_depth)\n\
    \    return depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp3ff387ru.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var nesting_level = 0\n\
    \        var max_nesting_level = 0\n        for char in paren_group {\n      \
    \      if char == \"(\" {\n                nesting_level += 1\n            } else\
    \ if char == \")\" {\n                nesting_level -= 1\n            }\n    \
    \        if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp8zhsypb9.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var max_depth = 0\n    var current_depth\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_depth += 1\n            if current_depth > max_depth {\n          \
    \      max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            current_depth -= 1\n        } else if char == \" \" {\n   \
    \         result.append(max_depth)\n            max_depth = 0\n            current_depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_depth = 0\n       \
    \ var depth = 0\n        for char in group {\n            if char == \"(\" {\n\
    \                depth += 1\n            } else if char == \")\" {\n         \
    \       depth -= 1\n            }\n            if depth > max_depth {\n      \
    \          max_depth = depth\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpcdf2j5mb.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var paren_stack = [Character]()\n\
    \        var max_depth = 0\n        var depth = 0\n        for paren in paren_group\
    \ {\n            if paren == \"(\" {\n                paren_stack.append(paren)\n\
    \                depth += 1\n                if depth > max_depth {\n        \
    \            max_depth = depth\n                }\n            } else if paren\
    \ == \")\" {\n                if paren_stack.count > 0 {\n                   \
    \ paren_stack.removeLast()\n                    depth -= 1\n                }\n\
    \            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp6adkbrac.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    for paren in paren_string\
    \ {\n        if paren == \"(\" {\n            paren_stack.push(paren)\n      \
    \      depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if paren == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    return max_depths\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpkq_68uve.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var paren_stack = Stack<Character>()\n\
    \    for c in paren_string {\n        if c == \"(\" {\n            paren_stack.push(c)\n\
    \            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if c == \")\" {\n            paren_stack.pop()\n\
    \            current_nesting_level -= 1\n        } else if c == \" \" {\n    \
    \        max_nesting_levels.append(max_nesting_level)\n            max_nesting_level\
    \ = 0\n            current_nesting_level = 0\n        }\n    }\n    max_nesting_levels.append(max_nesting_level)\n\
    \    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpc_oxvh8i.swift:11:23: error: cannot find 'Stack' in scope\n   \
    \ var paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    let paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting = [Int]()\n    for group in paren_groups {\n        var\
    \ current_nesting = 0\n        var max_nesting_in_group = 0\n        for char\
    \ in group.characters {\n            if char == \"(\" {\n                current_nesting\
    \ += 1\n            } else if char == \")\" {\n                current_nesting\
    \ -= 1\n            }\n            if current_nesting > max_nesting_in_group {\n\
    \                max_nesting_in_group = current_nesting\n            }\n     \
    \   }\n        max_nesting.append(max_nesting_in_group)\n    }\n    return max_nesting\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpz7zdimno.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var current_level: Int = 0\n   \
    \ var max_level: Int = 0\n    for char in paren_string {\n        if char == \"\
    (\" {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == \")\" {\n            current_level -= 1\n        } else if char ==\
    \ \" \" {\n            result.append(max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var count = 0\n        var\
    \ max_count = 0\n        for char in group {\n            if char == \"(\" {\n\
    \                count += 1\n            } else if char == \")\" {\n         \
    \       count -= 1\n            }\n            if count > max_count {\n      \
    \          max_count = count\n            }\n        }\n        result.append(max_count)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpf8_i4f2j.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var max_depths = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            depth -= 1\n  \
    \      } else if char == \" \" {\n            max_depths.append(max_depth)\n \
    \           max_depth = 0\n            depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var max_nesting_level = 0\n     \
    \   var nesting_level = 0\n        for char in group {\n            if char ==\
    \ \"(\" {\n                nesting_level += 1\n            } else if char == \"\
    )\" {\n                nesting_level -= 1\n            }\n            if nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = nesting_level\n \
    \           }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpxdekguvz.swift:9:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var max_nesting_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            max_nesting_list.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    max_nesting_list.append(max_nesting)\n\
    \    return max_nesting_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    let groups = paren_string.components(separatedBy: \" \")\n \
    \   var max_nesting_levels = [Int]()\n    for group in groups {\n        var nesting_level\
    \ = 0\n        var max_nesting_level = 0\n        for char in group {\n      \
    \      if char == \"(\" {\n                nesting_level += 1\n            } else\
    \ if char == \")\" {\n                nesting_level -= 1\n            }\n    \
    \        if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp1rfl54qe.swift:8:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var current_level = 0\n    var max_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.split(separator:\
    \ \" \")\n    for group in paren_groups {\n        var nesting_level = 0\n   \
    \     var max_nesting_level = 0\n        for char in group {\n            if char\
    \ == \"(\" {\n                nesting_level += 1\n            } else if char ==\
    \ \")\" {\n                nesting_level -= 1\n            }\n            if nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = nesting_level\n \
    \           }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var paren_stack: [Character] = []\n\
    \    var max_depth: Int = 0\n    var depth: Int = 0\n    for c in paren_string\
    \ {\n        if c == \"(\" {\n            paren_stack.append(c)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if c == \")\" {\n            if paren_stack.count\
    \ == 0 {\n                return []\n            }\n            paren_stack.removeLast()\n\
    \            depth -= 1\n        } else if c == \" \" {\n            if paren_stack.count\
    \ == 0 {\n                result.append(max_depth)\n                max_depth\
    \ = 0\n                depth = 0\n            }\n        }\n    }\n    if paren_stack.count\
    \ == 0 {\n        result.append(max_depth)\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var results: [Int] = []\n    var open_parens: Int = 0\n    var\
    \ max_open_parens: Int = 0\n    for char in paren_string {\n        if char ==\
    \ \"(\" {\n            open_parens += 1\n            if open_parens > max_open_parens\
    \ {\n                max_open_parens = open_parens\n            }\n        } else\
    \ if char == \")\" {\n            open_parens -= 1\n        } else if char ==\
    \ \" \" {\n            results.append(max_open_parens)\n            max_open_parens\
    \ = 0\n            open_parens = 0\n        }\n    }\n    results.append(max_open_parens)\n\
    \    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for group in paren_groups {\n   \
    \     var max_nesting_level = 0\n        var current_nesting_level = 0\n     \
    \   for char in group.characters {\n            if char == \"(\" {\n         \
    \       current_nesting_level += 1\n            } else if char == \")\" {\n  \
    \              current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpehichpnm.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var depth_stack = Stack<Int>()\n    var max_depth = 0\n    var\
    \ depth_list = [Int]()\n    for char in paren_string {\n        if char == \"\
    (\" {\n            depth_stack.push(1)\n        } else if char == \")\" {\n  \
    \          if depth_stack.isEmpty() {\n                depth_list.append(max_depth)\n\
    \                max_depth = 0\n            } else {\n                let depth\
    \ = depth_stack.pop()!\n                max_depth = max(max_depth, depth)\n  \
    \          }\n        }\n    }\n    return depth_list\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpg7n4g_36.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ depth_stack = Stack<Int>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    return max_depths\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp0_9o4r2x.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var depth = 0\n        for char in paren_group {\n            if char\
    \ == \"(\" {\n                depth += 1\n            } else if char == \")\"\
    \ {\n                depth -= 1\n            }\n            if depth > max_depth\
    \ {\n                max_depth = depth\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp8h3us746.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var depths = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    depths.append(max_depth)\n                max_depth = 0\n               \
    \ depth = 0\n            }\n        }\n    }\n    return depths\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpuj3x8xdr.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var max_depth = 0\n       \
    \ var current_depth = 0\n        for char in group.characters {\n            if\
    \ char == \"(\" {\n                current_depth += 1\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth\n             \
    \   }\n            } else if char == \")\" {\n                current_depth -=\
    \ 1\n            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpqq38ro4f.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups {\n\
    \        var max_nesting_level = 0\n        var current_nesting_level = 0\n  \
    \      for paren in paren_group {\n            if paren == \"(\" {\n         \
    \       current_nesting_level += 1\n            } else if paren == \")\" {\n \
    \               current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp6_6rktsu.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    let paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var paren_counts = [Int]()\n    for paren_group in paren_groups {\n   \
    \     var paren_stack = [Character]()\n        var max_count = 0\n        var\
    \ current_count = 0\n        for paren in paren_group {\n            if paren\
    \ == \"(\" {\n                paren_stack.append(paren)\n                current_count\
    \ += 1\n                if current_count > max_count {\n                    max_count\
    \ = current_count\n                }\n            } else if paren == \")\" {\n\
    \                if paren_stack.last == \"(\" {\n                    paren_stack.removeLast()\n\
    \                    current_count -= 1\n                }\n            }\n  \
    \      }\n        paren_counts.append(max_count)\n    }\n    return paren_counts\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpchouo2vj.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var nesting_level = 0\n   \
    \     var max_nesting_level = 0\n        for char in group.characters {\n    \
    \        if char == \"(\" {\n                nesting_level += 1\n            }\
    \ else if char == \")\" {\n                nesting_level -= 1\n            }\n\
    \            if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpumne1tce.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_levels = [Int]()\n    var paren_level = 0\n    var\
    \ paren_group = \"\"\n    for char in paren_string {\n        if char == \" \"\
    \ {\n            paren_levels.append(paren_level)\n            paren_level = 0\n\
    \            paren_group = \"\"\n        } else {\n            paren_group.append(char)\n\
    \            if char == \"(\" {\n                paren_level += 1\n          \
    \  } else if char == \")\" {\n                paren_level -= 1\n            }\n\
    \        }\n    }\n    paren_levels.append(paren_level)\n    return paren_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmpgirn6nx3/tmpgirn6nx3.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acef589fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acef5596b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acef5596988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acef55957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgirn6nx3                        0x0000563ff36096ee <unavailable> + 5870

    5    libc.so.6                          0x00002acef5a8b460 __libc_start_main +
    245

    6    tmpgirn6nx3                        0x0000563ff3609309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.split(separator: \" \")\n  \
    \  var paren_levels = [Int]()\n    for paren_group in paren_groups {\n       \
    \ var paren_level = 0\n        var max_level = 0\n        for paren in paren_group\
    \ {\n            if paren == \"(\" {\n                paren_level += 1\n     \
    \       } else if paren == \")\" {\n                paren_level -= 1\n       \
    \     }\n            if paren_level > max_level {\n                max_level =\
    \ paren_level\n            }\n        }\n        paren_levels.append(max_level)\n\
    \    }\n    return paren_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var current_max: Int = 0\n    var\
    \ current_count: Int = 0\n    for char in paren_string {\n        if char == \"\
    (\" {\n            current_count += 1\n            if current_count > current_max\
    \ {\n                current_max = current_count\n            }\n        } else\
    \ if char == \")\" {\n            current_count -= 1\n        } else if char ==\
    \ \" \" {\n            result.append(current_max)\n            current_max = 0\n\
    \            current_count = 0\n        }\n    }\n    result.append(current_max)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result: [Int] = []\n    var paren_stack: [Character] = []\n\
    \    var max_depth: Int = 0\n    var current_depth: Int = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.append(char)\n      \
    \      current_depth += 1\n            if current_depth > max_depth {\n      \
    \          max_depth = current_depth\n            }\n        } else if char ==\
    \ \")\" {\n            if paren_stack.count > 0 {\n                paren_stack.removeLast()\n\
    \                current_depth -= 1\n            }\n        } else if char ==\
    \ \" \" {\n            if paren_stack.count == 0 {\n                result.append(max_depth)\n\
    \                max_depth = 0\n                current_depth = 0\n          \
    \  }\n        }\n    }\n    if paren_stack.count == 0 {\n        result.append(max_depth)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting = [Int]()\n    for paren_group in paren_groups {\n    \
    \    var max_nesting_level = 0\n        var current_nesting_level = 0\n      \
    \  for char in paren_group.characters {\n            if char == \"(\" {\n    \
    \            current_nesting_level += 1\n            } else if char == \")\" {\n\
    \                current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting.append(max_nesting_level)\n   \
    \ }\n    return max_nesting\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmplh5a60cx.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_level = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        nesting_level += 1\n            if nesting_level > max_nesting {\n  \
    \              max_nesting = nesting_level\n            }\n        } else if char\
    \ == \")\" {\n            nesting_level -= 1\n        } else if char == \" \"\
    \ {\n            result.append(max_nesting)\n            max_nesting = 0\n   \
    \         nesting_level = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var stack = Stack<Character>()\n \
    \   var max_depth = 0\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.push(char)\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    stack.pop()\n            current_depth -= 1\n        } else if char == \"\
    \ \" {\n            result.append(max_depth)\n            max_depth = 0\n    \
    \        current_depth = 0\n        }\n    }\n    result.append(max_depth)\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpbxxa_601.swift:9:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for group in paren_groups {\n   \
    \     var current_nesting_level = 0\n        var max_nesting_level = 0\n     \
    \   for char in group.characters {\n            if char == \"(\" {\n         \
    \       current_nesting_level += 1\n            } else if char == \")\" {\n  \
    \              current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpm_o36rms.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            max_depth = max(max_depth, depth)\n        } else if char\
    \ == \")\" {\n            depth -= 1\n        } else if char == \" \" {\n    \
    \        result.append(max_depth)\n            max_depth = 0\n            depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: Exception
  stderr: 'tmp4o2ivye9/tmp4o2ivye9.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cd5f9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cd5c91b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6cd5c91988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6cd5c907b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4o2ivye9                        0x0000559f7e31768e <unavailable> + 5774

    5    libc.so.6                          0x00002b6cd6186460 __libc_start_main +
    245

    6    tmp4o2ivye9                        0x0000559f7e3172a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    for paren in paren_string\
    \ {\n        if paren == \"(\" {\n            paren_stack.push(paren)\n      \
    \      depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if paren == \")\" {\n            if paren_stack.peek()\
    \ == \"(\" {\n                paren_stack.pop()\n                depth -= 1\n\
    \                max_depths.append(max_depth)\n                max_depth = 0\n\
    \            }\n        }\n    }\n    return max_depths\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmporjm3yxg.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        result.append(parse_nested_parens_helper(paren_string:\
    \ paren_group))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\"\
    ) == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((()))\
    \ (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpkjy45nxd.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var stack = Stack<Character>()\n    var max_depth = 0\n    var\
    \ depths = [Int]()\n    var depth = 0\n    for c in paren_string {\n        if\
    \ c == \"(\" {\n            stack.push(c)\n            depth += 1\n          \
    \  if depth > max_depth {\n                max_depth = depth\n            }\n\
    \        } else if c == \")\" {\n            stack.pop()\n            depth -=\
    \ 1\n            if stack.isEmpty() {\n                depths.append(max_depth)\n\
    \                max_depth = 0\n                depth = 0\n            }\n   \
    \     }\n    }\n    return depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpjlgpecv9.swift:8:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var current_nesting = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting = 0\n    var nesting_level = 0\n    var max_nesting_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        nesting_level += 1\n            if nesting_level > max_nesting {\n  \
    \              max_nesting = nesting_level\n            }\n        } else if char\
    \ == \")\" {\n            nesting_level -= 1\n        } else if char == \" \"\
    \ {\n            max_nesting_list.append(max_nesting)\n            max_nesting\
    \ = 0\n            nesting_level = 0\n        }\n    }\n    max_nesting_list.append(max_nesting)\n\
    \    return max_nesting_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_nesting =\
    \ 0\n    var nesting_levels = [Int]()\n    for paren in paren_string {\n     \
    \   if paren == \"(\" {\n            paren_stack.push(paren)\n            max_nesting\
    \ += 1\n        } else if paren == \")\" {\n            paren_stack.pop()\n  \
    \          if paren_stack.isEmpty() {\n                nesting_levels.append(max_nesting)\n\
    \                max_nesting = 0\n            }\n        }\n    }\n    return\
    \ nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpivmk_2sb.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_nesting_level\
    \ = 0\n        var current_nesting_level = 0\n        for paren in paren_group\
    \ {\n            if paren == \"(\" {\n                current_nesting_level +=\
    \ 1\n            } else if paren == \")\" {\n                current_nesting_level\
    \ -= 1\n            }\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level\n            }\n\
    \        }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp_1zy7laa.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_nesting_level\
    \ = 0\n        var current_nesting_level = 0\n        for paren in paren_group\
    \ {\n            if paren == \"(\" {\n                current_nesting_level +=\
    \ 1\n            } else if paren == \")\" {\n                current_nesting_level\
    \ -= 1\n            }\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level\n            }\n\
    \        }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp_1zy7laa.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var depths = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            depth -= 1\n  \
    \      } else if char == \" \" {\n            depths.append(max_depth)\n     \
    \       max_depth = 0\n            depth = 0\n        }\n    }\n    depths.append(max_depth)\n\
    \    return depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824873
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack: [Character] = []\n    var max_depth: Int =\
    \ 0\n    var depth_list: [Int] = []\n    var depth: Int = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.append(char)\n      \
    \      depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.popLast()\n\
    \            depth_list.append(depth)\n            depth -= 1\n        } else\
    \ if char == \" \" {\n            depth_list.append(depth)\n        }\n    }\n\
    \    return depth_list\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmp6k3rbya3/tmp6k3rbya3.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b144f2dac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b144efd1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b144efd1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b144efd07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6k3rbya3                        0x000055a7d61907be <unavailable> + 6078

    5    libc.so.6                          0x00002b144f4c6460 __libc_start_main +
    245

    6    tmp6k3rbya3                        0x000055a7d61903d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for group in paren_groups {\n   \
    \     var nesting_level = 0\n        var max_nesting_level = 0\n        for char\
    \ in group.characters {\n            if char == \"(\" {\n                nesting_level\
    \ += 1\n            } else if char == \")\" {\n                nesting_level -=\
    \ 1\n            }\n            if nesting_level > max_nesting_level {\n     \
    \           max_nesting_level = nesting_level\n            }\n        }\n    \
    \    max_nesting_levels.append(max_nesting_level)\n    }\n    return max_nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9ues643u.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var max_depths = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            depth -= 1\n  \
    \      } else if char == \" \" {\n            max_depths.append(max_depth)\n \
    \           max_depth = 0\n            depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    return max_depths\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp0_9o4r2x.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824871
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_nesting = 0\n\
    \        var current_nesting = 0\n        for char in paren_group {\n        \
    \    if char == \"(\" {\n                current_nesting += 1\n            } else\
    \ if char == \")\" {\n                current_nesting -= 1\n            }\n  \
    \          if current_nesting > max_nesting {\n                max_nesting = current_nesting\n\
    \            }\n        }\n        result.append(max_nesting)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmprukh_004.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_counts = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var paren_count = 0\n\
    \        var max_paren_count = 0\n        for char in paren_group.characters {\n\
    \            if char == \"(\" {\n                paren_count += 1\n          \
    \  } else if char == \")\" {\n                paren_count -= 1\n            }\n\
    \            if paren_count > max_paren_count {\n                max_paren_count\
    \ = paren_count\n            }\n        }\n        paren_counts.append(max_paren_count)\n\
    \    }\n    return paren_counts\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpz59fe0ns.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.split(separator:\
    \ \" \")\n    for paren_group in paren_groups {\n        var count = 0\n     \
    \   var max_count = 0\n        for char in paren_group {\n            if char\
    \ == \"(\" {\n                count += 1\n            } else if char == \")\"\
    \ {\n                count -= 1\n            }\n            if count > max_count\
    \ {\n                max_count = count\n            }\n        }\n        result.append(max_count)\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var current_depth = 0\n        for char in paren_group {\n           \
    \ if char == \"(\" {\n                current_depth += 1\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth\n             \
    \   }\n            } else if char == \")\" {\n                current_depth -=\
    \ 1\n            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpacflnvba.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var max_level = 0\n        var level\
    \ = 0\n        for char in group {\n            if char == \"(\" {\n         \
    \       level += 1\n            } else if char == \")\" {\n                level\
    \ -= 1\n            }\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        }\n        result.append(max_level)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmprn82pvyy.swift:9:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var stack = Stack<Character>()\n    var max_depth = 0\n    var\
    \ depths = [Int]()\n    var current_depth = 0\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            stack.push(char)\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    stack.pop()\n            current_depth -= 1\n            if stack.isEmpty()\
    \ {\n                depths.append(max_depth)\n                max_depth = 0\n\
    \                current_depth = 0\n            }\n        }\n    }\n    return\
    \ depths\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpm9irkx6c.swift:8:17: error: cannot find 'Stack' in scope\n    var\
    \ stack = Stack<Character>()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var is_open_paren = false\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            is_open_paren = true\n\
    \            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            is_open_paren =\
    \ false\n            current_nesting_level -= 1\n        } else if char == \"\
    \ \" && !is_open_paren {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var stack = Stack<Character>()\n\
    \        var max_depth = 0\n        var depth = 0\n        for char in paren_group\
    \ {\n            if char == \"(\" {\n                stack.push(char)\n      \
    \          depth += 1\n                if depth > max_depth {\n              \
    \      max_depth = depth\n                }\n            } else if char == \"\
    )\" {\n                if stack.isEmpty() {\n                    break\n     \
    \           }\n                stack.pop()\n                depth -= 1\n     \
    \       }\n        }\n        result.append(max_depth)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpfkg746v7.swift:9:37: error: value of type 'String' has no member\
    \ 'components'\n    let paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpfkg746v7.swift:11:21:\
    \ error: cannot find 'Stack' in scope\n        var stack = Stack<Character>()\n\
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups {\n\
    \        var current_nesting_level = 0\n        var max_nesting_level = 0\n  \
    \      for paren in paren_group {\n            if paren == \"(\" {\n         \
    \       current_nesting_level += 1\n            } else if paren == \")\" {\n \
    \               current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpxvmwup4k.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_depth = 0\n    var depth = 0\n    var results = [Int]()\n\
    \    for c in paren_string {\n        if c == \"(\" {\n            depth += 1\n\
    \            if depth > max_depth {\n                max_depth = depth\n     \
    \       }\n        } else if c == \")\" {\n            depth -= 1\n        } else\
    \ if c == \" \" {\n            results.append(max_depth)\n            max_depth\
    \ = 0\n            depth = 0\n        }\n    }\n    results.append(max_depth)\n\
    \    return results\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmp9xn5rv8d.swift:8:23: error: cannot find 'Stack' in scope\n    var\
    \ paren_stack = Stack<Character>()\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var paren_stack = [Character]()\n\
    \    var max_depth = 0\n    var depth = 0\n    for char in paren_string {\n  \
    \      if char == \"(\" {\n            paren_stack.append(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.removeLast()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var nesting_level = 0\n        var\
    \ max_nesting_level = 0\n        for char in group {\n            if char == \"\
    (\" {\n                nesting_level += 1\n            } else if char == \")\"\
    \ {\n                nesting_level -= 1\n            }\n            if nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = nesting_level\n \
    \           }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpd0za2apy.swift:9:31: error: value of type 'String' has no member\
    \ 'components'\n    let groups = paren_string.components(separatedBy: \" \")\n\
    \                 ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824872
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for group in paren_groups {\n   \
    \     var max_level = 0\n        var current_level = 0\n        for char in group.characters\
    \ {\n            if char == \"(\" {\n                current_level += 1\n    \
    \        } else if char == \")\" {\n                current_level -= 1\n     \
    \       }\n            if current_level > max_level {\n                max_level\
    \ = current_level\n            }\n        }\n        max_nesting_levels.append(max_level)\n\
    \    }\n    return max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(parse_nested_parens(paren_string: \"(()()) ((())) () ((())()())\") == [2,\
    \ 3, 1, 3])\nassert(parse_nested_parens(paren_string: \"() (()) ((())) (((())))\"\
    ) == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string: \"(()(())((())))\"\
    ) == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpdhob4efc.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups {\n\
    \        var nesting_level = 0\n        var max_nesting_level = 0\n        for\
    \ char in paren_group.characters {\n            if char == \"(\" {\n         \
    \       nesting_level += 1\n            } else if char == \")\" {\n          \
    \      nesting_level -= 1\n            }\n            if nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = nesting_level\n            }\n      \
    \  }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpdfkkihee.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824871
- exit_code: -4
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var is_open_paren = false\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            current_nesting_level\
    \ += 1\n            is_open_paren = true\n        } else if char == \")\" {\n\
    \            if is_open_paren {\n                max_nesting_level = max(max_nesting_level,\
    \ current_nesting_level)\n            }\n            current_nesting_level -=\
    \ 1\n            is_open_paren = false\n        } else if char == \" \" {\n  \
    \          max_nesting_levels.append(max_nesting_level)\n            max_nesting_level\
    \ = 0\n            current_nesting_level = 0\n        }\n    }\n    return max_nesting_levels\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: Exception
  stderr: 'tmppb8n6ejb/tmppb8n6ejb.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5876288c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5875f7fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5875f7f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5875f7e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppb8n6ejb                        0x000055b76e46971e <unavailable> + 5918

    5    libc.so.6                          0x00002b5876474460 __libc_start_main +
    245

    6    tmppb8n6ejb                        0x000055b76e469339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659824873
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var result = [Int]()\n    var max_depth = 0\n    var current_depth\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_depth += 1\n            if current_depth > max_depth {\n          \
    \      max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            current_depth -= 1\n        } else if char == \" \" {\n   \
    \         result.append(max_depth)\n            max_depth = 0\n            current_depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824872
- exit_code: 0
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_levels: [Int] = []\n    var paren_level = 0\n    var\
    \ paren_stack: [Character] = []\n    var paren_group = \"\"\n    for char in paren_string\
    \ {\n        if char == \" \" {\n            paren_levels.append(paren_level)\n\
    \            paren_level = 0\n            paren_stack = []\n            paren_group\
    \ = \"\"\n        } else {\n            paren_group.append(char)\n           \
    \ if char == \"(\" {\n                paren_stack.append(char)\n             \
    \   paren_level = max(paren_level, paren_stack.count)\n            } else if char\
    \ == \")\" {\n                paren_stack.removeLast()\n            }\n      \
    \  }\n    }\n    paren_levels.append(paren_level)\n    return paren_levels\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()()) ((()))\
    \ () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659824873
- exit_code: 1
  program: "\n/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
    \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
    \ -> [Int] {\n    var paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    var max_nesting = [Int]()\n    for paren_group in paren_groups {\n    \
    \    var current_nesting = 0\n        var max_nesting_so_far = 0\n        for\
    \ char in paren_group.characters {\n            if char == \"(\" {\n         \
    \       current_nesting += 1\n            } else if char == \")\" {\n        \
    \        current_nesting -= 1\n            }\n            if current_nesting >\
    \ max_nesting_so_far {\n                max_nesting_so_far = current_nesting\n\
    \            }\n        }\n        max_nesting.append(max_nesting_so_far)\n  \
    \  }\n    return max_nesting\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(parse_nested_parens(paren_string:\
    \ \"(()()) ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
    \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
    \ \"(()(())((())))\") == [4])"
  status: SyntaxError
  stderr: "/tmp/tmpupl6m12z.swift:8:37: error: value of type 'String' has no member\
    \ 'components'\n    var paren_groups = paren_string.components(separatedBy: \"\
    \ \")\n                       ~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824873
