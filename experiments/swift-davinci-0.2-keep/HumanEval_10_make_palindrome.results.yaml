language: swift
name: HumanEval_10_make_palindrome
results:
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_common_suffix = longest_common_substring(string,\
    \ reversed)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_common_suffix.characters.count))\n    return string + String(prefix.characters.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpf5yl6pft.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpf5yl6pft.swift:14:33: error:\
    \ cannot find 'longest_common_substring' in scope\n    let longest_common_suffix\
    \ = longest_common_substring(string, reversed)\n                             \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpf5yl6pft.swift:15:25: error: value of type\
    \ 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_common_suffix.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpf5yl6pft.swift:15:60: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_common_suffix.characters.count))\n                               \
    \          ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    let string_chars_reversed\
    \ = Array(string.characters.reversed())\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n    \
    \    var j = 0\n        while i - j >= 0 && i + j < string_length && string_chars[i\
    \ - j] == string_chars[i + j] {\n            j += 1\n        }\n        if j >\
    \ longest_palindrome_length {\n            longest_palindrome_length = j\n   \
    \         longest_palindrome_start = i - j + 1\n        }\n    }\n    for i in\
    \ 0..<string_length - 1 {\n        var j = 0\n        while i - j >= 0 && i +\
    \ 1 + j < string_length && string_chars[i - j] == string_chars[i + 1 + j] {\n\
    \            j += 1\n        }\n        if j > longest_palindrome_length {\n \
    \           longest_palindrome_length = j\n            longest_palindrome_start\
    \ = i - j + 1\n        }\n    }\n    let prefix_start = longest_palindrome_start\
    \ + longest_palindrome_length\n    let prefix_end = string_length\n    let prefix_length\
    \ = prefix_end - prefix_start\n    let prefix_chars = string_chars[prefix_start..<prefix_end]\n\
    \    let prefix_chars_reversed = string_chars_reversed[prefix_start..<prefix_end]\n\
    \    return string + String(prefix_chars_reversed)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp9d5fpsm1.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp9d5fpsm1.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp9d5fpsm1.swift:18:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars_reversed = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp9d5fpsm1.swift:43:9: warning: initialization\
    \ of immutable value 'prefix_length' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    let prefix_length = prefix_end - prefix_start\n \
    \   ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmp9d5fpsm1.swift:44:9: warning: initialization\
    \ of immutable value 'prefix_chars' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    let prefix_chars = string_chars[prefix_start..<prefix_end]\n\
    \    ~~~~^~~~~~~~~~~~\n    _\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var palindrome_suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string_chars,\
    \ start: i, end: string_length - 1) {\n            palindrome_suffix_length =\
    \ string_length - i\n            break\n        }\n    }\n    let palindrome_prefix_length\
    \ = string_length - palindrome_suffix_length\n    var palindrome_chars = string_chars\n\
    \    for i in 0..<palindrome_prefix_length {\n        palindrome_chars.append(string_chars[palindrome_prefix_length\
    \ - i - 1])\n    }\n    return String(palindrome_chars)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpnygcc6_q.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpnygcc6_q.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpnygcc6_q.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_chars, start: i, end: string_length\
    \ - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters.map { String($0) }\n    let string_length = string.count\n\
    \    if string_length == 0 {\n        return \"\"\n    }\n    var longest_palindrome_suffix\
    \ = [String]()\n    for i in 0..<string_length {\n        var palindrome_suffix\
    \ = [String]()\n        for j in 0..<string_length {\n            if i + j < string_length\
    \ {\n                palindrome_suffix.append(string[i + j])\n            }\n\
    \        }\n        if is_palindrome(palindrome_suffix) {\n            if palindrome_suffix.count\
    \ > longest_palindrome_suffix.count {\n                longest_palindrome_suffix\
    \ = palindrome_suffix\n            }\n        }\n    }\n    var prefix = [String]()\n\
    \    for i in 0..<string_length - longest_palindrome_suffix.count {\n        prefix.append(string[i])\n\
    \    }\n    return prefix.joined(separator: \"\") + longest_palindrome_suffix.joined(separator:\
    \ \"\") + prefix.reversed().joined(separator: \"\")\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5g1ajxpq.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters.map { String($0) }\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5g1ajxpq.swift:26:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(palindrome_suffix) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var i = string_length\
    \ - 1\n    while i >= 0 {\n        if is_palindrome(string_chars, start: 0, end:\
    \ i) {\n            break\n        }\n        i -= 1\n    }\n    var prefix =\
    \ string.substring(to: string.index(string.startIndex, offsetBy: i + 1))\n   \
    \ prefix = String(prefix.characters.reversed())\n    return string + prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp2t0xyuag.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp2t0xyuag.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2t0xyuag.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_chars, start: 0, end: i) {\n     \
    \      ^~~~~~~~~~~~~\n/tmp/tmp2t0xyuag.swift:25:25: error: value of type 'String'\
    \ has no member 'substring'\n    var prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: i + 1))\n                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string_array, index:\
    \ i)\n        if palindrome_length > longest_palindrome_length {\n           \
    \ longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start\n    let prefix = string_array[prefix_start...prefix_end]\n\
    \    let prefix_reversed = prefix.reverse()\n    let palindrome = string + String(prefix_reversed)\n\
    \    return palindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmppzolzf_h.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmppzolzf_h.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmppzolzf_h.swift:21:33: error: cannot find 'palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = palindrome_length_at_index(string_array,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmppzolzf_h.swift:30:34:\
    \ error: cannot use mutating member on immutable value: 'prefix' is a 'let' constant\n\
    \    let prefix_reversed = prefix.reverse()\n                          ~~~~~~\
    \ ^\n/tmp/tmppzolzf_h.swift:29:5: note: change 'let' to 'var' to make it mutable\n\
    \    let prefix = string_array[prefix_start...prefix_end]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    if string_length == 1 {\n        return string\n    }\n    let string_chars\
    \ = Array(string.characters)\n    var longest_palindrome_length = 0\n    var longest_palindrome_start\
    \ = 0\n    for i in 0..<string_length {\n        let palindrome_length = longest_palindrome_length_at(string_chars,\
    \ string_length: string_length, center: i)\n        if palindrome_length > longest_palindrome_length\
    \ {\n            longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start + 1\n    let prefix = String(string_chars[prefix_start..<prefix_end])\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpysh_o12t.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpysh_o12t.swift:20:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpysh_o12t.swift:24:33: error: cannot find 'longest_palindrome_length_at'\
    \ in scope\n        let palindrome_length = longest_palindrome_length_at(string_chars,\
    \ string_length: string_length, center: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpysh_o12t.swift:33:52: error: value of type 'String' has no member 'reverse'\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n             \
    \                    ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        var j = 0\n        while i - j >= 0 && i + j < string_length && string_chars[i\
    \ - j] == string_chars[i + j] {\n            j += 1\n        }\n        if j >\
    \ longest_palindrome_length {\n            longest_palindrome_length = j\n   \
    \         longest_palindrome_start = i - j + 1\n        }\n    }\n    var result\
    \ = string\n    for i in 0..<string_length - longest_palindrome_length {\n   \
    \     result.append(string_chars[string_length - 1 - i])\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxmcdlsf4.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpxmcdlsf4.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpxmcdlsf4.swift:19:9: warning: variable 'longest_palindrome_start'\
    \ was written to, but never read\n    var longest_palindrome_start = 0\n     \
    \   ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let string_length = string.characters.count\n\
    \    let string_array = Array(string.characters)\n    var max_palindrome_length\
    \ = 0\n    var max_palindrome_index = 0\n    for i in 0..<string_length {\n  \
    \      let palindrome_length = get_palindrome_length(string_array, i)\n      \
    \  if palindrome_length > max_palindrome_length {\n            max_palindrome_length\
    \ = palindrome_length\n            max_palindrome_index = i\n        }\n    }\n\
    \    let prefix_length = string_length - max_palindrome_length\n    let prefix\
    \ = string_array[0..<prefix_length]\n    let prefix_reversed = prefix.reverse()\n\
    \    return string + String(prefix_reversed)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp02j9ai_2.swift:16:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp02j9ai_2.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp02j9ai_2.swift:21:33: error: cannot find 'get_palindrome_length'\
    \ in scope\n        let palindrome_length = get_palindrome_length(string_array,\
    \ i)\n                                ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp02j9ai_2.swift:29:34:\
    \ error: cannot use mutating member on immutable value: 'prefix' is a 'let' constant\n\
    \    let prefix_reversed = prefix.reverse()\n                          ~~~~~~\
    \ ^\n/tmp/tmp02j9ai_2.swift:28:5: note: change 'let' to 'var' to make it mutable\n\
    \    let prefix = string_array[0..<prefix_length]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_length = string.count\n    if string_length\
    \ == 0 {\n        return \"\"\n    }\n    var palindrome_suffix_length = 0\n \
    \   for i in 0..<string_length {\n        if is_palindrome(string, start: i, end:\
    \ string_length - 1) {\n            palindrome_suffix_length = string_length -\
    \ i\n            break\n        }\n    }\n    var result = string\n    for i in\
    \ 0..<string_length - palindrome_suffix_length {\n        result.append(string[string_length\
    \ - 1 - i])\n    }\n    return String(result)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp73w8m7ua.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp73w8m7ua.swift:20:12:\
    \ error: cannot find 'is_palindrome' in scope\n        if is_palindrome(string,\
    \ start: i, end: string_length - 1) {\n           ^~~~~~~~~~~~~\n/tmp/tmp73w8m7ua.swift:27:23:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        result.append(string[string_length - 1\
    \ - i])\n                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    var longest_palindrome_length = 0\n    var longest_palindrome_start\
    \ = 0\n    for i in 0..<string_length {\n        let palindrome_length = palindrome_length_at_index(string:\
    \ string, index: i)\n        if palindrome_length > longest_palindrome_length\
    \ {\n            longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start + 1\n    let prefix = string[string.index(string.startIndex,\
    \ offsetBy: prefix_start)..<string.index(string.startIndex, offsetBy: prefix_end)]\n\
    \    let prefix_reversed = String(prefix.characters.reversed())\n    return string\
    \ + prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpqk79m1ri.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpqk79m1ri.swift:20:33: error: cannot find 'palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = palindrome_length_at_index(string:\
    \ string, index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqk79m1ri.swift:29:41: error: 'characters' is unavailable: Please use Substring\
    \ directly\n    let prefix_reversed = String(prefix.characters.reversed())\n \
    \                                       ^~~~~~~~~~\nSwift.Substring:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: Substring\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    var string_array = Array(string.characters)\n    var palindrome_suffix\
    \ = Array(repeating: 0, count: string_length)\n    var center = 0\n    var right\
    \ = 0\n    for i in 0..<string_length {\n        let mirror = 2 * center - i\n\
    \        if right > i {\n            palindrome_suffix[i] = min(right - i, palindrome_suffix[mirror])\n\
    \        }\n        while i + palindrome_suffix[i] + 1 < string_length && i -\
    \ palindrome_suffix[i] - 1 >= 0 && string_array[i + palindrome_suffix[i] + 1]\
    \ == string_array[i - palindrome_suffix[i] - 1] {\n            palindrome_suffix[i]\
    \ += 1\n        }\n        if i + palindrome_suffix[i] > right {\n           \
    \ center = i\n            right = i + palindrome_suffix[i]\n        }\n    }\n\
    \    let max_suffix_length = palindrome_suffix.max()!\n    let prefix = string_array[0..<string_length\
    \ - max_suffix_length]\n    let prefix_reversed = prefix.reversed()\n    return\
    \ String(string_array) + String(prefix_reversed)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpmslfgjqf.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpmslfgjqf.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    var string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpmslfgjqf.swift:17:9: warning: variable 'string_array'\
    \ was never mutated; consider changing to 'let' constant\n    var string_array\
    \ = Array(string.characters)\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        // Check for odd palindromes.\n        var j = 0\n        while i - j\
    \ >= 0 && i + j < string_length && string_chars[i - j] == string_chars[i + j]\
    \ {\n            j += 1\n        }\n        if j > longest_palindrome_length {\n\
    \            longest_palindrome_length = j\n            longest_palindrome_start\
    \ = i - j + 1\n        }\n        // Check for even palindromes.\n        j =\
    \ 0\n        while i - j >= 0 && i + j + 1 < string_length && string_chars[i -\
    \ j] == string_chars[i + j + 1] {\n            j += 1\n        }\n        if j\
    \ > longest_palindrome_length {\n            longest_palindrome_length = j\n \
    \           longest_palindrome_start = i - j + 1\n        }\n    }\n    let prefix\
    \ = String(string_chars[0..<longest_palindrome_start])\n    let reversed_prefix\
    \ = String(prefix.characters.reverse())\n    return string + reversed_prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp2la0cymo.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp2la0cymo.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2la0cymo.swift:41:52: error: value of type 'String'\
    \ has no member 'reverse'\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var palindrome_suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string_array,\
    \ start: i, end: string_length - 1) {\n            palindrome_suffix_length =\
    \ string_length - i\n            break\n        }\n    }\n    var result = string\n\
    \    for i in 0..<string_length - palindrome_suffix_length {\n        result.append(string_array[string_length\
    \ - i - 1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpusdn1eww.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpusdn1eww.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpusdn1eww.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: i, end: string_length\
    \ - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    if length == 0 {\n        return \"\"\n    }\n\
    \    let suffix = longest_palindromic_suffix(string: string)\n    let prefix =\
    \ String(string.characters.prefix(length - suffix.characters.count))\n    return\
    \ prefix + String(suffix.characters.reversed()) + suffix\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp78huh8e4.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp78huh8e4.swift:17:18: error: cannot find 'longest_palindromic_suffix'\
    \ in scope\n    let suffix = longest_palindromic_suffix(string: string)\n    \
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let palindrome = string + reversed\n\
    \    let lps = longest_palindromic_substring(palindrome)\n    let prefix = String(string.characters.dropLast(lps.characters.count))\n\
    \    return prefix + string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp5zm_k__d.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp5zm_k__d.swift:15:15: error:\
    \ cannot find 'longest_palindromic_substring' in scope\n    let lps = longest_palindromic_substring(palindrome)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length <= 1 {\n        return string\n\
    \    }\n    let string_chars = Array(string.characters)\n    var palindrome_length\
    \ = 0\n    for i in 0..<string_length {\n        let j = string_length - i - 1\n\
    \        if string_chars[i] == string_chars[j] {\n            palindrome_length\
    \ += 1\n        } else {\n            break\n        }\n    }\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string_length - palindrome_length))\n\
    \    return string + String(prefix.characters.reverse())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpg3_c8eej.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpg3_c8eej.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpg3_c8eej.swift:27:25: error: value of type 'String'\
    \ has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string_length\
    \ - palindrome_length))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpg3_c8eej.swift:27:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string_length - palindrome_length))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.lowercaseString\n    let string_length = string.characters.count\n\
    \    if string_length == 0 {\n        return \"\"\n    }\n    let string_array\
    \ = Array(string.characters)\n    var longest_palindrome_length = 0\n    var longest_palindrome_start\
    \ = 0\n    for i in 0..<string_length {\n        let palindrome_length = palindrome_length_at_index(string_array,\
    \ i)\n        if palindrome_length > longest_palindrome_length {\n           \
    \ longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_length = string_length - longest_palindrome_length\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpu70ht51f.swift:13:25: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    let string = string.lowercaseString\n               \
    \  ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmpu70ht51f.swift:22:33: error: cannot find 'palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = palindrome_length_at_index(string_array,\
    \ i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let string_length = string.count\n    let\
    \ string_chars = Array(string)\n    var longest_palindrome_length = 0\n    var\
    \ longest_palindrome_start = 0\n    for i in 0..<string_length {\n        let\
    \ palindrome_length = longest_palindrome_length_at_index(string_chars: string_chars,\
    \ string_length: string_length, index: i)\n        if palindrome_length > longest_palindrome_length\
    \ {\n            longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let palindrome_end = longest_palindrome_start + longest_palindrome_length\n\
    \    let prefix = String(string_chars[0..<longest_palindrome_start])\n    let\
    \ suffix = String(string_chars[palindrome_end..<string_length])\n    return prefix\
    \ + suffix + String(suffix.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpx2pjopqx.swift:21:33: error: cannot find 'longest_palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = longest_palindrome_length_at_index(string_chars:\
    \ string_chars, string_length: string_length, index: i)\n                    \
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    if length == 0 {\n        return \"\"\n    }\n\
    \    let reversed = string.characters.reverse()\n    let reversed_string = String(reversed)\n\
    \    let lcs = longest_common_subsequence(string, reversed_string)\n    let lcs_length\
    \ = lcs.characters.count\n    if lcs_length == length {\n        return string\n\
    \    }\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(length\
    \ - lcs_length))\n    let reversed_prefix = prefix.characters.reverse()\n    let\
    \ reversed_prefix_string = String(reversed_prefix)\n    return string + reversed_prefix_string\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmppol1bpa4.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmppol1bpa4.swift:17:38: error: value of type 'String' has no member 'reverse'\n\
    \    let reversed = string.characters.reverse()\n                   ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmppol1bpa4.swift:19:15: error: cannot find 'longest_common_subsequence'\
    \ in scope\n    let lcs = longest_common_subsequence(string, reversed_string)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmppol1bpa4.swift:24:25: error:\
    \ value of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(length\
    \ - lcs_length))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmppol1bpa4.swift:24:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(length - lcs_length))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        var palindrome_length = 0\n        var palindrome_start = i\n       \
    \ for j in 0..<i {\n            if string_chars[i - j] == string_chars[i + j]\
    \ {\n                palindrome_length += 1\n                palindrome_start\
    \ -= 1\n            } else {\n                break\n            }\n        }\n\
    \        if palindrome_length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length\n            longest_palindrome_start = palindrome_start\n\
    \        }\n    }\n    var result = string\n    for i in 0..<string_length - longest_palindrome_length\
    \ {\n        result.append(string_chars[longest_palindrome_start - i])\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpt913ixkc.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpt913ixkc.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_characters = Array(string.characters)\n    var palindrome_suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string: string_characters,\
    \ start: i, end: string_length - 1) {\n            palindrome_suffix_length =\
    \ string_length - i\n            break\n        }\n    }\n    var palindrome_prefix\
    \ = \"\"\n    for i in 0..<string_length - palindrome_suffix_length {\n      \
    \  palindrome_prefix.append(string_characters[i])\n    }\n    return string +\
    \ String(palindrome_prefix.characters.reversed())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpdvxm8aiq.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpdvxm8aiq.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpdvxm8aiq.swift:20:12: error: cannot find\
    \ 'is_palindrome' in scope\n        if is_palindrome(string: string_characters,\
    \ start: i, end: string_length - 1) {\n           ^~~~~~~~~~~~~\n/tmp/tmpdvxm8aiq.swift:29:46:\
    \ error: 'characters' is unavailable: Please use String directly\n    return string\
    \ + String(palindrome_prefix.characters.reversed())\n                        \
    \                     ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let string_length = string.characters.count\n\
    \    let string_characters = Array(string.characters)\n    let reversed_string\
    \ = String(string_characters.reverse())\n    let string_suffix = reversed_string.substringToIndex(string.startIndex.advancedBy(string_length\
    \ - 1))\n    let string_prefix = reversed_string.substringFromIndex(string.startIndex.advancedBy(string_length\
    \ - 1))\n    let longest_palindrome_suffix = longest_palindrome_suffix_of(string)\n\
    \    return string + string_suffix.substringFromIndex(longest_palindrome_suffix.startIndex)\
    \ + string_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp1jcvg8eu.swift:16:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp1jcvg8eu.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp1jcvg8eu.swift:18:27: error: no exact matches\
    \ in call to initializer \n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmp1jcvg8eu.swift:18:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmp1jcvg8eu.swift:18:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmp1jcvg8eu.swift:18:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmp1jcvg8eu.swift:18:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_characters.reverse())\n\
    \                          ^\n/tmp/tmp1jcvg8eu.swift:19:76: error: value of type\
    \ 'String.Index' has no member 'advancedBy'\n    let string_suffix = reversed_string.substringToIndex(string.startIndex.advancedBy(string_length\
    \ - 1))\n                                                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n/tmp/tmp1jcvg8eu.swift:20:78: error: value of type 'String.Index'\
    \ has no member 'advancedBy'\n    let string_prefix = reversed_string.substringFromIndex(string.startIndex.advancedBy(string_length\
    \ - 1))\n                                                           ~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let s = Array(string)\n\
    \    let n = s.count\n    var i = n\n    while i > 0 {\n        if is_palindrome(s[0..<i])\
    \ {\n            break\n        }\n        i -= 1\n    }\n    let prefix = s[0..<i]\n\
    \    let suffix = s[i..<n]\n    return prefix + suffix.reversed()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmphpte_80p.swift:17:12: error: cannot find 'is_palindrome' in scope\n\
    \        if is_palindrome(s[0..<i]) {\n           ^~~~~~~~~~~~~\n/tmp/tmphpte_80p.swift:24:19:\
    \ error: no '+' candidates produce the expected contextual result type 'String'\n\
    \    return prefix + suffix.reversed()\n                  ^\nSwift.RangeReplaceableCollection:2:35:\
    \ note: '+' produces 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'),\
    \ not the expected contextual result type 'String'\n    @inlinable public static\
    \ func + <Other>(lhs: Self, rhs: Other) -> Self where Other : Sequence, Self.Element\
    \ == Other.Element\n                                  ^\nSwift.RangeReplaceableCollection:2:35:\
    \ note: '+' produces 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'),\
    \ not the expected contextual result type 'String'\n    @inlinable public static\
    \ func + <Other>(lhs: Self, rhs: Other) -> Self where Other : Sequence, Self.Element\
    \ == Other.Element\n                                  ^\nSwift.RangeReplaceableCollection:3:35:\
    \ note: '+' produces '[String.Element]' (aka 'Array<Character>'), not the expected\
    \ contextual result type 'String'\n    @inlinable public static func + <Other>(lhs:\
    \ Other, rhs: Self) -> Self where Other : Sequence, Self.Element == Other.Element\n\
    \                                  ^\nSwift.RangeReplaceableCollection:3:35: note:\
    \ '+' produces '[String.Element]' (aka 'Array<Character>'), not the expected contextual\
    \ result type 'String'\n    @inlinable public static func + <Other>(lhs: Other,\
    \ rhs: Self) -> Self where Other : Sequence, Self.Element == Other.Element\n \
    \                                 ^\nSwift.RangeReplaceableCollection:5:35: note:\
    \ '+' produces 'ArraySlice<String.Element>' (aka 'ArraySlice<Character>'), not\
    \ the expected contextual result type 'String'\n    @inlinable public static func\
    \ + <Other>(lhs: Self, rhs: Other) -> Self where Other : RangeReplaceableCollection,\
    \ Self.Element == Other.Element\n                                  ^\nSwift.RangeReplaceableCollection:5:35:\
    \ note: '+' produces 'ArraySlice<String.Element>' (aka 'Array"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let n = string.characters.count\n\
    \    if n == 0 {\n        return \"\"\n    }\n    let s = Array(string.characters)\n\
    \    let z = z_function(string: string)\n    var i = n - 1\n    while i > 0 &&\
    \ z[i] != n - i {\n        i -= 1\n    }\n    var result = string\n    for j in\
    \ 0..<n - i {\n        result.append(s[j])\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxiodll6w.swift:13:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let n = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpxiodll6w.swift:17:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    let s =\
    \ Array(string.characters)\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpxiodll6w.swift:18:13: error: cannot find\
    \ 'z_function' in scope\n    let z = z_function(string: string)\n            ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_common_suffix = longest_common_substring(string,\
    \ reversed)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - longest_common_suffix.characters.count))\n    return string + String(prefix.characters.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp94aiurqd.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp94aiurqd.swift:14:33: error:\
    \ cannot find 'longest_common_substring' in scope\n    let longest_common_suffix\
    \ = longest_common_substring(string, reversed)\n                             \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_common_suffix = longest_common_suffix_length(string,\
    \ reversed)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_common_suffix))\n    return string + String(prefix.characters.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpkqo869_e.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpkqo869_e.swift:14:33: error:\
    \ cannot find 'longest_common_suffix_length' in scope\n    let longest_common_suffix\
    \ = longest_common_suffix_length(string, reversed)\n                         \
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkqo869_e.swift:15:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_common_suffix))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpkqo869_e.swift:15:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_common_suffix))\n                                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let s = string.characters\n\
    \    let n = s.count\n    let s_rev = s.reverse()\n    var z = [Int](count: n,\
    \ repeatedValue: 0)\n    var l = 0\n    var r = 0\n    for i in 1..<n {\n    \
    \    if i <= r {\n            z[i] = min(r - i + 1, z[i - l])\n        }\n   \
    \     while i + z[i] < n && s_rev[z[i]] == s[i + z[i]] {\n            z[i] +=\
    \ 1\n        }\n        if i + z[i] - 1 > r {\n            l = i\n           \
    \ r = i + z[i] - 1\n        }\n    }\n    var prefix = String(s[0..<(n - z[n -\
    \ 1])])\n    return string + prefix.characters.reverse()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpf6nlryby.swift:13:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let s = string.characters\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpf6nlryby.swift:15:19:\
    \ error: value of type 'String' has no member 'reverse'\n    let s_rev = s.reverse()\n\
    \                ~ ^~~~~~~\n/tmp/tmpf6nlryby.swift:16:13: error: no exact matches\
    \ in call to initializer \n    var z = [Int](count: n, repeatedValue: 0)\n   \
    \         ^\n/tmp/tmpf6nlryby.swift:16:13: note: candidate has partially matching\
    \ parameter list (repeating: Int, count: Int)\n    var z = [Int](count: n, repeatedValue:\
    \ 0)\n            ^\n/tmp/tmpf6nlryby.swift:16:13: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var z = [Int](count:\
    \ n, repeatedValue: 0)\n            ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_common_postfix = longest_common_substring(string,\
    \ reversed)\n    let prefix = String(string.characters.dropLast(longest_common_postfix.characters.count))\n\
    \    return string + String(prefix.characters.reverse())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpa9a0228k.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpa9a0228k.swift:14:34: error:\
    \ cannot find 'longest_common_substring' in scope\n    let longest_common_postfix\
    \ = longest_common_substring(string, reversed)\n                             \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.lowercaseString\n    let string_length = string.characters.count\n\
    \    if string_length == 0 {\n        return \"\"\n    }\n    let string_characters\
    \ = Array(string.characters)\n    var longest_palindrome_length = 0\n    var longest_palindrome_index\
    \ = 0\n    for i in 0..<string_length {\n        let palindrome_length = longest_palindrome_length_at_index(string_characters,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    let prefix_length = longest_palindrome_index - longest_palindrome_length\
    \ + 1\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmprnuzy57e.swift:13:25: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    let string = string.lowercaseString\n               \
    \  ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmprnuzy57e.swift:22:33: error: cannot find 'longest_palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = longest_palindrome_length_at_index(string_characters,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let n = string.characters.count\n\
    \    if n == 0 {\n        return \"\"\n    }\n    let chars = Array(string.characters)\n\
    \    var i = n - 1\n    while i >= 0 {\n        if is_palindrome(chars, start:\
    \ 0, end: i) {\n            break\n        }\n        i -= 1\n    }\n    var result\
    \ = string\n    for j in 0..<n - i - 1 {\n        result.append(chars[n - j -\
    \ 1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp0mk1b1rj.swift:13:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let n = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp0mk1b1rj.swift:17:30:\
    \ error: 'characters' is unavailable: Please use String directly\n    let chars\
    \ = Array(string.characters)\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp0mk1b1rj.swift:20:12: error: cannot find\
    \ 'is_palindrome' in scope\n        if is_palindrome(chars, start: 0, end: i)\
    \ {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let palindrome_suffix = longest_palindrome_suffix(string)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - palindrome_suffix.characters.count))\n    return string + reversed.substringFromIndex(reversed.startIndex.advancedBy(palindrome_suffix.characters.count))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpzwzqiaqj.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpzwzqiaqj.swift:14:29: error:\
    \ cannot find 'longest_palindrome_suffix' in scope\n    let palindrome_suffix\
    \ = longest_palindrome_suffix(string)\n                            ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpzwzqiaqj.swift:15:25: error: value of type 'String' has no member 'substringToIndex'\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - palindrome_suffix.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpzwzqiaqj.swift:15:60: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - palindrome_suffix.characters.count))\n                                   \
    \      ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    if string_length == 1 {\n        return string\n    }\n    let string_characters\
    \ = Array(string.characters)\n    var longest_palindrome_length = 0\n    var longest_palindrome_start\
    \ = 0\n    for i in 0..<string_length {\n        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let palindrome_end = longest_palindrome_start + longest_palindrome_length\n\
    \    let prefix_start = palindrome_end - longest_palindrome_length\n    let prefix_end\
    \ = longest_palindrome_start\n    let prefix = String(string_characters[prefix_start..<prefix_end])\n\
    \    return string + String(prefix.characters.reverse())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpyb35ry6g.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpyb35ry6g.swift:20:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpyb35ry6g.swift:24:33: error: cannot find\
    \ 'palindrome_length_at_index' in scope\n        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpyb35ry6g.swift:34:46:\
    \ error: value of type 'String' has no member 'reverse'\n    return string + String(prefix.characters.reverse())\n\
    \                           ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_length = string.count\n    let string_length_half\
    \ = string_length / 2\n    var longest_palindrome_length = 0\n    var longest_palindrome_start\
    \ = 0\n    for i in 0..<string_length_half {\n        let palindrome_length =\
    \ palindrome_length_at_index(string, index: i)\n        if palindrome_length >\
    \ longest_palindrome_length {\n            longest_palindrome_length = palindrome_length\n\
    \            longest_palindrome_start = i\n        }\n    }\n    let prefix_start\
    \ = longest_palindrome_start - (longest_palindrome_length - 1)\n    let prefix_end\
    \ = longest_palindrome_start\n    let prefix = string[prefix_start..<prefix_end]\n\
    \    let prefix_reversed = String(prefix.reverse())\n    return String(string)\
    \ + prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpt0btx7rr.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpt0btx7rr.swift:19:33:\
    \ error: cannot find 'palindrome_length_at_index' in scope\n        let palindrome_length\
    \ = palindrome_length_at_index(string, index: i)\n                           \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt0btx7rr.swift:27:18: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    let prefix = string[prefix_start..<prefix_end]\n       \
    \          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpt0btx7rr.swift:28:41: error: value of type 'String' has no member 'reverse'\n\
    \    let prefix_reversed = String(prefix.reverse())\n                        \
    \         ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    let reversed_string\
    \ = String(string_chars.reverse())\n    let string_suffix = string + reversed_string\n\
    \    let string_suffix_length = string_suffix.characters.count\n    let string_suffix_chars\
    \ = Array(string_suffix.characters)\n    var longest_palindrome_length = 0\n \
    \   var longest_palindrome_index = 0\n    for i in 0..<string_suffix_length {\n\
    \        var is_palindrome = true\n        let max_palindrome_length = min(i +\
    \ 1, string_suffix_length - i)\n        for j in 0..<max_palindrome_length {\n\
    \            if string_suffix_chars[i - j] != string_suffix_chars[i + j] {\n \
    \               is_palindrome = false\n                break\n            }\n\
    \        }\n        if is_palindrome && max_palindrome_length > longest_palindrome_length\
    \ {\n            longest_palindrome_length = max_palindrome_length\n         \
    \   longest_palindrome_index = i\n        }\n    }\n    let prefix_start = longest_palindrome_index\
    \ - longest_palindrome_length + 1\n    let prefix_end = longest_palindrome_index\
    \ + 1\n    let prefix = String(string_suffix_chars[prefix_start..<prefix_end])\n\
    \    return string + String(prefix.characters.reverse())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp96i74h8b.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp96i74h8b.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp96i74h8b.swift:18:27: error: no exact matches in call\
    \ to initializer \n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmp96i74h8b.swift:18:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmp96i74h8b.swift:18:27: note: found candidate\
    \ with type '((), Int, Bool) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmp96i74h8b.swift:18:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmp96i74h8b.swift:18:27: note: found candidate\
    \ with type '(()) -> String'\n    let reversed_string = String(string_chars.reverse())\n\
    \                          ^\n/tmp/tmp96i74h8b.swift:26:45: error: cannot convert\
    \ value of type 'Int' to expected argument type 'Duration'\n        let max_palindrome_length\
    \ = min(i + 1, string_suffix_length - i)\n                                   \
    \         ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_length = string.count\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string, index: i)\n\
    \        if palindrome_length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length\n            longest_palindrome_start = i\n        }\n \
    \   }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start + 1\n    let prefix = string[prefix_start..<prefix_end]\n\
    \    let reversed_prefix = String(prefix.reverse())\n    return string + reversed_prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpg36y8tx2.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpg36y8tx2.swift:18:33:\
    \ error: cannot find 'palindrome_length_at_index' in scope\n        let palindrome_length\
    \ = palindrome_length_at_index(string, index: i)\n                           \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpg36y8tx2.swift:26:18: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    let prefix = string[prefix_start..<prefix_end]\n       \
    \          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpg36y8tx2.swift:27:41: error: value of type 'String' has no member 'reverse'\n\
    \    let reversed_prefix = String(prefix.reverse())\n                        \
    \         ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string_array, index:\
    \ i)\n        if palindrome_length > longest_palindrome_length {\n           \
    \ longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    var result = string\n    for i in 0..<string_length\
    \ - longest_palindrome_length {\n        result.append(string_array[string_length\
    \ - i - 1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpgzcwi38b.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpgzcwi38b.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgzcwi38b.swift:21:33: error: cannot find 'palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = palindrome_length_at_index(string_array,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_suffix = longest_common_suffix(string,\
    \ reversed)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_suffix.characters.count))\n    return string + String(prefix.characters.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp66gqlbs4.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp66gqlbs4.swift:14:26: error:\
    \ cannot find 'longest_common_suffix' in scope\n    let longest_suffix = longest_common_suffix(string,\
    \ reversed)\n                         ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp66gqlbs4.swift:15:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_suffix.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp66gqlbs4.swift:15:60: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_suffix.characters.count))\n                                      \
    \   ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let reversed_suffix = reversed.suffix(string.characters.count\
    \ - longest_palindromic_suffix(string: string).characters.count)\n    return string\
    \ + reversed_suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpevoggrym.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpevoggrym.swift:14:69: error:\
    \ cannot find 'longest_palindromic_suffix' in scope\n    let reversed_suffix =\
    \ reversed.suffix(string.characters.count - longest_palindromic_suffix(string:\
    \ string).characters.count)\n                                                \
    \                    ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    let string_chars_reversed\
    \ = Array(string.characters.reversed())\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_index = 0\n    for i in 0..<string_length {\n    \
    \    var j = 0\n        while i + j < string_length && j < string_length && string_chars[i\
    \ + j] == string_chars_reversed[j] {\n            j += 1\n        }\n        if\
    \ j > longest_palindrome_length {\n            longest_palindrome_length = j\n\
    \            longest_palindrome_index = i\n        }\n    }\n    var result =\
    \ string\n    for i in 0..<string_length - longest_palindrome_index - longest_palindrome_length\
    \ {\n        result.append(string_chars_reversed[i])\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6diq3n41.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp6diq3n41.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp6diq3n41.swift:18:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars_reversed = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_length = string.count\n    let string_half_length\
    \ = string_length / 2\n    var palindrome_suffix_length = 0\n    for i in 0..<string_half_length\
    \ {\n        if string[i] == string[string_length - i - 1] {\n            palindrome_suffix_length\
    \ += 1\n        } else {\n            break\n        }\n    }\n    let palindrome_prefix_length\
    \ = string_length - palindrome_suffix_length\n    let palindrome_prefix = string[0..<palindrome_prefix_length]\n\
    \    let palindrome_suffix = string[palindrome_suffix_length..<string_length]\n\
    \    let palindrome_prefix_reversed = palindrome_prefix.reversed()\n    return\
    \ String(palindrome_prefix + palindrome_suffix + palindrome_prefix_reversed)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpsiz76yi8.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpsiz76yi8.swift:18:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == string[string_length -\
    \ i - 1] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpsiz76yi8.swift:18:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == string[string_length - i - 1] {\n                   \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpsiz76yi8.swift:25:29: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    let palindrome_prefix = string[0..<palindrome_prefix_length]\n\
    \                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmpsiz76yi8.swift:26:29: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    let palindrome_suffix = string[palindrome_suffix_length..<string_length]\n\
    \                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start + 1\n    let prefix = String(string_characters[prefix_start..<prefix_end])\n\
    \    let prefix_reversed = String(prefix.characters.reverse())\n    return string\
    \ + prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp8qbvs9x2.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp8qbvs9x2.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp8qbvs9x2.swift:21:33: error: cannot find\
    \ 'palindrome_length_at_index' in scope\n        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8qbvs9x2.swift:30:52:\
    \ error: value of type 'String' has no member 'reverse'\n    let prefix_reversed\
    \ = String(prefix.characters.reverse())\n                                 ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let rev = string.reverse()\n\
    \    let l = string.characters.count\n    let s = string + \"#\" + rev\n    var\
    \ z = [Int](count: s.characters.count, repeatedValue: 0)\n    var left = 0\n \
    \   var right = 0\n    for i in 1..<s.characters.count {\n        if i > right\
    \ {\n            left = right = i\n            while right < s.characters.count\
    \ && s[s.startIndex.advancedBy(right)] == s[s.startIndex.advancedBy(right - left)]\
    \ {\n                right += 1\n            }\n            z[i] = right - left\n\
    \            right -= 1\n        } else {\n            let k = i - left\n    \
    \        if z[k] < right - i + 1 {\n                z[i] = z[k]\n            }\
    \ else {\n                left = i\n                while right < s.characters.count\
    \ && s[s.startIndex.advancedBy(right)] == s[s.startIndex.advancedBy(right - left)]\
    \ {\n                    right += 1\n                }\n                z[i] =\
    \ right - left\n                right -= 1\n            }\n        }\n    }\n\
    \    return string + rev.substringFromIndex(rev.startIndex.advancedBy(l - z[s.characters.count\
    \ - 1]))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqikdcza.swift:13:22: error: value of type 'String' has no member\
    \ 'reverse'\n    let rev = string.reverse()\n              ~~~~~~ ^~~~~~~\n/tmp/tmpuqikdcza.swift:14:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    let l =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpuqikdcza.swift:16:61: error: extra argument\
    \ 'repeatedValue' in call\n    var z = [Int](count: s.characters.count, repeatedValue:\
    \ 0)\n                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_index - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_index + 1\n    let prefix = string_characters[prefix_start..<prefix_end]\n\
    \    let prefix_reversed = prefix.reverse()\n    let result = string + String(prefix_reversed)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpab76yxc_.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpab76yxc_.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpab76yxc_.swift:21:33: error: cannot find\
    \ 'palindrome_length_at_index' in scope\n        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpab76yxc_.swift:30:34:\
    \ error: cannot use mutating member on immutable value: 'prefix' is a 'let' constant\n\
    \    let prefix_reversed = prefix.reverse()\n                          ~~~~~~\
    \ ^\n/tmp/tmpab76yxc_.swift:29:5: note: change 'let' to 'var' to make it mutable\n\
    \    let prefix = string_characters[prefix_start..<prefix_end]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: -4
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let reversed_string = String(string.reversed())\n\
    \    let string_length = string.count\n    let reversed_string_length = reversed_string.count\n\
    \    var longest_palindrome_length = 0\n    var longest_palindrome_index = 0\n\
    \    var z_function = [Int](repeating: 0, count: reversed_string_length)\n   \
    \ z_function[0] = string_length\n    var left = 0\n    var right = 0\n    for\
    \ i in 1..<reversed_string_length {\n        if i <= right {\n            z_function[i]\
    \ = min(right - i + 1, z_function[i - left])\n        }\n        while i + z_function[i]\
    \ < reversed_string_length && string[string.index(string.startIndex, offsetBy:\
    \ z_function[i])] == reversed_string[reversed_string.index(reversed_string.startIndex,\
    \ offsetBy: i + z_function[i])] {\n            z_function[i] += 1\n        }\n\
    \        if i + z_function[i] - 1 > right {\n            left = i\n          \
    \  right = i + z_function[i] - 1\n        }\n        if z_function[i] > longest_palindrome_length\
    \ {\n            longest_palindrome_length = z_function[i]\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    return string + String(reversed_string[reversed_string.index(reversed_string.startIndex,\
    \ offsetBy: longest_palindrome_index + longest_palindrome_length)..<reversed_string.endIndex])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: Exception
  stderr: 'tmp_p_5a72e/tmp_p_5a72e.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e86dbfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e86ab6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e86ab6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e86ab57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_p_5a72e                        0x000055acae4d1c65 <unavailable> + 7269

    5    libc.so.6                          0x00002b2e86fab460 __libc_start_main +
    245

    6    tmp_p_5a72e                        0x000055acae4d17b9 <unavailable> + 6073

    '
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_common_prefix = longest_common_prefix_suffix(string,\
    \ reversed)\n    let prefix = String(string.characters.prefixUpTo(string.characters.endIndex.advancedBy(-longest_common_prefix)))\n\
    \    return string + reversed.substringFromIndex(prefix.endIndex)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmplqst04p8.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmplqst04p8.swift:14:33: error:\
    \ cannot find 'longest_common_prefix_suffix' in scope\n    let longest_common_prefix\
    \ = longest_common_prefix_suffix(string, reversed)\n                         \
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplqst04p8.swift:15:43: error: value\
    \ of type 'String' has no member 'prefixUpTo'\n    let prefix = String(string.characters.prefixUpTo(string.characters.endIndex.advancedBy(-longest_common_prefix)))\n\
    \                        ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmplqst04p8.swift:15:81:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = String(string.characters.prefixUpTo(string.characters.endIndex.advancedBy(-longest_common_prefix)))\n\
    \                                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let string_length = string.characters.count\n\
    \    let string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = -1\n    for i in 0..<string_length {\n\
    \        let palindrome_length = longest_palindrome_length_at_index(string_characters,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_index - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_index + 1\n    let prefix = String(string_characters[prefix_start..<prefix_end])\n\
    \    let prefix_reversed = String(prefix.characters.reverse())\n    return string\
    \ + prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpsc8ogx7a.swift:16:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpsc8ogx7a.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpsc8ogx7a.swift:21:33: error: cannot find\
    \ 'longest_palindrome_length_at_index' in scope\n        let palindrome_length\
    \ = longest_palindrome_length_at_index(string_characters, index: i)\n        \
    \                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsc8ogx7a.swift:30:52:\
    \ error: value of type 'String' has no member 'reverse'\n    let prefix_reversed\
    \ = String(prefix.characters.reverse())\n                                 ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = longest_palindrome_length_at_index(string_array,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start + 1\n    let prefix = string_array[prefix_start..<prefix_end]\n\
    \    let reversed_prefix = prefix.reverse()\n    return string + String(reversed_prefix)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpqfsfnfgs.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpqfsfnfgs.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpqfsfnfgs.swift:21:33: error: cannot find 'longest_palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = longest_palindrome_length_at_index(string_array,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqfsfnfgs.swift:30:34: error: cannot use mutating member on immutable value:\
    \ 'prefix' is a 'let' constant\n    let reversed_prefix = prefix.reverse()\n \
    \                         ~~~~~~ ^\n/tmp/tmpqfsfnfgs.swift:29:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let prefix = string_array[prefix_start..<prefix_end]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_length = string_length - longest_palindrome_length\n\
    \    let prefix = string_characters[0..<prefix_length]\n    let prefix_reversed\
    \ = prefix.reverse()\n    let result = string + String(prefix_reversed)\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp0a0k0g93.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp0a0k0g93.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp0a0k0g93.swift:21:33: error: cannot find\
    \ 'palindrome_length_at_index' in scope\n        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0a0k0g93.swift:29:34:\
    \ error: cannot use mutating member on immutable value: 'prefix' is a 'let' constant\n\
    \    let prefix_reversed = prefix.reverse()\n                          ~~~~~~\
    \ ^\n/tmp/tmp0a0k0g93.swift:28:5: note: change 'let' to 'var' to make it mutable\n\
    \    let prefix = string_characters[0..<prefix_length]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_length = string.count\n    if string_length\
    \ == 0 {\n        return \"\"\n    }\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_index = 0\n    for i in 0..<string_length {\n    \
    \    var j = 0\n        while i - j >= 0 && i + j < string_length && string[i\
    \ - j] == string[i + j] {\n            j += 1\n        }\n        if j > longest_palindrome_length\
    \ {\n            longest_palindrome_length = j\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    let palindrome_end = longest_palindrome_index + longest_palindrome_length\n\
    \    let palindrome_begin = longest_palindrome_index - longest_palindrome_length\
    \ + 1\n    let prefix = string[0..<palindrome_begin].reverse()\n    let suffix\
    \ = string[palindrome_end..<string_length]\n    return String(prefix + string\
    \ + suffix)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpmh8rx6f4.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpmh8rx6f4.swift:22:54:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        while i - j >= 0 && i + j < string_length\
    \ && string[i - j] == string[i + j] {\n                                      \
    \               ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpmh8rx6f4.swift:22:71: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        while i - j >= 0 && i + j < string_length && string[i - j] == string[i\
    \ + j] {\n                                                                   \
    \   ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpmh8rx6f4.swift:32:47: error: value of type 'String' has\
    \ no member 'reverse'\n    let prefix = string[0..<palindrome_begin].reverse()\n\
    \                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpmh8rx6f4.swift:33:18:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n    let suffix = string[palindrome_end..<string_length]\n\
    \                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string_array, index:\
    \ i)\n        if palindrome_length > longest_palindrome_length {\n           \
    \ longest_palindrome_length = palindrome_length\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    let prefix_length = string_length - longest_palindrome_length\n\
    \    let prefix = string_array[0..<prefix_length]\n    let prefix_reversed = prefix.reverse()\n\
    \    let suffix = string_array[prefix_length..<string_length]\n    return String(suffix)\
    \ + String(prefix_reversed)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp_zbj4hv6.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp_zbj4hv6.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp_zbj4hv6.swift:21:33: error: cannot find 'palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = palindrome_length_at_index(string_array,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_zbj4hv6.swift:29:34:\
    \ error: cannot use mutating member on immutable value: 'prefix' is a 'let' constant\n\
    \    let prefix_reversed = prefix.reverse()\n                          ~~~~~~\
    \ ^\n/tmp/tmp_zbj4hv6.swift:28:5: note: change 'let' to 'var' to make it mutable\n\
    \    let prefix = string_array[0..<prefix_length]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    if length == 0 {\n        return \"\"\n    }\n\
    \    let chars = Array(string.characters)\n    let reversed = chars.reverse()\n\
    \    var i = 0\n    while i < length {\n        if chars[i] == reversed[i] {\n\
    \            i += 1\n        } else {\n            break\n        }\n    }\n \
    \   return string + String(reversed[i..<length])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp10juflhe.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp10juflhe.swift:17:30: error: 'characters' is unavailable: Please use String\
    \ directly\n    let chars = Array(string.characters)\n                       \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp10juflhe.swift:18:26:\
    \ error: cannot use mutating member on immutable value: 'chars' is a 'let' constant\n\
    \    let reversed = chars.reverse()\n                   ~~~~~ ^\n/tmp/tmp10juflhe.swift:17:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let chars = Array(string.characters)\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var palindrome_length\
    \ = 0\n    var palindrome_start = 0\n    for i in 0..<string_length {\n      \
    \  let length = max(\n            expand_palindrome(string_array, i, i),\n   \
    \         expand_palindrome(string_array, i, i + 1)\n        )\n        if length\
    \ > palindrome_length {\n            palindrome_length = length\n            palindrome_start\
    \ = i - (length - 1) / 2\n        }\n    }\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(palindrome_start))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp7v90o_wy.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp7v90o_wy.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp7v90o_wy.swift:22:13: error: cannot find 'expand_palindrome'\
    \ in scope\n            expand_palindrome(string_array, i, i),\n            ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7v90o_wy.swift:23:13: error: cannot find 'expand_palindrome' in scope\n\
    \            expand_palindrome(string_array, i, i + 1)\n            ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7v90o_wy.swift:30:25: error: value of type 'String' has no member 'substringToIndex'\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(palindrome_start))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp7v90o_wy.swift:30:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(palindrome_start))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: -4
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let n = string.count\n\
    \    if n == 0 {\n        return \"\"\n    }\n    let string = Array(string)\n\
    \    var palindrome = string\n    var i = 0\n    var j = n - 1\n    while i <\
    \ j {\n        if string[i] != string[j] {\n            break\n        }\n   \
    \     i += 1\n        j -= 1\n    }\n    if i >= j {\n        return String(string)\n\
    \    }\n    let suffix = Array(string[i...])\n    let prefix = Array(string[..<i])\n\
    \    let reversed_prefix = prefix.reversed()\n    palindrome.append(contentsOf:\
    \ reversed_prefix)\n    return String(palindrome)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: Exception
  stderr: 'tmplm2t39yh/tmplm2t39yh.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6750e99c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6750b90b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6750b90988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6750b8f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplm2t39yh                        0x00005616a4af4c72 <unavailable> + 7282

    5    libc.so.6                          0x00002b6751085460 __libc_start_main +
    245

    6    tmplm2t39yh                        0x00005616a4af46a9 <unavailable> + 5801

    '
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.lowercaseString\n    let reversed = String(string.characters.reverse())\n\
    \    let length = string.characters.count\n    var i = 0\n    while i < length\
    \ {\n        if string.substringFromIndex(string.startIndex.advancedBy(i)) ==\
    \ reversed.substringToIndex(reversed.startIndex.advancedBy(length - i)) {\n  \
    \          break\n        }\n        i += 1\n    }\n    return string + reversed.substringFromIndex(reversed.startIndex.advancedBy(i))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpies6ye6j.swift:13:25: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    let string = string.lowercaseString\n               \
    \  ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    let reversed_string = String(string.characters.reverse())\n\
    \    let string_with_reversed_prefix = string + reversed_string\n    let string_with_reversed_prefix_length\
    \ = string_with_reversed_prefix.characters.count\n    var longest_palindromic_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n    var\
    \ current_longest_palindromic_suffix_length = 0\n    for i in 1..<string_with_reversed_prefix_length\
    \ {\n        if string_with_reversed_prefix[i] == string_with_reversed_prefix[current_longest_palindromic_suffix_length]\
    \ {\n            current_longest_palindromic_suffix_length += 1\n            longest_palindromic_suffix[i]\
    \ = current_longest_palindromic_suffix_length\n        } else {\n            if\
    \ current_longest_palindromic_suffix_length != 0 {\n                current_longest_palindromic_suffix_length\
    \ = longest_palindromic_suffix[current_longest_palindromic_suffix_length - 1]\n\
    \                i -= 1\n            }\n        }\n    }\n    return string +\
    \ reversed_string[string_length - longest_palindromic_suffix[string_with_reversed_prefix_length\
    \ - 1]..<string_length]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpr13kxkm6.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpr13kxkm6.swift:14:52: error: value of type 'String' has\
    \ no member 'reverse'\n    let reversed_string = String(string.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpr13kxkm6.swift:17:102:\
    \ error: extra argument 'repeatedValue' in call\n    var longest_palindromic_suffix\
    \ = [Int](count: string_with_reversed_prefix_length, repeatedValue: 0)\n     \
    \                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        var j = 0\n        while i - j >= 0 && i + j < string_length && string_array[i\
    \ - j] == string_array[i + j] {\n            j += 1\n        }\n        j -= 1\n\
    \        if 2 * j + 1 > longest_palindrome_length {\n            longest_palindrome_length\
    \ = 2 * j + 1\n            longest_palindrome_start = i - j\n        }\n     \
    \   j = 0\n        while i - j >= 0 && i + j + 1 < string_length && string_array[i\
    \ - j] == string_array[i + j + 1] {\n            j += 1\n        }\n        j\
    \ -= 1\n        if 2 * j + 2 > longest_palindrome_length {\n            longest_palindrome_length\
    \ = 2 * j + 2\n            longest_palindrome_start = i - j\n        }\n    }\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start))\n\
    \    return string + String(prefix.characters.reverse())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmplsmmrome.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmplsmmrome.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmplsmmrome.swift:40:25: error: value of type 'String'\
    \ has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmplsmmrome.swift:40:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    let chars = Array(string.characters)\n    var\
    \ i = 0\n    var j = length - 1\n    while i < j {\n        if chars[i] != chars[j]\
    \ {\n            break\n        }\n        i += 1\n        j -= 1\n    }\n   \
    \ if i >= j {\n        return string\n    }\n    let prefix = String(chars[0..<i])\n\
    \    let suffix = String(chars[i..<length])\n    return prefix + reverse(string:\
    \ suffix) + suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpujq60n9x.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpujq60n9x.swift:14:30: error: 'characters' is unavailable: Please use String\
    \ directly\n    let chars = Array(string.characters)\n                       \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpujq60n9x.swift:29:21:\
    \ error: cannot find 'reverse' in scope\n    return prefix + reverse(string: suffix)\
    \ + suffix\n                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_len = string.count\n    if string_len ==\
    \ 0 {\n        return \"\"\n    }\n    var i = string_len - 1\n    while i >=\
    \ 0 {\n        if is_palindrome(string, start: 0, end: i) {\n            break\n\
    \        }\n        i -= 1\n    }\n    var result = string\n    for j in 0..<string_len\
    \ - i - 1 {\n        result.append(string[string_len - j - 1])\n    }\n    return\
    \ String(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpppbb9gs_.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpppbb9gs_.swift:20:12:\
    \ error: cannot find 'is_palindrome' in scope\n        if is_palindrome(string,\
    \ start: 0, end: i) {\n           ^~~~~~~~~~~~~\n/tmp/tmpppbb9gs_.swift:27:23:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        result.append(string[string_len - j - 1])\n\
    \                      ^~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let n = string.characters.count\n\
    \    if n == 0 {\n        return \"\"\n    }\n    var suffix = \"\"\n    var prefix\
    \ = \"\"\n    var i = 0\n    while i < n {\n        suffix = String(string[string.index(string.startIndex,\
    \ offsetBy: i)]) + suffix\n        prefix = prefix + String(string[string.index(string.startIndex,\
    \ offsetBy: i)])\n        if is_palindrome(string: suffix + prefix) {\n      \
    \      break\n        }\n        i += 1\n    }\n    return string + reverse(string:\
    \ prefix)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpn5y9nf3l.swift:13:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let n = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpn5y9nf3l.swift:23:12:\
    \ error: cannot find 'is_palindrome' in scope\n        if is_palindrome(string:\
    \ suffix + prefix) {\n           ^~~~~~~~~~~~~\n/tmp/tmpn5y9nf3l.swift:28:21:\
    \ error: cannot find 'reverse' in scope\n    return string + reverse(string: prefix)\n\
    \                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_length = string.count\n    let reversed_string\
    \ = string.reverse()\n    var longest_palindrome_length = 0\n    var longest_palindrome_index\
    \ = 0\n    for i in 0..<string_length {\n        let string_prefix = string[0..<i]\n\
    \        let string_suffix = reversed_string[0..<i]\n        if string_prefix\
    \ == string_suffix {\n            longest_palindrome_length = i\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    let string_prefix = string[0..<longest_palindrome_index]\n\
    \    let string_suffix = reversed_string[0..<longest_palindrome_index]\n    let\
    \ string_prefix_reversed = string_prefix.reverse()\n    return String(string_prefix\
    \ + string_suffix + string_prefix_reversed)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp7l8vk8da.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp7l8vk8da.swift:15:34:\
    \ error: value of type 'String' has no member 'reverse'\n    let reversed_string\
    \ = string.reverse()\n                          ~~~~~~ ^~~~~~~\n/tmp/tmp7l8vk8da.swift:19:29:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n        let string_prefix = string[0..<i]\n\
    \                            ^~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmp7l8vk8da.swift:26:25: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n    let string_prefix\
    \ = string[0..<longest_palindrome_index]\n                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp7l8vk8da.swift:28:48: error: value\
    \ of type 'String' has no member 'reverse'\n    let string_prefix_reversed = string_prefix.reverse()\n\
    \                                 ~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    let string_chars_reversed\
    \ = Array(string.characters.reversed())\n    var longest_palindrome_suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if string_chars[i] == string_chars_reversed[string_length\
    \ - 1 - i] {\n            longest_palindrome_suffix_length += 1\n        } else\
    \ {\n            break\n        }\n    }\n    var result = string\n    for i in\
    \ 0..<string_length - longest_palindrome_suffix_length {\n        result.append(string_chars_reversed[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpn81dtrd6.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpn81dtrd6.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpn81dtrd6.swift:18:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars_reversed = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let string_length = string.characters.count\n\
    \    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    // Find the longest palindrome\
    \ suffix.\n    for i in 0..<string_length {\n        let left = i\n        let\
    \ right = string_length - 1\n        var palindrome_length = 0\n        while\
    \ left < right {\n            if string_array[left] == string_array[right] {\n\
    \                palindrome_length += 1\n                left += 1\n         \
    \       right -= 1\n            } else {\n                break\n            }\n\
    \        }\n        if palindrome_length > longest_palindrome_length {\n     \
    \       longest_palindrome_length = palindrome_length\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    // Append reverse of the prefix to the end of the\
    \ string.\n    var result = string\n    for i in 0..<string_length - longest_palindrome_length\
    \ {\n        result.append(string_array[string_length - 1 - i])\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpdgeri7lq.swift:16:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpdgeri7lq.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpdgeri7lq.swift:28:22: error: left side of mutating\
    \ operator isn't mutable: 'left' is a 'let' constant\n                left +=\
    \ 1\n                ~~~~ ^\n/tmp/tmpdgeri7lq.swift:22:9: note: change 'let' to\
    \ 'var' to make it mutable\n        let left = i\n        ^~~\n        var\n/tmp/tmpdgeri7lq.swift:29:23:\
    \ error: left side of mutating operator isn't mutable: 'right' is a 'let' constant\n\
    \                right -= 1\n                ~~~~~ ^\n/tmp/tmpdgeri7lq.swift:23:9:\
    \ note: change 'let' to 'var' to make it mutable\n        let right = string_length\
    \ - 1\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_length = string.count\n    if string_length\
    \ == 0 {\n        return \"\"\n    }\n    var suffix = [Character]()\n    var\
    \ prefix = [Character]()\n    var longest_palindrome_length = 0\n    for i in\
    \ 0..<string_length {\n        let suffix_length = string_length - i\n       \
    \ let prefix_length = i\n        if suffix_length <= longest_palindrome_length\
    \ {\n            break\n        }\n        if is_palindrome(string: string, start:\
    \ i, length: suffix_length) {\n            longest_palindrome_length = suffix_length\n\
    \            suffix = Array(string[i..<string_length])\n            prefix = Array(string[0..<prefix_length])\n\
    \        }\n    }\n    return String(prefix.reversed()) + String(string) + String(suffix.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmph9kggtdf.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmph9kggtdf.swift:27:12:\
    \ error: cannot find 'is_palindrome' in scope\n        if is_palindrome(string:\
    \ string, start: i, length: suffix_length) {\n           ^~~~~~~~~~~~~\n/tmp/tmph9kggtdf.swift:29:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n            suffix = Array(string[i..<string_length])\n\
    \                           ^~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmph9kggtdf.swift:30:28: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n          \
    \  prefix = Array(string[0..<prefix_length])\n                           ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    var suffix_length = string_length\n    while suffix_length > 0 {\n\
    \        let suffix = string.substring(from: string.index(string.startIndex, offsetBy:\
    \ string_length - suffix_length))\n        if is_palindrome(string: suffix) {\n\
    \            break\n        }\n        suffix_length -= 1\n    }\n    let prefix\
    \ = string.substring(to: string.index(string.startIndex, offsetBy: string_length\
    \ - suffix_length))\n    return string + String(prefix.characters.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp9qa6rxxs.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp9qa6rxxs.swift:19:29: error: value of type 'String' has\
    \ no member 'substring'\n        let suffix = string.substring(from: string.index(string.startIndex,\
    \ offsetBy: string_length - suffix_length))\n                     ~~~~~~ ^~~~~~~~~\n\
    /tmp/tmp9qa6rxxs.swift:20:12: error: cannot find 'is_palindrome' in scope\n  \
    \      if is_palindrome(string: suffix) {\n           ^~~~~~~~~~~~~\n/tmp/tmp9qa6rxxs.swift:25:25:\
    \ error: value of type 'String' has no member 'substring'\n    let prefix = string.substring(to:\
    \ string.index(string.startIndex, offsetBy: string_length - suffix_length))\n\
    \                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.lowercaseString\n    let length = string.characters.count\n    if length\
    \ == 0 {\n        return \"\"\n    }\n    var suffix = \"\"\n    for i in 0..<length\
    \ {\n        let index = string.startIndex.advancedBy(i)\n        let suffix_length\
    \ = length - i\n        let suffix_end = string.endIndex.advancedBy(-i)\n    \
    \    let suffix_range = index..<suffix_end\n        let suffix_string = string.substringWithRange(suffix_range)\n\
    \        if is_palindrome(suffix_string) {\n            suffix = suffix_string\n\
    \            break\n        }\n    }\n    let prefix = String(suffix.characters.reverse())\n\
    \    return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmptwq1_yz4.swift:13:25: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    let string = string.lowercaseString\n               \
    \  ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmptwq1_yz4.swift:30:43: error: value of type\
    \ 'String' has no member 'reverse'\n    let prefix = String(suffix.characters.reverse())\n\
    \                        ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    let reversed_string_array\
    \ = Array(string.characters.reversed())\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_index = 0\n    for i in 0..<string_length {\n    \
    \    var j = 0\n        while i + j < string_length && j < string_length && string_array[i\
    \ + j] == reversed_string_array[j] {\n            j += 1\n        }\n        if\
    \ j > longest_palindrome_length {\n            longest_palindrome_length = j\n\
    \            longest_palindrome_index = i\n        }\n    }\n    var result =\
    \ string\n    for i in 0..<string_length - longest_palindrome_length {\n     \
    \   result.append(reversed_string_array[i])\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpw297jvb2.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpw297jvb2.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw297jvb2.swift:18:46: error: 'characters' is unavailable:\
    \ Please use String directly\n    let reversed_string_array = Array(string.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpw297jvb2.swift:20:9: warning: variable\
    \ 'longest_palindrome_index' was written to, but never read\n    var longest_palindrome_index\
    \ = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    if string_length == 1 {\n        return string\n    }\n    let string_chars\
    \ = Array(string.characters)\n    var suffix_length = 0\n    for i in 0..<string_length\
    \ {\n        if string_chars[i] == string_chars[string_length - 1 - i] {\n   \
    \         suffix_length += 1\n        } else {\n            break\n        }\n\
    \    }\n    if suffix_length == string_length {\n        return string\n    }\n\
    \    var prefix = string.substringToIndex(string.startIndex.advancedBy(string_length\
    \ - suffix_length))\n    prefix = String(prefix.characters.reverse())\n    return\
    \ string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpawfas8st.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpawfas8st.swift:20:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpawfas8st.swift:32:25: error: value of type 'String'\
    \ has no member 'substringToIndex'\n    var prefix = string.substringToIndex(string.startIndex.advancedBy(string_length\
    \ - suffix_length))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpawfas8st.swift:32:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    var prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string_length - suffix_length))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    if length == 0 {\n        return \"\"\n    }\n\
    \    let string_array = Array(string.characters)\n    var i = 0\n    var j = length\
    \ - 1\n    while i < j {\n        if string_array[i] != string_array[j] {\n  \
    \          break\n        }\n        i += 1\n        j -= 1\n    }\n    if i >=\
    \ j {\n        return string\n    }\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(i))\n\
    \    let suffix = string.substringFromIndex(string.startIndex.advancedBy(i))\n\
    \    return prefix + String(suffix.characters.reverse()) + suffix\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp2470e98t.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp2470e98t.swift:17:37: error: 'characters' is unavailable: Please use String\
    \ directly\n    let string_array = Array(string.characters)\n                \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp2470e98t.swift:30:25: error: value of type 'String' has no member\
    \ 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(i))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp2470e98t.swift:30:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(i))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp2470e98t.swift:31:25:\
    \ error: value of type 'String' has no member 'substringFromIndex'\n    let suffix\
    \ = string.substringFromIndex(string.startIndex.advancedBy(i))\n             \
    \    ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp2470e98t.swift:31:62: error: value of\
    \ type 'String.Index' has no member 'advancedBy'\n    let suffix = string.substringFromIndex(string.startIndex.advancedBy(i))\n\
    \                                           ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = longest_palindrome_length_at(string_chars, start:\
    \ i)\n        if palindrome_length > longest_palindrome_length {\n           \
    \ longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start + longest_palindrome_length\n\
    \    let prefix_end = string_length\n    let prefix = String(string_chars[prefix_start..<prefix_end])\n\
    \    let prefix_reversed = String(prefix.characters.reverse())\n    return string\
    \ + prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpft1a6whp.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpft1a6whp.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpft1a6whp.swift:21:33: error: cannot find 'longest_palindrome_length_at'\
    \ in scope\n        let palindrome_length = longest_palindrome_length_at(string_chars,\
    \ start: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpft1a6whp.swift:30:52:\
    \ error: value of type 'String' has no member 'reverse'\n    let prefix_reversed\
    \ = String(prefix.characters.reverse())\n                                 ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_len = string.count\n    if string_len ==\
    \ 0 {\n        return \"\"\n    }\n    var i = string_len - 1\n    while i >=\
    \ 0 {\n        if is_palindrome(string, start: 0, end: i) {\n            break\n\
    \        }\n        i -= 1\n    }\n    var prefix = string[string.startIndex..<string.startIndex.advancedBy(i\
    \ + 1)]\n    prefix = prefix.reverse()\n    return string + prefix\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp4jeftk07.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp4jeftk07.swift:20:12:\
    \ error: cannot find 'is_palindrome' in scope\n        if is_palindrome(string,\
    \ start: 0, end: i) {\n           ^~~~~~~~~~~~~\n/tmp/tmp4jeftk07.swift:25:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    var prefix\
    \ = string[string.startIndex..<string.startIndex.advancedBy(i + 1)]\n        \
    \                                    ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = longest_palindrome_length_at_index(string_characters,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    let prefix_begin = longest_palindrome_index - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_index + 1\n    let prefix = String(string_characters[prefix_begin..<prefix_end])\n\
    \    let reverse_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reverse_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpv_oah5pb.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpv_oah5pb.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpv_oah5pb.swift:21:33: error: cannot find\
    \ 'longest_palindrome_length_at_index' in scope\n        let palindrome_length\
    \ = longest_palindrome_length_at_index(string_characters, index: i)\n        \
    \                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpv_oah5pb.swift:30:51:\
    \ error: value of type 'String' has no member 'reverse'\n    let reverse_prefix\
    \ = String(prefix.characters.reverse())\n                                ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let s = Array(string)\n\
    \    let n = s.count\n    var i = 0\n    while i < n {\n        if is_palindrome(s,\
    \ i, n - 1) {\n            break\n        }\n        i += 1\n    }\n    var result\
    \ = string\n    for j in 0..<i {\n        result.append(s[i - j - 1])\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp8cg4sdft.swift:17:12: error: cannot find 'is_palindrome' in scope\n\
    \        if is_palindrome(s, i, n - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let combined = string + \"#\" + reversed\n\
    \    let lps = longest_prefix_suffix(combined)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpyv556wmf.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpyv556wmf.swift:15:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpyv556wmf.swift:16:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpyv556wmf.swift:16:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let suffix = longest_palindromic_suffix(string)\n\
    \    let prefix = String(string.prefix(string.count - suffix.count).reversed())\n\
    \    return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmppr511hgq.swift:16:18: error: cannot find 'longest_palindromic_suffix'\
    \ in scope\n    let suffix = longest_palindromic_suffix(string)\n            \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_length = string.count\n    if string_length\
    \ == 0 {\n        return \"\"\n    }\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_index = -1\n    for i in 0..<string_length {\n   \
    \     let palindrome_length = palindrome_length_at_index(string, index: i)\n \
    \       if palindrome_length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length\n            longest_palindrome_index = i\n        }\n \
    \   }\n    let prefix_length = string_length - longest_palindrome_length\n   \
    \ let prefix = string[string.startIndex..<string.startIndex.advancedBy(prefix_length)]\n\
    \    let reversed_prefix = String(prefix.reverse())\n    let palindrome = string\
    \ + reversed_prefix\n    return palindrome\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpqw7lqaxy.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpqw7lqaxy.swift:21:33:\
    \ error: cannot find 'palindrome_length_at_index' in scope\n        let palindrome_length\
    \ = palindrome_length_at_index(string, index: i)\n                           \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqw7lqaxy.swift:28:63: error: value of\
    \ type 'String.Index' has no member 'advancedBy'\n    let prefix = string[string.startIndex..<string.startIndex.advancedBy(prefix_length)]\n\
    \                                            ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var suffix_length\
    \ = string_length\n    while suffix_length > 0 {\n        if is_palindrome(string_array,\
    \ start: string_length - suffix_length, end: string_length - 1) {\n          \
    \  break\n        }\n        suffix_length -= 1\n    }\n    var prefix_length\
    \ = string_length - suffix_length\n    var result = string\n    while prefix_length\
    \ > 0 {\n        result.append(string_array[string_length - prefix_length])\n\
    \        prefix_length -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp2g_982nk.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp2g_982nk.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2g_982nk.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: string_length - suffix_length,\
    \ end: string_length - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        var j = 0\n        while i - j >= 0 && i + j < string_length && string_chars[i\
    \ - j] == string_chars[i + j] {\n            j += 1\n        }\n        if 2 *\
    \ j - 1 > longest_palindrome_length {\n            longest_palindrome_length =\
    \ 2 * j - 1\n            longest_palindrome_start = i - j + 1\n        }\n   \
    \     j = 0\n        while i - j >= 0 && i + j + 1 < string_length && string_chars[i\
    \ - j] == string_chars[i + j + 1] {\n            j += 1\n        }\n        if\
    \ 2 * j > longest_palindrome_length {\n            longest_palindrome_length =\
    \ 2 * j\n            longest_palindrome_start = i - j + 1\n        }\n    }\n\
    \    let prefix = String(string_chars[0..<longest_palindrome_start])\n    let\
    \ reversed_prefix = String(prefix.characters.reverse())\n    return string + reversed_prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpfyo5nfrf.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpfyo5nfrf.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpfyo5nfrf.swift:39:52: error: value of type 'String'\
    \ has no member 'reverse'\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \                                 ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let reversed = String(string.characters.reverse())\n\
    \    let concatenated = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(string:\
    \ concatenated)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - lps))\n    return string + String(prefix.characters.reverse())\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp9qiiqlk3.swift:16:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp9qiiqlk3.swift:18:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(string:\
    \ concatenated)\n              ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = longest_palindrome_length_at_index(string_chars,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    let palindrome_end_index = longest_palindrome_index\
    \ + longest_palindrome_length\n    let prefix_start_index = palindrome_end_index\
    \ - longest_palindrome_length\n    let prefix_end_index = longest_palindrome_index\n\
    \    let prefix = string_chars[prefix_start_index..<prefix_end_index]\n    let\
    \ prefix_reversed = prefix.reverse()\n    let palindrome = string_chars[0..<palindrome_end_index]\
    \ + prefix_reversed\n    return String(palindrome)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpqgbinbm5.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpqgbinbm5.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpqgbinbm5.swift:21:33: error: cannot find 'longest_palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = longest_palindrome_length_at_index(string_chars,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqgbinbm5.swift:31:34: error: cannot use mutating member on immutable value:\
    \ 'prefix' is a 'let' constant\n    let prefix_reversed = prefix.reverse()\n \
    \                         ~~~~~~ ^\n/tmp/tmpqgbinbm5.swift:30:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let prefix = string_chars[prefix_start_index..<prefix_end_index]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var palindrome_length\
    \ = 0\n    var palindrome_start = 0\n    for i in 0..<string_length {\n      \
    \  let palindrome_length_odd = get_palindrome_length(string_array, i, i)\n   \
    \     let palindrome_length_even = get_palindrome_length(string_array, i, i +\
    \ 1)\n        let palindrome_length_current = max(palindrome_length_odd, palindrome_length_even)\n\
    \        if palindrome_length_current > palindrome_length {\n            palindrome_length\
    \ = palindrome_length_current\n            palindrome_start = i - (palindrome_length\
    \ - 1) / 2\n        }\n    }\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(palindrome_start))\n\
    \    let prefix_reversed = String(prefix.characters.reverse())\n    return string\
    \ + prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpd08yzk7q.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpd08yzk7q.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpd08yzk7q.swift:21:37: error: cannot find 'get_palindrome_length'\
    \ in scope\n        let palindrome_length_odd = get_palindrome_length(string_array,\
    \ i, i)\n                                    ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpd08yzk7q.swift:22:38:\
    \ error: cannot find 'get_palindrome_length' in scope\n        let palindrome_length_even\
    \ = get_palindrome_length(string_array, i, i + 1)\n                          \
    \           ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpd08yzk7q.swift:29:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(palindrome_start))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpd08yzk7q.swift:29:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(palindrome_start))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    var string_array = Array(string.characters)\n    var palindrome_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string_array,\
    \ start: i - palindrome_length - 1, end: i) {\n            palindrome_length +=\
    \ 2\n        } else if is_palindrome(string_array, start: i - palindrome_length,\
    \ end: i) {\n            palindrome_length += 1\n        }\n    }\n    var result\
    \ = string\n    for i in 0..<string_length - palindrome_length {\n        result.append(string_array[string_length\
    \ - i - 1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpighpvx76.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpighpvx76.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    var string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpighpvx76.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: i - palindrome_length\
    \ - 1, end: i) {\n           ^~~~~~~~~~~~~\n/tmp/tmpighpvx76.swift:22:19: error:\
    \ cannot find 'is_palindrome' in scope\n        } else if is_palindrome(string_array,\
    \ start: i - palindrome_length, end: i) {\n                  ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = longest_palindrome_length_at_index(string_array,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start + 1\n    let prefix = string_array[prefix_start..<prefix_end]\n\
    \    let reversed_prefix = prefix.reverse()\n    return string + String(reversed_prefix)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpqfsfnfgs.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpqfsfnfgs.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpqfsfnfgs.swift:21:33: error: cannot find 'longest_palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = longest_palindrome_length_at_index(string_array,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqfsfnfgs.swift:30:34: error: cannot use mutating member on immutable value:\
    \ 'prefix' is a 'let' constant\n    let reversed_prefix = prefix.reverse()\n \
    \                         ~~~~~~ ^\n/tmp/tmpqfsfnfgs.swift:29:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let prefix = string_array[prefix_start..<prefix_end]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let suffix = longest_palindromic_suffix(string)\n\
    \    let prefix = String(string.prefix(string.count - suffix.count).reversed())\n\
    \    return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmppr511hgq.swift:16:18: error: cannot find 'longest_palindromic_suffix'\
    \ in scope\n    let suffix = longest_palindromic_suffix(string)\n            \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = string.characters.reverse()\n    let reversed_string = String(reversed)\n\
    \    let string_length = string.characters.count\n    let reversed_string_length\
    \ = reversed_string.characters.count\n    var max_palindrome_length = 0\n    var\
    \ max_palindrome_index = 0\n    var table = Array(count: string_length, repeatedValue:\
    \ Array(count: reversed_string_length, repeatedValue: 0))\n    for i in 0..<string_length\
    \ {\n        for j in 0..<reversed_string_length {\n            if string[i] ==\
    \ reversed_string[j] {\n                if i == 0 || j == 0 {\n              \
    \      table[i][j] = 1\n                } else {\n                    table[i][j]\
    \ = table[i - 1][j - 1] + 1\n                }\n                if table[i][j]\
    \ > max_palindrome_length {\n                    max_palindrome_length = table[i][j]\n\
    \                    max_palindrome_index = i\n                }\n           \
    \ }\n        }\n    }\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(max_palindrome_index\
    \ + 1))\n    let suffix = reversed_string.substringFromIndex(reversed_string.startIndex.advancedBy(max_palindrome_length))\n\
    \    return prefix + suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp60y12j5g.swift:13:38: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = string.characters.reverse()\n                \
    \   ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp60y12j5g.swift:15:32: error: 'characters'\
    \ is unavailable: Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp60y12j5g.swift:19:17: error: no exact matches in call\
    \ to initializer \n    var table = Array(count: string_length, repeatedValue:\
    \ Array(count: reversed_string_length, repeatedValue: 0))\n                ^\n\
    /tmp/tmp60y12j5g.swift:19:17: note: found candidate with type '(_, Int) -> Array<_>'\n\
    \    var table = Array(count: string_length, repeatedValue: Array(count: reversed_string_length,\
    \ repeatedValue: 0))\n                ^\n/tmp/tmp60y12j5g.swift:19:112: error:\
    \ extra argument 'repeatedValue' in call\n    var table = Array(count: string_length,\
    \ repeatedValue: Array(count: reversed_string_length, repeatedValue: 0))\n   \
    \                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n\
    /tmp/tmp60y12j5g.swift:35:25: error: value of type 'String' has no member 'substringToIndex'\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(max_palindrome_index\
    \ + 1))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp60y12j5g.swift:35:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(max_palindrome_index\
    \ + 1))\n                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let reversed = String(string.characters.reverse())\n\
    \    let concatenated = string + reversed\n    let suffix = longest_common_substring(string:\
    \ concatenated, substring: reversed)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - suffix.characters.count))\n    return prefix + string\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxicfujyi.swift:16:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpxicfujyi.swift:18:18: error:\
    \ cannot find 'longest_common_substring' in scope\n    let suffix = longest_common_substring(string:\
    \ concatenated, substring: reversed)\n                 ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var suffix_length\
    \ = string_length\n    while suffix_length > 0 {\n        if is_palindrome(string_array,\
    \ start: string_length - suffix_length, end: string_length - 1) {\n          \
    \  break\n        }\n        suffix_length -= 1\n    }\n    var prefix_length\
    \ = string_length - suffix_length\n    var result = string\n    while prefix_length\
    \ > 0 {\n        result.append(string_array[string_length - prefix_length])\n\
    \        prefix_length -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp2g_982nk.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp2g_982nk.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp2g_982nk.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: string_length - suffix_length,\
    \ end: string_length - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let (suffix, _) = longest_palindrome_suffix(string)\n\
    \    let prefix = String(string.characters.prefix(string.characters.count - suffix.characters.count))\n\
    \    return string + String(prefix.characters.reverse())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpbrnd4nxd.swift:16:23: error: cannot find 'longest_palindrome_suffix'\
    \ in scope\n    let (suffix, _) = longest_palindrome_suffix(string)\n        \
    \              ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpbrnd4nxd.swift:16:23: error:\
    \ type of expression is ambiguous without more context\n    let (suffix, _) =\
    \ longest_palindrome_suffix(string)\n                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length <= 1 {\n        return string\n\
    \    }\n    let string_array = Array(string.characters)\n    var max_palindrome_length\
    \ = 0\n    var max_palindrome_index = 0\n    var i = 0\n    while i < string_length\
    \ {\n        var j = 1\n        while i - j >= 0 && i + j < string_length && string_array[i\
    \ - j] == string_array[i + j] {\n            j += 1\n        }\n        if 2 *\
    \ j - 1 > max_palindrome_length {\n            max_palindrome_length = 2 * j -\
    \ 1\n            max_palindrome_index = i\n        }\n        i += 1\n    }\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(max_palindrome_index\
    \ - max_palindrome_length / 2))\n    let suffix = String(prefix.characters.reverse())\n\
    \    return string + suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpnfjp4kye.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpnfjp4kye.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpnfjp4kye.swift:32:25: error: value of type 'String'\
    \ has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(max_palindrome_index\
    \ - max_palindrome_length / 2))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpnfjp4kye.swift:32:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(max_palindrome_index\
    \ - max_palindrome_length / 2))\n                                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    if string_length == 1 {\n        return string\n    }\n    let string_characters\
    \ = Array(string.characters)\n    var longest_palindrome_length = 0\n    var longest_palindrome_start\
    \ = 0\n    for i in 0..<string_length {\n        let palindrome_length = longest_palindrome_length_from_center(string_characters,\
    \ center: i)\n        if palindrome_length > longest_palindrome_length {\n   \
    \         longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let palindrome_end = longest_palindrome_start + longest_palindrome_length\n\
    \    let prefix_start = longest_palindrome_start - (string_length - palindrome_end)\n\
    \    let prefix = string[string.index(string.startIndex, offsetBy: prefix_start)..<string.index(string.startIndex,\
    \ offsetBy: longest_palindrome_start)]\n    return string + String(prefix.characters.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpoao2i6ss.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpoao2i6ss.swift:20:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpoao2i6ss.swift:24:33: error: cannot find\
    \ 'longest_palindrome_length_from_center' in scope\n        let palindrome_length\
    \ = longest_palindrome_length_from_center(string_characters, center: i)\n    \
    \                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpoao2i6ss.swift:33:35:\
    \ error: 'characters' is unavailable: Please use Substring directly\n    return\
    \ string + String(prefix.characters.reversed())\n                            \
    \      ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: Substring { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.lowercaseString\n    let string_length = string.characters.count\n\
    \    if string_length == 0 {\n        return \"\"\n    }\n    if string_length\
    \ == 1 {\n        return string\n    }\n    let string_characters = Array(string.characters)\n\
    \    var longest_palindrome_length = 0\n    var longest_palindrome_start = 0\n\
    \    for i in 0..<string_length {\n        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start\n    let prefix = string[string.startIndex.advancedBy(prefix_start)..<string.startIndex.advancedBy(prefix_end\
    \ + 1)]\n    let reversed_prefix = String(prefix.characters.reverse())\n    return\
    \ string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp43s1lk5s.swift:13:25: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    let string = string.lowercaseString\n               \
    \  ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp43s1lk5s.swift:25:33: error: cannot find 'palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    var i = 0\n    while i < string_length\
    \ {\n        var j = 0\n        while i - j >= 0 && i + j < string_length && string_array[i\
    \ - j] == string_array[i + j] {\n            j += 1\n        }\n        if j >\
    \ longest_palindrome_length {\n            longest_palindrome_length = j\n   \
    \         longest_palindrome_index = i\n        }\n        i += 1\n    }\n   \
    \ var result = \"\"\n    for i in 0..<longest_palindrome_index - longest_palindrome_length\
    \ + 1 {\n        result.append(string_array[i])\n    }\n    for i in (longest_palindrome_index\
    \ + longest_palindrome_length - 1).stride(through: longest_palindrome_index +\
    \ 1, by: -1) {\n        result.append(string_array[i])\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpenfqr0cw.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpenfqr0cw.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpenfqr0cw.swift:36:73: error: value of type 'Int' has\
    \ no member 'stride'\n    for i in (longest_palindrome_index + longest_palindrome_length\
    \ - 1).stride(through: longest_palindrome_index + 1, by: -1) {\n             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    var string_array = Array(string.characters)\n    var palindrome_suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string_array,\
    \ start: 0, end: string_length - i - 1) {\n            palindrome_suffix_length\
    \ = string_length - i\n            break\n        }\n    }\n    var palindrome_prefix\
    \ = Array(string_array[0..<palindrome_suffix_length].reverse())\n    return String(string_array)\
    \ + String(palindrome_prefix)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpbmo2oqce.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpbmo2oqce.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    var string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpbmo2oqce.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: 0, end: string_length\
    \ - i - 1) {\n           ^~~~~~~~~~~~~\n/tmp/tmpbmo2oqce.swift:25:35: error: missing\
    \ argument label 'arrayLiteral:' in call\n    var palindrome_prefix = Array(string_array[0..<palindrome_suffix_length].reverse())\n\
    \                                  ^\n                                  arrayLiteral:\
    \ \n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let n = string.characters.count\n\
    \    if n == 0 {\n        return \"\"\n    }\n    let s = Array(string.characters)\n\
    \    var i = 0\n    while i < n - i - 1 {\n        if s[i] != s[n - i - 1] {\n\
    \            break\n        }\n        i += 1\n    }\n    var prefix = String(s[0..<i])\n\
    \    var suffix = String(s[i..<n])\n    return prefix + suffix.characters.reversed()\
    \ + prefix.characters.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpzlcgbpsv.swift:13:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let n = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpzlcgbpsv.swift:17:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    let s =\
    \ Array(string.characters)\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpzlcgbpsv.swift:27:28: error: 'characters'\
    \ is unavailable: Please use String directly\n    return prefix + suffix.characters.reversed()\
    \ + prefix.characters.reversed()\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpzlcgbpsv.swift:27:59: error: 'characters'\
    \ is unavailable: Please use String directly\n    return prefix + suffix.characters.reversed()\
    \ + prefix.characters.reversed()\n                                           \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpzlcgbpsv.swift:25:9: warning: variable 'prefix' was never mutated;\
    \ consider changing to 'let' constant\n    var prefix = String(s[0..<i])\n   \
    \ ~~~ ^\n    let\n/tmp/tmpzlcgbpsv.swift:26:9: warning: variable 'suffix' was\
    \ never mutated; consider changing to 'let' constant\n    var suffix = String(s[i..<n])\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let n = string.characters.count\n\
    \    let s = Array(string.characters)\n    var i = 0\n    while i < n {\n    \
    \    if is_palindrome(s, i, n - 1) {\n            break\n        }\n        i\
    \ += 1\n    }\n    var prefix = string.substringToIndex(string.startIndex.advancedBy(i))\n\
    \    prefix = String(prefix.characters.reverse())\n    return string + prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5vnhnkgk.swift:13:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let n = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp5vnhnkgk.swift:14:26:\
    \ error: 'characters' is unavailable: Please use String directly\n    let s =\
    \ Array(string.characters)\n                         ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp5vnhnkgk.swift:17:12: error: cannot find\
    \ 'is_palindrome' in scope\n        if is_palindrome(s, i, n - 1) {\n        \
    \   ^~~~~~~~~~~~~\n/tmp/tmp5vnhnkgk.swift:22:25: error: value of type 'String'\
    \ has no member 'substringToIndex'\n    var prefix = string.substringToIndex(string.startIndex.advancedBy(i))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp5vnhnkgk.swift:22:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    var prefix = string.substringToIndex(string.startIndex.advancedBy(i))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    if length == 0 {\n        return \"\"\n    }\n\
    \    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<length {\n     \
    \   var j = 0\n        while i - j >= 0 && i + j < length && string_chars[i -\
    \ j] == string_chars[i + j] {\n            j += 1\n        }\n        if 2 * j\
    \ - 1 > longest_palindrome_length {\n            longest_palindrome_length = 2\
    \ * j - 1\n            longest_palindrome_start = i - j + 1\n        }\n     \
    \   j = 0\n        while i - j >= 0 && i + j + 1 < length && string_chars[i -\
    \ j] == string_chars[i + j + 1] {\n            j += 1\n        }\n        if 2\
    \ * j > longest_palindrome_length {\n            longest_palindrome_length = 2\
    \ * j\n            longest_palindrome_start = i - j + 1\n        }\n    }\n  \
    \  let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start))\n\
    \    let reverse_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reverse_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpspmiasix.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpspmiasix.swift:17:37: error: 'characters' is unavailable: Please use String\
    \ directly\n    let string_chars = Array(string.characters)\n                \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpspmiasix.swift:38:25: error: value of type 'String' has no member\
    \ 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpspmiasix.swift:38:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let n = string.characters.count\n\
    \    if n == 0 {\n        return \"\"\n    }\n    let suffix = longest_palindromic_suffix(string:\
    \ string)\n    let prefix = String(string.characters.prefix(n - suffix.characters.count).reversed())\n\
    \    return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpdsaqrrf9.swift:13:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let n = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpdsaqrrf9.swift:17:18:\
    \ error: cannot find 'longest_palindromic_suffix' in scope\n    let suffix = longest_palindromic_suffix(string:\
    \ string)\n                 ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let reversed = String(string.characters.reverse())\n\
    \    let lcs = longest_common_substring(string, reversed)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lcs.characters.count))\n    return string + String(prefix.characters.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmped920h6w.swift:16:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmped920h6w.swift:17:15: error:\
    \ cannot find 'longest_common_substring' in scope\n    let lcs = longest_common_substring(string,\
    \ reversed)\n              ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmped920h6w.swift:18:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lcs.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmped920h6w.swift:18:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lcs.characters.count))\n                                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var palindrome_length\
    \ = string_length\n    var palindrome_start = 0\n    while palindrome_length >\
    \ 0 {\n        if is_palindrome(string_chars, start: palindrome_start, length:\
    \ palindrome_length) {\n            break\n        }\n        palindrome_length\
    \ -= 1\n        palindrome_start += 1\n    }\n    let prefix_length = string_length\
    \ - palindrome_length\n    let prefix_start = 0\n    let prefix_chars = Array(string.characters.prefix(prefix_length).reversed())\n\
    \    let palindrome_chars = string_chars[palindrome_start..<palindrome_start+palindrome_length]\n\
    \    return String(prefix_chars) + String(palindrome_chars)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpe_w30itu.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpe_w30itu.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpe_w30itu.swift:21:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_chars, start: palindrome_start, length:\
    \ palindrome_length) {\n           ^~~~~~~~~~~~~\n/tmp/tmpe_w30itu.swift:29:37:\
    \ error: 'characters' is unavailable: Please use String directly\n    let prefix_chars\
    \ = Array(string.characters.prefix(prefix_length).reversed())\n              \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let palindrome = string + reversed\n\
    \    let longest_palindrome = find_longest_palindrome(palindrome)\n    let prefix\
    \ = String(string.characters.prefix(string.characters.count - longest_palindrome.characters.count))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp7yrtsh8x.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp7yrtsh8x.swift:15:30: error:\
    \ cannot find 'find_longest_palindrome' in scope\n    let longest_palindrome =\
    \ find_longest_palindrome(palindrome)\n                             ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let length = string.count\n    var i = 0\n    var j\
    \ = length - 1\n    while i < j {\n        if string[i] != string[j] {\n     \
    \       break\n        }\n        i += 1\n        j -= 1\n    }\n    if i >= j\
    \ {\n        return String(string)\n    }\n    let prefix = string[0..<i]\n  \
    \  let suffix = string[i..<length]\n    let reversed_prefix = prefix.reversed()\n\
    \    return String(suffix) + String(reversed_prefix) + String(suffix)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpeqzuuzso.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpeqzuuzso.swift:18:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != string[j] {\n         \
    \  ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpeqzuuzso.swift:18:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] != string[j] {\n                        ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpeqzuuzso.swift:27:18:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n    let prefix = string[0..<i]\n \
    \                ^~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpeqzuuzso.swift:28:18:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n    let suffix = string[i..<length]\n\
    \                 ^~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let string_length = string.characters.count\n\
    \    let reversed_length = reversed.characters.count\n    var lps = [Int](count:\
    \ reversed_length, repeatedValue: 0)\n    var i = 1\n    var j = 0\n    while\
    \ i < reversed_length {\n        if reversed[reversed.startIndex.advancedBy(i)]\
    \ == reversed[reversed.startIndex.advancedBy(j)] {\n            lps[i] = j + 1\n\
    \            i += 1\n            j += 1\n        } else {\n            if j !=\
    \ 0 {\n                j = lps[j - 1]\n            } else {\n                lps[i]\
    \ = 0\n                i += 1\n            }\n        }\n    }\n    let prefix\
    \ = reversed.substringToIndex(reversed.startIndex.advancedBy(reversed_length -\
    \ lps[reversed_length - 1]))\n    return string + prefix\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp8t77ey1x.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp8t77ey1x.swift:14:32: error:\
    \ 'characters' is unavailable: Please use String directly\n    let string_length\
    \ = string.characters.count\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8t77ey1x.swift:16:60: error: extra argument\
    \ 'repeatedValue' in call\n    var lps = [Int](count: reversed_length, repeatedValue:\
    \ 0)\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var palindrome_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string_array,\
    \ start: 0, end: string_length - i - 1) {\n            palindrome_length = string_length\
    \ - i\n            break\n        }\n    }\n    var result = string\n    for i\
    \ in 0..<string_length - palindrome_length {\n        result.append(string_array[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpjy2lz8sr.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpjy2lz8sr.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjy2lz8sr.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: 0, end: string_length\
    \ - i - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let stringLength\
    \ = string.characters.count\n    if stringLength == 0 {\n        return \"\"\n\
    \    }\n    var suffix = string\n    var prefix = \"\"\n    for _ in 0..<stringLength\
    \ {\n        if is_palindrome(suffix) {\n            break\n        }\n      \
    \  suffix.removeAtIndex(suffix.startIndex)\n        prefix.append(string[string.endIndex.predecessor()])\n\
    \    }\n    return string + reverse(prefix)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpcnknzu1m.swift:13:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    let stringLength = string.characters.count\n      \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpcnknzu1m.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(suffix) {\n           ^~~~~~~~~~~~~\n/tmp/tmpcnknzu1m.swift:23:16:\
    \ error: value of type 'String' has no member 'removeAtIndex'\n        suffix.removeAtIndex(suffix.startIndex)\n\
    \        ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpcnknzu1m.swift:24:46: error: value of type\
    \ 'String.Index' has no member 'predecessor'\n        prefix.append(string[string.endIndex.predecessor()])\n\
    \                             ~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpcnknzu1m.swift:26:21:\
    \ error: cannot find 'reverse' in scope\n    return string + reverse(prefix)\n\
    \                    ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let suffix = longest_palindromic_suffix(string)\n\
    \    let prefix = String(string.prefix(string.count - suffix.count).reversed())\n\
    \    return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmppr511hgq.swift:16:18: error: cannot find 'longest_palindromic_suffix'\
    \ in scope\n    let suffix = longest_palindromic_suffix(string)\n            \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_characters = Array(string.characters)\n    var palindrome_suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if string_characters[i] == string_characters[string_length\
    \ - 1 - i] {\n            palindrome_suffix_length += 1\n        } else {\n  \
    \          break\n        }\n    }\n    if palindrome_suffix_length == string_length\
    \ {\n        return string\n    }\n    let palindrome_prefix = String(string_characters[0..<(string_length\
    \ - palindrome_suffix_length)])\n    let palindrome_prefix_reversed = String(palindrome_prefix.characters.reverse())\n\
    \    return string + palindrome_prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp3hiyxpta.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp3hiyxpta.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp3hiyxpta.swift:30:74: error: value of type\
    \ 'String' has no member 'reverse'\n    let palindrome_prefix_reversed = String(palindrome_prefix.characters.reverse())\n\
    \                                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    let string_array = Array(string.characters)\n\
    \    var longest_palindrome_length = 0\n    var longest_palindrome_start = 0\n\
    \    for i in 0..<string_length {\n        let palindrome_length = longest_palindrome_length_at_index(string_array,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let palindrome_end = longest_palindrome_start + longest_palindrome_length\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    let suffix\
    \ = string.substringFromIndex(string.startIndex.advancedBy(palindrome_end))\n\
    \    return string + reversed_prefix + suffix\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpvl4jc8d2.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpvl4jc8d2.swift:14:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvl4jc8d2.swift:18:33: error: cannot find 'longest_palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = longest_palindrome_length_at_index(string_array,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpvl4jc8d2.swift:25:25: error: value of type 'String' has no member 'substringToIndex'\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpvl4jc8d2.swift:25:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpvl4jc8d2.swift:27:25:\
    \ error: value of type 'String' has no member 'substringFromIndex'\n    let suffix\
    \ = string.substringFromIndex(string.startIndex.advancedBy(palindrome_end))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpvl4jc8d2.swift:27:62: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let suffix = string.substringFromIndex(string.startIndex.advancedBy(palindrome_end))\n\
    \                                           ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_characters = Array(string.characters)\n    var i = 0\n\
    \    while i < string_length {\n        if is_palindrome(string_characters, start:\
    \ 0, end: string_length - i - 1) {\n            break\n        }\n        i +=\
    \ 1\n    }\n    var result = string\n    for j in 0..<i {\n        result.append(string_characters[j])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpsknrhzje.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpsknrhzje.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpsknrhzje.swift:20:12: error: cannot find\
    \ 'is_palindrome' in scope\n        if is_palindrome(string_characters, start:\
    \ 0, end: string_length - i - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var i = string_length\
    \ - 1\n    while i >= 0 {\n        if is_palindrome(string_array, start: 0, end:\
    \ i) {\n            break\n        }\n        i -= 1\n    }\n    let prefix =\
    \ string.substringToIndex(string.startIndex.advancedBy(i + 1))\n    return string\
    \ + String(prefix.characters.reverse())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp79l86xhd.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp79l86xhd.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp79l86xhd.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: 0, end: i) {\n     \
    \      ^~~~~~~~~~~~~\n/tmp/tmp79l86xhd.swift:25:25: error: value of type 'String'\
    \ has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(i\
    \ + 1))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp79l86xhd.swift:25:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(i + 1))\n           \
    \                              ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = longest_palindrome_length_at(string_chars, i)\n\
    \        if palindrome_length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length\n            longest_palindrome_start = i\n        }\n \
    \   }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start + 1\n    let prefix = string_chars[prefix_start..<prefix_end]\n\
    \    let prefix_reversed = prefix.reverse()\n    return string + String(prefix_reversed)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp7wiwls6h.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp7wiwls6h.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp7wiwls6h.swift:21:33: error: cannot find 'longest_palindrome_length_at'\
    \ in scope\n        let palindrome_length = longest_palindrome_length_at(string_chars,\
    \ i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7wiwls6h.swift:30:34:\
    \ error: cannot use mutating member on immutable value: 'prefix' is a 'let' constant\n\
    \    let prefix_reversed = prefix.reverse()\n                          ~~~~~~\
    \ ^\n/tmp/tmp7wiwls6h.swift:29:5: note: change 'let' to 'var' to make it mutable\n\
    \    let prefix = string_chars[prefix_start..<prefix_end]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var palindrome_suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string_chars,\
    \ start: 0, end: string_length - i - 1) {\n            palindrome_suffix_length\
    \ = string_length - i\n            break\n        }\n    }\n    var palindrome_prefix\
    \ = Array(string_chars[0..<palindrome_suffix_length])\n    palindrome_prefix.reverse()\n\
    \    return string + String(palindrome_prefix)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpnje1riqi.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpnje1riqi.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpnje1riqi.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_chars, start: 0, end: string_length\
    \ - i - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_length = string.count\n    if string_length\
    \ == 0 {\n        return \"\"\n    }\n    let string_length_half = string_length\
    \ / 2\n    var suffix_length = 0\n    for i in 0..<string_length_half {\n    \
    \    if string[i] == string[string_length - 1 - i] {\n            suffix_length\
    \ += 1\n        } else {\n            break\n        }\n    }\n    let prefix\
    \ = string[0..<string_length - suffix_length]\n    let prefix_reversed = String(prefix.reverse())\n\
    \    return string + prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxpwu0m8o.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpxpwu0m8o.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == string[string_length -\
    \ 1 - i] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpxpwu0m8o.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == string[string_length - 1 - i] {\n                   \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpxpwu0m8o.swift:27:18: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    let prefix = string[0..<string_length - suffix_length]\n\
    \                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmpxpwu0m8o.swift:28:41: error: value of type 'String'\
    \ has no member 'reverse'\n    let prefix_reversed = String(prefix.reverse())\n\
    \                                 ~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = string.reverse()\n    let length = string.characters.count\n    let reversed_prefix\
    \ = reversed.substringToIndex(reversed.startIndex.advancedBy(length))\n    let\
    \ reversed_suffix = reversed.substringFromIndex(reversed.startIndex.advancedBy(length))\n\
    \    let palindrome_suffix = reversed_suffix + string\n    let palindrome_suffix_length\
    \ = palindrome_suffix.characters.count\n    var palindrome_suffix_index = palindrome_suffix.startIndex\n\
    \    var palindrome_suffix_end_index = palindrome_suffix.startIndex\n    var palindrome_suffix_length_index\
    \ = 0\n    var palindrome_suffix_length_end_index = 0\n    while palindrome_suffix_index\
    \ < palindrome_suffix.endIndex {\n        palindrome_suffix_end_index = palindrome_suffix.startIndex.advancedBy(palindrome_suffix_length\
    \ - palindrome_suffix_length_index)\n        if palindrome_suffix[palindrome_suffix_index]\
    \ == palindrome_suffix[palindrome_suffix_end_index] {\n            palindrome_suffix_length_index\
    \ += 1\n            palindrome_suffix_length_end_index += 1\n        } else {\n\
    \            palindrome_suffix_length_index = 0\n            palindrome_suffix_length_end_index\
    \ = 0\n        }\n        palindrome_suffix_index = palindrome_suffix_index.successor()\n\
    \    }\n    return reversed_prefix + palindrome_suffix.substringFromIndex(palindrome_suffix.startIndex.advancedBy(palindrome_suffix_length_end_index))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxd0yx4_d.swift:13:27: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = string.reverse()\n                   ~~~~~~ ^~~~~~~\n\
    /tmp/tmpxd0yx4_d.swift:14:25: error: 'characters' is unavailable: Please use String\
    \ directly\n    let length = string.characters.count\n                       \
    \ ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = Array(string)\n    let length = string.count\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    for i in 0..<length {\n     \
    \   let palindrome_length = palindrome_length_at(string: string, index: i)\n \
    \       if palindrome_length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length\n            longest_palindrome_index = i\n        }\n \
    \   }\n    let palindrome_end = longest_palindrome_index + longest_palindrome_length\n\
    \    let prefix = string[0..<(longest_palindrome_index - longest_palindrome_length)]\n\
    \    let suffix = string[palindrome_end..<length]\n    return String(prefix +\
    \ suffix.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpqeagm2mv.swift:18:33: error: cannot find 'palindrome_length_at'\
    \ in scope\n        let palindrome_length = palindrome_length_at(string: string,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let len = string.characters.count\n\
    \    if len == 0 {\n        return \"\"\n    }\n    let chars = Array(string.characters)\n\
    \    var i = len - 1\n    while i >= 0 {\n        if chars[0...i] == chars[i...i].reverse()\
    \ {\n            break\n        }\n        i -= 1\n    }\n    return string +\
    \ String(chars[0...len - i - 1].reverse())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmphqcteiuo.swift:13:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    let len = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmphqcteiuo.swift:17:30:\
    \ error: 'characters' is unavailable: Please use String directly\n    let chars\
    \ = Array(string.characters)\n                             ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmphqcteiuo.swift:20:25: error: binary operator\
    \ '==' cannot be applied to operands of type 'ArraySlice<String.Element>' (aka\
    \ 'ArraySlice<Character>') and '()'\n        if chars[0...i] == chars[i...i].reverse()\
    \ {\n           ~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphqcteiuo.swift:20:25:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ ((), ())\n        if chars[0...i] == chars[i...i].reverse() {\n            \
    \            ^\n/tmp/tmphqcteiuo.swift:25:21: error: type '()' cannot conform\
    \ to 'LosslessStringConvertible'\n    return string + String(chars[0...len - i\
    \ - 1].reverse())\n                    ^\n/tmp/tmphqcteiuo.swift:25:21: note:\
    \ only concrete types such as structs, enums and classes can conform to protocols\n\
    \    return string + String(chars[0...len - i - 1].reverse())\n              \
    \      ^\n/tmp/tmphqcteiuo.swift:25:21: note: required by initializer 'init(_:)'\
    \ where 'T' = '()'\n    return string + String(chars[0...len - i - 1].reverse())\n\
    \                    ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let reversed = String(string.characters.reverse())\n\
    \    let postfix = reversed.substringFromIndex(reversed.startIndex.advancedBy(string.characters.count\
    \ - longest_palindromic_suffix(string).characters.count))\n    return string +\
    \ postfix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmprsu7jm1m.swift:16:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmprsu7jm1m.swift:17:104: error:\
    \ cannot find 'longest_palindromic_suffix' in scope\n    let postfix = reversed.substringFromIndex(reversed.startIndex.advancedBy(string.characters.count\
    \ - longest_palindromic_suffix(string).characters.count))\n                  \
    \                                                                            \
    \         ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let reversed = String(string.characters.reverse())\n\
    \    let palindrome = string + reversed\n    let suffix = longest_common_suffix(palindrome,\
    \ string)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - suffix.characters.count))\n    return prefix + string\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpq4628z5y.swift:16:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpq4628z5y.swift:18:18: error:\
    \ cannot find 'longest_common_suffix' in scope\n    let suffix = longest_common_suffix(palindrome,\
    \ string)\n                 ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let (palindrome, _) = find_longest_palindrome(string:\
    \ string)\n    let prefix = String(string.prefix(string.count - palindrome.count))\n\
    \    return string + String(prefix.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp2sse_ew0.swift:16:27: error: cannot find 'find_longest_palindrome'\
    \ in scope\n    let (palindrome, _) = find_longest_palindrome(string: string)\n\
    \                          ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp2sse_ew0.swift:16:27:\
    \ error: type of expression is ambiguous without more context\n    let (palindrome,\
    \ _) = find_longest_palindrome(string: string)\n                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let palindrome_suffix = longest_palindrome_suffix(string)\n\
    \    let prefix = string.substringToIndex(string.endIndex.advancedBy(-palindrome_suffix.characters.count))\n\
    \    return string + reversed.substringFromIndex(prefix.endIndex)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxropgtk9.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpxropgtk9.swift:14:29: error:\
    \ cannot find 'longest_palindrome_suffix' in scope\n    let palindrome_suffix\
    \ = longest_palindrome_suffix(string)\n                            ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxropgtk9.swift:15:25: error: value of type 'String' has no member 'substringToIndex'\n\
    \    let prefix = string.substringToIndex(string.endIndex.advancedBy(-palindrome_suffix.characters.count))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpxropgtk9.swift:15:58: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.endIndex.advancedBy(-palindrome_suffix.characters.count))\n\
    \                                         ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length <= 1 {\n        return string\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = longest_palindrome_length_at(string_chars, i)\n\
    \        if palindrome_length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length\n            longest_palindrome_start = i\n        }\n \
    \   }\n    let palindrome_end = longest_palindrome_start + longest_palindrome_length\n\
    \    let prefix_start = palindrome_end + 1\n    let prefix_end = string_length\n\
    \    let prefix = string[string.index(string.startIndex, offsetBy: prefix_start)..<string.index(string.startIndex,\
    \ offsetBy: prefix_end)]\n    let reversed_prefix = String(prefix.characters.reversed())\n\
    \    return string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5y26d7cp.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp5y26d7cp.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp5y26d7cp.swift:21:33: error: cannot find 'longest_palindrome_length_at'\
    \ in scope\n        let palindrome_length = longest_palindrome_length_at(string_chars,\
    \ i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5y26d7cp.swift:31:41:\
    \ error: 'characters' is unavailable: Please use Substring directly\n    let reversed_prefix\
    \ = String(prefix.characters.reversed())\n                                   \
    \     ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: Substring { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    if length == 0 {\n        return \"\"\n    }\n\
    \    let chars = Array(string.characters)\n    let reversed = chars.reverse()\n\
    \    let reversed_string = String(reversed)\n    let suffix = longest_common_suffix(string,\
    \ reversed_string)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(length\
    \ - suffix.characters.count))\n    return string + reversed_string.substringFromIndex(reversed_string.startIndex.advancedBy(suffix.characters.count))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp0kp6wtl8.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp0kp6wtl8.swift:17:30: error: 'characters' is unavailable: Please use String\
    \ directly\n    let chars = Array(string.characters)\n                       \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp0kp6wtl8.swift:18:26:\
    \ error: cannot use mutating member on immutable value: 'chars' is a 'let' constant\n\
    \    let reversed = chars.reverse()\n                   ~~~~~ ^\n/tmp/tmp0kp6wtl8.swift:17:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let chars = Array(string.characters)\n\
    \    ^~~\n    var\n/tmp/tmp0kp6wtl8.swift:20:18: error: cannot find 'longest_common_suffix'\
    \ in scope\n    let suffix = longest_common_suffix(string, reversed_string)\n\
    \                 ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0kp6wtl8.swift:21:25: error:\
    \ value of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(length\
    \ - suffix.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp0kp6wtl8.swift:21:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(length - suffix.characters.count))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string_chars, string_length:\
    \ string_length, index: i)\n        if palindrome_length > longest_palindrome_length\
    \ {\n            longest_palindrome_length = palindrome_length\n            longest_palindrome_index\
    \ = i\n        }\n    }\n    let prefix_length = longest_palindrome_index - longest_palindrome_length\
    \ + 1\n    let prefix = String(string_chars[0..<prefix_length])\n    let reversed_prefix\
    \ = String(prefix.characters.reverse())\n    return string + reversed_prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxqvz22tr.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpxqvz22tr.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpxqvz22tr.swift:21:33: error: cannot find 'palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = palindrome_length_at_index(string_chars,\
    \ string_length: string_length, index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxqvz22tr.swift:29:52: error: value of type 'String' has no member 'reverse'\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n             \
    \                    ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp8_1o_6n2.swift:16:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp8_1o_6n2.swift:18:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8_1o_6n2.swift:19:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp8_1o_6n2.swift:19:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    var suffix_length = 0\n    for i in 0..<string_length {\n        let\
    \ suffix = string.substring(from: string.index(string.startIndex, offsetBy: i))\n\
    \        if is_palindrome(string: suffix) {\n            suffix_length = suffix.characters.count\n\
    \            break\n        }\n    }\n    let prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: string_length - suffix_length))\n    return string + String(prefix.characters.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpb98s3oiq.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpb98s3oiq.swift:19:29: error: value of type 'String' has\
    \ no member 'substring'\n        let suffix = string.substring(from: string.index(string.startIndex,\
    \ offsetBy: i))\n                     ~~~~~~ ^~~~~~~~~\n/tmp/tmpb98s3oiq.swift:20:12:\
    \ error: cannot find 'is_palindrome' in scope\n        if is_palindrome(string:\
    \ suffix) {\n           ^~~~~~~~~~~~~\n/tmp/tmpb98s3oiq.swift:25:25: error: value\
    \ of type 'String' has no member 'substring'\n    let prefix = string.substring(to:\
    \ string.index(string.startIndex, offsetBy: string_length - suffix_length))\n\
    \                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let string_length = string.characters.count\n\
    \    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_position(string_array, position:\
    \ i)\n        if palindrome_length > longest_palindrome_length {\n           \
    \ longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start + 1\n    let prefix = string_array[prefix_start..<prefix_end]\n\
    \    let reversed_prefix = prefix.reverse()\n    return string + String(reversed_prefix)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpck8gwzeh.swift:16:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpck8gwzeh.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpck8gwzeh.swift:21:33: error: cannot find 'palindrome_length_at_position'\
    \ in scope\n        let palindrome_length = palindrome_length_at_position(string_array,\
    \ position: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpck8gwzeh.swift:30:34: error: cannot use mutating member on immutable value:\
    \ 'prefix' is a 'let' constant\n    let reversed_prefix = prefix.reverse()\n \
    \                         ~~~~~~ ^\n/tmp/tmpck8gwzeh.swift:29:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let prefix = string_array[prefix_start..<prefix_end]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_common_suffix = longest_common_substring(string,\
    \ reversed)\n    let prefix = String(string.characters.dropLast(longest_common_suffix.characters.count))\n\
    \    return string + String(prefix.characters.reverse())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6cepn9bw.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp6cepn9bw.swift:14:33: error:\
    \ cannot find 'longest_common_substring' in scope\n    let longest_common_suffix\
    \ = longest_common_substring(string, reversed)\n                             \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var i = string_length\
    \ - 1\n    while i >= 0 {\n        if is_palindrome(string_array, start: 0, end:\
    \ i) {\n            break\n        }\n        i -= 1\n    }\n    var result =\
    \ string\n    for j in 0..<string_length - i - 1 {\n        result.append(string_array[string_length\
    \ - j - 1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpqiwpj79d.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpqiwpj79d.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpqiwpj79d.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: 0, end: i) {\n     \
    \      ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_length = string.count\n    if string_length\
    \ == 0 {\n        return \"\"\n    }\n    var longest_palindrome_length = 0\n\
    \    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n    \
    \    let palindrome_length = get_palindrome_length(string, i)\n        if palindrome_length\
    \ > longest_palindrome_length {\n            longest_palindrome_length = palindrome_length\n\
    \            longest_palindrome_start = i\n        }\n    }\n    let palindrome_end\
    \ = longest_palindrome_start + longest_palindrome_length\n    let prefix = string[0..<longest_palindrome_start].reversed()\n\
    \    let suffix = string[palindrome_end..<string_length]\n    return String(string[0..<palindrome_end])\
    \ + String(prefix) + String(suffix)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp1nvztcs6.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp1nvztcs6.swift:21:33:\
    \ error: cannot find 'get_palindrome_length' in scope\n        let palindrome_length\
    \ = get_palindrome_length(string, i)\n                                ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1nvztcs6.swift:28:18: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n    let prefix\
    \ = string[0..<longest_palindrome_start].reversed()\n                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp1nvztcs6.swift:29:18: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n    let suffix = string[palindrome_end..<string_length]\n  \
    \               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmp1nvztcs6.swift:30:19: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an integer range, use a String.Index range instead.\n    return\
    \ String(string[0..<palindrome_end]) + String(prefix) + String(suffix)\n     \
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014264
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    let reversed_string_array\
    \ = string_array.reversed()\n    var longest_palindrome_suffix_length = 0\n  \
    \  for i in 0..<string_length {\n        if string_array[i] == reversed_string_array[i]\
    \ {\n            longest_palindrome_suffix_length += 1\n        } else {\n   \
    \         break\n        }\n    }\n    let prefix_to_append = string_array[0..<(string_length\
    \ - longest_palindrome_suffix_length)].reversed()\n    return string + String(prefix_to_append)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp10g7165v.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp10g7165v.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp10g7165v.swift:21:53: error: cannot convert value of\
    \ type 'Int' to expected argument type 'ReversedCollection<[String.Element]>.Index'\
    \ (aka 'ReversedCollection<Array<Character>>.Index')\n        if string_array[i]\
    \ == reversed_string_array[i] {\n                                            \
    \        ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let suffix = longest_palindromic_suffix(string)\n\
    \    let prefix = String(string.prefix(string.count - suffix.count).reversed())\n\
    \    return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmppr511hgq.swift:16:18: error: cannot find 'longest_palindromic_suffix'\
    \ in scope\n    let suffix = longest_palindromic_suffix(string)\n            \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var i = string_length\
    \ - 1\n    while i >= 0 {\n        if is_palindrome(string_chars, start: 0, end:\
    \ i) {\n            break\n        }\n        i -= 1\n    }\n    let prefix =\
    \ string[string.startIndex..<string.index(string.startIndex, offsetBy: i + 1)]\n\
    \    let reversed_prefix = String(prefix.characters.reversed())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpcabdlhri.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpcabdlhri.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpcabdlhri.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_chars, start: 0, end: i) {\n     \
    \      ^~~~~~~~~~~~~\n/tmp/tmpcabdlhri.swift:26:41: error: 'characters' is unavailable:\
    \ Please use Substring directly\n    let reversed_prefix = String(prefix.characters.reversed())\n\
    \                                        ^~~~~~~~~~\nSwift.Substring:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: Substring\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = min(i, string_length - i - 1)\n        var palindrome_start\
    \ = i - palindrome_length\n        var palindrome_end = i + palindrome_length\n\
    \        while palindrome_start >= 0 && palindrome_end < string_length && string_characters[palindrome_start]\
    \ == string_characters[palindrome_end] {\n            palindrome_start -= 1\n\
    \            palindrome_end += 1\n        }\n        palindrome_start += 1\n \
    \       palindrome_end -= 1\n        if palindrome_end - palindrome_start > longest_palindrome_length\
    \ {\n            longest_palindrome_length = palindrome_end - palindrome_start\n\
    \            longest_palindrome_start = palindrome_start\n        }\n    }\n \
    \   let prefix = String(string_characters[0..<longest_palindrome_start])\n   \
    \ let suffix = String(string_characters[longest_palindrome_start..<string_length])\n\
    \    return suffix + String(prefix.characters.reverse())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpylafn0yn.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpylafn0yn.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpylafn0yn.swift:37:46: error: value of type\
    \ 'String' has no member 'reverse'\n    return suffix + String(prefix.characters.reverse())\n\
    \                           ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    var suffix_length = string_length\n    while suffix_length > 0 {\n\
    \        let suffix = string.substring(from: string.index(string.startIndex, offsetBy:\
    \ string_length - suffix_length))\n        if is_palindrome(string: suffix) {\n\
    \            let prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: string_length - suffix_length))\n            return string + String(prefix.characters.reversed())\n\
    \        }\n        suffix_length -= 1\n    }\n    return \"\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpamd3rod4.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpamd3rod4.swift:19:29: error: value of type 'String' has\
    \ no member 'substring'\n        let suffix = string.substring(from: string.index(string.startIndex,\
    \ offsetBy: string_length - suffix_length))\n                     ~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpamd3rod4.swift:20:12: error: cannot find 'is_palindrome' in scope\n  \
    \      if is_palindrome(string: suffix) {\n           ^~~~~~~~~~~~~\n/tmp/tmpamd3rod4.swift:21:33:\
    \ error: value of type 'String' has no member 'substring'\n            let prefix\
    \ = string.substring(to: string.index(string.startIndex, offsetBy: string_length\
    \ - suffix_length))\n                         ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string_chars, index:\
    \ i)\n        if palindrome_length > longest_palindrome_length {\n           \
    \ longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start + 1\n    let prefix = string_chars[prefix_start..<prefix_end]\n\
    \    let reversed_prefix = prefix.reverse()\n    let result = string + String(reversed_prefix)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmphn3_0vxs.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmphn3_0vxs.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmphn3_0vxs.swift:21:33: error: cannot find 'palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = palindrome_length_at_index(string_chars,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphn3_0vxs.swift:30:34:\
    \ error: cannot use mutating member on immutable value: 'prefix' is a 'let' constant\n\
    \    let reversed_prefix = prefix.reverse()\n                          ~~~~~~\
    \ ^\n/tmp/tmphn3_0vxs.swift:29:5: note: change 'let' to 'var' to make it mutable\n\
    \    let prefix = string_chars[prefix_start..<prefix_end]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_characters = Array(string.characters)\n    var i = string_length\
    \ - 1\n    while i >= 0 {\n        if string_characters[0...i] == string_characters[i...string_length\
    \ - 1].reverse() {\n            break\n        }\n        i -= 1\n    }\n    return\
    \ string + string_characters[0...string_length - i - 1].reverse().joinWithSeparator(\"\
    \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(make_palindrome(string: \"\"\
    ) == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmplk8vp83u.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmplk8vp83u.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmplk8vp83u.swift:20:37: error: binary operator\
    \ '==' cannot be applied to operands of type 'ArraySlice<String.Element>' (aka\
    \ 'ArraySlice<Character>') and '()'\n        if string_characters[0...i] == string_characters[i...string_length\
    \ - 1].reverse() {\n           ~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplk8vp83u.swift:20:37: note: overloads for '==' exist with these partially\
    \ matching parameter lists: ((), ())\n        if string_characters[0...i] == string_characters[i...string_length\
    \ - 1].reverse() {\n                                    ^\n/tmp/tmplk8vp83u.swift:25:76:\
    \ error: value of tuple type '()' has no member 'joinWithSeparator'\n    return\
    \ string + string_characters[0...string_length - i - 1].reverse().joinWithSeparator(\"\
    \")\n                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = get_palindrome_length(string_chars, i)\n    \
    \    if palindrome_length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length\n            longest_palindrome_index = i\n        }\n \
    \   }\n    var result = string\n    for i in 0..<string_length - longest_palindrome_length\
    \ {\n        result.append(string_chars[string_length - i - 1])\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp02qq29sd.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp02qq29sd.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp02qq29sd.swift:21:33: error: cannot find 'get_palindrome_length'\
    \ in scope\n        let palindrome_length = get_palindrome_length(string_chars,\
    \ i)\n                                ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_suffix = longest_common_suffix(string,\
    \ reversed)\n    let prefix = String(string.characters.dropLast(longest_suffix.characters.count))\n\
    \    return string + String(prefix.characters.reverse())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpmk9ldl4k.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpmk9ldl4k.swift:14:26: error:\
    \ cannot find 'longest_common_suffix' in scope\n    let longest_suffix = longest_common_suffix(string,\
    \ reversed)\n                         ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let string_length = string.characters.count\n\
    \    let reversed_length = reversed.characters.count\n    var lps = [Int](count:\
    \ reversed_length, repeatedValue: 0)\n    var i = 1\n    var j = 0\n    while\
    \ i < reversed_length {\n        if reversed[reversed.startIndex.advancedBy(i)]\
    \ == reversed[reversed.startIndex.advancedBy(j)] {\n            lps[i] = j + 1\n\
    \            i += 1\n            j += 1\n        } else {\n            if j !=\
    \ 0 {\n                j = lps[j - 1]\n            } else {\n                lps[i]\
    \ = 0\n                i += 1\n            }\n        }\n    }\n    return string\
    \ + reversed.substringFromIndex(reversed.startIndex.advancedBy(lps[reversed_length\
    \ - 1]))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp36w88yet.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp36w88yet.swift:14:32: error:\
    \ 'characters' is unavailable: Please use String directly\n    let string_length\
    \ = string.characters.count\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp36w88yet.swift:16:60: error: extra argument\
    \ 'repeatedValue' in call\n    var lps = [Int](count: reversed_length, repeatedValue:\
    \ 0)\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let n = string.characters.count\n\
    \    if n == 0 {\n        return \"\"\n    }\n    let string_chars = Array(string.characters)\n\
    \    let reversed_string_chars = Array(string.characters.reversed())\n    var\
    \ longest_palindrome_length = 0\n    var longest_palindrome_start = 0\n    for\
    \ i in 0..<n {\n        let palindrome_length = min(n - i, i + 1)\n        var\
    \ is_palindrome = true\n        for j in 0..<palindrome_length {\n           \
    \ if string_chars[i - j] != reversed_string_chars[i + j] {\n                is_palindrome\
    \ = false\n                break\n            }\n        }\n        if is_palindrome\
    \ && palindrome_length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length\n            longest_palindrome_start = i\n        }\n \
    \   }\n    var result = string\n    for i in 0..<n - longest_palindrome_length\
    \ {\n        result.append(reversed_string_chars[i])\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjf7zrbev.swift:13:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let n = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpjf7zrbev.swift:17:37:\
    \ error: 'characters' is unavailable: Please use String directly\n    let string_chars\
    \ = Array(string.characters)\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjf7zrbev.swift:18:46:\
    \ error: 'characters' is unavailable: Please use String directly\n    let reversed_string_chars\
    \ = Array(string.characters.reversed())\n                                    \
    \         ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpjf7zrbev.swift:20:9:\
    \ warning: variable 'longest_palindrome_start' was written to, but never read\n\
    \    var longest_palindrome_start = 0\n        ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    let string_chars = Array(string.characters)\n\
    \    var palindrome_suffix = \"\"\n    var palindrome_prefix = \"\"\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    var palindrome_length = 0\n \
    \   var palindrome_index = 0\n    var i = 0\n    var j = 0\n    var k = 0\n  \
    \  var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n   \
    \ var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var\
    \ v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var aa\
    \ = 0\n    var ab = 0\n    var ac = 0\n    var ad = 0\n    var ae = 0\n    var\
    \ af = 0\n    var ag = 0\n    var ah = 0\n    var ai = 0\n    var aj = 0\n   \
    \ var ak = 0\n    var al = 0\n    var am = 0\n    var an = 0\n    var ao = 0\n\
    \    var ap = 0\n    var aq = 0\n    var ar = 0\n    var as = 0\n    var at =\
    \ 0\n    var au = 0\n    var av = 0\n    var aw = 0\n    var ax = 0\n    var ay\
    \ = 0\n    var az = 0\n    var ba = 0\n    var bb = 0\n    var bc = 0\n    var\
    \ bd = 0\n    var be = 0\n    var bf = 0\n    var bg = 0\n    var bh = 0\n   \
    \ var bi = 0\n    var bj = 0\n    var bk = 0\n    var bl = 0\n    var bm = 0\n\
    \    var bn = 0\n    var bo = 0\n    var bp = 0\n    var bq = 0\n    var br =\
    \ 0\n    var bs = 0\n    var bt = 0\n    var bu = 0\n    var bv = 0\n    var\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpip3uewfu.swift:57:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmpip3uewfu.swift:57:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmpip3uewfu.swift:87:8: error: expected pattern\n    var\n\
    \       ^\n/tmp/tmpip3uewfu.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpip3uewfu.swift:14:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpip3uewfu.swift:13:9: warning: initialization of immutable\
    \ value 'string_length' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    let string_length = string.characters.count\n    ~~~~^~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpip3uewfu.swift:14:9: warning: initialization of immutable value\
    \ 'string_chars' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    let string_chars = Array(string.characters)\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmpip3uewfu.swift:15:9: warning: initialization of variable 'palindrome_suffix'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var palindrome_suffix = \"\"\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpip3uewfu.swift:16:9:\
    \ warning: initialization of variable 'palindrome_prefix' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var palindrome_prefix =\
    \ \"\"\n    ~~~~^~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpip3uewfu.swift:17:9: warning:\
    \ initialization of variable 'longest_palindrome_length' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var longest_palindrome_len"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let (suffix, _) = longest_common_substring(string,\
    \ reversed)\n    return string + reversed.substringFromIndex(suffix.endIndex)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp7f9y79es.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp7f9y79es.swift:14:23: error:\
    \ cannot find 'longest_common_substring' in scope\n    let (suffix, _) = longest_common_substring(string,\
    \ reversed)\n                      ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7f9y79es.swift:14:23:\
    \ error: type of expression is ambiguous without more context\n    let (suffix,\
    \ _) = longest_common_substring(string, reversed)\n                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    if length == 0 {\n        return \"\"\n    }\n\
    \    let reversed = String(string.characters.reverse())\n    let suffix = reversed.substringFromIndex(reversed.startIndex.advancedBy(length\
    \ - 1))\n    let prefix = reversed.substringToIndex(reversed.startIndex.advancedBy(length\
    \ - 1))\n    return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpji8vlqer.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpji8vlqer.swift:17:45: error: value of type 'String' has no member 'reverse'\n\
    \    let reversed = String(string.characters.reverse())\n                    \
    \      ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let string_length = string.characters.count\n\
    \    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_index = 0\n    var current_palindrome_length\
    \ = 0\n    var current_palindrome_index = 0\n    for i in 0..<string_length {\n\
    \        if is_palindrome(string_array, start: i - current_palindrome_length -\
    \ 1, end: i) {\n            current_palindrome_length += 2\n            current_palindrome_index\
    \ = i - current_palindrome_length + 1\n        } else if is_palindrome(string_array,\
    \ start: i - current_palindrome_length, end: i) {\n            current_palindrome_length\
    \ += 1\n            current_palindrome_index = i - current_palindrome_length +\
    \ 1\n        }\n        if current_palindrome_length > longest_palindrome_length\
    \ {\n            longest_palindrome_length = current_palindrome_length\n     \
    \       longest_palindrome_index = current_palindrome_index\n        }\n    }\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \    let suffix = string.substringFromIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ + longest_palindrome_length))\n    return prefix + String(suffix.characters.reverse())\
    \ + suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpyp93ckt3.swift:16:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpyp93ckt3.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpyp93ckt3.swift:23:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: i - current_palindrome_length\
    \ - 1, end: i) {\n           ^~~~~~~~~~~~~\n/tmp/tmpyp93ckt3.swift:26:19: error:\
    \ cannot find 'is_palindrome' in scope\n        } else if is_palindrome(string_array,\
    \ start: i - current_palindrome_length, end: i) {\n                  ^~~~~~~~~~~~~\n\
    /tmp/tmpyp93ckt3.swift:35:25: error: value of type 'String' has no member 'substringToIndex'\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpyp93ckt3.swift:35:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_index))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpyp93ckt3.swift:36:25:\
    \ error: value of type 'String' has no member 'substringFromIndex'\n    let suffix\
    \ = string.substringFromIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ + longest_palindrome_length))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpyp93ckt3.swift:36:62: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let suffix = string.substringFromIndex(string.startIndex.advancedBy(longest_palindrome_index\
    \ + longest_palindrome_length))\n                                           ~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.count\n    if string_length == 0 {\n        return \"\"\n    }\n  \
    \  let string_array = Array(string)\n    var longest_palindrome_suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        let prefix_length = string_length\
    \ - i\n        if is_palindrome(string_array, start: 0, end: prefix_length - 1)\
    \ {\n            longest_palindrome_suffix_length = prefix_length\n          \
    \  break\n        }\n    }\n    let prefix_length = string_length - longest_palindrome_suffix_length\n\
    \    let prefix = String(string_array[0..<prefix_length])\n    let suffix = String(string_array[prefix_length..<string_length])\n\
    \    return suffix + prefix.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmprzc3vxb3.swift:21:12: error: cannot find 'is_palindrome' in scope\n\
    \        if is_palindrome(string_array, start: 0, end: prefix_length - 1) {\n\
    \           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let n = string.count\n\
    \    if n == 0 {\n        return \"\"\n    }\n    let s = Array(string)\n    var\
    \ z = z_function(string: string)\n    var i = n - 1\n    while i > 0 && z[i] !=\
    \ i {\n        i -= 1\n    }\n    var prefix = s[0..<i].map { String($0) }.joined()\n\
    \    prefix = String(prefix.reversed())\n    return string + prefix\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpf_q0wde1.swift:18:13: error: cannot find 'z_function' in scope\n\
    \    var z = z_function(string: string)\n            ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let suffix = longest_palindromic_suffix(string:\
    \ string)\n    let prefix = String(string.prefix(string.count - suffix.count).reversed())\n\
    \    return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpngvo_5k4.swift:16:18: error: cannot find 'longest_palindromic_suffix'\
    \ in scope\n    let suffix = longest_palindromic_suffix(string: string)\n    \
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let prefix = string.prefix(string.count\
    \ - 1)\n    let suffix = string.suffix(string.count - 1)\n    if prefix == suffix.reversed()\
    \ {\n        return string\n    }\n    return make_palindrome(string: prefix)\
    \ + String(suffix.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp8z58ftl5.swift:18:25: error: cannot convert value of type '[Character]'\
    \ to expected argument type 'String.SubSequence' (aka 'Substring')\n    if prefix\
    \ == suffix.reversed() {\n                        ^\n/tmp/tmp8z58ftl5.swift:21:36:\
    \ error: cannot convert value of type 'String.SubSequence' (aka 'Substring') to\
    \ expected argument type 'String'\n    return make_palindrome(string: prefix)\
    \ + String(suffix.reversed())\n                                   ^\n        \
    \                           String( )\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        var j = 0\n        while i - j >= 0 && i + j < string_length && string_array[i\
    \ - j] == string_array[i + j] {\n            j += 1\n        }\n        if j *\
    \ 2 - 1 > longest_palindrome_length {\n            longest_palindrome_length =\
    \ j * 2 - 1\n            longest_palindrome_start = i - j + 1\n        }\n   \
    \     j = 0\n        while i - j >= 0 && i + j + 1 < string_length && string_array[i\
    \ - j] == string_array[i + j + 1] {\n            j += 1\n        }\n        if\
    \ j * 2 > longest_palindrome_length {\n            longest_palindrome_length =\
    \ j * 2\n            longest_palindrome_start = i - j + 1\n        }\n    }\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start))\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmptq3q14s5.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmptq3q14s5.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmptq3q14s5.swift:38:25: error: value of type 'String'\
    \ has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmptq3q14s5.swift:38:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(longest_palindrome_start))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let lcs = longest_common_subsequence(string,\
    \ reversed)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lcs.characters.count))\n    return string + String(prefix.characters.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpf0qfbhi5.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpf0qfbhi5.swift:14:15: error:\
    \ cannot find 'longest_common_subsequence' in scope\n    let lcs = longest_common_subsequence(string,\
    \ reversed)\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpf0qfbhi5.swift:15:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lcs.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpf0qfbhi5.swift:15:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lcs.characters.count))\n                                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    if length == 0 {\n        return \"\"\n    }\n\
    \    var suffix = string\n    var prefix = \"\"\n    for _ in 0..<length {\n \
    \       if is_palindrome(suffix) {\n            break\n        }\n        suffix\
    \ = suffix.substring(from: suffix.index(after: suffix.startIndex))\n        prefix\
    \ = prefix.substring(to: prefix.index(before: prefix.endIndex))\n        prefix\
    \ = String(string[string.index(before: string.endIndex)]) + prefix\n    }\n  \
    \  return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpprun_6jq.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpprun_6jq.swift:20:12: error: cannot find 'is_palindrome' in scope\n  \
    \      if is_palindrome(suffix) {\n           ^~~~~~~~~~~~~\n/tmp/tmpprun_6jq.swift:23:25:\
    \ error: value of type 'String' has no member 'substring'\n        suffix = suffix.substring(from:\
    \ suffix.index(after: suffix.startIndex))\n                 ~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpprun_6jq.swift:24:25: error: value of type 'String' has no member 'substring'\n\
    \        prefix = prefix.substring(to: prefix.index(before: prefix.endIndex))\n\
    \                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_len = string.count\n    let string_reversed\
    \ = string.reverse()\n    var longest_palindrome_len = 0\n    var longest_palindrome_end\
    \ = 0\n    var longest_palindrome_start = 0\n    var longest_palindrome_end_reversed\
    \ = 0\n    var longest_palindrome_start_reversed = 0\n    var longest_palindrome_len_reversed\
    \ = 0\n    var longest_palindrome_end_reversed_reversed = 0\n    var longest_palindrome_start_reversed_reversed\
    \ = 0\n    var longest_palindrome_len_reversed_reversed = 0\n    var longest_palindrome_end_reversed_reversed_reversed\
    \ = 0\n    var longest_palindrome_start_reversed_reversed_reversed = 0\n    var\
    \ longest_palindrome_len_reversed_reversed_reversed = 0\n    var longest_palindrome_end_reversed_reversed_reversed_reversed\
    \ = 0\n    var longest_palindrome_start_reversed_reversed_reversed_reversed =\
    \ 0\n    var longest_palindrome_len_reversed_reversed_reversed_reversed = 0\n\
    \    var longest_palindrome_end_reversed_reversed_reversed_reversed_reversed =\
    \ 0\n    var longest_palindrome_start_reversed_reversed_reversed_reversed_reversed\
    \ = 0\n    var longest_palindrome_len_reversed_reversed_reversed_reversed_reversed\
    \ = 0\n    var longest_palindrome_end_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = 0\n    var longest_palindrome_start_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = 0\n    var longest_palindrome_len_re\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmppg7hsiqn.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmppg7hsiqn.swift:15:34:\
    \ error: value of type 'String' has no member 'reverse'\n    let string_reversed\
    \ = string.reverse()\n                          ~~~~~~ ^~~~~~~\n/tmp/tmppg7hsiqn.swift:36:9:\
    \ error: type annotation missing in pattern\n    var longest_palindrome_len_re\n\
    \        ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    if length == 0 {\n        return \"\"\n    }\n\
    \    let string_array = Array(string.characters)\n    var i = 0\n    while i <\
    \ length {\n        if is_palindrome(string_array, start: 0, end: length - i -\
    \ 1) {\n            break\n        }\n        i += 1\n    }\n    let prefix =\
    \ string_array[0..<length - i]\n    let suffix = prefix.reverse()\n    return\
    \ string + String(suffix)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpynh4ge50.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpynh4ge50.swift:17:37: error: 'characters' is unavailable: Please use String\
    \ directly\n    let string_array = Array(string.characters)\n                \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpynh4ge50.swift:20:12: error: cannot find 'is_palindrome' in scope\n\
    \        if is_palindrome(string_array, start: 0, end: length - i - 1) {\n   \
    \        ^~~~~~~~~~~~~\n/tmp/tmpynh4ge50.swift:26:25: error: cannot use mutating\
    \ member on immutable value: 'prefix' is a 'let' constant\n    let suffix = prefix.reverse()\n\
    \                 ~~~~~~ ^\n/tmp/tmpynh4ge50.swift:25:5: note: change 'let' to\
    \ 'var' to make it mutable\n    let prefix = string_array[0..<length - i]\n  \
    \  ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var longest_palindrome_suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string_array,\
    \ start: i, end: string_length - 1) {\n            longest_palindrome_suffix_length\
    \ = string_length - i\n            break\n        }\n    }\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string_length\
    \ - longest_palindrome_suffix_length))\n    let reversed_prefix = String(prefix.characters.reverse())\n\
    \    return string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpw7yh1l8s.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpw7yh1l8s.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw7yh1l8s.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: i, end: string_length\
    \ - 1) {\n           ^~~~~~~~~~~~~\n/tmp/tmpw7yh1l8s.swift:25:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string_length\
    \ - longest_palindrome_suffix_length))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpw7yh1l8s.swift:25:60: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string_length\
    \ - longest_palindrome_suffix_length))\n                                     \
    \    ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string: string_array,\
    \ start: i, end: string_length - 1) {\n            suffix_length = string_length\
    \ - i\n            break\n        }\n    }\n    var result = string\n    for i\
    \ in 0..<string_length - suffix_length {\n        result.append(string_array[string_length\
    \ - 1 - i])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp1vsw4di3.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp1vsw4di3.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp1vsw4di3.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string: string_array, start: i, end: string_length\
    \ - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let lcs = longest_common_substring(string,\
    \ reversed)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lcs.characters.count))\n    return string + String(prefix.characters.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxhhnflc_.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpxhhnflc_.swift:14:15: error:\
    \ cannot find 'longest_common_substring' in scope\n    let lcs = longest_common_substring(string,\
    \ reversed)\n              ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxhhnflc_.swift:15:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lcs.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpxhhnflc_.swift:15:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lcs.characters.count))\n                                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string_chars, index:\
    \ i)\n        if palindrome_length > longest_palindrome_length {\n           \
    \ longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_length = string_length - longest_palindrome_length\n\
    \    let prefix = string_chars[0..<prefix_length]\n    let reversed_prefix = prefix.reverse()\n\
    \    return string + String(reversed_prefix)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpigmdd40_.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpigmdd40_.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpigmdd40_.swift:21:33: error: cannot find 'palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = palindrome_length_at_index(string_chars,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpigmdd40_.swift:29:34:\
    \ error: cannot use mutating member on immutable value: 'prefix' is a 'let' constant\n\
    \    let reversed_prefix = prefix.reverse()\n                          ~~~~~~\
    \ ^\n/tmp/tmpigmdd40_.swift:28:5: note: change 'let' to 'var' to make it mutable\n\
    \    let prefix = string_chars[0..<prefix_length]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let stringLength\
    \ = string.characters.count\n    if stringLength == 0 {\n        return \"\"\n\
    \    }\n    if stringLength == 1 {\n        return string\n    }\n    let stringChars\
    \ = Array(string.characters)\n    var longestPalindromeSuffixLength = 0\n    for\
    \ i in 0..<stringLength {\n        if is_palindrome(string: String(stringChars[i..<stringLength]))\
    \ {\n            longestPalindromeSuffixLength = stringLength - i\n          \
    \  break\n        }\n    }\n    let prefix = String(stringChars[0..<(stringLength\
    \ - longestPalindromeSuffixLength)])\n    let reversePrefix = String(prefix.characters.reversed())\n\
    \    return prefix + reversePrefix + String(stringChars[(stringLength - longestPalindromeSuffixLength)..<stringLength])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpjiu7hb9k.swift:13:31: error: 'characters' is unavailable: Please\
    \ use String directly\n    let stringLength = string.characters.count\n      \
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpjiu7hb9k.swift:20:36: error: 'characters' is unavailable:\
    \ Please use String directly\n    let stringChars = Array(string.characters)\n\
    \                                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpjiu7hb9k.swift:23:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string: String(stringChars[i..<stringLength]))\
    \ {\n           ^~~~~~~~~~~~~\n/tmp/tmpjiu7hb9k.swift:29:39: error: 'characters'\
    \ is unavailable: Please use String directly\n    let reversePrefix = String(prefix.characters.reversed())\n\
    \                                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let n = string.characters.count\n\
    \    if n == 0 {\n        return \"\"\n    }\n    let string_chars = Array(string.characters)\n\
    \    var suffix = [Int](count: n, repeatedValue: 0)\n    var i = 0\n    var j\
    \ = 1\n    while j < n {\n        if string_chars[i] == string_chars[j] {\n  \
    \          suffix[j] = i + 1\n            i += 1\n            j += 1\n       \
    \ } else if i == 0 {\n            suffix[j] = 0\n            j += 1\n        }\
    \ else {\n            i = suffix[i - 1]\n        }\n    }\n    let prefix = string_chars[0..<(n\
    \ - suffix[n - 1])].reverse()\n    return string + String(prefix)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6pou9sbk.swift:13:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let n = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp6pou9sbk.swift:17:37:\
    \ error: 'characters' is unavailable: Please use String directly\n    let string_chars\
    \ = Array(string.characters)\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp6pou9sbk.swift:18:18:\
    \ error: no exact matches in call to initializer \n    var suffix = [Int](count:\
    \ n, repeatedValue: 0)\n                 ^\n/tmp/tmp6pou9sbk.swift:18:18: note:\
    \ candidate has partially matching parameter list (repeating: Int, count: Int)\n\
    \    var suffix = [Int](count: n, repeatedValue: 0)\n                 ^\n/tmp/tmp6pou9sbk.swift:18:18:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var suffix = [Int](count: n, repeatedValue: 0)\n                 ^\n\
    /tmp/tmp6pou9sbk.swift:33:56: error: cannot use mutating member on immutable value:\
    \ 'string_chars' is a 'let' constant\n    let prefix = string_chars[0..<(n - suffix[n\
    \ - 1])].reverse()\n                 ~~~~~~~~~~~~                          ^\n\
    /tmp/tmp6pou9sbk.swift:17:5: note: change 'let' to 'var' to make it mutable\n\
    \    let string_chars = Array(string.characters)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var palindrome_suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string_chars,\
    \ start: 0, end: string_length - i - 1) {\n            palindrome_suffix_length\
    \ = string_length - i\n            break\n        }\n    }\n    var palindrome_prefix\
    \ = \"\"\n    for i in 0..<string_length - palindrome_suffix_length {\n      \
    \  palindrome_prefix.append(string_chars[i])\n    }\n    return string + String(palindrome_prefix.characters.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpkqfypwu1.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpkqfypwu1.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpkqfypwu1.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_chars, start: 0, end: string_length\
    \ - i - 1) {\n           ^~~~~~~~~~~~~\n/tmp/tmpkqfypwu1.swift:29:46: error: 'characters'\
    \ is unavailable: Please use String directly\n    return string + String(palindrome_prefix.characters.reversed())\n\
    \                                             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string_chars,\
    \ start: i, length: string_length - i) {\n            longest_palindrome_length\
    \ = string_length - i\n            break\n        }\n    }\n    var result = string\n\
    \    for i in 0..<string_length - longest_palindrome_length {\n        result.append(string_chars[i])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpmz_wm7_w.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpmz_wm7_w.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpmz_wm7_w.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_chars, start: i, length: string_length\
    \ - i) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = get_palindrome_length(string_array, start: i,\
    \ length: string_length)\n        if palindrome_length > longest_palindrome_length\
    \ {\n            longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_length = string_length - longest_palindrome_length\n\
    \    let prefix = string_array[0..<prefix_length]\n    let prefix_reversed = prefix.reverse()\n\
    \    let palindrome = string_array[longest_palindrome_start..<string_length]\n\
    \    return String(prefix_reversed) + String(palindrome) + String(prefix)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmprlgx6jqw.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmprlgx6jqw.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmprlgx6jqw.swift:21:33: error: cannot find 'get_palindrome_length'\
    \ in scope\n        let palindrome_length = get_palindrome_length(string_array,\
    \ start: i, length: string_length)\n                                ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmprlgx6jqw.swift:29:34: error: cannot use mutating member on immutable value:\
    \ 'prefix' is a 'let' constant\n    let prefix_reversed = prefix.reverse()\n \
    \                         ~~~~~~ ^\n/tmp/tmprlgx6jqw.swift:28:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let prefix = string_array[0..<prefix_length]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    var suffix = string\n    var suffix_length = string_length\n    var\
    \ prefix_length = 0\n    while suffix_length > 0 {\n        if is_palindrome(suffix)\
    \ {\n            break\n        }\n        suffix = suffix.substringFromIndex(suffix.startIndex.advancedBy(1))\n\
    \        suffix_length -= 1\n        prefix_length += 1\n    }\n    if suffix_length\
    \ == 0 {\n        return string\n    }\n    var prefix = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n\
    \    prefix = String(prefix.characters.reverse())\n    return string + prefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpdtfj4b5b.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpdtfj4b5b.swift:21:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(suffix) {\n           ^~~~~~~~~~~~~\n/tmp/tmpdtfj4b5b.swift:24:25:\
    \ error: value of type 'String' has no member 'substringFromIndex'\n        suffix\
    \ = suffix.substringFromIndex(suffix.startIndex.advancedBy(1))\n             \
    \    ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpdtfj4b5b.swift:24:62: error: value of\
    \ type 'String.Index' has no member 'advancedBy'\n        suffix = suffix.substringFromIndex(suffix.startIndex.advancedBy(1))\n\
    \                                           ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpdtfj4b5b.swift:31:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    var prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n   \
    \              ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpdtfj4b5b.swift:31:60: error: value\
    \ of type 'String.Index' has no member 'advancedBy'\n    var prefix = string.substringToIndex(string.startIndex.advancedBy(prefix_length))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_end = 0\n    var longest_palindrome_start =\
    \ 0\n    var longest_palindrome_end_index = 0\n    var longest_palindrome_start_index\
    \ = 0\n    var longest_palindrome_length_index = 0\n    var palindrome_length\
    \ = 0\n    var palindrome_end = 0\n    var palindrome_start = 0\n    var palindrome_end_index\
    \ = 0\n    var palindrome_start_index = 0\n    var palindrome_length_index = 0\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n  \
    \  var ac = 0\n    var ad = 0\n    var ae = 0\n    var af = 0\n    var ag = 0\n\
    \    var ah = 0\n    var ai = 0\n    var aj = 0\n    var ak = 0\n    var al =\
    \ 0\n    var am = 0\n    var an = 0\n    var ao = 0\n    var ap = 0\n    var aq\
    \ = 0\n    var ar = 0\n    var as = 0\n    var at = 0\n    var au = 0\n    var\
    \ av = 0\n    var aw = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n   \
    \ var ba = 0\n    var bb = 0\n    var bc = 0\n    var bd = 0\n    var be = 0\n\
    \    var bf = 0\n    var bg = 0\n    var bh = 0\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp30h52naa.swift:66:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmp30h52naa.swift:66:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmp30h52naa.swift:13:32: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_length = string.characters.count\n\
    \                               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp30h52naa.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp30h52naa.swift:17:9: warning: initialization of immutable\
    \ value 'string_chars' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    let string_chars = Array(string.characters)\n    ~~~~^~~~~~~~~~~~\n\
    \    _\n/tmp/tmp30h52naa.swift:18:9: warning: initialization of variable 'longest_palindrome_length'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_length = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n   \
    \ _\n/tmp/tmp30h52naa.swift:19:9: warning: initialization of variable 'longest_palindrome_end'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var longest_palindrome_end = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp30h52naa.swift:20:9:\
    \ warning: initialization of variable 'longest_palindrome_start' was never used;\
    \ consider replacing with assignment to '_' or removing it\n    var longest_palindrome_start\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmp30h52naa.swift:21:9: warning:\
    \ initialization of variable 'longest_palindrome_end_index' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var longest_palindrome_end_index\
    \ = 0\n    ~~~~^~~~~~~"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start + 1\n    let prefix = string_characters[prefix_start..<prefix_end]\n\
    \    let reversed_prefix = prefix.reverse()\n    return string + String(reversed_prefix)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpue5ezvm4.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpue5ezvm4.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpue5ezvm4.swift:21:33: error: cannot find\
    \ 'palindrome_length_at_index' in scope\n        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpue5ezvm4.swift:30:34:\
    \ error: cannot use mutating member on immutable value: 'prefix' is a 'let' constant\n\
    \    let reversed_prefix = prefix.reverse()\n                          ~~~~~~\
    \ ^\n/tmp/tmpue5ezvm4.swift:29:5: note: change 'let' to 'var' to make it mutable\n\
    \    let prefix = string_characters[prefix_start..<prefix_end]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    var palindrome_length = 0\n    for i in 0..<string_length {\n    \
    \    if is_palindrome(string: string, start: i, end: string_length - 1) {\n  \
    \          palindrome_length = string_length - i\n            break\n        }\n\
    \    }\n    let prefix = string.substring(to: string.index(string.startIndex,\
    \ offsetBy: string_length - palindrome_length))\n    let reversed_prefix = String(prefix.characters.reversed())\n\
    \    return string + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpu0_18kpi.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpu0_18kpi.swift:19:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string: string, start: i, end: string_length\
    \ - 1) {\n           ^~~~~~~~~~~~~\n/tmp/tmpu0_18kpi.swift:24:25: error: value\
    \ of type 'String' has no member 'substring'\n    let prefix = string.substring(to:\
    \ string.index(string.startIndex, offsetBy: string_length - palindrome_length))\n\
    \                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let n = string.characters.count\n\
    \    if n == 0 {\n        return \"\"\n    }\n    let string_chars = Array(string.characters)\n\
    \    var longest_suffix_palindrome_length = 0\n    for i in 0..<n {\n        if\
    \ is_palindrome(string_chars, start: i, end: n - 1) {\n            longest_suffix_palindrome_length\
    \ = n - i\n            break\n        }\n    }\n    var prefix = string.substringToIndex(string.startIndex.advancedBy(n\
    \ - longest_suffix_palindrome_length))\n    prefix = String(prefix.characters.reverse())\n\
    \    return string + prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpupochtdz.swift:13:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    let n = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpupochtdz.swift:17:37:\
    \ error: 'characters' is unavailable: Please use String directly\n    let string_chars\
    \ = Array(string.characters)\n                                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpupochtdz.swift:20:12:\
    \ error: cannot find 'is_palindrome' in scope\n        if is_palindrome(string_chars,\
    \ start: i, end: n - 1) {\n           ^~~~~~~~~~~~~\n/tmp/tmpupochtdz.swift:25:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    var prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(n - longest_suffix_palindrome_length))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpupochtdz.swift:25:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    var prefix = string.substringToIndex(string.startIndex.advancedBy(n\
    \ - longest_suffix_palindrome_length))\n                                     \
    \    ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_common_suffix = longest_common_substring(string,\
    \ reversed)\n    let prefix = String(string.characters.dropLast(longest_common_suffix.characters.count))\n\
    \    return string + String(prefix.characters.reverse())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6cepn9bw.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp6cepn9bw.swift:14:33: error:\
    \ cannot find 'longest_common_substring' in scope\n    let longest_common_suffix\
    \ = longest_common_substring(string, reversed)\n                             \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    if length == 0 {\n        return \"\"\n    }\n\
    \    let reversed = String(string.characters.reverse())\n    let suffix = reversed.substringFromIndex(reversed.startIndex.advancedBy(length\
    \ - 1))\n    let prefix = reversed.substringToIndex(reversed.startIndex.advancedBy(length\
    \ - 1))\n    let palindrome = string + suffix\n    if is_palindrome(palindrome)\
    \ {\n        return palindrome\n    }\n    return string + prefix\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmphtnjzvtx.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmphtnjzvtx.swift:17:45: error: value of type 'String' has no member 'reverse'\n\
    \    let reversed = String(string.characters.reverse())\n                    \
    \      ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmphtnjzvtx.swift:21:8: error: cannot find\
    \ 'is_palindrome' in scope\n    if is_palindrome(palindrome) {\n       ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let lcs = longest_common_subsequence(string,\
    \ reversed)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - lcs.characters.count))\n    return string + String(prefix.characters.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpofgph3cw.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpofgph3cw.swift:14:15: error:\
    \ cannot find 'longest_common_subsequence' in scope\n    let lcs = longest_common_subsequence(string,\
    \ reversed)\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string_array,\
    \ start: i, end: string_length - 1) {\n            suffix_length = string_length\
    \ - i\n            break\n        }\n    }\n    var prefix_length = string_length\
    \ - suffix_length\n    var result = string\n    for i in 0..<prefix_length {\n\
    \        result.append(string_array[prefix_length - i - 1])\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpw56hgfp_.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpw56hgfp_.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpw56hgfp_.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: i, end: string_length\
    \ - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed_string\
    \ = String(string.characters.reverse())\n    let string_length = string.characters.count\n\
    \    let reversed_string_length = reversed_string.characters.count\n    var lps\
    \ = [Int](count: string_length, repeatedValue: 0)\n    var i = 0, j = 0\n    while\
    \ i < string_length {\n        if string[i] == reversed_string[j] {\n        \
    \    lps[i] = j + 1\n            i += 1\n            j += 1\n        } else if\
    \ j == 0 {\n            lps[i] = 0\n            i += 1\n        } else {\n   \
    \         j = lps[j - 1]\n        }\n    }\n    return string + reversed_string.substringFromIndex(reversed_string_length\
    \ - lps[string_length - 1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp_4v4699x.swift:13:52: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed_string = String(string.characters.reverse())\n \
    \                                ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp_4v4699x.swift:14:32:\
    \ error: 'characters' is unavailable: Please use String directly\n    let string_length\
    \ = string.characters.count\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp_4v4699x.swift:16:15: error: no exact\
    \ matches in call to initializer \n    var lps = [Int](count: string_length, repeatedValue:\
    \ 0)\n              ^\n/tmp/tmp_4v4699x.swift:16:15: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var lps = [Int](count:\
    \ string_length, repeatedValue: 0)\n              ^\n/tmp/tmp_4v4699x.swift:16:15:\
    \ note: candidate has partially matching parameter list (repeating: Int, count:\
    \ Int)\n    var lps = [Int](count: string_length, repeatedValue: 0)\n        \
    \      ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    if length == 0 {\n        return \"\"\n    }\n\
    \    let string_array = Array(string.characters)\n    var i = length - 1\n   \
    \ while i >= 0 {\n        if is_palindrome(string_array, start: 0, end: i) {\n\
    \            break\n        }\n        i -= 1\n    }\n    var result = string\n\
    \    for j in 0..<length - i - 1 {\n        result.append(string_array[j])\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpv0jmlir9.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpv0jmlir9.swift:17:37: error: 'characters' is unavailable: Please use String\
    \ directly\n    let string_array = Array(string.characters)\n                \
    \                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpv0jmlir9.swift:20:12: error: cannot find 'is_palindrome' in scope\n\
    \        if is_palindrome(string_array, start: 0, end: i) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_end = 0\n    var palindrome_lengths = [Int](count:\
    \ string_length, repeatedValue: 0)\n    for i in 0..<string_length {\n       \
    \ // We are looking for a palindrome of the form:\n        //     string[0:i]\
    \ + string[i] + string[0:i]\n        // We can find the length of the palindrome\
    \ by looking at the palindrome\n        // of the form:\n        //     string[0:i-1]\
    \ + string[i-1] + string[0:i-1]\n        // and adding 2 if the last character\
    \ of the palindrome is the same as\n        // the character at index i.\n   \
    \     var palindrome_length = 0\n        if i > 0 {\n            let palindrome_length_without_last_char\
    \ = palindrome_lengths[i - 1]\n            if string_chars[i - palindrome_length_without_last_char\
    \ - 1] == string_chars[i] {\n                palindrome_length = palindrome_length_without_last_char\
    \ + 2\n            }\n        } else {\n            palindrome_length = 1\n  \
    \      }\n        palindrome_lengths[i] = palindrome_length\n        if palindrome_length\
    \ > longest_palindrome_length {\n            longest_palindrome_length = palindrome_length\n\
    \            longest_palindrome_end = i\n        }\n    }\n    let longest_palindrome_start\
    \ = longest_palindrome_end - longest_palindrome_length + 1\n    let prefix = String(string_chars[0..<longest_palindrome_start])\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpvp1mmjlw.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpvp1mmjlw.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpvp1mmjlw.swift:20:30: error: no exact matches in call\
    \ to initializer \n    var palindrome_lengths = [Int](count: string_length, repeatedValue:\
    \ 0)\n                             ^\n/tmp/tmpvp1mmjlw.swift:20:30: note: candidate\
    \ has partially matching parameter list (repeating: Int, count: Int)\n    var\
    \ palindrome_lengths = [Int](count: string_length, repeatedValue: 0)\n       \
    \                      ^\n/tmp/tmpvp1mmjlw.swift:20:30: note: candidate has partially\
    \ matching parameter list (repeating: Int, count: Int)\n    var palindrome_lengths\
    \ = [Int](count: string_length, repeatedValue: 0)\n                          \
    \   ^\n/tmp/tmpvp1mmjlw.swift:46:52: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed_prefix = String(prefix.characters.reverse())\n \
    \                                ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_palindrome = longest_palindrome_suffix(string)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_palindrome.characters.count))\n    return string + reversed.substringFromIndex(reversed.startIndex.advancedBy(longest_palindrome.characters.count))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpxf7e5g7j.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpxf7e5g7j.swift:14:30: error:\
    \ cannot find 'longest_palindrome_suffix' in scope\n    let longest_palindrome\
    \ = longest_palindrome_suffix(string)\n                             ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxf7e5g7j.swift:15:25: error: value of type 'String' has no member 'substringToIndex'\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_palindrome.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpxf7e5g7j.swift:15:60: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_palindrome.characters.count))\n                                  \
    \       ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_common_suffix = longest_common_substring(string,\
    \ reversed)\n    let prefix = String(string.characters.dropLast(longest_common_suffix.characters.count))\n\
    \    return string + String(prefix.characters.reverse())\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp6cepn9bw.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp6cepn9bw.swift:14:33: error:\
    \ cannot find 'longest_common_substring' in scope\n    let longest_common_suffix\
    \ = longest_common_substring(string, reversed)\n                             \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_characters = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start + 1\n    let prefix = String(string_characters[prefix_start..<prefix_end])\n\
    \    let reversed_prefix = String(prefix.characters.reverse())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmprrcij2_t.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmprrcij2_t.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmprrcij2_t.swift:21:33: error: cannot find\
    \ 'palindrome_length_at_index' in scope\n        let palindrome_length = palindrome_length_at_index(string_characters,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmprrcij2_t.swift:30:52:\
    \ error: value of type 'String' has no member 'reverse'\n    let reversed_prefix\
    \ = String(prefix.characters.reverse())\n                                 ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let palindrome = string + reversed\n\
    \    let lps = longest_palindromic_substring(palindrome)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - lps.characters.count))\n    return prefix + string\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpzgtmohmc.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpzgtmohmc.swift:15:15: error:\
    \ cannot find 'longest_palindromic_substring' in scope\n    let lps = longest_palindromic_substring(palindrome)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_common_suffix = longest_common_substring(string,\
    \ reversed)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_common_suffix.characters.count))\n    return string + String(prefix.characters.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpf5yl6pft.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpf5yl6pft.swift:14:33: error:\
    \ cannot find 'longest_common_substring' in scope\n    let longest_common_suffix\
    \ = longest_common_substring(string, reversed)\n                             \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpf5yl6pft.swift:15:25: error: value of type\
    \ 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_common_suffix.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpf5yl6pft.swift:15:60: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - longest_common_suffix.characters.count))\n                               \
    \          ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014262
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let length = string.count\n    if length == 0 {\n \
    \       return \"\"\n    }\n    var i = length - 1\n    while i >= 0 {\n     \
    \   if is_palindrome(string, start: 0, end: i) {\n            break\n        }\n\
    \        i -= 1\n    }\n    let prefix = string[0..<i]\n    let suffix = string[i..<length]\n\
    \    return String(prefix) + String(suffix.reversed())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpgkrasf0j.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpgkrasf0j.swift:20:12:\
    \ error: cannot find 'is_palindrome' in scope\n        if is_palindrome(string,\
    \ start: 0, end: i) {\n           ^~~~~~~~~~~~~\n/tmp/tmpgkrasf0j.swift:25:18:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n    let prefix = string[0..<i]\n \
    \                ^~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript<R>(bounds: R) -> String\
    \ where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmpgkrasf0j.swift:26:18:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an integer\
    \ range, use a String.Index range instead.\n    let suffix = string[i..<length]\n\
    \                 ^~~~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let prefix = string.prefix(string.count\
    \ - longest_palindrome_suffix(string: string).count)\n    return string + String(prefix.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpoik2xhet.swift:16:47: error: cannot find 'longest_palindrome_suffix'\
    \ in scope\n    let prefix = string.prefix(string.count - longest_palindrome_suffix(string:\
    \ string).count)\n                                              ^~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    var longest_palindrome_length = 0\n    var longest_palindrome_start\
    \ = 0\n    for i in 0..<string_length {\n        let palindrome_length = longest_palindrome_length_at(string,\
    \ start: i)\n        if palindrome_length > longest_palindrome_length {\n    \
    \        longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start + longest_palindrome_length\n\
    \    let prefix_end = string_length\n    let prefix = string[string.index(string.startIndex,\
    \ offsetBy: prefix_start)..<string.index(string.startIndex, offsetBy: prefix_end)]\n\
    \    let reversed_prefix = String(prefix.characters.reversed())\n    return string\
    \ + reversed_prefix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpp2w_8bih.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpp2w_8bih.swift:20:33: error: cannot find 'longest_palindrome_length_at'\
    \ in scope\n        let palindrome_length = longest_palindrome_length_at(string,\
    \ start: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpp2w_8bih.swift:29:41:\
    \ error: 'characters' is unavailable: Please use Substring directly\n    let reversed_prefix\
    \ = String(prefix.characters.reversed())\n                                   \
    \     ^~~~~~~~~~\nSwift.Substring:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: Substring { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters.map { String($0) }\n    let reversed = string.reverse()\n\
    \    let n = string.count\n    var i = 0\n    while i < n {\n        if string[i]\
    \ == reversed[i] {\n            i += 1\n        } else {\n            break\n\
    \        }\n    }\n    let prefix = string[0..<i]\n    let suffix = reversed[i..<n]\n\
    \    return string.joinWithSeparator(\"\") + suffix.joinWithSeparator(\"\")\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp3j0lrsf5.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters.map { String($0) }\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp3j0lrsf5.swift:14:27: error: cannot use mutating member\
    \ on immutable value: 'string' is a 'let' constant\n    let reversed = string.reverse()\n\
    \                   ~~~~~~ ^\n/tmp/tmp3j0lrsf5.swift:13:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let string = string.characters.map { String($0)\
    \ }\n    ^~~\n    var\n/tmp/tmp3j0lrsf5.swift:26:19: error: value of type '[String]'\
    \ has no member 'joinWithSeparator'\n    return string.joinWithSeparator(\"\"\
    ) + suffix.joinWithSeparator(\"\")\n           ~~~~~~ ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let length\
    \ = string.characters.count\n    if length == 0 {\n        return \"\"\n    }\n\
    \    let reversed = string.characters.reverse()\n    let reversed_string = String(reversed)\n\
    \    let suffix = longest_common_suffix(string, reversed_string)\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(length - suffix.characters.count))\n\
    \    let reversed_prefix = prefix.characters.reverse()\n    let reversed_prefix_string\
    \ = String(reversed_prefix)\n    return string + reversed_prefix_string\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp5c04s8tl.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let length = string.characters.count\n            \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmp5c04s8tl.swift:17:38: error: value of type 'String' has no member 'reverse'\n\
    \    let reversed = string.characters.reverse()\n                   ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmp5c04s8tl.swift:19:18: error: cannot find 'longest_common_suffix'\
    \ in scope\n    let suffix = longest_common_suffix(string, reversed_string)\n\
    \                 ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5c04s8tl.swift:20:25: error:\
    \ value of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(length\
    \ - suffix.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp5c04s8tl.swift:20:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(length - suffix.characters.count))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let s = Array(string)\n\
    \    let n = s.count\n    if n == 0 {\n        return \"\"\n    }\n    var i =\
    \ n - 1\n    while i >= 0 {\n        if is_palindrome(s, 0, i) {\n           \
    \ break\n        }\n        i -= 1\n    }\n    var j = 0\n    while j < n - i\
    \ - 1 {\n        s.append(s[j])\n        j += 1\n    }\n    return String(s)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpiw65fud5.swift:20:12: error: cannot find 'is_palindrome' in scope\n\
    \        if is_palindrome(s, 0, i) {\n           ^~~~~~~~~~~~~\n/tmp/tmpiw65fud5.swift:27:11:\
    \ error: cannot use mutating member on immutable value: 's' is a 'let' constant\n\
    \        s.append(s[j])\n        ~ ^\n/tmp/tmpiw65fud5.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let s = Array(string)\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let length = string.characters.count\n\
    \    var i = 0\n    while i < length {\n        if string.hasPrefix(reversed.substringFromIndex(reversed.startIndex.advancedBy(i)))\
    \ {\n            return string + reversed.substringFromIndex(reversed.startIndex.advancedBy(i))\n\
    \        }\n        i += 1\n    }\n    return string + reversed\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp238wr2z8.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp238wr2z8.swift:14:25: error:\
    \ 'characters' is unavailable: Please use String directly\n    let length = string.characters.count\n\
    \                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.lowercaseString\n    let length = string.characters.count\n    if length\
    \ == 0 {\n        return \"\"\n    }\n    var suffix = string\n    var prefix\
    \ = \"\"\n    var i = 0\n    while i < length {\n        if is_palindrome(suffix)\
    \ {\n            break\n        }\n        suffix.removeAtIndex(suffix.startIndex)\n\
    \        prefix.append(string[string.startIndex.advancedBy(i)])\n        i +=\
    \ 1\n    }\n    return string + String(prefix.characters.reverse())\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp3svq2anp.swift:13:25: error: value of type 'String' has no member\
    \ 'lowercaseString'\n    let string = string.lowercaseString\n               \
    \  ~~~~~~ ^~~~~~~~~~~~~~~\n/tmp/tmp3svq2anp.swift:22:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(suffix) {\n           ^~~~~~~~~~~~~\n/tmp/tmp3svq2anp.swift:29:46:\
    \ error: value of type 'String' has no member 'reverse'\n    return string + String(prefix.characters.reverse())\n\
    \                           ~~~~~~~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = palindrome_length_at_index(string_array, index:\
    \ i)\n        if palindrome_length > longest_palindrome_length {\n           \
    \ longest_palindrome_length = palindrome_length\n            longest_palindrome_start\
    \ = i\n        }\n    }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\
    \ + 1\n    let prefix_end = longest_palindrome_start + 1\n    let prefix = string_array[prefix_start..<prefix_end]\n\
    \    let prefix_reversed = prefix.reverse()\n    return string + String(prefix_reversed)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpuhp8ciue.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpuhp8ciue.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpuhp8ciue.swift:21:33: error: cannot find 'palindrome_length_at_index'\
    \ in scope\n        let palindrome_length = palindrome_length_at_index(string_array,\
    \ index: i)\n                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuhp8ciue.swift:30:34:\
    \ error: cannot use mutating member on immutable value: 'prefix' is a 'let' constant\n\
    \    let prefix_reversed = prefix.reverse()\n                          ~~~~~~\
    \ ^\n/tmp/tmpuhp8ciue.swift:29:5: note: change 'let' to 'var' to make it mutable\n\
    \    let prefix = string_array[prefix_start..<prefix_end]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_characters = Array(string.characters)\n    var longest_palindrome_suffix_length\
    \ = 0\n    for i in 0..<string_length {\n        if is_palindrome(string_characters,\
    \ start: i, end: string_length - 1) {\n            longest_palindrome_suffix_length\
    \ = string_length - i\n            break\n        }\n    }\n    var result = string\n\
    \    for i in 0..<string_length - longest_palindrome_suffix_length {\n       \
    \ result.append(string_characters[string_length - 1 - i])\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp88_u0bpy.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp88_u0bpy.swift:17:42: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_characters = Array(string.characters)\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp88_u0bpy.swift:20:12: error: cannot find\
    \ 'is_palindrome' in scope\n        if is_palindrome(string_characters, start:\
    \ i, end: string_length - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var suffix_length\
    \ = 0\n    while suffix_length < string_length {\n        if is_palindrome(string_array,\
    \ start: 0, end: string_length - suffix_length - 1) {\n            break\n   \
    \     }\n        suffix_length += 1\n    }\n    var prefix_length = 0\n    while\
    \ prefix_length < string_length - suffix_length {\n        if is_palindrome(string_array,\
    \ start: prefix_length, end: string_length - 1) {\n            break\n       \
    \ }\n        prefix_length += 1\n    }\n    var result = string\n    for i in\
    \ 0..<prefix_length {\n        result.append(string_array[prefix_length - i -\
    \ 1])\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpgdu3bjo8.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpgdu3bjo8.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgdu3bjo8.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: 0, end: string_length\
    \ - suffix_length - 1) {\n           ^~~~~~~~~~~~~\n/tmp/tmpgdu3bjo8.swift:27:12:\
    \ error: cannot find 'is_palindrome' in scope\n        if is_palindrome(string_array,\
    \ start: prefix_length, end: string_length - 1) {\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let lcs = longest_common_subsequence(string,\
    \ reversed)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - lcs.characters.count))\n    return string + String(prefix.characters.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpofgph3cw.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpofgph3cw.swift:14:15: error:\
    \ cannot find 'longest_common_subsequence' in scope\n    let lcs = longest_common_subsequence(string,\
    \ reversed)\n              ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let string_length = string.characters.count\n\
    \    let reversed_length = reversed.characters.count\n    var lps = [Int](count:\
    \ reversed_length, repeatedValue: 0)\n    var i = 1\n    var j = 0\n    while\
    \ i < reversed_length {\n        if reversed[reversed.startIndex.advancedBy(i)]\
    \ == reversed[reversed.startIndex.advancedBy(j)] {\n            lps[i] = j + 1\n\
    \            i += 1\n            j += 1\n        } else {\n            if j !=\
    \ 0 {\n                j = lps[j - 1]\n            } else {\n                lps[i]\
    \ = 0\n                i += 1\n            }\n        }\n    }\n    let prefix\
    \ = reversed.substringToIndex(reversed.startIndex.advancedBy(reversed_length -\
    \ lps[reversed_length - 1]))\n    return string + prefix\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp8t77ey1x.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp8t77ey1x.swift:14:32: error:\
    \ 'characters' is unavailable: Please use String directly\n    let string_length\
    \ = string.characters.count\n                               ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp8t77ey1x.swift:16:60: error: extra argument\
    \ 'repeatedValue' in call\n    var lps = [Int](count: reversed_length, repeatedValue:\
    \ 0)\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let reversed = String(string.characters.reverse())\n\
    \    let lcs = longest_common_substring(string, reversed)\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lcs.characters.count))\n    return string + String(prefix.characters.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmped920h6w.swift:16:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmped920h6w.swift:17:15: error:\
    \ cannot find 'longest_common_substring' in scope\n    let lcs = longest_common_substring(string,\
    \ reversed)\n              ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmped920h6w.swift:18:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lcs.characters.count))\n                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmped920h6w.swift:18:60:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(string.characters.count\
    \ - lcs.characters.count))\n                                         ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string\
    \ = string.characters\n    let string_length = string.count\n    var suffix_length\
    \ = string_length\n    var prefix_length = 0\n    var palindrome_length = 0\n\
    \    var palindrome_index = 0\n    var palindrome_suffix = \"\"\n    var palindrome_prefix\
    \ = \"\"\n    var palindrome = \"\"\n    \n    while suffix_length > 0 {\n   \
    \     if is_palindrome(string, start: 0, end: string_length - suffix_length) {\n\
    \            palindrome_length = string_length - suffix_length\n            palindrome_index\
    \ = suffix_length\n            break\n        }\n        suffix_length -= 1\n\
    \    }\n    \n    while prefix_length < palindrome_index {\n        palindrome_suffix\
    \ += String(string[string_length - palindrome_index + prefix_length])\n      \
    \  prefix_length += 1\n    }\n    \n    palindrome = String(string) + palindrome_suffix\n\
    \    \n    return palindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp_gqilupv.swift:13:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string = string.characters\n                  \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp_gqilupv.swift:24:12:\
    \ error: cannot find 'is_palindrome' in scope\n        if is_palindrome(string,\
    \ start: 0, end: string_length - suffix_length) {\n           ^~~~~~~~~~~~~\n\
    /tmp/tmp_gqilupv.swift:33:37: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        palindrome_suffix +=\
    \ String(string[string_length - palindrome_index + prefix_length])\n         \
    \                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014264
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_chars = Array(string.characters)\n    var longest_palindrome_length\
    \ = 0\n    var longest_palindrome_start = 0\n    for i in 0..<string_length {\n\
    \        let palindrome_length = get_palindrome_length(string_chars, i)\n    \
    \    if palindrome_length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = palindrome_length\n            longest_palindrome_start = i\n        }\n \
    \   }\n    let prefix_start = longest_palindrome_start - longest_palindrome_length\n\
    \    let prefix_end = longest_palindrome_start - 1\n    let prefix = String(string_chars[prefix_start...prefix_end])\n\
    \    let prefix_reversed = String(prefix.characters.reverse())\n    return string\
    \ + prefix_reversed\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmps392y40r.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmps392y40r.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmps392y40r.swift:21:33: error: cannot find 'get_palindrome_length'\
    \ in scope\n        let palindrome_length = get_palindrome_length(string_chars,\
    \ i)\n                                ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmps392y40r.swift:30:52:\
    \ error: value of type 'String' has no member 'reverse'\n    let prefix_reversed\
    \ = String(prefix.characters.reverse())\n                                 ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014264
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    let string_array = Array(string.characters)\n\
    \    var palindrome_suffix = \"\"\n    var palindrome_suffix_length = 0\n    for\
    \ i in 0..<string_length {\n        let substring = String(string_array[i..<string_length])\n\
    \        if is_palindrome(substring) {\n            palindrome_suffix = substring\n\
    \            palindrome_suffix_length = substring.characters.count\n         \
    \   break\n        }\n    }\n    let palindrome_prefix = String(string_array[0..<(string_length\
    \ - palindrome_suffix_length)])\n    return palindrome_prefix + String(palindrome_suffix.characters.reverse())\
    \ + palindrome_suffix\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpzle7n7gu.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpzle7n7gu.swift:14:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpzle7n7gu.swift:19:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(substring) {\n           ^~~~~~~~~~~~~\n\
    /tmp/tmpzle7n7gu.swift:21:50: error: 'characters' is unavailable: Please use String\
    \ directly\n            palindrome_suffix_length = substring.characters.count\n\
    \                                                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpzle7n7gu.swift:26:68: error: value of\
    \ type 'String' has no member 'reverse'\n    return palindrome_prefix + String(palindrome_suffix.characters.reverse())\
    \ + palindrome_suffix\n                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014264
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let reversed\
    \ = String(string.characters.reverse())\n    let longest_common_prefix = longest_common_prefix_suffix(string,\
    \ reversed)\n    let prefix = String(string.characters.prefix(string.characters.count\
    \ - longest_common_prefix))\n    return string + String(prefix.characters.reverse())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmpu50qif47.swift:13:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmpu50qif47.swift:14:33: error:\
    \ cannot find 'longest_common_prefix_suffix' in scope\n    let longest_common_prefix\
    \ = longest_common_prefix_suffix(string, reversed)\n                         \
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    if string_length == 0 {\n        return \"\"\n\
    \    }\n    let string_array = Array(string.characters)\n    var i = string_length\
    \ - 1\n    while i >= 0 {\n        if is_palindrome(string_array, start: 0, end:\
    \ i) {\n            break\n        }\n        i -= 1\n    }\n    var result =\
    \ string\n    for j in (0...i-1).reverse() {\n        result.append(string_array[j])\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(make_palindrome(string:\
    \ \"\") == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmpz2axuwuh.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpz2axuwuh.swift:17:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_array = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpz2axuwuh.swift:20:12: error: cannot find 'is_palindrome'\
    \ in scope\n        if is_palindrome(string_array, start: 0, end: i) {\n     \
    \      ^~~~~~~~~~~~~\n/tmp/tmpz2axuwuh.swift:26:24: error: value of type 'ClosedRange<Int>'\
    \ has no member 'reverse'\n    for j in (0...i-1).reverse() {\n             ~~~~~~~~~\
    \ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014263
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    if string.isEmpty\
    \ {\n        return string\n    }\n    let reversed = String(string.characters.reverse())\n\
    \    let combined = string + \"#\" + reversed\n    let lps = longest_prefix_suffix(combined)\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \    let suffix = String(prefix.characters.reverse())\n    return string + suffix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: SyntaxError
  stderr: "/tmp/tmp_80x2wzn.swift:16:45: error: value of type 'String' has no member\
    \ 'reverse'\n    let reversed = String(string.characters.reverse())\n        \
    \                  ~~~~~~~~~~~~~~~~~ ^~~~~~~\n/tmp/tmp_80x2wzn.swift:18:15: error:\
    \ cannot find 'longest_prefix_suffix' in scope\n    let lps = longest_prefix_suffix(combined)\n\
    \              ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_80x2wzn.swift:19:25: error: value\
    \ of type 'String' has no member 'substringToIndex'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp_80x2wzn.swift:19:60: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let prefix = string.substringToIndex(string.startIndex.advancedBy(lps.count))\n\
    \                                         ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014264
- exit_code: -4
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let n = string.count\n\
    \    let string = Array(string)\n    var z = [Int](repeating: 0, count: n)\n \
    \   var l = 0\n    var r = 0\n    for i in 1..<n {\n        if i <= r {\n    \
    \        z[i] = min(r - i + 1, z[i - l])\n        }\n        while i + z[i] <\
    \ n && string[z[i]] == string[i + z[i]] {\n            z[i] += 1\n        }\n\
    \        if i + z[i] - 1 > r {\n            l = i\n            r = i + z[i] -\
    \ 1\n        }\n    }\n    var result = \"\"\n    for i in 0..<n - z[n - 1] {\n\
    \        result += String(string[n - 1 - i])\n    }\n    for i in 0..<n {\n  \
    \      result += String(string[i])\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(make_palindrome(string: \"\") == \"\")\nassert(make_palindrome(string:\
    \ \"x\") == \"x\")\nassert(make_palindrome(string: \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string:\
    \ \"xyx\") == \"xyx\")\nassert(make_palindrome(string: \"jerry\") == \"jerryrrej\"\
    )"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002ad682a2fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad682726561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad682726286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad68272613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad682725bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpy_nyet08                        0x0000563203b53fc8 <unavailable> + 8136

    6    tmpy_nyet08                        0x0000563203b53875 <unavailable> + 6261

    7    libc.so.6                          0x00002ad682c1b460 __libc_start_main +
    245

    8    tmpy_nyet08                        0x0000563203b53579 <unavailable> + 5497

    '
  stdout: ''
  timestamp: 1660014264
- exit_code: 1
  program: "\n/// Find the shortest palindrome that begins with a supplied string.\n\
    /// Algorithm idea is simple:\n/// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n/// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n/// >>> make_palindrome('')\n\
    /// ''\n/// >>> make_palindrome('cat')\n/// 'catac'\n/// >>> make_palindrome('cata')\n\
    /// 'catac'\nfunc make_palindrome(string: String) -> String {\n    let string_length\
    \ = string.characters.count\n    let string_chars = Array(string.characters)\n\
    \    var longest_palindrome_length = 0\n    var longest_palindrome_index = 0\n\
    \    var palindrome_lengths = Array(count: string_length, repeatedValue: 0)\n\
    \    for i in 0..<string_length {\n        let left = i - 1\n        let right\
    \ = i + 1\n        var length = 1\n        while left >= 0 && right < string_length\
    \ && string_chars[left] == string_chars[right] {\n            length += 2\n  \
    \          left -= 1\n            right += 1\n        }\n        palindrome_lengths[i]\
    \ = length\n        if length > longest_palindrome_length {\n            longest_palindrome_length\
    \ = length\n            longest_palindrome_index = i\n        }\n    }\n    let\
    \ palindrome_start = longest_palindrome_index - longest_palindrome_length + 1\n\
    \    let palindrome_end = longest_palindrome_index + longest_palindrome_length\n\
    \    let prefix = string.substringToIndex(string.startIndex.advancedBy(palindrome_start))\n\
    \    let suffix = string.substringFromIndex(string.startIndex.advancedBy(palindrome_end))\n\
    \    return prefix + suffix.characters.reverse().map { String($0) }.joinWithSeparator(\"\
    \")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(make_palindrome(string: \"\"\
    ) == \"\")\nassert(make_palindrome(string: \"x\") == \"x\")\nassert(make_palindrome(string:\
    \ \"xyz\") == \"xyzyx\")\nassert(make_palindrome(string: \"xyx\") == \"xyx\")\n\
    assert(make_palindrome(string: \"jerry\") == \"jerryrrej\")"
  status: SyntaxError
  stderr: "/tmp/tmp7aulssr1.swift:13:32: error: 'characters' is unavailable: Please\
    \ use String directly\n    let string_length = string.characters.count\n     \
    \                          ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmp7aulssr1.swift:14:37: error: 'characters' is unavailable:\
    \ Please use String directly\n    let string_chars = Array(string.characters)\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp7aulssr1.swift:17:30: error: no exact matches in call\
    \ to initializer \n    var palindrome_lengths = Array(count: string_length, repeatedValue:\
    \ 0)\n                             ^\n/tmp/tmp7aulssr1.swift:17:30: note: candidate\
    \ has partially matching parameter list (repeating: _, count: Int)\n    var palindrome_lengths\
    \ = Array(count: string_length, repeatedValue: 0)\n                          \
    \   ^\n/tmp/tmp7aulssr1.swift:17:30: note: candidate has partially matching parameter\
    \ list (repeating: _, count: Int)\n    var palindrome_lengths = Array(count: string_length,\
    \ repeatedValue: 0)\n                             ^\n/tmp/tmp7aulssr1.swift:24:18:\
    \ error: left side of mutating operator isn't mutable: 'left' is a 'let' constant\n\
    \            left -= 1\n            ~~~~ ^\n/tmp/tmp7aulssr1.swift:19:9: note:\
    \ change 'let' to 'var' to make it mutable\n        let left = i - 1\n       \
    \ ^~~\n        var\n/tmp/tmp7aulssr1.swift:25:19: error: left side of mutating\
    \ operator isn't mutable: 'right' is a 'let' constant\n            right += 1\n\
    \            ~~~~~ ^\n/tmp/tmp7aulssr1.swift:20:9: note: change 'let' to 'var'\
    \ to make it mutable\n        let right = i + 1\n        ^~~\n        var\n/tmp/tmp7aulssr1.swift:35:25:\
    \ error: value of type 'String' has no member 'substringToIndex'\n    let prefix\
    \ = string.substringToIndex(string.startIndex.advancedBy(palindrome_start))\n\
    \                 ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmp7aulssr1.swift:3"
  stdout: ''
  timestamp: 1660014264
