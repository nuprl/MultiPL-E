language: swift
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    let numerals\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"]\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1]\n    for (index, numeral) in numerals.enumerate() {\n      \
    \  while num >= values[index] {\n            result += numeral\n            num\
    \ -= values[index]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpgxqau62_.swift:14:38: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in numerals.enumerate() {\n          \
    \                  ~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var remainder = number\n    while\
    \ remainder > 0 {\n        if remainder >= 1000 {\n            result += \"m\"\
    \n            remainder -= 1000\n        } else if remainder >= 900 {\n      \
    \      result += \"cm\"\n            remainder -= 900\n        } else if remainder\
    \ >= 500 {\n            result += \"d\"\n            remainder -= 500\n      \
    \  } else if remainder >= 400 {\n            result += \"cd\"\n            remainder\
    \ -= 400\n        } else if remainder >= 100 {\n            result += \"c\"\n\
    \            remainder -= 100\n        } else if remainder >= 90 {\n         \
    \   result += \"xc\"\n            remainder -= 90\n        } else if remainder\
    \ >= 50 {\n            result += \"l\"\n            remainder -= 50\n        }\
    \ else if remainder >= 40 {\n            result += \"xl\"\n            remainder\
    \ -= 40\n        } else if remainder >= 10 {\n            result += \"x\"\n  \
    \          remainder -= 10\n        } else if remainder >= 9 {\n            result\
    \ += \"ix\"\n            remainder -= 9\n        } else if remainder >= 5 {\n\
    \            result += \"v\"\n            remainder -= 5\n        } else if remainder\
    \ >= 4 {\n            result += \"iv\"\n            remainder -= 4\n        }\
    \ else if remainder >= 1 {\n            result += \"i\"\n            remainder\
    \ -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    let roman_numerals\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"]\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1]\n    for i in 0..<values.count {\n        while number >= values[i]\
    \ {\n            result += roman_numerals[i]\n            number -= values[i]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while num >= numbers[index] {\n            result += numeral\n  \
    \          num -= numbers[index]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp1_vo3mv5.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let values\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var roman_string\
    \ = \"\"\n    var remaining_number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while remaining_number >= values[index] {\n            roman_string\
    \ += numeral\n            remaining_number -= values[index]\n        }\n    }\n\
    \    return roman_string\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpfie1u5md.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let values\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= values[index] {\n            result += numeral\n\
    \            number -= values[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpa4srp14u.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let values\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var remaining = number\n    for (index, value) in values.enumerate() {\n\
    \        while remaining >= value {\n            result += roman_numerals[index]\n\
    \            remaining -= value\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpe5qiva_m.swift:14:34: error: value of type '[Int]' has no member\
    \ 'enumerate'\n    for (index, value) in values.enumerate() {\n              \
    \            ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, roman) in roman_numerals.enumerate()\
    \ {\n        let number = numbers[index]\n        while num >= number {\n    \
    \        result += roman\n            num -= number\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpesohhgjh.swift:14:42: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, roman) in roman_numerals.enumerate() {\n      \
    \                    ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= numbers[index] {\n            result += numeral\n\
    \            number -= numbers[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpjo25kzkx.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while num >= numbers[index] {\n            result += numeral\n  \
    \          num -= numbers[index]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp1_vo3mv5.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= numbers[index] {\n            result += numeral\n\
    \            number -= numbers[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpjo25kzkx.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let values\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= values[index] {\n            result += numeral\n\
    \            number -= values[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpa4srp14u.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var remaining = number\n    let\
    \ roman_numerals = [\n        (1000, \"m\"),\n        (900, \"cm\"),\n       \
    \ (500, \"d\"),\n        (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"\
    xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n  \
    \      (9, \"ix\"),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"\
    i\")\n    ]\n    for (value, numeral) in roman_numerals {\n        while remaining\
    \ >= value {\n            result += numeral\n            remaining -= value\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var remainder = number\n    let\
    \ roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let values = [1000, 900, 500, 400,\
    \ 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    for (index, value) in values.enumerate()\
    \ {\n        while remainder >= value {\n            result += roman_numerals[index]\n\
    \            remainder -= value\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpesyo784j.swift:14:34: error: value of type '[Int]' has no member\
    \ 'enumerate'\n    for (index, value) in values.enumerate() {\n              \
    \            ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let values\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= values[index] {\n            result += numeral\n\
    \            number -= values[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpa4srp14u.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let values\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while num >= values[index] {\n            result += numeral\n   \
    \         num -= values[index]\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpmkhbtdxs.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var roman = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            roman += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            roman += \"cm\"\n     \
    \       num -= 900\n        } else if num >= 500 {\n            roman += \"d\"\
    \n            num -= 500\n        } else if num >= 400 {\n            roman +=\
    \ \"cd\"\n            num -= 400\n        } else if num >= 100 {\n           \
    \ roman += \"c\"\n            num -= 100\n        } else if num >= 90 {\n    \
    \        roman += \"xc\"\n            num -= 90\n        } else if num >= 50 {\n\
    \            roman += \"l\"\n            num -= 50\n        } else if num >= 40\
    \ {\n            roman += \"xl\"\n            num -= 40\n        } else if num\
    \ >= 10 {\n            roman += \"x\"\n            num -= 10\n        } else if\
    \ num >= 9 {\n            roman += \"ix\"\n            num -= 9\n        } else\
    \ if num >= 5 {\n            roman += \"v\"\n            num -= 5\n        } else\
    \ if num >= 4 {\n            roman += \"iv\"\n            num -= 4\n        }\
    \ else if num >= 1 {\n            roman += \"i\"\n            num -= 1\n     \
    \   }\n    }\n    return roman\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var roman = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            roman += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            roman += \"cm\"\n     \
    \       num -= 900\n        } else if num >= 500 {\n            roman += \"d\"\
    \n            num -= 500\n        } else if num >= 400 {\n            roman +=\
    \ \"cd\"\n            num -= 400\n        } else if num >= 100 {\n           \
    \ roman += \"c\"\n            num -= 100\n        } else if num >= 90 {\n    \
    \        roman += \"xc\"\n            num -= 90\n        } else if num >= 50 {\n\
    \            roman += \"l\"\n            num -= 50\n        } else if num >= 40\
    \ {\n            roman += \"xl\"\n            num -= 40\n        } else if num\
    \ >= 10 {\n            roman += \"x\"\n            num -= 10\n        } else if\
    \ num >= 9 {\n            roman += \"ix\"\n            num -= 9\n        } else\
    \ if num >= 5 {\n            roman += \"v\"\n            num -= 5\n        } else\
    \ if num >= 4 {\n            roman += \"iv\"\n            num -= 4\n        }\
    \ else if num >= 1 {\n            roman += \"i\"\n            num -= 1\n     \
    \   }\n    }\n    return roman\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while num >= numbers[index] {\n            result += numeral\n  \
    \          num -= numbers[index]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp1_vo3mv5.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\n        \"m\", \"cm\", \"d\",\
    \ \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n\
    \    ]\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n\
    \    var result = \"\"\n    var num = number\n    for (index, value) in values.enumerate()\
    \ {\n        while num >= value {\n            result += roman_numerals[index]\n\
    \            num -= value\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpbw0_yiv0.swift:16:34: error: value of type '[Int]' has no member\
    \ 'enumerate'\n    for (index, value) in values.enumerate() {\n              \
    \            ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while num >= numbers[index] {\n            result += numeral\n  \
    \          num -= numbers[index]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp1_vo3mv5.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while num >= numbers[index] {\n            result += numeral\n  \
    \          num -= numbers[index]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp1_vo3mv5.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    let roman_numerals\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"]\n    let decimal_values = [1000, 900, 500, 400, 100, 90,\
    \ 50, 40, 10, 9, 5, 4, 1]\n    for (index, roman_numeral) in roman_numerals.enumerate()\
    \ {\n        let decimal_value = decimal_values[index]\n        while number >=\
    \ decimal_value {\n            result += roman_numeral\n            number -=\
    \ decimal_value\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpj_57q56f.swift:14:50: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, roman_numeral) in roman_numerals.enumerate() {\n\
    \                                  ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= numbers[index] {\n            result += numeral\n\
    \            number -= numbers[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpjo25kzkx.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let numeral_map = [\n        1: \"i\",\n        4: \"\
    iv\",\n        5: \"v\",\n        9: \"ix\",\n        10: \"x\",\n        40:\
    \ \"xl\",\n        50: \"l\",\n        90: \"xc\",\n        100: \"c\",\n    \
    \    400: \"cd\",\n        500: \"d\",\n        900: \"cm\",\n        1000: \"\
    m\"\n    ]\n    var result = \"\"\n    var num = number\n    for (key, value)\
    \ in numeral_map.reverse() {\n        while num >= key {\n            result +=\
    \ value\n            num -= key\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp9fow2awd.swift:27:37: error: value of type '[Int : String]' has\
    \ no member 'reverse'\n    for (key, value) in numeral_map.reverse() {\n     \
    \                   ~~~~~~~~~~~ ^~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let values\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var remainder = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while remainder >= values[index] {\n            result += numeral\n\
    \            remainder -= values[index]\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpxi2znp2k.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    let roman_numerals\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"]\n    let numbers = [1000, 900, 500, 400, 100, 90, 50,\
    \ 40, 10, 9, 5, 4, 1]\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= numbers[index] {\n            result += numeral\n\
    \            number -= numbers[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpdiadt_n1.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var roman = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            roman += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            roman += \"cm\"\n     \
    \       num -= 900\n        } else if num >= 500 {\n            roman += \"d\"\
    \n            num -= 500\n        } else if num >= 400 {\n            roman +=\
    \ \"cd\"\n            num -= 400\n        } else if num >= 100 {\n           \
    \ roman += \"c\"\n            num -= 100\n        } else if num >= 90 {\n    \
    \        roman += \"xc\"\n            num -= 90\n        } else if num >= 50 {\n\
    \            roman += \"l\"\n            num -= 50\n        } else if num >= 40\
    \ {\n            roman += \"xl\"\n            num -= 40\n        } else if num\
    \ >= 10 {\n            roman += \"x\"\n            num -= 10\n        } else if\
    \ num >= 9 {\n            roman += \"ix\"\n            num -= 9\n        } else\
    \ if num >= 5 {\n            roman += \"v\"\n            num -= 5\n        } else\
    \ if num >= 4 {\n            roman += \"iv\"\n            num -= 4\n        }\
    \ else if num >= 1 {\n            roman += \"i\"\n            num -= 1\n     \
    \   }\n    }\n    return roman\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    let numerals\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"]\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1]\n    for (index, value) in values.enumerate() {\n        while\
    \ num >= value {\n            result += numerals[index]\n            num -= value\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp45267ezo.swift:14:34: error: value of type '[Int]' has no member\
    \ 'enumerate'\n    for (index, value) in values.enumerate() {\n              \
    \            ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while num >= numbers[index] {\n            result += numeral\n  \
    \          num -= numbers[index]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp1_vo3mv5.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= numbers[index] {\n            result += numeral\n\
    \            number -= numbers[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpjo25kzkx.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while num >= numbers[index] {\n            result += numeral\n  \
    \          num -= numbers[index]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp1_vo3mv5.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var num = number\n    var result = \"\"\n    let roman_numerals\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"]\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1]\n    for (index, numeral) in roman_numerals.enumerate() {\n\
    \        while num >= values[index] {\n            num -= values[index]\n    \
    \        result += numeral\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp5535tbzw.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while num >= numbers[index] {\n            result += numeral\n  \
    \          num -= numbers[index]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp1_vo3mv5.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for i in 0..<numbers.count {\n        while num\
    \ >= numbers[i] {\n            result += roman_numerals[i]\n            num -=\
    \ numbers[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= numbers[index] {\n            result += numeral\n\
    \            number -= numbers[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpjo25kzkx.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\n        \"m\", \"cm\", \"d\",\
    \ \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n\
    \    ]\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n\
    \    var result = \"\"\n    var num = number\n    for (index, roman_numeral) in\
    \ roman_numerals.enumerate() {\n        while num >= values[index] {\n       \
    \     result += roman_numeral\n            num -= values[index]\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmppet4rzk2.swift:16:50: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, roman_numeral) in roman_numerals.enumerate() {\n\
    \                                  ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let values\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var remainder = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        let value = values[index]\n        while remainder >= value {\n \
    \           result += numeral\n            remainder -= value\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmppd7z61mt.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: -4
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\n        1000: \"m\",\n       \
    \ 900: \"cm\",\n        500: \"d\",\n        400: \"cd\",\n        100: \"c\"\
    ,\n        90: \"xc\",\n        50: \"l\",\n        40: \"xl\",\n        10: \"\
    x\",\n        9: \"ix\",\n        5: \"v\",\n        4: \"iv\",\n        1: \"\
    i\"\n    ]\n    var result = \"\"\n    var number = number\n    for (arabic, roman)\
    \ in roman_numerals {\n        while number >= arabic {\n            result +=\
    \ roman\n            number -= arabic\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: Exception
  stderr: 'tmpsu_oo9_o/tmpsu_oo9_o.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac571162c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac570e59b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac570e59988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac570e587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsu_oo9_o                        0x000055af2fb71693 <unavailable> + 5779

    5    libc.so.6                          0x00002ac57134e460 __libc_start_main +
    245

    6    tmpsu_oo9_o                        0x000055af2fb712f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\n        (1000, \"m\"),\n     \
    \   (900, \"cm\"),\n        (500, \"d\"),\n        (400, \"cd\"),\n        (100,\
    \ \"c\"),\n        (90, \"xc\"),\n        (50, \"l\"),\n        (40, \"xl\"),\n\
    \        (10, \"x\"),\n        (9, \"ix\"),\n        (5, \"v\"),\n        (4,\
    \ \"iv\"),\n        (1, \"i\")\n    ]\n    var result = \"\"\n    var num = number\n\
    \    for (arabic, roman) in roman_numerals {\n        while num >= arabic {\n\
    \            result += roman\n            num -= arabic\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var number = number\n    var result = \"\"\n    let roman_numerals\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"]\n    let numbers = [1000, 900, 500, 400, 100, 90, 50,\
    \ 40, 10, 9, 5, 4, 1]\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= numbers[index] {\n            result += numeral\n\
    \            number -= numbers[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpar2149nw.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let values\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, value) in values.enumerate() {\n   \
    \     while num >= value {\n            result += roman_numerals[index]\n    \
    \        num -= value\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpdgnxqusg.swift:14:34: error: value of type '[Int]' has no member\
    \ 'enumerate'\n    for (index, value) in values.enumerate() {\n              \
    \            ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while num >= numbers[index] {\n            result += numeral\n  \
    \          num -= numbers[index]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp1_vo3mv5.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: -4
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    return \"\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: Exception
  stderr: 'tmpebcs1erc/tmpebcs1erc.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad4b1f48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad4b1c3fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad4b1c3f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad4b1c3e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpebcs1erc                        0x000055a5728dc2e3 <unavailable> + 4835

    5    libc.so.6                          0x00002ad4b2134460 __libc_start_main +
    245

    6    tmpebcs1erc                        0x000055a5728dbf49 <unavailable> + 3913

    '
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    let roman_numerals\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"]\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1]\n    for (index, value) in values.enumerate() {\n        while\
    \ num >= value {\n            result += roman_numerals[index]\n            num\
    \ -= value\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpn6yv1zu5.swift:14:34: error: value of type '[Int]' has no member\
    \ 'enumerate'\n    for (index, value) in values.enumerate() {\n              \
    \            ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= numbers[index] {\n            result += numeral\n\
    \            number -= numbers[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpjo25kzkx.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: -4
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\n        \"m\": 1000,\n       \
    \ \"cm\": 900,\n        \"d\": 500,\n        \"cd\": 400,\n        \"c\": 100,\n\
    \        \"xc\": 90,\n        \"l\": 50,\n        \"xl\": 40,\n        \"x\":\
    \ 10,\n        \"ix\": 9,\n        \"v\": 5,\n        \"iv\": 4,\n        \"i\"\
    : 1\n    ]\n    var result = \"\"\n    var num = number\n    for (roman, arabic)\
    \ in roman_numerals {\n        while num >= arabic {\n            result += roman\n\
    \            num -= arabic\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: Exception
  stderr: 'tmpizy6del0/tmpizy6del0.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4563493c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b456318ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b456318a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45631897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpizy6del0                        0x000055f1a1f6e693 <unavailable> + 5779

    5    libc.so.6                          0x00002b456367f460 __libc_start_main +
    245

    6    tmpizy6del0                        0x000055f1a1f6e2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    let roman_numerals\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"]\n    let numbers = [1000, 900, 500, 400, 100, 90, 50,\
    \ 40, 10, 9, 5, 4, 1]\n    for i in 0..<numbers.count {\n        while num >=\
    \ numbers[i] {\n            result += roman_numerals[i]\n            num -= numbers[i]\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var remaining = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        let number = numbers[index]\n        while remaining >= number {\n\
    \            result += numeral\n            remaining -= number\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp3y3iabrn.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    let numerals\
    \ = [\n        (1000, \"m\"),\n        (900, \"cm\"),\n        (500, \"d\"),\n\
    \        (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"xc\"),\n      \
    \  (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n        (9, \"ix\"\
    ),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"i\")\n    ]\n   \
    \ for (value, numeral) in numerals {\n        while num >= value {\n         \
    \   result += numeral\n            num -= value\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= numbers[index] {\n            result += numeral\n\
    \            number -= numbers[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpjo25kzkx.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= numbers[index] {\n            result += numeral\n\
    \            number -= numbers[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpjo25kzkx.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var roman = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            roman += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            roman += \"cm\"\n     \
    \       num -= 900\n        } else if num >= 500 {\n            roman += \"d\"\
    \n            num -= 500\n        } else if num >= 400 {\n            roman +=\
    \ \"cd\"\n            num -= 400\n        } else if num >= 100 {\n           \
    \ roman += \"c\"\n            num -= 100\n        } else if num >= 90 {\n    \
    \        roman += \"xc\"\n            num -= 90\n        } else if num >= 50 {\n\
    \            roman += \"l\"\n            num -= 50\n        } else if num >= 40\
    \ {\n            roman += \"xl\"\n            num -= 40\n        } else if num\
    \ >= 10 {\n            roman += \"x\"\n            num -= 10\n        } else if\
    \ num >= 9 {\n            roman += \"ix\"\n            num -= 9\n        } else\
    \ if num >= 5 {\n            roman += \"v\"\n            num -= 5\n        } else\
    \ if num >= 4 {\n            roman += \"iv\"\n            num -= 4\n        }\
    \ else if num >= 1 {\n            roman += \"i\"\n            num -= 1\n     \
    \   }\n    }\n    return roman\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var num = number\n    var result = \"\"\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= numbers[index] {\n            result += numeral\n\
    \            number -= numbers[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpjo25kzkx.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var num = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while num >= numbers[index] {\n            result += numeral\n  \
    \          num -= numbers[index]\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmp1_vo3mv5.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    let roman_numerals\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"]\n    let arabic_numerals = [1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1]\n    for i in 0..<roman_numerals.count {\n     \
    \   while num >= arabic_numerals[i] {\n            result += roman_numerals[i]\n\
    \            num -= arabic_numerals[i]\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var number = number\n    var result = \"\"\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    let roman_numerals\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"]\n    let values = [1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1]\n    for i in 0..<roman_numerals.count {\n        while num\
    \ >= values[i] {\n            result += roman_numerals[i]\n            num -=\
    \ values[i]\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    let roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"]\n    let numbers\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    var result = \"\
    \"\n    var number = number\n    for (index, numeral) in roman_numerals.enumerate()\
    \ {\n        while number >= numbers[index] {\n            result += numeral\n\
    \            number -= numbers[index]\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpjo25kzkx.swift:14:44: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, numeral) in roman_numerals.enumerate() {\n    \
    \                        ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    let numerals\
    \ = [\n        (1000, \"m\"),\n        (900, \"cm\"),\n        (500, \"d\"),\n\
    \        (400, \"cd\"),\n        (100, \"c\"),\n        (90, \"xc\"),\n      \
    \  (50, \"l\"),\n        (40, \"xl\"),\n        (10, \"x\"),\n        (9, \"ix\"\
    ),\n        (5, \"v\"),\n        (4, \"iv\"),\n        (1, \"i\")\n    ]\n   \
    \ for (value, numeral) in numerals {\n        while num >= value {\n         \
    \   result += numeral\n            num -= value\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 1
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    let roman_numerals\
    \ = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\"\
    , \"v\", \"iv\", \"i\"]\n    let numbers = [1000, 900, 500, 400, 100, 90, 50,\
    \ 40, 10, 9, 5, 4, 1]\n    for (index, roman) in roman_numerals.enumerate() {\n\
    \        let number = numbers[index]\n        while num >= number {\n        \
    \    result += roman\n            num -= number\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(int_to_mini_roman(number:\
    \ 19) == \"xix\")\nassert(int_to_mini_roman(number: 152) == \"clii\")\nassert(int_to_mini_roman(number:\
    \ 251) == \"ccli\")\nassert(int_to_mini_roman(number: 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number:\
    \ 500) == \"d\")\nassert(int_to_mini_roman(number: 1) == \"i\")\nassert(int_to_mini_roman(number:\
    \ 4) == \"iv\")\nassert(int_to_mini_roman(number: 43) == \"xliii\")\nassert(int_to_mini_roman(number:\
    \ 90) == \"xc\")\nassert(int_to_mini_roman(number: 94) == \"xciv\")\nassert(int_to_mini_roman(number:\
    \ 532) == \"dxxxii\")\nassert(int_to_mini_roman(number: 900) == \"cm\")\nassert(int_to_mini_roman(number:\
    \ 994) == \"cmxciv\")\nassert(int_to_mini_roman(number: 1000) == \"m\")"
  status: SyntaxError
  stderr: "/tmp/tmpty3i_kg4.swift:14:42: error: value of type '[String]' has no member\
    \ 'enumerate'\n    for (index, roman) in roman_numerals.enumerate() {\n      \
    \                    ~~~~~~~~~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var number = number\n    while\
    \ number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n   \
    \         number -= 1000\n        } else if number >= 900 {\n            result\
    \ += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n  \
    \          result += \"d\"\n            number -= 500\n        } else if number\
    \ >= 400 {\n            result += \"cd\"\n            number -= 400\n        }\
    \ else if number >= 100 {\n            result += \"c\"\n            number -=\
    \ 100\n        } else if number >= 90 {\n            result += \"xc\"\n      \
    \      number -= 90\n        } else if number >= 50 {\n            result += \"\
    l\"\n            number -= 50\n        } else if number >= 40 {\n            result\
    \ += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n    \
    \        result += \"x\"\n            number -= 10\n        } else if number >=\
    \ 9 {\n            result += \"ix\"\n            number -= 9\n        } else if\
    \ number >= 5 {\n            result += \"v\"\n            number -= 5\n      \
    \  } else if number >= 4 {\n            result += \"iv\"\n            number -=\
    \ 4\n        } else if number >= 1 {\n            result += \"i\"\n          \
    \  number -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
- exit_code: 0
  program: "\n/// Given a positive integer, obtain its roman numeral equivalent as\
    \ a string,\n/// and return it in lowercase.\n/// Restrictions: 1 <= num <= 1000\n\
    /// Examples:\n/// >>> int_to_mini_roman(19) == 'xix'\n/// >>> int_to_mini_roman(152)\
    \ == 'clii'\n/// >>> int_to_mini_roman(426) == 'cdxxvi'\nfunc int_to_mini_roman(number:\
    \ Int) -> String {\n    var result = \"\"\n    var num = number\n    while num\
    \ > 0 {\n        if num >= 1000 {\n            result += \"m\"\n            num\
    \ -= 1000\n        } else if num >= 900 {\n            result += \"cm\"\n    \
    \        num -= 900\n        } else if num >= 500 {\n            result += \"\
    d\"\n            num -= 500\n        } else if num >= 400 {\n            result\
    \ += \"cd\"\n            num -= 400\n        } else if num >= 100 {\n        \
    \    result += \"c\"\n            num -= 100\n        } else if num >= 90 {\n\
    \            result += \"xc\"\n            num -= 90\n        } else if num >=\
    \ 50 {\n            result += \"l\"\n            num -= 50\n        } else if\
    \ num >= 40 {\n            result += \"xl\"\n            num -= 40\n        }\
    \ else if num >= 10 {\n            result += \"x\"\n            num -= 10\n  \
    \      } else if num >= 9 {\n            result += \"ix\"\n            num -=\
    \ 9\n        } else if num >= 5 {\n            result += \"v\"\n            num\
    \ -= 5\n        } else if num >= 4 {\n            result += \"iv\"\n         \
    \   num -= 4\n        } else if num >= 1 {\n            result += \"i\"\n    \
    \        num -= 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(int_to_mini_roman(number: 19) == \"xix\")\nassert(int_to_mini_roman(number:\
    \ 152) == \"clii\")\nassert(int_to_mini_roman(number: 251) == \"ccli\")\nassert(int_to_mini_roman(number:\
    \ 426) == \"cdxxvi\")\nassert(int_to_mini_roman(number: 500) == \"d\")\nassert(int_to_mini_roman(number:\
    \ 1) == \"i\")\nassert(int_to_mini_roman(number: 4) == \"iv\")\nassert(int_to_mini_roman(number:\
    \ 43) == \"xliii\")\nassert(int_to_mini_roman(number: 90) == \"xc\")\nassert(int_to_mini_roman(number:\
    \ 94) == \"xciv\")\nassert(int_to_mini_roman(number: 532) == \"dxxxii\")\nassert(int_to_mini_roman(number:\
    \ 900) == \"cm\")\nassert(int_to_mini_roman(number: 994) == \"cmxciv\")\nassert(int_to_mini_roman(number:\
    \ 1000) == \"m\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014197
