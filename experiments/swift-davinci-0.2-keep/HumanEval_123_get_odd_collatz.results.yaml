language: swift
name: HumanEval_123_get_odd_collatz
results:
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpw1ye57lc/tmpw1ye57lc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae38d040c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae38cd37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae38cd37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae38cd367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ye57lc                        0x000055582e9504ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae38d22c460 __libc_start_main +
    245

    6    tmpw1ye57lc                        0x000055582e950119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = current * 3 + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpfne41wvv/tmpfne41wvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c5e35dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c5e054b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c5e054988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c5e0537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfne41wvv                        0x000055fd5346355a <unavailable> + 5466

    5    libc.so.6                          0x00002b0c5e549460 __libc_start_main +
    245

    6    tmpfne41wvv                        0x000055fd53463189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = current * 3 + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpfne41wvv/tmpfne41wvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c5e35dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c5e054b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c5e054988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c5e0537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfne41wvv                        0x000055fd5346355a <unavailable> + 5466

    5    libc.so.6                          0x00002b0c5e549460 __libc_start_main +
    245

    6    tmpfne41wvv                        0x000055fd53463189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmppogx0ezl/tmppogx0ezl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76cd163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76cce5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76cce5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76cce597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppogx0ezl                        0x0000562c02ada5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b76cd34f460 __libc_start_main +
    245

    6    tmppogx0ezl                        0x0000562c02ada1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var num = n\n    while num != 1 {\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n        collatz.append(num)\n    }\n    return collatz.filter { $0\
    \ % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpqbeya5__/tmpqbeya5__.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1497bb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14978a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14978a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14978a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqbeya5__                        0x00005578fe94755a <unavailable> + 5466

    5    libc.so.6                          0x00002b1497d9d460 __libc_start_main +
    245

    6    tmpqbeya5__                        0x00005578fe947189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter({$0\
    \ % 2 != 0})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp1c31p9_t/tmp1c31p9_t.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6129908c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61295ffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b61295ff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b61295fe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1c31p9_t                        0x000055f5c5dfe5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b6129af4460 __libc_start_main +
    245

    6    tmp1c31p9_t                        0x000055f5c5dfe1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : 3 * num + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpzv6aymty/tmpzv6aymty.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b892d663c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b892d35ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b892d35a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b892d3597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzv6aymty                        0x000055e820fee4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b892d84f460 __libc_start_main +
    245

    6    tmpzv6aymty                        0x000055e820fee119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var odd = [Int]()\n    while collatz.last != 1 {\n      \
    \  if collatz.last! % 2 == 0 {\n            collatz.append(collatz.last! / 2)\n\
    \        } else {\n            collatz.append(collatz.last! * 3 + 1)\n       \
    \ }\n    }\n    for i in collatz {\n        if i % 2 != 0 {\n            odd.append(i)\n\
    \        }\n    }\n    return odd\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp4jyu2377/tmp4jyu2377.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b65f9219c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b65f8f10b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b65f8f10988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65f8f0f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4jyu2377                        0x000055902b8626ea <unavailable> + 5866

    5    libc.so.6                          0x00002b65f9405460 __libc_start_main +
    245

    6    tmp4jyu2377                        0x000055902b862319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : 3 * num + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpzv6aymty/tmpzv6aymty.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b892d663c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b892d35ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b892d35a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b892d3597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzv6aymty                        0x000055e820fee4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b892d84f460 __libc_start_main +
    245

    6    tmpzv6aymty                        0x000055e820fee119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        n = n % 2 == 0 ? n / 2 : 3 * n +\
    \ 1\n        collatz.append(n)\n    }\n    return collatz.filter { $0 % 2 != 0\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14) == [1,\
    \ 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpk114m5kd.swift:16:9: error: cannot assign to value: 'n' is a 'let'\
    \ constant\n        n = n % 2 == 0 ? n / 2 : 3 * n + 1\n        ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var current = n\n    while current != 1 {\n        if\
    \ current % 2 == 1 {\n            result.append(current)\n        }\n        current\
    \ = current % 2 == 0 ? current / 2 : current * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp5ysbchyn/tmp5ysbchyn.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac237160c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac236e57b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac236e57988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac236e567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ysbchyn                        0x0000561bbaa534ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac23734c460 __libc_start_main +
    245

    6    tmp5ysbchyn                        0x0000561bbaa53119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = 3 * current + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpnsk11v9l/tmpnsk11v9l.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aab2489fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aab24596b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aab24596988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aab245957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnsk11v9l                        0x000055654c90f55a <unavailable> + 5466

    5    libc.so.6                          0x00002aab24a8b460 __libc_start_main +
    245

    6    tmpnsk11v9l                        0x000055654c90f189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var oddCollatz = [Int]()\n    var current = n\n    while\
    \ current != 1 {\n        if current % 2 == 0 {\n            current /= 2\n  \
    \      } else {\n            current = 3 * current + 1\n        }\n        collatz.append(current)\n\
    \    }\n    for i in collatz {\n        if i % 2 != 0 {\n            oddCollatz.append(i)\n\
    \        }\n    }\n    return oddCollatz\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmptlck2gjj/tmptlck2gjj.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3f30168c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3f2fe5fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3f2fe5f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3f2fe5e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptlck2gjj                        0x0000555a91d6064a <unavailable> + 5706

    5    libc.so.6                          0x00002b3f30354460 __libc_start_main +
    245

    6    tmptlck2gjj                        0x0000555a91d60279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result: [Int] = []\n    var num = n\n    while num != 1 {\n        if num %\
    \ 2 == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpjraxhxyg/tmpjraxhxyg.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab520836c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab52052db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab52052d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab52052c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjraxhxyg                        0x000056047820f48a <unavailable> + 5258

    5    libc.so.6                          0x00002ab520a22460 __libc_start_main +
    245

    6    tmpjraxhxyg                        0x000056047820f0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    return\
    \ []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_odd_collatz(n: 14) == [1,\
    \ 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl0bi2s6p/tmpl0bi2s6p.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ef5095c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ef4d8cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ef4d8c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ef4d8b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl0bi2s6p                        0x000055deb820239a <unavailable> + 5018

    5    libc.so.6                          0x00002b4ef5281460 __libc_start_main +
    245

    6    tmpl0bi2s6p                        0x000055deb8201fc9 <unavailable> + 4041

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var next = n\n    while next != 1 {\n        if next % 2\
    \ == 0 {\n            next /= 2\n        } else {\n            next = next * 3\
    \ + 1\n        }\n        collatz.append(next)\n    }\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp955ht5w3/tmp955ht5w3.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae059e3bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae059b32b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae059b32988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae059b317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp955ht5w3                        0x000055c2cf68855a <unavailable> + 5466

    5    libc.so.6                          0x00002ae05a027460 __libc_start_main +
    245

    6    tmp955ht5w3                        0x000055c2cf688189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = current * 3 + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpfne41wvv/tmpfne41wvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c5e35dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c5e054b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c5e054988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c5e0537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfne41wvv                        0x000055fd5346355a <unavailable> + 5466

    5    libc.so.6                          0x00002b0c5e549460 __libc_start_main +
    245

    6    tmpfne41wvv                        0x000055fd53463189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result: [Int] = []\n    var num = n\n    while num != 1 {\n        if num %\
    \ 2 == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpjraxhxyg/tmpjraxhxyg.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab520836c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab52052db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab52052d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab52052c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjraxhxyg                        0x000056047820f48a <unavailable> + 5258

    5    libc.so.6                          0x00002ab520a22460 __libc_start_main +
    245

    6    tmpjraxhxyg                        0x000056047820f0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpw1ye57lc/tmpw1ye57lc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae38d040c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae38cd37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae38cd37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae38cd367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ye57lc                        0x000055582e9504ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae38d22c460 __libc_start_main +
    245

    6    tmpw1ye57lc                        0x000055582e950119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var i = n\n    while i > 1 {\n        collatz.append(i)\n\
    \        if i % 2 == 0 {\n            i /= 2\n        } else {\n            i\
    \ = 3 * i + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp6v8b99ho/tmp6v8b99ho.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24d7892c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24d7589b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24d7589988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24d75887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6v8b99ho                        0x00005556e6e065aa <unavailable> + 5546

    5    libc.so.6                          0x00002b24d7a7e460 __libc_start_main +
    245

    6    tmp6v8b99ho                        0x00005556e6e061d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpw1ye57lc/tmpw1ye57lc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae38d040c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae38cd37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae38cd37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae38cd367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ye57lc                        0x000055582e9504ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae38d22c460 __libc_start_main +
    245

    6    tmpw1ye57lc                        0x000055582e950119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = n * 3 + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmp5f15g0qi.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmp5f15g0qi.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = n *\
    \ 3 + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpw1ye57lc/tmpw1ye57lc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae38d040c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae38cd37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae38cd37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae38cd367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ye57lc                        0x000055582e9504ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae38d22c460 __libc_start_main +
    245

    6    tmpw1ye57lc                        0x000055582e950119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var i = n\n    while i != 1 {\n        if i % 2 == 0 {\n\
    \            i /= 2\n        } else {\n            i = 3 * i + 1\n        }\n\
    \        collatz.append(i)\n    }\n    return collatz.filter{$0 % 2 != 0}\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpnsdxdor8/tmpnsdxdor8.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1429ed9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1429bd0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1429bd0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1429bcf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnsdxdor8                        0x00005644fc07a55a <unavailable> + 5466

    5    libc.so.6                          0x00002b142a0c5460 __libc_start_main +
    245

    6    tmpnsdxdor8                        0x00005644fc07a189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpw1ye57lc/tmpw1ye57lc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae38d040c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae38cd37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae38cd37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae38cd367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ye57lc                        0x000055582e9504ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae38d22c460 __libc_start_main +
    245

    6    tmpw1ye57lc                        0x000055582e950119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = current * 3 + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpfne41wvv/tmpfne41wvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c5e35dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c5e054b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c5e054988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c5e0537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfne41wvv                        0x000055fd5346355a <unavailable> + 5466

    5    libc.so.6                          0x00002b0c5e549460 __libc_start_main +
    245

    6    tmpfne41wvv                        0x000055fd53463189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : 3 * num + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpzv6aymty/tmpzv6aymty.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b892d663c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b892d35ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b892d35a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b892d3597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzv6aymty                        0x000055e820fee4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b892d84f460 __libc_start_main +
    245

    6    tmpzv6aymty                        0x000055e820fee119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = current * 3 + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpfne41wvv/tmpfne41wvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c5e35dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c5e054b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c5e054988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c5e0537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfne41wvv                        0x000055fd5346355a <unavailable> + 5466

    5    libc.so.6                          0x00002b0c5e549460 __libc_start_main +
    245

    6    tmpfne41wvv                        0x000055fd53463189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = current * 3 + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpfne41wvv/tmpfne41wvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c5e35dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c5e054b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c5e054988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c5e0537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfne41wvv                        0x000055fd5346355a <unavailable> + 5466

    5    libc.so.6                          0x00002b0c5e549460 __libc_start_main +
    245

    6    tmpfne41wvv                        0x000055fd53463189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpw1ye57lc/tmpw1ye57lc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae38d040c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae38cd37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae38cd37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae38cd367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ye57lc                        0x000055582e9504ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae38d22c460 __libc_start_main +
    245

    6    tmpw1ye57lc                        0x000055582e950119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmppogx0ezl/tmppogx0ezl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76cd163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76cce5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76cce5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76cce597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppogx0ezl                        0x0000562c02ada5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b76cd34f460 __libc_start_main +
    245

    6    tmppogx0ezl                        0x0000562c02ada1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmppogx0ezl/tmppogx0ezl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76cd163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76cce5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76cce5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76cce597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppogx0ezl                        0x0000562c02ada5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b76cd34f460 __libc_start_main +
    245

    6    tmppogx0ezl                        0x0000562c02ada1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpw1ye57lc/tmpw1ye57lc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae38d040c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae38cd37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae38cd37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae38cd367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ye57lc                        0x000055582e9504ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae38d22c460 __libc_start_main +
    245

    6    tmpw1ye57lc                        0x000055582e950119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : 3 * num + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpzv6aymty/tmpzv6aymty.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b892d663c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b892d35ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b892d35a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b892d3597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzv6aymty                        0x000055e820fee4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b892d84f460 __libc_start_main +
    245

    6    tmpzv6aymty                        0x000055e820fee119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while collatz.last! != 1 {\n        if collatz.last! % 2\
    \ == 0 {\n            collatz.append(collatz.last! / 2)\n        } else {\n  \
    \          collatz.append(collatz.last! * 3 + 1)\n        }\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpin5k9t9o/tmpin5k9t9o.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e92a90c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e92787b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e92787988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e927867b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpin5k9t9o                        0x000055a9f03885fa <unavailable> + 5626

    5    libc.so.6                          0x00002b8e92c7c460 __libc_start_main +
    245

    6    tmpin5k9t9o                        0x000055a9f0388229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result: [Int] = []\n    var num = n\n    while num != 1 {\n        if num %\
    \ 2 == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpjraxhxyg/tmpjraxhxyg.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab520836c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab52052db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab52052d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab52052c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjraxhxyg                        0x000056047820f48a <unavailable> + 5258

    5    libc.so.6                          0x00002ab520a22460 __libc_start_main +
    245

    6    tmpjraxhxyg                        0x000056047820f0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result: [Int] = []\n    var num = n\n    while num != 1 {\n        if num %\
    \ 2 == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpjraxhxyg/tmpjraxhxyg.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab520836c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab52052db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab52052d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab52052c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjraxhxyg                        0x000056047820f48a <unavailable> + 5258

    5    libc.so.6                          0x00002ab520a22460 __libc_start_main +
    245

    6    tmpjraxhxyg                        0x000056047820f0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpw1ye57lc/tmpw1ye57lc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae38d040c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae38cd37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae38cd37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae38cd367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ye57lc                        0x000055582e9504ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae38d22c460 __libc_start_main +
    245

    6    tmpw1ye57lc                        0x000055582e950119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var i = n\n    while i > 1 {\n        collatz.append(i)\n\
    \        if i % 2 == 0 {\n            i /= 2\n        } else {\n            i\
    \ = 3 * i + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp6v8b99ho/tmp6v8b99ho.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b24d7892c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b24d7589b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b24d7589988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b24d75887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6v8b99ho                        0x00005556e6e065aa <unavailable> + 5546

    5    libc.so.6                          0x00002b24d7a7e460 __libc_start_main +
    245

    6    tmp6v8b99ho                        0x00005556e6e061d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : 3 * num + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmph8wzyglz/tmph8wzyglz.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f4ea21c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f4e718b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f4e718988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f4e7177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8wzyglz                        0x0000557e652b54ea <unavailable> + 5354

    5    libc.so.6                          0x00002b2f4ec0d460 __libc_start_main +
    245

    6    tmph8wzyglz                        0x0000557e652b5119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var odd = [Int]()\n    while n != 1 {\n        if n % 2 ==\
    \ 0 {\n            n /= 2\n        } else {\n            n = n * 3 + 1\n     \
    \   }\n        collatz.append(n)\n    }\n    for i in collatz {\n        if i\
    \ % 2 != 0 {\n            odd.append(i)\n        }\n    }\n    return odd\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmp6tcvsfcr.swift:18:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmp6tcvsfcr.swift:20:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = n *\
    \ 3 + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : 3 * num + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpzv6aymty/tmpzv6aymty.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b892d663c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b892d35ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b892d35a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b892d3597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzv6aymty                        0x000055e820fee4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b892d84f460 __libc_start_main +
    245

    6    tmpzv6aymty                        0x000055e820fee119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        current\
    \ = current % 2 == 0 ? current / 2 : current * 3 + 1\n        collatz.append(current)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpvvam5aid/tmpvvam5aid.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6451e7dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6451b74b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6451b74988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6451b737b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvvam5aid                        0x000055753e13955a <unavailable> + 5466

    5    libc.so.6                          0x00002b6452069460 __libc_start_main +
    245

    6    tmpvvam5aid                        0x000055753e139189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : 3 * num + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpzv6aymty/tmpzv6aymty.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b892d663c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b892d35ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b892d35a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b892d3597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzv6aymty                        0x000055e820fee4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b892d84f460 __libc_start_main +
    245

    6    tmpzv6aymty                        0x000055e820fee119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result: [Int] = []\n    var num = n\n    while num != 1 {\n        if num %\
    \ 2 == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpjraxhxyg/tmpjraxhxyg.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab520836c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab52052db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab52052d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab52052c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjraxhxyg                        0x000056047820f48a <unavailable> + 5258

    5    libc.so.6                          0x00002ab520a22460 __libc_start_main +
    245

    6    tmpjraxhxyg                        0x000056047820f0b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var next = n\n    while next != 1 {\n        next = next\
    \ % 2 == 0 ? next / 2 : next * 3 + 1\n        collatz.append(next)\n    }\n  \
    \  return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: Exception
  stderr: 'tmpu6ltdxox/tmpu6ltdxox.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd3bf9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd3bc95b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd3bc95988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd3bc947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu6ltdxox                        0x000055d030d2455a <unavailable> + 5466

    5    libc.so.6                          0x00002abd3c18a460 __libc_start_main +
    245

    6    tmpu6ltdxox                        0x000055d030d24189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmppogx0ezl/tmppogx0ezl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76cd163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76cce5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76cce5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76cce597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppogx0ezl                        0x0000562c02ada5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b76cd34f460 __libc_start_main +
    245

    6    tmppogx0ezl                        0x0000562c02ada1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = 3 * current + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpnsk11v9l/tmpnsk11v9l.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aab2489fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aab24596b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aab24596988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aab245957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnsk11v9l                        0x000055654c90f55a <unavailable> + 5466

    5    libc.so.6                          0x00002aab24a8b460 __libc_start_main +
    245

    6    tmpnsk11v9l                        0x000055654c90f189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmppogx0ezl/tmppogx0ezl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76cd163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76cce5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76cce5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76cce597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppogx0ezl                        0x0000562c02ada5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b76cd34f460 __libc_start_main +
    245

    6    tmppogx0ezl                        0x0000562c02ada1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var odd = [Int]()\n    var current = n\n    while current\
    \ != 1 {\n        if current % 2 == 0 {\n            current /= 2\n        } else\
    \ {\n            current = current * 3 + 1\n        }\n        collatz.append(current)\n\
    \    }\n    for num in collatz {\n        if num % 2 != 0 {\n            odd.append(num)\n\
    \        }\n    }\n    return odd\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpp_65bg_v/tmpp_65bg_v.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2db46d4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2db43cbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2db43cb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2db43ca7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp_65bg_v                        0x000055bdf7d7164a <unavailable> + 5706

    5    libc.so.6                          0x00002b2db48c0460 __libc_start_main +
    245

    6    tmpp_65bg_v                        0x000055bdf7d71279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = current * 3 + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpfne41wvv/tmpfne41wvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c5e35dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c5e054b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c5e054988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c5e0537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfne41wvv                        0x000055fd5346355a <unavailable> + 5466

    5    libc.so.6                          0x00002b0c5e549460 __libc_start_main +
    245

    6    tmpfne41wvv                        0x000055fd53463189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = current * 3 + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpfne41wvv/tmpfne41wvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c5e35dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c5e054b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c5e054988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c5e0537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfne41wvv                        0x000055fd5346355a <unavailable> + 5466

    5    libc.so.6                          0x00002b0c5e549460 __libc_start_main +
    245

    6    tmpfne41wvv                        0x000055fd53463189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = n * 3 + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmp5f15g0qi.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmp5f15g0qi.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = n *\
    \ 3 + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var num = n\n    while num != 1 {\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = num * 3 + 1\n\
    \        }\n        collatz.append(num)\n    }\n    return collatz.filter { $0\
    \ % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp1hjj5fql/tmp1hjj5fql.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b17ca9e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b17ca6d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b17ca6d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b17ca6d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1hjj5fql                        0x0000559a47c5855a <unavailable> + 5466

    5    libc.so.6                          0x00002b17cabcd460 __libc_start_main +
    245

    6    tmp1hjj5fql                        0x0000559a47c58189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : 3 * num + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpzv6aymty/tmpzv6aymty.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b892d663c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b892d35ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b892d35a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b892d3597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzv6aymty                        0x000055e820fee4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b892d84f460 __libc_start_main +
    245

    6    tmpzv6aymty                        0x000055e820fee119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var num = n\n    while num != 1 {\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n        collatz.append(num)\n    }\n    return collatz.filter { $0\
    \ % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpqbeya5__/tmpqbeya5__.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1497bb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14978a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14978a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14978a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqbeya5__                        0x00005578fe94755a <unavailable> + 5466

    5    libc.so.6                          0x00002b1497d9d460 __libc_start_main +
    245

    6    tmpqbeya5__                        0x00005578fe947189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmppogx0ezl/tmppogx0ezl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76cd163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76cce5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76cce5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76cce597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppogx0ezl                        0x0000562c02ada5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b76cd34f460 __libc_start_main +
    245

    6    tmppogx0ezl                        0x0000562c02ada1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var odd_collatz = [Int]()\n    while collatz.last != 1 {\n\
    \        if collatz.last! % 2 == 0 {\n            collatz.append(collatz.last!\
    \ / 2)\n        } else {\n            collatz.append(collatz.last! * 3 + 1)\n\
    \        }\n    }\n    for i in collatz {\n        if i % 2 != 0 {\n         \
    \   odd_collatz.append(i)\n        }\n    }\n    return odd_collatz\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpd0l6s0s_/tmpd0l6s0s_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b63880cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6387dc2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6387dc2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6387dc17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd0l6s0s_                        0x00005607a86e16ea <unavailable> + 5866

    5    libc.so.6                          0x00002b63882b7460 __libc_start_main +
    245

    6    tmpd0l6s0s_                        0x00005607a86e1319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter({$0\
    \ % 2 != 0})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp1c31p9_t/tmp1c31p9_t.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6129908c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61295ffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b61295ff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b61295fe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1c31p9_t                        0x000055f5c5dfe5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b6129af4460 __libc_start_main +
    245

    6    tmp1c31p9_t                        0x000055f5c5dfe1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        result.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    result.append(1)\n    return result.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpv3ul2j_r/tmpv3ul2j_r.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b145342bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1453122b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1453122988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14531217b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv3ul2j_r                        0x000055ad28a245aa <unavailable> + 5546

    5    libc.so.6                          0x00002b1453617460 __libc_start_main +
    245

    6    tmpv3ul2j_r                        0x000055ad28a241d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmppogx0ezl/tmppogx0ezl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76cd163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76cce5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76cce5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76cce597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppogx0ezl                        0x0000562c02ada5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b76cd34f460 __libc_start_main +
    245

    6    tmppogx0ezl                        0x0000562c02ada1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var num = n\n    while num != 1 {\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n        collatz.append(num)\n    }\n    return collatz.filter { $0\
    \ % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpqbeya5__/tmpqbeya5__.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1497bb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14978a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14978a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14978a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqbeya5__                        0x00005578fe94755a <unavailable> + 5466

    5    libc.so.6                          0x00002b1497d9d460 __libc_start_main +
    245

    6    tmpqbeya5__                        0x00005578fe947189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = current * 3 + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpfne41wvv/tmpfne41wvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c5e35dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c5e054b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c5e054988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c5e0537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfne41wvv                        0x000055fd5346355a <unavailable> + 5466

    5    libc.so.6                          0x00002b0c5e549460 __libc_start_main +
    245

    6    tmpfne41wvv                        0x000055fd53463189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = 3 * current + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpnsk11v9l/tmpnsk11v9l.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aab2489fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aab24596b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aab24596988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aab245957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnsk11v9l                        0x000055654c90f55a <unavailable> + 5466

    5    libc.so.6                          0x00002aab24a8b460 __libc_start_main +
    245

    6    tmpnsk11v9l                        0x000055654c90f189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpw1ye57lc/tmpw1ye57lc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae38d040c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae38cd37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae38cd37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae38cd367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ye57lc                        0x000055582e9504ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae38d22c460 __libc_start_main +
    245

    6    tmpw1ye57lc                        0x000055582e950119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmppogx0ezl/tmppogx0ezl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76cd163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76cce5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76cce5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76cce597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppogx0ezl                        0x0000562c02ada5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b76cd34f460 __libc_start_main +
    245

    6    tmppogx0ezl                        0x0000562c02ada1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpw1ye57lc/tmpw1ye57lc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae38d040c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae38cd37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae38cd37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae38cd367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ye57lc                        0x000055582e9504ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae38d22c460 __libc_start_main +
    245

    6    tmpw1ye57lc                        0x000055582e950119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var num = n\n    while num != 1 {\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n        collatz.append(num)\n    }\n    return collatz.filter { $0\
    \ % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpqbeya5__/tmpqbeya5__.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1497bb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14978a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14978a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14978a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqbeya5__                        0x00005578fe94755a <unavailable> + 5466

    5    libc.so.6                          0x00002b1497d9d460 __libc_start_main +
    245

    6    tmpqbeya5__                        0x00005578fe947189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: 1
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    while n != 1 {\n        if n % 2 == 0 {\n            n /=\
    \ 2\n        } else {\n            n = 3 * n + 1\n        }\n        collatz.append(n)\n\
    \    }\n    return collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n:\
    \ 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1, 3, 5])\nassert(get_odd_collatz(n:\
    \ 1) == [1])"
  status: SyntaxError
  stderr: "/tmp/tmpco7_090d.swift:17:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= 2\n            ~ ^\n/tmp/tmpco7_090d.swift:19:13:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n            n = 3 *\
    \ n + 1\n            ^\n"
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : 3 * num + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpzv6aymty/tmpzv6aymty.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b892d663c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b892d35ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b892d35a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b892d3597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzv6aymty                        0x000055e820fee4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b892d84f460 __libc_start_main +
    245

    6    tmpzv6aymty                        0x000055e820fee119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmppogx0ezl/tmppogx0ezl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76cd163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76cce5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76cce5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76cce597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppogx0ezl                        0x0000562c02ada5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b76cd34f460 __libc_start_main +
    245

    6    tmppogx0ezl                        0x0000562c02ada1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmppogx0ezl/tmppogx0ezl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76cd163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76cce5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76cce5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76cce597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppogx0ezl                        0x0000562c02ada5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b76cd34f460 __libc_start_main +
    245

    6    tmppogx0ezl                        0x0000562c02ada1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpw1ye57lc/tmpw1ye57lc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae38d040c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae38cd37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae38cd37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae38cd367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ye57lc                        0x000055582e9504ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae38d22c460 __libc_start_main +
    245

    6    tmpw1ye57lc                        0x000055582e950119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmppogx0ezl/tmppogx0ezl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76cd163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76cce5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76cce5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76cce597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppogx0ezl                        0x0000562c02ada5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b76cd34f460 __libc_start_main +
    245

    6    tmppogx0ezl                        0x0000562c02ada1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num > 1 {\n        if num % 2 ==\
    \ 1 {\n            result.append(num)\n        }\n        num = num % 2 == 0 ?\
    \ num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpw1ye57lc/tmpw1ye57lc.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae38d040c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae38cd37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae38cd37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae38cd367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1ye57lc                        0x000055582e9504ea <unavailable> + 5354

    5    libc.so.6                          0x00002ae38d22c460 __libc_start_main +
    245

    6    tmpw1ye57lc                        0x000055582e950119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var num = n\n    while num != 1 {\n        if num % 2 ==\
    \ 0 {\n            num /= 2\n        } else {\n            num = 3 * num + 1\n\
    \        }\n        collatz.append(num)\n    }\n    return collatz.filter { $0\
    \ % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpqbeya5__/tmpqbeya5__.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1497bb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b14978a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b14978a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b14978a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqbeya5__                        0x00005578fe94755a <unavailable> + 5466

    5    libc.so.6                          0x00002b1497d9d460 __libc_start_main +
    245

    6    tmpqbeya5__                        0x00005578fe947189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : 3 * num + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpzv6aymty/tmpzv6aymty.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b892d663c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b892d35ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b892d35a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b892d3597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzv6aymty                        0x000055e820fee4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b892d84f460 __libc_start_main +
    245

    6    tmpzv6aymty                        0x000055e820fee119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = current * 3 + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpfne41wvv/tmpfne41wvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c5e35dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c5e054b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c5e054988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c5e0537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfne41wvv                        0x000055fd5346355a <unavailable> + 5466

    5    libc.so.6                          0x00002b0c5e549460 __libc_start_main +
    245

    6    tmpfne41wvv                        0x000055fd53463189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : 3 * num + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpzv6aymty/tmpzv6aymty.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b892d663c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b892d35ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b892d35a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b892d3597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzv6aymty                        0x000055e820fee4ea <unavailable> + 5354

    5    libc.so.6                          0x00002b892d84f460 __libc_start_main +
    245

    6    tmpzv6aymty                        0x000055e820fee119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = num * 3 + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmppogx0ezl/tmppogx0ezl.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76cd163c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b76cce5ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b76cce5a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b76cce597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppogx0ezl                        0x0000562c02ada5aa <unavailable> + 5546

    5    libc.so.6                          0x00002b76cd34f460 __libc_start_main +
    245

    6    tmppogx0ezl                        0x0000562c02ada1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var odd = [Int]()\n    var current = n\n    while current\
    \ != 1 {\n        if current % 2 == 0 {\n            current /= 2\n        } else\
    \ {\n            current = 3 * current + 1\n        }\n        collatz.append(current)\n\
    \    }\n    for i in collatz {\n        if i % 2 != 0 {\n            odd.append(i)\n\
    \        }\n    }\n    return odd\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpoa2stx3d/tmpoa2stx3d.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adbf8159c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adbf7e50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adbf7e50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adbf7e4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoa2stx3d                        0x0000563f4814c64a <unavailable> + 5706

    5    libc.so.6                          0x00002adbf8345460 __libc_start_main +
    245

    6    tmpoa2stx3d                        0x0000563f4814c279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = 3 * current + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpnsk11v9l/tmpnsk11v9l.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aab2489fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aab24596b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aab24596988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aab245957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnsk11v9l                        0x000055654c90f55a <unavailable> + 5466

    5    libc.so.6                          0x00002aab24a8b460 __libc_start_main +
    245

    6    tmpnsk11v9l                        0x000055654c90f189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [n]\n    var current = n\n    while current != 1 {\n        if current\
    \ % 2 == 0 {\n            current /= 2\n        } else {\n            current\
    \ = current * 3 + 1\n        }\n        collatz.append(current)\n    }\n    return\
    \ collatz.filter { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpfne41wvv/tmpfne41wvv.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c5e35dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c5e054b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c5e054988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c5e0537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfne41wvv                        0x000055fd5346355a <unavailable> + 5466

    5    libc.so.6                          0x00002b0c5e549460 __libc_start_main +
    245

    6    tmpfne41wvv                        0x000055fd53463189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ collatz = [Int]()\n    var num = n\n    while num != 1 {\n        collatz.append(num)\n\
    \        if num % 2 == 0 {\n            num /= 2\n        } else {\n         \
    \   num = 3 * num + 1\n        }\n    }\n    collatz.append(1)\n    return collatz.filter\
    \ { $0 % 2 != 0 }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpwd2m4x4c/tmpwd2m4x4c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b827da4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b827d745b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b827d745988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b827d7447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd2m4x4c                        0x000055b39a7555aa <unavailable> + 5546

    5    libc.so.6                          0x00002b827dc3a460 __libc_start_main +
    245

    6    tmpwd2m4x4c                        0x000055b39a7551d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var current = n\n    while current != 1 {\n        if\
    \ current % 2 == 1 {\n            result.append(current)\n        }\n        current\
    \ = current % 2 == 0 ? current / 2 : current * 3 + 1\n    }\n    result.append(1)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_odd_collatz(n:\
    \ 14) == [1, 5, 7, 11, 13, 17])\nassert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n:\
    \ 12) == [1, 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmp5ysbchyn/tmp5ysbchyn.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac237160c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac236e57b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac236e57988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac236e567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ysbchyn                        0x0000561bbaa534ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac23734c460 __libc_start_main +
    245

    6    tmp5ysbchyn                        0x0000561bbaa53119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
- exit_code: -4
  program: "\n/// Given a positive integer n, return a sorted list that has the odd\
    \ numbers in collatz sequence.\n/// The Collatz conjecture is a conjecture in\
    \ mathematics that concerns a sequence defined\n/// as follows: start with any\
    \ positive integer n. Then each term is obtained from the \n/// previous term\
    \ as follows: if the previous term is even, the next term is one half of \n///\
    \ the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n/// term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n/// Note: \n/// 1. Collatz(1) is [1].\n///\
    \ 2. returned list sorted in increasing order.\n/// For example:\n/// get_odd_collatz(5)\
    \ returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd\
    \ numbers are only 1, and 5.\nfunc get_odd_collatz(n: Int) -> [Int] {\n    var\
    \ result = [Int]()\n    var num = n\n    while num != 1 {\n        if num % 2\
    \ == 1 {\n            result.append(num)\n        }\n        num = num % 2 ==\
    \ 0 ? num / 2 : num * 3 + 1\n    }\n    result.append(1)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_odd_collatz(n: 14) == [1, 5, 7, 11, 13, 17])\n\
    assert(get_odd_collatz(n: 5) == [1, 5])\nassert(get_odd_collatz(n: 12) == [1,\
    \ 3, 5])\nassert(get_odd_collatz(n: 1) == [1])"
  status: Exception
  stderr: 'tmpl9rpwx9d/tmpl9rpwx9d.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac96034ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac960045b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac960045988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac9600447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl9rpwx9d                        0x000055db602354ea <unavailable> + 5354

    5    libc.so.6                          0x00002ac96053a460 __libc_start_main +
    245

    6    tmpl9rpwx9d                        0x000055db60235119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659824795
