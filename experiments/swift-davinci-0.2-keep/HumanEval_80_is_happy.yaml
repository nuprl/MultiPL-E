name: HumanEval_80_is_happy
language: swift
prompt: "\n/// You are given a string s.\n/// Your task is to check if the string\
  \ is happy or not.\n/// A string is happy if its length is at least 3 and every\
  \ 3 consecutive letters are distinct\n/// For example:\n/// is_happy(a) => False\n\
  /// is_happy(aa) => False\n/// is_happy(abcd) => True\n/// is_happy(aabb) => False\n\
  /// is_happy(adb) => True\n/// is_happy(xyy) => False\nfunc is_happy(s: String)\
  \ -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(is_happy(s: \"a\") == false)\nassert(is_happy(s:\
  \ \"aa\") == false)\nassert(is_happy(s: \"abcd\") == true)\nassert(is_happy(s: \"\
  aabb\") == false)\nassert(is_happy(s: \"adb\") == true)\nassert(is_happy(s: \"xyy\"\
  ) == false)\nassert(is_happy(s: \"iopaxpoi\") == true)\nassert(is_happy(s: \"iopaxioi\"\
  ) == false)"
completions: ["    if s.count < 3 {\n        return false\n    }\n    var result =\
    \ true\n    for i in 0..<s.count - 2 {\n        let start = s.index(s.startIndex,\
    \ offsetBy: i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n   \
    \     let range = start..<end\n        let sub = s[range]\n        let set = Set(sub)\n\
    \        if set.count != 3 {\n            result = false\n            break\n\
    \        }\n    }\n    return result", "    if s.count < 3 {\n        return false\n\
    \    }\n    var i = 0\n    while i < s.count - 2 {\n        let start = s.index(s.startIndex,\
    \ offsetBy: i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n   \
    \     let sub = s[start..<end]\n        if Set(sub).count != 3 {\n           \
    \ return false\n        }\n        i += 1\n    }\n    return true", "    guard\
    \ s.count >= 3 else { return false }\n    for i in 0..<s.count - 2 {\n       \
    \ let start = s.index(s.startIndex, offsetBy: i)\n        let end = s.index(s.startIndex,\
    \ offsetBy: i + 3)\n        let sub = s[start..<end]\n        let set = Set(sub)\n\
    \        if set.count != 3 {\n            return false\n        }\n    }\n   \
    \ return true", "    if s.count < 3 {\n        return false\n    }\n    for i\
    \ in 0..<s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n\
    \        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count != 3 {\n            return false\n        }\n    }\n\
    \    return true", '    return false', "    guard s.count >= 3 else { return false\
    \ }\n    for i in 0..<s.count - 2 {\n        let start = s.index(s.startIndex,\
    \ offsetBy: i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n   \
    \     let range = start..<end\n        let subString = s[range]\n        if Set(subString).count\
    \ != 3 {\n            return false\n        }\n    }\n    return true", "    if\
    \ s.count < 3 {\n        return false\n    }\n    var result = true\n    for i\
    \ in 0..<s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n\
    \        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let range =\
    \ start..<end\n        let subString = s[range]\n        let set = Set(subString)\n\
    \        if set.count != 3 {\n            result = false\n            break\n\
    \        }\n    }\n    return result", "    if s.count < 3 {\n        return false\n\
    \    }\n    var result = true\n    for i in 0..<s.count - 2 {\n        let start\
    \ = s.index(s.startIndex, offsetBy: i)\n        let end = s.index(s.startIndex,\
    \ offsetBy: i + 3)\n        let range = start..<end\n        let subString = s[range]\n\
    \        if Set(subString).count != 3 {\n            result = false\n        \
    \    break\n        }\n    }\n    return result", "    if s.count < 3 {\n    \
    \    return false\n    }\n    var result = true\n    var index = s.startIndex\n\
    \    while index < s.endIndex {\n        let start = s.index(index, offsetBy:\
    \ 0)\n        let end = s.index(index, offsetBy: 3)\n        let range = start..<end\n\
    \        let subString = s[range]\n        if Set(subString).count != 3 {\n  \
    \          result = false\n            break\n        }\n        index = s.index(index,\
    \ offsetBy: 3)\n    }\n    return result", "    guard s.count >= 3 else { return\
    \ false }\n    var result = true\n    for i in 0..<s.count - 2 {\n        let\
    \ start = s.index(s.startIndex, offsetBy: i)\n        let end = s.index(s.startIndex,\
    \ offsetBy: i + 3)\n        let sub = s[start..<end]\n        let set = Set(sub)\n\
    \        if set.count < 3 {\n            result = false\n            break\n \
    \       }\n    }\n    return result", "    if s.count < 3 {\n        return false\n\
    \    }\n    for i in 0..<s.count - 2 {\n        let start = s.index(s.startIndex,\
    \ offsetBy: i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n   \
    \     let subString = s[start..<end]\n        if Set(subString).count != 3 {\n\
    \            return false\n        }\n    }\n    return true", "    guard s.count\
    \ >= 3 else { return false }\n    for i in 0..<s.count - 2 {\n        let start\
    \ = s.index(s.startIndex, offsetBy: i)\n        let end = s.index(s.startIndex,\
    \ offsetBy: i + 3)\n        let sub = s[start..<end]\n        if Set(sub).count\
    \ != 3 {\n            return false\n        }\n    }\n    return true", "    if\
    \ s.count < 3 {\n        return false\n    }\n    for i in 0..<s.count - 2 {\n\
    \        let index1 = s.index(s.startIndex, offsetBy: i)\n        let index2 =\
    \ s.index(s.startIndex, offsetBy: i + 1)\n        let index3 = s.index(s.startIndex,\
    \ offsetBy: i + 2)\n        if s[index1] == s[index2] || s[index1] == s[index3]\
    \ || s[index2] == s[index3] {\n            return false\n        }\n    }\n  \
    \  return true", "    guard s.count >= 3 else { return false }\n    for i in 0..<s.count-2\
    \ {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end =\
    \ s.index(s.startIndex, offsetBy: i+3)\n        let range = start..<end\n    \
    \    let sub = s[range]\n        if Set(sub).count != 3 {\n            return\
    \ false\n        }\n    }\n    return true", "    guard s.count >= 3 else { return\
    \ false }\n    var previous = \"\"\n    for char in s {\n        if previous.count\
    \ == 2 {\n            if previous.contains(char) {\n                return false\n\
    \            }\n            previous = \"\"\n        }\n        previous.append(char)\n\
    \    }\n    return true", "    guard s.count >= 3 else { return false }\n    for\
    \ i in 0..<s.count - 2 {\n        let start = s.index(s.startIndex, offsetBy:\
    \ i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n        let sub\
    \ = s[start..<end]\n        if Set(sub).count < 3 {\n            return false\n\
    \        }\n    }\n    return true", "    guard s.count >= 3 else { return false\
    \ }\n    for i in 0..<s.count - 2 {\n        let start = s.index(s.startIndex,\
    \ offsetBy: i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n   \
    \     let range = start..<end\n        let sub = s[range]\n        if Set(sub).count\
    \ != 3 {\n            return false\n        }\n    }\n    return true", '    return
    false', "    guard s.count >= 3 else { return false }\n    for i in 0..<s.count\
    \ - 2 {\n        let start = s.index(s.startIndex, offsetBy: i)\n        let end\
    \ = s.index(s.startIndex, offsetBy: i + 3)\n        let sub = s[start..<end]\n\
    \        if Set(sub).count < 3 {\n            return false\n        }\n    }\n\
    \    return true", "    guard s.count >= 3 else { return false }\n    var result\
    \ = true\n    for i in 0..<s.count - 2 {\n        let start = s.index(s.startIndex,\
    \ offsetBy: i)\n        let end = s.index(s.startIndex, offsetBy: i + 3)\n   \
    \     let range = start..<end\n        let sub = s[range]\n        let set = Set(sub)\n\
    \        if set.count != 3 {\n            result = false\n            break\n\
    \        }\n    }\n    return result"]
stop_tokens:
- "\n}"
