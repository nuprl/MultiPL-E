name: HumanEval_6_parse_nested_parens
language: swift
prompt: "\n/// Input to this function is a string represented multiple groups for\
  \ nested parentheses separated by spaces.\n/// For each of the group, output the\
  \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
  \ of nesting while ((())) has three.\n/// >>> parse_nested_parens('(()()) ((()))\
  \ () ((())()())')\n/// [2, 3, 1, 3]\nfunc parse_nested_parens(paren_string: String)\
  \ -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(parse_nested_parens(paren_string: \"(()())\
  \ ((())) () ((())()())\") == [2, 3, 1, 3])\nassert(parse_nested_parens(paren_string:\
  \ \"() (()) ((())) (((())))\") == [1, 2, 3, 4])\nassert(parse_nested_parens(paren_string:\
  \ \"(()(())((())))\") == [4])"
completions: ["    var paren_groups = paren_string.components(separatedBy: \" \")\n\
    \    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups {\n\
    \        var max_nesting_level = 0\n        var current_nesting_level = 0\n  \
    \      for paren in paren_group {\n            if paren == \"(\" {\n         \
    \       current_nesting_level += 1\n            } else if paren == \")\" {\n \
    \               current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var paren_stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var depth = 0\n    var max_depths = [Int]()\n    for\
    \ char in paren_string {\n        if char == \"(\" {\n            paren_stack.push(char)\n\
    \            depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    return max_depths", "  \
    \  var max_nesting = 0\n    var current_nesting = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            current_nesting\
    \ += 1\n            if current_nesting > max_nesting {\n                max_nesting\
    \ = current_nesting\n            }\n        } else if char == \")\" {\n      \
    \      current_nesting -= 1\n        } else if char == \" \" {\n            result.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n        }\n   \
    \ }\n    result.append(max_nesting)\n    return result", "    var result = [Int]()\n\
    \    let paren_groups = paren_string.split(separator: \" \")\n    for paren_group\
    \ in paren_groups {\n        var stack = [Character]()\n        var max_depth\
    \ = 0\n        for char in paren_group {\n            if char == \"(\" {\n   \
    \             stack.append(char)\n                max_depth = max(max_depth, stack.count)\n\
    \            } else if char == \")\" {\n                stack.removeLast()\n \
    \           }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result", "    var max_nesting_level = 0\n    var nesting_level = 0\n    var\
    \ max_nesting_levels: [Int] = []\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            nesting_level += 1\n            if nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = nesting_level\n            }\n      \
    \  } else if char == \")\" {\n            nesting_level -= 1\n            if nesting_level\
    \ == 0 {\n                max_nesting_levels.append(max_nesting_level)\n     \
    \           max_nesting_level = 0\n            }\n        }\n    }\n    return\
    \ max_nesting_levels", "    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels", "    var result = [Int]()\n    var current_max = 0\n  \
    \  var current_count = 0\n    for char in paren_string {\n        if char == \"\
    (\" {\n            current_count += 1\n            if current_count > current_max\
    \ {\n                current_max = current_count\n            }\n        } else\
    \ if char == \")\" {\n            current_count -= 1\n        } else if char ==\
    \ \" \" {\n            result.append(current_max)\n            current_max = 0\n\
    \            current_count = 0\n        }\n    }\n    result.append(current_max)\n\
    \    return result", "    var result = [Int]()\n    var max_level = 0\n    var\
    \ level = 0\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        level += 1\n            max_level = max(max_level, level)\n        }\
    \ else if char == \")\" {\n            level -= 1\n        } else if char == \"\
    \ \" {\n            result.append(max_level)\n            max_level = 0\n    \
    \        level = 0\n        }\n    }\n    result.append(max_level)\n    return\
    \ result", "    var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var nesting_level = 0\n   \
    \     var max_nesting_level = 0\n        for char in group.characters {\n    \
    \        if char == \"(\" {\n                nesting_level += 1\n            }\
    \ else if char == \")\" {\n                nesting_level -= 1\n            }\n\
    \            if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var max_nesting_levels = [Int]()\n\
    \    var current_nesting_level = 0\n    var max_nesting_level = 0\n    var i =\
    \ 0\n    while i < paren_string.count {\n        let index = paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)\n        let paren = paren_string[index]\n        if paren == \"\
    (\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if paren == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if paren == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n        i += 1\n    }\n    max_nesting_levels.append(max_nesting_level)\n\
    \    return max_nesting_levels", "    var max_nesting_levels = [Int]()\n    var\
    \ current_nesting_level = 0\n    var max_nesting_level = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            current_nesting_level += 1\n    \
    \        if current_nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = current_nesting_level\n            }\n        } else if char == \")\" {\n\
    \            current_nesting_level -= 1\n        } else if char == \" \" {\n \
    \           max_nesting_levels.append(max_nesting_level)\n            max_nesting_level\
    \ = 0\n            current_nesting_level = 0\n        }\n    }\n    max_nesting_levels.append(max_nesting_level)\n\
    \    return max_nesting_levels", "    let groups = paren_string.split(separator:\
    \ \" \")\n    var max_nesting = [Int]()\n    for group in groups {\n        var\
    \ nesting = 0\n        var max_nesting_in_group = 0\n        for char in group\
    \ {\n            if char == \"(\" {\n                nesting += 1\n          \
    \  } else if char == \")\" {\n                nesting -= 1\n            }\n  \
    \          if nesting > max_nesting_in_group {\n                max_nesting_in_group\
    \ = nesting\n            }\n        }\n        max_nesting.append(max_nesting_in_group)\n\
    \    }\n    return max_nesting", "    var result = [Int]()\n    var i = 0\n  \
    \  var j = 0\n    var count = 0\n    var max_count = 0\n    while i < paren_string.count\
    \ {\n        let char = paren_string[paren_string.index(paren_string.startIndex,\
    \ offsetBy: i)]\n        if char == \"(\" {\n            count += 1\n        \
    \    max_count = max(max_count, count)\n        } else if char == \")\" {\n  \
    \          count -= 1\n        } else if char == \" \" {\n            result.append(max_count)\n\
    \            max_count = 0\n            count = 0\n            j = i + 1\n   \
    \     }\n        i += 1\n    }\n    result.append(max_count)\n    return result",
  "    var max_depth = 0\n    var depth = 0\n    var max_depths = [Int]()\n    for\
    \ char in paren_string {\n        if char == \"(\" {\n            depth += 1\n\
    \            if depth > max_depth {\n                max_depth = depth\n     \
    \       }\n        } else if char == \")\" {\n            depth -= 1\n       \
    \ } else if char == \" \" {\n            max_depths.append(max_depth)\n      \
    \      max_depth = 0\n            depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths", "    var paren_groups = paren_string.split(separator:\
    \ \" \")\n    var result = [Int]()\n    for paren_group in paren_groups {\n  \
    \      var max_depth = 0\n        var current_depth = 0\n        for char in paren_group\
    \ {\n            if char == \"(\" {\n                current_depth += 1\n    \
    \        } else if char == \")\" {\n                current_depth -= 1\n     \
    \       }\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result", "    var result = [Int]()\n    var current_level =\
    \ 0\n    var max_level = 0\n    for char in paren_string {\n        if char ==\
    \ \"(\" {\n            current_level += 1\n            max_level = max(max_level,\
    \ current_level)\n        } else if char == \")\" {\n            current_level\
    \ -= 1\n        } else if char == \" \" {\n            result.append(max_level)\n\
    \            max_level = 0\n            current_level = 0\n        }\n    }\n\
    \    result.append(max_level)\n    return result", "    var max_depth = 0\n  \
    \  var depth = 0\n    var max_depth_list = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            depth += 1\n            if depth\
    \ > max_depth {\n                max_depth = depth\n            }\n        } else\
    \ if char == \")\" {\n            depth -= 1\n        } else if char == \" \"\
    \ {\n            max_depth_list.append(max_depth)\n            max_depth = 0\n\
    \            depth = 0\n        }\n    }\n    max_depth_list.append(max_depth)\n\
    \    return max_depth_list", "    var result = [Int]()\n    var paren_stack =\
    \ Stack<Character>()\n    var max_depth = 0\n    for paren in paren_string {\n\
    \        if paren == \"(\" {\n            paren_stack.push(paren)\n          \
    \  max_depth = max(max_depth, paren_stack.count)\n        } else if paren == \"\
    )\" {\n            paren_stack.pop()\n        } else if paren == \" \" {\n   \
    \         result.append(max_depth)\n            max_depth = 0\n        }\n   \
    \ }\n    result.append(max_depth)\n    return result", "    var result = [Int]()\n\
    \    var current_level = 0\n    var max_level = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            current_level += 1\n            max_level\
    \ = max(max_level, current_level)\n        } else if char == \")\" {\n       \
    \     current_level -= 1\n        } else if char == \" \" {\n            result.append(max_level)\n\
    \            max_level = 0\n            current_level = 0\n        }\n    }\n\
    \    result.append(max_level)\n    return result", "    var result = [Int]()\n\
    \    let paren_groups = paren_string.components(separatedBy: \" \")\n    for group\
    \ in paren_groups {\n        var max_depth = 0\n        var current_depth = 0\n\
    \        for paren in group {\n            if paren == \"(\" {\n             \
    \   current_depth += 1\n            } else if paren == \")\" {\n             \
    \   current_depth -= 1\n            }\n            if current_depth > max_depth\
    \ {\n                max_depth = current_depth\n            }\n        }\n   \
    \     result.append(max_depth)\n    }\n    return result", "    var max_nesting_levels\
    \ = [Int]()\n    var current_nesting_level = 0\n    var max_nesting_level = 0\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            current_nesting_level\
    \ += 1\n            if current_nesting_level > max_nesting_level {\n         \
    \       max_nesting_level = current_nesting_level\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting_level -= 1\n        } else if\
    \ char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels", "    var result = [Int]()\n    var paren_stack = [Character]()\n\
    \    var max_depth = 0\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.append(char)\n      \
    \      current_depth += 1\n            if current_depth > max_depth {\n      \
    \          max_depth = current_depth\n            }\n        } else if char ==\
    \ \")\" {\n            if paren_stack.last == \"(\" {\n                paren_stack.removeLast()\n\
    \                current_depth -= 1\n            } else {\n                print(\"\
    Invalid input\")\n                return []\n            }\n        } else if\
    \ char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            current_depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var max_depth = 0\n    var depth = 0\n    var max_depths\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            depth\
    \ -= 1\n        } else if char == \" \" {\n            max_depths.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths", "    var max_nesting = 0\n    var nesting_level = 0\n\
    \    var results = [Int]()\n    for char in paren_string {\n        if char ==\
    \ \"(\" {\n            nesting_level += 1\n            if nesting_level > max_nesting\
    \ {\n                max_nesting = nesting_level\n            }\n        } else\
    \ if char == \")\" {\n            nesting_level -= 1\n        } else if char ==\
    \ \" \" {\n            results.append(max_nesting)\n            max_nesting =\
    \ 0\n            nesting_level = 0\n        }\n    }\n    results.append(max_nesting)\n\
    \    return results", "    var stack = Stack<Character>()\n    var max_depth =\
    \ 0\n    var depths = [Int]()\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.push(char)\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    if stack.isEmpty {\n                depths.append(0)\n                current_depth\
    \ = 0\n                max_depth = 0\n            } else {\n                stack.pop()\n\
    \                current_depth -= 1\n            }\n        } else if char ==\
    \ \" \" {\n            depths.append(max_depth)\n            current_depth = 0\n\
    \            max_depth = 0\n        }\n    }\n    depths.append(max_depth)\n \
    \   return depths", "    var paren_stack = Stack<Character>()\n    var max_nesting\
    \ = 0\n    var nesting_levels = [Int]()\n    for char in paren_string {\n    \
    \    if char == \"(\" {\n            paren_stack.push(char)\n            max_nesting\
    \ += 1\n        } else if char == \")\" {\n            paren_stack.pop()\n   \
    \         if paren_stack.isEmpty() {\n                nesting_levels.append(max_nesting)\n\
    \                max_nesting = 0\n            }\n        }\n    }\n    return\
    \ nesting_levels", "    var result = [Int]()\n    var current_level = 0\n    var\
    \ max_level = 0\n    for char in paren_string {\n        if char == \"(\" {\n\
    \            current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result", "    var stack = Stack<Character>()\n    var max_level =\
    \ 0\n    var level = 0\n    var max_levels = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.push(char)\n            level\
    \ += 1\n            if level > max_level {\n                max_level = level\n\
    \            }\n        } else if char == \")\" {\n            stack.pop()\n \
    \           level -= 1\n            if stack.isEmpty() {\n                max_levels.append(max_level)\n\
    \                max_level = 0\n                level = 0\n            }\n   \
    \     }\n    }\n    return max_levels", "    var max_nesting = 0\n    var current_nesting\
    \ = 0\n    var max_nesting_list = [Int]()\n    for char in paren_string {\n  \
    \      if char == \"(\" {\n            current_nesting += 1\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting\n           \
    \ }\n        } else if char == \")\" {\n            current_nesting -= 1\n   \
    \     } else if char == \" \" {\n            max_nesting_list.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n        }\n   \
    \ }\n    max_nesting_list.append(max_nesting)\n    return max_nesting_list", " \
    \   let paren_groups = paren_string.components(separatedBy: \" \")\n    var max_nesting_levels\
    \ = [Int]()\n    for paren_group in paren_groups {\n        var max_nesting_level\
    \ = 0\n        var current_nesting_level = 0\n        for paren in paren_group\
    \ {\n            if paren == \"(\" {\n                current_nesting_level +=\
    \ 1\n            } else if paren == \")\" {\n                current_nesting_level\
    \ -= 1\n            }\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level\n            }\n\
    \        }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels", "    var max_nesting_levels = [Int]()\n    let groups =\
    \ paren_string.components(separatedBy: \" \")\n    for group in groups {\n   \
    \     var nesting_level = 0\n        var max_nesting_level = 0\n        for char\
    \ in group {\n            if char == \"(\" {\n                nesting_level +=\
    \ 1\n            } else if char == \")\" {\n                nesting_level -= 1\n\
    \            }\n            if nesting_level > max_nesting_level {\n         \
    \       max_nesting_level = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var result = [Int]()\n    let paren_groups\
    \ = paren_string.components(separatedBy: \" \")\n    for paren_group in paren_groups\
    \ {\n        var paren_stack = Stack<Character>()\n        var max_nesting = 0\n\
    \        var current_nesting = 0\n        for paren in paren_group {\n       \
    \     if paren == \"(\" {\n                paren_stack.push(paren)\n         \
    \       current_nesting += 1\n                if current_nesting > max_nesting\
    \ {\n                    max_nesting = current_nesting\n                }\n  \
    \          } else if paren == \")\" {\n                if paren_stack.isEmpty()\
    \ {\n                    print(\"Error: Unmatched closing parenthesis\")\n   \
    \                 return []\n                } else {\n                    paren_stack.pop()\n\
    \                    current_nesting -= 1\n                }\n            }\n\
    \        }\n        if !paren_stack.isEmpty() {\n            print(\"Error: Unmatched\
    \ opening parenthesis\")\n            return []\n        }\n        result.append(max_nesting)\n\
    \    }\n    return result", "    var max_nesting_levels = [Int]()\n    let paren_groups\
    \ = paren_string.components(separatedBy: \" \")\n    for group in paren_groups\
    \ {\n        var max_level = 0\n        var current_level = 0\n        for char\
    \ in group {\n            if char == \"(\" {\n                current_level +=\
    \ 1\n            } else if char == \")\" {\n                current_level -= 1\n\
    \            }\n            if current_level > max_level {\n                max_level\
    \ = current_level\n            }\n        }\n        max_nesting_levels.append(max_level)\n\
    \    }\n    return max_nesting_levels", "    var result = [Int]()\n    let paren_groups\
    \ = paren_string.components(separatedBy: \" \")\n    for group in paren_groups\
    \ {\n        var max_depth = 0\n        var current_depth = 0\n        for char\
    \ in group {\n            if char == \"(\" {\n                current_depth +=\
    \ 1\n                if current_depth > max_depth {\n                    max_depth\
    \ = current_depth\n                }\n            } else if char == \")\" {\n\
    \                current_depth -= 1\n            }\n        }\n        result.append(max_depth)\n\
    \    }\n    return result", "    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var result = [Int]()\n    for paren_group in paren_groups {\n  \
    \      result.append(parse_nested_parens_helper(paren_group: paren_group))\n \
    \   }\n    return result", "    var result = [Int]()\n    var stack = Stack<Character>()\n\
    \    var max_level = 0\n    var current_level = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.push(char)\n            current_level\
    \ += 1\n            if current_level > max_level {\n                max_level\
    \ = current_level\n            }\n        } else if char == \")\" {\n        \
    \    stack.pop()\n            current_level -= 1\n        } else if char == \"\
    \ \" {\n            result.append(max_level)\n            max_level = 0\n    \
    \        current_level = 0\n        }\n    }\n    result.append(max_level)\n \
    \   return result", "    var result: [Int] = []\n    var current_level: Int =\
    \ 0\n    var max_level: Int = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == \")\" {\n            current_level -= 1\n        } else if char ==\
    \ \" \" {\n            result.append(max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result", "    var max_depth = 0\n    var depth = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        depth += 1\n            max_depth = max(max_depth, depth)\n        }\
    \ else if char == \")\" {\n            depth -= 1\n        } else if char == \"\
    \ \" {\n            result.append(max_depth)\n            max_depth = 0\n    \
    \        depth = 0\n        }\n    }\n    result.append(max_depth)\n    return\
    \ result", "    var max_depth = 0\n    var current_depth = 0\n    var result =\
    \ [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n      \
    \      current_depth += 1\n            max_depth = max(max_depth, current_depth)\n\
    \        } else if char == \")\" {\n            current_depth -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            current_depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var paren_stack = Stack<Character>()\n    var max_depth\
    \ = 0\n    var depth = 0\n    var result = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var stack = Stack<Character>()\n\
    \        var max_depth = 0\n        var current_depth = 0\n        for char in\
    \ group {\n            if char == \"(\" {\n                stack.push(char)\n\
    \                current_depth += 1\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth\n                }\n      \
    \      } else if char == \")\" {\n                if stack.isEmpty() {\n     \
    \               print(\"Error: mismatched parentheses\")\n                   \
    \ return [Int]()\n                }\n                stack.pop()\n           \
    \     current_depth -= 1\n            }\n        }\n        if !stack.isEmpty()\
    \ {\n            print(\"Error: mismatched parentheses\")\n            return\
    \ [Int]()\n        }\n        result.append(max_depth)\n    }\n    return result",
  "    var result = [Int]()\n    var current_level = 0\n    var max_level = 0\n  \
    \  for char in paren_string {\n        if char == \"(\" {\n            current_level\
    \ += 1\n            max_level = max(max_level, current_level)\n        } else\
    \ if char == \")\" {\n            current_level -= 1\n        } else if char ==\
    \ \" \" {\n            result.append(max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result", "    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_nesting = 0\n\
    \        var current_nesting = 0\n        for char in paren_group {\n        \
    \    if char == \"(\" {\n                current_nesting += 1\n            } else\
    \ if char == \")\" {\n                current_nesting -= 1\n            }\n  \
    \          if current_nesting > max_nesting {\n                max_nesting = current_nesting\n\
    \            }\n        }\n        result.append(max_nesting)\n    }\n    return\
    \ result", "    var max_nesting_levels = [Int]()\n    var current_level = 0\n\
    \    var max_level = 0\n    for char in paren_string {\n        if char == \"\
    (\" {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == \")\" {\n            current_level -= 1\n        } else if char ==\
    \ \" \" {\n            max_nesting_levels.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    max_nesting_levels.append(max_level)\n\
    \    return max_nesting_levels", "    var result: [Int] = []\n    var current_level\
    \ = 0\n    var max_level = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            current_level += 1\n            max_level = max(max_level,\
    \ current_level)\n        } else if char == \")\" {\n            current_level\
    \ -= 1\n        } else if char == \" \" {\n            result.append(max_level)\n\
    \            max_level = 0\n            current_level = 0\n        }\n    }\n\
    \    result.append(max_level)\n    return result", "    var max_nesting = 0\n\
    \    var nesting_level = 0\n    var result = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            nesting_level += 1\n            if\
    \ nesting_level > max_nesting {\n                max_nesting = nesting_level\n\
    \            }\n        } else if char == \")\" {\n            nesting_level -=\
    \ 1\n        } else if char == \" \" {\n            result.append(max_nesting)\n\
    \            max_nesting = 0\n            nesting_level = 0\n        }\n    }\n\
    \    result.append(max_nesting)\n    return result", "    var result = [Int]()\n\
    \    var paren_stack = Stack<Character>()\n    var max_depth = 0\n    var depth\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  paren_stack.push(char)\n            depth += 1\n            if depth > max_depth\
    \ {\n                max_depth = depth\n            }\n        } else if char\
    \ == \")\" {\n            if paren_stack.isEmpty() {\n                result.append(0)\n\
    \                depth = 0\n                max_depth = 0\n            } else\
    \ {\n                paren_stack.pop()\n                depth -= 1\n         \
    \   }\n        } else if char == \" \" {\n            if paren_stack.isEmpty()\
    \ {\n                result.append(max_depth)\n                depth = 0\n   \
    \             max_depth = 0\n            }\n        }\n    }\n    if !paren_stack.isEmpty()\
    \ {\n        result.append(0)\n    } else {\n        result.append(max_depth)\n\
    \    }\n    return result", "    var result = [Int]()\n    let paren_groups =\
    \ paren_string.components(separatedBy: \" \")\n    for group in paren_groups {\n\
    \        var max_depth = 0\n        var depth = 0\n        for char in group {\n\
    \            if char == \"(\" {\n                depth += 1\n            } else\
    \ if char == \")\" {\n                depth -= 1\n            }\n            if\
    \ depth > max_depth {\n                max_depth = depth\n            }\n    \
    \    }\n        result.append(max_depth)\n    }\n    return result", "    var\
    \ max_nesting = 0\n    var current_nesting = 0\n    var result = [Int]()\n   \
    \ for char in paren_string {\n        if char == \"(\" {\n            current_nesting\
    \ += 1\n            if current_nesting > max_nesting {\n                max_nesting\
    \ = current_nesting\n            }\n        } else if char == \")\" {\n      \
    \      current_nesting -= 1\n        } else if char == \" \" {\n            result.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n        }\n   \
    \ }\n    result.append(max_nesting)\n    return result", "    var max_nesting_level\
    \ = 0\n    var nesting_level = 0\n    var max_nesting_levels = [Int]()\n    for\
    \ char in paren_string {\n        if char == \"(\" {\n            nesting_level\
    \ += 1\n            if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level\n            }\n        } else if char == \")\" {\n        \
    \    nesting_level -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            nesting_level = 0\n        }\n\
    \    }\n    max_nesting_levels.append(max_nesting_level)\n    return max_nesting_levels",
  "    var max_nesting = 0\n    var nesting_level = 0\n    var max_nesting_list =\
    \ [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n      \
    \      nesting_level += 1\n            if nesting_level > max_nesting {\n    \
    \            max_nesting = nesting_level\n            }\n        } else if char\
    \ == \")\" {\n            nesting_level -= 1\n        } else if char == \" \"\
    \ {\n            max_nesting_list.append(max_nesting)\n            max_nesting\
    \ = 0\n            nesting_level = 0\n        }\n    }\n    max_nesting_list.append(max_nesting)\n\
    \    return max_nesting_list", "    var result = [Int]()\n    var current_max\
    \ = 0\n    var current_count = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            current_count += 1\n            if current_count > current_max\
    \ {\n                current_max = current_count\n            }\n        } else\
    \ if char == \")\" {\n            current_count -= 1\n        } else if char ==\
    \ \" \" {\n            result.append(current_max)\n            current_max = 0\n\
    \            current_count = 0\n        }\n    }\n    result.append(current_max)\n\
    \    return result", "    var paren_stack = Stack<Character>()\n    var max_depth\
    \ = 0\n    var depths = [Int]()\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            paren_stack.push(char)\n            max_depth += 1\n\
    \        } else if char == \")\" {\n            paren_stack.pop()\n          \
    \  if paren_stack.isEmpty() {\n                depths.append(max_depth)\n    \
    \            max_depth = 0\n            }\n        }\n    }\n    return depths",
  "    var max_depth = 0\n    var depth = 0\n    var max_depths = [Int]()\n    for\
    \ char in paren_string {\n        if char == \"(\" {\n            depth += 1\n\
    \            if depth > max_depth {\n                max_depth = depth\n     \
    \       }\n        } else if char == \")\" {\n            depth -= 1\n       \
    \ } else if char == \" \" {\n            max_depths.append(max_depth)\n      \
    \      max_depth = 0\n            depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths", "    var max_nesting_levels = [Int]()\n    let groups\
    \ = paren_string.split(separator: \" \")\n    for group in groups {\n        var\
    \ nesting_level = 0\n        var max_nesting_level = 0\n        for char in group\
    \ {\n            if char == \"(\" {\n                nesting_level += 1\n    \
    \        } else if char == \")\" {\n                nesting_level -= 1\n     \
    \       }\n            if nesting_level > max_nesting_level {\n              \
    \  max_nesting_level = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups\
    \ {\n        var max_nesting_level = 0\n        var current_nesting_level = 0\n\
    \        for paren in paren_group {\n            if paren == \"(\" {\n       \
    \         current_nesting_level += 1\n            } else if paren == \")\" {\n\
    \                current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var result = [Int]()\n    var stack\
    \ = Stack<Character>()\n    var max_depth = 0\n    var depth = 0\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            stack.push(char)\n\
    \            depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            if stack.isEmpty\
    \ {\n                print(\"Error: mismatched parentheses\")\n              \
    \  return []\n            }\n            stack.pop()\n            depth -= 1\n\
    \        } else if char == \" \" {\n            if stack.isEmpty {\n         \
    \       result.append(max_depth)\n                max_depth = 0\n            }\n\
    \        }\n    }\n    if !stack.isEmpty {\n        print(\"Error: mismatched\
    \ parentheses\")\n        return []\n    }\n    result.append(max_depth)\n   \
    \ return result", "    var result = [Int]()\n    var current_level = 0\n    var\
    \ max_level = 0\n    for char in paren_string {\n        if char == \"(\" {\n\
    \            current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result", "    var paren_stack = Stack<Character>()\n    var max_depth\
    \ = 0\n    var depth = 0\n    var result = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var paren_levels = [Int]()\n    var paren_level = 0\n\
    \    var paren_count = 0\n    for char in paren_string {\n        if char == \"\
    (\" {\n            paren_count += 1\n            paren_level += 1\n        } else\
    \ if char == \")\" {\n            paren_count -= 1\n            paren_level -=\
    \ 1\n        } else if char == \" \" {\n            paren_levels.append(paren_level)\n\
    \            paren_level = 0\n        }\n    }\n    paren_levels.append(paren_level)\n\
    \    return paren_levels", "    var max_nesting = 0\n    var current_nesting =\
    \ 0\n    var result: [Int] = []\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            current_nesting += 1\n            max_nesting = max(max_nesting,\
    \ current_nesting)\n        } else if char == \")\" {\n            current_nesting\
    \ -= 1\n        } else if char == \" \" {\n            result.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n        }\n   \
    \ }\n    result.append(max_nesting)\n    return result", "    let paren_groups\
    \ = paren_string.components(separatedBy: \" \")\n    var max_nesting = [Int]()\n\
    \    for paren_group in paren_groups {\n        var current_nesting = 0\n    \
    \    var max_nesting_in_group = 0\n        for paren in paren_group {\n      \
    \      if paren == \"(\" {\n                current_nesting += 1\n           \
    \ } else if paren == \")\" {\n                current_nesting -= 1\n         \
    \   }\n            if current_nesting > max_nesting_in_group {\n             \
    \   max_nesting_in_group = current_nesting\n            }\n        }\n       \
    \ max_nesting.append(max_nesting_in_group)\n    }\n    return max_nesting", " \
    \   var result = [Int]()\n    var paren_stack = Stack<Character>()\n    var max_depth\
    \ = 0\n    var curr_depth = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            paren_stack.push(char)\n            curr_depth += 1\n\
    \            if curr_depth > max_depth {\n                max_depth = curr_depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            curr_depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            curr_depth = 0\n        }\n    }\n   \
    \ result.append(max_depth)\n    return result", "    var paren_stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            paren_stack.push(char)\n\
    \            depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var paren_stack: [Character] = []\n    var max_depth:\
    \ Int = 0\n    var depths: [Int] = []\n    var depth: Int = 0\n    for char in\
    \ paren_string {\n        if char == \"(\" {\n            paren_stack.append(char)\n\
    \            depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.popLast()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            depths.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    depths.append(max_depth)\n\
    \    return depths", "    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups\
    \ {\n        var nesting_level = 0\n        var max_nesting_level = 0\n      \
    \  for char in paren_group.characters {\n            if char == \"(\" {\n    \
    \            nesting_level += 1\n            } else if char == \")\" {\n     \
    \           nesting_level -= 1\n            }\n            if nesting_level >\
    \ max_nesting_level {\n                max_nesting_level = nesting_level\n   \
    \         }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var max_nesting = 0\n    var nesting_levels\
    \ = [Int]()\n    var current_nesting = 0\n    for char in paren_string {\n   \
    \     if char == \"(\" {\n            current_nesting += 1\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting\n           \
    \ }\n        } else if char == \")\" {\n            current_nesting -= 1\n   \
    \     } else if char == \" \" {\n            nesting_levels.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n        }\n   \
    \ }\n    nesting_levels.append(max_nesting)\n    return nesting_levels", "   \
    \ var result: [Int] = []\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var current_depth = 0\n        for char in paren_group {\n           \
    \ if char == \"(\" {\n                current_depth += 1\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth\n             \
    \   }\n            } else if char == \")\" {\n                current_depth -=\
    \ 1\n            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result", "    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var depths = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depths.append(max_depth)\n            max_depth = 0\n           \
    \ depth = 0\n        }\n    }\n    return depths", "    var max_nesting = 0\n\
    \    var nesting_level = 0\n    var result = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            nesting_level += 1\n            if\
    \ nesting_level > max_nesting {\n                max_nesting = nesting_level\n\
    \            }\n        } else if char == \")\" {\n            nesting_level -=\
    \ 1\n        } else if char == \" \" {\n            result.append(max_nesting)\n\
    \            max_nesting = 0\n            nesting_level = 0\n        }\n    }\n\
    \    result.append(max_nesting)\n    return result", "    var max_nesting = 0\n\
    \    var nesting_level = 0\n    var max_nesting_list = [Int]()\n    for char in\
    \ paren_string {\n        if char == \"(\" {\n            nesting_level += 1\n\
    \            if nesting_level > max_nesting {\n                max_nesting = nesting_level\n\
    \            }\n        } else if char == \")\" {\n            nesting_level -=\
    \ 1\n        } else if char == \" \" {\n            max_nesting_list.append(max_nesting)\n\
    \            max_nesting = 0\n            nesting_level = 0\n        }\n    }\n\
    \    max_nesting_list.append(max_nesting)\n    return max_nesting_list", "   \
    \ var result = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var max_level = 0\n        var level\
    \ = 0\n        for char in group {\n            if char == \"(\" {\n         \
    \       level += 1\n            } else if char == \")\" {\n                level\
    \ -= 1\n            }\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        }\n        result.append(max_level)\n    }\n\
    \    return result", "    var result: [Int] = []\n    var max_depth = 0\n    var\
    \ current_depth = 0\n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            current_depth += 1\n            if current_depth > max_depth\
    \ {\n                max_depth = current_depth\n            }\n        } else\
    \ if char == \")\" {\n            current_depth -= 1\n        } else if char ==\
    \ \" \" {\n            result.append(max_depth)\n            max_depth = 0\n \
    \           current_depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var max_nesting = [Int]()\n    var current_nesting =\
    \ 0\n    var max_current_nesting = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting += 1\n            if current_nesting\
    \ > max_current_nesting {\n                max_current_nesting = current_nesting\n\
    \            }\n        } else if char == \")\" {\n            current_nesting\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting.append(max_current_nesting)\n\
    \            max_current_nesting = 0\n            current_nesting = 0\n      \
    \  }\n    }\n    max_nesting.append(max_current_nesting)\n    return max_nesting",
  "    var max_depth = 0\n    var current_depth = 0\n    var max_depth_list = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    current_depth -= 1\n        } else if char == \" \" {\n            max_depth_list.append(max_depth)\n\
    \            max_depth = 0\n            current_depth = 0\n        }\n    }\n\
    \    max_depth_list.append(max_depth)\n    return max_depth_list", "    var results:\
    \ [Int] = []\n    var paren_stack: [Character] = []\n    var max_depth: Int =\
    \ 0\n    var depth: Int = 0\n    for char in paren_string {\n        if char ==\
    \ \"(\" {\n            paren_stack.append(char)\n            depth += 1\n    \
    \        if depth > max_depth {\n                max_depth = depth\n         \
    \   }\n        } else if char == \")\" {\n            if paren_stack.count > 0\
    \ {\n                paren_stack.removeLast()\n                depth -= 1\n  \
    \          }\n        } else if char == \" \" {\n            if paren_stack.count\
    \ == 0 {\n                results.append(max_depth)\n                max_depth\
    \ = 0\n                depth = 0\n            }\n        }\n    }\n    if paren_stack.count\
    \ == 0 {\n        results.append(max_depth)\n    }\n    return results", "   \
    \ var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_nesting = 0\n\
    \        var current_nesting = 0\n        for char in paren_group {\n        \
    \    if char == \"(\" {\n                current_nesting += 1\n            } else\
    \ if char == \")\" {\n                current_nesting -= 1\n            }\n  \
    \          if current_nesting > max_nesting {\n                max_nesting = current_nesting\n\
    \            }\n        }\n        result.append(max_nesting)\n    }\n    return\
    \ result", "    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var result = [Int]()\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.push(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var max_nesting = 0\n    var current_nesting = 0\n \
    \   var result = [Int]()\n    for char in paren_string {\n        if char == \"\
    (\" {\n            current_nesting += 1\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result", "    var result = [Int]()\n    var current_level = 0\n  \
    \  var max_level = 0\n    for char in paren_string {\n        if char == \"(\"\
    \ {\n            current_level += 1\n            max_level = max(max_level, current_level)\n\
    \        } else if char == \")\" {\n            current_level -= 1\n        }\
    \ else if char == \" \" {\n            result.append(max_level)\n            max_level\
    \ = 0\n            current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result", "    var max_nesting = 0\n    var nesting_level = 0\n   \
    \ var result = [Int]()\n    for char in paren_string {\n        if char == \"\
    (\" {\n            nesting_level += 1\n            if nesting_level > max_nesting\
    \ {\n                max_nesting = nesting_level\n            }\n        } else\
    \ if char == \")\" {\n            nesting_level -= 1\n        } else if char ==\
    \ \" \" {\n            result.append(max_nesting)\n            max_nesting = 0\n\
    \            nesting_level = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result", "    var paren_levels = [Int]()\n    var paren_level = 0\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            paren_level\
    \ += 1\n        } else if char == \")\" {\n            paren_level -= 1\n    \
    \    } else if char == \" \" {\n            paren_levels.append(paren_level)\n\
    \            paren_level = 0\n        }\n    }\n    return paren_levels", "  \
    \  var result = [Int]()\n    var max_nesting = 0\n    var nesting = 0\n    for\
    \ char in paren_string {\n        if char == \"(\" {\n            nesting += 1\n\
    \            if nesting > max_nesting {\n                max_nesting = nesting\n\
    \            }\n        } else if char == \")\" {\n            nesting -= 1\n\
    \        } else if char == \" \" {\n            result.append(max_nesting)\n \
    \           max_nesting = 0\n            nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result", "    var result: [Int] = []\n    var max_depth = 0\n    var\
    \ depth = 0\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            depth\
    \ -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var current_group = \"\"\n    var groups\
    \ = paren_string.components(separatedBy: \" \")\n    for group in groups {\n \
    \       current_group = group\n        for char in current_group.characters {\n\
    \            if char == \"(\" {\n                current_nesting_level += 1\n\
    \            } else if char == \")\" {\n                current_nesting_level\
    \ -= 1\n            }\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level\n            }\n\
    \        }\n        max_nesting_levels.append(max_nesting_level)\n        current_nesting_level\
    \ = 0\n        max_nesting_level = 0\n    }\n    return max_nesting_levels", " \
    \   var max_nesting_levels = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var nesting_level = 0\n\
    \        var max_nesting_level = 0\n        for char in paren_group {\n      \
    \      if char == \"(\" {\n                nesting_level += 1\n            } else\
    \ if char == \")\" {\n                nesting_level -= 1\n            }\n    \
    \        if nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups\
    \ {\n        var max_nesting_level = 0\n        var current_nesting_level = 0\n\
    \        for paren in paren_group {\n            if paren == \"(\" {\n       \
    \         current_nesting_level += 1\n            } else if paren == \")\" {\n\
    \                current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for group in paren_groups\
    \ {\n        var nesting_level = 0\n        var max_nesting_level = 0\n      \
    \  for char in group.characters {\n            if char == \"(\" {\n          \
    \      nesting_level += 1\n            } else if char == \")\" {\n           \
    \     nesting_level -= 1\n            }\n            if nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = nesting_level\n            }\n      \
    \  }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels", "    var max_depth = 0\n    var depth = 0\n    var result\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        depth += 1\n            max_depth = max(max_depth, depth)\n        }\
    \ else if char == \")\" {\n            depth -= 1\n        } else if char == \"\
    \ \" {\n            result.append(max_depth)\n            max_depth = 0\n    \
    \        depth = 0\n        }\n    }\n    result.append(max_depth)\n    return\
    \ result", "    var result = [Int]()\n    var max_depth = 0\n    var current_depth\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_depth += 1\n            if current_depth > max_depth {\n          \
    \      max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            current_depth -= 1\n        } else if char == \" \" {\n   \
    \         result.append(max_depth)\n            max_depth = 0\n            current_depth\
    \ = 0\n        }\n    }\n    result.append(max_depth)\n    return result", " \
    \   var max_depth = 0\n    var depth = 0\n    var max_depth_list = [Int]()\n \
    \   for char in paren_string {\n        if char == \"(\" {\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            depth -= 1\n  \
    \      } else if char == \" \" {\n            max_depth_list.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    max_depth_list.append(max_depth)\n\
    \    return max_depth_list", "    var paren_stack = Stack<Character>()\n    var\
    \ max_depth = 0\n    var depths = [Int]()\n    var depth = 0\n    for paren in\
    \ paren_string {\n        if paren == \"(\" {\n            depth += 1\n      \
    \      max_depth = max(max_depth, depth)\n            paren_stack.push(paren)\n\
    \        } else if paren == \")\" {\n            depth -= 1\n            paren_stack.pop()\n\
    \            if paren_stack.isEmpty() {\n                depths.append(max_depth)\n\
    \                max_depth = 0\n            }\n        }\n    }\n    return depths",
  "    var result: [Int] = []\n    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var stack: [Character]\
    \ = []\n        var max_level = 0\n        var current_level = 0\n        for\
    \ char in paren_group.characters {\n            if char == \"(\" {\n         \
    \       current_level += 1\n                max_level = max(max_level, current_level)\n\
    \                stack.append(char)\n            } else if char == \")\" {\n \
    \               current_level -= 1\n                stack.popLast()\n        \
    \    }\n        }\n        result.append(max_level)\n    }\n    return result",
  "    var max_nesting = 0\n    var current_nesting = 0\n    var result = [Int]()\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            current_nesting\
    \ += 1\n            if current_nesting > max_nesting {\n                max_nesting\
    \ = current_nesting\n            }\n        } else if char == \")\" {\n      \
    \      current_nesting -= 1\n        } else if char == \" \" {\n            result.append(max_nesting)\n\
    \            max_nesting = 0\n            current_nesting = 0\n        }\n   \
    \ }\n    result.append(max_nesting)\n    return result", "    var max_nesting_levels\
    \ = [Int]()\n    let paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    for paren_group in paren_groups {\n        var max_nesting_level = 0\n\
    \        var current_nesting_level = 0\n        for char in paren_group {\n  \
    \          if char == \"(\" {\n                current_nesting_level += 1\n  \
    \          } else if char == \")\" {\n                current_nesting_level -=\
    \ 1\n            }\n            if current_nesting_level > max_nesting_level {\n\
    \                max_nesting_level = current_nesting_level\n            }\n  \
    \      }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels", "    var max_nesting = [Int]()\n    var current_nesting\
    \ = 0\n    var max_current_nesting = 0\n    for char in paren_string {\n     \
    \   if char == \"(\" {\n            current_nesting += 1\n            if current_nesting\
    \ > max_current_nesting {\n                max_current_nesting = current_nesting\n\
    \            }\n        } else if char == \")\" {\n            current_nesting\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting.append(max_current_nesting)\n\
    \            max_current_nesting = 0\n            current_nesting = 0\n      \
    \  }\n    }\n    max_nesting.append(max_current_nesting)\n    return max_nesting",
  "    var paren_stack = Stack<Character>()\n    var max_depth = 0\n    var depth\
    \ = 0\n    var max_depths = [Int]()\n    for char in paren_string {\n        if\
    \ char == \"(\" {\n            paren_stack.push(char)\n            depth += 1\n\
    \            if depth > max_depth {\n                max_depth = depth\n     \
    \       }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    return max_depths", "  \
    \  var max_nesting_levels = [Int]()\n    var current_nesting_level = 0\n    var\
    \ max_nesting_level = 0\n    for paren in paren_string {\n        if paren ==\
    \ \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if paren == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if paren == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    return max_nesting_levels", "    var result: [Int] = []\n\
    \    let paren_groups = paren_string.components(separatedBy: \" \")\n    for group\
    \ in paren_groups {\n        var max_depth = 0\n        var current_depth = 0\n\
    \        for char in group.characters {\n            if char == \"(\" {\n    \
    \            current_depth += 1\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth\n                }\n      \
    \      } else if char == \")\" {\n                current_depth -= 1\n       \
    \     }\n        }\n        result.append(max_depth)\n    }\n    return result",
  "    var max_nested_parens = [Int]()\n    var current_nested_parens = 0\n    var\
    \ max_current_nested_parens = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            current_nested_parens += 1\n            if current_nested_parens\
    \ > max_current_nested_parens {\n                max_current_nested_parens = current_nested_parens\n\
    \            }\n        } else if char == \")\" {\n            current_nested_parens\
    \ -= 1\n        } else if char == \" \" {\n            max_nested_parens.append(max_current_nested_parens)\n\
    \            max_current_nested_parens = 0\n            current_nested_parens\
    \ = 0\n        }\n    }\n    max_nested_parens.append(max_current_nested_parens)\n\
    \    return max_nested_parens", "    var max_depth = 0\n    var current_depth\
    \ = 0\n    var max_depths = [Int]()\n    for char in paren_string {\n        if\
    \ char == \"(\" {\n            current_depth += 1\n            if current_depth\
    \ > max_depth {\n                max_depth = current_depth\n            }\n  \
    \      } else if char == \")\" {\n            current_depth -= 1\n        } else\
    \ if char == \" \" {\n            max_depths.append(max_depth)\n            max_depth\
    \ = 0\n            current_depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths", "    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var stack = Stack<Character>()\n\
    \        var max_depth = 0\n        var depth = 0\n        for paren in paren_group\
    \ {\n            if paren == \"(\" {\n                stack.push(paren)\n    \
    \            depth += 1\n                if depth > max_depth {\n            \
    \        max_depth = depth\n                }\n            } else if paren ==\
    \ \")\" {\n                if stack.isEmpty() {\n                    print(\"\
    Invalid paren group: \\(paren_group)\")\n                    break\n         \
    \       }\n                stack.pop()\n                depth -= 1\n         \
    \   }\n        }\n        if !stack.isEmpty() {\n            print(\"Invalid paren\
    \ group: \\(paren_group)\")\n        }\n        result.append(max_depth)\n   \
    \ }\n    return result", "    var paren_levels = [Int]()\n    var paren_stack\
    \ = [Character]()\n    var current_level = 0\n    for char in paren_string {\n\
    \        if char == \"(\" {\n            paren_stack.append(char)\n          \
    \  current_level += 1\n        } else if char == \")\" {\n            paren_stack.removeLast()\n\
    \            current_level -= 1\n        } else if char == \" \" {\n         \
    \   paren_levels.append(current_level)\n        }\n    }\n    return paren_levels",
  "    var result = [Int]()\n    var paren_stack = Stack<Character>()\n    var max_depth\
    \ = 0\n    var current_depth = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            paren_stack.push(char)\n            current_depth +=\
    \ 1\n            if current_depth > max_depth {\n                max_depth = current_depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            current_depth -= 1\n        } else if char == \" \" {\n         \
    \   if paren_stack.isEmpty() {\n                result.append(max_depth)\n   \
    \             max_depth = 0\n                current_depth = 0\n            }\n\
    \        }\n    }\n    result.append(max_depth)\n    return result", "    var\
    \ max_nesting_levels = [Int]()\n    var current_nesting_level = 0\n    var max_nesting_level\
    \ = 0\n    for char in paren_string {\n        if char == \"(\" {\n          \
    \  current_nesting_level += 1\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level\n            }\n\
    \        } else if char == \")\" {\n            current_nesting_level -= 1\n \
    \       } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels", "    var max_depth = 0\n    var depth = 0\n    var depths\
    \ = [Int]()\n    for c in paren_string {\n        if c == \"(\" {\n          \
    \  depth += 1\n            if depth > max_depth {\n                max_depth =\
    \ depth\n            }\n        } else if c == \")\" {\n            depth -= 1\n\
    \        } else if c == \" \" {\n            depths.append(max_depth)\n      \
    \      max_depth = 0\n            depth = 0\n        }\n    }\n    return depths",
  "    var paren_stack = Stack<Character>()\n    var max_nesting = 0\n    var nesting_levels\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        paren_stack.push(char)\n            max_nesting += 1\n        } else\
    \ if char == \")\" {\n            paren_stack.pop()\n            if paren_stack.isEmpty()\
    \ {\n                nesting_levels.append(max_nesting)\n                max_nesting\
    \ = 0\n            }\n        }\n    }\n    return nesting_levels", "    var max_nesting_levels\
    \ = [Int]()\n    var current_nesting_level = 0\n    var max_nesting_level = 0\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            current_nesting_level\
    \ += 1\n            if current_nesting_level > max_nesting_level {\n         \
    \       max_nesting_level = current_nesting_level\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting_level -= 1\n        } else if\
    \ char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting = [Int]()\n    for paren_group in paren_groups {\n\
    \        var current_nesting = 0\n        var max_nesting_in_group = 0\n     \
    \   for char in paren_group.characters {\n            if char == \"(\" {\n   \
    \             current_nesting += 1\n            } else if char == \")\" {\n  \
    \              current_nesting -= 1\n            }\n            if current_nesting\
    \ > max_nesting_in_group {\n                max_nesting_in_group = current_nesting\n\
    \            }\n        }\n        max_nesting.append(max_nesting_in_group)\n\
    \    }\n    return max_nesting", "    var max_depth = 0\n    var depth = 0\n \
    \   var result = [Int]()\n    for char in paren_string {\n        if char == \"\
    (\" {\n            depth += 1\n            max_depth = max(max_depth, depth)\n\
    \        } else if char == \")\" {\n            depth -= 1\n        } else if\
    \ char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var paren_stack = Stack<Character>()\n    var max_depth\
    \ = 0\n    var depths = [Int]()\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    current_depth += 1\n            if current_depth > max_depth {\n        \
    \        max_depth = current_depth\n            }\n        } else if char == \"\
    )\" {\n            paren_stack.pop()\n            current_depth -= 1\n       \
    \ } else if char == \" \" {\n            depths.append(max_depth)\n          \
    \  max_depth = 0\n            current_depth = 0\n        }\n    }\n    depths.append(max_depth)\n\
    \    return depths", "    var paren_stack = Stack<Character>()\n    var max_depth\
    \ = 0\n    var depth = 0\n    var result = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var result = [Int]()\n    let groups = paren_string.split(separator:\
    \ \" \")\n    for group in groups {\n        var max_depth = 0\n        var depth\
    \ = 0\n        for char in group {\n            if char == \"(\" {\n         \
    \       depth += 1\n            } else if char == \")\" {\n                depth\
    \ -= 1\n            }\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        }\n        result.append(max_depth)\n    }\n\
    \    return result", "    var max_nesting_levels: [Int] = []\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels", "    var result: [Int] = []\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var stack: [Character] = []\n   \
    \     var max_depth = 0\n        for char in group {\n            if char == \"\
    (\" {\n                stack.append(char)\n                max_depth = max(max_depth,\
    \ stack.count)\n            } else if char == \")\" {\n                stack.popLast()\n\
    \            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result", "    var max_depth = 0\n    var current_depth = 0\n    var max_depth_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_depth += 1\n            if current_depth > max_depth {\n    \
    \            max_depth = current_depth\n            }\n        } else if char\
    \ == \")\" {\n            current_depth -= 1\n        } else if char == \" \"\
    \ {\n            max_depth_list.append(max_depth)\n            max_depth = 0\n\
    \            current_depth = 0\n        }\n    }\n    max_depth_list.append(max_depth)\n\
    \    return max_depth_list", "    var results: [Int] = []\n    var current_level\
    \ = 0\n    var max_level = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == \")\" {\n            current_level -= 1\n        } else if char ==\
    \ \" \" {\n            results.append(max_level)\n            max_level = 0\n\
    \            current_level = 0\n        }\n    }\n    results.append(max_level)\n\
    \    return results", "    var max_nesting = 0\n    var nesting_levels = [Int]()\n\
    \    var current_nesting = 0\n    for paren in paren_string {\n        if paren\
    \ == \"(\" {\n            current_nesting += 1\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting\n           \
    \ }\n        } else if paren == \")\" {\n            nesting_levels.append(current_nesting)\n\
    \            current_nesting -= 1\n        }\n    }\n    return nesting_levels",
  "    var paren_stack = Stack<Character>()\n    var max_depth = 0\n    var depth\
    \ = 0\n    var result = [Int]()\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            paren_stack.push(char)\n            depth += 1\n   \
    \         if depth > max_depth {\n                max_depth = depth\n        \
    \    }\n        } else if char == \")\" {\n            paren_stack.pop()\n   \
    \         depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var result = [Int]()\n    var stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.push(char)\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    stack.pop()\n            current_depth -= 1\n        } else if char == \"\
    \ \" {\n            result.append(max_depth)\n            max_depth = 0\n    \
    \        current_depth = 0\n        }\n    }\n    result.append(max_depth)\n \
    \   return result", "    var paren_stack = Stack<Character>()\n    var max_depth\
    \ = 0\n    var depths = [Int]()\n    var depth = 0\n    for paren in paren_string\
    \ {\n        if paren == \"(\" {\n            paren_stack.push(paren)\n      \
    \      depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if paren == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if paren == \" \" {\n            depths.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    depths.append(max_depth)\n\
    \    return depths", "    var max_nesting_levels = [Int]()\n    let paren_groups\
    \ = paren_string.components(separatedBy: \" \")\n    for paren_group in paren_groups\
    \ {\n        var nesting_level = 0\n        var max_nesting_level = 0\n      \
    \  for char in paren_group {\n            if char == \"(\" {\n               \
    \ nesting_level += 1\n            } else if char == \")\" {\n                nesting_level\
    \ -= 1\n            }\n            if nesting_level > max_nesting_level {\n  \
    \              max_nesting_level = nesting_level\n            }\n        }\n \
    \       max_nesting_levels.append(max_nesting_level)\n    }\n    return max_nesting_levels",
  "    var result = [Int]()\n    var max_depth = 0\n    var current_depth = 0\n  \
    \  for char in paren_string {\n        if char == \"(\" {\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    current_depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            current_depth = 0\n        }\n    }\n\
    \    result.append(max_depth)\n    return result", "    var result = [Int]()\n\
    \    let paren_groups = paren_string.components(separatedBy: \" \")\n    for group\
    \ in paren_groups {\n        var max_depth = 0\n        var depth = 0\n      \
    \  for char in group {\n            if char == \"(\" {\n                depth\
    \ += 1\n            } else if char == \")\" {\n                depth -= 1\n  \
    \          }\n            if depth > max_depth {\n                max_depth =\
    \ depth\n            }\n        }\n        result.append(max_depth)\n    }\n \
    \   return result", "    var max_nesting = 0\n    var current_nesting = 0\n  \
    \  var result = [Int]()\n    for char in paren_string {\n        if char == \"\
    (\" {\n            current_nesting += 1\n            if current_nesting > max_nesting\
    \ {\n                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            result.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result", "    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels", "    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var paren_stack = [Character]()\n\
    \        var max_depth = 0\n        var depth = 0\n        for paren in paren_group\
    \ {\n            if paren == \"(\" {\n                paren_stack.append(paren)\n\
    \                depth += 1\n                if depth > max_depth {\n        \
    \            max_depth = depth\n                }\n            } else if paren\
    \ == \")\" {\n                if paren_stack.count > 0 {\n                   \
    \ paren_stack.removeLast()\n                    depth -= 1\n                }\n\
    \            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result", "    var paren_stack = Stack<Character>()\n    var max_depth = 0\n\
    \    var depth = 0\n    var max_depths = [Int]()\n    for paren in paren_string\
    \ {\n        if paren == \"(\" {\n            paren_stack.push(paren)\n      \
    \      depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if paren == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    return max_depths", "  \
    \  var max_nesting_levels = [Int]()\n    var current_nesting_level = 0\n    var\
    \ max_nesting_level = 0\n    var paren_stack = Stack<Character>()\n    for c in\
    \ paren_string {\n        if c == \"(\" {\n            paren_stack.push(c)\n \
    \           current_nesting_level += 1\n            if current_nesting_level >\
    \ max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if c == \")\" {\n            paren_stack.pop()\n\
    \            current_nesting_level -= 1\n        } else if c == \" \" {\n    \
    \        max_nesting_levels.append(max_nesting_level)\n            max_nesting_level\
    \ = 0\n            current_nesting_level = 0\n        }\n    }\n    max_nesting_levels.append(max_nesting_level)\n\
    \    return max_nesting_levels", "    var max_nesting = 0\n    var current_nesting\
    \ = 0\n    var result = [Int]()\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            current_nesting += 1\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting\n           \
    \ }\n        } else if char == \")\" {\n            current_nesting -= 1\n   \
    \     } else if char == \" \" {\n            result.append(max_nesting)\n    \
    \        max_nesting = 0\n            current_nesting = 0\n        }\n    }\n\
    \    result.append(max_nesting)\n    return result", "    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting = [Int]()\n    for group in paren_groups {\n   \
    \     var current_nesting = 0\n        var max_nesting_in_group = 0\n        for\
    \ char in group.characters {\n            if char == \"(\" {\n               \
    \ current_nesting += 1\n            } else if char == \")\" {\n              \
    \  current_nesting -= 1\n            }\n            if current_nesting > max_nesting_in_group\
    \ {\n                max_nesting_in_group = current_nesting\n            }\n \
    \       }\n        max_nesting.append(max_nesting_in_group)\n    }\n    return\
    \ max_nesting", "    var result: [Int] = []\n    var current_level: Int = 0\n\
    \    var max_level: Int = 0\n    for char in paren_string {\n        if char ==\
    \ \"(\" {\n            current_level += 1\n            if current_level > max_level\
    \ {\n                max_level = current_level\n            }\n        } else\
    \ if char == \")\" {\n            current_level -= 1\n        } else if char ==\
    \ \" \" {\n            result.append(max_level)\n            max_level = 0\n \
    \           current_level = 0\n        }\n    }\n    result.append(max_level)\n\
    \    return result", "    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in paren_groups {\n        var count = 0\n        var\
    \ max_count = 0\n        for char in group {\n            if char == \"(\" {\n\
    \                count += 1\n            } else if char == \")\" {\n         \
    \       count -= 1\n            }\n            if count > max_count {\n      \
    \          max_count = count\n            }\n        }\n        result.append(max_count)\n\
    \    }\n    return result", "    var max_depth = 0\n    var depth = 0\n    var\
    \ max_depths = [Int]()\n    for char in paren_string {\n        if char == \"\
    (\" {\n            depth += 1\n            if depth > max_depth {\n          \
    \      max_depth = depth\n            }\n        } else if char == \")\" {\n \
    \           depth -= 1\n        } else if char == \" \" {\n            max_depths.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths", "    var max_nesting_levels = [Int]()\n    let groups\
    \ = paren_string.components(separatedBy: \" \")\n    for group in groups {\n \
    \       var max_nesting_level = 0\n        var nesting_level = 0\n        for\
    \ char in group {\n            if char == \"(\" {\n                nesting_level\
    \ += 1\n            } else if char == \")\" {\n                nesting_level -=\
    \ 1\n            }\n            if nesting_level > max_nesting_level {\n     \
    \           max_nesting_level = nesting_level\n            }\n        }\n    \
    \    max_nesting_levels.append(max_nesting_level)\n    }\n    return max_nesting_levels",
  "    var max_nesting = 0\n    var current_nesting = 0\n    var max_nesting_list\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        current_nesting += 1\n            if current_nesting > max_nesting {\n\
    \                max_nesting = current_nesting\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting -= 1\n        } else if char\
    \ == \" \" {\n            max_nesting_list.append(max_nesting)\n            max_nesting\
    \ = 0\n            current_nesting = 0\n        }\n    }\n    max_nesting_list.append(max_nesting)\n\
    \    return max_nesting_list", "    var max_nesting = 0\n    var current_nesting\
    \ = 0\n    var result = [Int]()\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            current_nesting += 1\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting\n           \
    \ }\n        } else if char == \")\" {\n            current_nesting -= 1\n   \
    \     } else if char == \" \" {\n            result.append(max_nesting)\n    \
    \        max_nesting = 0\n            current_nesting = 0\n        }\n    }\n\
    \    result.append(max_nesting)\n    return result", "    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for group in groups {\n  \
    \      var nesting_level = 0\n        var max_nesting_level = 0\n        for char\
    \ in group {\n            if char == \"(\" {\n                nesting_level +=\
    \ 1\n            } else if char == \")\" {\n                nesting_level -= 1\n\
    \            }\n            if nesting_level > max_nesting_level {\n         \
    \       max_nesting_level = nesting_level\n            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var result: [Int] = []\n    var current_level\
    \ = 0\n    var max_level = 0\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            current_level += 1\n            max_level = max(max_level,\
    \ current_level)\n        } else if char == \")\" {\n            current_level\
    \ -= 1\n        } else if char == \" \" {\n            result.append(max_level)\n\
    \            max_level = 0\n            current_level = 0\n        }\n    }\n\
    \    result.append(max_level)\n    return result", "    var max_nesting_levels\
    \ = [Int]()\n    let paren_groups = paren_string.split(separator: \" \")\n   \
    \ for group in paren_groups {\n        var nesting_level = 0\n        var max_nesting_level\
    \ = 0\n        for char in group {\n            if char == \"(\" {\n         \
    \       nesting_level += 1\n            } else if char == \")\" {\n          \
    \      nesting_level -= 1\n            }\n            if nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = nesting_level\n            }\n      \
    \  }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels", "    var result: [Int] = []\n    var paren_stack: [Character]\
    \ = []\n    var max_depth: Int = 0\n    var depth: Int = 0\n    for c in paren_string\
    \ {\n        if c == \"(\" {\n            paren_stack.append(c)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if c == \")\" {\n            if paren_stack.count\
    \ == 0 {\n                return []\n            }\n            paren_stack.removeLast()\n\
    \            depth -= 1\n        } else if c == \" \" {\n            if paren_stack.count\
    \ == 0 {\n                result.append(max_depth)\n                max_depth\
    \ = 0\n                depth = 0\n            }\n        }\n    }\n    if paren_stack.count\
    \ == 0 {\n        result.append(max_depth)\n    }\n    return result", "    var\
    \ results: [Int] = []\n    var open_parens: Int = 0\n    var max_open_parens:\
    \ Int = 0\n    for char in paren_string {\n        if char == \"(\" {\n      \
    \      open_parens += 1\n            if open_parens > max_open_parens {\n    \
    \            max_open_parens = open_parens\n            }\n        } else if char\
    \ == \")\" {\n            open_parens -= 1\n        } else if char == \" \" {\n\
    \            results.append(max_open_parens)\n            max_open_parens = 0\n\
    \            open_parens = 0\n        }\n    }\n    results.append(max_open_parens)\n\
    \    return results", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for group in paren_groups\
    \ {\n        var max_nesting_level = 0\n        var current_nesting_level = 0\n\
    \        for char in group.characters {\n            if char == \"(\" {\n    \
    \            current_nesting_level += 1\n            } else if char == \")\" {\n\
    \                current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var max_nesting_levels = [Int]()\n\
    \    var current_nesting_level = 0\n    var max_nesting_level = 0\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            current_nesting_level\
    \ += 1\n            if current_nesting_level > max_nesting_level {\n         \
    \       max_nesting_level = current_nesting_level\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting_level -= 1\n        } else if\
    \ char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels", "    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels", "    var depth_stack = Stack<Int>()\n    var max_depth\
    \ = 0\n    var depth_list = [Int]()\n    for char in paren_string {\n        if\
    \ char == \"(\" {\n            depth_stack.push(1)\n        } else if char ==\
    \ \")\" {\n            if depth_stack.isEmpty() {\n                depth_list.append(max_depth)\n\
    \                max_depth = 0\n            } else {\n                let depth\
    \ = depth_stack.pop()!\n                max_depth = max(max_depth, depth)\n  \
    \          }\n        }\n    }\n    return depth_list", "    var paren_stack =\
    \ Stack<Character>()\n    var max_depth = 0\n    var depth = 0\n    var max_depths\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        paren_stack.push(char)\n            depth += 1\n            if depth\
    \ > max_depth {\n                max_depth = depth\n            }\n        } else\
    \ if char == \")\" {\n            paren_stack.pop()\n            depth -= 1\n\
    \            if paren_stack.isEmpty() {\n                max_depths.append(max_depth)\n\
    \                max_depth = 0\n                depth = 0\n            }\n   \
    \     }\n    }\n    return max_depths", "    var result = [Int]()\n    let paren_groups\
    \ = paren_string.components(separatedBy: \" \")\n    for paren_group in paren_groups\
    \ {\n        var max_depth = 0\n        var depth = 0\n        for char in paren_group\
    \ {\n            if char == \"(\" {\n                depth += 1\n            }\
    \ else if char == \")\" {\n                depth -= 1\n            }\n       \
    \     if depth > max_depth {\n                max_depth = depth\n            }\n\
    \        }\n        result.append(max_depth)\n    }\n    return result", "   \
    \ var paren_stack = Stack<Character>()\n    var max_depth = 0\n    var depth =\
    \ 0\n    var depths = [Int]()\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            paren_stack.push(char)\n            depth += 1\n   \
    \         if depth > max_depth {\n                max_depth = depth\n        \
    \    }\n        } else if char == \")\" {\n            paren_stack.pop()\n   \
    \         depth -= 1\n            if paren_stack.isEmpty() {\n               \
    \ depths.append(max_depth)\n                max_depth = 0\n                depth\
    \ = 0\n            }\n        }\n    }\n    return depths", "    var result: [Int]\
    \ = []\n    let paren_groups = paren_string.components(separatedBy: \" \")\n \
    \   for group in paren_groups {\n        var max_depth = 0\n        var current_depth\
    \ = 0\n        for char in group.characters {\n            if char == \"(\" {\n\
    \                current_depth += 1\n                if current_depth > max_depth\
    \ {\n                    max_depth = current_depth\n                }\n      \
    \      } else if char == \")\" {\n                current_depth -= 1\n       \
    \     }\n        }\n        result.append(max_depth)\n    }\n    return result",
  "    var max_depth = 0\n    var depth = 0\n    var result = [Int]()\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            depth += 1\n    \
    \        max_depth = max(max_depth, depth)\n        } else if char == \")\" {\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups\
    \ {\n        var max_nesting_level = 0\n        var current_nesting_level = 0\n\
    \        for paren in paren_group {\n            if paren == \"(\" {\n       \
    \         current_nesting_level += 1\n            } else if paren == \")\" {\n\
    \                current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var paren_counts = [Int]()\n    for paren_group in paren_groups\
    \ {\n        var paren_stack = [Character]()\n        var max_count = 0\n    \
    \    var current_count = 0\n        for paren in paren_group {\n            if\
    \ paren == \"(\" {\n                paren_stack.append(paren)\n              \
    \  current_count += 1\n                if current_count > max_count {\n      \
    \              max_count = current_count\n                }\n            } else\
    \ if paren == \")\" {\n                if paren_stack.last == \"(\" {\n      \
    \              paren_stack.removeLast()\n                    current_count -=\
    \ 1\n                }\n            }\n        }\n        paren_counts.append(max_count)\n\
    \    }\n    return paren_counts", "    var max_nesting_levels = [Int]()\n    var\
    \ current_nesting_level = 0\n    var max_nesting_level = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            current_nesting_level += 1\n    \
    \        if current_nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = current_nesting_level\n            }\n        } else if char == \")\" {\n\
    \            current_nesting_level -= 1\n        } else if char == \" \" {\n \
    \           max_nesting_levels.append(max_nesting_level)\n            max_nesting_level\
    \ = 0\n            current_nesting_level = 0\n        }\n    }\n    max_nesting_levels.append(max_nesting_level)\n\
    \    return max_nesting_levels", "    var max_nesting_levels = [Int]()\n    let\
    \ paren_groups = paren_string.components(separatedBy: \" \")\n    for group in\
    \ paren_groups {\n        var nesting_level = 0\n        var max_nesting_level\
    \ = 0\n        for char in group.characters {\n            if char == \"(\" {\n\
    \                nesting_level += 1\n            } else if char == \")\" {\n \
    \               nesting_level -= 1\n            }\n            if nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = nesting_level\n \
    \           }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var paren_levels = [Int]()\n    var\
    \ paren_level = 0\n    var paren_group = \"\"\n    for char in paren_string {\n\
    \        if char == \" \" {\n            paren_levels.append(paren_level)\n  \
    \          paren_level = 0\n            paren_group = \"\"\n        } else {\n\
    \            paren_group.append(char)\n            if char == \"(\" {\n      \
    \          paren_level += 1\n            } else if char == \")\" {\n         \
    \       paren_level -= 1\n            }\n        }\n    }\n    paren_levels.append(paren_level)\n\
    \    return paren_levels", "    var paren_groups = paren_string.split(separator:\
    \ \" \")\n    var paren_levels = [Int]()\n    for paren_group in paren_groups\
    \ {\n        var paren_level = 0\n        var max_level = 0\n        for paren\
    \ in paren_group {\n            if paren == \"(\" {\n                paren_level\
    \ += 1\n            } else if paren == \")\" {\n                paren_level -=\
    \ 1\n            }\n            if paren_level > max_level {\n               \
    \ max_level = paren_level\n            }\n        }\n        paren_levels.append(max_level)\n\
    \    }\n    return paren_levels", "    var result: [Int] = []\n    var current_max:\
    \ Int = 0\n    var current_count: Int = 0\n    for char in paren_string {\n  \
    \      if char == \"(\" {\n            current_count += 1\n            if current_count\
    \ > current_max {\n                current_max = current_count\n            }\n\
    \        } else if char == \")\" {\n            current_count -= 1\n        }\
    \ else if char == \" \" {\n            result.append(current_max)\n          \
    \  current_max = 0\n            current_count = 0\n        }\n    }\n    result.append(current_max)\n\
    \    return result", "    var result: [Int] = []\n    var paren_stack: [Character]\
    \ = []\n    var max_depth: Int = 0\n    var current_depth: Int = 0\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            paren_stack.append(char)\n\
    \            current_depth += 1\n            if current_depth > max_depth {\n\
    \                max_depth = current_depth\n            }\n        } else if char\
    \ == \")\" {\n            if paren_stack.count > 0 {\n                paren_stack.removeLast()\n\
    \                current_depth -= 1\n            }\n        } else if char ==\
    \ \" \" {\n            if paren_stack.count == 0 {\n                result.append(max_depth)\n\
    \                max_depth = 0\n                current_depth = 0\n          \
    \  }\n        }\n    }\n    if paren_stack.count == 0 {\n        result.append(max_depth)\n\
    \    }\n    return result", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting = [Int]()\n    for paren_group in paren_groups {\n\
    \        var max_nesting_level = 0\n        var current_nesting_level = 0\n  \
    \      for char in paren_group.characters {\n            if char == \"(\" {\n\
    \                current_nesting_level += 1\n            } else if char == \"\
    )\" {\n                current_nesting_level -= 1\n            }\n           \
    \ if current_nesting_level > max_nesting_level {\n                max_nesting_level\
    \ = current_nesting_level\n            }\n        }\n        max_nesting.append(max_nesting_level)\n\
    \    }\n    return max_nesting", "    var max_nesting = 0\n    var nesting_level\
    \ = 0\n    var result = [Int]()\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            nesting_level += 1\n            if nesting_level > max_nesting\
    \ {\n                max_nesting = nesting_level\n            }\n        } else\
    \ if char == \")\" {\n            nesting_level -= 1\n        } else if char ==\
    \ \" \" {\n            result.append(max_nesting)\n            max_nesting = 0\n\
    \            nesting_level = 0\n        }\n    }\n    result.append(max_nesting)\n\
    \    return result", "    var result = [Int]()\n    var stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.push(char)\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    stack.pop()\n            current_depth -= 1\n        } else if char == \"\
    \ \" {\n            result.append(max_depth)\n            max_depth = 0\n    \
    \        current_depth = 0\n        }\n    }\n    result.append(max_depth)\n \
    \   return result", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for group in paren_groups\
    \ {\n        var current_nesting_level = 0\n        var max_nesting_level = 0\n\
    \        for char in group.characters {\n            if char == \"(\" {\n    \
    \            current_nesting_level += 1\n            } else if char == \")\" {\n\
    \                current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var max_depth = 0\n    var depth\
    \ = 0\n    var result = [Int]()\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            depth += 1\n            max_depth = max(max_depth, depth)\n\
    \        } else if char == \")\" {\n            depth -= 1\n        } else if\
    \ char == \" \" {\n            result.append(max_depth)\n            max_depth\
    \ = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    return max_nesting_levels", "    var paren_stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var depth = 0\n    var max_depths = [Int]()\n    for\
    \ paren in paren_string {\n        if paren == \"(\" {\n            paren_stack.push(paren)\n\
    \            depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if paren == \")\" {\n            if paren_stack.peek()\
    \ == \"(\" {\n                paren_stack.pop()\n                depth -= 1\n\
    \                max_depths.append(max_depth)\n                max_depth = 0\n\
    \            }\n        }\n    }\n    return max_depths", "    var max_nesting_levels\
    \ = [Int]()\n    var current_nesting_level = 0\n    var max_nesting_level = 0\n\
    \    for char in paren_string {\n        if char == \"(\" {\n            current_nesting_level\
    \ += 1\n            if current_nesting_level > max_nesting_level {\n         \
    \       max_nesting_level = current_nesting_level\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting_level -= 1\n        } else if\
    \ char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels", "    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        result.append(parse_nested_parens_helper(paren_string:\
    \ paren_group))\n    }\n    return result", "    var stack = Stack<Character>()\n\
    \    var max_depth = 0\n    var depths = [Int]()\n    var depth = 0\n    for c\
    \ in paren_string {\n        if c == \"(\" {\n            stack.push(c)\n    \
    \        depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if c == \")\" {\n            stack.pop()\n\
    \            depth -= 1\n            if stack.isEmpty() {\n                depths.append(max_depth)\n\
    \                max_depth = 0\n                depth = 0\n            }\n   \
    \     }\n    }\n    return depths", "    var max_nesting = 0\n    var current_nesting\
    \ = 0\n    var result = [Int]()\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            current_nesting += 1\n            if current_nesting\
    \ > max_nesting {\n                max_nesting = current_nesting\n           \
    \ }\n        } else if char == \")\" {\n            current_nesting -= 1\n   \
    \     } else if char == \" \" {\n            result.append(max_nesting)\n    \
    \        max_nesting = 0\n            current_nesting = 0\n        }\n    }\n\
    \    result.append(max_nesting)\n    return result", "    var max_nesting = 0\n\
    \    var nesting_level = 0\n    var max_nesting_list = [Int]()\n    for char in\
    \ paren_string {\n        if char == \"(\" {\n            nesting_level += 1\n\
    \            if nesting_level > max_nesting {\n                max_nesting = nesting_level\n\
    \            }\n        } else if char == \")\" {\n            nesting_level -=\
    \ 1\n        } else if char == \" \" {\n            max_nesting_list.append(max_nesting)\n\
    \            max_nesting = 0\n            nesting_level = 0\n        }\n    }\n\
    \    max_nesting_list.append(max_nesting)\n    return max_nesting_list", "   \
    \ var paren_stack = Stack<Character>()\n    var max_nesting = 0\n    var nesting_levels\
    \ = [Int]()\n    for paren in paren_string {\n        if paren == \"(\" {\n  \
    \          paren_stack.push(paren)\n            max_nesting += 1\n        } else\
    \ if paren == \")\" {\n            paren_stack.pop()\n            if paren_stack.isEmpty()\
    \ {\n                nesting_levels.append(max_nesting)\n                max_nesting\
    \ = 0\n            }\n        }\n    }\n    return nesting_levels", "    var max_nesting_levels\
    \ = [Int]()\n    let paren_groups = paren_string.components(separatedBy: \" \"\
    )\n    for paren_group in paren_groups {\n        var max_nesting_level = 0\n\
    \        var current_nesting_level = 0\n        for paren in paren_group {\n \
    \           if paren == \"(\" {\n                current_nesting_level += 1\n\
    \            } else if paren == \")\" {\n                current_nesting_level\
    \ -= 1\n            }\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level\n            }\n\
    \        }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels", "    var max_nesting_levels = [Int]()\n    let paren_groups\
    \ = paren_string.components(separatedBy: \" \")\n    for paren_group in paren_groups\
    \ {\n        var max_nesting_level = 0\n        var current_nesting_level = 0\n\
    \        for paren in paren_group {\n            if paren == \"(\" {\n       \
    \         current_nesting_level += 1\n            } else if paren == \")\" {\n\
    \                current_nesting_level -= 1\n            }\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var max_depth = 0\n    var depth\
    \ = 0\n    var depths = [Int]()\n    for char in paren_string {\n        if char\
    \ == \"(\" {\n            depth += 1\n            if depth > max_depth {\n   \
    \             max_depth = depth\n            }\n        } else if char == \")\"\
    \ {\n            depth -= 1\n        } else if char == \" \" {\n            depths.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    depths.append(max_depth)\n\
    \    return depths", "    var paren_stack: [Character] = []\n    var max_depth:\
    \ Int = 0\n    var depth_list: [Int] = []\n    var depth: Int = 0\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            paren_stack.append(char)\n\
    \            depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.popLast()\n\
    \            depth_list.append(depth)\n            depth -= 1\n        } else\
    \ if char == \" \" {\n            depth_list.append(depth)\n        }\n    }\n\
    \    return depth_list", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for group in paren_groups\
    \ {\n        var nesting_level = 0\n        var max_nesting_level = 0\n      \
    \  for char in group.characters {\n            if char == \"(\" {\n          \
    \      nesting_level += 1\n            } else if char == \")\" {\n           \
    \     nesting_level -= 1\n            }\n            if nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = nesting_level\n            }\n      \
    \  }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels", "    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    for char in paren_string {\n       \
    \ if char == \"(\" {\n            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            current_nesting_level\
    \ -= 1\n        } else if char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels", "    var max_depth = 0\n    var depth = 0\n    var max_depths\
    \ = [Int]()\n    for char in paren_string {\n        if char == \"(\" {\n    \
    \        depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            depth\
    \ -= 1\n        } else if char == \" \" {\n            max_depths.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    max_depths.append(max_depth)\n\
    \    return max_depths", "    var paren_stack = Stack<Character>()\n    var max_depth\
    \ = 0\n    var depth = 0\n    var max_depths = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n            if paren_stack.isEmpty() {\n            \
    \    max_depths.append(max_depth)\n                max_depth = 0\n           \
    \     depth = 0\n            }\n        }\n    }\n    return max_depths", "  \
    \  var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_nesting = 0\n\
    \        var current_nesting = 0\n        for char in paren_group {\n        \
    \    if char == \"(\" {\n                current_nesting += 1\n            } else\
    \ if char == \")\" {\n                current_nesting -= 1\n            }\n  \
    \          if current_nesting > max_nesting {\n                max_nesting = current_nesting\n\
    \            }\n        }\n        result.append(max_nesting)\n    }\n    return\
    \ result", "    var paren_counts = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var paren_count = 0\n\
    \        var max_paren_count = 0\n        for char in paren_group.characters {\n\
    \            if char == \"(\" {\n                paren_count += 1\n          \
    \  } else if char == \")\" {\n                paren_count -= 1\n            }\n\
    \            if paren_count > max_paren_count {\n                max_paren_count\
    \ = paren_count\n            }\n        }\n        paren_counts.append(max_paren_count)\n\
    \    }\n    return paren_counts", "    var result = [Int]()\n    let paren_groups\
    \ = paren_string.split(separator: \" \")\n    for paren_group in paren_groups\
    \ {\n        var count = 0\n        var max_count = 0\n        for char in paren_group\
    \ {\n            if char == \"(\" {\n                count += 1\n            }\
    \ else if char == \")\" {\n                count -= 1\n            }\n       \
    \     if count > max_count {\n                max_count = count\n            }\n\
    \        }\n        result.append(max_count)\n    }\n    return result", "   \
    \ var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var max_depth = 0\n \
    \       var current_depth = 0\n        for char in paren_group {\n           \
    \ if char == \"(\" {\n                current_depth += 1\n                if current_depth\
    \ > max_depth {\n                    max_depth = current_depth\n             \
    \   }\n            } else if char == \")\" {\n                current_depth -=\
    \ 1\n            }\n        }\n        result.append(max_depth)\n    }\n    return\
    \ result", "    var result = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var max_level = 0\n        var level\
    \ = 0\n        for char in group {\n            if char == \"(\" {\n         \
    \       level += 1\n            } else if char == \")\" {\n                level\
    \ -= 1\n            }\n            if level > max_level {\n                max_level\
    \ = level\n            }\n        }\n        result.append(max_level)\n    }\n\
    \    return result", "    var stack = Stack<Character>()\n    var max_depth =\
    \ 0\n    var depths = [Int]()\n    var current_depth = 0\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            stack.push(char)\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    stack.pop()\n            current_depth -= 1\n            if stack.isEmpty()\
    \ {\n                depths.append(max_depth)\n                max_depth = 0\n\
    \                current_depth = 0\n            }\n        }\n    }\n    return\
    \ depths", "    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var is_open_paren = false\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            is_open_paren = true\n\
    \            current_nesting_level += 1\n            if current_nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = current_nesting_level\n\
    \            }\n        } else if char == \")\" {\n            is_open_paren =\
    \ false\n            current_nesting_level -= 1\n        } else if char == \"\
    \ \" && !is_open_paren {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels", "    var result = [Int]()\n    let paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    for paren_group in paren_groups {\n        var stack = Stack<Character>()\n\
    \        var max_depth = 0\n        var depth = 0\n        for char in paren_group\
    \ {\n            if char == \"(\" {\n                stack.push(char)\n      \
    \          depth += 1\n                if depth > max_depth {\n              \
    \      max_depth = depth\n                }\n            } else if char == \"\
    )\" {\n                if stack.isEmpty() {\n                    break\n     \
    \           }\n                stack.pop()\n                depth -= 1\n     \
    \       }\n        }\n        result.append(max_depth)\n    }\n    return result",
  "    var paren_groups = paren_string.components(separatedBy: \" \")\n    var max_nesting_levels\
    \ = [Int]()\n    for paren_group in paren_groups {\n        var current_nesting_level\
    \ = 0\n        var max_nesting_level = 0\n        for paren in paren_group {\n\
    \            if paren == \"(\" {\n                current_nesting_level += 1\n\
    \            } else if paren == \")\" {\n                current_nesting_level\
    \ -= 1\n            }\n            if current_nesting_level > max_nesting_level\
    \ {\n                max_nesting_level = current_nesting_level\n            }\n\
    \        }\n        max_nesting_levels.append(max_nesting_level)\n    }\n    return\
    \ max_nesting_levels", "    var max_depth = 0\n    var depth = 0\n    var results\
    \ = [Int]()\n    for c in paren_string {\n        if c == \"(\" {\n          \
    \  depth += 1\n            if depth > max_depth {\n                max_depth =\
    \ depth\n            }\n        } else if c == \")\" {\n            depth -= 1\n\
    \        } else if c == \" \" {\n            results.append(max_depth)\n     \
    \       max_depth = 0\n            depth = 0\n        }\n    }\n    results.append(max_depth)\n\
    \    return results", "    var paren_stack = Stack<Character>()\n    var max_depth\
    \ = 0\n    var depth = 0\n    var result = [Int]()\n    for char in paren_string\
    \ {\n        if char == \"(\" {\n            paren_stack.push(char)\n        \
    \    depth += 1\n            if depth > max_depth {\n                max_depth\
    \ = depth\n            }\n        } else if char == \")\" {\n            paren_stack.pop()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var result = [Int]()\n    var paren_stack = [Character]()\n\
    \    var max_depth = 0\n    var depth = 0\n    for char in paren_string {\n  \
    \      if char == \"(\" {\n            paren_stack.append(char)\n            depth\
    \ += 1\n            if depth > max_depth {\n                max_depth = depth\n\
    \            }\n        } else if char == \")\" {\n            paren_stack.removeLast()\n\
    \            depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            depth = 0\n        }\n    }\n    result.append(max_depth)\n\
    \    return result", "    var max_nesting_levels = [Int]()\n    let groups = paren_string.components(separatedBy:\
    \ \" \")\n    for group in groups {\n        var nesting_level = 0\n        var\
    \ max_nesting_level = 0\n        for char in group {\n            if char == \"\
    (\" {\n                nesting_level += 1\n            } else if char == \")\"\
    \ {\n                nesting_level -= 1\n            }\n            if nesting_level\
    \ > max_nesting_level {\n                max_nesting_level = nesting_level\n \
    \           }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for group in paren_groups\
    \ {\n        var max_level = 0\n        var current_level = 0\n        for char\
    \ in group.characters {\n            if char == \"(\" {\n                current_level\
    \ += 1\n            } else if char == \")\" {\n                current_level -=\
    \ 1\n            }\n            if current_level > max_level {\n             \
    \   max_level = current_level\n            }\n        }\n        max_nesting_levels.append(max_level)\n\
    \    }\n    return max_nesting_levels", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting_levels = [Int]()\n    for paren_group in paren_groups\
    \ {\n        var nesting_level = 0\n        var max_nesting_level = 0\n      \
    \  for char in paren_group.characters {\n            if char == \"(\" {\n    \
    \            nesting_level += 1\n            } else if char == \")\" {\n     \
    \           nesting_level -= 1\n            }\n            if nesting_level >\
    \ max_nesting_level {\n                max_nesting_level = nesting_level\n   \
    \         }\n        }\n        max_nesting_levels.append(max_nesting_level)\n\
    \    }\n    return max_nesting_levels", "    var max_nesting_levels = [Int]()\n\
    \    var current_nesting_level = 0\n    var max_nesting_level = 0\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            current_nesting_level\
    \ += 1\n            if current_nesting_level > max_nesting_level {\n         \
    \       max_nesting_level = current_nesting_level\n            }\n        } else\
    \ if char == \")\" {\n            current_nesting_level -= 1\n        } else if\
    \ char == \" \" {\n            max_nesting_levels.append(max_nesting_level)\n\
    \            max_nesting_level = 0\n            current_nesting_level = 0\n  \
    \      }\n    }\n    max_nesting_levels.append(max_nesting_level)\n    return\
    \ max_nesting_levels", "    var max_nesting_levels = [Int]()\n    var current_nesting_level\
    \ = 0\n    var max_nesting_level = 0\n    var is_open_paren = false\n    for char\
    \ in paren_string {\n        if char == \"(\" {\n            current_nesting_level\
    \ += 1\n            is_open_paren = true\n        } else if char == \")\" {\n\
    \            if is_open_paren {\n                max_nesting_level = max(max_nesting_level,\
    \ current_nesting_level)\n            }\n            current_nesting_level -=\
    \ 1\n            is_open_paren = false\n        } else if char == \" \" {\n  \
    \          max_nesting_levels.append(max_nesting_level)\n            max_nesting_level\
    \ = 0\n            current_nesting_level = 0\n        }\n    }\n    return max_nesting_levels",
  "    var result = [Int]()\n    var max_depth = 0\n    var current_depth = 0\n  \
    \  for char in paren_string {\n        if char == \"(\" {\n            current_depth\
    \ += 1\n            if current_depth > max_depth {\n                max_depth\
    \ = current_depth\n            }\n        } else if char == \")\" {\n        \
    \    current_depth -= 1\n        } else if char == \" \" {\n            result.append(max_depth)\n\
    \            max_depth = 0\n            current_depth = 0\n        }\n    }\n\
    \    result.append(max_depth)\n    return result", "    var paren_levels: [Int]\
    \ = []\n    var paren_level = 0\n    var paren_stack: [Character] = []\n    var\
    \ paren_group = \"\"\n    for char in paren_string {\n        if char == \" \"\
    \ {\n            paren_levels.append(paren_level)\n            paren_level = 0\n\
    \            paren_stack = []\n            paren_group = \"\"\n        } else\
    \ {\n            paren_group.append(char)\n            if char == \"(\" {\n  \
    \              paren_stack.append(char)\n                paren_level = max(paren_level,\
    \ paren_stack.count)\n            } else if char == \")\" {\n                paren_stack.removeLast()\n\
    \            }\n        }\n    }\n    paren_levels.append(paren_level)\n    return\
    \ paren_levels", "    var paren_groups = paren_string.components(separatedBy:\
    \ \" \")\n    var max_nesting = [Int]()\n    for paren_group in paren_groups {\n\
    \        var current_nesting = 0\n        var max_nesting_so_far = 0\n       \
    \ for char in paren_group.characters {\n            if char == \"(\" {\n     \
    \           current_nesting += 1\n            } else if char == \")\" {\n    \
    \            current_nesting -= 1\n            }\n            if current_nesting\
    \ > max_nesting_so_far {\n                max_nesting_so_far = current_nesting\n\
    \            }\n        }\n        max_nesting.append(max_nesting_so_far)\n  \
    \  }\n    return max_nesting"]
stop_tokens:
- "\n}"
