{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "ts",
  "prompt": "//Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunction k_smallest_pairs(nums1: number[], nums2: number[], k: number): number[][] {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = k_smallest_pairs;\n  assert.deepEqual(candidate([1, 3, 7], [2, 4, 6], 2),[[1, 2], [1, 4]]);\n  assert.deepEqual(candidate([1, 3, 7], [2, 4, 6], 1),[[1, 2]]);\n  assert.deepEqual(candidate([1, 3, 7], [2, 4, 6], 7),[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]);\n}\n\ntest();",
  "stop_tokens": [
    "\nfunction ",
    "\n/*",
    "\n//",
    "\nclass"
  ],
  "completions": [
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n",
    "    const result: number[][] = [];\n    const queue: number[][] = [];\n    const visited: boolean[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        visited[i] = [];\n        for (let j = 0; j < nums2.length; j++) {\n            visited[i][j] = false;\n        }\n    }\n    queue.push([0, 0]);\n    visited[0][0] = true;\n    while (queue.length > 0 && result.length < k) {\n        const [i, j] = queue.shift()!;\n        result.push([nums1[i], nums2[j]]);\n        if (i + 1 < nums1.length && !visited[i + 1][j]) {\n            queue.push([i + 1, j]);\n            visited[i + 1][j] = true;\n        }\n        if (j + 1 < nums2.length && !visited[i][j + 1]) {\n            queue.push([i, j + 1]);\n            visited[i][j + 1] = true;\n        }\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let i: number = 0;\n    let j: number = 0;\n    let n: number = nums1.length;\n    let m: number = nums2.length;\n    if (n == 0 || m == 0 || k == 0) {\n        return result;\n    }\n    heap.push([nums1[0] + nums2[0], 0, 0]);\n    while (k > 0 && heap.length > 0) {\n        let [sum, i, j] = heap.shift();\n        result.push([nums1[i], nums2[j]]);\n        if (i + 1 < n && j + 1 < m) {\n            heap.push([nums1[i + 1] + nums2[j], i + 1, j]);\n            heap.push([nums1[i] + nums2[j + 1], i, j + 1]);\n        } else if (i + 1 < n) {\n            heap.push([nums1[i + 1] + nums2[j], i + 1, j]);\n        } else if (j + 1 < m) {\n            heap.push([nums1[i] + nums2[j + 1], i, j + 1]);\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let arr = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            arr.push([nums1[i], nums2[j]]);\n        }\n    }\n    arr.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return arr.slice(0, k);\n}\n",
    "  const pairs: number[][] = [];\n  for (let i = 0; i < nums1.length; i++) {\n    for (let j = 0; j < nums2.length; j++) {\n      pairs.push([nums1[i], nums2[j]]);\n    }\n  }\n  return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "  const pairs: number[][] = [];\n  for (let i = 0; i < nums1.length; i++) {\n    for (let j = 0; j < nums2.length; j++) {\n      pairs.push([nums1[i], nums2[j]]);\n    }\n  }\n  pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n  return pairs.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const pairs = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let tmp: number[] = [];\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                tmp = [i, index[i]];\n            }\n        }\n        result.push([nums1[tmp[0]], nums2[tmp[1]]]);\n        index[tmp[0]]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let t: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                t = i;\n                min_val = nums1[i] + nums2[index[i]];\n            }\n        }\n        if (t === -1) {\n            break;\n        }\n        result.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    let pq: MinHeap<number> = new MinHeap<number>();\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pq.push([nums1[i], nums2[j]]);\n        }\n    }\n    for (let i = 0; i < k; i++) {\n        if (pq.size() === 0) {\n            break;\n        }\n        result.push(pq.pop());\n    }\n    return result;\n}\n",
    "    let pairs = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let t = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                t = i;\n                min_val = nums1[i] + nums2[index[i]];\n            }\n        }\n        if (t == -1) {\n            break;\n        }\n        result.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) return result;\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && index.length > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < index.length; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) break;\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        if (index[min_index] === len2) {\n            index.splice(min_index, 1);\n        }\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    while (count < k && i < len1 && j < len2) {\n        let sum = nums1[i] + nums2[j];\n        if (sum < 0) {\n            i++;\n        } else if (sum > 0) {\n            j++;\n        } else {\n            result.push([nums1[i], nums2[j]]);\n            i++;\n            j++;\n            count++;\n        }\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0) return res;\n    let heap: number[][] = [];\n    let push = function (arr: number[]) {\n        heap.push(arr);\n        let i = heap.length - 1;\n        while (i > 0) {\n            let p = (i - 1) >> 1;\n            if (heap[i][0] + heap[i][1] < heap[p][0] + heap[p][1]) {\n                let t = heap[i];\n                heap[i] = heap[p];\n                heap[p] = t;\n                i = p;\n            } else {\n                break;\n            }\n        }\n    }\n    let pop = function () {\n        let res = heap[0];\n        let i = 0;\n        heap[0] = heap[heap.length - 1];\n        heap.pop();\n        while (i < heap.length) {\n            let l = (i << 1) + 1;\n            let r = (i << 1) + 2;\n            if (l >= heap.length) break;\n            let next = l;\n            if (r < heap.length && heap[r][0] + heap[r][1] < heap[l][0] + heap[l][1]) {\n                next = r;\n            }\n            if (heap[i][0] + heap[i][1] > heap[next][0] + heap[next][1]) {\n                let t = heap[i];\n                heap[i] = heap[next];\n                heap[next] = t;\n                i = next;\n            } else {\n                break;\n            }\n        }\n        return res;\n    }\n    for (let i = 0; i < len1; i++) {\n        push([nums1[i], nums2[0], 0]);\n    }\n    for (let i = 0; i < k && i < len1 * len2; i++) {\n        let cur = pop();",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let index: number[] = [];\n    let i: number = 0;\n    let j: number = 0;\n    let n: number = nums1.length;\n    let m: number = nums2.length;\n    if (n === 0 || m === 0) {\n        return result;\n    }\n    while (i < n && j < m && i + j < k) {\n        heap.push([nums1[i] + nums2[j], i, j]);\n        index.push(j);\n        if (j === m - 1) {\n            i++;\n            j = 0;\n        } else {\n            j++;\n        }\n    }\n    if (i + j < k && i < n) {\n        for (let p: number = i; p < n; p++) {\n            for (let q: number = 0; q < m && p + q < k; q++) {\n                heap.push([nums1[p] + nums2[q], p, q]);\n            }\n        }\n    }\n    heapify(heap, 0, heap.length);\n    while (heap.length > 0 && result.length < k) {\n        let t: number[] = heap.shift();\n        result.push([nums1[t[1]], nums2[t[2]]]);\n        if (index[t[1]] + 1 < m) {\n            heap.push([nums1[t[1]] + nums2[index[t[1]] + 1], t[1], index[t[1]] + 1]);\n            index[t[1]]++;\n            heapify(heap, 0, heap.length);\n        }\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let res: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            res.push([nums1[i], nums2[j]]);\n        }\n    }\n    res.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return res.slice(0, k);\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => {\n        return a[0] + a[1] - b[0] - b[1];\n    });\n    return pairs.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return [];\n    }\n    const result: number[][] = [];\n    const visited: boolean[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        visited[i] = [];\n        for (let j = 0; j < nums2.length; j++) {\n            visited[i][j] = false;\n        }\n    }\n    const queue: number[][] = [];\n    queue.push([0, 0, nums1[0] + nums2[0]]);\n    visited[0][0] = true;\n    while (k > 0 && queue.length > 0) {\n        const [i, j, sum] = queue.shift() as number[];\n        result.push([nums1[i], nums2[j]]);\n        k--;\n        if (i + 1 < nums1.length && !visited[i + 1][j]) {\n            queue.push([i + 1, j, nums1[i + 1] + nums2[j]]);\n            visited[i + 1][j] = true;\n        }\n        if (j + 1 < nums2.length && !visited[i][j + 1]) {\n            queue.push([i, j + 1, nums1[i] + nums2[j + 1]]);\n            visited[i][j + 1] = true;\n        }\n        queue.sort((a, b) => a[2] - b[2]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[] = [];\n    let heapSize: number = 0;\n    let heapify = (i: number) => {\n        let l = 2 * i + 1;\n        let r = 2 * i + 2;\n        let smallest = i;\n        if (l < heapSize && heap[l] < heap[smallest]) {\n            smallest = l;\n        }\n        if (r < heapSize && heap[r] < heap[smallest]) {\n            smallest = r;\n        }\n        if (smallest != i) {\n            let tmp = heap[i];\n            heap[i] = heap[smallest];\n            heap[smallest] = tmp;\n            heapify(smallest);\n        }\n    }\n    let buildHeap = () => {\n        heapSize = nums1.length;\n        for (let i = 0; i < nums1.length; i++) {\n            heap[i] = nums1[i] + nums2[0];\n        }\n        for (let i = Math.floor(nums1.length / 2); i >= 0; i--) {\n            heapify(i);\n        }\n    }\n    let extractMin = () => {\n        let min = heap[0];\n        heap[0] = heap[heapSize - 1];\n        heapSize--;\n        heapify(0);\n        return min;\n    }\n    let insert = (val: number) => {\n        heapSize++;\n        heap[heapSize - 1] = val;\n        let i = heapSize - 1;\n        while (i > 0 && heap[Math.floor((i - 1) / 2)] > heap[i]) {\n            let tmp = heap[i];\n            heap[i] = heap[Math.floor((i - 1) / 2)];\n            heap[Math.floor((i - 1) / 2)] = tmp;\n            i = Math.floor((i - 1) / 2);\n        }\n    }\n    let getNext = (nums: number[], val: number) => {\n        let i = 0;\n        while (i < num",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let visited: number[] = [];\n    let i: number = 0;\n    let j: number = 0;\n    let sum: number = 0;\n    let temp: number[] = [];\n    let temp_sum: number = 0;\n    let temp_i: number = 0;\n    let temp_j: number = 0;\n    let temp_index: number = 0;\n    let temp_visited: number = 0;\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    for (i = 0; i < nums1.length; i++) {\n        for (j = 0; j < nums2.length; j++) {\n            sum = nums1[i] + nums2[j];\n            heap.push([sum, i, j]);\n            visited.push(0);\n        }\n    }\n    heap.sort((a, b) => {\n        return a[0] - b[0];\n    });\n    for (i = 0; i < k; i++) {\n        if (heap.length === 0) {\n            break;\n        }\n        temp = heap.shift();\n        temp_sum = temp[0];\n        temp_i = temp[1];\n        temp_j = temp[2];\n        temp_index = temp_i * nums2.length + temp_j;\n        temp_visited = visited[temp_index];\n        if (temp_visited === 0) {\n            result.push([nums1[temp_i], nums2[temp_j]]);\n            visited[temp_index] = 1;\n            if (temp_j + 1 < nums2.length) {\n                heap.push([nums1[temp_i] + nums2[temp_j + 1], temp_i, temp_j + 1]);\n            }\n        }\n        heap.sort((a, b) => {\n            return a[0] - b[0];\n        });\n    }\n    return result;\n}\n\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n    let minHeap = new MinHeap();\n    for (let i = 0; i < nums1.length; i++) {\n        minHeap.add(nums1[i] + nums2[0], [nums1[i], nums2[0]]);\n    }\n    for (let i = 0; i < k && !minHeap.isEmpty(); i++) {\n        let pair = minHeap.poll();\n        result.push(pair.value);\n        let last = pair.value[1];\n        if (last < nums2[nums2.length - 1]) {\n            let index = nums2.indexOf(last);\n            minHeap.add(pair.value[0] + nums2[index + 1], [pair.value[0], nums2[index + 1]]);\n        }\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    const index = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let i = 0;\n    let j = 0;\n    while (i < len1 && j < len2 && result.length < k) {\n        if (nums1[i] < nums2[j]) {\n            result.push([nums1[i], nums2[j]]);\n            i++;\n        } else {\n            result.push([nums1[i], nums2[j]]);\n            j++;\n        }\n    }\n    return result;\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize: number = 0;\n    let i: number = 0;\n    let j: number = 0;\n\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n\n    while (i < nums1.length && j < nums2.length) {\n        heap.push([nums1[i], nums2[j]]);\n        heapSize++;\n        i++;\n        j++;\n    }\n\n    while (i < nums1.length) {\n        heap.push([nums1[i], nums2[0]]);\n        heapSize++;\n        i++;\n    }\n\n    while (j < nums2.length) {\n        heap.push([nums1[0], nums2[j]]);\n        heapSize++;\n        j++;\n    }\n\n    heap = build_min_heap(heap, heapSize);\n\n    while (k > 0 && heapSize > 0) {\n        result.push(heap[0]);\n        heap[0] = heap[heapSize - 1];\n        heapSize--;\n        heap = min_heapify(heap, 0, heapSize);\n        k--;\n    }\n\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let res: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0 && res.length < len1 * len2) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    const result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    const queue: number[][] = [];\n    for (let i = 0; i < nums1.length && i < k; i++) {\n        queue.push([nums1[i], nums2[0], 0]);\n    }\n    while (k-- > 0 && queue.length > 0) {\n        const [n1, n2, idx] = queue.shift()!;\n        result.push([n1, n2]);\n        if (idx === nums2.length - 1) {\n            continue;\n        }\n        queue.push([n1, nums2[idx + 1], idx + 1]);\n        queue.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 * len2 === 0) return result;\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    for (let i = 0; i < k && i < len1 * len2; i++) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let j = 0; j < len1; j++) {\n            if (index[j] < len2 && nums1[j] + nums2[index[j]] < min_val) {\n                min_val = nums1[j] + nums2[index[j]];\n                min_index = j;\n            }\n        }\n        if (min_index === -1) break;\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let pq: PriorityQueue<number> = new PriorityQueue<number>();\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pq.enqueue(nums1[i] + nums2[j]);\n        }\n    }\n    for (let i = 0; i < k; i++) {\n        result.push(pq.dequeue());\n    }\n    return result;\n}\n",
    "    const res: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return res;\n    }\n    const pq: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        pq.push([nums1[i], nums2[0], 0]);\n    }\n    pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    while (res.length < k && pq.length > 0) {\n        const [n1, n2, index] = pq.shift();\n        res.push([n1, n2]);\n        if (index === nums2.length - 1) {\n            continue;\n        }\n        pq.push([n1, nums2[index + 1], index + 1]);\n        pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    }\n    return res;\n}\n",
    "    if (nums1.length === 0 || nums2.length === 0) {\n        return [];\n    }\n    const result: number[][] = [];\n    const queue: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        queue.push([nums1[i], nums2[0], 0]);\n    }\n    while (k > 0 && queue.length > 0) {\n        const [x, y, z] = queue.shift() as number[];\n        result.push([x, y]);\n        if (z < nums2.length - 1) {\n            queue.push([x, nums2[z + 1], z + 1]);\n        }\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let length1: number = nums1.length;\n    let length2: number = nums2.length;\n    let index: number[] = Array(length1).fill(0);\n    while (k > 0 && result.length < length1 * length2) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < length1; i++) {\n            if (index[i] < length2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    while (count < k && i < len1 && j < len2) {\n        if (nums1[i] < nums2[j]) {\n            result.push([nums1[i], nums2[j]]);\n            i++;\n        } else {\n            result.push([nums1[i], nums2[j]]);\n            j++;\n        }\n        count++;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    for (let i = 0; i < k; i++) {\n        let min = Number.MAX_VALUE;\n        let t = -1;\n        for (let j = 0; j < len1; j++) {\n            if (index[j] < len2 && nums1[j] + nums2[index[j]] < min) {\n                t = j;\n                min = nums1[j] + nums2[index[j]];\n            }\n        }\n        if (t == -1) {\n            break;\n        }\n        result.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) return result;\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) continue;\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) break;\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    let heap: number[][] = [];\n    let visited: boolean[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        visited[i] = [];\n        for (let j = 0; j < nums2.length; j++) {\n            visited[i][j] = false;\n        }\n    }\n    heap.push([nums1[0] + nums2[0], 0, 0]);\n    visited[0][0] = true;\n    while (k > 0 && heap.length > 0) {\n        let pair: number[] = heap.shift();\n        result.push([nums1[pair[1]], nums2[pair[2]]]);\n        k--;\n        if (pair[1] + 1 < nums1.length && !visited[pair[1] + 1][pair[2]]) {\n            heap.push([nums1[pair[1] + 1] + nums2[pair[2]], pair[1] + 1, pair[2]]);\n            visited[pair[1] + 1][pair[2]] = true;\n        }\n        if (pair[2] + 1 < nums2.length && !visited[pair[1]][pair[2] + 1]) {\n            heap.push([nums1[pair[1]] + nums2[pair[2] + 1], pair[1], pair[2] + 1]);\n            visited[pair[1]][pair[2] + 1] = true;\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    const index = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    nums1.forEach(n1 => {\n        nums2.forEach(n2 => {\n            pairs.push([n1, n2]);\n        });\n    });\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            res.push([nums1[i], nums2[j]]);\n        }\n    }\n    res.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return res.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => {\n        return a[0] + a[1] - b[0] - b[1];\n    });\n    return result.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 * len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_pair = [-1, -1];\n        for (let n = 0; n < len1; n++) {\n            if (index[n] >= len2) {\n                continue;\n            }\n            let sum = nums1[n] + nums2[index[n]];\n            if (sum < min_val) {\n                min_val = sum;\n                min_pair = [n, index[n]];\n            }\n        }\n        if (min_pair[0] !== -1 && min_pair[1] !== -1) {\n            result.push([nums1[min_pair[0]], nums2[min_pair[1]]]);\n            index[min_pair[0]]++;\n            k--;\n        }\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let index1 = 0;\n    let index2 = 0;\n    let count = 0;\n    while (index1 < len1 && index2 < len2 && count < k) {\n        let sum = nums1[index1] + nums2[index2];\n        if (result.length === 0) {\n            result.push([nums1[index1], nums2[index2]]);\n            count++;\n        } else {\n            let i = 0;\n            while (i < result.length && result[i][0] + result[i][1] <= sum) {\n                i++;\n            }\n            result.splice(i, 0, [nums1[index1], nums2[index2]]);\n            count++;\n        }\n        if (index2 < len2 - 1 && (index1 === len1 - 1 || nums2[index2 + 1] < nums1[index1 + 1])) {\n            index2++;\n        } else {\n            index1++;\n        }\n    }\n    return result.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let i = 0;\n    let j = 0;\n    while (i < nums1.length && j < nums2.length && result.length < k) {\n        result.push([nums1[i], nums2[j]]);\n        if (i === nums1.length - 1) {\n            j++;\n        } else if (j === 0 || nums1[i + 1] < nums2[j - 1]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    let heap: number[][] = [];\n    let visited: boolean[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        visited[i] = [];\n        for (let j = 0; j < nums2.length; j++) {\n            visited[i][j] = false;\n        }\n    }\n    heap.push([nums1[0] + nums2[0], 0, 0]);\n    visited[0][0] = true;\n    while (k > 0 && heap.length > 0) {\n        let [sum, i, j] = heap.shift();\n        result.push([nums1[i], nums2[j]]);\n        k--;\n        if (i + 1 < nums1.length && !visited[i + 1][j]) {\n            heap.push([nums1[i + 1] + nums2[j], i + 1, j]);\n            visited[i + 1][j] = true;\n        }\n        if (j + 1 < nums2.length && !visited[i][j + 1]) {\n            heap.push([nums1[i] + nums2[j + 1], i, j + 1]);\n            visited[i][j + 1] = true;\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let i: number = 0;\n    let j: number = 0;\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    heap.push([nums1[0] + nums2[0], 0, 0]);\n    while (k > 0 && i < len1 && j < len2) {\n        let [sum, x, y] = heap.shift();\n        result.push([nums1[x], nums2[y]]);\n        if (y === 0 && x + 1 < len1) {\n            heap.push([nums1[x + 1] + nums2[y], x + 1, y]);\n        }\n        if (y + 1 < len2) {\n            heap.push([nums1[x] + nums2[y + 1], x, y + 1]);\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n    let heap: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        heap.push([nums1[i] + nums2[0], i, 0]);\n    }\n    heap = heap.sort((a, b) => a[0] - b[0]);\n    while (k > 0 && heap.length > 0) {\n        let [sum, i, j] = heap.shift();\n        result.push([nums1[i], nums2[j]]);\n        if (j + 1 < nums2.length) {\n            heap.push([nums1[i] + nums2[j + 1], i, j + 1]);\n        }\n        heap = heap.sort((a, b) => a[0] - b[0]);\n        k--;\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    let i = 0;\n    let j = 0;\n    while (i < nums1.length && j < nums2.length && pairs.length < k) {\n        pairs.push([nums1[i], nums2[j]]);\n        if (i === nums1.length - 1) {\n            j++;\n        } else if (j === nums2.length - 1) {\n            i++;\n        } else {\n            if (nums1[i + 1] < nums2[j + 1]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n    }\n    return pairs;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) return result;\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) break;\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let i = 0;\n    let j = 0;\n    while (i < len1 && j < len2 && k > 0) {\n        let sum = nums1[i] + nums2[j];\n        if (res.length === 0) {\n            res.push([nums1[i], nums2[j]]);\n        } else {\n            let len = res.length;\n            let m = 0;\n            while (m < len) {\n                if (sum < res[m][0] + res[m][1]) {\n                    break;\n                }\n                m++;\n            }\n            res.splice(m, 0, [nums1[i], nums2[j]]);\n        }\n        if (i === len1 - 1) {\n            j++;\n        } else if (j === len2 - 1) {\n            i++;\n        } else {\n            if (nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n    let minHeap: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        minHeap.push([nums1[i] + nums2[0], i, 0]);\n    }\n    heapify(minHeap);\n    for (let i = 0; i < k && minHeap.length > 0; i++) {\n        let [sum, i1, i2] = minHeap.shift();\n        result.push([nums1[i1], nums2[i2]]);\n        if (i2 + 1 < nums2.length) {\n            minHeap.push([nums1[i1] + nums2[i2 + 1], i1, i2 + 1]);\n            heapify(minHeap);\n        }\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 * len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index.push(0);\n    }\n    for (let i: number = 0; i < k && i < len1 * len2; i++) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let j: number = 0; j < len1; j++) {\n            if (index[j] < len2 && nums1[j] + nums2[index[j]] < min_val) {\n                min_val = nums1[j] + nums2[index[j]];\n                min_index = j;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index1: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index1.push(0);\n    }\n    let index2: number[] = [];\n    for (let i = 0; i < len2; i++) {\n        index2.push(0);\n    }\n    for (let i = 0; i < k; i++) {\n        let min = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let j = 0; j < len1; j++) {\n            if (index1[j] >= len2) {\n                continue;\n            }\n            if (nums1[j] + nums2[index1[j]] < min) {\n                min = nums1[j] + nums2[index1[j]];\n                min_index = j;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index1[min_index]]]);\n        index1[min_index]++;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let min_val = Infinity;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let res: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return res;\n    }\n    let heap: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        heap.push([nums1[i] + nums2[0], i, 0]);\n    }\n    heap.sort((a, b) => a[0] - b[0]);\n    for (let i = 0; i < k && i < nums1.length * nums2.length; i++) {\n        let [sum, i1, i2] = heap.shift();\n        res.push([nums1[i1], nums2[i2]]);\n        if (i2 + 1 < nums2.length) {\n            heap.push([nums1[i1] + nums2[i2 + 1], i1, i2 + 1]);\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n    }\n    return res;\n}\n",
    "  const pairs = [];\n  for (let i = 0; i < nums1.length; i++) {\n    for (let j = 0; j < nums2.length; j++) {\n      pairs.push([nums1[i], nums2[j]]);\n    }\n  }\n  pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n  return pairs.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => {\n        return a[0] + a[1] - b[0] - b[1];\n    });\n    return pairs.slice(0, k);\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    const minHeap = new MinHeap();\n    for (let i = 0; i < len1; i++) {\n        minHeap.insert(nums1[i] + nums2[0], [nums1[i], nums2[0]]);\n    }\n    for (let i = 0; i < k && !minHeap.isEmpty(); i++) {\n        const pair = minHeap.pop();\n        result.push(pair.value);\n        const last = pair.value[1];\n        if (last < nums2[len2 - 1]) {\n            const index = nums2.indexOf(last);\n            minHeap.insert(pair.value[0] + nums2[index + 1], [pair.value[0], nums2[index + 1]]);\n        }\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    const index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val = Number.MAX_SAFE_INTEGER;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    for (let i = 0; i < len1; i++) {\n        for (let j = 0; j < len2; j++) {\n            res.push([nums1[i], nums2[j]]);\n        }\n    }\n    res.sort((a, b) => {\n        return a[0] + a[1] - b[0] - b[1];\n    });\n    return res.slice(0, k);\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let n1: number = nums1.length;\n    let n2: number = nums2.length;\n    if (n1 == 0 || n2 == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < n1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i = 0; i < n1; i++) {\n            if (index[i] >= n2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n\n    for (let i = 0; i < len1; i++) {\n        for (let j = 0; j < len2; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n\n    result.sort((a, b) => {\n        return a[0] + a[1] - b[0] - b[1];\n    });\n\n    return result.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let t = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                t = i;\n                min_val = nums1[i] + nums2[index[i]];\n            }\n        }\n        if (t == -1) {\n            break;\n        }\n        result.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let i: number = 0;\n    let j: number = 0;\n    let heap_size: number = 0;\n    let temp: number[];\n    let sum: number;\n\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n\n    while (i < nums1.length && j < nums2.length && heap_size < k) {\n        sum = nums1[i] + nums2[j];\n        heap.push([sum, i, j]);\n        heap_size++;\n        j++;\n    }\n\n    while (heap_size > 0) {\n        temp = heap.shift();\n        result.push([nums1[temp[1]], nums2[temp[2]]]);\n        heap_size--;\n\n        if (temp[2] + 1 < nums2.length) {\n            sum = nums1[temp[1]] + nums2[temp[2] + 1];\n            heap.push([sum, temp[1], temp[2] + 1]);\n            heap_size++;\n        }\n\n        if (temp[2] === 0 && temp[1] + 1 < nums1.length) {\n            j = 0;\n            i = temp[1] + 1;\n            while (j < nums2.length && heap_size < k) {\n                sum = nums1[i] + nums2[j];\n                heap.push([sum, i, j]);\n                heap_size++;\n                j++;\n            }\n        }\n    }\n\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0) return res;\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) break;\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [];\n        temp.push(nums1[min_index]);\n        temp.push(nums2[index[min_index]]);\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) return result;\n    const index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) continue;\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) break;\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let t = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                t = i;\n                min_val = nums1[i] + nums2[index[i]];\n            }\n        }\n        if (t == -1) {\n            break;\n        }\n        result.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [];\n        temp.push(nums1[min_index]);\n        temp.push(nums2[index[min_index]]);\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return [];\n    }\n    let heap = new Heap<number[]>((a, b) => a[0] + a[1] - b[0] - b[1]);\n    for (let i = 0; i < nums1.length && i < k; i++) {\n        heap.push([nums1[i], nums2[0], 0]);\n    }\n    let result = [];\n    while (k-- > 0 && heap.size() > 0) {\n        let [n1, n2, index] = heap.pop();\n        result.push([n1, n2]);\n        if (index === nums2.length - 1) {\n            continue;\n        }\n        heap.push([n1, nums2[index + 1], index + 1]);\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    while (count < k && i < len1 && j < len2) {\n        let sum = nums1[i] + nums2[j];\n        if (sum < 0) {\n            i++;\n        } else if (sum > 0) {\n            j++;\n        } else {\n            res.push([nums1[i], nums2[j]]);\n            i++;\n            j++;\n            count++;\n        }\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return res;\n    }\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        res.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [];\n        temp.push(nums1[min_index]);\n        temp.push(nums2[index[min_index]]);\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[] = [];\n    let heapSize = 0;\n    let heapify = (i: number) => {\n        let left = 2 * i + 1;\n        let right = 2 * i + 2;\n        let smallest = i;\n        if (left < heapSize && heap[left] < heap[smallest]) {\n            smallest = left;\n        }\n        if (right < heapSize && heap[right] < heap[smallest]) {\n            smallest = right;\n        }\n        if (smallest !== i) {\n            let temp = heap[i];\n            heap[i] = heap[smallest];\n            heap[smallest] = temp;\n            heapify(smallest);\n        }\n    };\n    let buildHeap = () => {\n        heapSize = nums1.length;\n        for (let i = Math.floor(heapSize / 2); i >= 0; i--) {\n            heapify(i);\n        }\n    };\n    let extractMin = () => {\n        if (heapSize === 0) {\n            return -1;\n        }\n        let min = heap[0];\n        heap[0] = heap[heapSize - 1];\n        heapSize--;\n        heapify(0);\n        return min;\n    };\n    let insert = (val: number) => {\n        heapSize++;\n        let i = heapSize - 1;\n        heap[i] = val;\n        while (i !== 0 && heap[Math.floor((i - 1) / 2)] > heap[i]) {\n            let temp = heap[i];\n            heap[i] = heap[Math.floor((i - 1) / 2)];\n            heap[Math.floor((i - 1) / 2)] = temp;\n            i = Math.floor((i - 1) / 2);\n        }\n    };\n    let getKthElement = (k: number) => {\n        buildHeap();\n        let result = -1;\n        for (let i = 0; i < k; i++) {\n            result = extractMin();\n        }\n        return result;\n   ",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0) return res;\n    let pq = new PriorityQueue({ comparator: (a, b) => a[0] + a[1] - b[0] - b[1] });\n    for (let i = 0; i < len1; i++) {\n        for (let j = 0; j < len2; j++) {\n            pq.enqueue([nums1[i], nums2[j]]);\n        }\n    }\n    while (k-- > 0 && !pq.isEmpty()) {\n        res.push(pq.dequeue());\n    }\n    return res;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    const index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val = Number.MAX_SAFE_INTEGER;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0) return result;\n    let heap: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        heap.push([nums1[i] + nums2[0], i, 0]);\n    }\n    heap.sort((a, b) => a[0] - b[0]);\n    for (let i = 0; i < k && i < nums1.length * nums2.length; i++) {\n        let [sum, i1, i2] = heap.shift();\n        result.push([nums1[i1], nums2[i2]]);\n        if (i2 + 1 < nums2.length) {\n            heap.push([nums1[i1] + nums2[i2 + 1], i1, i2 + 1]);\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    let heap: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        heap.push([nums1[i] + nums2[0], i, 0]);\n    }\n    heap.sort((a, b) => a[0] - b[0]);\n    for (let i = 0; i < k && i < nums1.length * nums2.length; i++) {\n        let [sum, i1, i2] = heap.shift();\n        result.push([nums1[i1], nums2[i2]]);\n        if (i2 + 1 < nums2.length) {\n            heap.push([nums1[i1] + nums2[i2 + 1], i1, i2 + 1]);\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0) return res;\n    let len1 = nums1.length, len2 = nums2.length;\n    let index1: number[] = new Array(len1).fill(0);\n    while (k > 0 && res.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE, min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index1[i] >= len2) continue;\n            if (nums1[i] + nums2[index1[i]] < min_val) {\n                min_val = nums1[i] + nums2[index1[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index1[min_index]]]);\n        index1[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[] = [];\n    let heapSize: number = 0;\n    let heapCapacity: number = k;\n\n    function push(pair: number[]) {\n        if (heapSize < heapCapacity) {\n            heap[heapSize] = pair[0] + pair[1];\n            let current: number = heapSize;\n            let parent: number = Math.floor((current - 1) / 2);\n            while (current > 0 && heap[current] < heap[parent]) {\n                [heap[current], heap[parent]] = [heap[parent], heap[current]];\n                current = parent;\n                parent = Math.floor((current - 1) / 2);\n            }\n            heapSize++;\n        } else {\n            if (pair[0] + pair[1] < heap[0]) {\n                heap[0] = pair[0] + pair[1];\n                let current: number = 0;\n                let left: number = 1;\n                let right: number = 2;\n                let next: number = heap[left] < heap[right] ? left : right;\n                while (heap[current] > heap[next]) {\n                    [heap[current], heap[next]] = [heap[next], heap[current]];\n                    current = next;\n                    left = 2 * current + 1;\n                    right = 2 * current + 2;\n                    next = heap[left] < heap[right] ? left : right;\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            push([nums1[i], nums2[j]]);\n        }\n    }\n\n    for (let i = 0; i < heapSize; i++) {\n        result.push([Math.floor(heap[i] / 10), heap[i] % 10]);\n    }\n\n    return result;\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    const result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n    const queue = new PriorityQueue((a, b) => a[0] + a[1] < b[0] + b[1]);\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            queue.enqueue([nums1[i], nums2[j]]);\n        }\n    }\n    while (k > 0 && !queue.isEmpty()) {\n        result.push(queue.dequeue());\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0) {\n        return result;\n    }\n    let heap: number[][] = [];\n    for (let i = 0; i < len1; i++) {\n        heap.push([nums1[i] + nums2[0], i, 0]);\n    }\n    heap.sort((a, b) => a[0] - b[0]);\n    for (let i = 0; i < k && i < len1 * len2; i++) {\n        let top = heap.shift();\n        result.push([nums1[top[1]], nums2[top[2]]]);\n        if (top[2] < len2 - 1) {\n            heap.push([nums1[top[1]] + nums2[top[2] + 1], top[1], top[2] + 1]);\n            heap.sort((a, b) => a[0] - b[0]);\n        }\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_SAFE_INTEGER;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_SAFE_INTEGER;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    let i = 0;\n    let j = 0;\n    while (i < nums1.length && j < nums2.length && pairs.length < k) {\n        pairs.push([nums1[i], nums2[j]]);\n        if (j === nums2.length - 1) {\n            i++;\n            j = 0;\n        } else {\n            j++;\n        }\n    }\n    return pairs;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize: number = 0;\n\n    function push(pair: number[]) {\n        heap.push(pair);\n        let index: number = heapSize;\n        let parent: number = Math.floor((index - 1) / 2);\n        while (index > 0 && heap[index][0] + heap[index][1] < heap[parent][0] + heap[parent][1]) {\n            [heap[index], heap[parent]] = [heap[parent], heap[index]];\n            index = parent;\n            parent = Math.floor((index - 1) / 2);\n        }\n        heapSize++;\n    }\n\n    function pop(): number[] {\n        let result: number[] = heap[0];\n        heap[0] = heap[--heapSize];\n        heap.pop();\n        let index: number = 0;\n        let left: number = 1;\n        let right: number = 2;\n        let smallest: number = index;\n        if (left < heapSize && heap[left][0] + heap[left][1] < heap[smallest][0] + heap[smallest][1]) {\n            smallest = left;\n        }\n        if (right < heapSize && heap[right][0] + heap[right][1] < heap[smallest][0] + heap[smallest][1]) {\n            smallest = right;\n        }\n        while (smallest !== index) {\n            [heap[index], heap[smallest]] = [heap[smallest], heap[index]];\n            index = smallest;\n            left = 2 * index + 1;\n            right = 2 * index + 2;\n            if (left < heapSize && heap[left][0] + heap[left][1] < heap[smallest][0] + heap[smallest][1]) {\n                smallest = left;\n            }\n            if (right < heapSize && heap[right][0] + heap[right][1] < heap[smallest][0] + heap[smallest][1]) {\n                smallest = right;\n            }\n        }\n        return result;\n   ",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let t: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                t = i;\n                min_val = nums1[i] + nums2[index[i]];\n            }\n        }\n        if (t == -1) {\n            break;\n        }\n        let temp: number[] = [];\n        temp.push(nums1[t]);\n        temp.push(nums2[index[t]]);\n        result.push(temp);\n        index[t]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        res.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 * len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    for (let i = 0; i < k && i < len1 * len2; i++) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let j = 0; j < len1; j++) {\n            if (index[j] < len2 && nums1[j] + nums2[index[j]] < min_val) {\n                min_val = nums1[j] + nums2[index[j]];\n                min_index = j;\n            }\n        }\n        if (min_index !== -1) {\n            result.push([nums1[min_index], nums2[index[min_index]]]);\n            index[min_index]++;\n        }\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n    let heap: number[] = [];\n    let visited: boolean[][] = new Array(nums1.length).fill(false).map(() => new Array(nums2.length).fill(false));\n    heap.push(nums1[0] + nums2[0]);\n    visited[0][0] = true;\n    while (result.length < k && heap.length > 0) {\n        let min: number = heap.shift();\n        let i: number = 0;\n        let j: number = 0;\n        for (let m: number = 0; m < nums1.length; m++) {\n            for (let n: number = 0; n < nums2.length; n++) {\n                if (nums1[m] + nums2[n] === min) {\n                    i = m;\n                    j = n;\n                    break;\n                }\n            }\n        }\n        result.push([nums1[i], nums2[j]]);\n        if (i + 1 < nums1.length && !visited[i + 1][j]) {\n            heap.push(nums1[i + 1] + nums2[j]);\n            visited[i + 1][j] = true;\n        }\n        if (j + 1 < nums2.length && !visited[i][j + 1]) {\n            heap.push(nums1[i] + nums2[j + 1]);\n            visited[i][j + 1] = true;\n        }\n        heap.sort((a, b) => a - b);\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "  let result: number[][] = [];\n  let len1 = nums1.length;\n  let len2 = nums2.length;\n  if (len1 === 0 || len2 === 0) {\n    return result;\n  }\n  let index: number[] = [];\n  for (let i = 0; i < len1; i++) {\n    index.push(0);\n  }\n  while (k > 0) {\n    let min_val = Number.MAX_SAFE_INTEGER;\n    let min_index = -1;\n    for (let i = 0; i < len1; i++) {\n      if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n        min_val = nums1[i] + nums2[index[i]];\n        min_index = i;\n      }\n    }\n    if (min_index === -1) {\n      break;\n    }\n    result.push([nums1[min_index], nums2[index[min_index]]]);\n    index[min_index]++;\n    k--;\n  }\n  return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let i = 0;\n    let j = 0;\n    while (i < nums1.length && j < nums2.length) {\n        result.push([nums1[i], nums2[j]]);\n        if (i < nums1.length - 1) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n    return result.slice(0, k);\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let res: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            res.push([nums1[i], nums2[j]]);\n        }\n    }\n    res.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return res.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let index: number[] = [];\n    if (len1 * len2 === 0) {\n        return result;\n    }\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    for (let i = 0; i < k && i < len1 * len2; i++) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let j = 0; j < len1; j++) {\n            if (index[j] < len2 && nums1[j] + nums2[index[j]] < min_val) {\n                min_val = nums1[j] + nums2[index[j]];\n                min_index = j;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return res;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        res.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 * len2 === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    const index: number[] = new Array(len1).fill(0);\n    while (k > 0) {\n        let min_val = Number.MAX_SAFE_INTEGER;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    const queue: number[][] = [];\n    for (let i = 0; i < nums1.length && i < k; i++) {\n        queue.push([nums1[i], nums2[0], 0]);\n    }\n    while (k-- > 0 && queue.length) {\n        queue.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n        const [n1, n2, idx] = queue.shift();\n        result.push([n1, n2]);\n        if (idx === nums2.length - 1) {\n            continue;\n        }\n        queue.push([n1, nums2[idx + 1], idx + 1]);\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let res: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 * len2 === 0) return res;\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0 && res.length < len1 * len2) {\n        let cur_min: number = Number.MAX_VALUE;\n        let t: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < cur_min) {\n                cur_min = nums1[i] + nums2[index[i]];\n                t = i;\n            }\n        }\n        if (t === -1) break;\n        res.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n        k--;\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize: number = 0;\n\n    function push(pair: number[]) {\n        heap.push(pair);\n        let i = heapSize++;\n        while (i > 0) {\n            let parent = (i - 1) >> 1;\n            if (heap[parent][0] + heap[parent][1] <= heap[i][0] + heap[i][1]) {\n                break;\n            }\n            let tmp = heap[parent];\n            heap[parent] = heap[i];\n            heap[i] = tmp;\n            i = parent;\n        }\n    }\n\n    function pop(): number[] {\n        let ret = heap[0];\n        let i = 0;\n        while (i * 2 + 1 < heapSize) {\n            let left = i * 2 + 1;\n            let right = i * 2 + 2;\n            let smallerChild = (right < heapSize && heap[right][0] + heap[right][1] < heap[left][0] + heap[left][1]) ? right : left;\n            if (heap[smallerChild][0] + heap[smallerChild][1] >= heap[heapSize - 1][0] + heap[heapSize - 1][1]) {\n                break;\n            }\n            heap[i] = heap[smallerChild];\n            i = smallerChild;\n        }\n        heap[i] = heap[--heapSize];\n        heap.pop();\n        return ret;\n    }\n\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n\n    for (let i = 0; i < nums1.length && i < k; i++) {\n        push([nums1[i], nums2[0], 0]);\n    }\n\n    for (let i = 0; i < k && heapSize > 0; i++) {\n        let pair = pop();\n        result.push([pair[0], pair[1]]);\n        if (pair[2] === nums2.length - 1) {\n            continue;",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0) {\n        return result;\n    }\n    const queue: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        queue.push([nums1[i], nums2[0], 0]);\n    }\n    queue.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    while (k > 0 && queue.length > 0) {\n        const [n1, n2, index] = queue.shift();\n        result.push([n1, n2]);\n        if (index < nums2.length - 1) {\n            queue.push([n1, nums2[index + 1], index + 1]);\n        }\n        queue.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n        k--;\n    }\n    return result;\n}\n",
    "    let arr: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            arr.push([nums1[i], nums2[j]]);\n        }\n    }\n    arr.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return arr.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return res;\n    }\n    let pq: number[][] = [];\n    for (let i: number = 0; i < nums1.length; i++) {\n        pq.push([nums1[i], nums2[0], 0]);\n    }\n    while (k > 0 && pq.length > 0) {\n        let [n1, n2, i2]: number[] = pq.shift();\n        res.push([n1, n2]);\n        k--;\n        if (i2 + 1 < nums2.length) {\n            pq.push([n1, nums2[i2 + 1], i2 + 1]);\n        }\n        pq.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    }\n    return res;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[] = [];\n    let heapSize: number = 0;\n    let heapCapacity: number = k;\n    let first: number = 0;\n    let second: number = 0;\n    let firstLength: number = nums1.length;\n    let secondLength: number = nums2.length;\n    let i: number = 0;\n    let j: number = 0;\n    let temp: number = 0;\n\n    if (firstLength === 0 || secondLength === 0 || k === 0) {\n        return result;\n    }\n\n    for (i = 0; i < firstLength; i++) {\n        for (j = 0; j < secondLength; j++) {\n            if (heapSize < heapCapacity) {\n                heap.push(nums1[i] + nums2[j]);\n                heapSize++;\n                if (heapSize === heapCapacity) {\n                    heap = heapify(heap);\n                }\n            } else {\n                if (nums1[i] + nums2[j] < heap[0]) {\n                    heap[0] = nums1[i] + nums2[j];\n                    heap = heapify(heap);\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < heapSize; i++) {\n        temp = heap[0] - nums1[first];\n        for (j = 0; j < secondLength; j++) {\n            if (nums2[j] === temp) {\n                result.push([nums1[first], nums2[j]]);\n                break;\n            }\n        }\n        if (second + 1 < secondLength) {\n            second++;\n        } else {\n            first++;\n            second = 0;\n        }\n        heap[0] = nums1[first] + nums2[second];\n        heap = heapify(heap);\n    }\n\n    return result;\n}\n",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n",
    "    let res: number[][] = [];\n    let len1 = nums1.length, len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) return res;\n    for (let i = 0; i < len1; i++) {\n        for (let j = 0; j < len2; j++) {\n            res.push([nums1[i], nums2[j]]);\n        }\n    }\n    res.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return res.slice(0, k);\n}\n",
    "    let pairs: number[][] = [];\n    let i = 0;\n    let j = 0;\n    while (i < nums1.length && j < nums2.length && pairs.length < k) {\n        pairs.push([nums1[i], nums2[j]]);\n        if (j === nums2.length - 1) {\n            i++;\n            j = 0;\n        } else {\n            j++;\n        }\n    }\n    return pairs;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    let index: number[] = [];\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    for (let i = 0; i < k && i < len1 * len2; i++) {\n        let min_val = Number.MAX_VALUE;\n        let t = -1;\n        for (let j = 0; j < len1; j++) {\n            if (index[j] < len2 && nums1[j] + nums2[index[j]] < min_val) {\n                t = j;\n                min_val = nums1[j] + nums2[index[j]];\n            }\n        }\n        if (t === -1) {\n            break;\n        }\n        result.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n    }\n    return result;\n}\n",
    "  const pairs: number[][] = [];\n  const len1 = nums1.length;\n  const len2 = nums2.length;\n  for (let i = 0; i < len1; i++) {\n    for (let j = 0; j < len2; j++) {\n      pairs.push([nums1[i], nums2[j]]);\n    }\n  }\n  return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let res: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            res.push([nums1[i], nums2[j]]);\n        }\n    }\n    res.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return res.slice(0, k);\n}\n",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val: number = Number.MAX_VALUE;\n        let min_index: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp: number[] = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    const result: number[][] = [];\n    const len1 = nums1.length;\n    const len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    const index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let heapSize: number = 0;\n    let i: number = 0;\n    let j: number = 0;\n    let current: number[] = [nums1[i], nums2[j]];\n    let next: number[] = [nums1[i + 1], nums2[j]];\n    let nextNext: number[] = [nums1[i], nums2[j + 1]];\n    let temp: number[];\n    let temp2: number[];\n    let temp3: number[];\n    let temp4: number[];\n    let temp5: number[];\n    let temp6: number[];\n    let temp7: number[];\n    let temp8: number[];\n    let temp9: number[];\n    let temp10: number[];\n    let temp11: number[];\n    let temp12: number[];\n    let temp13: number[];\n    let temp14: number[];\n    let temp15: number[];\n    let temp16: number[];\n    let temp17: number[];\n    let temp18: number[];\n    let temp19: number[];\n    let temp20: number[];\n    let temp21: number[];\n    let temp22: number[];\n    let temp23: number[];\n    let temp24: number[];\n    let temp25: number[];\n    let temp26: number[];\n    let temp27: number[];\n    let temp28: number[];\n    let temp29: number[];\n    let temp30: number[];\n    let temp31: number[];\n    let temp32: number[];\n    let temp33: number[];\n    let temp34: number[];\n    let temp35: number[];\n    let temp36: number[];\n    let temp37: number[];\n    let temp38: number[];\n    let temp39: number[];\n    let temp40: number[];\n    let temp41: number[];\n    let temp42: number[];\n    let temp43: number[];\n    let temp44",
    "    const result: number[][] = [];\n    const queue: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            const sum = nums1[i] + nums2[j];\n            if (queue.length < k) {\n                queue.push([nums1[i], nums2[j]]);\n            } else {\n                if (sum < queue[0][0] + queue[0][1]) {\n                    queue.shift();\n                    queue.push([nums1[i], nums2[j]]);\n                }\n            }\n        }\n    }\n    return queue;\n}\n"
  ]
}