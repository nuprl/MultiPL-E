{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "ts",
  "prompt": "//Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunction k_smallest_pairs(nums1: number[], nums2: number[], k: number): number[][] {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = k_smallest_pairs;\n  assert.deepEqual(candidate([1, 3, 7], [2, 4, 6], 2),[[1, 2], [1, 4]]);\n  assert.deepEqual(candidate([1, 3, 7], [2, 4, 6], 1),[[1, 2]]);\n  assert.deepEqual(candidate([1, 3, 7], [2, 4, 6], 7),[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]);\n}\n\ntest();",
  "stop_tokens": [
    "\nfunction ",
    "\n/*",
    "\n//",
    "\nclass"
  ],
  "completions": [
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n",
    "    const result: number[][] = [];\n    const queue: number[][] = [];\n    const visited: boolean[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        visited[i] = [];\n        for (let j = 0; j < nums2.length; j++) {\n            visited[i][j] = false;\n        }\n    }\n    queue.push([0, 0]);\n    visited[0][0] = true;\n    while (queue.length > 0 && result.length < k) {\n        const [i, j] = queue.shift()!;\n        result.push([nums1[i], nums2[j]]);\n        if (i + 1 < nums1.length && !visited[i + 1][j]) {\n            queue.push([i + 1, j]);\n            visited[i + 1][j] = true;\n        }\n        if (j + 1 < nums2.length && !visited[i][j + 1]) {\n            queue.push([i, j + 1]);\n            visited[i][j + 1] = true;\n        }\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let heap: number[][] = [];\n    let i: number = 0;\n    let j: number = 0;\n    let n: number = nums1.length;\n    let m: number = nums2.length;\n    if (n == 0 || m == 0 || k == 0) {\n        return result;\n    }\n    heap.push([nums1[0] + nums2[0], 0, 0]);\n    while (k > 0 && heap.length > 0) {\n        let [sum, i, j] = heap.shift();\n        result.push([nums1[i], nums2[j]]);\n        if (i + 1 < n && j + 1 < m) {\n            heap.push([nums1[i + 1] + nums2[j], i + 1, j]);\n            heap.push([nums1[i] + nums2[j + 1], i, j + 1]);\n        } else if (i + 1 < n) {\n            heap.push([nums1[i + 1] + nums2[j], i + 1, j]);\n        } else if (j + 1 < m) {\n            heap.push([nums1[i] + nums2[j + 1], i, j + 1]);\n        }\n        heap.sort((a, b) => a[0] - b[0]);\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        let temp = [nums1[min_index], nums2[index[min_index]]];\n        result.push(temp);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let arr = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            arr.push([nums1[i], nums2[j]]);\n        }\n    }\n    arr.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return arr.slice(0, k);\n}\n",
    "  const pairs: number[][] = [];\n  for (let i = 0; i < nums1.length; i++) {\n    for (let j = 0; j < nums2.length; j++) {\n      pairs.push([nums1[i], nums2[j]]);\n    }\n  }\n  return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "  const pairs: number[][] = [];\n  for (let i = 0; i < nums1.length; i++) {\n    for (let j = 0; j < nums2.length; j++) {\n      pairs.push([nums1[i], nums2[j]]);\n    }\n  }\n  pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n  return pairs.slice(0, k);\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index == -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            result.push([nums1[i], nums2[j]]);\n        }\n    }\n    result.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return result.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const pairs = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    const pairs: number[][] = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    return pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]).slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0 && result.length < len1 * len2) {\n        let min_val = Number.MAX_VALUE;\n        let tmp: number[] = [];\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                tmp = [i, index[i]];\n            }\n        }\n        result.push([nums1[tmp[0]], nums2[tmp[1]]]);\n        index[tmp[0]]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index.push(0);\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let min_index = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] < len2 && nums1[i] + nums2[index[i]] < min_val) {\n                min_val = nums1[i] + nums2[index[i]];\n                min_index = i;\n            }\n        }\n        if (min_index === -1) {\n            break;\n        }\n        result.push([nums1[min_index], nums2[index[min_index]]]);\n        index[min_index]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    let len1: number = nums1.length;\n    let len2: number = nums2.length;\n    if (len1 === 0 || len2 === 0 || k === 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i: number = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0) {\n        let min_val: number = Number.MAX_VALUE;\n        let t: number = -1;\n        for (let i: number = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                t = i;\n                min_val = nums1[i] + nums2[index[i]];\n            }\n        }\n        if (t === -1) {\n            break;\n        }\n        result.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n        k--;\n    }\n    return result;\n}\n",
    "    let result: number[][] = [];\n    if (nums1.length === 0 || nums2.length === 0 || k === 0) {\n        return result;\n    }\n    let pq: MinHeap<number> = new MinHeap<number>();\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pq.push([nums1[i], nums2[j]]);\n        }\n    }\n    for (let i = 0; i < k; i++) {\n        if (pq.size() === 0) {\n            break;\n        }\n        result.push(pq.pop());\n    }\n    return result;\n}\n",
    "    let pairs = [];\n    for (let i = 0; i < nums1.length; i++) {\n        for (let j = 0; j < nums2.length; j++) {\n            pairs.push([nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort((a, b) => a[0] + a[1] - b[0] - b[1]);\n    return pairs.slice(0, k);\n}\n\nconsole.log(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3));\nconsole.log(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2));\nconsole.log(k_smallest_pairs([1, 2], [3], 3));",
    "    let result: number[][] = [];\n    let len1 = nums1.length;\n    let len2 = nums2.length;\n    if (len1 == 0 || len2 == 0 || k == 0) {\n        return result;\n    }\n    let index: number[] = [];\n    for (let i = 0; i < len1; i++) {\n        index[i] = 0;\n    }\n    while (k > 0) {\n        let min_val = Number.MAX_VALUE;\n        let t = -1;\n        for (let i = 0; i < len1; i++) {\n            if (index[i] >= len2) {\n                continue;\n            }\n            if (nums1[i] + nums2[index[i]] < min_val) {\n                t = i;\n                min_val = nums1[i] + nums2[index[i]];\n            }\n        }\n        if (t == -1) {\n            break;\n        }\n        result.push([nums1[t], nums2[index[t]]]);\n        index[t]++;\n        k--;\n    }\n    return result;\n}\n"
  ]
}