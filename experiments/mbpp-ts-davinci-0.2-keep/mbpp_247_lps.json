{
  "name": "mbpp_247_lps",
  "language": "ts",
  "prompt": "//Write a function to find the length of the longest palindromic subsequence in the given string.\nfunction lps(str: string): number {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py",
  "prompt_terminology": "verbatim",
  "tests": "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = lps;\n  assert.deepEqual(candidate(\"TENS FOR TENS\"),5);\n  assert.deepEqual(candidate(\"CARDIO FOR CARDS\"),7);\n  assert.deepEqual(candidate(\"PART OF THE JOURNEY IS PART\"),9);\n}\n\ntest();",
  "stop_tokens": [
    "\nfunction ",
    "\n/*",
    "\n//",
    "\nclass"
  ],
  "completions": [
    "  const n = str.length;\n  const dp = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    dp[i][i] = 1;\n  }\n\n  for (let l = 2; l <= n; l++) {\n    for (let i = 0; i < n - l + 1; i++) {\n      const j = i + l - 1;\n      if (str[i] === str[j] && l === 2) {\n        dp[i][j] = 2;\n      } else if (str[i] === str[j]) {\n        dp[i][j] = dp[i + 1][j - 1] + 2;\n      } else {\n        dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n  return dp[0][n - 1];\n}\n",
    "  const n = str.length;\n  const dp = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n\n  for (let startIndex = n - 1; startIndex >= 0; startIndex--) {\n    for (let endIndex = startIndex + 1; endIndex < n; endIndex++) {\n      if (str[startIndex] === str[endIndex]) {\n        dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];\n      } else {\n        dp[startIndex][endIndex] = Math.max(\n          dp[startIndex + 1][endIndex],\n          dp[startIndex][endIndex - 1]\n        );\n      }\n    }\n  }\n\n  return dp[0][n - 1];\n}\n\nconsole.log(lps(\"abdbca\"));\nconsole.log(lps(\"cddpd\"));\nconsole.log(lps(\"pqr\"));\n",
    "    const n = str.length;\n    const dp = Array.from(Array(n), () => Array(n).fill(0));\n\n    for (let i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n\n    for (let startIndex = n - 1; startIndex >= 0; startIndex--) {\n        for (let endIndex = startIndex + 1; endIndex < n; endIndex++) {\n            if (str[startIndex] === str[endIndex]) {\n                dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];\n            } else {\n                dp[startIndex][endIndex] = Math.max(\n                    dp[startIndex + 1][endIndex],\n                    dp[startIndex][endIndex - 1]\n                );\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n",
    "    const n = str.length;\n    const dp: number[][] = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n        dp[i][i] = 1;\n    }\n    for (let i = 0; i < n - 1; i++) {\n        if (str[i] === str[i + 1]) {\n            dp[i][i + 1] = 2;\n        } else {\n            dp[i][i + 1] = 1;\n        }\n    }\n    for (let len = 3; len <= n; len++) {\n        for (let i = 0; i < n - len + 1; i++) {\n            const j = i + len - 1;\n            if (str[i] === str[j]) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n\nconsole.log(lps('abdbca'));\nconsole.log(lps('cddpd'));\nconsole.log(lps('pqr'));\n",
    "    const n = str.length;\n    const dp = Array(n).fill(null).map(() => Array(n).fill(0));\n\n    for (let i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n\n    for (let startIndex = n - 1; startIndex >= 0; startIndex--) {\n        for (let endIndex = startIndex + 1; endIndex < n; endIndex++) {\n            if (str[startIndex] === str[endIndex]) {\n                dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];\n            } else {\n                dp[startIndex][endIndex] = Math.max(\n                    dp[startIndex + 1][endIndex],\n                    dp[startIndex][endIndex - 1]\n                );\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n\nconsole.log(lps(\"abdbca\"));\nconsole.log(lps(\"cddpd\"));\nconsole.log(lps(\"pqr\"));\n",
    "  const n = str.length;\n  const dp = Array(n)\n    .fill(null)\n    .map(() => Array(n).fill(0));\n\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n\n  for (let startIndex = n - 1; startIndex >= 0; startIndex--) {\n    for (let endIndex = startIndex + 1; endIndex < n; endIndex++) {\n      if (str[startIndex] === str[endIndex]) {\n        dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];\n      } else {\n        dp[startIndex][endIndex] = Math.max(\n          dp[startIndex + 1][endIndex],\n          dp[startIndex][endIndex - 1]\n        );\n      }\n    }\n  }\n\n  return dp[0][n - 1];\n}\n",
    "  let n = str.length;\n  let i, j, cl;\n  let L = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n\n  // Strings of length 1 are palindrome of lentgh 1\n  for (i = 0; i < n; i++) L[i][i] = 1;\n\n  // Build the table. Note that the lower diagonal values of table are\n  // useless and not filled in the process. The values are filled in a\n  // manner similar to Matrix Chain Multiplication DP solution (See\n  // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/\n  // cl is length of substring\n  for (cl = 2; cl <= n; cl++) {\n    for (i = 0; i < n - cl + 1; i++) {\n      j = i + cl - 1;\n      if (str[i] == str[j] && cl == 2)\n        L[i][j] = 2;\n      else if (str[i] == str[j])\n        L[i][j] = L[i + 1][j - 1] + 2;\n      else\n        L[i][j] = Math.max(L[i][j - 1], L[i + 1][j]);\n    }\n  }\n\n  return L[0][n - 1];\n}\n",
    "  const n = str.length;\n  const dp = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n\n  for (let startIndex = n - 1; startIndex >= 0; startIndex--) {\n    for (let endIndex = startIndex + 1; endIndex < n; endIndex++) {\n      if (str[startIndex] === str[endIndex]) {\n        dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];\n      } else {\n        dp[startIndex][endIndex] = Math.max(\n          dp[startIndex + 1][endIndex],\n          dp[startIndex][endIndex - 1]\n        );\n      }\n    }\n  }\n\n  return dp[0][n - 1];\n}\n",
    "  let n = str.length;\n  let i, j, cl;\n  let L = new Array(n);\n  for (i = 0; i < n; i++) {\n    L[i] = new Array(n);\n    L[i][i] = 1;\n  }\n  for (cl = 2; cl <= n; cl++) {\n    for (i = 0; i < n - cl + 1; i++) {\n      j = i + cl - 1;\n      if (str[i] == str[j] && cl == 2) L[i][j] = 2;\n      else if (str[i] == str[j]) L[i][j] = L[i + 1][j - 1] + 2;\n      else L[i][j] = Math.max(L[i][j - 1], L[i + 1][j]);\n    }\n  }\n  return L[0][n - 1];\n}\n",
    "  const n = str.length;\n  const dp = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n\n  for (let startIndex = n - 1; startIndex >= 0; startIndex--) {\n    for (let endIndex = startIndex + 1; endIndex < n; endIndex++) {\n      if (str[startIndex] === str[endIndex]) {\n        dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];\n      } else {\n        dp[startIndex][endIndex] = Math.max(\n          dp[startIndex + 1][endIndex],\n          dp[startIndex][endIndex - 1]\n        );\n      }\n    }\n  }\n  return dp[0][n - 1];\n}\n\nconsole.log(lps(\"abdbca\"));\nconsole.log(lps(\"cddpd\"));\nconsole.log(lps(\"pqr\"));\n",
    "  const n = str.length;\n  const dp = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n\n  for (let startIndex = n - 1; startIndex >= 0; startIndex--) {\n    for (let endIndex = startIndex + 1; endIndex < n; endIndex++) {\n      if (str[startIndex] === str[endIndex]) {\n        dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];\n      } else {\n        dp[startIndex][endIndex] = Math.max(\n          dp[startIndex + 1][endIndex],\n          dp[startIndex][endIndex - 1]\n        );\n      }\n    }\n  }\n  return dp[0][n - 1];\n}\n\nconsole.log(lps(\"abdbca\"));\nconsole.log(lps(\"cddpd\"));\nconsole.log(lps(\"pqr\"));\n",
    "    const n = str.length;\n    const dp: number[][] = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n        for (let j = 0; j < n; j++) {\n            dp[i][j] = 0;\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n\n    for (let cl = 2; cl <= n; cl++) {\n        for (let i = 0; i < n - cl + 1; i++) {\n            const j = i + cl - 1;\n            if (str[i] === str[j] && cl === 2) {\n                dp[i][j] = 2;\n            } else if (str[i] === str[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n\nconsole.log(lps('abdbca'));\nconsole.log(lps('cddpd'));\nconsole.log(lps('pqr'));\n",
    "  let n = str.length;\n  let i, j, cl;\n  let L = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n\n  // Strings of length 1 are palindrome of length 1\n  for (i = 0; i < n; i++) L[i][i] = 1;\n\n  // Build the table. Note that the lower\n  // diagonal values of table are\n  // useless and not filled in the process.\n  // The values are filled in a manner similar\n  //  to Matrix Chain Multiplication DP solution (See\n  // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/\n  // cl is length of substring\n  for (cl = 2; cl <= n; cl++) {\n    for (i = 0; i < n - cl + 1; i++) {\n      j = i + cl - 1;\n      if (str[i] == str[j] && cl == 2) L[i][j] = 2;\n      else if (str[i] == str[j]) L[i][j] = L[i + 1][j - 1] + 2;\n      else L[i][j] = Math.max(L[i][j - 1], L[i + 1][j]);\n    }\n  }\n\n  return L[0][n - 1];\n}\n",
    "    const n = str.length;\n    const dp = Array.from(Array(n), () => Array(n).fill(0));\n    for (let i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for (let start = n - 1; start >= 0; start--) {\n        for (let end = start + 1; end < n; end++) {\n            if (str[start] === str[end]) {\n                dp[start][end] = 2 + dp[start + 1][end - 1];\n            } else {\n                dp[start][end] = Math.max(dp[start + 1][end], dp[start][end - 1]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n",
    "  const n = str.length;\n  const dp = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n\n  for (let startIndex = n - 1; startIndex >= 0; startIndex--) {\n    for (let endIndex = startIndex + 1; endIndex < n; endIndex++) {\n      if (str[startIndex] === str[endIndex]) {\n        dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];\n      } else {\n        dp[startIndex][endIndex] = Math.max(\n          dp[startIndex + 1][endIndex],\n          dp[startIndex][endIndex - 1]\n        );\n      }\n    }\n  }\n\n  return dp[0][n - 1];\n}\n",
    "  const n = str.length;\n  const dp: number[][] = [];\n  for (let i = 0; i < n; i++) {\n    dp[i] = [];\n    for (let j = 0; j < n; j++) {\n      dp[i][j] = 0;\n    }\n  }\n\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n\n  for (let len = 2; len <= n; len++) {\n    for (let i = 0; i < n - len + 1; i++) {\n      const j = i + len - 1;\n      if (str[i] === str[j] && len === 2) {\n        dp[i][j] = 2;\n      } else if (str[i] === str[j]) {\n        dp[i][j] = dp[i + 1][j - 1] + 2;\n      } else {\n        dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n\n  return dp[0][n - 1];\n}\n\nconsole.log(lps(\"agbdba\"));\n",
    "  const n = str.length;\n  const dp = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n\n  for (let startIndex = n - 1; startIndex >= 0; startIndex--) {\n    for (let endIndex = startIndex + 1; endIndex < n; endIndex++) {\n      if (str[startIndex] === str[endIndex]) {\n        dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];\n      } else {\n        dp[startIndex][endIndex] = Math.max(\n          dp[startIndex + 1][endIndex],\n          dp[startIndex][endIndex - 1]\n        );\n      }\n    }\n  }\n\n  return dp[0][n - 1];\n}\n\nconsole.log(lps(\"abdbca\"));\nconsole.log(lps(\"cddpd\"));\nconsole.log(lps(\"pqr\"));\n",
    "  const n = str.length;\n  const dp = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n\n  for (let startIndex = n - 1; startIndex >= 0; startIndex--) {\n    for (let endIndex = startIndex + 1; endIndex < n; endIndex++) {\n      if (str[startIndex] === str[endIndex]) {\n        dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];\n      } else {\n        dp[startIndex][endIndex] = Math.max(\n          dp[startIndex + 1][endIndex],\n          dp[startIndex][endIndex - 1]\n        );\n      }\n    }\n  }\n  return dp[0][n - 1];\n}\n\nconsole.log(lps(\"abdbca\"));\nconsole.log(lps(\"cddpd\"));\nconsole.log(lps(\"pqr\"));\n",
    "  const n = str.length;\n  const dp = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1;\n  }\n\n  for (let startIndex = n - 1; startIndex >= 0; startIndex--) {\n    for (let endIndex = startIndex + 1; endIndex < n; endIndex++) {\n      if (str[startIndex] === str[endIndex]) {\n        dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];\n      } else {\n        dp[startIndex][endIndex] = Math.max(\n          dp[startIndex + 1][endIndex],\n          dp[startIndex][endIndex - 1]\n        );\n      }\n    }\n  }\n\n  return dp[0][n - 1];\n}\n\nconsole.log(lps(\"abdbca\"));\nconsole.log(lps(\"cddpd\"));\nconsole.log(lps(\"pqr\"));",
    "    const n = str.length;\n    const dp = Array(n).fill(null).map(() => Array(n).fill(0));\n\n    for (let i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n\n    for (let startIndex = n - 1; startIndex >= 0; startIndex--) {\n        for (let endIndex = startIndex + 1; endIndex < n; endIndex++) {\n            if (str[startIndex] === str[endIndex]) {\n                dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];\n            } else {\n                dp[startIndex][endIndex] = Math.max(dp[startIndex + 1][endIndex], dp[startIndex][endIndex - 1]);\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n"
  ]
}