{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "ts",
  "prompt": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost: number[][]): number {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "verbatim",
  "tests": "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
  "stop_tokens": [
    "\nfunction ",
    "\n/*",
    "\n//",
    "\nclass"
  ],
  "completions": [
    "    const n = cost.length;\n    const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < n; i++) {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let i = 1; i < n; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "  const n = cost.length;\n  const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for (let i = 1; i < n; i++) {\n    dp[0][i] = dp[0][i - 1] + cost[0][i];\n    dp[i][0] = dp[i - 1][0] + cost[i][0];\n  }\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n    }\n  }\n  return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "  const n = cost.length;\n  const dp: number[][] = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for (let i = 1; i < n; i++) {\n    dp[0][i] = dp[0][i - 1] + cost[0][i];\n    dp[i][0] = dp[i - 1][0] + cost[i][0];\n  }\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n    }\n  }\n  return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for (let i = 0; i < row; i++) {\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < row; i++) {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let i = 1; i < col; i++) {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n    }\n    for (let i = 1; i < row; i++) {\n        for (let j = 1; j < col; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[row - 1][col - 1] / (row + col - 1);\n}\n",
    "    let n = cost.length;\n    let dp: number[][] = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < n; i++) {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let i = 1; i < n; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "    const n = cost.length;\n    const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < n; i++) {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let i = 1; i < n; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "  const n = cost.length;\n  const dp = Array(n)\n    .fill(0)\n    .map(() => Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for (let i = 1; i < n; i++) {\n    dp[0][i] = dp[0][i - 1] + cost[0][i];\n    dp[i][0] = dp[i - 1][0] + cost[i][0];\n  }\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n    }\n  }\n  return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "  const n = cost.length;\n  const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for (let i = 1; i < n; i++) {\n    dp[0][i] = dp[0][i - 1] + cost[0][i];\n    dp[i][0] = dp[i - 1][0] + cost[i][0];\n  }\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n    }\n  }\n  return dp[n - 1][n - 1] / (2 * n - 1);\n}\n\nconsole.log(maxAverageOfPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]]));\n",
    "    let n = cost.length;\n    let m = cost[0].length;\n    let dp: number[][] = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n        for (let j = 0; j < m; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < n; i++) {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let j = 1; j < m; j++) {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for (let i = 1; i < n; i++) {\n        for (let j = 1; j < m; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][m - 1] / (n + m - 1);\n}\n",
    "    const n = cost.length;\n    const m = cost[0].length;\n    const dp: number[][] = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n    }\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < n; i++) {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let j = 1; j < m; j++) {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for (let i = 1; i < n; i++) {\n        for (let j = 1; j < m; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][m - 1] / (n + m - 1);\n}\n",
    "  const n = cost.length;\n  const m = cost[0].length;\n  const dp = new Array(n);\n  for (let i = 0; i < n; i++) {\n    dp[i] = new Array(m);\n    dp[i][0] = cost[i][0];\n  }\n  for (let i = 0; i < m; i++) {\n    dp[0][i] = cost[0][i];\n  }\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < m; j++) {\n      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n    }\n  }\n  return dp[n - 1][m - 1] / (n + m - 1);\n}\n",
    "    const n = cost.length;\n    const dp: number[][] = Array.from({ length: n }, () => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < n; i++) {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let i = 1; i < n; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "    const n = cost.length;\n    const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < n; i++) {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let i = 1; i < n; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "    let n = cost.length;\n    let dp: number[][] = new Array(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = new Array(n);\n        for (let j = 0; j < n; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < n; i++) {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let i = 1; i < n; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "    const n = cost.length;\n    const dp: number[][] = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < n; i++) {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let i = 1; i < n; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "  const n = cost.length;\n  const dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for (let i = 1; i < n; i++) {\n    dp[i][0] = dp[i - 1][0] + cost[i][0];\n    dp[0][i] = dp[0][i - 1] + cost[0][i];\n  }\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n    }\n  }\n  return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "    const n = cost.length;\n    const dp: number[][] = [];\n    for (let i = 0; i < n; i++) {\n        dp[i] = [];\n        for (let j = 0; j < n; j++) {\n            dp[i][j] = 0;\n        }\n    }\n\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < n; i++) {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n\n    for (let i = 1; i < n; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "    let dp: number[][] = [];\n    for (let i = 0; i < cost.length; i++) {\n        dp[i] = [];\n        for (let j = 0; j < cost[i].length; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < cost.length; i++) {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let i = 1; i < cost[0].length; i++) {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n    }\n    for (let i = 1; i < cost.length; i++) {\n        for (let j = 1; j < cost[i].length; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[cost.length - 1][cost[0].length - 1] / (cost.length + cost[0].length - 1);\n}\n",
    "    const n = cost.length;\n    const dp: number[][] = Array(n).fill(0).map(() => Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < n; i++) {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let i = 1; i < n; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n",
    "    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp: number[][] = [];\n    for (let i = 0; i < rows; i++) {\n        dp[i] = [];\n        for (let j = 0; j < cols; j++) {\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for (let i = 1; i < rows; i++) {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for (let i = 1; i < cols; i++) {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n    }\n    for (let i = 1; i < rows; i++) {\n        for (let j = 1; j < cols; j++) {\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[rows - 1][cols - 1] / (rows + cols - 1);\n}\n"
  ]
}