name: HumanEval_61_correct_bracketing
language: rkt
prompt: "#lang racket\n\n;; brackets is a string of \"(\" and \")\".\n;; return True\
  \ if every opening bracket has a corresponding closing bracket.\n;; >>> (correct_bracketing\
  \ \"(\")\n;; #f\n;; >>> (correct_bracketing \"()\")\n;; #t\n;; >>> (correct_bracketing\
  \ \"(()())\")\n;; #t\n;; >>> (correct_bracketing \")(()\")\n;; #f\n(define (correct_bracketing\
  \ brackets)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n\
  \    (check-equal? (candidate \"()\") #t)\n    (check-equal? (candidate \"(()())\"\
  ) #t)\n    (check-equal? (candidate \"()()(()())()\") #t)\n    (check-equal? (candidate\
  \ \"()()((()()())())(()()(()))\") #t)\n    (check-equal? (candidate \"((()())))\"\
  ) #f)\n    (check-equal? (candidate \")(()\") #f)\n    (check-equal? (candidate\
  \ \"(\") #f)\n    (check-equal? (candidate \"((((\") #f)\n    (check-equal? (candidate\
  \ \")\") #f)\n    (check-equal? (candidate \"(()\") #f)\n    (check-equal? (candidate\
  \ \"()()(()())())(()\") #f)\n    (check-equal? (candidate \"()()(()())()))()\")\
  \ #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? brackets) #t]\n    [(equal? (first brackets)\
    \ \")\") #f]\n    [else (correct_bracketing (rest brackets))]))\n", "  (define\
    \ (helper brackets count)\n    (cond\n      [(empty? brackets) (= count 0)]\n\
    \      [(char=? (first brackets) #\\() (helper (rest brackets) (+ count 1))]\n\
    \      [(char=? (first brackets) #\\)) (and (not (zero? count)) (helper (rest\
    \ brackets) (- count 1)))]))\n  (helper brackets 0))\n", "  (define (helper brackets\
    \ count)\n    (cond\n      [(empty? brackets) (= count 0)]\n      [(char=? (first\
    \ brackets) #\\() (helper (rest brackets) (+ count 1))]\n      [(char=? (first\
    \ brackets) #\\)) (and (not (= count 0)) (helper (rest brackets) (- count 1)))]))\n\
    \  (helper brackets 0))\n", "  (define (helper brackets count)\n    (cond\n  \
    \    [(empty? brackets) (= count 0)]\n      [(char=? (first brackets) #\\() (helper\
    \ (rest brackets) (+ count 1))]\n      [(char=? (first brackets) #\\)) (and (not\
    \ (= count 0)) (helper (rest brackets) (- count 1)))]))\n  (helper brackets 0))\n",
  "  (cond\n    [(empty? brackets) #t]\n    [(equal? (first brackets) \")\") #f]\n\
    \    [else (correct_bracketing (rest brackets))]))\n", "  (define (helper brackets\
    \ count)\n    (cond ((string=? brackets \"\") (= count 0))\n          ((string=?\
    \ (substring brackets 0 1) \"(\") (helper (substring brackets 1) (+ count 1)))\n\
    \          ((string=? (substring brackets 0 1) \")\") (and (> count 0) (helper\
    \ (substring brackets 1) (- count 1))))))\n  (helper brackets 0))\n", "  (define\
    \ (helper brackets count)\n    (cond\n      [(empty? brackets) (= count 0)]\n\
    \      [(char=? (first brackets) #\\() (helper (rest brackets) (+ count 1))]\n\
    \      [(char=? (first brackets) #\\)) (and (not (= count 0)) (helper (rest brackets)\
    \ (- count 1)))]))\n  (helper brackets 0))\n", "  (let loop ([brackets brackets]\
    \ [open 0])\n    (cond [(empty? brackets) (= open 0)]\n          [(char=? (first\
    \ brackets) #\\()\n           (loop (rest brackets) (+ open 1))]\n          [(char=?\
    \ (first brackets) #\\))\n           (and (positive? open)\n                (loop\
    \ (rest brackets) (- open 1)))]\n          [else (error \"invalid character in\
    \ brackets\")])))\n", "  (define (helper brackets count)\n    (cond\n      [(empty?\
    \ brackets) (= count 0)]\n      [(char=? (first brackets) #\\() (helper (rest\
    \ brackets) (+ count 1))]\n      [(char=? (first brackets) #\\)) (and (not (=\
    \ count 0)) (helper (rest brackets) (- count 1)))]))\n  (helper brackets 0))\n",
  "  (define (helper brackets count)\n    (cond\n      [(empty? brackets) (= count\
    \ 0)]\n      [(char=? (first brackets) #\\() (helper (rest brackets) (+ count\
    \ 1))]\n      [(char=? (first brackets) #\\)) (and (not (= count 0)) (helper (rest\
    \ brackets) (- count 1)))]))\n  (helper brackets 0))\n", "  (define (helper brackets\
    \ count)\n    (cond\n      [(empty? brackets) (= count 0)]\n      [(char=? (first\
    \ brackets) #\\() (helper (rest brackets) (+ count 1))]\n      [(char=? (first\
    \ brackets) #\\)) (and (not (= count 0)) (helper (rest brackets) (- count 1)))]))\n\
    \  (helper brackets 0))\n", "  (define (helper brackets count)\n    (cond\n  \
    \    [(empty? brackets) (= count 0)]\n      [(char=? (first brackets) #\\() (helper\
    \ (rest brackets) (+ count 1))]\n      [(char=? (first brackets) #\\)) (and (not\
    \ (= count 0)) (helper (rest brackets) (- count 1)))]))\n  (helper brackets 0))\n",
  "  (define (helper brackets count)\n    (cond\n      [(empty? brackets) (= count\
    \ 0)]\n      [(char=? (first brackets) #\\() (helper (rest brackets) (+ count\
    \ 1))]\n      [(char=? (first brackets) #\\)) (and (not (= count 0)) (helper (rest\
    \ brackets) (- count 1)))]))\n  (helper brackets 0))\n", "  (define (helper brackets\
    \ count)\n    (cond\n      [(empty? brackets) (zero? count)]\n      [(char=? (first\
    \ brackets) #\\()\n       (helper (rest brackets) (+ count 1))]\n      [(char=?\
    \ (first brackets) #\\))\n       (and (positive? count)\n            (helper (rest\
    \ brackets) (- count 1)))]))\n  (helper brackets 0))\n", "  (cond\n    [(empty?\
    \ brackets) #t]\n    [(string=? (first brackets) \"(\")\n     (if (string=? (last\
    \ brackets) \")\")\n         (correct_bracketing (substring brackets 1 (- (string-length\
    \ brackets) 1)))\n         #f)]\n    [else #f]))\n", "  (cond\n    [(empty? brackets)\
    \ #t]\n    [(equal? (first brackets) \")\") #f]\n    [else (correct_bracketing\
    \ (rest brackets))]))\n", "  (cond\n    [(empty? brackets) #t]\n    [(equal? (first\
    \ brackets) \")\") #f]\n    [else (correct_bracketing (rest brackets))]))\n",
  "  (define (helper brackets count)\n    (cond\n      [(empty? brackets) (= count\
    \ 0)]\n      [(char=? (first brackets) #\\() (helper (rest brackets) (+ count\
    \ 1))]\n      [(char=? (first brackets) #\\)) (and (not (= count 0)) (helper (rest\
    \ brackets) (- count 1)))]))\n  (helper brackets 0))\n", "  (define (helper brackets\
    \ count)\n    (cond\n      [(empty? brackets) (= count 0)]\n      [(char=? (first\
    \ brackets) #\\() (helper (rest brackets) (+ count 1))]\n      [(char=? (first\
    \ brackets) #\\)) (and (not (zero? count)) (helper (rest brackets) (- count 1)))]))\n\
    \  (helper brackets 0))\n", "  (cond\n    [(empty? brackets) #t]\n    [(equal?\
    \ (first brackets) \")\") #f]\n    [else (correct_bracketing (rest brackets))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
